begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Liveness for SSA trees.    Copyright (C) 2003, 2004, 2005 Free Software Foundation, Inc.    Contributed by Andrew MacLeod<amacleod@redhat.com>  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_include
include|#
directive|include
file|"bitmap.h"
end_include

begin_include
include|#
directive|include
file|"tree-flow.h"
end_include

begin_include
include|#
directive|include
file|"tree-gimple.h"
end_include

begin_include
include|#
directive|include
file|"tree-inline.h"
end_include

begin_include
include|#
directive|include
file|"varray.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"hashtab.h"
end_include

begin_include
include|#
directive|include
file|"tree-dump.h"
end_include

begin_include
include|#
directive|include
file|"tree-ssa-live.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"vecprim.h"
end_include

begin_function_decl
specifier|static
name|void
name|live_worklist
parameter_list|(
name|tree_live_info_p
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree_live_info_p
name|new_tree_live_info
parameter_list|(
name|var_map
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|set_if_valid
parameter_list|(
name|var_map
parameter_list|,
name|bitmap
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|add_livein_if_notdef
parameter_list|(
name|tree_live_info_p
parameter_list|,
name|bitmap
parameter_list|,
name|tree
parameter_list|,
name|basic_block
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|register_ssa_partition
parameter_list|(
name|var_map
parameter_list|,
name|tree
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|add_conflicts_if_valid
parameter_list|(
name|tpa_p
parameter_list|,
name|conflict_graph
parameter_list|,
name|var_map
parameter_list|,
name|bitmap
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|partition_pair_p
name|find_partition_pair
parameter_list|(
name|coalesce_list_p
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* This is where the mapping from SSA version number to real storage variable    is tracked.       All SSA versions of the same variable may not ultimately be mapped back to    the same real variable. In that instance, we need to detect the live    range overlap, and give one of the variable new storage. The vector    'partition_to_var' tracks which partition maps to which variable.     Given a VAR, it is sometimes desirable to know which partition that VAR    represents.  There is an additional field in the variable annotation to    track that information.  */
end_comment

begin_comment
comment|/* Create a variable partition map of SIZE, initialize and return it.  */
end_comment

begin_function
name|var_map
name|init_var_map
parameter_list|(
name|int
name|size
parameter_list|)
block|{
name|var_map
name|map
decl_stmt|;
name|map
operator|=
operator|(
name|var_map
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|_var_map
argument_list|)
argument_list|)
expr_stmt|;
name|map
operator|->
name|var_partition
operator|=
name|partition_new
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|map
operator|->
name|partition_to_var
operator|=
operator|(
name|tree
operator|*
operator|)
name|xmalloc
argument_list|(
name|size
operator|*
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|map
operator|->
name|partition_to_var
argument_list|,
literal|0
argument_list|,
name|size
operator|*
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|)
expr_stmt|;
name|map
operator|->
name|partition_to_compact
operator|=
name|NULL
expr_stmt|;
name|map
operator|->
name|compact_to_partition
operator|=
name|NULL
expr_stmt|;
name|map
operator|->
name|num_partitions
operator|=
name|size
expr_stmt|;
name|map
operator|->
name|partition_size
operator|=
name|size
expr_stmt|;
name|map
operator|->
name|ref_count
operator|=
name|NULL
expr_stmt|;
return|return
name|map
return|;
block|}
end_function

begin_comment
comment|/* Free memory associated with MAP.  */
end_comment

begin_function
name|void
name|delete_var_map
parameter_list|(
name|var_map
name|map
parameter_list|)
block|{
name|free
argument_list|(
name|map
operator|->
name|partition_to_var
argument_list|)
expr_stmt|;
name|partition_delete
argument_list|(
name|map
operator|->
name|var_partition
argument_list|)
expr_stmt|;
if|if
condition|(
name|map
operator|->
name|partition_to_compact
condition|)
name|free
argument_list|(
name|map
operator|->
name|partition_to_compact
argument_list|)
expr_stmt|;
if|if
condition|(
name|map
operator|->
name|compact_to_partition
condition|)
name|free
argument_list|(
name|map
operator|->
name|compact_to_partition
argument_list|)
expr_stmt|;
if|if
condition|(
name|map
operator|->
name|ref_count
condition|)
name|free
argument_list|(
name|map
operator|->
name|ref_count
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|map
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function will combine the partitions in MAP for VAR1 and VAR2.  It     Returns the partition which represents the new partition.  If the two     partitions cannot be combined, NO_PARTITION is returned.  */
end_comment

begin_function
name|int
name|var_union
parameter_list|(
name|var_map
name|map
parameter_list|,
name|tree
name|var1
parameter_list|,
name|tree
name|var2
parameter_list|)
block|{
name|int
name|p1
decl_stmt|,
name|p2
decl_stmt|,
name|p3
decl_stmt|;
name|tree
name|root_var
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|other_var
init|=
name|NULL_TREE
decl_stmt|;
comment|/* This is independent of partition_to_compact. If partition_to_compact is       on, then whichever one of these partitions is absorbed will never have a      dereference into the partition_to_compact array any more.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|var1
argument_list|)
operator|==
name|SSA_NAME
condition|)
name|p1
operator|=
name|partition_find
argument_list|(
name|map
operator|->
name|var_partition
argument_list|,
name|SSA_NAME_VERSION
argument_list|(
name|var1
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|p1
operator|=
name|var_to_partition
argument_list|(
name|map
argument_list|,
name|var1
argument_list|)
expr_stmt|;
if|if
condition|(
name|map
operator|->
name|compact_to_partition
condition|)
name|p1
operator|=
name|map
operator|->
name|compact_to_partition
index|[
name|p1
index|]
expr_stmt|;
name|root_var
operator|=
name|var1
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|var2
argument_list|)
operator|==
name|SSA_NAME
condition|)
name|p2
operator|=
name|partition_find
argument_list|(
name|map
operator|->
name|var_partition
argument_list|,
name|SSA_NAME_VERSION
argument_list|(
name|var2
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|p2
operator|=
name|var_to_partition
argument_list|(
name|map
argument_list|,
name|var2
argument_list|)
expr_stmt|;
if|if
condition|(
name|map
operator|->
name|compact_to_partition
condition|)
name|p2
operator|=
name|map
operator|->
name|compact_to_partition
index|[
name|p2
index|]
expr_stmt|;
comment|/* If there is no root_var set, or it's not a user variable, set the 	 root_var to this one.  */
if|if
condition|(
operator|!
name|root_var
operator|||
operator|(
name|DECL_P
argument_list|(
name|root_var
argument_list|)
operator|&&
name|DECL_IGNORED_P
argument_list|(
name|root_var
argument_list|)
operator|)
condition|)
block|{
name|other_var
operator|=
name|root_var
expr_stmt|;
name|root_var
operator|=
name|var2
expr_stmt|;
block|}
else|else
name|other_var
operator|=
name|var2
expr_stmt|;
block|}
name|gcc_assert
argument_list|(
name|p1
operator|!=
name|NO_PARTITION
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|p2
operator|!=
name|NO_PARTITION
argument_list|)
expr_stmt|;
if|if
condition|(
name|p1
operator|==
name|p2
condition|)
name|p3
operator|=
name|p1
expr_stmt|;
else|else
name|p3
operator|=
name|partition_union
argument_list|(
name|map
operator|->
name|var_partition
argument_list|,
name|p1
argument_list|,
name|p2
argument_list|)
expr_stmt|;
if|if
condition|(
name|map
operator|->
name|partition_to_compact
condition|)
name|p3
operator|=
name|map
operator|->
name|partition_to_compact
index|[
name|p3
index|]
expr_stmt|;
if|if
condition|(
name|root_var
condition|)
name|change_partition_var
argument_list|(
name|map
argument_list|,
name|root_var
argument_list|,
name|p3
argument_list|)
expr_stmt|;
if|if
condition|(
name|other_var
condition|)
name|change_partition_var
argument_list|(
name|map
argument_list|,
name|other_var
argument_list|,
name|p3
argument_list|)
expr_stmt|;
return|return
name|p3
return|;
block|}
end_function

begin_comment
comment|/* Compress the partition numbers in MAP such that they fall in the range     0..(num_partitions-1) instead of wherever they turned out during    the partitioning exercise.  This removes any references to unused    partitions, thereby allowing bitmaps and other vectors to be much    denser.  Compression type is controlled by FLAGS.     This is implemented such that compaction doesn't affect partitioning.    Ie., once partitions are created and possibly merged, running one    or more different kind of compaction will not affect the partitions    themselves.  Their index might change, but all the same variables will    still be members of the same partition group.  This allows work on reduced    sets, and no loss of information when a larger set is later desired.     In particular, coalescing can work on partitions which have 2 or more    definitions, and then 'recompact' later to include all the single    definitions for assignment to program variables.  */
end_comment

begin_function
name|void
name|compact_var_map
parameter_list|(
name|var_map
name|map
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|sbitmap
name|used
decl_stmt|;
name|int
name|tmp
decl_stmt|,
name|root
decl_stmt|,
name|root_i
decl_stmt|;
name|unsigned
name|int
name|x
decl_stmt|,
name|limit
decl_stmt|,
name|count
decl_stmt|;
name|tree
name|var
decl_stmt|;
name|root_var_p
name|rv
init|=
name|NULL
decl_stmt|;
name|limit
operator|=
name|map
operator|->
name|partition_size
expr_stmt|;
name|used
operator|=
name|sbitmap_alloc
argument_list|(
name|limit
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|used
argument_list|)
expr_stmt|;
comment|/* Already compressed? Abandon the old one.  */
if|if
condition|(
name|map
operator|->
name|partition_to_compact
condition|)
block|{
name|free
argument_list|(
name|map
operator|->
name|partition_to_compact
argument_list|)
expr_stmt|;
name|map
operator|->
name|partition_to_compact
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|map
operator|->
name|compact_to_partition
condition|)
block|{
name|free
argument_list|(
name|map
operator|->
name|compact_to_partition
argument_list|)
expr_stmt|;
name|map
operator|->
name|compact_to_partition
operator|=
name|NULL
expr_stmt|;
block|}
name|map
operator|->
name|num_partitions
operator|=
name|map
operator|->
name|partition_size
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|VARMAP_NO_SINGLE_DEFS
condition|)
name|rv
operator|=
name|root_var_init
argument_list|(
name|map
argument_list|)
expr_stmt|;
name|map
operator|->
name|partition_to_compact
operator|=
operator|(
name|int
operator|*
operator|)
name|xmalloc
argument_list|(
name|limit
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|map
operator|->
name|partition_to_compact
argument_list|,
literal|0xff
argument_list|,
operator|(
name|limit
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* Find out which partitions are actually referenced.  */
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|limit
condition|;
name|x
operator|++
control|)
block|{
name|tmp
operator|=
name|partition_find
argument_list|(
name|map
operator|->
name|var_partition
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TEST_BIT
argument_list|(
name|used
argument_list|,
name|tmp
argument_list|)
operator|&&
name|map
operator|->
name|partition_to_var
index|[
name|tmp
index|]
operator|!=
name|NULL_TREE
condition|)
block|{
comment|/* It is referenced, check to see if there is more than one version 	     in the root_var table, if one is available.  */
if|if
condition|(
name|rv
condition|)
block|{
name|root
operator|=
name|root_var_find
argument_list|(
name|rv
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|root_i
operator|=
name|root_var_first_partition
argument_list|(
name|rv
argument_list|,
name|root
argument_list|)
expr_stmt|;
comment|/* If there is only one, don't include this in the compaction.  */
if|if
condition|(
name|root_var_next_partition
argument_list|(
name|rv
argument_list|,
name|root_i
argument_list|)
operator|==
name|ROOT_VAR_NONE
condition|)
continue|continue;
block|}
name|SET_BIT
argument_list|(
name|used
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
block|}
comment|/* Build a compacted partitioning.  */
if|if
condition|(
name|count
operator|!=
name|limit
condition|)
block|{
name|sbitmap_iterator
name|sbi
decl_stmt|;
name|map
operator|->
name|compact_to_partition
operator|=
operator|(
name|int
operator|*
operator|)
name|xmalloc
argument_list|(
name|count
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
comment|/* SSA renaming begins at 1, so skip 0 when compacting.  */
name|EXECUTE_IF_SET_IN_SBITMAP
argument_list|(
argument|used
argument_list|,
literal|1
argument_list|,
argument|x
argument_list|,
argument|sbi
argument_list|)
block|{
name|map
operator|->
name|partition_to_compact
index|[
name|x
index|]
operator|=
name|count
expr_stmt|;
name|map
operator|->
name|compact_to_partition
index|[
name|count
index|]
operator|=
name|x
expr_stmt|;
name|var
operator|=
name|map
operator|->
name|partition_to_var
index|[
name|x
index|]
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|var
argument_list|)
operator|!=
name|SSA_NAME
condition|)
name|change_partition_var
argument_list|(
name|map
argument_list|,
name|var
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
name|free
argument_list|(
name|map
operator|->
name|partition_to_compact
argument_list|)
expr_stmt|;
name|map
operator|->
name|partition_to_compact
operator|=
name|NULL
expr_stmt|;
block|}
name|map
operator|->
name|num_partitions
operator|=
name|count
expr_stmt|;
if|if
condition|(
name|rv
condition|)
name|root_var_delete
argument_list|(
name|rv
argument_list|)
expr_stmt|;
name|sbitmap_free
argument_list|(
name|used
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function is used to change the representative variable in MAP for VAR's     partition from an SSA_NAME variable to a regular variable.  This allows     partitions to be mapped back to real variables.  */
end_comment

begin_function
name|void
name|change_partition_var
parameter_list|(
name|var_map
name|map
parameter_list|,
name|tree
name|var
parameter_list|,
name|int
name|part
parameter_list|)
block|{
name|var_ann_t
name|ann
decl_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|var
argument_list|)
operator|!=
name|SSA_NAME
argument_list|)
expr_stmt|;
name|ann
operator|=
name|var_ann
argument_list|(
name|var
argument_list|)
expr_stmt|;
name|ann
operator|->
name|out_of_ssa_tag
operator|=
literal|1
expr_stmt|;
name|VAR_ANN_PARTITION
argument_list|(
name|ann
argument_list|)
operator|=
name|part
expr_stmt|;
if|if
condition|(
name|map
operator|->
name|compact_to_partition
condition|)
name|map
operator|->
name|partition_to_var
index|[
name|map
operator|->
name|compact_to_partition
index|[
name|part
index|]
index|]
operator|=
name|var
expr_stmt|;
block|}
end_function

begin_function_decl
specifier|static
specifier|inline
name|void
name|mark_all_vars_used
parameter_list|(
name|tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Helper function for mark_all_vars_used, called via walk_tree.  */
end_comment

begin_function
specifier|static
name|tree
name|mark_all_vars_used_1
parameter_list|(
name|tree
modifier|*
name|tp
parameter_list|,
name|int
modifier|*
name|walk_subtrees
parameter_list|,
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|tree
name|t
init|=
operator|*
name|tp
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|SSA_NAME
condition|)
name|t
operator|=
name|SSA_NAME_VAR
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Ignore TREE_ORIGINAL for TARGET_MEM_REFS, as well as other      fields that do not contain vars.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TARGET_MEM_REF
condition|)
block|{
name|mark_all_vars_used
argument_list|(
operator|&
name|TMR_SYMBOL
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|mark_all_vars_used
argument_list|(
operator|&
name|TMR_BASE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|mark_all_vars_used
argument_list|(
operator|&
name|TMR_INDEX
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|walk_subtrees
operator|=
literal|0
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Only need to mark VAR_DECLS; parameters and return results are not      eliminated as unused.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|VAR_DECL
condition|)
name|set_is_used
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_TYPE_OR_DECL_P
argument_list|(
name|t
argument_list|)
condition|)
operator|*
name|walk_subtrees
operator|=
literal|0
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Mark all VAR_DECLS under *EXPR_P as used, so that they won't be     eliminated during the tree->rtl conversion process.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|mark_all_vars_used
parameter_list|(
name|tree
modifier|*
name|expr_p
parameter_list|)
block|{
name|walk_tree
argument_list|(
name|expr_p
argument_list|,
name|mark_all_vars_used_1
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Remove local variables that are not referenced in the IL.  */
end_comment

begin_function
name|void
name|remove_unused_locals
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|tree
name|t
decl_stmt|,
modifier|*
name|cell
decl_stmt|;
comment|/* Assume all locals are unused.  */
for|for
control|(
name|t
operator|=
name|cfun
operator|->
name|unexpanded_var_list
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|tree
name|var
init|=
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|var
argument_list|)
operator|!=
name|FUNCTION_DECL
operator|&&
name|var_ann
argument_list|(
name|var
argument_list|)
condition|)
name|var_ann
argument_list|(
name|var
argument_list|)
operator|->
name|used
operator|=
name|false
expr_stmt|;
block|}
comment|/* Walk the CFG marking all referenced symbols.  */
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|block_stmt_iterator
name|bsi
decl_stmt|;
name|tree
name|phi
decl_stmt|,
name|def
decl_stmt|;
comment|/* Walk the statements.  */
for|for
control|(
name|bsi
operator|=
name|bsi_start
argument_list|(
name|bb
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|;
name|bsi_next
argument_list|(
operator|&
name|bsi
argument_list|)
control|)
name|mark_all_vars_used
argument_list|(
name|bsi_stmt_ptr
argument_list|(
name|bsi
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|phi
operator|=
name|phi_nodes
argument_list|(
name|bb
argument_list|)
init|;
name|phi
condition|;
name|phi
operator|=
name|PHI_CHAIN
argument_list|(
name|phi
argument_list|)
control|)
block|{
name|use_operand_p
name|arg_p
decl_stmt|;
name|ssa_op_iter
name|i
decl_stmt|;
comment|/* No point processing globals.  */
if|if
condition|(
name|is_global_var
argument_list|(
name|SSA_NAME_VAR
argument_list|(
name|PHI_RESULT
argument_list|(
name|phi
argument_list|)
argument_list|)
argument_list|)
condition|)
continue|continue;
name|def
operator|=
name|PHI_RESULT
argument_list|(
name|phi
argument_list|)
expr_stmt|;
name|mark_all_vars_used
argument_list|(
operator|&
name|def
argument_list|)
expr_stmt|;
name|FOR_EACH_PHI_ARG
argument_list|(
argument|arg_p
argument_list|,
argument|phi
argument_list|,
argument|i
argument_list|,
argument|SSA_OP_ALL_USES
argument_list|)
block|{
name|tree
name|arg
init|=
name|USE_FROM_PTR
argument_list|(
name|arg_p
argument_list|)
decl_stmt|;
name|mark_all_vars_used
argument_list|(
operator|&
name|arg
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Remove unmarked vars and clear used flag.  */
for|for
control|(
name|cell
operator|=
operator|&
name|cfun
operator|->
name|unexpanded_var_list
init|;
operator|*
name|cell
condition|;
control|)
block|{
name|tree
name|var
init|=
name|TREE_VALUE
argument_list|(
operator|*
name|cell
argument_list|)
decl_stmt|;
name|var_ann_t
name|ann
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|var
argument_list|)
operator|!=
name|FUNCTION_DECL
operator|&&
operator|(
operator|!
operator|(
name|ann
operator|=
name|var_ann
argument_list|(
name|var
argument_list|)
operator|)
operator|||
operator|!
name|ann
operator|->
name|used
operator|)
condition|)
block|{
operator|*
name|cell
operator|=
name|TREE_CHAIN
argument_list|(
operator|*
name|cell
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|cell
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
operator|*
name|cell
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This function looks through the program and uses FLAGS to determine what     SSA versioned variables are given entries in a new partition table.  This    new partition map is returned.  */
end_comment

begin_function
name|var_map
name|create_ssa_var_map
parameter_list|(
name|int
name|flags
parameter_list|)
block|{
name|block_stmt_iterator
name|bsi
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|tree
name|dest
decl_stmt|,
name|use
decl_stmt|;
name|tree
name|stmt
decl_stmt|;
name|var_map
name|map
decl_stmt|;
name|ssa_op_iter
name|iter
decl_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
name|bitmap
name|used_in_real_ops
decl_stmt|;
name|bitmap
name|used_in_virtual_ops
decl_stmt|;
endif|#
directive|endif
name|map
operator|=
name|init_var_map
argument_list|(
name|num_ssa_names
operator|+
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
name|used_in_real_ops
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|used_in_virtual_ops
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|flags
operator|&
name|SSA_VAR_MAP_REF_COUNT
condition|)
block|{
name|map
operator|->
name|ref_count
operator|=
operator|(
name|int
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
operator|(
name|num_ssa_names
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|map
operator|->
name|ref_count
argument_list|,
literal|0
argument_list|,
operator|(
name|num_ssa_names
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|tree
name|phi
decl_stmt|,
name|arg
decl_stmt|;
for|for
control|(
name|phi
operator|=
name|phi_nodes
argument_list|(
name|bb
argument_list|)
init|;
name|phi
condition|;
name|phi
operator|=
name|PHI_CHAIN
argument_list|(
name|phi
argument_list|)
control|)
block|{
name|int
name|i
decl_stmt|;
name|register_ssa_partition
argument_list|(
name|map
argument_list|,
name|PHI_RESULT
argument_list|(
name|phi
argument_list|)
argument_list|,
name|false
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PHI_NUM_ARGS
argument_list|(
name|phi
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|arg
operator|=
name|PHI_ARG_DEF
argument_list|(
name|phi
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|SSA_NAME
condition|)
name|register_ssa_partition
argument_list|(
name|map
argument_list|,
name|arg
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|mark_all_vars_used
argument_list|(
operator|&
name|PHI_ARG_DEF_TREE
argument_list|(
name|phi
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|bsi
operator|=
name|bsi_start
argument_list|(
name|bb
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|;
name|bsi_next
argument_list|(
operator|&
name|bsi
argument_list|)
control|)
block|{
name|stmt
operator|=
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
expr_stmt|;
comment|/* Register USE and DEF operands in each statement.  */
name|FOR_EACH_SSA_TREE_OPERAND
argument_list|(
argument|use
argument_list|,
argument|stmt
argument_list|,
argument|iter
argument_list|,
argument|SSA_OP_USE
argument_list|)
block|{
name|register_ssa_partition
argument_list|(
name|map
argument_list|,
name|use
argument_list|,
name|true
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
name|bitmap_set_bit
argument_list|(
name|used_in_real_ops
argument_list|,
name|DECL_UID
argument_list|(
name|SSA_NAME_VAR
argument_list|(
name|use
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|FOR_EACH_SSA_TREE_OPERAND
argument_list|(
argument|dest
argument_list|,
argument|stmt
argument_list|,
argument|iter
argument_list|,
argument|SSA_OP_DEF
argument_list|)
block|{
name|register_ssa_partition
argument_list|(
name|map
argument_list|,
name|dest
argument_list|,
name|false
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
name|bitmap_set_bit
argument_list|(
name|used_in_real_ops
argument_list|,
name|DECL_UID
argument_list|(
name|SSA_NAME_VAR
argument_list|(
name|dest
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
comment|/* Validate that virtual ops don't get used in funny ways.  */
name|FOR_EACH_SSA_TREE_OPERAND
argument_list|(
argument|use
argument_list|,
argument|stmt
argument_list|,
argument|iter
argument_list|,
argument|SSA_OP_VIRTUAL_USES | SSA_OP_VMUSTDEF
argument_list|)
block|{
name|bitmap_set_bit
argument_list|(
name|used_in_virtual_ops
argument_list|,
name|DECL_UID
argument_list|(
name|SSA_NAME_VAR
argument_list|(
name|use
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* ENABLE_CHECKING */
name|mark_all_vars_used
argument_list|(
name|bsi_stmt_ptr
argument_list|(
name|bsi
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|#
directive|if
name|defined
name|ENABLE_CHECKING
block|{
name|unsigned
name|i
decl_stmt|;
name|bitmap
name|both
init|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
name|bitmap_and
argument_list|(
name|both
argument_list|,
name|used_in_real_ops
argument_list|,
name|used_in_virtual_ops
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bitmap_empty_p
argument_list|(
name|both
argument_list|)
condition|)
block|{
name|bitmap_iterator
name|bi
decl_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|both
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|bi
argument_list|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Variable %s used in real and virtual operands\n"
argument_list|,
name|get_name
argument_list|(
name|referenced_var
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|internal_error
argument_list|(
literal|"SSA corruption"
argument_list|)
expr_stmt|;
block|}
name|BITMAP_FREE
argument_list|(
name|used_in_real_ops
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|used_in_virtual_ops
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|both
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|map
return|;
block|}
end_function

begin_comment
comment|/* Allocate and return a new live range information object base on MAP.  */
end_comment

begin_function
specifier|static
name|tree_live_info_p
name|new_tree_live_info
parameter_list|(
name|var_map
name|map
parameter_list|)
block|{
name|tree_live_info_p
name|live
decl_stmt|;
name|unsigned
name|x
decl_stmt|;
name|live
operator|=
operator|(
name|tree_live_info_p
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|tree_live_info_d
argument_list|)
argument_list|)
expr_stmt|;
name|live
operator|->
name|map
operator|=
name|map
expr_stmt|;
name|live
operator|->
name|num_blocks
operator|=
name|last_basic_block
expr_stmt|;
name|live
operator|->
name|global
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|live
operator|->
name|livein
operator|=
operator|(
name|bitmap
operator|*
operator|)
name|xmalloc
argument_list|(
name|num_var_partitions
argument_list|(
name|map
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|bitmap
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|num_var_partitions
argument_list|(
name|map
argument_list|)
condition|;
name|x
operator|++
control|)
name|live
operator|->
name|livein
index|[
name|x
index|]
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
comment|/* liveout is deferred until it is actually requested.  */
name|live
operator|->
name|liveout
operator|=
name|NULL
expr_stmt|;
return|return
name|live
return|;
block|}
end_function

begin_comment
comment|/* Free storage for live range info object LIVE.  */
end_comment

begin_function
name|void
name|delete_tree_live_info
parameter_list|(
name|tree_live_info_p
name|live
parameter_list|)
block|{
name|int
name|x
decl_stmt|;
if|if
condition|(
name|live
operator|->
name|liveout
condition|)
block|{
for|for
control|(
name|x
operator|=
name|live
operator|->
name|num_blocks
operator|-
literal|1
init|;
name|x
operator|>=
literal|0
condition|;
name|x
operator|--
control|)
name|BITMAP_FREE
argument_list|(
name|live
operator|->
name|liveout
index|[
name|x
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|live
operator|->
name|liveout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|live
operator|->
name|livein
condition|)
block|{
for|for
control|(
name|x
operator|=
name|num_var_partitions
argument_list|(
name|live
operator|->
name|map
argument_list|)
operator|-
literal|1
init|;
name|x
operator|>=
literal|0
condition|;
name|x
operator|--
control|)
name|BITMAP_FREE
argument_list|(
name|live
operator|->
name|livein
index|[
name|x
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|live
operator|->
name|livein
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|live
operator|->
name|global
condition|)
name|BITMAP_FREE
argument_list|(
name|live
operator|->
name|global
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|live
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Using LIVE, fill in all the live-on-entry blocks between the defs and uses     for partition I.  STACK is a varray used for temporary memory which is     passed in rather than being allocated on every call.  */
end_comment

begin_function
specifier|static
name|void
name|live_worklist
parameter_list|(
name|tree_live_info_p
name|live
parameter_list|,
name|int
modifier|*
name|stack
parameter_list|,
name|int
name|i
parameter_list|)
block|{
name|unsigned
name|b
decl_stmt|;
name|tree
name|var
decl_stmt|;
name|basic_block
name|def_bb
init|=
name|NULL
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|var_map
name|map
init|=
name|live
operator|->
name|map
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
name|int
modifier|*
name|tos
init|=
name|stack
decl_stmt|;
name|var
operator|=
name|partition_to_var
argument_list|(
name|map
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|SSA_NAME_DEF_STMT
argument_list|(
name|var
argument_list|)
condition|)
name|def_bb
operator|=
name|bb_for_stmt
argument_list|(
name|SSA_NAME_DEF_STMT
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|live->livein[i]
argument_list|,
literal|0
argument_list|,
argument|b
argument_list|,
argument|bi
argument_list|)
block|{
operator|*
name|tos
operator|++
operator|=
name|b
expr_stmt|;
block|}
while|while
condition|(
name|tos
operator|!=
name|stack
condition|)
block|{
name|b
operator|=
operator|*
operator|--
name|tos
expr_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|BASIC_BLOCK (b)->preds
argument_list|)
if|if
condition|(
name|e
operator|->
name|src
operator|!=
name|ENTRY_BLOCK_PTR
condition|)
block|{
comment|/* Its not live on entry to the block its defined in.  */
if|if
condition|(
name|e
operator|->
name|src
operator|==
name|def_bb
condition|)
continue|continue;
if|if
condition|(
operator|!
name|bitmap_bit_p
argument_list|(
name|live
operator|->
name|livein
index|[
name|i
index|]
argument_list|,
name|e
operator|->
name|src
operator|->
name|index
argument_list|)
condition|)
block|{
name|bitmap_set_bit
argument_list|(
name|live
operator|->
name|livein
index|[
name|i
index|]
argument_list|,
name|e
operator|->
name|src
operator|->
name|index
argument_list|)
expr_stmt|;
operator|*
name|tos
operator|++
operator|=
name|e
operator|->
name|src
operator|->
name|index
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* If VAR is in a partition of MAP, set the bit for that partition in VEC.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|set_if_valid
parameter_list|(
name|var_map
name|map
parameter_list|,
name|bitmap
name|vec
parameter_list|,
name|tree
name|var
parameter_list|)
block|{
name|int
name|p
init|=
name|var_to_partition
argument_list|(
name|map
argument_list|,
name|var
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|!=
name|NO_PARTITION
condition|)
name|bitmap_set_bit
argument_list|(
name|vec
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If VAR is in a partition and it isn't defined in DEF_VEC, set the livein and     global bit for it in the LIVE object.  BB is the block being processed.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|add_livein_if_notdef
parameter_list|(
name|tree_live_info_p
name|live
parameter_list|,
name|bitmap
name|def_vec
parameter_list|,
name|tree
name|var
parameter_list|,
name|basic_block
name|bb
parameter_list|)
block|{
name|int
name|p
init|=
name|var_to_partition
argument_list|(
name|live
operator|->
name|map
argument_list|,
name|var
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|NO_PARTITION
operator|||
name|bb
operator|==
name|ENTRY_BLOCK_PTR
condition|)
return|return;
if|if
condition|(
operator|!
name|bitmap_bit_p
argument_list|(
name|def_vec
argument_list|,
name|p
argument_list|)
condition|)
block|{
name|bitmap_set_bit
argument_list|(
name|live
operator|->
name|livein
index|[
name|p
index|]
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|bitmap_set_bit
argument_list|(
name|live
operator|->
name|global
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Given partition map MAP, calculate all the live on entry bitmaps for     each basic block.  Return a live info object.  */
end_comment

begin_function
name|tree_live_info_p
name|calculate_live_on_entry
parameter_list|(
name|var_map
name|map
parameter_list|)
block|{
name|tree_live_info_p
name|live
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|bitmap
name|saw_def
decl_stmt|;
name|tree
name|phi
decl_stmt|,
name|var
decl_stmt|,
name|stmt
decl_stmt|;
name|tree
name|op
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|int
modifier|*
name|stack
decl_stmt|;
name|block_stmt_iterator
name|bsi
decl_stmt|;
name|ssa_op_iter
name|iter
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
name|int
name|num
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
endif|#
directive|endif
name|saw_def
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|live
operator|=
name|new_tree_live_info
argument_list|(
name|map
argument_list|)
expr_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|bitmap_clear
argument_list|(
name|saw_def
argument_list|)
expr_stmt|;
for|for
control|(
name|phi
operator|=
name|phi_nodes
argument_list|(
name|bb
argument_list|)
init|;
name|phi
condition|;
name|phi
operator|=
name|PHI_CHAIN
argument_list|(
name|phi
argument_list|)
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|unsigned
operator|)
name|PHI_NUM_ARGS
argument_list|(
name|phi
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|var
operator|=
name|PHI_ARG_DEF
argument_list|(
name|phi
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|phi_ssa_name_p
argument_list|(
name|var
argument_list|)
condition|)
continue|continue;
name|stmt
operator|=
name|SSA_NAME_DEF_STMT
argument_list|(
name|var
argument_list|)
expr_stmt|;
name|e
operator|=
name|EDGE_PRED
argument_list|(
name|bb
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* Any uses in PHIs which either don't have def's or are not 	         defined in the block from which the def comes, will be live 		 on entry to that block.  */
if|if
condition|(
operator|!
name|stmt
operator|||
name|e
operator|->
name|src
operator|!=
name|bb_for_stmt
argument_list|(
name|stmt
argument_list|)
condition|)
name|add_livein_if_notdef
argument_list|(
name|live
argument_list|,
name|saw_def
argument_list|,
name|var
argument_list|,
name|e
operator|->
name|src
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Don't mark PHI results as defined until all the PHI nodes have 	 been processed. If the PHI sequence is: 	    a_3 = PHI<a_1, a_2> 	    b_3 = PHI<b_1, a_3> 	 The a_3 referred to in b_3's PHI node is the one incoming on the 	 edge, *not* the PHI node just seen.  */
for|for
control|(
name|phi
operator|=
name|phi_nodes
argument_list|(
name|bb
argument_list|)
init|;
name|phi
condition|;
name|phi
operator|=
name|PHI_CHAIN
argument_list|(
name|phi
argument_list|)
control|)
block|{
name|var
operator|=
name|PHI_RESULT
argument_list|(
name|phi
argument_list|)
expr_stmt|;
name|set_if_valid
argument_list|(
name|map
argument_list|,
name|saw_def
argument_list|,
name|var
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|bsi
operator|=
name|bsi_start
argument_list|(
name|bb
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|;
name|bsi_next
argument_list|(
operator|&
name|bsi
argument_list|)
control|)
block|{
name|stmt
operator|=
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
expr_stmt|;
name|FOR_EACH_SSA_TREE_OPERAND
argument_list|(
argument|op
argument_list|,
argument|stmt
argument_list|,
argument|iter
argument_list|,
argument|SSA_OP_USE
argument_list|)
block|{
name|add_livein_if_notdef
argument_list|(
name|live
argument_list|,
name|saw_def
argument_list|,
name|op
argument_list|,
name|bb
argument_list|)
expr_stmt|;
block|}
name|FOR_EACH_SSA_TREE_OPERAND
argument_list|(
argument|op
argument_list|,
argument|stmt
argument_list|,
argument|iter
argument_list|,
argument|SSA_OP_DEF
argument_list|)
block|{
name|set_if_valid
argument_list|(
name|map
argument_list|,
name|saw_def
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|stack
operator|=
name|XNEWVEC
argument_list|(
name|int
argument_list|,
name|last_basic_block
argument_list|)
expr_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|live->global
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|bi
argument_list|)
block|{
name|live_worklist
argument_list|(
name|live
argument_list|,
name|stack
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|stack
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
comment|/* Check for live on entry partitions and report those with a DEF in       the program. This will typically mean an optimization has done       something wrong.  */
name|bb
operator|=
name|ENTRY_BLOCK_PTR
expr_stmt|;
name|num
operator|=
literal|0
expr_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
block|{
name|int
name|entry_block
init|=
name|e
operator|->
name|dest
operator|->
name|index
decl_stmt|;
if|if
condition|(
name|e
operator|->
name|dest
operator|==
name|EXIT_BLOCK_PTR
condition|)
continue|continue;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|unsigned
operator|)
name|num_var_partitions
argument_list|(
name|map
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|basic_block
name|tmp
decl_stmt|;
name|tree
name|d
decl_stmt|;
name|var
operator|=
name|partition_to_var
argument_list|(
name|map
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|SSA_NAME_DEF_STMT
argument_list|(
name|var
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|bb_for_stmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|d
operator|=
name|default_def
argument_list|(
name|SSA_NAME_VAR
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitmap_bit_p
argument_list|(
name|live_entry_blocks
argument_list|(
name|live
argument_list|,
name|i
argument_list|)
argument_list|,
name|entry_block
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|IS_EMPTY_STMT
argument_list|(
name|stmt
argument_list|)
condition|)
block|{
name|num
operator|++
expr_stmt|;
name|print_generic_expr
argument_list|(
name|stderr
argument_list|,
name|var
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" is defined "
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" in BB%d, "
argument_list|,
name|tmp
operator|->
name|index
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"by:\n"
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|stderr
argument_list|,
name|stmt
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nIt is also live-on-entry to entry BB %d"
argument_list|,
name|entry_block
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" So it appears to have multiple defs.\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|d
operator|!=
name|var
condition|)
block|{
name|num
operator|++
expr_stmt|;
name|print_generic_expr
argument_list|(
name|stderr
argument_list|,
name|var
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" is live-on-entry to BB%d "
argument_list|,
name|entry_block
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" but is not the default def of "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|stderr
argument_list|,
name|d
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" and there is no default def.\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|d
operator|==
name|var
condition|)
block|{
comment|/* The only way this var shouldn't be marked live on entry is  		   if it occurs in a PHI argument of the block.  */
name|int
name|z
decl_stmt|,
name|ok
init|=
literal|0
decl_stmt|;
for|for
control|(
name|phi
operator|=
name|phi_nodes
argument_list|(
name|e
operator|->
name|dest
argument_list|)
init|;
name|phi
operator|&&
operator|!
name|ok
condition|;
name|phi
operator|=
name|PHI_CHAIN
argument_list|(
name|phi
argument_list|)
control|)
block|{
for|for
control|(
name|z
operator|=
literal|0
init|;
name|z
operator|<
name|PHI_NUM_ARGS
argument_list|(
name|phi
argument_list|)
condition|;
name|z
operator|++
control|)
if|if
condition|(
name|var
operator|==
name|PHI_ARG_DEF
argument_list|(
name|phi
argument_list|,
name|z
argument_list|)
condition|)
block|{
name|ok
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|ok
condition|)
continue|continue;
name|num
operator|++
expr_stmt|;
name|print_generic_expr
argument_list|(
name|stderr
argument_list|,
name|var
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" is not marked live-on-entry to entry BB%d "
argument_list|,
name|entry_block
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"but it is a default def so it should be.\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|gcc_assert
argument_list|(
name|num
operator|<=
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|BITMAP_FREE
argument_list|(
name|saw_def
argument_list|)
expr_stmt|;
return|return
name|live
return|;
block|}
end_function

begin_comment
comment|/* Calculate the live on exit vectors based on the entry info in LIVEINFO.  */
end_comment

begin_function
name|void
name|calculate_live_on_exit
parameter_list|(
name|tree_live_info_p
name|liveinfo
parameter_list|)
block|{
name|unsigned
name|b
decl_stmt|;
name|unsigned
name|i
decl_stmt|,
name|x
decl_stmt|;
name|bitmap
modifier|*
name|on_exit
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|tree
name|t
decl_stmt|,
name|phi
decl_stmt|;
name|bitmap
name|on_entry
decl_stmt|;
name|var_map
name|map
init|=
name|liveinfo
operator|->
name|map
decl_stmt|;
name|on_exit
operator|=
operator|(
name|bitmap
operator|*
operator|)
name|xmalloc
argument_list|(
name|last_basic_block
operator|*
sizeof|sizeof
argument_list|(
name|bitmap
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
operator|(
name|unsigned
operator|)
name|last_basic_block
condition|;
name|x
operator|++
control|)
name|on_exit
index|[
name|x
index|]
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
comment|/* Set all the live-on-exit bits for uses in PHIs.  */
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
for|for
control|(
name|phi
operator|=
name|phi_nodes
argument_list|(
name|bb
argument_list|)
init|;
name|phi
condition|;
name|phi
operator|=
name|PHI_CHAIN
argument_list|(
name|phi
argument_list|)
control|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|unsigned
operator|)
name|PHI_NUM_ARGS
argument_list|(
name|phi
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|t
operator|=
name|PHI_ARG_DEF
argument_list|(
name|phi
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|e
operator|=
name|PHI_ARG_EDGE
argument_list|(
name|phi
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|phi_ssa_name_p
argument_list|(
name|t
argument_list|)
operator|||
name|e
operator|->
name|src
operator|==
name|ENTRY_BLOCK_PTR
condition|)
continue|continue;
name|set_if_valid
argument_list|(
name|map
argument_list|,
name|on_exit
index|[
name|e
operator|->
name|src
operator|->
name|index
index|]
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Set live on exit for all predecessors of live on entry's.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_var_partitions
argument_list|(
name|map
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|bitmap_iterator
name|bi
decl_stmt|;
name|on_entry
operator|=
name|live_entry_blocks
argument_list|(
name|liveinfo
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|on_entry
argument_list|,
literal|0
argument_list|,
argument|b
argument_list|,
argument|bi
argument_list|)
block|{
name|edge_iterator
name|ei
decl_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|BASIC_BLOCK (b)->preds
argument_list|)
if|if
condition|(
name|e
operator|->
name|src
operator|!=
name|ENTRY_BLOCK_PTR
condition|)
name|bitmap_set_bit
argument_list|(
name|on_exit
index|[
name|e
operator|->
name|src
operator|->
name|index
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
name|liveinfo
operator|->
name|liveout
operator|=
name|on_exit
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize a tree_partition_associator object using MAP.  */
end_comment

begin_function
specifier|static
name|tpa_p
name|tpa_init
parameter_list|(
name|var_map
name|map
parameter_list|)
block|{
name|tpa_p
name|tpa
decl_stmt|;
name|int
name|num_partitions
init|=
name|num_var_partitions
argument_list|(
name|map
argument_list|)
decl_stmt|;
name|int
name|x
decl_stmt|;
if|if
condition|(
name|num_partitions
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
name|tpa
operator|=
operator|(
name|tpa_p
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|tree_partition_associator_d
argument_list|)
argument_list|)
expr_stmt|;
name|tpa
operator|->
name|num_trees
operator|=
literal|0
expr_stmt|;
name|tpa
operator|->
name|uncompressed_num
operator|=
operator|-
literal|1
expr_stmt|;
name|tpa
operator|->
name|map
operator|=
name|map
expr_stmt|;
name|tpa
operator|->
name|next_partition
operator|=
operator|(
name|int
operator|*
operator|)
name|xmalloc
argument_list|(
name|num_partitions
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|tpa
operator|->
name|next_partition
argument_list|,
name|TPA_NONE
argument_list|,
name|num_partitions
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|tpa
operator|->
name|partition_to_tree_map
operator|=
operator|(
name|int
operator|*
operator|)
name|xmalloc
argument_list|(
name|num_partitions
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|tpa
operator|->
name|partition_to_tree_map
argument_list|,
name|TPA_NONE
argument_list|,
name|num_partitions
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|=
name|MAX
argument_list|(
literal|40
argument_list|,
operator|(
name|num_partitions
operator|/
literal|20
operator|)
argument_list|)
expr_stmt|;
name|tpa
operator|->
name|trees
operator|=
name|VEC_alloc
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|tpa
operator|->
name|first_partition
operator|=
name|VEC_alloc
argument_list|(
name|int
argument_list|,
name|heap
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return
name|tpa
return|;
block|}
end_function

begin_comment
comment|/* Remove PARTITION_INDEX from TREE_INDEX's list in the tpa structure TPA.  */
end_comment

begin_function
name|void
name|tpa_remove_partition
parameter_list|(
name|tpa_p
name|tpa
parameter_list|,
name|int
name|tree_index
parameter_list|,
name|int
name|partition_index
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|i
operator|=
name|tpa_first_partition
argument_list|(
name|tpa
argument_list|,
name|tree_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|partition_index
condition|)
block|{
name|VEC_replace
argument_list|(
name|int
argument_list|,
name|tpa
operator|->
name|first_partition
argument_list|,
name|tree_index
argument_list|,
name|tpa
operator|->
name|next_partition
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
init|;
name|i
operator|!=
name|TPA_NONE
condition|;
name|i
operator|=
name|tpa_next_partition
argument_list|(
name|tpa
argument_list|,
name|i
argument_list|)
control|)
block|{
if|if
condition|(
name|tpa
operator|->
name|next_partition
index|[
name|i
index|]
operator|==
name|partition_index
condition|)
block|{
name|tpa
operator|->
name|next_partition
index|[
name|i
index|]
operator|=
name|tpa
operator|->
name|next_partition
index|[
name|partition_index
index|]
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Free the memory used by tree_partition_associator object TPA.  */
end_comment

begin_function
name|void
name|tpa_delete
parameter_list|(
name|tpa_p
name|tpa
parameter_list|)
block|{
if|if
condition|(
operator|!
name|tpa
condition|)
return|return;
name|VEC_free
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
name|tpa
operator|->
name|trees
argument_list|)
expr_stmt|;
name|VEC_free
argument_list|(
name|int
argument_list|,
name|heap
argument_list|,
name|tpa
operator|->
name|first_partition
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tpa
operator|->
name|partition_to_tree_map
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tpa
operator|->
name|next_partition
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tpa
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function will remove any tree entries from TPA which have only a single    element.  This will help keep the size of the conflict graph down.  The     function returns the number of remaining tree lists.  */
end_comment

begin_function
name|int
name|tpa_compact
parameter_list|(
name|tpa_p
name|tpa
parameter_list|)
block|{
name|int
name|last
decl_stmt|,
name|x
decl_stmt|,
name|y
decl_stmt|,
name|first
decl_stmt|,
name|swap_i
decl_stmt|;
name|tree
name|swap_t
decl_stmt|;
comment|/* Find the last list which has more than 1 partition.  */
for|for
control|(
name|last
operator|=
name|tpa
operator|->
name|num_trees
operator|-
literal|1
init|;
name|last
operator|>
literal|0
condition|;
name|last
operator|--
control|)
block|{
name|first
operator|=
name|tpa_first_partition
argument_list|(
name|tpa
argument_list|,
name|last
argument_list|)
expr_stmt|;
if|if
condition|(
name|tpa_next_partition
argument_list|(
name|tpa
argument_list|,
name|first
argument_list|)
operator|!=
name|NO_PARTITION
condition|)
break|break;
block|}
name|x
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|x
operator|<
name|last
condition|)
block|{
name|first
operator|=
name|tpa_first_partition
argument_list|(
name|tpa
argument_list|,
name|x
argument_list|)
expr_stmt|;
comment|/* If there is not more than one partition, swap with the current end 	 of the tree list.  */
if|if
condition|(
name|tpa_next_partition
argument_list|(
name|tpa
argument_list|,
name|first
argument_list|)
operator|==
name|NO_PARTITION
condition|)
block|{
name|swap_t
operator|=
name|VEC_index
argument_list|(
name|tree
argument_list|,
name|tpa
operator|->
name|trees
argument_list|,
name|last
argument_list|)
expr_stmt|;
name|swap_i
operator|=
name|VEC_index
argument_list|(
name|int
argument_list|,
name|tpa
operator|->
name|first_partition
argument_list|,
name|last
argument_list|)
expr_stmt|;
comment|/* Update the last entry. Since it is known to only have one 	     partition, there is nothing else to update.  */
name|VEC_replace
argument_list|(
name|tree
argument_list|,
name|tpa
operator|->
name|trees
argument_list|,
name|last
argument_list|,
name|VEC_index
argument_list|(
name|tree
argument_list|,
name|tpa
operator|->
name|trees
argument_list|,
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|VEC_replace
argument_list|(
name|int
argument_list|,
name|tpa
operator|->
name|first_partition
argument_list|,
name|last
argument_list|,
name|VEC_index
argument_list|(
name|int
argument_list|,
name|tpa
operator|->
name|first_partition
argument_list|,
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|tpa
operator|->
name|partition_to_tree_map
index|[
name|tpa_first_partition
argument_list|(
name|tpa
argument_list|,
name|last
argument_list|)
index|]
operator|=
name|last
expr_stmt|;
comment|/* Since this list is known to have more than one partition, update 	     the list owner entries.  */
name|VEC_replace
argument_list|(
name|tree
argument_list|,
name|tpa
operator|->
name|trees
argument_list|,
name|x
argument_list|,
name|swap_t
argument_list|)
expr_stmt|;
name|VEC_replace
argument_list|(
name|int
argument_list|,
name|tpa
operator|->
name|first_partition
argument_list|,
name|x
argument_list|,
name|swap_i
argument_list|)
expr_stmt|;
for|for
control|(
name|y
operator|=
name|tpa_first_partition
argument_list|(
name|tpa
argument_list|,
name|x
argument_list|)
init|;
name|y
operator|!=
name|NO_PARTITION
condition|;
name|y
operator|=
name|tpa_next_partition
argument_list|(
name|tpa
argument_list|,
name|y
argument_list|)
control|)
name|tpa
operator|->
name|partition_to_tree_map
index|[
name|y
index|]
operator|=
name|x
expr_stmt|;
comment|/* Ensure last is a list with more than one partition.  */
name|last
operator|--
expr_stmt|;
for|for
control|(
init|;
name|last
operator|>
name|x
condition|;
name|last
operator|--
control|)
block|{
name|first
operator|=
name|tpa_first_partition
argument_list|(
name|tpa
argument_list|,
name|last
argument_list|)
expr_stmt|;
if|if
condition|(
name|tpa_next_partition
argument_list|(
name|tpa
argument_list|,
name|first
argument_list|)
operator|!=
name|NO_PARTITION
condition|)
break|break;
block|}
block|}
name|x
operator|++
expr_stmt|;
block|}
name|first
operator|=
name|tpa_first_partition
argument_list|(
name|tpa
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|tpa_next_partition
argument_list|(
name|tpa
argument_list|,
name|first
argument_list|)
operator|!=
name|NO_PARTITION
condition|)
name|x
operator|++
expr_stmt|;
name|tpa
operator|->
name|uncompressed_num
operator|=
name|tpa
operator|->
name|num_trees
expr_stmt|;
name|tpa
operator|->
name|num_trees
operator|=
name|x
expr_stmt|;
return|return
name|last
return|;
block|}
end_function

begin_comment
comment|/* Initialize a root_var object with SSA partitions from MAP which are based     on each root variable.  */
end_comment

begin_function
name|root_var_p
name|root_var_init
parameter_list|(
name|var_map
name|map
parameter_list|)
block|{
name|root_var_p
name|rv
decl_stmt|;
name|int
name|num_partitions
init|=
name|num_var_partitions
argument_list|(
name|map
argument_list|)
decl_stmt|;
name|int
name|x
decl_stmt|,
name|p
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|var_ann_t
name|ann
decl_stmt|;
name|sbitmap
name|seen
decl_stmt|;
name|rv
operator|=
name|tpa_init
argument_list|(
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rv
condition|)
return|return
name|NULL
return|;
name|seen
operator|=
name|sbitmap_alloc
argument_list|(
name|num_partitions
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|seen
argument_list|)
expr_stmt|;
comment|/* Start at the end and work towards the front. This will provide a list      that is ordered from smallest to largest.  */
for|for
control|(
name|x
operator|=
name|num_partitions
operator|-
literal|1
init|;
name|x
operator|>=
literal|0
condition|;
name|x
operator|--
control|)
block|{
name|t
operator|=
name|partition_to_var
argument_list|(
name|map
argument_list|,
name|x
argument_list|)
expr_stmt|;
comment|/* The var map may not be compacted yet, so check for NULL.  */
if|if
condition|(
operator|!
name|t
condition|)
continue|continue;
name|p
operator|=
name|var_to_partition
argument_list|(
name|map
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|p
operator|!=
name|NO_PARTITION
argument_list|)
expr_stmt|;
comment|/* Make sure we only put coalesced partitions into the list once.  */
if|if
condition|(
name|TEST_BIT
argument_list|(
name|seen
argument_list|,
name|p
argument_list|)
condition|)
continue|continue;
name|SET_BIT
argument_list|(
name|seen
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|SSA_NAME
condition|)
name|t
operator|=
name|SSA_NAME_VAR
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|ann
operator|=
name|var_ann
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|ann
operator|->
name|root_var_processed
condition|)
block|{
name|rv
operator|->
name|next_partition
index|[
name|p
index|]
operator|=
name|VEC_index
argument_list|(
name|int
argument_list|,
name|rv
operator|->
name|first_partition
argument_list|,
name|VAR_ANN_ROOT_INDEX
argument_list|(
name|ann
argument_list|)
argument_list|)
expr_stmt|;
name|VEC_replace
argument_list|(
name|int
argument_list|,
name|rv
operator|->
name|first_partition
argument_list|,
name|VAR_ANN_ROOT_INDEX
argument_list|(
name|ann
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ann
operator|->
name|root_var_processed
operator|=
literal|1
expr_stmt|;
name|VAR_ANN_ROOT_INDEX
argument_list|(
name|ann
argument_list|)
operator|=
name|rv
operator|->
name|num_trees
operator|++
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
name|rv
operator|->
name|trees
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|int
argument_list|,
name|heap
argument_list|,
name|rv
operator|->
name|first_partition
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
name|rv
operator|->
name|partition_to_tree_map
index|[
name|p
index|]
operator|=
name|VAR_ANN_ROOT_INDEX
argument_list|(
name|ann
argument_list|)
expr_stmt|;
block|}
comment|/* Reset the out_of_ssa_tag flag on each variable for later use.  */
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|rv
operator|->
name|num_trees
condition|;
name|x
operator|++
control|)
block|{
name|t
operator|=
name|VEC_index
argument_list|(
name|tree
argument_list|,
name|rv
operator|->
name|trees
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|var_ann
argument_list|(
name|t
argument_list|)
operator|->
name|root_var_processed
operator|=
literal|0
expr_stmt|;
block|}
name|sbitmap_free
argument_list|(
name|seen
argument_list|)
expr_stmt|;
return|return
name|rv
return|;
block|}
end_function

begin_comment
comment|/* Initialize a type_var structure which associates all the partitions in MAP     of the same type to the type node's index.  Volatiles are ignored.  */
end_comment

begin_function
name|type_var_p
name|type_var_init
parameter_list|(
name|var_map
name|map
parameter_list|)
block|{
name|type_var_p
name|tv
decl_stmt|;
name|int
name|x
decl_stmt|,
name|y
decl_stmt|,
name|p
decl_stmt|;
name|int
name|num_partitions
init|=
name|num_var_partitions
argument_list|(
name|map
argument_list|)
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|sbitmap
name|seen
decl_stmt|;
name|tv
operator|=
name|tpa_init
argument_list|(
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tv
condition|)
return|return
name|NULL
return|;
name|seen
operator|=
name|sbitmap_alloc
argument_list|(
name|num_partitions
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|seen
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
name|num_partitions
operator|-
literal|1
init|;
name|x
operator|>=
literal|0
condition|;
name|x
operator|--
control|)
block|{
name|t
operator|=
name|partition_to_var
argument_list|(
name|map
argument_list|,
name|x
argument_list|)
expr_stmt|;
comment|/* Disallow coalescing of these types of variables.  */
if|if
condition|(
operator|!
name|t
operator|||
name|TREE_THIS_VOLATILE
argument_list|(
name|t
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|RESULT_DECL
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|PARM_DECL
operator|||
operator|(
name|DECL_P
argument_list|(
name|t
argument_list|)
operator|&&
operator|(
name|DECL_REGISTER
argument_list|(
name|t
argument_list|)
operator|||
operator|!
name|DECL_IGNORED_P
argument_list|(
name|t
argument_list|)
operator|||
name|DECL_RTL_SET_P
argument_list|(
name|t
argument_list|)
operator|)
operator|)
condition|)
continue|continue;
name|p
operator|=
name|var_to_partition
argument_list|(
name|map
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|p
operator|!=
name|NO_PARTITION
argument_list|)
expr_stmt|;
comment|/* If partitions have been coalesced, only add the representative  	 for the partition to the list once.  */
if|if
condition|(
name|TEST_BIT
argument_list|(
name|seen
argument_list|,
name|p
argument_list|)
condition|)
continue|continue;
name|SET_BIT
argument_list|(
name|seen
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|t
operator|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Find the list for this type.  */
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|tv
operator|->
name|num_trees
condition|;
name|y
operator|++
control|)
if|if
condition|(
name|t
operator|==
name|VEC_index
argument_list|(
name|tree
argument_list|,
name|tv
operator|->
name|trees
argument_list|,
name|y
argument_list|)
condition|)
break|break;
if|if
condition|(
name|y
operator|==
name|tv
operator|->
name|num_trees
condition|)
block|{
name|tv
operator|->
name|num_trees
operator|++
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
name|tv
operator|->
name|trees
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|int
argument_list|,
name|heap
argument_list|,
name|tv
operator|->
name|first_partition
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tv
operator|->
name|next_partition
index|[
name|p
index|]
operator|=
name|VEC_index
argument_list|(
name|int
argument_list|,
name|tv
operator|->
name|first_partition
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|VEC_replace
argument_list|(
name|int
argument_list|,
name|tv
operator|->
name|first_partition
argument_list|,
name|y
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
name|tv
operator|->
name|partition_to_tree_map
index|[
name|p
index|]
operator|=
name|y
expr_stmt|;
block|}
name|sbitmap_free
argument_list|(
name|seen
argument_list|)
expr_stmt|;
return|return
name|tv
return|;
block|}
end_function

begin_comment
comment|/* Create a new coalesce list object from MAP and return it.  */
end_comment

begin_function
name|coalesce_list_p
name|create_coalesce_list
parameter_list|(
name|var_map
name|map
parameter_list|)
block|{
name|coalesce_list_p
name|list
decl_stmt|;
name|list
operator|=
operator|(
name|coalesce_list_p
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|coalesce_list_d
argument_list|)
argument_list|)
expr_stmt|;
name|list
operator|->
name|map
operator|=
name|map
expr_stmt|;
name|list
operator|->
name|add_mode
operator|=
name|true
expr_stmt|;
name|list
operator|->
name|list
operator|=
operator|(
name|partition_pair_p
operator|*
operator|)
name|xcalloc
argument_list|(
name|num_var_partitions
argument_list|(
name|map
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|partition_pair_d
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|list
return|;
block|}
end_function

begin_comment
comment|/* Delete coalesce list CL.  */
end_comment

begin_function
name|void
name|delete_coalesce_list
parameter_list|(
name|coalesce_list_p
name|cl
parameter_list|)
block|{
name|free
argument_list|(
name|cl
operator|->
name|list
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Find a matching coalesce pair object in CL for partitions P1 and P2.  If     one isn't found, return NULL if CREATE is false, otherwise create a new     coalesce pair object and return it.  */
end_comment

begin_function
specifier|static
name|partition_pair_p
name|find_partition_pair
parameter_list|(
name|coalesce_list_p
name|cl
parameter_list|,
name|int
name|p1
parameter_list|,
name|int
name|p2
parameter_list|,
name|bool
name|create
parameter_list|)
block|{
name|partition_pair_p
name|node
decl_stmt|,
name|tmp
decl_stmt|;
name|int
name|s
decl_stmt|;
comment|/* Normalize so that p1 is the smaller value.  */
if|if
condition|(
name|p2
operator|<
name|p1
condition|)
block|{
name|s
operator|=
name|p1
expr_stmt|;
name|p1
operator|=
name|p2
expr_stmt|;
name|p2
operator|=
name|s
expr_stmt|;
block|}
name|tmp
operator|=
name|NULL
expr_stmt|;
comment|/* The list is sorted such that if we find a value greater than p2,      p2 is not in the list.  */
for|for
control|(
name|node
operator|=
name|cl
operator|->
name|list
index|[
name|p1
index|]
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
block|{
if|if
condition|(
name|node
operator|->
name|second_partition
operator|==
name|p2
condition|)
return|return
name|node
return|;
elseif|else
if|if
condition|(
name|node
operator|->
name|second_partition
operator|>
name|p2
condition|)
break|break;
name|tmp
operator|=
name|node
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|create
condition|)
return|return
name|NULL
return|;
name|node
operator|=
operator|(
name|partition_pair_p
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|partition_pair_d
argument_list|)
argument_list|)
expr_stmt|;
name|node
operator|->
name|first_partition
operator|=
name|p1
expr_stmt|;
name|node
operator|->
name|second_partition
operator|=
name|p2
expr_stmt|;
name|node
operator|->
name|cost
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tmp
operator|!=
name|NULL
condition|)
block|{
name|node
operator|->
name|next
operator|=
name|tmp
operator|->
name|next
expr_stmt|;
name|tmp
operator|->
name|next
operator|=
name|node
expr_stmt|;
block|}
else|else
block|{
comment|/* This is now the first node in the list.  */
name|node
operator|->
name|next
operator|=
name|cl
operator|->
name|list
index|[
name|p1
index|]
expr_stmt|;
name|cl
operator|->
name|list
index|[
name|p1
index|]
operator|=
name|node
expr_stmt|;
block|}
return|return
name|node
return|;
block|}
end_function

begin_comment
comment|/* Return cost of execution of copy instruction with FREQUENCY    possibly on CRITICAL edge and in HOT basic block.  */
end_comment

begin_function
name|int
name|coalesce_cost
parameter_list|(
name|int
name|frequency
parameter_list|,
name|bool
name|hot
parameter_list|,
name|bool
name|critical
parameter_list|)
block|{
comment|/* Base costs on BB frequencies bounded by 1.  */
name|int
name|cost
init|=
name|frequency
decl_stmt|;
if|if
condition|(
operator|!
name|cost
condition|)
name|cost
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|optimize_size
operator|||
name|hot
condition|)
name|cost
operator|=
literal|1
expr_stmt|;
comment|/* Inserting copy on critical edge costs more      than inserting it elsewhere.  */
if|if
condition|(
name|critical
condition|)
name|cost
operator|*=
literal|2
expr_stmt|;
return|return
name|cost
return|;
block|}
end_function

begin_comment
comment|/* Add a potential coalesce between P1 and P2 in CL with a cost of VALUE.  */
end_comment

begin_function
name|void
name|add_coalesce
parameter_list|(
name|coalesce_list_p
name|cl
parameter_list|,
name|int
name|p1
parameter_list|,
name|int
name|p2
parameter_list|,
name|int
name|value
parameter_list|)
block|{
name|partition_pair_p
name|node
decl_stmt|;
name|gcc_assert
argument_list|(
name|cl
operator|->
name|add_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|p1
operator|==
name|p2
condition|)
return|return;
name|node
operator|=
name|find_partition_pair
argument_list|(
name|cl
argument_list|,
name|p1
argument_list|,
name|p2
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|node
operator|->
name|cost
operator|+=
name|value
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Comparison function to allow qsort to sort P1 and P2 in descending order.  */
end_comment

begin_function
specifier|static
name|int
name|compare_pairs
parameter_list|(
specifier|const
name|void
modifier|*
name|p1
parameter_list|,
specifier|const
name|void
modifier|*
name|p2
parameter_list|)
block|{
return|return
operator|(
operator|*
operator|(
name|partition_pair_p
operator|*
operator|)
name|p2
operator|)
operator|->
name|cost
operator|-
operator|(
operator|*
operator|(
name|partition_pair_p
operator|*
operator|)
name|p1
operator|)
operator|->
name|cost
return|;
block|}
end_function

begin_comment
comment|/* Prepare CL for removal of preferred pairs.  When finished, list element     0 has all the coalesce pairs, sorted in order from most important coalesce     to least important.  */
end_comment

begin_function
name|void
name|sort_coalesce_list
parameter_list|(
name|coalesce_list_p
name|cl
parameter_list|)
block|{
name|unsigned
name|x
decl_stmt|,
name|num
decl_stmt|,
name|count
decl_stmt|;
name|partition_pair_p
name|chain
decl_stmt|,
name|p
decl_stmt|;
name|partition_pair_p
modifier|*
name|list
decl_stmt|;
name|gcc_assert
argument_list|(
name|cl
operator|->
name|add_mode
argument_list|)
expr_stmt|;
name|cl
operator|->
name|add_mode
operator|=
name|false
expr_stmt|;
comment|/* Compact the array of lists to a single list, and count the elements.  */
name|num
operator|=
literal|0
expr_stmt|;
name|chain
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|num_var_partitions
argument_list|(
name|cl
operator|->
name|map
argument_list|)
condition|;
name|x
operator|++
control|)
if|if
condition|(
name|cl
operator|->
name|list
index|[
name|x
index|]
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|p
operator|=
name|cl
operator|->
name|list
index|[
name|x
index|]
init|;
name|p
operator|->
name|next
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
name|num
operator|++
expr_stmt|;
name|num
operator|++
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|chain
expr_stmt|;
name|chain
operator|=
name|cl
operator|->
name|list
index|[
name|x
index|]
expr_stmt|;
name|cl
operator|->
name|list
index|[
name|x
index|]
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Only call qsort if there are more than 2 items.  */
if|if
condition|(
name|num
operator|>
literal|2
condition|)
block|{
name|list
operator|=
name|XNEWVEC
argument_list|(
name|partition_pair_p
argument_list|,
name|num
argument_list|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|chain
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
name|list
index|[
name|count
operator|++
index|]
operator|=
name|p
expr_stmt|;
name|gcc_assert
argument_list|(
name|count
operator|==
name|num
argument_list|)
expr_stmt|;
name|qsort
argument_list|(
name|list
argument_list|,
name|count
argument_list|,
sizeof|sizeof
argument_list|(
name|partition_pair_p
argument_list|)
argument_list|,
name|compare_pairs
argument_list|)
expr_stmt|;
name|p
operator|=
name|list
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|1
init|;
name|x
operator|<
name|num
condition|;
name|x
operator|++
control|)
block|{
name|p
operator|->
name|next
operator|=
name|list
index|[
name|x
index|]
expr_stmt|;
name|p
operator|=
name|list
index|[
name|x
index|]
expr_stmt|;
block|}
name|p
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|cl
operator|->
name|list
index|[
literal|0
index|]
operator|=
name|list
index|[
literal|0
index|]
expr_stmt|;
name|free
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cl
operator|->
name|list
index|[
literal|0
index|]
operator|=
name|chain
expr_stmt|;
if|if
condition|(
name|num
operator|==
literal|2
condition|)
block|{
comment|/* Simply swap the two elements if they are in the wrong order.  */
if|if
condition|(
name|chain
operator|->
name|cost
operator|<
name|chain
operator|->
name|next
operator|->
name|cost
condition|)
block|{
name|cl
operator|->
name|list
index|[
literal|0
index|]
operator|=
name|chain
operator|->
name|next
expr_stmt|;
name|cl
operator|->
name|list
index|[
literal|0
index|]
operator|->
name|next
operator|=
name|chain
expr_stmt|;
name|chain
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Retrieve the best remaining pair to coalesce from CL.  Returns the 2     partitions via P1 and P2.  Their calculated cost is returned by the function.    NO_BEST_COALESCE is returned if the coalesce list is empty.  */
end_comment

begin_function
specifier|static
name|int
name|pop_best_coalesce
parameter_list|(
name|coalesce_list_p
name|cl
parameter_list|,
name|int
modifier|*
name|p1
parameter_list|,
name|int
modifier|*
name|p2
parameter_list|)
block|{
name|partition_pair_p
name|node
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|cl
operator|->
name|add_mode
argument_list|)
expr_stmt|;
name|node
operator|=
name|cl
operator|->
name|list
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|node
condition|)
return|return
name|NO_BEST_COALESCE
return|;
name|cl
operator|->
name|list
index|[
literal|0
index|]
operator|=
name|node
operator|->
name|next
expr_stmt|;
operator|*
name|p1
operator|=
name|node
operator|->
name|first_partition
expr_stmt|;
operator|*
name|p2
operator|=
name|node
operator|->
name|second_partition
expr_stmt|;
name|ret
operator|=
name|node
operator|->
name|cost
expr_stmt|;
name|free
argument_list|(
name|node
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* If variable VAR is in a partition in MAP, add a conflict in GRAPH between     VAR and any other live partitions in VEC which are associated via TPA.      Reset the live bit in VEC.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|add_conflicts_if_valid
parameter_list|(
name|tpa_p
name|tpa
parameter_list|,
name|conflict_graph
name|graph
parameter_list|,
name|var_map
name|map
parameter_list|,
name|bitmap
name|vec
parameter_list|,
name|tree
name|var
parameter_list|)
block|{
name|int
name|p
decl_stmt|,
name|y
decl_stmt|,
name|first
decl_stmt|;
name|p
operator|=
name|var_to_partition
argument_list|(
name|map
argument_list|,
name|var
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NO_PARTITION
condition|)
block|{
name|bitmap_clear_bit
argument_list|(
name|vec
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|first
operator|=
name|tpa_find_tree
argument_list|(
name|tpa
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* If find returns nothing, this object isn't interesting.  */
if|if
condition|(
name|first
operator|==
name|TPA_NONE
condition|)
return|return;
comment|/* Only add interferences between objects in the same list.  */
for|for
control|(
name|y
operator|=
name|tpa_first_partition
argument_list|(
name|tpa
argument_list|,
name|first
argument_list|)
init|;
name|y
operator|!=
name|TPA_NONE
condition|;
name|y
operator|=
name|tpa_next_partition
argument_list|(
name|tpa
argument_list|,
name|y
argument_list|)
control|)
block|{
if|if
condition|(
name|bitmap_bit_p
argument_list|(
name|vec
argument_list|,
name|y
argument_list|)
condition|)
name|conflict_graph_add
argument_list|(
name|graph
argument_list|,
name|p
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Return a conflict graph for the information contained in LIVE_INFO.  Only    conflicts between items in the same TPA list are added.  If optional     coalesce list CL is passed in, any copies encountered are added.  */
end_comment

begin_function
name|conflict_graph
name|build_tree_conflict_graph
parameter_list|(
name|tree_live_info_p
name|liveinfo
parameter_list|,
name|tpa_p
name|tpa
parameter_list|,
name|coalesce_list_p
name|cl
parameter_list|)
block|{
name|conflict_graph
name|graph
decl_stmt|;
name|var_map
name|map
decl_stmt|;
name|bitmap
name|live
decl_stmt|;
name|unsigned
name|x
decl_stmt|,
name|y
decl_stmt|,
name|i
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|int
modifier|*
name|partition_link
decl_stmt|,
modifier|*
name|tpa_nodes
decl_stmt|;
name|VEC
argument_list|(
name|int
argument_list|,
name|heap
argument_list|)
operator|*
name|tpa_to_clear
expr_stmt|;
name|unsigned
name|l
decl_stmt|;
name|ssa_op_iter
name|iter
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
name|map
operator|=
name|live_var_map
argument_list|(
name|liveinfo
argument_list|)
expr_stmt|;
name|graph
operator|=
name|conflict_graph_new
argument_list|(
name|num_var_partitions
argument_list|(
name|map
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tpa_num_trees
argument_list|(
name|tpa
argument_list|)
operator|==
literal|0
condition|)
return|return
name|graph
return|;
name|live
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|partition_link
operator|=
name|XCNEWVEC
argument_list|(
name|int
argument_list|,
name|num_var_partitions
argument_list|(
name|map
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|tpa_nodes
operator|=
name|XCNEWVEC
argument_list|(
name|int
argument_list|,
name|tpa_num_trees
argument_list|(
name|tpa
argument_list|)
argument_list|)
expr_stmt|;
name|tpa_to_clear
operator|=
name|VEC_alloc
argument_list|(
name|int
argument_list|,
name|heap
argument_list|,
literal|50
argument_list|)
expr_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|block_stmt_iterator
name|bsi
decl_stmt|;
name|tree
name|phi
decl_stmt|;
name|int
name|idx
decl_stmt|;
comment|/* Start with live on exit temporaries.  */
name|bitmap_copy
argument_list|(
name|live
argument_list|,
name|live_on_exit
argument_list|(
name|liveinfo
argument_list|,
name|bb
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|bsi
operator|=
name|bsi_last
argument_list|(
name|bb
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|;
name|bsi_prev
argument_list|(
operator|&
name|bsi
argument_list|)
control|)
block|{
name|bool
name|is_a_copy
init|=
name|false
decl_stmt|;
name|tree
name|stmt
init|=
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
decl_stmt|;
comment|/* A copy between 2 partitions does not introduce an interference  	     by itself.  If they did, you would never be able to coalesce  	     two things which are copied.  If the two variables really do  	     conflict, they will conflict elsewhere in the program.   	      	     This is handled specially here since we may also be interested  	     in copies between real variables and SSA_NAME variables.  We may 	     be interested in trying to coalesce SSA_NAME variables with 	     root variables in some cases.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|MODIFY_EXPR
condition|)
block|{
name|tree
name|lhs
init|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|rhs
init|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|int
name|p1
decl_stmt|,
name|p2
decl_stmt|;
name|int
name|bit
decl_stmt|;
if|if
condition|(
name|DECL_P
argument_list|(
name|lhs
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|lhs
argument_list|)
operator|==
name|SSA_NAME
condition|)
name|p1
operator|=
name|var_to_partition
argument_list|(
name|map
argument_list|,
name|lhs
argument_list|)
expr_stmt|;
else|else
name|p1
operator|=
name|NO_PARTITION
expr_stmt|;
if|if
condition|(
name|DECL_P
argument_list|(
name|rhs
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|SSA_NAME
condition|)
name|p2
operator|=
name|var_to_partition
argument_list|(
name|map
argument_list|,
name|rhs
argument_list|)
expr_stmt|;
else|else
name|p2
operator|=
name|NO_PARTITION
expr_stmt|;
if|if
condition|(
name|p1
operator|!=
name|NO_PARTITION
operator|&&
name|p2
operator|!=
name|NO_PARTITION
condition|)
block|{
name|is_a_copy
operator|=
name|true
expr_stmt|;
name|bit
operator|=
name|bitmap_bit_p
argument_list|(
name|live
argument_list|,
name|p2
argument_list|)
expr_stmt|;
comment|/* If the RHS is live, make it not live while we add 		     the conflicts, then make it live again.  */
if|if
condition|(
name|bit
condition|)
name|bitmap_clear_bit
argument_list|(
name|live
argument_list|,
name|p2
argument_list|)
expr_stmt|;
name|add_conflicts_if_valid
argument_list|(
name|tpa
argument_list|,
name|graph
argument_list|,
name|map
argument_list|,
name|live
argument_list|,
name|lhs
argument_list|)
expr_stmt|;
if|if
condition|(
name|bit
condition|)
name|bitmap_set_bit
argument_list|(
name|live
argument_list|,
name|p2
argument_list|)
expr_stmt|;
if|if
condition|(
name|cl
condition|)
name|add_coalesce
argument_list|(
name|cl
argument_list|,
name|p1
argument_list|,
name|p2
argument_list|,
name|coalesce_cost
argument_list|(
name|bb
operator|->
name|frequency
argument_list|,
name|maybe_hot_bb_p
argument_list|(
name|bb
argument_list|)
argument_list|,
name|false
argument_list|)
argument_list|)
expr_stmt|;
name|set_if_valid
argument_list|(
name|map
argument_list|,
name|live
argument_list|,
name|rhs
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|is_a_copy
condition|)
block|{
name|tree
name|var
decl_stmt|;
name|FOR_EACH_SSA_TREE_OPERAND
argument_list|(
argument|var
argument_list|,
argument|stmt
argument_list|,
argument|iter
argument_list|,
argument|SSA_OP_DEF
argument_list|)
block|{
name|add_conflicts_if_valid
argument_list|(
name|tpa
argument_list|,
name|graph
argument_list|,
name|map
argument_list|,
name|live
argument_list|,
name|var
argument_list|)
expr_stmt|;
block|}
name|FOR_EACH_SSA_TREE_OPERAND
argument_list|(
argument|var
argument_list|,
argument|stmt
argument_list|,
argument|iter
argument_list|,
argument|SSA_OP_USE
argument_list|)
block|{
name|set_if_valid
argument_list|(
name|map
argument_list|,
name|live
argument_list|,
name|var
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* If result of a PHI is unused, then the loops over the statements 	 will not record any conflicts.  However, since the PHI node is  	 going to be translated out of SSA form we must record a conflict 	 between the result of the PHI and any variables with are live.  	 Otherwise the out-of-ssa translation may create incorrect code.  */
for|for
control|(
name|phi
operator|=
name|phi_nodes
argument_list|(
name|bb
argument_list|)
init|;
name|phi
condition|;
name|phi
operator|=
name|PHI_CHAIN
argument_list|(
name|phi
argument_list|)
control|)
block|{
name|tree
name|result
init|=
name|PHI_RESULT
argument_list|(
name|phi
argument_list|)
decl_stmt|;
name|int
name|p
init|=
name|var_to_partition
argument_list|(
name|map
argument_list|,
name|result
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|!=
name|NO_PARTITION
operator|&&
operator|!
name|bitmap_bit_p
argument_list|(
name|live
argument_list|,
name|p
argument_list|)
condition|)
name|add_conflicts_if_valid
argument_list|(
name|tpa
argument_list|,
name|graph
argument_list|,
name|map
argument_list|,
name|live
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
comment|/* Anything which is still live at this point interferes.   	 In order to implement this efficiently, only conflicts between 	 partitions which have the same TPA root need be added. 	 TPA roots which have been seen are tracked in 'tpa_nodes'.  A nonzero 	 entry points to an index into 'partition_link', which then indexes  	 into itself forming a linked list of partitions sharing a tpa root  	 which have been seen as live up to this point.  Since partitions start 	 at index zero, all entries in partition_link are (partition + 1).  	 Conflicts are added between the current partition and any already seen. 	 tpa_clear contains all the tpa_roots processed, and these are the only 	 entries which need to be zero'd out for a clean restart.  */
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|live
argument_list|,
literal|0
argument_list|,
argument|x
argument_list|,
argument|bi
argument_list|)
block|{
name|i
operator|=
name|tpa_find_tree
argument_list|(
name|tpa
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
operator|(
name|unsigned
operator|)
name|TPA_NONE
condition|)
block|{
name|int
name|start
init|=
name|tpa_nodes
index|[
name|i
index|]
decl_stmt|;
comment|/* If start is 0, a new root reference list is being started. 		 Register it to be cleared.  */
if|if
condition|(
operator|!
name|start
condition|)
name|VEC_safe_push
argument_list|(
name|int
argument_list|,
name|heap
argument_list|,
name|tpa_to_clear
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* Add interferences to other tpa members seen.  */
for|for
control|(
name|y
operator|=
name|start
init|;
name|y
operator|!=
literal|0
condition|;
name|y
operator|=
name|partition_link
index|[
name|y
index|]
control|)
name|conflict_graph_add
argument_list|(
name|graph
argument_list|,
name|x
argument_list|,
name|y
operator|-
literal|1
argument_list|)
expr_stmt|;
name|tpa_nodes
index|[
name|i
index|]
operator|=
name|x
operator|+
literal|1
expr_stmt|;
name|partition_link
index|[
name|x
operator|+
literal|1
index|]
operator|=
name|start
expr_stmt|;
block|}
block|}
comment|/* Now clear the used tpa root references.  */
for|for
control|(
name|l
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|int
argument_list|,
name|tpa_to_clear
argument_list|,
name|l
argument_list|,
name|idx
argument_list|)
condition|;
name|l
operator|++
control|)
name|tpa_nodes
index|[
name|idx
index|]
operator|=
literal|0
expr_stmt|;
name|VEC_truncate
argument_list|(
name|int
argument_list|,
name|tpa_to_clear
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|tpa_nodes
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|partition_link
argument_list|)
expr_stmt|;
name|VEC_free
argument_list|(
name|int
argument_list|,
name|heap
argument_list|,
name|tpa_to_clear
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|live
argument_list|)
expr_stmt|;
return|return
name|graph
return|;
block|}
end_function

begin_comment
comment|/* This routine will attempt to coalesce the elements in TPA subject to the    conflicts found in GRAPH.  If optional coalesce_list CL is provided,     only coalesces specified within the coalesce list are attempted.  Otherwise     an attempt is made to coalesce as many partitions within each TPA grouping     as possible.  If DEBUG is provided, debug output will be sent there.  */
end_comment

begin_function
name|void
name|coalesce_tpa_members
parameter_list|(
name|tpa_p
name|tpa
parameter_list|,
name|conflict_graph
name|graph
parameter_list|,
name|var_map
name|map
parameter_list|,
name|coalesce_list_p
name|cl
parameter_list|,
name|FILE
modifier|*
name|debug
parameter_list|)
block|{
name|int
name|x
decl_stmt|,
name|y
decl_stmt|,
name|z
decl_stmt|,
name|w
decl_stmt|;
name|tree
name|var
decl_stmt|,
name|tmp
decl_stmt|;
comment|/* Attempt to coalesce any items in a coalesce list.  */
if|if
condition|(
name|cl
condition|)
block|{
while|while
condition|(
name|pop_best_coalesce
argument_list|(
name|cl
argument_list|,
operator|&
name|x
argument_list|,
operator|&
name|y
argument_list|)
operator|!=
name|NO_BEST_COALESCE
condition|)
block|{
if|if
condition|(
name|debug
condition|)
block|{
name|fprintf
argument_list|(
name|debug
argument_list|,
literal|"Coalesce list: (%d)"
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|debug
argument_list|,
name|partition_to_var
argument_list|(
name|map
argument_list|,
name|x
argument_list|)
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|debug
argument_list|,
literal|"& (%d)"
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|debug
argument_list|,
name|partition_to_var
argument_list|(
name|map
argument_list|,
name|y
argument_list|)
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
block|}
name|w
operator|=
name|tpa_find_tree
argument_list|(
name|tpa
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|z
operator|=
name|tpa_find_tree
argument_list|(
name|tpa
argument_list|,
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|!=
name|z
operator|||
name|w
operator|==
name|TPA_NONE
operator|||
name|z
operator|==
name|TPA_NONE
condition|)
block|{
if|if
condition|(
name|debug
condition|)
block|{
if|if
condition|(
name|w
operator|!=
name|z
condition|)
name|fprintf
argument_list|(
name|debug
argument_list|,
literal|": Fail, Non-matching TPA's\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|TPA_NONE
condition|)
name|fprintf
argument_list|(
name|debug
argument_list|,
literal|": Fail %d non TPA.\n"
argument_list|,
name|x
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|debug
argument_list|,
literal|": Fail %d non TPA.\n"
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
name|var
operator|=
name|partition_to_var
argument_list|(
name|map
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|partition_to_var
argument_list|(
name|map
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|x
operator|=
name|var_to_partition
argument_list|(
name|map
argument_list|,
name|var
argument_list|)
expr_stmt|;
name|y
operator|=
name|var_to_partition
argument_list|(
name|map
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|debug
argument_list|,
literal|" [map: %d, %d] "
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|==
name|y
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|debug
argument_list|,
literal|": Already Coalesced.\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|conflict_graph_conflict_p
argument_list|(
name|graph
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
condition|)
block|{
name|z
operator|=
name|var_union
argument_list|(
name|map
argument_list|,
name|var
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|z
operator|==
name|NO_PARTITION
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|debug
argument_list|,
literal|": Unable to perform partition union.\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* z is the new combined partition. We need to remove the other 	         partition from the list. Set x to be that other partition.  */
if|if
condition|(
name|z
operator|==
name|x
condition|)
block|{
name|conflict_graph_merge_regs
argument_list|(
name|graph
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|w
operator|=
name|tpa_find_tree
argument_list|(
name|tpa
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|tpa_remove_partition
argument_list|(
name|tpa
argument_list|,
name|w
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|conflict_graph_merge_regs
argument_list|(
name|graph
argument_list|,
name|y
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|w
operator|=
name|tpa_find_tree
argument_list|(
name|tpa
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|tpa_remove_partition
argument_list|(
name|tpa
argument_list|,
name|w
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|debug
argument_list|,
literal|": Success -> %d\n"
argument_list|,
name|z
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|debug
argument_list|,
literal|": Fail due to conflict\n"
argument_list|)
expr_stmt|;
block|}
comment|/* If using a coalesce list, don't try to coalesce anything else.  */
return|return;
block|}
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|tpa_num_trees
argument_list|(
name|tpa
argument_list|)
condition|;
name|x
operator|++
control|)
block|{
while|while
condition|(
name|tpa_first_partition
argument_list|(
name|tpa
argument_list|,
name|x
argument_list|)
operator|!=
name|TPA_NONE
condition|)
block|{
name|int
name|p1
decl_stmt|,
name|p2
decl_stmt|;
comment|/* Coalesce first partition with anything that doesn't conflict.  */
name|y
operator|=
name|tpa_first_partition
argument_list|(
name|tpa
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|tpa_remove_partition
argument_list|(
name|tpa
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|var
operator|=
name|partition_to_var
argument_list|(
name|map
argument_list|,
name|y
argument_list|)
expr_stmt|;
comment|/* p1 is the partition representative to which y belongs.  */
name|p1
operator|=
name|var_to_partition
argument_list|(
name|map
argument_list|,
name|var
argument_list|)
expr_stmt|;
for|for
control|(
name|z
operator|=
name|tpa_next_partition
argument_list|(
name|tpa
argument_list|,
name|y
argument_list|)
init|;
name|z
operator|!=
name|TPA_NONE
condition|;
name|z
operator|=
name|tpa_next_partition
argument_list|(
name|tpa
argument_list|,
name|z
argument_list|)
control|)
block|{
name|tmp
operator|=
name|partition_to_var
argument_list|(
name|map
argument_list|,
name|z
argument_list|)
expr_stmt|;
comment|/* p2 is the partition representative to which z belongs.  */
name|p2
operator|=
name|var_to_partition
argument_list|(
name|map
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
block|{
name|fprintf
argument_list|(
name|debug
argument_list|,
literal|"Coalesce : "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|debug
argument_list|,
name|var
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|debug
argument_list|,
literal|"&"
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|debug
argument_list|,
name|tmp
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|debug
argument_list|,
literal|"  (%d ,%d)"
argument_list|,
name|p1
argument_list|,
name|p2
argument_list|)
expr_stmt|;
block|}
comment|/* If partitions are already merged, don't check for conflict.  */
if|if
condition|(
name|tmp
operator|==
name|var
condition|)
block|{
name|tpa_remove_partition
argument_list|(
name|tpa
argument_list|,
name|x
argument_list|,
name|z
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|debug
argument_list|,
literal|": Already coalesced\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|conflict_graph_conflict_p
argument_list|(
name|graph
argument_list|,
name|p1
argument_list|,
name|p2
argument_list|)
condition|)
block|{
name|int
name|v
decl_stmt|;
if|if
condition|(
name|tpa_find_tree
argument_list|(
name|tpa
argument_list|,
name|y
argument_list|)
operator|==
name|TPA_NONE
operator|||
name|tpa_find_tree
argument_list|(
name|tpa
argument_list|,
name|z
argument_list|)
operator|==
name|TPA_NONE
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|debug
argument_list|,
literal|": Fail non-TPA member\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|v
operator|=
name|var_union
argument_list|(
name|map
argument_list|,
name|var
argument_list|,
name|tmp
argument_list|)
operator|)
operator|==
name|NO_PARTITION
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|debug
argument_list|,
literal|": Fail cannot combine partitions\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|tpa_remove_partition
argument_list|(
name|tpa
argument_list|,
name|x
argument_list|,
name|z
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|==
name|p1
condition|)
name|conflict_graph_merge_regs
argument_list|(
name|graph
argument_list|,
name|v
argument_list|,
name|z
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Update the first partition's representative.  */
name|conflict_graph_merge_regs
argument_list|(
name|graph
argument_list|,
name|v
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|p1
operator|=
name|v
expr_stmt|;
block|}
comment|/* The root variable of the partition may be changed 		       now.  */
name|var
operator|=
name|partition_to_var
argument_list|(
name|map
argument_list|,
name|p1
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|debug
argument_list|,
literal|": Success -> %d\n"
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|debug
argument_list|,
literal|": Fail, Conflict\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Send debug info for coalesce list CL to file F.  */
end_comment

begin_function
name|void
name|dump_coalesce_list
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|,
name|coalesce_list_p
name|cl
parameter_list|)
block|{
name|partition_pair_p
name|node
decl_stmt|;
name|int
name|x
decl_stmt|,
name|num
decl_stmt|;
name|tree
name|var
decl_stmt|;
if|if
condition|(
name|cl
operator|->
name|add_mode
condition|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"Coalesce List:\n"
argument_list|)
expr_stmt|;
name|num
operator|=
name|num_var_partitions
argument_list|(
name|cl
operator|->
name|map
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|num
condition|;
name|x
operator|++
control|)
block|{
name|node
operator|=
name|cl
operator|->
name|list
index|[
name|x
index|]
expr_stmt|;
if|if
condition|(
name|node
condition|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"["
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|f
argument_list|,
name|partition_to_var
argument_list|(
name|cl
operator|->
name|map
argument_list|,
name|x
argument_list|)
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"] - "
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
block|{
name|var
operator|=
name|partition_to_var
argument_list|(
name|cl
operator|->
name|map
argument_list|,
name|node
operator|->
name|second_partition
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|f
argument_list|,
name|var
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"(%1d), "
argument_list|,
name|node
operator|->
name|cost
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"Sorted Coalesce list:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|node
operator|=
name|cl
operator|->
name|list
index|[
literal|0
index|]
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"(%d) "
argument_list|,
name|node
operator|->
name|cost
argument_list|)
expr_stmt|;
name|var
operator|=
name|partition_to_var
argument_list|(
name|cl
operator|->
name|map
argument_list|,
name|node
operator|->
name|first_partition
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|f
argument_list|,
name|var
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|" : "
argument_list|)
expr_stmt|;
name|var
operator|=
name|partition_to_var
argument_list|(
name|cl
operator|->
name|map
argument_list|,
name|node
operator|->
name|second_partition
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|f
argument_list|,
name|var
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Output tree_partition_associator object TPA to file F..  */
end_comment

begin_function
name|void
name|tpa_dump
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|,
name|tpa_p
name|tpa
parameter_list|)
block|{
name|int
name|x
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|tpa
condition|)
return|return;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|tpa_num_trees
argument_list|(
name|tpa
argument_list|)
condition|;
name|x
operator|++
control|)
block|{
name|print_generic_expr
argument_list|(
name|f
argument_list|,
name|tpa_tree
argument_list|(
name|tpa
argument_list|,
name|x
argument_list|)
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|" : ("
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|tpa_first_partition
argument_list|(
name|tpa
argument_list|,
name|x
argument_list|)
init|;
name|i
operator|!=
name|TPA_NONE
condition|;
name|i
operator|=
name|tpa_next_partition
argument_list|(
name|tpa
argument_list|,
name|i
argument_list|)
control|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"(%d)"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|f
argument_list|,
name|partition_to_var
argument_list|(
name|tpa
operator|->
name|map
argument_list|,
name|i
argument_list|)
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
if|if
condition|(
name|tpa_find_tree
argument_list|(
name|tpa
argument_list|,
name|i
argument_list|)
operator|!=
name|x
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"**find tree incorrectly set** "
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|fprintf
argument_list|(
name|f
argument_list|,
literal|")\n"
argument_list|)
expr_stmt|;
block|}
name|fflush
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output partition map MAP to file F.  */
end_comment

begin_function
name|void
name|dump_var_map
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|,
name|var_map
name|map
parameter_list|)
block|{
name|int
name|t
decl_stmt|;
name|unsigned
name|x
decl_stmt|,
name|y
decl_stmt|;
name|int
name|p
decl_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\nPartition map \n\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|map
operator|->
name|num_partitions
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
name|map
operator|->
name|compact_to_partition
operator|!=
name|NULL
condition|)
name|p
operator|=
name|map
operator|->
name|compact_to_partition
index|[
name|x
index|]
expr_stmt|;
else|else
name|p
operator|=
name|x
expr_stmt|;
if|if
condition|(
name|map
operator|->
name|partition_to_var
index|[
name|p
index|]
operator|==
name|NULL_TREE
condition|)
continue|continue;
name|t
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|y
operator|=
literal|1
init|;
name|y
operator|<
name|num_ssa_names
condition|;
name|y
operator|++
control|)
block|{
name|p
operator|=
name|partition_find
argument_list|(
name|map
operator|->
name|var_partition
argument_list|,
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|map
operator|->
name|partition_to_compact
condition|)
name|p
operator|=
name|map
operator|->
name|partition_to_compact
index|[
name|p
index|]
expr_stmt|;
if|if
condition|(
name|p
operator|==
operator|(
name|int
operator|)
name|x
condition|)
block|{
if|if
condition|(
name|t
operator|++
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"Partition %d ("
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|f
argument_list|,
name|partition_to_var
argument_list|(
name|map
argument_list|,
name|p
argument_list|)
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|" - "
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%d "
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|t
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|")\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output live range info LIVE to file F, controlled by FLAG.  */
end_comment

begin_function
name|void
name|dump_live_info
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|,
name|tree_live_info_p
name|live
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|var_map
name|map
init|=
name|live
operator|->
name|map
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
if|if
condition|(
operator|(
name|flag
operator|&
name|LIVEDUMP_ENTRY
operator|)
operator|&&
name|live
operator|->
name|livein
condition|)
block|{
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\nLive on entry to BB%d : "
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_var_partitions
argument_list|(
name|map
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|bitmap_bit_p
argument_list|(
name|live_entry_blocks
argument_list|(
name|live
argument_list|,
name|i
argument_list|)
argument_list|,
name|bb
operator|->
name|index
argument_list|)
condition|)
block|{
name|print_generic_expr
argument_list|(
name|f
argument_list|,
name|partition_to_var
argument_list|(
name|map
argument_list|,
name|i
argument_list|)
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"  "
argument_list|)
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|flag
operator|&
name|LIVEDUMP_EXIT
operator|)
operator|&&
name|live
operator|->
name|liveout
condition|)
block|{
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\nLive on exit from BB%d : "
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|live->liveout[bb->index]
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|bi
argument_list|)
block|{
name|print_generic_expr
argument_list|(
name|f
argument_list|,
name|partition_to_var
argument_list|(
name|map
argument_list|,
name|i
argument_list|)
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"  "
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
end_ifdef

begin_function
name|void
name|register_ssa_partition_check
parameter_list|(
name|tree
name|ssa_var
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|ssa_var
argument_list|)
operator|==
name|SSA_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_gimple_reg
argument_list|(
name|SSA_NAME_VAR
argument_list|(
name|ssa_var
argument_list|)
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Illegally registering a virtual SSA name :"
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|stderr
argument_list|,
name|ssa_var
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" in the SSA->Normal phase.\n"
argument_list|)
expr_stmt|;
name|internal_error
argument_list|(
literal|"SSA corruption"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

