begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Generic dominator tree walker    Copyright (C) 2003, 2004, 2005 Free Software Foundation, Inc.    Contributed by Diego Novillo<dnovillo@redhat.com>  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"tree-flow.h"
end_include

begin_include
include|#
directive|include
file|"domwalk.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_comment
comment|/* This file implements a generic walker for dominator trees.     To understand the dominator walker one must first have a grasp of dominators,   immediate dominators and the dominator tree.    Dominators     A block B1 is said to dominate B2 if every path from the entry to B2 must     pass through B1.  Given the dominance relationship, we can proceed to     compute immediate dominators.  Note it is not important whether or not     our definition allows a block to dominate itself.    Immediate Dominators:     Every block in the CFG has no more than one immediate dominator.  The     immediate dominator of block BB must dominate BB and must not dominate     any other dominator of BB and must not be BB itself.    Dominator tree:     If we then construct a tree where each node is a basic block and there     is an edge from each block's immediate dominator to the block itself, then     we have a dominator tree.     [ Note this walker can also walk the post-dominator tree, which is     defined in a similar manner.  i.e., block B1 is said to post-dominate     block B2 if all paths from B2 to the exit block must pass through     B1.  ]    For example, given the CFG                     1                    |                    2                   / \                  3   4                     / \        +---------->5   6        |          / \ /        |    +--->8   7        |    |   /    |        |    +--9    11        |      /      |        +--- 10 ---> 12 	        We have a dominator tree which looks like                     1                    |                    2                   / \                  /   \                 3     4                    / / \ \                    | | | |                    5 6 7 12                    |   |                    8   11                    |                    9                    |                   10            The dominator tree is the basis for a number of analysis, transformation   and optimization algorithms that operate on a semi-global basis.      The dominator walker is a generic routine which visits blocks in the CFG   via a depth first search of the dominator tree.  In the example above   the dominator walker might visit blocks in the following order   1, 2, 3, 4, 5, 8, 9, 10, 6, 7, 11, 12.      The dominator walker has a number of callbacks to perform actions   during the walk of the dominator tree.  There are two callbacks   which walk statements, one before visiting the dominator children,   one after visiting the dominator children.  There is a callback    before and after each statement walk callback.  In addition, the   dominator walker manages allocation/deallocation of data structures   which are local to each block visited.      The dominator walker is meant to provide a generic means to build a pass   which can analyze or transform/optimize a function based on walking   the dominator tree.  One simply fills in the dominator walker data   structure with the appropriate callbacks and calls the walker.      We currently use the dominator walker to prune the set of variables   which might need PHI nodes (which can greatly improve compile-time   performance in some cases).      We also use the dominator walker to rewrite the function into SSA form   which reduces code duplication since the rewriting phase is inherently   a walk of the dominator tree.    And (of course), we use the dominator walker to drive a our dominator   optimizer, which is a semi-global optimizer.    TODO:      Walking statements is based on the block statement iterator abstraction,     which is currently an abstraction over walking tree statements.  Thus     the dominator walker is currently only useful for trees.  */
end_comment

begin_comment
comment|/* Recursively walk the dominator tree.     WALK_DATA contains a set of callbacks to perform pass-specific    actions during the dominator walk as well as a stack of block local    data maintained during the dominator walk.     BB is the basic block we are currently visiting.  */
end_comment

begin_function
name|void
name|walk_dominator_tree
parameter_list|(
name|struct
name|dom_walk_data
modifier|*
name|walk_data
parameter_list|,
name|basic_block
name|bb
parameter_list|)
block|{
name|void
modifier|*
name|bd
init|=
name|NULL
decl_stmt|;
name|basic_block
name|dest
decl_stmt|;
name|block_stmt_iterator
name|bsi
decl_stmt|;
name|bool
name|is_interesting
decl_stmt|;
name|basic_block
modifier|*
name|worklist
init|=
name|XNEWVEC
argument_list|(
name|basic_block
argument_list|,
name|n_basic_blocks
operator|*
literal|2
argument_list|)
decl_stmt|;
name|int
name|sp
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|true
condition|)
block|{
comment|/* Don't worry about unreachable blocks.  */
if|if
condition|(
name|EDGE_COUNT
argument_list|(
name|bb
operator|->
name|preds
argument_list|)
operator|>
literal|0
operator|||
name|bb
operator|==
name|ENTRY_BLOCK_PTR
condition|)
block|{
comment|/* If block BB is not interesting to the caller, then none of the 	     callbacks that walk the statements in BB are going to be 	     executed.  */
name|is_interesting
operator|=
name|walk_data
operator|->
name|interesting_blocks
operator|==
name|NULL
operator|||
name|TEST_BIT
argument_list|(
name|walk_data
operator|->
name|interesting_blocks
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
comment|/* Callback to initialize the local data structure.  */
if|if
condition|(
name|walk_data
operator|->
name|initialize_block_local_data
condition|)
block|{
name|bool
name|recycled
decl_stmt|;
comment|/* First get some local data, reusing any local data pointer we may 	         have saved.  */
if|if
condition|(
name|VEC_length
argument_list|(
name|void_p
argument_list|,
name|walk_data
operator|->
name|free_block_data
argument_list|)
operator|>
literal|0
condition|)
block|{
name|bd
operator|=
name|VEC_pop
argument_list|(
name|void_p
argument_list|,
name|walk_data
operator|->
name|free_block_data
argument_list|)
expr_stmt|;
name|recycled
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|bd
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
name|walk_data
operator|->
name|block_local_data_size
argument_list|)
expr_stmt|;
name|recycled
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Push the local data into the local data stack.  */
name|VEC_safe_push
argument_list|(
name|void_p
argument_list|,
name|heap
argument_list|,
name|walk_data
operator|->
name|block_data_stack
argument_list|,
name|bd
argument_list|)
expr_stmt|;
comment|/* Call the initializer.  */
name|walk_data
operator|->
name|initialize_block_local_data
argument_list|(
name|walk_data
argument_list|,
name|bb
argument_list|,
name|recycled
argument_list|)
expr_stmt|;
block|}
comment|/* Callback for operations to execute before we have walked the 	     dominator children, but before we walk statements.  */
if|if
condition|(
name|walk_data
operator|->
name|before_dom_children_before_stmts
condition|)
call|(
modifier|*
name|walk_data
operator|->
name|before_dom_children_before_stmts
call|)
argument_list|(
name|walk_data
argument_list|,
name|bb
argument_list|)
expr_stmt|;
comment|/* Statement walk before walking dominator children.  */
if|if
condition|(
name|is_interesting
operator|&&
name|walk_data
operator|->
name|before_dom_children_walk_stmts
condition|)
block|{
if|if
condition|(
name|walk_data
operator|->
name|walk_stmts_backward
condition|)
for|for
control|(
name|bsi
operator|=
name|bsi_last
argument_list|(
name|bb
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|;
name|bsi_prev
argument_list|(
operator|&
name|bsi
argument_list|)
control|)
call|(
modifier|*
name|walk_data
operator|->
name|before_dom_children_walk_stmts
call|)
argument_list|(
name|walk_data
argument_list|,
name|bb
argument_list|,
name|bsi
argument_list|)
expr_stmt|;
else|else
for|for
control|(
name|bsi
operator|=
name|bsi_start
argument_list|(
name|bb
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|;
name|bsi_next
argument_list|(
operator|&
name|bsi
argument_list|)
control|)
call|(
modifier|*
name|walk_data
operator|->
name|before_dom_children_walk_stmts
call|)
argument_list|(
name|walk_data
argument_list|,
name|bb
argument_list|,
name|bsi
argument_list|)
expr_stmt|;
block|}
comment|/* Callback for operations to execute before we have walked the 	     dominator children, and after we walk statements.  */
if|if
condition|(
name|walk_data
operator|->
name|before_dom_children_after_stmts
condition|)
call|(
modifier|*
name|walk_data
operator|->
name|before_dom_children_after_stmts
call|)
argument_list|(
name|walk_data
argument_list|,
name|bb
argument_list|)
expr_stmt|;
comment|/* Mark the current BB to be popped out of the recursion stack 	     once childs are processed.  */
name|worklist
index|[
name|sp
operator|++
index|]
operator|=
name|bb
expr_stmt|;
name|worklist
index|[
name|sp
operator|++
index|]
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|dest
operator|=
name|first_dom_son
argument_list|(
name|walk_data
operator|->
name|dom_direction
argument_list|,
name|bb
argument_list|)
init|;
name|dest
condition|;
name|dest
operator|=
name|next_dom_son
argument_list|(
name|walk_data
operator|->
name|dom_direction
argument_list|,
name|dest
argument_list|)
control|)
name|worklist
index|[
name|sp
operator|++
index|]
operator|=
name|dest
expr_stmt|;
block|}
comment|/* NULL is used to signalize pop operation in recursion stack.  */
while|while
condition|(
name|sp
operator|>
literal|0
operator|&&
operator|!
name|worklist
index|[
name|sp
operator|-
literal|1
index|]
condition|)
block|{
operator|--
name|sp
expr_stmt|;
name|bb
operator|=
name|worklist
index|[
operator|--
name|sp
index|]
expr_stmt|;
name|is_interesting
operator|=
name|walk_data
operator|->
name|interesting_blocks
operator|==
name|NULL
operator|||
name|TEST_BIT
argument_list|(
name|walk_data
operator|->
name|interesting_blocks
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
comment|/* Callback for operations to execute after we have walked the 	     dominator children, but before we walk statements.  */
if|if
condition|(
name|walk_data
operator|->
name|after_dom_children_before_stmts
condition|)
call|(
modifier|*
name|walk_data
operator|->
name|after_dom_children_before_stmts
call|)
argument_list|(
name|walk_data
argument_list|,
name|bb
argument_list|)
expr_stmt|;
comment|/* Statement walk after walking dominator children.  */
if|if
condition|(
name|is_interesting
operator|&&
name|walk_data
operator|->
name|after_dom_children_walk_stmts
condition|)
block|{
if|if
condition|(
name|walk_data
operator|->
name|walk_stmts_backward
condition|)
for|for
control|(
name|bsi
operator|=
name|bsi_last
argument_list|(
name|bb
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|;
name|bsi_prev
argument_list|(
operator|&
name|bsi
argument_list|)
control|)
call|(
modifier|*
name|walk_data
operator|->
name|after_dom_children_walk_stmts
call|)
argument_list|(
name|walk_data
argument_list|,
name|bb
argument_list|,
name|bsi
argument_list|)
expr_stmt|;
else|else
for|for
control|(
name|bsi
operator|=
name|bsi_start
argument_list|(
name|bb
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|;
name|bsi_next
argument_list|(
operator|&
name|bsi
argument_list|)
control|)
call|(
modifier|*
name|walk_data
operator|->
name|after_dom_children_walk_stmts
call|)
argument_list|(
name|walk_data
argument_list|,
name|bb
argument_list|,
name|bsi
argument_list|)
expr_stmt|;
block|}
comment|/* Callback for operations to execute after we have walked the 	     dominator children and after we have walked statements.  */
if|if
condition|(
name|walk_data
operator|->
name|after_dom_children_after_stmts
condition|)
call|(
modifier|*
name|walk_data
operator|->
name|after_dom_children_after_stmts
call|)
argument_list|(
name|walk_data
argument_list|,
name|bb
argument_list|)
expr_stmt|;
if|if
condition|(
name|walk_data
operator|->
name|initialize_block_local_data
condition|)
block|{
comment|/* And finally pop the record off the block local data stack.  */
name|bd
operator|=
name|VEC_pop
argument_list|(
name|void_p
argument_list|,
name|walk_data
operator|->
name|block_data_stack
argument_list|)
expr_stmt|;
comment|/* And save the block data so that we can re-use it.  */
name|VEC_safe_push
argument_list|(
name|void_p
argument_list|,
name|heap
argument_list|,
name|walk_data
operator|->
name|free_block_data
argument_list|,
name|bd
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sp
condition|)
name|bb
operator|=
name|worklist
index|[
operator|--
name|sp
index|]
expr_stmt|;
else|else
break|break;
block|}
name|free
argument_list|(
name|worklist
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|init_walk_dominator_tree
parameter_list|(
name|struct
name|dom_walk_data
modifier|*
name|walk_data
parameter_list|)
block|{
name|walk_data
operator|->
name|free_block_data
operator|=
name|NULL
expr_stmt|;
name|walk_data
operator|->
name|block_data_stack
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|void
name|fini_walk_dominator_tree
parameter_list|(
name|struct
name|dom_walk_data
modifier|*
name|walk_data
parameter_list|)
block|{
if|if
condition|(
name|walk_data
operator|->
name|initialize_block_local_data
condition|)
block|{
while|while
condition|(
name|VEC_length
argument_list|(
name|void_p
argument_list|,
name|walk_data
operator|->
name|free_block_data
argument_list|)
operator|>
literal|0
condition|)
name|free
argument_list|(
name|VEC_pop
argument_list|(
name|void_p
argument_list|,
name|walk_data
operator|->
name|free_block_data
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|VEC_free
argument_list|(
name|void_p
argument_list|,
name|heap
argument_list|,
name|walk_data
operator|->
name|free_block_data
argument_list|)
expr_stmt|;
name|VEC_free
argument_list|(
name|void_p
argument_list|,
name|heap
argument_list|,
name|walk_data
operator|->
name|block_data_stack
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

