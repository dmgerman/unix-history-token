begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Control flow graph manipulation code for GNU compiler.    Copyright (C) 1987, 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2000, 2001 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* This file contains low level functions to manipulate the CFG and    analyze it.  All other modules should not transform the datastructure    directly and use abstraction instead.  The file is supposed to be    ordered bottom-up and should not contain any code dependent on a    particular intermediate language (RTL or trees).     Available functionality:      - Initialization/deallocation 	 init_flow, clear_edges      - Low level basic block manipulation 	 alloc_block, expunge_block      - Edge manipulation 	 make_edge, make_single_succ_edge, cached_make_edge, remove_edge 	 - Low level edge redirection (without updating instruction chain) 	     redirect_edge_succ, redirect_edge_succ_nodup, redirect_edge_pred      - Dumping and debugging 	 dump_flow_info, debug_flow_info, dump_edge_info      - Allocation of AUX fields for basic blocks 	 alloc_aux_for_blocks, free_aux_for_blocks, alloc_aux_for_block  */
end_comment

begin_escape
end_escape

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_comment
comment|/* The obstack on which the flow graph components are allocated.  */
end_comment

begin_decl_stmt
name|struct
name|obstack
name|flow_obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|flow_firstobj
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of basic blocks in the current function.  */
end_comment

begin_decl_stmt
name|int
name|n_basic_blocks
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of edges in the current function.  */
end_comment

begin_decl_stmt
name|int
name|n_edges
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* First edge in the deleted edges chain.  */
end_comment

begin_decl_stmt
name|edge
name|first_deleted_edge
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|basic_block
name|first_deleted_block
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The basic block array.  */
end_comment

begin_decl_stmt
name|varray_type
name|basic_block_info
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The special entry and exit blocks.  */
end_comment

begin_decl_stmt
name|struct
name|basic_block_def
name|entry_exit_blocks
index|[
literal|2
index|]
init|=
block|{
block|{
name|NULL
block|,
comment|/* head */
name|NULL
block|,
comment|/* end */
name|NULL
block|,
comment|/* head_tree */
name|NULL
block|,
comment|/* end_tree */
name|NULL
block|,
comment|/* pred */
name|NULL
block|,
comment|/* succ */
name|NULL
block|,
comment|/* local_set */
name|NULL
block|,
comment|/* cond_local_set */
name|NULL
block|,
comment|/* global_live_at_start */
name|NULL
block|,
comment|/* global_live_at_end */
name|NULL
block|,
comment|/* aux */
name|ENTRY_BLOCK
block|,
comment|/* index */
literal|0
block|,
comment|/* loop_depth */
literal|0
block|,
comment|/* count */
literal|0
block|,
comment|/* frequency */
literal|0
comment|/* flags */
block|}
block|,
block|{
name|NULL
block|,
comment|/* head */
name|NULL
block|,
comment|/* end */
name|NULL
block|,
comment|/* head_tree */
name|NULL
block|,
comment|/* end_tree */
name|NULL
block|,
comment|/* pred */
name|NULL
block|,
comment|/* succ */
name|NULL
block|,
comment|/* local_set */
name|NULL
block|,
comment|/* cond_local_set */
name|NULL
block|,
comment|/* global_live_at_start */
name|NULL
block|,
comment|/* global_live_at_end */
name|NULL
block|,
comment|/* aux */
name|EXIT_BLOCK
block|,
comment|/* index */
literal|0
block|,
comment|/* loop_depth */
literal|0
block|,
comment|/* count */
literal|0
block|,
comment|/* frequency */
literal|0
comment|/* flags */
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|debug_flow_info
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|free_edge
name|PARAMS
argument_list|(
operator|(
name|edge
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Called once at initialization time.  */
end_comment

begin_function
name|void
name|init_flow
parameter_list|()
block|{
specifier|static
name|int
name|initialized
decl_stmt|;
name|first_deleted_edge
operator|=
literal|0
expr_stmt|;
name|first_deleted_block
operator|=
literal|0
expr_stmt|;
name|n_edges
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|initialized
condition|)
block|{
name|gcc_obstack_init
argument_list|(
operator|&
name|flow_obstack
argument_list|)
expr_stmt|;
name|flow_firstobj
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|flow_obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|initialized
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|obstack_free
argument_list|(
operator|&
name|flow_obstack
argument_list|,
name|flow_firstobj
argument_list|)
expr_stmt|;
name|flow_firstobj
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|flow_obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Helper function for remove_edge and clear_edges.  Frees edge structure    without actually unlinking it from the pred/succ lists.  */
end_comment

begin_function
specifier|static
name|void
name|free_edge
parameter_list|(
name|e
parameter_list|)
name|edge
name|e
decl_stmt|;
block|{
name|n_edges
operator|--
expr_stmt|;
name|memset
argument_list|(
name|e
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|e
argument_list|)
expr_stmt|;
name|e
operator|->
name|succ_next
operator|=
name|first_deleted_edge
expr_stmt|;
name|first_deleted_edge
operator|=
name|e
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Free the memory associated with the edge structures.  */
end_comment

begin_function
name|void
name|clear_edges
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|edge
name|e
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
operator|++
name|i
control|)
block|{
name|basic_block
name|bb
init|=
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|edge
name|e
init|=
name|bb
operator|->
name|succ
decl_stmt|;
while|while
condition|(
name|e
condition|)
block|{
name|edge
name|next
init|=
name|e
operator|->
name|succ_next
decl_stmt|;
name|free_edge
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|e
operator|=
name|next
expr_stmt|;
block|}
name|bb
operator|->
name|succ
operator|=
name|NULL
expr_stmt|;
name|bb
operator|->
name|pred
operator|=
name|NULL
expr_stmt|;
block|}
name|e
operator|=
name|ENTRY_BLOCK_PTR
operator|->
name|succ
expr_stmt|;
while|while
condition|(
name|e
condition|)
block|{
name|edge
name|next
init|=
name|e
operator|->
name|succ_next
decl_stmt|;
name|free_edge
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|e
operator|=
name|next
expr_stmt|;
block|}
name|EXIT_BLOCK_PTR
operator|->
name|pred
operator|=
name|NULL
expr_stmt|;
name|ENTRY_BLOCK_PTR
operator|->
name|succ
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|n_edges
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Allocate memory for basic_block.  */
end_comment

begin_function
name|basic_block
name|alloc_block
parameter_list|()
block|{
name|basic_block
name|bb
decl_stmt|;
if|if
condition|(
name|first_deleted_block
condition|)
block|{
name|bb
operator|=
name|first_deleted_block
expr_stmt|;
name|first_deleted_block
operator|=
operator|(
name|basic_block
operator|)
name|bb
operator|->
name|succ
expr_stmt|;
name|bb
operator|->
name|succ
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|bb
operator|=
operator|(
name|basic_block
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|flow_obstack
argument_list|,
sizeof|sizeof
expr|*
name|bb
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|bb
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|bb
argument_list|)
expr_stmt|;
block|}
return|return
name|bb
return|;
block|}
end_function

begin_comment
comment|/* Remove block B from the basic block array and compact behind it.  */
end_comment

begin_function
name|void
name|expunge_block
parameter_list|(
name|b
parameter_list|)
name|basic_block
name|b
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|n
init|=
name|n_basic_blocks
decl_stmt|;
for|for
control|(
name|i
operator|=
name|b
operator|->
name|index
init|;
name|i
operator|+
literal|1
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
name|basic_block
name|x
init|=
name|BASIC_BLOCK
argument_list|(
name|i
operator|+
literal|1
argument_list|)
decl_stmt|;
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
operator|=
name|x
expr_stmt|;
name|x
operator|->
name|index
operator|=
name|i
expr_stmt|;
block|}
comment|/* Invalidate data to make bughunting easier.  */
name|memset
argument_list|(
name|b
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|b
argument_list|)
expr_stmt|;
name|b
operator|->
name|index
operator|=
operator|-
literal|3
expr_stmt|;
name|basic_block_info
operator|->
name|num_elements
operator|--
expr_stmt|;
name|n_basic_blocks
operator|--
expr_stmt|;
name|b
operator|->
name|succ
operator|=
operator|(
name|edge
operator|)
name|first_deleted_block
expr_stmt|;
name|first_deleted_block
operator|=
operator|(
name|basic_block
operator|)
name|b
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Create an edge connecting SRC and DST with FLAGS optionally using    edge cache CACHE.  Return the new edge, NULL if already exist.  */
end_comment

begin_function
name|edge
name|cached_make_edge
parameter_list|(
name|edge_cache
parameter_list|,
name|src
parameter_list|,
name|dst
parameter_list|,
name|flags
parameter_list|)
name|sbitmap
modifier|*
name|edge_cache
decl_stmt|;
name|basic_block
name|src
decl_stmt|,
name|dst
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|int
name|use_edge_cache
decl_stmt|;
name|edge
name|e
decl_stmt|;
comment|/* Don't bother with edge cache for ENTRY or EXIT, if there aren't that      many edges to them, or we didn't allocate memory for it.  */
name|use_edge_cache
operator|=
operator|(
name|edge_cache
operator|&&
name|src
operator|!=
name|ENTRY_BLOCK_PTR
operator|&&
name|dst
operator|!=
name|EXIT_BLOCK_PTR
operator|)
expr_stmt|;
comment|/* Make sure we don't add duplicate edges.  */
switch|switch
condition|(
name|use_edge_cache
condition|)
block|{
default|default:
comment|/* Quick test for non-existence of the edge.  */
if|if
condition|(
operator|!
name|TEST_BIT
argument_list|(
name|edge_cache
index|[
name|src
operator|->
name|index
index|]
argument_list|,
name|dst
operator|->
name|index
argument_list|)
condition|)
break|break;
comment|/* The edge exists; early exit if no work to do.  */
if|if
condition|(
name|flags
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
comment|/* FALLTHRU */
case|case
literal|0
case|:
for|for
control|(
name|e
operator|=
name|src
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
if|if
condition|(
name|e
operator|->
name|dest
operator|==
name|dst
condition|)
block|{
name|e
operator|->
name|flags
operator||=
name|flags
expr_stmt|;
return|return
name|NULL
return|;
block|}
break|break;
block|}
if|if
condition|(
name|first_deleted_edge
condition|)
block|{
name|e
operator|=
name|first_deleted_edge
expr_stmt|;
name|first_deleted_edge
operator|=
name|e
operator|->
name|succ_next
expr_stmt|;
block|}
else|else
block|{
name|e
operator|=
operator|(
name|edge
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|flow_obstack
argument_list|,
sizeof|sizeof
expr|*
name|e
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|e
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|e
argument_list|)
expr_stmt|;
block|}
name|n_edges
operator|++
expr_stmt|;
name|e
operator|->
name|succ_next
operator|=
name|src
operator|->
name|succ
expr_stmt|;
name|e
operator|->
name|pred_next
operator|=
name|dst
operator|->
name|pred
expr_stmt|;
name|e
operator|->
name|src
operator|=
name|src
expr_stmt|;
name|e
operator|->
name|dest
operator|=
name|dst
expr_stmt|;
name|e
operator|->
name|flags
operator|=
name|flags
expr_stmt|;
name|src
operator|->
name|succ
operator|=
name|e
expr_stmt|;
name|dst
operator|->
name|pred
operator|=
name|e
expr_stmt|;
if|if
condition|(
name|use_edge_cache
condition|)
name|SET_BIT
argument_list|(
name|edge_cache
index|[
name|src
operator|->
name|index
index|]
argument_list|,
name|dst
operator|->
name|index
argument_list|)
expr_stmt|;
return|return
name|e
return|;
block|}
end_function

begin_comment
comment|/* Create an edge connecting SRC and DEST with flags FLAGS.  Return newly    created edge or NULL if already exist.  */
end_comment

begin_function
name|edge
name|make_edge
parameter_list|(
name|src
parameter_list|,
name|dest
parameter_list|,
name|flags
parameter_list|)
name|basic_block
name|src
decl_stmt|,
name|dest
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
return|return
name|cached_make_edge
argument_list|(
name|NULL
argument_list|,
name|src
argument_list|,
name|dest
argument_list|,
name|flags
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Create an edge connecting SRC to DEST and set probability by knowing    that it is the single edge leaving SRC.  */
end_comment

begin_function
name|edge
name|make_single_succ_edge
parameter_list|(
name|src
parameter_list|,
name|dest
parameter_list|,
name|flags
parameter_list|)
name|basic_block
name|src
decl_stmt|,
name|dest
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|edge
name|e
init|=
name|make_edge
argument_list|(
name|src
argument_list|,
name|dest
argument_list|,
name|flags
argument_list|)
decl_stmt|;
name|e
operator|->
name|probability
operator|=
name|REG_BR_PROB_BASE
expr_stmt|;
name|e
operator|->
name|count
operator|=
name|src
operator|->
name|count
expr_stmt|;
return|return
name|e
return|;
block|}
end_function

begin_comment
comment|/* This function will remove an edge from the flow graph.  */
end_comment

begin_function
name|void
name|remove_edge
parameter_list|(
name|e
parameter_list|)
name|edge
name|e
decl_stmt|;
block|{
name|edge
name|last_pred
init|=
name|NULL
decl_stmt|;
name|edge
name|last_succ
init|=
name|NULL
decl_stmt|;
name|edge
name|tmp
decl_stmt|;
name|basic_block
name|src
decl_stmt|,
name|dest
decl_stmt|;
name|src
operator|=
name|e
operator|->
name|src
expr_stmt|;
name|dest
operator|=
name|e
operator|->
name|dest
expr_stmt|;
for|for
control|(
name|tmp
operator|=
name|src
operator|->
name|succ
init|;
name|tmp
operator|&&
name|tmp
operator|!=
name|e
condition|;
name|tmp
operator|=
name|tmp
operator|->
name|succ_next
control|)
name|last_succ
operator|=
name|tmp
expr_stmt|;
if|if
condition|(
operator|!
name|tmp
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|last_succ
condition|)
name|last_succ
operator|->
name|succ_next
operator|=
name|e
operator|->
name|succ_next
expr_stmt|;
else|else
name|src
operator|->
name|succ
operator|=
name|e
operator|->
name|succ_next
expr_stmt|;
for|for
control|(
name|tmp
operator|=
name|dest
operator|->
name|pred
init|;
name|tmp
operator|&&
name|tmp
operator|!=
name|e
condition|;
name|tmp
operator|=
name|tmp
operator|->
name|pred_next
control|)
name|last_pred
operator|=
name|tmp
expr_stmt|;
if|if
condition|(
operator|!
name|tmp
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|last_pred
condition|)
name|last_pred
operator|->
name|pred_next
operator|=
name|e
operator|->
name|pred_next
expr_stmt|;
else|else
name|dest
operator|->
name|pred
operator|=
name|e
operator|->
name|pred_next
expr_stmt|;
name|free_edge
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Redirect an edge's successor from one block to another.  */
end_comment

begin_function
name|void
name|redirect_edge_succ
parameter_list|(
name|e
parameter_list|,
name|new_succ
parameter_list|)
name|edge
name|e
decl_stmt|;
name|basic_block
name|new_succ
decl_stmt|;
block|{
name|edge
modifier|*
name|pe
decl_stmt|;
comment|/* Disconnect the edge from the old successor block.  */
for|for
control|(
name|pe
operator|=
operator|&
name|e
operator|->
name|dest
operator|->
name|pred
init|;
operator|*
name|pe
operator|!=
name|e
condition|;
name|pe
operator|=
operator|&
operator|(
operator|*
name|pe
operator|)
operator|->
name|pred_next
control|)
continue|continue;
operator|*
name|pe
operator|=
operator|(
operator|*
name|pe
operator|)
operator|->
name|pred_next
expr_stmt|;
comment|/* Reconnect the edge to the new successor block.  */
name|e
operator|->
name|pred_next
operator|=
name|new_succ
operator|->
name|pred
expr_stmt|;
name|new_succ
operator|->
name|pred
operator|=
name|e
expr_stmt|;
name|e
operator|->
name|dest
operator|=
name|new_succ
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Like previous but avoid possible duplicate edge.  */
end_comment

begin_function
name|edge
name|redirect_edge_succ_nodup
parameter_list|(
name|e
parameter_list|,
name|new_succ
parameter_list|)
name|edge
name|e
decl_stmt|;
name|basic_block
name|new_succ
decl_stmt|;
block|{
name|edge
name|s
decl_stmt|;
comment|/* Check whether the edge is already present.  */
for|for
control|(
name|s
operator|=
name|e
operator|->
name|src
operator|->
name|succ
init|;
name|s
condition|;
name|s
operator|=
name|s
operator|->
name|succ_next
control|)
if|if
condition|(
name|s
operator|->
name|dest
operator|==
name|new_succ
operator|&&
name|s
operator|!=
name|e
condition|)
break|break;
if|if
condition|(
name|s
condition|)
block|{
name|s
operator|->
name|flags
operator||=
name|e
operator|->
name|flags
expr_stmt|;
name|s
operator|->
name|probability
operator|+=
name|e
operator|->
name|probability
expr_stmt|;
name|s
operator|->
name|count
operator|+=
name|e
operator|->
name|count
expr_stmt|;
name|remove_edge
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|e
operator|=
name|s
expr_stmt|;
block|}
else|else
name|redirect_edge_succ
argument_list|(
name|e
argument_list|,
name|new_succ
argument_list|)
expr_stmt|;
return|return
name|e
return|;
block|}
end_function

begin_comment
comment|/* Redirect an edge's predecessor from one block to another.  */
end_comment

begin_function
name|void
name|redirect_edge_pred
parameter_list|(
name|e
parameter_list|,
name|new_pred
parameter_list|)
name|edge
name|e
decl_stmt|;
name|basic_block
name|new_pred
decl_stmt|;
block|{
name|edge
modifier|*
name|pe
decl_stmt|;
comment|/* Disconnect the edge from the old predecessor block.  */
for|for
control|(
name|pe
operator|=
operator|&
name|e
operator|->
name|src
operator|->
name|succ
init|;
operator|*
name|pe
operator|!=
name|e
condition|;
name|pe
operator|=
operator|&
operator|(
operator|*
name|pe
operator|)
operator|->
name|succ_next
control|)
continue|continue;
operator|*
name|pe
operator|=
operator|(
operator|*
name|pe
operator|)
operator|->
name|succ_next
expr_stmt|;
comment|/* Reconnect the edge to the new predecessor block.  */
name|e
operator|->
name|succ_next
operator|=
name|new_pred
operator|->
name|succ
expr_stmt|;
name|new_pred
operator|->
name|succ
operator|=
name|e
expr_stmt|;
name|e
operator|->
name|src
operator|=
name|new_pred
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|dump_flow_info
parameter_list|(
name|file
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|reg_class_names
index|[]
init|=
name|REG_CLASS_NAMES
decl_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d registers.\n"
argument_list|,
name|max_regno
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|FIRST_PSEUDO_REGISTER
init|;
name|i
operator|<
name|max_regno
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|REG_N_REFS
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|enum
name|reg_class
name|class
decl_stmt|,
name|altclass
decl_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\nRegister %d used %d times across %d insns"
argument_list|,
name|i
argument_list|,
name|REG_N_REFS
argument_list|(
name|i
argument_list|)
argument_list|,
name|REG_LIVE_LENGTH
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|REG_BASIC_BLOCK
argument_list|(
name|i
argument_list|)
operator|>=
literal|0
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" in block %d"
argument_list|,
name|REG_BASIC_BLOCK
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|REG_N_SETS
argument_list|(
name|i
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"; set %d time%s"
argument_list|,
name|REG_N_SETS
argument_list|(
name|i
argument_list|)
argument_list|,
operator|(
name|REG_N_SETS
argument_list|(
name|i
argument_list|)
operator|==
literal|1
operator|)
condition|?
literal|""
else|:
literal|"s"
argument_list|)
expr_stmt|;
if|if
condition|(
name|REG_USERVAR_P
argument_list|(
name|regno_reg_rtx
index|[
name|i
index|]
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"; user var"
argument_list|)
expr_stmt|;
if|if
condition|(
name|REG_N_DEATHS
argument_list|(
name|i
argument_list|)
operator|!=
literal|1
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"; dies in %d places"
argument_list|,
name|REG_N_DEATHS
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|REG_N_CALLS_CROSSED
argument_list|(
name|i
argument_list|)
operator|==
literal|1
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"; crosses 1 call"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|REG_N_CALLS_CROSSED
argument_list|(
name|i
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"; crosses %d calls"
argument_list|,
name|REG_N_CALLS_CROSSED
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|PSEUDO_REGNO_BYTES
argument_list|(
name|i
argument_list|)
operator|!=
name|UNITS_PER_WORD
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"; %d bytes"
argument_list|,
name|PSEUDO_REGNO_BYTES
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|class
operator|=
name|reg_preferred_class
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|altclass
operator|=
name|reg_alternate_class
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|class
operator|!=
name|GENERAL_REGS
operator|||
name|altclass
operator|!=
name|ALL_REGS
condition|)
block|{
if|if
condition|(
name|altclass
operator|==
name|ALL_REGS
operator|||
name|class
operator|==
name|ALL_REGS
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"; pref %s"
argument_list|,
name|reg_class_names
index|[
operator|(
name|int
operator|)
name|class
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|altclass
operator|==
name|NO_REGS
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"; %s or none"
argument_list|,
name|reg_class_names
index|[
operator|(
name|int
operator|)
name|class
index|]
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"; pref %s, else %s"
argument_list|,
name|reg_class_names
index|[
operator|(
name|int
operator|)
name|class
index|]
argument_list|,
name|reg_class_names
index|[
operator|(
name|int
operator|)
name|altclass
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|REG_POINTER
argument_list|(
name|regno_reg_rtx
index|[
name|i
index|]
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"; pointer"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|".\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n%d basic blocks, %d edges.\n"
argument_list|,
name|n_basic_blocks
argument_list|,
name|n_edges
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
name|i
operator|++
control|)
block|{
name|basic_block
name|bb
init|=
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\nBasic block %d: first insn %d, last %d, "
argument_list|,
name|i
argument_list|,
name|INSN_UID
argument_list|(
name|bb
operator|->
name|head
argument_list|)
argument_list|,
name|INSN_UID
argument_list|(
name|bb
operator|->
name|end
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"loop_depth %d, count "
argument_list|,
name|bb
operator|->
name|loop_depth
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDEST_INT_PRINT_DEC
argument_list|,
name|bb
operator|->
name|count
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|", freq %i.\n"
argument_list|,
name|bb
operator|->
name|frequency
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"Predecessors: "
argument_list|)
expr_stmt|;
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|pred
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|pred_next
control|)
name|dump_edge_info
argument_list|(
name|file
argument_list|,
name|e
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\nSuccessors: "
argument_list|)
expr_stmt|;
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
name|dump_edge_info
argument_list|(
name|file
argument_list|,
name|e
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\nRegisters live at start:"
argument_list|)
expr_stmt|;
name|dump_regset
argument_list|(
name|bb
operator|->
name|global_live_at_start
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\nRegisters live at end:"
argument_list|)
expr_stmt|;
name|dump_regset
argument_list|(
name|bb
operator|->
name|global_live_at_end
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|debug_flow_info
parameter_list|()
block|{
name|dump_flow_info
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dump_edge_info
parameter_list|(
name|file
parameter_list|,
name|e
parameter_list|,
name|do_succ
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|int
name|do_succ
decl_stmt|;
block|{
name|basic_block
name|side
init|=
operator|(
name|do_succ
condition|?
name|e
operator|->
name|dest
else|:
name|e
operator|->
name|src
operator|)
decl_stmt|;
if|if
condition|(
name|side
operator|==
name|ENTRY_BLOCK_PTR
condition|)
name|fputs
argument_list|(
literal|" ENTRY"
argument_list|,
name|file
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|side
operator|==
name|EXIT_BLOCK_PTR
condition|)
name|fputs
argument_list|(
literal|" EXIT"
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %d"
argument_list|,
name|side
operator|->
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|probability
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" [%.1f%%] "
argument_list|,
name|e
operator|->
name|probability
operator|*
literal|100.0
operator|/
name|REG_BR_PROB_BASE
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|count
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" count:"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDEST_INT_PRINT_DEC
argument_list|,
name|e
operator|->
name|count
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|e
operator|->
name|flags
condition|)
block|{
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|bitnames
index|[]
init|=
block|{
literal|"fallthru"
block|,
literal|"ab"
block|,
literal|"abcall"
block|,
literal|"eh"
block|,
literal|"fake"
block|,
literal|"dfs_back"
block|}
decl_stmt|;
name|int
name|comma
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|,
name|flags
init|=
name|e
operator|->
name|flags
decl_stmt|;
name|fputs
argument_list|(
literal|" ("
argument_list|,
name|file
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|flags
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|flags
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
block|{
name|flags
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|i
operator|)
expr_stmt|;
if|if
condition|(
name|comma
condition|)
name|fputc
argument_list|(
literal|','
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
operator|(
name|int
operator|)
name|ARRAY_SIZE
argument_list|(
name|bitnames
argument_list|)
condition|)
name|fputs
argument_list|(
name|bitnames
index|[
name|i
index|]
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|comma
operator|=
literal|1
expr_stmt|;
block|}
name|fputc
argument_list|(
literal|')'
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Simple routines to easily allocate AUX fields of basic blocks.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|block_aux_obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
modifier|*
name|first_block_aux_obj
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|edge_aux_obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
modifier|*
name|first_edge_aux_obj
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Allocate an memory block of SIZE as BB->aux.  The obstack must    be first initialized by alloc_aux_for_blocks.  */
end_comment

begin_function
specifier|inline
name|void
name|alloc_aux_for_block
parameter_list|(
name|bb
parameter_list|,
name|size
parameter_list|)
name|basic_block
name|bb
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
comment|/* Verify that aux field is clear.  */
if|if
condition|(
name|bb
operator|->
name|aux
operator|||
operator|!
name|first_block_aux_obj
condition|)
name|abort
argument_list|()
expr_stmt|;
name|bb
operator|->
name|aux
operator|=
name|obstack_alloc
argument_list|(
operator|&
name|block_aux_obstack
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|bb
operator|->
name|aux
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize the block_aux_obstack and if SIZE is nonzero, call    alloc_aux_for_block for each basic block.  */
end_comment

begin_function
name|void
name|alloc_aux_for_blocks
parameter_list|(
name|size
parameter_list|)
name|int
name|size
decl_stmt|;
block|{
specifier|static
name|int
name|initialized
decl_stmt|;
if|if
condition|(
operator|!
name|initialized
condition|)
block|{
name|gcc_obstack_init
argument_list|(
operator|&
name|block_aux_obstack
argument_list|)
expr_stmt|;
name|initialized
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Check whether AUX data are still allocated.  */
elseif|else
if|if
condition|(
name|first_block_aux_obj
condition|)
name|abort
argument_list|()
expr_stmt|;
name|first_block_aux_obj
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|block_aux_obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
name|i
operator|++
control|)
name|alloc_aux_for_block
argument_list|(
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|alloc_aux_for_block
argument_list|(
name|ENTRY_BLOCK_PTR
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|alloc_aux_for_block
argument_list|(
name|EXIT_BLOCK_PTR
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Clear AUX pointers of all blocks.  */
end_comment

begin_function
name|void
name|clear_aux_for_blocks
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
name|i
operator|++
control|)
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
operator|->
name|aux
operator|=
name|NULL
expr_stmt|;
name|ENTRY_BLOCK_PTR
operator|->
name|aux
operator|=
name|NULL
expr_stmt|;
name|EXIT_BLOCK_PTR
operator|->
name|aux
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Free data allocated in block_aux_obstack and clear AUX pointers    of all blocks.  */
end_comment

begin_function
name|void
name|free_aux_for_blocks
parameter_list|()
block|{
if|if
condition|(
operator|!
name|first_block_aux_obj
condition|)
name|abort
argument_list|()
expr_stmt|;
name|obstack_free
argument_list|(
operator|&
name|block_aux_obstack
argument_list|,
name|first_block_aux_obj
argument_list|)
expr_stmt|;
name|first_block_aux_obj
operator|=
name|NULL
expr_stmt|;
name|clear_aux_for_blocks
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Allocate an memory edge of SIZE as BB->aux.  The obstack must    be first initialized by alloc_aux_for_edges.  */
end_comment

begin_function
specifier|inline
name|void
name|alloc_aux_for_edge
parameter_list|(
name|e
parameter_list|,
name|size
parameter_list|)
name|edge
name|e
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
comment|/* Verify that aux field is clear.  */
if|if
condition|(
name|e
operator|->
name|aux
operator|||
operator|!
name|first_edge_aux_obj
condition|)
name|abort
argument_list|()
expr_stmt|;
name|e
operator|->
name|aux
operator|=
name|obstack_alloc
argument_list|(
operator|&
name|edge_aux_obstack
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|e
operator|->
name|aux
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize the edge_aux_obstack and if SIZE is nonzero, call    alloc_aux_for_edge for each basic edge.  */
end_comment

begin_function
name|void
name|alloc_aux_for_edges
parameter_list|(
name|size
parameter_list|)
name|int
name|size
decl_stmt|;
block|{
specifier|static
name|int
name|initialized
decl_stmt|;
if|if
condition|(
operator|!
name|initialized
condition|)
block|{
name|gcc_obstack_init
argument_list|(
operator|&
name|edge_aux_obstack
argument_list|)
expr_stmt|;
name|initialized
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Check whether AUX data are still allocated.  */
elseif|else
if|if
condition|(
name|first_edge_aux_obj
condition|)
name|abort
argument_list|()
expr_stmt|;
name|first_edge_aux_obj
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|edge_aux_obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
operator|-
literal|1
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
name|i
operator|++
control|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|edge
name|e
decl_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
name|bb
operator|=
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
expr_stmt|;
else|else
name|bb
operator|=
name|ENTRY_BLOCK_PTR
expr_stmt|;
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
name|alloc_aux_for_edge
argument_list|(
name|e
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Clear AUX pointers of all edges.  */
end_comment

begin_function
name|void
name|clear_aux_for_edges
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
operator|-
literal|1
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
name|i
operator|++
control|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|edge
name|e
decl_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
name|bb
operator|=
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
expr_stmt|;
else|else
name|bb
operator|=
name|ENTRY_BLOCK_PTR
expr_stmt|;
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
name|e
operator|->
name|aux
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Free data allocated in edge_aux_obstack and clear AUX pointers    of all edges.  */
end_comment

begin_function
name|void
name|free_aux_for_edges
parameter_list|()
block|{
if|if
condition|(
operator|!
name|first_edge_aux_obj
condition|)
name|abort
argument_list|()
expr_stmt|;
name|obstack_free
argument_list|(
operator|&
name|edge_aux_obstack
argument_list|,
name|first_edge_aux_obj
argument_list|)
expr_stmt|;
name|first_edge_aux_obj
operator|=
name|NULL
expr_stmt|;
name|clear_aux_for_edges
argument_list|()
expr_stmt|;
block|}
end_function

end_unit

