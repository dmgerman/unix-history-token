begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Control flow graph manipulation code for GNU compiler.    Copyright (C) 1987, 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2000, 2001, 2002, 2003, 2004, 2005    Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* This file contains low level functions to manipulate the CFG and    analyze it.  All other modules should not transform the data structure    directly and use abstraction instead.  The file is supposed to be    ordered bottom-up and should not contain any code dependent on a    particular intermediate language (RTL or trees).     Available functionality:      - Initialization/deallocation 	 init_flow, clear_edges      - Low level basic block manipulation 	 alloc_block, expunge_block      - Edge manipulation 	 make_edge, make_single_succ_edge, cached_make_edge, remove_edge 	 - Low level edge redirection (without updating instruction chain) 	     redirect_edge_succ, redirect_edge_succ_nodup, redirect_edge_pred      - Dumping and debugging 	 dump_flow_info, debug_flow_info, dump_edge_info      - Allocation of AUX fields for basic blocks 	 alloc_aux_for_blocks, free_aux_for_blocks, alloc_aux_for_block      - clear_bb_flags      - Consistency checking 	 verify_flow_info      - Dumping and debugging 	 print_rtl_with_bb, dump_bb, debug_bb, debug_bb_n  */
end_comment

begin_escape
end_escape

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"tree-pass.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"hashtab.h"
end_include

begin_include
include|#
directive|include
file|"alloc-pool.h"
end_include

begin_comment
comment|/* The obstack on which the flow graph components are allocated.  */
end_comment

begin_decl_stmt
name|struct
name|bitmap_obstack
name|reg_obstack
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|debug_flow_info
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_edge
parameter_list|(
name|edge
parameter_list|)
function_decl|;
end_function_decl

begin_escape
end_escape

begin_define
define|#
directive|define
name|RDIV
parameter_list|(
name|X
parameter_list|,
name|Y
parameter_list|)
value|(((X) + (Y) / 2) / (Y))
end_define

begin_comment
comment|/* Called once at initialization time.  */
end_comment

begin_function
name|void
name|init_flow
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|cfun
operator|->
name|cfg
condition|)
name|cfun
operator|->
name|cfg
operator|=
name|ggc_alloc_cleared
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|control_flow_graph
argument_list|)
argument_list|)
expr_stmt|;
name|n_edges
operator|=
literal|0
expr_stmt|;
name|ENTRY_BLOCK_PTR
operator|=
name|ggc_alloc_cleared
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|basic_block_def
argument_list|)
argument_list|)
expr_stmt|;
name|ENTRY_BLOCK_PTR
operator|->
name|index
operator|=
name|ENTRY_BLOCK
expr_stmt|;
name|EXIT_BLOCK_PTR
operator|=
name|ggc_alloc_cleared
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|basic_block_def
argument_list|)
argument_list|)
expr_stmt|;
name|EXIT_BLOCK_PTR
operator|->
name|index
operator|=
name|EXIT_BLOCK
expr_stmt|;
name|ENTRY_BLOCK_PTR
operator|->
name|next_bb
operator|=
name|EXIT_BLOCK_PTR
expr_stmt|;
name|EXIT_BLOCK_PTR
operator|->
name|prev_bb
operator|=
name|ENTRY_BLOCK_PTR
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Helper function for remove_edge and clear_edges.  Frees edge structure    without actually unlinking it from the pred/succ lists.  */
end_comment

begin_function
specifier|static
name|void
name|free_edge
parameter_list|(
name|edge
name|e
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|n_edges
operator|--
expr_stmt|;
name|ggc_free
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Free the memory associated with the edge structures.  */
end_comment

begin_function
name|void
name|clear_edges
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
name|free_edge
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|VEC_truncate
argument_list|(
name|edge
argument_list|,
name|bb
operator|->
name|succs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|VEC_truncate
argument_list|(
name|edge
argument_list|,
name|bb
operator|->
name|preds
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|ENTRY_BLOCK_PTR->succs
argument_list|)
name|free_edge
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|VEC_truncate
argument_list|(
name|edge
argument_list|,
name|EXIT_BLOCK_PTR
operator|->
name|preds
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|VEC_truncate
argument_list|(
name|edge
argument_list|,
name|ENTRY_BLOCK_PTR
operator|->
name|succs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|n_edges
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Allocate memory for basic_block.  */
end_comment

begin_function
name|basic_block
name|alloc_block
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|bb
operator|=
name|ggc_alloc_cleared
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|bb
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|bb
return|;
block|}
end_function

begin_comment
comment|/* Link block B to chain after AFTER.  */
end_comment

begin_function
name|void
name|link_block
parameter_list|(
name|basic_block
name|b
parameter_list|,
name|basic_block
name|after
parameter_list|)
block|{
name|b
operator|->
name|next_bb
operator|=
name|after
operator|->
name|next_bb
expr_stmt|;
name|b
operator|->
name|prev_bb
operator|=
name|after
expr_stmt|;
name|after
operator|->
name|next_bb
operator|=
name|b
expr_stmt|;
name|b
operator|->
name|next_bb
operator|->
name|prev_bb
operator|=
name|b
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Unlink block B from chain.  */
end_comment

begin_function
name|void
name|unlink_block
parameter_list|(
name|basic_block
name|b
parameter_list|)
block|{
name|b
operator|->
name|next_bb
operator|->
name|prev_bb
operator|=
name|b
operator|->
name|prev_bb
expr_stmt|;
name|b
operator|->
name|prev_bb
operator|->
name|next_bb
operator|=
name|b
operator|->
name|next_bb
expr_stmt|;
name|b
operator|->
name|prev_bb
operator|=
name|NULL
expr_stmt|;
name|b
operator|->
name|next_bb
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Sequentially order blocks and compact the arrays.  */
end_comment

begin_function
name|void
name|compact_blocks
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|SET_BASIC_BLOCK
argument_list|(
name|ENTRY_BLOCK
argument_list|,
name|ENTRY_BLOCK_PTR
argument_list|)
expr_stmt|;
name|SET_BASIC_BLOCK
argument_list|(
name|EXIT_BLOCK
argument_list|,
name|EXIT_BLOCK_PTR
argument_list|)
expr_stmt|;
name|i
operator|=
name|NUM_FIXED_BLOCKS
expr_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|SET_BASIC_BLOCK
argument_list|(
name|i
argument_list|,
name|bb
argument_list|)
expr_stmt|;
name|bb
operator|->
name|index
operator|=
name|i
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
name|gcc_assert
argument_list|(
name|i
operator|==
name|n_basic_blocks
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|last_basic_block
condition|;
name|i
operator|++
control|)
name|SET_BASIC_BLOCK
argument_list|(
name|i
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|last_basic_block
operator|=
name|n_basic_blocks
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Remove block B from the basic block array.  */
end_comment

begin_function
name|void
name|expunge_block
parameter_list|(
name|basic_block
name|b
parameter_list|)
block|{
name|unlink_block
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|SET_BASIC_BLOCK
argument_list|(
name|b
operator|->
name|index
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|n_basic_blocks
operator|--
expr_stmt|;
comment|/* We should be able to ggc_free here, but we are not.      The dead SSA_NAMES are left pointing to dead statements that are pointing      to dead basic blocks making garbage collector to die.      We should be able to release all dead SSA_NAMES and at the same time we should      clear out BB pointer of dead statements consistently.  */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Connect E to E->src.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|connect_src
parameter_list|(
name|edge
name|e
parameter_list|)
block|{
name|VEC_safe_push
argument_list|(
name|edge
argument_list|,
name|gc
argument_list|,
name|e
operator|->
name|src
operator|->
name|succs
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Connect E to E->dest.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|connect_dest
parameter_list|(
name|edge
name|e
parameter_list|)
block|{
name|basic_block
name|dest
init|=
name|e
operator|->
name|dest
decl_stmt|;
name|VEC_safe_push
argument_list|(
name|edge
argument_list|,
name|gc
argument_list|,
name|dest
operator|->
name|preds
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|e
operator|->
name|dest_idx
operator|=
name|EDGE_COUNT
argument_list|(
name|dest
operator|->
name|preds
argument_list|)
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Disconnect edge E from E->src.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|disconnect_src
parameter_list|(
name|edge
name|e
parameter_list|)
block|{
name|basic_block
name|src
init|=
name|e
operator|->
name|src
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|edge
name|tmp
decl_stmt|;
for|for
control|(
name|ei
operator|=
name|ei_start
argument_list|(
name|src
operator|->
name|succs
argument_list|)
init|;
operator|(
name|tmp
operator|=
name|ei_safe_edge
argument_list|(
name|ei
argument_list|)
operator|)
condition|;
control|)
block|{
if|if
condition|(
name|tmp
operator|==
name|e
condition|)
block|{
name|VEC_unordered_remove
argument_list|(
name|edge
argument_list|,
name|src
operator|->
name|succs
argument_list|,
name|ei
operator|.
name|index
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
name|ei_next
argument_list|(
operator|&
name|ei
argument_list|)
expr_stmt|;
block|}
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Disconnect edge E from E->dest.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|disconnect_dest
parameter_list|(
name|edge
name|e
parameter_list|)
block|{
name|basic_block
name|dest
init|=
name|e
operator|->
name|dest
decl_stmt|;
name|unsigned
name|int
name|dest_idx
init|=
name|e
operator|->
name|dest_idx
decl_stmt|;
name|VEC_unordered_remove
argument_list|(
name|edge
argument_list|,
name|dest
operator|->
name|preds
argument_list|,
name|dest_idx
argument_list|)
expr_stmt|;
comment|/* If we removed an edge in the middle of the edge vector, we need      to update dest_idx of the edge that moved into the "hole".  */
if|if
condition|(
name|dest_idx
operator|<
name|EDGE_COUNT
argument_list|(
name|dest
operator|->
name|preds
argument_list|)
condition|)
name|EDGE_PRED
argument_list|(
name|dest
argument_list|,
name|dest_idx
argument_list|)
operator|->
name|dest_idx
operator|=
name|dest_idx
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create an edge connecting SRC and DEST with flags FLAGS.  Return newly    created edge.  Use this only if you are sure that this edge can't    possibly already exist.  */
end_comment

begin_function
name|edge
name|unchecked_make_edge
parameter_list|(
name|basic_block
name|src
parameter_list|,
name|basic_block
name|dst
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|edge
name|e
decl_stmt|;
name|e
operator|=
name|ggc_alloc_cleared
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|e
argument_list|)
argument_list|)
expr_stmt|;
name|n_edges
operator|++
expr_stmt|;
name|e
operator|->
name|src
operator|=
name|src
expr_stmt|;
name|e
operator|->
name|dest
operator|=
name|dst
expr_stmt|;
name|e
operator|->
name|flags
operator|=
name|flags
expr_stmt|;
name|connect_src
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|connect_dest
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|execute_on_growing_pred
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
name|e
return|;
block|}
end_function

begin_comment
comment|/* Create an edge connecting SRC and DST with FLAGS optionally using    edge cache CACHE.  Return the new edge, NULL if already exist.  */
end_comment

begin_function
name|edge
name|cached_make_edge
parameter_list|(
name|sbitmap
name|edge_cache
parameter_list|,
name|basic_block
name|src
parameter_list|,
name|basic_block
name|dst
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
if|if
condition|(
name|edge_cache
operator|==
name|NULL
operator|||
name|src
operator|==
name|ENTRY_BLOCK_PTR
operator|||
name|dst
operator|==
name|EXIT_BLOCK_PTR
condition|)
return|return
name|make_edge
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|flags
argument_list|)
return|;
comment|/* Does the requested edge already exist?  */
if|if
condition|(
operator|!
name|TEST_BIT
argument_list|(
name|edge_cache
argument_list|,
name|dst
operator|->
name|index
argument_list|)
condition|)
block|{
comment|/* The edge does not exist.  Create one and update the 	 cache.  */
name|SET_BIT
argument_list|(
name|edge_cache
argument_list|,
name|dst
operator|->
name|index
argument_list|)
expr_stmt|;
return|return
name|unchecked_make_edge
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|flags
argument_list|)
return|;
block|}
comment|/* At this point, we know that the requested edge exists.  Adjust      flags if necessary.  */
if|if
condition|(
name|flags
condition|)
block|{
name|edge
name|e
init|=
name|find_edge
argument_list|(
name|src
argument_list|,
name|dst
argument_list|)
decl_stmt|;
name|e
operator|->
name|flags
operator||=
name|flags
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Create an edge connecting SRC and DEST with flags FLAGS.  Return newly    created edge or NULL if already exist.  */
end_comment

begin_function
name|edge
name|make_edge
parameter_list|(
name|basic_block
name|src
parameter_list|,
name|basic_block
name|dest
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|edge
name|e
init|=
name|find_edge
argument_list|(
name|src
argument_list|,
name|dest
argument_list|)
decl_stmt|;
comment|/* Make sure we don't add duplicate edges.  */
if|if
condition|(
name|e
condition|)
block|{
name|e
operator|->
name|flags
operator||=
name|flags
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|unchecked_make_edge
argument_list|(
name|src
argument_list|,
name|dest
argument_list|,
name|flags
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Create an edge connecting SRC to DEST and set probability by knowing    that it is the single edge leaving SRC.  */
end_comment

begin_function
name|edge
name|make_single_succ_edge
parameter_list|(
name|basic_block
name|src
parameter_list|,
name|basic_block
name|dest
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|edge
name|e
init|=
name|make_edge
argument_list|(
name|src
argument_list|,
name|dest
argument_list|,
name|flags
argument_list|)
decl_stmt|;
name|e
operator|->
name|probability
operator|=
name|REG_BR_PROB_BASE
expr_stmt|;
name|e
operator|->
name|count
operator|=
name|src
operator|->
name|count
expr_stmt|;
return|return
name|e
return|;
block|}
end_function

begin_comment
comment|/* This function will remove an edge from the flow graph.  */
end_comment

begin_function
name|void
name|remove_edge
parameter_list|(
name|edge
name|e
parameter_list|)
block|{
name|remove_predictions_associated_with_edge
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|execute_on_shrinking_pred
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|disconnect_src
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|disconnect_dest
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|free_edge
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Redirect an edge's successor from one block to another.  */
end_comment

begin_function
name|void
name|redirect_edge_succ
parameter_list|(
name|edge
name|e
parameter_list|,
name|basic_block
name|new_succ
parameter_list|)
block|{
name|execute_on_shrinking_pred
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|disconnect_dest
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|e
operator|->
name|dest
operator|=
name|new_succ
expr_stmt|;
comment|/* Reconnect the edge to the new successor block.  */
name|connect_dest
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|execute_on_growing_pred
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Like previous but avoid possible duplicate edge.  */
end_comment

begin_function
name|edge
name|redirect_edge_succ_nodup
parameter_list|(
name|edge
name|e
parameter_list|,
name|basic_block
name|new_succ
parameter_list|)
block|{
name|edge
name|s
decl_stmt|;
name|s
operator|=
name|find_edge
argument_list|(
name|e
operator|->
name|src
argument_list|,
name|new_succ
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|&&
name|s
operator|!=
name|e
condition|)
block|{
name|s
operator|->
name|flags
operator||=
name|e
operator|->
name|flags
expr_stmt|;
name|s
operator|->
name|probability
operator|+=
name|e
operator|->
name|probability
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|probability
operator|>
name|REG_BR_PROB_BASE
condition|)
name|s
operator|->
name|probability
operator|=
name|REG_BR_PROB_BASE
expr_stmt|;
name|s
operator|->
name|count
operator|+=
name|e
operator|->
name|count
expr_stmt|;
name|remove_edge
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|e
operator|=
name|s
expr_stmt|;
block|}
else|else
name|redirect_edge_succ
argument_list|(
name|e
argument_list|,
name|new_succ
argument_list|)
expr_stmt|;
return|return
name|e
return|;
block|}
end_function

begin_comment
comment|/* Redirect an edge's predecessor from one block to another.  */
end_comment

begin_function
name|void
name|redirect_edge_pred
parameter_list|(
name|edge
name|e
parameter_list|,
name|basic_block
name|new_pred
parameter_list|)
block|{
name|disconnect_src
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|e
operator|->
name|src
operator|=
name|new_pred
expr_stmt|;
comment|/* Reconnect the edge to the new predecessor block.  */
name|connect_src
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Clear all basic block flags, with the exception of partitioning.  */
end_comment

begin_function
name|void
name|clear_bb_flags
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|FOR_BB_BETWEEN
argument_list|(
argument|bb
argument_list|,
argument|ENTRY_BLOCK_PTR
argument_list|,
argument|NULL
argument_list|,
argument|next_bb
argument_list|)
name|bb
operator|->
name|flags
operator|=
operator|(
name|BB_PARTITION
argument_list|(
name|bb
argument_list|)
operator||
operator|(
name|bb
operator|->
name|flags
operator|&
name|BB_DISABLE_SCHEDULE
operator|)
operator||
operator|(
name|bb
operator|->
name|flags
operator|&
name|BB_RTL
operator|)
operator|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Check the consistency of profile information.  We can't do that    in verify_flow_info, as the counts may get invalid for incompletely    solved graphs, later eliminating of conditionals or roundoff errors.    It is still practical to have them reported for debugging of simple    testcases.  */
end_comment

begin_function
name|void
name|check_bb_profile
parameter_list|(
name|basic_block
name|bb
parameter_list|,
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|edge
name|e
decl_stmt|;
name|int
name|sum
init|=
literal|0
decl_stmt|;
name|gcov_type
name|lsum
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
if|if
condition|(
name|profile_status
operator|==
name|PROFILE_ABSENT
condition|)
return|return;
if|if
condition|(
name|bb
operator|!=
name|EXIT_BLOCK_PTR
condition|)
block|{
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
name|sum
operator|+=
name|e
operator|->
name|probability
expr_stmt|;
if|if
condition|(
name|EDGE_COUNT
argument_list|(
name|bb
operator|->
name|succs
argument_list|)
operator|&&
name|abs
argument_list|(
name|sum
operator|-
name|REG_BR_PROB_BASE
argument_list|)
operator|>
literal|100
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"Invalid sum of outgoing probabilities %.1f%%\n"
argument_list|,
name|sum
operator|*
literal|100.0
operator|/
name|REG_BR_PROB_BASE
argument_list|)
expr_stmt|;
name|lsum
operator|=
literal|0
expr_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
name|lsum
operator|+=
name|e
operator|->
name|count
expr_stmt|;
if|if
condition|(
name|EDGE_COUNT
argument_list|(
name|bb
operator|->
name|succs
argument_list|)
operator|&&
operator|(
name|lsum
operator|-
name|bb
operator|->
name|count
operator|>
literal|100
operator|||
name|lsum
operator|-
name|bb
operator|->
name|count
operator|<
operator|-
literal|100
operator|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"Invalid sum of outgoing counts %i, should be %i\n"
argument_list|,
operator|(
name|int
operator|)
name|lsum
argument_list|,
operator|(
name|int
operator|)
name|bb
operator|->
name|count
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bb
operator|!=
name|ENTRY_BLOCK_PTR
condition|)
block|{
name|sum
operator|=
literal|0
expr_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->preds
argument_list|)
name|sum
operator|+=
name|EDGE_FREQUENCY
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|abs
argument_list|(
name|sum
operator|-
name|bb
operator|->
name|frequency
argument_list|)
operator|>
literal|100
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"Invalid sum of incoming frequencies %i, should be %i\n"
argument_list|,
name|sum
argument_list|,
name|bb
operator|->
name|frequency
argument_list|)
expr_stmt|;
name|lsum
operator|=
literal|0
expr_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->preds
argument_list|)
name|lsum
operator|+=
name|e
operator|->
name|count
expr_stmt|;
if|if
condition|(
name|lsum
operator|-
name|bb
operator|->
name|count
operator|>
literal|100
operator|||
name|lsum
operator|-
name|bb
operator|->
name|count
operator|<
operator|-
literal|100
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"Invalid sum of incoming counts %i, should be %i\n"
argument_list|,
operator|(
name|int
operator|)
name|lsum
argument_list|,
operator|(
name|int
operator|)
name|bb
operator|->
name|count
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Emit basic block information for BB.  HEADER is true if the user wants    the generic information and the predecessors, FOOTER is true if they want    the successors.  FLAGS is the dump flags of interest; TDF_DETAILS emit    global register liveness information.  PREFIX is put in front of every    line.  The output is emitted to FILE.  */
end_comment

begin_function
name|void
name|dump_bb_info
parameter_list|(
name|basic_block
name|bb
parameter_list|,
name|bool
name|header
parameter_list|,
name|bool
name|footer
parameter_list|,
name|int
name|flags
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|,
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
if|if
condition|(
name|header
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n%sBasic block %d "
argument_list|,
name|prefix
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|bb
operator|->
name|prev_bb
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|", prev %d"
argument_list|,
name|bb
operator|->
name|prev_bb
operator|->
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|bb
operator|->
name|next_bb
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|", next %d"
argument_list|,
name|bb
operator|->
name|next_bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|", loop_depth %d, count "
argument_list|,
name|bb
operator|->
name|loop_depth
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDEST_INT_PRINT_DEC
argument_list|,
name|bb
operator|->
name|count
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|", freq %i"
argument_list|,
name|bb
operator|->
name|frequency
argument_list|)
expr_stmt|;
if|if
condition|(
name|maybe_hot_bb_p
argument_list|(
name|bb
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|", maybe hot"
argument_list|)
expr_stmt|;
if|if
condition|(
name|probably_never_executed_bb_p
argument_list|(
name|bb
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|", probably never executed"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|".\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%sPredecessors: "
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->preds
argument_list|)
name|dump_edge_info
argument_list|(
name|file
argument_list|,
name|e
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|footer
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n%sSuccessors: "
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
name|dump_edge_info
argument_list|(
name|file
argument_list|,
name|e
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|TDF_DETAILS
operator|)
operator|&&
operator|(
name|bb
operator|->
name|flags
operator|&
name|BB_RTL
operator|)
condition|)
block|{
if|if
condition|(
name|bb
operator|->
name|il
operator|.
name|rtl
operator|->
name|global_live_at_start
operator|&&
name|header
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n%sRegisters live at start:"
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
name|dump_regset
argument_list|(
name|bb
operator|->
name|il
operator|.
name|rtl
operator|->
name|global_live_at_start
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bb
operator|->
name|il
operator|.
name|rtl
operator|->
name|global_live_at_end
operator|&&
name|footer
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n%sRegisters live at end:"
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
name|dump_regset
argument_list|(
name|bb
operator|->
name|il
operator|.
name|rtl
operator|->
name|global_live_at_end
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
block|}
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dump_flow_info
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
comment|/* There are no pseudo registers after reload.  Don't dump them.  */
if|if
condition|(
name|reg_n_info
operator|&&
operator|!
name|reload_completed
operator|&&
operator|(
name|flags
operator|&
name|TDF_DETAILS
operator|)
operator|!=
literal|0
condition|)
block|{
name|unsigned
name|int
name|i
decl_stmt|,
name|max
init|=
name|max_reg_num
argument_list|()
decl_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d registers.\n"
argument_list|,
name|max
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|FIRST_PSEUDO_REGISTER
init|;
name|i
operator|<
name|max
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|REG_N_REFS
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|enum
name|reg_class
name|class
decl_stmt|,
name|altclass
decl_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\nRegister %d used %d times across %d insns"
argument_list|,
name|i
argument_list|,
name|REG_N_REFS
argument_list|(
name|i
argument_list|)
argument_list|,
name|REG_LIVE_LENGTH
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|REG_BASIC_BLOCK
argument_list|(
name|i
argument_list|)
operator|>=
literal|0
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" in block %d"
argument_list|,
name|REG_BASIC_BLOCK
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|REG_N_SETS
argument_list|(
name|i
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"; set %d time%s"
argument_list|,
name|REG_N_SETS
argument_list|(
name|i
argument_list|)
argument_list|,
operator|(
name|REG_N_SETS
argument_list|(
name|i
argument_list|)
operator|==
literal|1
operator|)
condition|?
literal|""
else|:
literal|"s"
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno_reg_rtx
index|[
name|i
index|]
operator|!=
name|NULL
operator|&&
name|REG_USERVAR_P
argument_list|(
name|regno_reg_rtx
index|[
name|i
index|]
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"; user var"
argument_list|)
expr_stmt|;
if|if
condition|(
name|REG_N_DEATHS
argument_list|(
name|i
argument_list|)
operator|!=
literal|1
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"; dies in %d places"
argument_list|,
name|REG_N_DEATHS
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|REG_N_CALLS_CROSSED
argument_list|(
name|i
argument_list|)
operator|==
literal|1
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"; crosses 1 call"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|REG_N_CALLS_CROSSED
argument_list|(
name|i
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"; crosses %d calls"
argument_list|,
name|REG_N_CALLS_CROSSED
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno_reg_rtx
index|[
name|i
index|]
operator|!=
name|NULL
operator|&&
name|PSEUDO_REGNO_BYTES
argument_list|(
name|i
argument_list|)
operator|!=
name|UNITS_PER_WORD
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"; %d bytes"
argument_list|,
name|PSEUDO_REGNO_BYTES
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|class
operator|=
name|reg_preferred_class
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|altclass
operator|=
name|reg_alternate_class
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|class
operator|!=
name|GENERAL_REGS
operator|||
name|altclass
operator|!=
name|ALL_REGS
condition|)
block|{
if|if
condition|(
name|altclass
operator|==
name|ALL_REGS
operator|||
name|class
operator|==
name|ALL_REGS
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"; pref %s"
argument_list|,
name|reg_class_names
index|[
operator|(
name|int
operator|)
name|class
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|altclass
operator|==
name|NO_REGS
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"; %s or none"
argument_list|,
name|reg_class_names
index|[
operator|(
name|int
operator|)
name|class
index|]
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"; pref %s, else %s"
argument_list|,
name|reg_class_names
index|[
operator|(
name|int
operator|)
name|class
index|]
argument_list|,
name|reg_class_names
index|[
operator|(
name|int
operator|)
name|altclass
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|regno_reg_rtx
index|[
name|i
index|]
operator|!=
name|NULL
operator|&&
name|REG_POINTER
argument_list|(
name|regno_reg_rtx
index|[
name|i
index|]
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"; pointer"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|".\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n%d basic blocks, %d edges.\n"
argument_list|,
name|n_basic_blocks
argument_list|,
name|n_edges
argument_list|)
expr_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|dump_bb_info
argument_list|(
name|bb
argument_list|,
name|true
argument_list|,
name|true
argument_list|,
name|flags
argument_list|,
literal|""
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|check_bb_profile
argument_list|(
name|bb
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|debug_flow_info
parameter_list|(
name|void
parameter_list|)
block|{
name|dump_flow_info
argument_list|(
name|stderr
argument_list|,
name|TDF_DETAILS
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dump_edge_info
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|edge
name|e
parameter_list|,
name|int
name|do_succ
parameter_list|)
block|{
name|basic_block
name|side
init|=
operator|(
name|do_succ
condition|?
name|e
operator|->
name|dest
else|:
name|e
operator|->
name|src
operator|)
decl_stmt|;
if|if
condition|(
name|side
operator|==
name|ENTRY_BLOCK_PTR
condition|)
name|fputs
argument_list|(
literal|" ENTRY"
argument_list|,
name|file
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|side
operator|==
name|EXIT_BLOCK_PTR
condition|)
name|fputs
argument_list|(
literal|" EXIT"
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %d"
argument_list|,
name|side
operator|->
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|probability
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" [%.1f%%] "
argument_list|,
name|e
operator|->
name|probability
operator|*
literal|100.0
operator|/
name|REG_BR_PROB_BASE
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|count
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" count:"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDEST_INT_PRINT_DEC
argument_list|,
name|e
operator|->
name|count
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|e
operator|->
name|flags
condition|)
block|{
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|bitnames
index|[]
init|=
block|{
literal|"fallthru"
block|,
literal|"ab"
block|,
literal|"abcall"
block|,
literal|"eh"
block|,
literal|"fake"
block|,
literal|"dfs_back"
block|,
literal|"can_fallthru"
block|,
literal|"irreducible"
block|,
literal|"sibcall"
block|,
literal|"loop_exit"
block|,
literal|"true"
block|,
literal|"false"
block|,
literal|"exec"
block|}
decl_stmt|;
name|int
name|comma
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|,
name|flags
init|=
name|e
operator|->
name|flags
decl_stmt|;
name|fputs
argument_list|(
literal|" ("
argument_list|,
name|file
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|flags
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|flags
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
block|{
name|flags
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|i
operator|)
expr_stmt|;
if|if
condition|(
name|comma
condition|)
name|fputc
argument_list|(
literal|','
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
operator|(
name|int
operator|)
name|ARRAY_SIZE
argument_list|(
name|bitnames
argument_list|)
condition|)
name|fputs
argument_list|(
name|bitnames
index|[
name|i
index|]
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|comma
operator|=
literal|1
expr_stmt|;
block|}
name|fputc
argument_list|(
literal|')'
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Simple routines to easily allocate AUX fields of basic blocks.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|block_aux_obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
modifier|*
name|first_block_aux_obj
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|edge_aux_obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
modifier|*
name|first_edge_aux_obj
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Allocate a memory block of SIZE as BB->aux.  The obstack must    be first initialized by alloc_aux_for_blocks.  */
end_comment

begin_function
specifier|inline
name|void
name|alloc_aux_for_block
parameter_list|(
name|basic_block
name|bb
parameter_list|,
name|int
name|size
parameter_list|)
block|{
comment|/* Verify that aux field is clear.  */
name|gcc_assert
argument_list|(
operator|!
name|bb
operator|->
name|aux
operator|&&
name|first_block_aux_obj
argument_list|)
expr_stmt|;
name|bb
operator|->
name|aux
operator|=
name|obstack_alloc
argument_list|(
operator|&
name|block_aux_obstack
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|bb
operator|->
name|aux
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize the block_aux_obstack and if SIZE is nonzero, call    alloc_aux_for_block for each basic block.  */
end_comment

begin_function
name|void
name|alloc_aux_for_blocks
parameter_list|(
name|int
name|size
parameter_list|)
block|{
specifier|static
name|int
name|initialized
decl_stmt|;
if|if
condition|(
operator|!
name|initialized
condition|)
block|{
name|gcc_obstack_init
argument_list|(
operator|&
name|block_aux_obstack
argument_list|)
expr_stmt|;
name|initialized
operator|=
literal|1
expr_stmt|;
block|}
else|else
comment|/* Check whether AUX data are still allocated.  */
name|gcc_assert
argument_list|(
operator|!
name|first_block_aux_obj
argument_list|)
expr_stmt|;
name|first_block_aux_obj
operator|=
name|obstack_alloc
argument_list|(
operator|&
name|block_aux_obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
condition|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|FOR_BB_BETWEEN
argument_list|(
argument|bb
argument_list|,
argument|ENTRY_BLOCK_PTR
argument_list|,
argument|NULL
argument_list|,
argument|next_bb
argument_list|)
name|alloc_aux_for_block
argument_list|(
name|bb
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Clear AUX pointers of all blocks.  */
end_comment

begin_function
name|void
name|clear_aux_for_blocks
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|FOR_BB_BETWEEN
argument_list|(
argument|bb
argument_list|,
argument|ENTRY_BLOCK_PTR
argument_list|,
argument|NULL
argument_list|,
argument|next_bb
argument_list|)
name|bb
operator|->
name|aux
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Free data allocated in block_aux_obstack and clear AUX pointers    of all blocks.  */
end_comment

begin_function
name|void
name|free_aux_for_blocks
parameter_list|(
name|void
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|first_block_aux_obj
argument_list|)
expr_stmt|;
name|obstack_free
argument_list|(
operator|&
name|block_aux_obstack
argument_list|,
name|first_block_aux_obj
argument_list|)
expr_stmt|;
name|first_block_aux_obj
operator|=
name|NULL
expr_stmt|;
name|clear_aux_for_blocks
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Allocate a memory edge of SIZE as BB->aux.  The obstack must    be first initialized by alloc_aux_for_edges.  */
end_comment

begin_function
specifier|inline
name|void
name|alloc_aux_for_edge
parameter_list|(
name|edge
name|e
parameter_list|,
name|int
name|size
parameter_list|)
block|{
comment|/* Verify that aux field is clear.  */
name|gcc_assert
argument_list|(
operator|!
name|e
operator|->
name|aux
operator|&&
name|first_edge_aux_obj
argument_list|)
expr_stmt|;
name|e
operator|->
name|aux
operator|=
name|obstack_alloc
argument_list|(
operator|&
name|edge_aux_obstack
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|e
operator|->
name|aux
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize the edge_aux_obstack and if SIZE is nonzero, call    alloc_aux_for_edge for each basic edge.  */
end_comment

begin_function
name|void
name|alloc_aux_for_edges
parameter_list|(
name|int
name|size
parameter_list|)
block|{
specifier|static
name|int
name|initialized
decl_stmt|;
if|if
condition|(
operator|!
name|initialized
condition|)
block|{
name|gcc_obstack_init
argument_list|(
operator|&
name|edge_aux_obstack
argument_list|)
expr_stmt|;
name|initialized
operator|=
literal|1
expr_stmt|;
block|}
else|else
comment|/* Check whether AUX data are still allocated.  */
name|gcc_assert
argument_list|(
operator|!
name|first_edge_aux_obj
argument_list|)
expr_stmt|;
name|first_edge_aux_obj
operator|=
name|obstack_alloc
argument_list|(
operator|&
name|edge_aux_obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
condition|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|FOR_BB_BETWEEN
argument_list|(
argument|bb
argument_list|,
argument|ENTRY_BLOCK_PTR
argument_list|,
argument|EXIT_BLOCK_PTR
argument_list|,
argument|next_bb
argument_list|)
block|{
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
name|alloc_aux_for_edge
argument_list|(
name|e
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Clear AUX pointers of all edges.  */
end_comment

begin_function
name|void
name|clear_aux_for_edges
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|FOR_BB_BETWEEN
argument_list|(
argument|bb
argument_list|,
argument|ENTRY_BLOCK_PTR
argument_list|,
argument|EXIT_BLOCK_PTR
argument_list|,
argument|next_bb
argument_list|)
block|{
name|edge_iterator
name|ei
decl_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
name|e
operator|->
name|aux
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Free data allocated in edge_aux_obstack and clear AUX pointers    of all edges.  */
end_comment

begin_function
name|void
name|free_aux_for_edges
parameter_list|(
name|void
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|first_edge_aux_obj
argument_list|)
expr_stmt|;
name|obstack_free
argument_list|(
operator|&
name|edge_aux_obstack
argument_list|,
name|first_edge_aux_obj
argument_list|)
expr_stmt|;
name|first_edge_aux_obj
operator|=
name|NULL
expr_stmt|;
name|clear_aux_for_edges
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|debug_bb
parameter_list|(
name|basic_block
name|bb
parameter_list|)
block|{
name|dump_bb
argument_list|(
name|bb
argument_list|,
name|stderr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|basic_block
name|debug_bb_n
parameter_list|(
name|int
name|n
parameter_list|)
block|{
name|basic_block
name|bb
init|=
name|BASIC_BLOCK
argument_list|(
name|n
argument_list|)
decl_stmt|;
name|dump_bb
argument_list|(
name|bb
argument_list|,
name|stderr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|bb
return|;
block|}
end_function

begin_comment
comment|/* Dumps cfg related information about basic block BB to FILE.  */
end_comment

begin_function
specifier|static
name|void
name|dump_cfg_bb_info
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|basic_block
name|bb
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|bool
name|first
init|=
name|true
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|bb_bitnames
index|[]
init|=
block|{
literal|"dirty"
block|,
literal|"new"
block|,
literal|"reachable"
block|,
literal|"visited"
block|,
literal|"irreducible_loop"
block|,
literal|"superblock"
block|}
decl_stmt|;
specifier|const
name|unsigned
name|n_bitnames
init|=
sizeof|sizeof
argument_list|(
name|bb_bitnames
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"Basic block %d"
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_bitnames
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|bb
operator|->
name|flags
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
block|{
if|if
condition|(
name|first
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" ("
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|first
operator|=
name|false
expr_stmt|;
name|fputs
argument_list|(
name|bb_bitnames
index|[
name|i
index|]
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|first
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"Predecessors: "
argument_list|)
expr_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->preds
argument_list|)
name|dump_edge_info
argument_list|(
name|file
argument_list|,
name|e
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\nSuccessors: "
argument_list|)
expr_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
name|dump_edge_info
argument_list|(
name|file
argument_list|,
name|e
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dumps a brief description of cfg to FILE.  */
end_comment

begin_function
name|void
name|brief_dump_cfg
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|dump_cfg_bb_info
argument_list|(
name|file
argument_list|,
name|bb
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* An edge originally destinating BB of FREQUENCY and COUNT has been proved to    leave the block by TAKEN_EDGE.  Update profile of BB such that edge E can be    redirected to destination of TAKEN_EDGE.     This function may leave the profile inconsistent in the case TAKEN_EDGE    frequency or count is believed to be lower than FREQUENCY or COUNT    respectively.  */
end_comment

begin_function
name|void
name|update_bb_profile_for_threading
parameter_list|(
name|basic_block
name|bb
parameter_list|,
name|int
name|edge_frequency
parameter_list|,
name|gcov_type
name|count
parameter_list|,
name|edge
name|taken_edge
parameter_list|)
block|{
name|edge
name|c
decl_stmt|;
name|int
name|prob
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|bb
operator|->
name|count
operator|-=
name|count
expr_stmt|;
if|if
condition|(
name|bb
operator|->
name|count
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"bb %i count became negative after threading"
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|bb
operator|->
name|count
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Compute the probability of TAKEN_EDGE being reached via threaded edge.      Watch for overflows.  */
if|if
condition|(
name|bb
operator|->
name|frequency
condition|)
name|prob
operator|=
name|edge_frequency
operator|*
name|REG_BR_PROB_BASE
operator|/
name|bb
operator|->
name|frequency
expr_stmt|;
else|else
name|prob
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|prob
operator|>
name|taken_edge
operator|->
name|probability
condition|)
block|{
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Jump threading proved probability of edge "
literal|"%i->%i too small (it is %i, should be %i).\n"
argument_list|,
name|taken_edge
operator|->
name|src
operator|->
name|index
argument_list|,
name|taken_edge
operator|->
name|dest
operator|->
name|index
argument_list|,
name|taken_edge
operator|->
name|probability
argument_list|,
name|prob
argument_list|)
expr_stmt|;
name|prob
operator|=
name|taken_edge
operator|->
name|probability
expr_stmt|;
block|}
comment|/* Now rescale the probabilities.  */
name|taken_edge
operator|->
name|probability
operator|-=
name|prob
expr_stmt|;
name|prob
operator|=
name|REG_BR_PROB_BASE
operator|-
name|prob
expr_stmt|;
name|bb
operator|->
name|frequency
operator|-=
name|edge_frequency
expr_stmt|;
if|if
condition|(
name|bb
operator|->
name|frequency
operator|<
literal|0
condition|)
name|bb
operator|->
name|frequency
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|prob
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Edge frequencies of bb %i has been reset, "
literal|"frequency of block should end up being 0, it is %i\n"
argument_list|,
name|bb
operator|->
name|index
argument_list|,
name|bb
operator|->
name|frequency
argument_list|)
expr_stmt|;
name|EDGE_SUCC
argument_list|(
name|bb
argument_list|,
literal|0
argument_list|)
operator|->
name|probability
operator|=
name|REG_BR_PROB_BASE
expr_stmt|;
name|ei
operator|=
name|ei_start
argument_list|(
name|bb
operator|->
name|succs
argument_list|)
expr_stmt|;
name|ei_next
argument_list|(
operator|&
name|ei
argument_list|)
expr_stmt|;
for|for
control|(
init|;
operator|(
name|c
operator|=
name|ei_safe_edge
argument_list|(
name|ei
argument_list|)
operator|)
condition|;
name|ei_next
argument_list|(
operator|&
name|ei
argument_list|)
control|)
name|c
operator|->
name|probability
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|prob
operator|!=
name|REG_BR_PROB_BASE
condition|)
block|{
name|int
name|scale
init|=
name|RDIV
argument_list|(
literal|65536
operator|*
name|REG_BR_PROB_BASE
argument_list|,
name|prob
argument_list|)
decl_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|c
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
block|{
name|c
operator|->
name|probability
operator|=
name|RDIV
argument_list|(
name|c
operator|->
name|probability
operator|*
name|scale
argument_list|,
literal|65536
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|probability
operator|>
name|REG_BR_PROB_BASE
condition|)
name|c
operator|->
name|probability
operator|=
name|REG_BR_PROB_BASE
expr_stmt|;
block|}
block|}
name|gcc_assert
argument_list|(
name|bb
operator|==
name|taken_edge
operator|->
name|src
argument_list|)
expr_stmt|;
name|taken_edge
operator|->
name|count
operator|-=
name|count
expr_stmt|;
if|if
condition|(
name|taken_edge
operator|->
name|count
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"edge %i->%i count became negative after threading"
argument_list|,
name|taken_edge
operator|->
name|src
operator|->
name|index
argument_list|,
name|taken_edge
operator|->
name|dest
operator|->
name|index
argument_list|)
expr_stmt|;
name|taken_edge
operator|->
name|count
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Multiply all frequencies of basic blocks in array BBS of length NBBS    by NUM/DEN, in int arithmetic.  May lose some accuracy.  */
end_comment

begin_function
name|void
name|scale_bbs_frequencies_int
parameter_list|(
name|basic_block
modifier|*
name|bbs
parameter_list|,
name|int
name|nbbs
parameter_list|,
name|int
name|num
parameter_list|,
name|int
name|den
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|edge
name|e
decl_stmt|;
if|if
condition|(
name|num
operator|<
literal|0
condition|)
name|num
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|num
operator|>
name|den
condition|)
return|return;
comment|/* Assume that the users are producing the fraction from frequencies      that never grow far enough to risk arithmetic overflow.  */
name|gcc_assert
argument_list|(
name|num
operator|<
literal|65536
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nbbs
condition|;
name|i
operator|++
control|)
block|{
name|edge_iterator
name|ei
decl_stmt|;
name|bbs
index|[
name|i
index|]
operator|->
name|frequency
operator|=
name|RDIV
argument_list|(
name|bbs
index|[
name|i
index|]
operator|->
name|frequency
operator|*
name|num
argument_list|,
name|den
argument_list|)
expr_stmt|;
name|bbs
index|[
name|i
index|]
operator|->
name|count
operator|=
name|RDIV
argument_list|(
name|bbs
index|[
name|i
index|]
operator|->
name|count
operator|*
name|num
argument_list|,
name|den
argument_list|)
expr_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bbs[i]->succs
argument_list|)
name|e
operator|->
name|count
operator|=
name|RDIV
argument_list|(
name|e
operator|->
name|count
operator|*
name|num
argument_list|,
name|den
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* numbers smaller than this value are safe to multiply without getting    64bit overflow.  */
end_comment

begin_define
define|#
directive|define
name|MAX_SAFE_MULTIPLIER
value|(1<< (sizeof (HOST_WIDEST_INT) * 4 - 1))
end_define

begin_comment
comment|/* Multiply all frequencies of basic blocks in array BBS of length NBBS    by NUM/DEN, in gcov_type arithmetic.  More accurate than previous    function but considerably slower.  */
end_comment

begin_function
name|void
name|scale_bbs_frequencies_gcov_type
parameter_list|(
name|basic_block
modifier|*
name|bbs
parameter_list|,
name|int
name|nbbs
parameter_list|,
name|gcov_type
name|num
parameter_list|,
name|gcov_type
name|den
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|gcov_type
name|fraction
init|=
name|RDIV
argument_list|(
name|num
operator|*
literal|65536
argument_list|,
name|den
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
name|fraction
operator|>=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|num
operator|<
name|MAX_SAFE_MULTIPLIER
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nbbs
condition|;
name|i
operator|++
control|)
block|{
name|edge_iterator
name|ei
decl_stmt|;
name|bbs
index|[
name|i
index|]
operator|->
name|frequency
operator|=
name|RDIV
argument_list|(
name|bbs
index|[
name|i
index|]
operator|->
name|frequency
operator|*
name|num
argument_list|,
name|den
argument_list|)
expr_stmt|;
if|if
condition|(
name|bbs
index|[
name|i
index|]
operator|->
name|count
operator|<=
name|MAX_SAFE_MULTIPLIER
condition|)
name|bbs
index|[
name|i
index|]
operator|->
name|count
operator|=
name|RDIV
argument_list|(
name|bbs
index|[
name|i
index|]
operator|->
name|count
operator|*
name|num
argument_list|,
name|den
argument_list|)
expr_stmt|;
else|else
name|bbs
index|[
name|i
index|]
operator|->
name|count
operator|=
name|RDIV
argument_list|(
name|bbs
index|[
name|i
index|]
operator|->
name|count
operator|*
name|fraction
argument_list|,
literal|65536
argument_list|)
expr_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bbs[i]->succs
argument_list|)
if|if
condition|(
name|bbs
index|[
name|i
index|]
operator|->
name|count
operator|<=
name|MAX_SAFE_MULTIPLIER
condition|)
name|e
operator|->
name|count
operator|=
name|RDIV
argument_list|(
name|e
operator|->
name|count
operator|*
name|num
argument_list|,
name|den
argument_list|)
expr_stmt|;
else|else
name|e
operator|->
name|count
operator|=
name|RDIV
argument_list|(
name|e
operator|->
name|count
operator|*
name|fraction
argument_list|,
literal|65536
argument_list|)
expr_stmt|;
block|}
else|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nbbs
condition|;
name|i
operator|++
control|)
block|{
name|edge_iterator
name|ei
decl_stmt|;
if|if
condition|(
sizeof|sizeof
argument_list|(
name|gcov_type
argument_list|)
operator|>
sizeof|sizeof
argument_list|(
name|int
argument_list|)
condition|)
name|bbs
index|[
name|i
index|]
operator|->
name|frequency
operator|=
name|RDIV
argument_list|(
name|bbs
index|[
name|i
index|]
operator|->
name|frequency
operator|*
name|num
argument_list|,
name|den
argument_list|)
expr_stmt|;
else|else
name|bbs
index|[
name|i
index|]
operator|->
name|frequency
operator|=
name|RDIV
argument_list|(
name|bbs
index|[
name|i
index|]
operator|->
name|frequency
operator|*
name|fraction
argument_list|,
literal|65536
argument_list|)
expr_stmt|;
name|bbs
index|[
name|i
index|]
operator|->
name|count
operator|=
name|RDIV
argument_list|(
name|bbs
index|[
name|i
index|]
operator|->
name|count
operator|*
name|fraction
argument_list|,
literal|65536
argument_list|)
expr_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bbs[i]->succs
argument_list|)
name|e
operator|->
name|count
operator|=
name|RDIV
argument_list|(
name|e
operator|->
name|count
operator|*
name|fraction
argument_list|,
literal|65536
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Data structures used to maintain mapping between basic blocks and    copies.  */
end_comment

begin_decl_stmt
specifier|static
name|htab_t
name|bb_original
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|htab_t
name|bb_copy
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|alloc_pool
name|original_copy_bb_pool
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|htab_bb_copy_original_entry
block|{
comment|/* Block we are attaching info to.  */
name|int
name|index1
decl_stmt|;
comment|/* Index of original or copy (depending on the hashtable) */
name|int
name|index2
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|hashval_t
name|bb_copy_original_hash
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|htab_bb_copy_original_entry
modifier|*
name|data
init|=
operator|(
operator|(
expr|struct
name|htab_bb_copy_original_entry
operator|*
operator|)
name|p
operator|)
decl_stmt|;
return|return
name|data
operator|->
name|index1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bb_copy_original_eq
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|,
specifier|const
name|void
modifier|*
name|q
parameter_list|)
block|{
name|struct
name|htab_bb_copy_original_entry
modifier|*
name|data
init|=
operator|(
operator|(
expr|struct
name|htab_bb_copy_original_entry
operator|*
operator|)
name|p
operator|)
decl_stmt|;
name|struct
name|htab_bb_copy_original_entry
modifier|*
name|data2
init|=
operator|(
operator|(
expr|struct
name|htab_bb_copy_original_entry
operator|*
operator|)
name|q
operator|)
decl_stmt|;
return|return
name|data
operator|->
name|index1
operator|==
name|data2
operator|->
name|index1
return|;
block|}
end_function

begin_comment
comment|/* Initialize the data structures to maintain mapping between blocks    and its copies.  */
end_comment

begin_function
name|void
name|initialize_original_copy_tables
parameter_list|(
name|void
parameter_list|)
block|{
name|gcc_assert
argument_list|(
operator|!
name|original_copy_bb_pool
argument_list|)
expr_stmt|;
name|original_copy_bb_pool
operator|=
name|create_alloc_pool
argument_list|(
literal|"original_copy"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|htab_bb_copy_original_entry
argument_list|)
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|bb_original
operator|=
name|htab_create
argument_list|(
literal|10
argument_list|,
name|bb_copy_original_hash
argument_list|,
name|bb_copy_original_eq
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|bb_copy
operator|=
name|htab_create
argument_list|(
literal|10
argument_list|,
name|bb_copy_original_hash
argument_list|,
name|bb_copy_original_eq
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Free the data structures to maintain mapping between blocks and    its copies.  */
end_comment

begin_function
name|void
name|free_original_copy_tables
parameter_list|(
name|void
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|original_copy_bb_pool
argument_list|)
expr_stmt|;
name|htab_delete
argument_list|(
name|bb_copy
argument_list|)
expr_stmt|;
name|htab_delete
argument_list|(
name|bb_original
argument_list|)
expr_stmt|;
name|free_alloc_pool
argument_list|(
name|original_copy_bb_pool
argument_list|)
expr_stmt|;
name|bb_copy
operator|=
name|NULL
expr_stmt|;
name|bb_original
operator|=
name|NULL
expr_stmt|;
name|original_copy_bb_pool
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set original for basic block.  Do nothing when data structures are not    initialized so passes not needing this don't need to care.  */
end_comment

begin_function
name|void
name|set_bb_original
parameter_list|(
name|basic_block
name|bb
parameter_list|,
name|basic_block
name|original
parameter_list|)
block|{
if|if
condition|(
name|original_copy_bb_pool
condition|)
block|{
name|struct
name|htab_bb_copy_original_entry
modifier|*
modifier|*
name|slot
decl_stmt|;
name|struct
name|htab_bb_copy_original_entry
name|key
decl_stmt|;
name|key
operator|.
name|index1
operator|=
name|bb
operator|->
name|index
expr_stmt|;
name|slot
operator|=
operator|(
expr|struct
name|htab_bb_copy_original_entry
operator|*
operator|*
operator|)
name|htab_find_slot
argument_list|(
name|bb_original
argument_list|,
operator|&
name|key
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|slot
condition|)
operator|(
operator|*
name|slot
operator|)
operator|->
name|index2
operator|=
name|original
operator|->
name|index
expr_stmt|;
else|else
block|{
operator|*
name|slot
operator|=
name|pool_alloc
argument_list|(
name|original_copy_bb_pool
argument_list|)
expr_stmt|;
operator|(
operator|*
name|slot
operator|)
operator|->
name|index1
operator|=
name|bb
operator|->
name|index
expr_stmt|;
operator|(
operator|*
name|slot
operator|)
operator|->
name|index2
operator|=
name|original
operator|->
name|index
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Get the original basic block.  */
end_comment

begin_function
name|basic_block
name|get_bb_original
parameter_list|(
name|basic_block
name|bb
parameter_list|)
block|{
name|struct
name|htab_bb_copy_original_entry
modifier|*
name|entry
decl_stmt|;
name|struct
name|htab_bb_copy_original_entry
name|key
decl_stmt|;
name|gcc_assert
argument_list|(
name|original_copy_bb_pool
argument_list|)
expr_stmt|;
name|key
operator|.
name|index1
operator|=
name|bb
operator|->
name|index
expr_stmt|;
name|entry
operator|=
operator|(
expr|struct
name|htab_bb_copy_original_entry
operator|*
operator|)
name|htab_find
argument_list|(
name|bb_original
argument_list|,
operator|&
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
condition|)
return|return
name|BASIC_BLOCK
argument_list|(
name|entry
operator|->
name|index2
argument_list|)
return|;
else|else
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Set copy for basic block.  Do nothing when data structures are not    initialized so passes not needing this don't need to care.  */
end_comment

begin_function
name|void
name|set_bb_copy
parameter_list|(
name|basic_block
name|bb
parameter_list|,
name|basic_block
name|copy
parameter_list|)
block|{
if|if
condition|(
name|original_copy_bb_pool
condition|)
block|{
name|struct
name|htab_bb_copy_original_entry
modifier|*
modifier|*
name|slot
decl_stmt|;
name|struct
name|htab_bb_copy_original_entry
name|key
decl_stmt|;
name|key
operator|.
name|index1
operator|=
name|bb
operator|->
name|index
expr_stmt|;
name|slot
operator|=
operator|(
expr|struct
name|htab_bb_copy_original_entry
operator|*
operator|*
operator|)
name|htab_find_slot
argument_list|(
name|bb_copy
argument_list|,
operator|&
name|key
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|slot
condition|)
operator|(
operator|*
name|slot
operator|)
operator|->
name|index2
operator|=
name|copy
operator|->
name|index
expr_stmt|;
else|else
block|{
operator|*
name|slot
operator|=
name|pool_alloc
argument_list|(
name|original_copy_bb_pool
argument_list|)
expr_stmt|;
operator|(
operator|*
name|slot
operator|)
operator|->
name|index1
operator|=
name|bb
operator|->
name|index
expr_stmt|;
operator|(
operator|*
name|slot
operator|)
operator|->
name|index2
operator|=
name|copy
operator|->
name|index
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Get the copy of basic block.  */
end_comment

begin_function
name|basic_block
name|get_bb_copy
parameter_list|(
name|basic_block
name|bb
parameter_list|)
block|{
name|struct
name|htab_bb_copy_original_entry
modifier|*
name|entry
decl_stmt|;
name|struct
name|htab_bb_copy_original_entry
name|key
decl_stmt|;
name|gcc_assert
argument_list|(
name|original_copy_bb_pool
argument_list|)
expr_stmt|;
name|key
operator|.
name|index1
operator|=
name|bb
operator|->
name|index
expr_stmt|;
name|entry
operator|=
operator|(
expr|struct
name|htab_bb_copy_original_entry
operator|*
operator|)
name|htab_find
argument_list|(
name|bb_copy
argument_list|,
operator|&
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
condition|)
return|return
name|BASIC_BLOCK
argument_list|(
name|entry
operator|->
name|index2
argument_list|)
return|;
else|else
return|return
name|NULL
return|;
block|}
end_function

end_unit

