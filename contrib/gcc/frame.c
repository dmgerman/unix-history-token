begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Subroutines needed for unwinding stack frames for exception handling.  */
end_comment

begin_comment
comment|/* Compile this one with gcc.  */
end_comment

begin_comment
comment|/* Copyright (C) 1997, 1998, 2000 Free Software Foundation, Inc.    Contributed by Jason Merrill<jason@cygnus.com>.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* As a special exception, if you link this library with other files,    some of which are compiled with GCC, to produce an executable,    this library does not by itself cause the resulting executable    to be covered by the GNU General Public License.    This exception does not however invalidate any other reasons why    the executable file might be covered by the GNU General Public License.  */
end_comment

begin_comment
comment|/* It is incorrect to include config.h here, because this file is being    compiled for the target, and hence definitions concerning only the host    do not apply.  */
end_comment

begin_include
include|#
directive|include
file|"tconfig.h"
end_include

begin_comment
comment|/* We disable this when inhibit_libc, so that gcc can still be built without    needing header files first.  */
end_comment

begin_comment
comment|/* ??? This is not a good solution, since prototypes may be required in    some cases for correct code.  See also libgcc2.c.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|inhibit_libc
end_ifndef

begin_comment
comment|/* fixproto guarantees these system headers exist. */
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"defaults.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DWARF2_UNWIND_INFO
end_ifdef

begin_include
include|#
directive|include
file|"dwarf2.h"
end_include

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"gthr.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__GTHREAD_MUTEX_INIT
end_ifdef

begin_decl_stmt
specifier|static
name|__gthread_mutex_t
name|object_mutex
init|=
name|__GTHREAD_MUTEX_INIT
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|__gthread_mutex_t
name|object_mutex
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Don't use `fancy_abort' here even if config.h says to use it.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|abort
end_ifdef

begin_undef
undef|#
directive|undef
name|abort
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Some types used by the DWARF 2 spec.  */
end_comment

begin_typedef
typedef|typedef
name|int
name|sword
name|__attribute__
typedef|((
name|mode
typedef|(
name|SI
typedef|)));
end_typedef

begin_typedef
typedef|typedef
name|unsigned
name|int
name|uword
name|__attribute__
typedef|((
name|mode
typedef|(
name|SI
typedef|)));
end_typedef

begin_typedef
typedef|typedef
name|unsigned
name|int
name|uaddr
name|__attribute__
typedef|((
name|mode
typedef|(
name|pointer
typedef|)));
end_typedef

begin_typedef
typedef|typedef
name|int
name|saddr
name|__attribute__
typedef|((
name|mode
typedef|(
name|pointer
typedef|)));
end_typedef

begin_typedef
typedef|typedef
name|unsigned
name|char
name|ubyte
typedef|;
end_typedef

begin_comment
comment|/* Terminology:    CIE - Common Information Element    FDE - Frame Descriptor Element     There is one per function, and it describes where the function code    is located, and what the register lifetimes and stack layout are    within the function.     The data structures are defined in the DWARF specfication, although    not in a very readable way (see LITERATURE).     Every time an exception is thrown, the code needs to locate the FDE    for the current function, and starts to look for exception regions    from that FDE. This works in a two-level search:    a) in a linear search, find the shared image (i.e. DLL) containing       the PC    b) using the FDE table for that shared object, locate the FDE using       binary search (which requires the sorting).  */
end_comment

begin_comment
comment|/* The first few fields of a CIE.  The CIE_id field is 0 for a CIE,    to distinguish it from a valid FDE.  FDEs are aligned to an addressing    unit boundary, but the fields within are unaligned.  */
end_comment

begin_struct
struct|struct
name|dwarf_cie
block|{
name|uword
name|length
decl_stmt|;
name|sword
name|CIE_id
decl_stmt|;
name|ubyte
name|version
decl_stmt|;
name|char
name|augmentation
index|[
literal|0
index|]
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|,
name|aligned
argument_list|(
name|__alignof__
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
operator|)
argument_list|)
struct|;
end_struct

begin_comment
comment|/* The first few fields of an FDE.  */
end_comment

begin_struct
struct|struct
name|dwarf_fde
block|{
name|uword
name|length
decl_stmt|;
name|sword
name|CIE_delta
decl_stmt|;
name|void
modifier|*
name|pc_begin
decl_stmt|;
name|uaddr
name|pc_range
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|,
name|aligned
argument_list|(
name|__alignof__
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
operator|)
argument_list|)
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|dwarf_fde
name|fde
typedef|;
end_typedef

begin_comment
comment|/* Objects to be searched for frame unwind info.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|object
modifier|*
name|objects
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The information we care about from a CIE.  */
end_comment

begin_struct
struct|struct
name|cie_info
block|{
name|char
modifier|*
name|augmentation
decl_stmt|;
name|void
modifier|*
name|eh_ptr
decl_stmt|;
name|int
name|code_align
decl_stmt|;
name|int
name|data_align
decl_stmt|;
name|unsigned
name|ra_regno
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The current unwind state, plus a saved copy for DW_CFA_remember_state.  */
end_comment

begin_struct
struct|struct
name|frame_state_internal
block|{
name|struct
name|frame_state
name|s
decl_stmt|;
name|struct
name|frame_state_internal
modifier|*
name|saved_state
decl_stmt|;
block|}
struct|;
end_struct

begin_escape
end_escape

begin_comment
comment|/* This is undefined below if we need it to be an actual function.  */
end_comment

begin_define
define|#
directive|define
name|init_object_mutex_once
parameter_list|()
end_define

begin_if
if|#
directive|if
name|__GTHREADS
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|__GTHREAD_MUTEX_INIT_FUNCTION
end_ifdef

begin_comment
comment|/* Helper for init_object_mutex_once.  */
end_comment

begin_function
specifier|static
name|void
name|init_object_mutex
parameter_list|(
name|void
parameter_list|)
block|{
name|__GTHREAD_MUTEX_INIT_FUNCTION
argument_list|(
operator|&
name|object_mutex
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Call this to arrange to initialize the object mutex.  */
end_comment

begin_undef
undef|#
directive|undef
name|init_object_mutex_once
end_undef

begin_function
specifier|static
name|void
name|init_object_mutex_once
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|__gthread_once_t
name|once
init|=
name|__GTHREAD_ONCE_INIT
decl_stmt|;
name|__gthread_once
argument_list|(
operator|&
name|once
argument_list|,
name|init_object_mutex
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __GTHREAD_MUTEX_INIT_FUNCTION */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __GTHREADS */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Decode the unsigned LEB128 constant at BUF into the variable pointed to    by R, and return the new value of BUF.  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|decode_uleb128
parameter_list|(
name|unsigned
name|char
modifier|*
name|buf
parameter_list|,
name|unsigned
modifier|*
name|r
parameter_list|)
block|{
name|unsigned
name|shift
init|=
literal|0
decl_stmt|;
name|unsigned
name|result
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|unsigned
name|byte
init|=
operator|*
name|buf
operator|++
decl_stmt|;
name|result
operator||=
operator|(
name|byte
operator|&
literal|0x7f
operator|)
operator|<<
name|shift
expr_stmt|;
if|if
condition|(
operator|(
name|byte
operator|&
literal|0x80
operator|)
operator|==
literal|0
condition|)
break|break;
name|shift
operator|+=
literal|7
expr_stmt|;
block|}
operator|*
name|r
operator|=
name|result
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_comment
comment|/* Decode the signed LEB128 constant at BUF into the variable pointed to    by R, and return the new value of BUF.  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|decode_sleb128
parameter_list|(
name|unsigned
name|char
modifier|*
name|buf
parameter_list|,
name|int
modifier|*
name|r
parameter_list|)
block|{
name|unsigned
name|shift
init|=
literal|0
decl_stmt|;
name|unsigned
name|result
init|=
literal|0
decl_stmt|;
name|unsigned
name|byte
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|byte
operator|=
operator|*
name|buf
operator|++
expr_stmt|;
name|result
operator||=
operator|(
name|byte
operator|&
literal|0x7f
operator|)
operator|<<
name|shift
expr_stmt|;
name|shift
operator|+=
literal|7
expr_stmt|;
if|if
condition|(
operator|(
name|byte
operator|&
literal|0x80
operator|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|shift
operator|<
operator|(
sizeof|sizeof
argument_list|(
operator|*
name|r
argument_list|)
operator|*
literal|8
operator|)
operator|&&
operator|(
name|byte
operator|&
literal|0x40
operator|)
operator|!=
literal|0
condition|)
name|result
operator||=
operator|-
operator|(
literal|1
operator|<<
name|shift
operator|)
expr_stmt|;
operator|*
name|r
operator|=
name|result
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_comment
comment|/* Read unaligned data from the instruction buffer.  */
end_comment

begin_union
union|union
name|unaligned
block|{
name|void
modifier|*
name|p
decl_stmt|;
name|unsigned
name|b2
name|__attribute__
argument_list|(
operator|(
name|mode
argument_list|(
name|HI
argument_list|)
operator|)
argument_list|)
decl_stmt|;
name|unsigned
name|b4
name|__attribute__
argument_list|(
operator|(
name|mode
argument_list|(
name|SI
argument_list|)
operator|)
argument_list|)
decl_stmt|;
name|unsigned
name|b8
name|__attribute__
argument_list|(
operator|(
name|mode
argument_list|(
name|DI
argument_list|)
operator|)
argument_list|)
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
union|;
end_union

begin_function
specifier|static
specifier|inline
name|void
modifier|*
name|read_pointer
parameter_list|(
name|void
modifier|*
name|p
parameter_list|)
block|{
name|union
name|unaligned
modifier|*
name|up
init|=
name|p
decl_stmt|;
return|return
name|up
operator|->
name|p
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|unsigned
name|read_1byte
parameter_list|(
name|void
modifier|*
name|p
parameter_list|)
block|{
return|return
operator|*
operator|(
name|unsigned
name|char
operator|*
operator|)
name|p
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|unsigned
name|read_2byte
parameter_list|(
name|void
modifier|*
name|p
parameter_list|)
block|{
name|union
name|unaligned
modifier|*
name|up
init|=
name|p
decl_stmt|;
return|return
name|up
operator|->
name|b2
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|unsigned
name|read_4byte
parameter_list|(
name|void
modifier|*
name|p
parameter_list|)
block|{
name|union
name|unaligned
modifier|*
name|up
init|=
name|p
decl_stmt|;
return|return
name|up
operator|->
name|b4
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|unsigned
name|long
name|read_8byte
parameter_list|(
name|void
modifier|*
name|p
parameter_list|)
block|{
name|union
name|unaligned
modifier|*
name|up
init|=
name|p
decl_stmt|;
return|return
name|up
operator|->
name|b8
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Ordering function for FDEs.  Functions can't overlap, so we just compare    their starting addresses.  */
end_comment

begin_function
specifier|static
specifier|inline
name|saddr
name|fde_compare
parameter_list|(
name|fde
modifier|*
name|x
parameter_list|,
name|fde
modifier|*
name|y
parameter_list|)
block|{
return|return
operator|(
name|saddr
operator|)
name|x
operator|->
name|pc_begin
operator|-
operator|(
name|saddr
operator|)
name|y
operator|->
name|pc_begin
return|;
block|}
end_function

begin_comment
comment|/* Return the address of the FDE after P.  */
end_comment

begin_function
specifier|static
specifier|inline
name|fde
modifier|*
name|next_fde
parameter_list|(
name|fde
modifier|*
name|p
parameter_list|)
block|{
return|return
operator|(
name|fde
operator|*
operator|)
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
name|p
operator|)
operator|+
name|p
operator|->
name|length
operator|+
sizeof|sizeof
argument_list|(
name|p
operator|->
name|length
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Sorting an array of FDEs by address.    (Ideally we would have the linker sort the FDEs so we don't have to do    it at run time. But the linkers are not yet prepared for this.)  */
end_comment

begin_comment
comment|/* This is a special mix of insertion sort and heap sort, optimized for    the data sets that actually occur. They look like    101 102 103 127 128 105 108 110 190 111 115 119 125 160 126 129 130.    I.e. a linearly increasing sequence (coming from functions in the text    section), with additionally a few unordered elements (coming from functions    in gnu_linkonce sections) whose values are higher than the values in the    surrounding linear sequence (but not necessarily higher than the values    at the end of the linear sequence!).    The worst-case total run time is O(N) + O(n log (n)), where N is the    total number of FDEs and n is the number of erratic ones.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|fde_vector
block|{
name|fde
modifier|*
modifier|*
name|array
decl_stmt|;
name|size_t
name|count
decl_stmt|;
block|}
name|fde_vector
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|fde_accumulator
block|{
name|fde_vector
name|linear
decl_stmt|;
name|fde_vector
name|erratic
decl_stmt|;
block|}
name|fde_accumulator
typedef|;
end_typedef

begin_function
specifier|static
specifier|inline
name|void
name|start_fde_sort
parameter_list|(
name|fde_accumulator
modifier|*
name|accu
parameter_list|,
name|size_t
name|count
parameter_list|)
block|{
name|accu
operator|->
name|linear
operator|.
name|array
operator|=
operator|(
name|fde
operator|*
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|fde
operator|*
argument_list|)
operator|*
name|count
argument_list|)
expr_stmt|;
name|accu
operator|->
name|erratic
operator|.
name|array
operator|=
operator|(
name|fde
operator|*
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|fde
operator|*
argument_list|)
operator|*
name|count
argument_list|)
expr_stmt|;
name|accu
operator|->
name|linear
operator|.
name|count
operator|=
literal|0
expr_stmt|;
name|accu
operator|->
name|erratic
operator|.
name|count
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|fde_insert
parameter_list|(
name|fde_accumulator
modifier|*
name|accu
parameter_list|,
name|fde
modifier|*
name|this_fde
parameter_list|)
block|{
name|accu
operator|->
name|linear
operator|.
name|array
index|[
name|accu
operator|->
name|linear
operator|.
name|count
operator|++
index|]
operator|=
name|this_fde
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Split LINEAR into a linear sequence with low values and an erratic    sequence with high values, put the linear one (of longest possible    length) into LINEAR and the erratic one into ERRATIC. This is O(N).  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|fde_split
parameter_list|(
name|fde_vector
modifier|*
name|linear
parameter_list|,
name|fde_vector
modifier|*
name|erratic
parameter_list|)
block|{
name|size_t
name|count
init|=
name|linear
operator|->
name|count
decl_stmt|;
name|size_t
name|linear_max
init|=
operator|(
name|size_t
operator|)
operator|-
literal|1
decl_stmt|;
name|size_t
name|previous_max
index|[
name|count
index|]
decl_stmt|;
name|size_t
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
name|linear_max
init|;
name|j
operator|!=
operator|(
name|size_t
operator|)
operator|-
literal|1
operator|&&
name|fde_compare
argument_list|(
name|linear
operator|->
name|array
index|[
name|i
index|]
argument_list|,
name|linear
operator|->
name|array
index|[
name|j
index|]
argument_list|)
operator|<
literal|0
condition|;
name|j
operator|=
name|previous_max
index|[
name|j
index|]
control|)
block|{
name|erratic
operator|->
name|array
index|[
name|erratic
operator|->
name|count
operator|++
index|]
operator|=
name|linear
operator|->
name|array
index|[
name|j
index|]
expr_stmt|;
name|linear
operator|->
name|array
index|[
name|j
index|]
operator|=
operator|(
name|fde
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
name|previous_max
index|[
name|i
index|]
operator|=
name|j
expr_stmt|;
name|linear_max
operator|=
name|i
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|linear
operator|->
name|array
index|[
name|i
index|]
operator|!=
operator|(
name|fde
operator|*
operator|)
name|NULL
condition|)
name|linear
operator|->
name|array
index|[
name|j
operator|++
index|]
operator|=
name|linear
operator|->
name|array
index|[
name|i
index|]
expr_stmt|;
name|linear
operator|->
name|count
operator|=
name|j
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is O(n log(n)).  BSD/OS defines heapsort in stdlib.h, so we must    use a name that does not conflict.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|frame_heapsort
parameter_list|(
name|fde_vector
modifier|*
name|erratic
parameter_list|)
block|{
comment|/* For a description of this algorithm, see:      Samuel P. Harbison, Guy L. Steele Jr.: C, a reference manual, 2nd ed.,      p. 60-61. */
name|fde
modifier|*
modifier|*
name|a
init|=
name|erratic
operator|->
name|array
decl_stmt|;
comment|/* A portion of the array is called a "heap" if for all i>=0:      If i and 2i+1 are valid indices, then a[i]>= a[2i+1].      If i and 2i+2 are valid indices, then a[i]>= a[2i+2]. */
define|#
directive|define
name|SWAP
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|do { fde * tmp = x; x = y; y = tmp; } while (0)
name|size_t
name|n
init|=
name|erratic
operator|->
name|count
decl_stmt|;
name|size_t
name|m
init|=
name|n
decl_stmt|;
name|size_t
name|i
decl_stmt|;
while|while
condition|(
name|m
operator|>
literal|0
condition|)
block|{
comment|/* Invariant: a[m..n-1] is a heap. */
name|m
operator|--
expr_stmt|;
for|for
control|(
name|i
operator|=
name|m
init|;
literal|2
operator|*
name|i
operator|+
literal|1
operator|<
name|n
condition|;
control|)
block|{
if|if
condition|(
literal|2
operator|*
name|i
operator|+
literal|2
operator|<
name|n
operator|&&
name|fde_compare
argument_list|(
name|a
index|[
literal|2
operator|*
name|i
operator|+
literal|2
index|]
argument_list|,
name|a
index|[
literal|2
operator|*
name|i
operator|+
literal|1
index|]
argument_list|)
operator|>
literal|0
operator|&&
name|fde_compare
argument_list|(
name|a
index|[
literal|2
operator|*
name|i
operator|+
literal|2
index|]
argument_list|,
name|a
index|[
name|i
index|]
argument_list|)
operator|>
literal|0
condition|)
block|{
name|SWAP
argument_list|(
name|a
index|[
name|i
index|]
argument_list|,
name|a
index|[
literal|2
operator|*
name|i
operator|+
literal|2
index|]
argument_list|)
expr_stmt|;
name|i
operator|=
literal|2
operator|*
name|i
operator|+
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fde_compare
argument_list|(
name|a
index|[
literal|2
operator|*
name|i
operator|+
literal|1
index|]
argument_list|,
name|a
index|[
name|i
index|]
argument_list|)
operator|>
literal|0
condition|)
block|{
name|SWAP
argument_list|(
name|a
index|[
name|i
index|]
argument_list|,
name|a
index|[
literal|2
operator|*
name|i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
name|i
operator|=
literal|2
operator|*
name|i
operator|+
literal|1
expr_stmt|;
block|}
else|else
break|break;
block|}
block|}
while|while
condition|(
name|n
operator|>
literal|1
condition|)
block|{
comment|/* Invariant: a[0..n-1] is a heap. */
name|n
operator|--
expr_stmt|;
name|SWAP
argument_list|(
name|a
index|[
literal|0
index|]
argument_list|,
name|a
index|[
name|n
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
literal|2
operator|*
name|i
operator|+
literal|1
operator|<
name|n
condition|;
control|)
block|{
if|if
condition|(
literal|2
operator|*
name|i
operator|+
literal|2
operator|<
name|n
operator|&&
name|fde_compare
argument_list|(
name|a
index|[
literal|2
operator|*
name|i
operator|+
literal|2
index|]
argument_list|,
name|a
index|[
literal|2
operator|*
name|i
operator|+
literal|1
index|]
argument_list|)
operator|>
literal|0
operator|&&
name|fde_compare
argument_list|(
name|a
index|[
literal|2
operator|*
name|i
operator|+
literal|2
index|]
argument_list|,
name|a
index|[
name|i
index|]
argument_list|)
operator|>
literal|0
condition|)
block|{
name|SWAP
argument_list|(
name|a
index|[
name|i
index|]
argument_list|,
name|a
index|[
literal|2
operator|*
name|i
operator|+
literal|2
index|]
argument_list|)
expr_stmt|;
name|i
operator|=
literal|2
operator|*
name|i
operator|+
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fde_compare
argument_list|(
name|a
index|[
literal|2
operator|*
name|i
operator|+
literal|1
index|]
argument_list|,
name|a
index|[
name|i
index|]
argument_list|)
operator|>
literal|0
condition|)
block|{
name|SWAP
argument_list|(
name|a
index|[
name|i
index|]
argument_list|,
name|a
index|[
literal|2
operator|*
name|i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
name|i
operator|=
literal|2
operator|*
name|i
operator|+
literal|1
expr_stmt|;
block|}
else|else
break|break;
block|}
block|}
undef|#
directive|undef
name|SWAP
block|}
end_function

begin_comment
comment|/* Merge V1 and V2, both sorted, and put the result into V1. */
end_comment

begin_function
specifier|static
name|void
name|fde_merge
parameter_list|(
name|fde_vector
modifier|*
name|v1
parameter_list|,
specifier|const
name|fde_vector
modifier|*
name|v2
parameter_list|)
block|{
name|size_t
name|i1
decl_stmt|,
name|i2
decl_stmt|;
name|fde
modifier|*
name|fde2
decl_stmt|;
name|i2
operator|=
name|v2
operator|->
name|count
expr_stmt|;
if|if
condition|(
name|i2
operator|>
literal|0
condition|)
block|{
name|i1
operator|=
name|v1
operator|->
name|count
expr_stmt|;
do|do
block|{
name|i2
operator|--
expr_stmt|;
name|fde2
operator|=
name|v2
operator|->
name|array
index|[
name|i2
index|]
expr_stmt|;
while|while
condition|(
name|i1
operator|>
literal|0
operator|&&
name|fde_compare
argument_list|(
name|v1
operator|->
name|array
index|[
name|i1
operator|-
literal|1
index|]
argument_list|,
name|fde2
argument_list|)
operator|>
literal|0
condition|)
block|{
name|v1
operator|->
name|array
index|[
name|i1
operator|+
name|i2
index|]
operator|=
name|v1
operator|->
name|array
index|[
name|i1
operator|-
literal|1
index|]
expr_stmt|;
name|i1
operator|--
expr_stmt|;
block|}
name|v1
operator|->
name|array
index|[
name|i1
operator|+
name|i2
index|]
operator|=
name|fde2
expr_stmt|;
block|}
do|while
condition|(
name|i2
operator|>
literal|0
condition|)
do|;
name|v1
operator|->
name|count
operator|+=
name|v2
operator|->
name|count
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|fde
modifier|*
modifier|*
name|end_fde_sort
parameter_list|(
name|fde_accumulator
modifier|*
name|accu
parameter_list|,
name|size_t
name|count
parameter_list|)
block|{
if|if
condition|(
name|accu
operator|->
name|linear
operator|.
name|count
operator|!=
name|count
condition|)
name|abort
argument_list|()
expr_stmt|;
name|fde_split
argument_list|(
operator|&
name|accu
operator|->
name|linear
argument_list|,
operator|&
name|accu
operator|->
name|erratic
argument_list|)
expr_stmt|;
if|if
condition|(
name|accu
operator|->
name|linear
operator|.
name|count
operator|+
name|accu
operator|->
name|erratic
operator|.
name|count
operator|!=
name|count
condition|)
name|abort
argument_list|()
expr_stmt|;
name|frame_heapsort
argument_list|(
operator|&
name|accu
operator|->
name|erratic
argument_list|)
expr_stmt|;
name|fde_merge
argument_list|(
operator|&
name|accu
operator|->
name|linear
argument_list|,
operator|&
name|accu
operator|->
name|erratic
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|accu
operator|->
name|erratic
operator|.
name|array
argument_list|)
expr_stmt|;
return|return
name|accu
operator|->
name|linear
operator|.
name|array
return|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|count_fdes
parameter_list|(
name|fde
modifier|*
name|this_fde
parameter_list|)
block|{
name|size_t
name|count
decl_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|this_fde
operator|->
name|length
operator|!=
literal|0
condition|;
name|this_fde
operator|=
name|next_fde
argument_list|(
name|this_fde
argument_list|)
control|)
block|{
comment|/* Skip CIEs and linked once FDE entries.  */
if|if
condition|(
name|this_fde
operator|->
name|CIE_delta
operator|==
literal|0
operator|||
name|this_fde
operator|->
name|pc_begin
operator|==
literal|0
condition|)
continue|continue;
operator|++
name|count
expr_stmt|;
block|}
return|return
name|count
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|add_fdes
parameter_list|(
name|fde
modifier|*
name|this_fde
parameter_list|,
name|fde_accumulator
modifier|*
name|accu
parameter_list|,
name|void
modifier|*
modifier|*
name|beg_ptr
parameter_list|,
name|void
modifier|*
modifier|*
name|end_ptr
parameter_list|)
block|{
name|void
modifier|*
name|pc_begin
init|=
operator|*
name|beg_ptr
decl_stmt|;
name|void
modifier|*
name|pc_end
init|=
operator|*
name|end_ptr
decl_stmt|;
for|for
control|(
init|;
name|this_fde
operator|->
name|length
operator|!=
literal|0
condition|;
name|this_fde
operator|=
name|next_fde
argument_list|(
name|this_fde
argument_list|)
control|)
block|{
comment|/* Skip CIEs and linked once FDE entries.  */
if|if
condition|(
name|this_fde
operator|->
name|CIE_delta
operator|==
literal|0
operator|||
name|this_fde
operator|->
name|pc_begin
operator|==
literal|0
condition|)
continue|continue;
name|fde_insert
argument_list|(
name|accu
argument_list|,
name|this_fde
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_fde
operator|->
name|pc_begin
operator|<
name|pc_begin
condition|)
name|pc_begin
operator|=
name|this_fde
operator|->
name|pc_begin
expr_stmt|;
if|if
condition|(
name|this_fde
operator|->
name|pc_begin
operator|+
name|this_fde
operator|->
name|pc_range
operator|>
name|pc_end
condition|)
name|pc_end
operator|=
name|this_fde
operator|->
name|pc_begin
operator|+
name|this_fde
operator|->
name|pc_range
expr_stmt|;
block|}
operator|*
name|beg_ptr
operator|=
name|pc_begin
expr_stmt|;
operator|*
name|end_ptr
operator|=
name|pc_end
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set up a sorted array of pointers to FDEs for a loaded object.  We    count up the entries before allocating the array because it's likely to    be faster.  */
end_comment

begin_function
specifier|static
name|void
name|frame_init
parameter_list|(
name|struct
name|object
modifier|*
name|ob
parameter_list|)
block|{
name|size_t
name|count
decl_stmt|;
name|fde_accumulator
name|accu
decl_stmt|;
name|void
modifier|*
name|pc_begin
decl_stmt|,
modifier|*
name|pc_end
decl_stmt|;
if|if
condition|(
name|ob
operator|->
name|fde_array
condition|)
block|{
name|fde
modifier|*
modifier|*
name|p
init|=
name|ob
operator|->
name|fde_array
decl_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
operator|*
name|p
condition|;
operator|++
name|p
control|)
name|count
operator|+=
name|count_fdes
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
block|}
else|else
name|count
operator|=
name|count_fdes
argument_list|(
name|ob
operator|->
name|fde_begin
argument_list|)
expr_stmt|;
name|ob
operator|->
name|count
operator|=
name|count
expr_stmt|;
name|start_fde_sort
argument_list|(
operator|&
name|accu
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|pc_begin
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|uaddr
operator|)
operator|-
literal|1
expr_stmt|;
name|pc_end
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ob
operator|->
name|fde_array
condition|)
block|{
name|fde
modifier|*
modifier|*
name|p
init|=
name|ob
operator|->
name|fde_array
decl_stmt|;
for|for
control|(
init|;
operator|*
name|p
condition|;
operator|++
name|p
control|)
name|add_fdes
argument_list|(
operator|*
name|p
argument_list|,
operator|&
name|accu
argument_list|,
operator|&
name|pc_begin
argument_list|,
operator|&
name|pc_end
argument_list|)
expr_stmt|;
block|}
else|else
name|add_fdes
argument_list|(
name|ob
operator|->
name|fde_begin
argument_list|,
operator|&
name|accu
argument_list|,
operator|&
name|pc_begin
argument_list|,
operator|&
name|pc_end
argument_list|)
expr_stmt|;
name|ob
operator|->
name|fde_array
operator|=
name|end_fde_sort
argument_list|(
operator|&
name|accu
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|ob
operator|->
name|pc_begin
operator|=
name|pc_begin
expr_stmt|;
name|ob
operator|->
name|pc_end
operator|=
name|pc_end
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return a pointer to the FDE for the function containing PC.  */
end_comment

begin_function
specifier|static
name|fde
modifier|*
name|find_fde
parameter_list|(
name|void
modifier|*
name|pc
parameter_list|)
block|{
name|struct
name|object
modifier|*
name|ob
decl_stmt|;
name|size_t
name|lo
decl_stmt|,
name|hi
decl_stmt|;
name|init_object_mutex_once
argument_list|()
expr_stmt|;
name|__gthread_mutex_lock
argument_list|(
operator|&
name|object_mutex
argument_list|)
expr_stmt|;
for|for
control|(
name|ob
operator|=
name|objects
init|;
name|ob
condition|;
name|ob
operator|=
name|ob
operator|->
name|next
control|)
block|{
if|if
condition|(
name|ob
operator|->
name|pc_begin
operator|==
literal|0
condition|)
name|frame_init
argument_list|(
name|ob
argument_list|)
expr_stmt|;
if|if
condition|(
name|pc
operator|>=
name|ob
operator|->
name|pc_begin
operator|&&
name|pc
operator|<
name|ob
operator|->
name|pc_end
condition|)
break|break;
block|}
name|__gthread_mutex_unlock
argument_list|(
operator|&
name|object_mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|ob
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Standard binary search algorithm.  */
for|for
control|(
name|lo
operator|=
literal|0
operator|,
name|hi
operator|=
name|ob
operator|->
name|count
init|;
name|lo
operator|<
name|hi
condition|;
control|)
block|{
name|size_t
name|i
init|=
operator|(
name|lo
operator|+
name|hi
operator|)
operator|/
literal|2
decl_stmt|;
name|fde
modifier|*
name|f
init|=
name|ob
operator|->
name|fde_array
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|pc
operator|<
name|f
operator|->
name|pc_begin
condition|)
name|hi
operator|=
name|i
expr_stmt|;
elseif|else
if|if
condition|(
name|pc
operator|>=
name|f
operator|->
name|pc_begin
operator|+
name|f
operator|->
name|pc_range
condition|)
name|lo
operator|=
name|i
operator|+
literal|1
expr_stmt|;
else|else
return|return
name|f
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
specifier|inline
name|struct
name|dwarf_cie
modifier|*
name|get_cie
parameter_list|(
name|fde
modifier|*
name|f
parameter_list|)
block|{
return|return
operator|(
operator|(
name|void
operator|*
operator|)
operator|&
name|f
operator|->
name|CIE_delta
operator|)
operator|-
name|f
operator|->
name|CIE_delta
return|;
block|}
end_function

begin_comment
comment|/* Extract any interesting information from the CIE for the translation    unit F belongs to.  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|extract_cie_info
parameter_list|(
name|fde
modifier|*
name|f
parameter_list|,
name|struct
name|cie_info
modifier|*
name|c
parameter_list|)
block|{
name|void
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
name|c
operator|->
name|augmentation
operator|=
name|get_cie
argument_list|(
name|f
argument_list|)
operator|->
name|augmentation
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|c
operator|->
name|augmentation
argument_list|,
literal|""
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|c
operator|->
name|augmentation
argument_list|,
literal|"eh"
argument_list|)
operator|!=
literal|0
operator|&&
name|c
operator|->
name|augmentation
index|[
literal|0
index|]
operator|!=
literal|'z'
condition|)
return|return
literal|0
return|;
name|p
operator|=
name|c
operator|->
name|augmentation
operator|+
name|strlen
argument_list|(
name|c
operator|->
name|augmentation
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|c
operator|->
name|augmentation
argument_list|,
literal|"eh"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|c
operator|->
name|eh_ptr
operator|=
name|read_pointer
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
expr_stmt|;
block|}
else|else
name|c
operator|->
name|eh_ptr
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|decode_uleb128
argument_list|(
name|p
argument_list|,
operator|&
name|c
operator|->
name|code_align
argument_list|)
expr_stmt|;
name|p
operator|=
name|decode_sleb128
argument_list|(
name|p
argument_list|,
operator|&
name|c
operator|->
name|data_align
argument_list|)
expr_stmt|;
name|c
operator|->
name|ra_regno
operator|=
operator|*
operator|(
name|unsigned
name|char
operator|*
operator|)
name|p
operator|++
expr_stmt|;
comment|/* If the augmentation starts with 'z', we now see the length of the      augmentation fields.  */
if|if
condition|(
name|c
operator|->
name|augmentation
index|[
literal|0
index|]
operator|==
literal|'z'
condition|)
block|{
name|p
operator|=
name|decode_uleb128
argument_list|(
name|p
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
name|p
operator|+=
name|i
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* Decode one instruction's worth of DWARF 2 call frame information.    Used by __frame_state_for.  Takes pointers P to the instruction to    decode, STATE to the current register unwind information, INFO to the    current CIE information, and PC to the current PC value.  Returns a    pointer to the next instruction.  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|execute_cfa_insn
parameter_list|(
name|void
modifier|*
name|p
parameter_list|,
name|struct
name|frame_state_internal
modifier|*
name|state
parameter_list|,
name|struct
name|cie_info
modifier|*
name|info
parameter_list|,
name|void
modifier|*
modifier|*
name|pc
parameter_list|)
block|{
name|unsigned
name|insn
init|=
operator|*
operator|(
name|unsigned
name|char
operator|*
operator|)
name|p
operator|++
decl_stmt|;
name|unsigned
name|reg
decl_stmt|;
name|int
name|offset
decl_stmt|;
if|if
condition|(
name|insn
operator|&
name|DW_CFA_advance_loc
condition|)
operator|*
name|pc
operator|+=
operator|(
operator|(
name|insn
operator|&
literal|0x3f
operator|)
operator|*
name|info
operator|->
name|code_align
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|insn
operator|&
name|DW_CFA_offset
condition|)
block|{
name|reg
operator|=
operator|(
name|insn
operator|&
literal|0x3f
operator|)
expr_stmt|;
name|p
operator|=
name|decode_uleb128
argument_list|(
name|p
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|*=
name|info
operator|->
name|data_align
expr_stmt|;
name|state
operator|->
name|s
operator|.
name|saved
index|[
name|reg
index|]
operator|=
name|REG_SAVED_OFFSET
expr_stmt|;
name|state
operator|->
name|s
operator|.
name|reg_or_offset
index|[
name|reg
index|]
operator|=
name|offset
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|insn
operator|&
name|DW_CFA_restore
condition|)
block|{
name|reg
operator|=
operator|(
name|insn
operator|&
literal|0x3f
operator|)
expr_stmt|;
name|state
operator|->
name|s
operator|.
name|saved
index|[
name|reg
index|]
operator|=
name|REG_UNSAVED
expr_stmt|;
block|}
else|else
switch|switch
condition|(
name|insn
condition|)
block|{
case|case
name|DW_CFA_set_loc
case|:
operator|*
name|pc
operator|=
name|read_pointer
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_CFA_advance_loc1
case|:
operator|*
name|pc
operator|+=
name|read_1byte
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
name|DW_CFA_advance_loc2
case|:
operator|*
name|pc
operator|+=
name|read_2byte
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|DW_CFA_advance_loc4
case|:
operator|*
name|pc
operator|+=
name|read_4byte
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
break|break;
case|case
name|DW_CFA_offset_extended
case|:
name|p
operator|=
name|decode_uleb128
argument_list|(
name|p
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
name|p
operator|=
name|decode_uleb128
argument_list|(
name|p
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|*=
name|info
operator|->
name|data_align
expr_stmt|;
name|state
operator|->
name|s
operator|.
name|saved
index|[
name|reg
index|]
operator|=
name|REG_SAVED_OFFSET
expr_stmt|;
name|state
operator|->
name|s
operator|.
name|reg_or_offset
index|[
name|reg
index|]
operator|=
name|offset
expr_stmt|;
break|break;
case|case
name|DW_CFA_restore_extended
case|:
name|p
operator|=
name|decode_uleb128
argument_list|(
name|p
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
name|state
operator|->
name|s
operator|.
name|saved
index|[
name|reg
index|]
operator|=
name|REG_UNSAVED
expr_stmt|;
break|break;
case|case
name|DW_CFA_undefined
case|:
case|case
name|DW_CFA_same_value
case|:
case|case
name|DW_CFA_nop
case|:
break|break;
case|case
name|DW_CFA_register
case|:
block|{
name|unsigned
name|reg2
decl_stmt|;
name|p
operator|=
name|decode_uleb128
argument_list|(
name|p
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
name|p
operator|=
name|decode_uleb128
argument_list|(
name|p
argument_list|,
operator|&
name|reg2
argument_list|)
expr_stmt|;
name|state
operator|->
name|s
operator|.
name|saved
index|[
name|reg
index|]
operator|=
name|REG_SAVED_REG
expr_stmt|;
name|state
operator|->
name|s
operator|.
name|reg_or_offset
index|[
name|reg
index|]
operator|=
name|reg2
expr_stmt|;
block|}
break|break;
case|case
name|DW_CFA_def_cfa
case|:
name|p
operator|=
name|decode_uleb128
argument_list|(
name|p
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
name|p
operator|=
name|decode_uleb128
argument_list|(
name|p
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
name|state
operator|->
name|s
operator|.
name|cfa_reg
operator|=
name|reg
expr_stmt|;
name|state
operator|->
name|s
operator|.
name|cfa_offset
operator|=
name|offset
expr_stmt|;
break|break;
case|case
name|DW_CFA_def_cfa_register
case|:
name|p
operator|=
name|decode_uleb128
argument_list|(
name|p
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
name|state
operator|->
name|s
operator|.
name|cfa_reg
operator|=
name|reg
expr_stmt|;
break|break;
case|case
name|DW_CFA_def_cfa_offset
case|:
name|p
operator|=
name|decode_uleb128
argument_list|(
name|p
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
name|state
operator|->
name|s
operator|.
name|cfa_offset
operator|=
name|offset
expr_stmt|;
break|break;
case|case
name|DW_CFA_remember_state
case|:
block|{
name|struct
name|frame_state_internal
modifier|*
name|save
init|=
operator|(
expr|struct
name|frame_state_internal
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|frame_state_internal
argument_list|)
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|save
argument_list|,
name|state
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|frame_state_internal
argument_list|)
argument_list|)
expr_stmt|;
name|state
operator|->
name|saved_state
operator|=
name|save
expr_stmt|;
block|}
break|break;
case|case
name|DW_CFA_restore_state
case|:
block|{
name|struct
name|frame_state_internal
modifier|*
name|save
init|=
name|state
operator|->
name|saved_state
decl_stmt|;
name|memcpy
argument_list|(
name|state
argument_list|,
name|save
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|frame_state_internal
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|save
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* FIXME: Hardcoded for SPARC register window configuration.  */
case|case
name|DW_CFA_GNU_window_save
case|:
for|for
control|(
name|reg
operator|=
literal|16
init|;
name|reg
operator|<
literal|32
condition|;
operator|++
name|reg
control|)
block|{
name|state
operator|->
name|s
operator|.
name|saved
index|[
name|reg
index|]
operator|=
name|REG_SAVED_OFFSET
expr_stmt|;
name|state
operator|->
name|s
operator|.
name|reg_or_offset
index|[
name|reg
index|]
operator|=
operator|(
name|reg
operator|-
literal|16
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DW_CFA_GNU_args_size
case|:
name|p
operator|=
name|decode_uleb128
argument_list|(
name|p
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
name|state
operator|->
name|s
operator|.
name|args_size
operator|=
name|offset
expr_stmt|;
break|break;
case|case
name|DW_CFA_GNU_negative_offset_extended
case|:
name|p
operator|=
name|decode_uleb128
argument_list|(
name|p
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
name|p
operator|=
name|decode_uleb128
argument_list|(
name|p
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|*=
name|info
operator|->
name|data_align
expr_stmt|;
name|state
operator|->
name|s
operator|.
name|saved
index|[
name|reg
index|]
operator|=
name|REG_SAVED_OFFSET
expr_stmt|;
name|state
operator|->
name|s
operator|.
name|reg_or_offset
index|[
name|reg
index|]
operator|=
operator|-
name|offset
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Called from crtbegin.o to register the unwind info for an object.  */
end_comment

begin_function
name|void
name|__register_frame_info
parameter_list|(
name|void
modifier|*
name|begin
parameter_list|,
name|struct
name|object
modifier|*
name|ob
parameter_list|)
block|{
name|ob
operator|->
name|fde_begin
operator|=
name|begin
expr_stmt|;
name|ob
operator|->
name|pc_begin
operator|=
name|ob
operator|->
name|pc_end
operator|=
literal|0
expr_stmt|;
name|ob
operator|->
name|fde_array
operator|=
literal|0
expr_stmt|;
name|ob
operator|->
name|count
operator|=
literal|0
expr_stmt|;
name|init_object_mutex_once
argument_list|()
expr_stmt|;
name|__gthread_mutex_lock
argument_list|(
operator|&
name|object_mutex
argument_list|)
expr_stmt|;
name|ob
operator|->
name|next
operator|=
name|objects
expr_stmt|;
name|objects
operator|=
name|ob
expr_stmt|;
name|__gthread_mutex_unlock
argument_list|(
operator|&
name|object_mutex
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|__register_frame
parameter_list|(
name|void
modifier|*
name|begin
parameter_list|)
block|{
name|struct
name|object
modifier|*
name|ob
init|=
operator|(
expr|struct
name|object
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|object
argument_list|)
argument_list|)
decl_stmt|;
name|__register_frame_info
argument_list|(
name|begin
argument_list|,
name|ob
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Similar, but BEGIN is actually a pointer to a table of unwind entries    for different translation units.  Called from the file generated by    collect2.  */
end_comment

begin_function
name|void
name|__register_frame_info_table
parameter_list|(
name|void
modifier|*
name|begin
parameter_list|,
name|struct
name|object
modifier|*
name|ob
parameter_list|)
block|{
name|ob
operator|->
name|fde_begin
operator|=
name|begin
expr_stmt|;
name|ob
operator|->
name|fde_array
operator|=
name|begin
expr_stmt|;
name|ob
operator|->
name|pc_begin
operator|=
name|ob
operator|->
name|pc_end
operator|=
literal|0
expr_stmt|;
name|ob
operator|->
name|count
operator|=
literal|0
expr_stmt|;
name|init_object_mutex_once
argument_list|()
expr_stmt|;
name|__gthread_mutex_lock
argument_list|(
operator|&
name|object_mutex
argument_list|)
expr_stmt|;
name|ob
operator|->
name|next
operator|=
name|objects
expr_stmt|;
name|objects
operator|=
name|ob
expr_stmt|;
name|__gthread_mutex_unlock
argument_list|(
operator|&
name|object_mutex
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|__register_frame_table
parameter_list|(
name|void
modifier|*
name|begin
parameter_list|)
block|{
name|struct
name|object
modifier|*
name|ob
init|=
operator|(
expr|struct
name|object
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|object
argument_list|)
argument_list|)
decl_stmt|;
name|__register_frame_info_table
argument_list|(
name|begin
argument_list|,
name|ob
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called from crtbegin.o to deregister the unwind info for an object.  */
end_comment

begin_function
name|void
modifier|*
name|__deregister_frame_info
parameter_list|(
name|void
modifier|*
name|begin
parameter_list|)
block|{
name|struct
name|object
modifier|*
modifier|*
name|p
decl_stmt|;
name|init_object_mutex_once
argument_list|()
expr_stmt|;
name|__gthread_mutex_lock
argument_list|(
operator|&
name|object_mutex
argument_list|)
expr_stmt|;
name|p
operator|=
operator|&
name|objects
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|p
operator|)
operator|->
name|fde_begin
operator|==
name|begin
condition|)
block|{
name|struct
name|object
modifier|*
name|ob
init|=
operator|*
name|p
decl_stmt|;
operator|*
name|p
operator|=
operator|(
operator|*
name|p
operator|)
operator|->
name|next
expr_stmt|;
comment|/* If we've run init_frame for this object, free the FDE array.  */
if|if
condition|(
name|ob
operator|->
name|pc_begin
condition|)
name|free
argument_list|(
name|ob
operator|->
name|fde_array
argument_list|)
expr_stmt|;
name|__gthread_mutex_unlock
argument_list|(
operator|&
name|object_mutex
argument_list|)
expr_stmt|;
return|return
operator|(
name|void
operator|*
operator|)
name|ob
return|;
block|}
name|p
operator|=
operator|&
operator|(
operator|(
operator|*
name|p
operator|)
operator|->
name|next
operator|)
expr_stmt|;
block|}
name|__gthread_mutex_unlock
argument_list|(
operator|&
name|object_mutex
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|__deregister_frame
parameter_list|(
name|void
modifier|*
name|begin
parameter_list|)
block|{
name|free
argument_list|(
name|__deregister_frame_info
argument_list|(
name|begin
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called from __throw to find the registers to restore for a given    PC_TARGET.  The caller should allocate a local variable of `struct    frame_state' (declared in frame.h) and pass its address to STATE_IN.  */
end_comment

begin_function
name|struct
name|frame_state
modifier|*
name|__frame_state_for
parameter_list|(
name|void
modifier|*
name|pc_target
parameter_list|,
name|struct
name|frame_state
modifier|*
name|state_in
parameter_list|)
block|{
name|fde
modifier|*
name|f
decl_stmt|;
name|void
modifier|*
name|insn
decl_stmt|,
modifier|*
name|end
decl_stmt|,
modifier|*
name|pc
decl_stmt|;
name|struct
name|cie_info
name|info
decl_stmt|;
name|struct
name|frame_state_internal
name|state
decl_stmt|;
name|f
operator|=
name|find_fde
argument_list|(
name|pc_target
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|insn
operator|=
name|extract_cie_info
argument_list|(
name|f
argument_list|,
operator|&
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|memset
argument_list|(
operator|&
name|state
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|state
argument_list|)
argument_list|)
expr_stmt|;
name|state
operator|.
name|s
operator|.
name|retaddr_column
operator|=
name|info
operator|.
name|ra_regno
expr_stmt|;
name|state
operator|.
name|s
operator|.
name|eh_ptr
operator|=
name|info
operator|.
name|eh_ptr
expr_stmt|;
comment|/* First decode all the insns in the CIE.  */
name|end
operator|=
name|next_fde
argument_list|(
operator|(
name|fde
operator|*
operator|)
name|get_cie
argument_list|(
name|f
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|insn
operator|<
name|end
condition|)
name|insn
operator|=
name|execute_cfa_insn
argument_list|(
name|insn
argument_list|,
operator|&
name|state
argument_list|,
operator|&
name|info
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|insn
operator|=
operator|(
operator|(
name|fde
operator|*
operator|)
name|f
operator|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|info
operator|.
name|augmentation
index|[
literal|0
index|]
operator|==
literal|'z'
condition|)
block|{
name|int
name|i
decl_stmt|;
name|insn
operator|=
name|decode_uleb128
argument_list|(
name|insn
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
name|insn
operator|+=
name|i
expr_stmt|;
block|}
comment|/* Then the insns in the FDE up to our target PC.  */
name|end
operator|=
name|next_fde
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|pc
operator|=
name|f
operator|->
name|pc_begin
expr_stmt|;
while|while
condition|(
name|insn
operator|<
name|end
operator|&&
name|pc
operator|<=
name|pc_target
condition|)
name|insn
operator|=
name|execute_cfa_insn
argument_list|(
name|insn
argument_list|,
operator|&
name|state
argument_list|,
operator|&
name|info
argument_list|,
operator|&
name|pc
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|state_in
argument_list|,
operator|&
name|state
operator|.
name|s
argument_list|,
sizeof|sizeof
argument_list|(
name|state
operator|.
name|s
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|state_in
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DWARF2_UNWIND_INFO */
end_comment

end_unit

