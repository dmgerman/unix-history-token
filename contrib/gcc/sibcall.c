begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Generic sibling call optimization support    Copyright (C) 1999, 2000, 2001, 2002 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_comment
comment|/* In case alternate_exit_block contains copy from pseudo, to return value,    record the pseudo here.  In such case the pseudo must be set to function    return in the sibcall sequence.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|return_value_pseudo
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|identify_call_return_value
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|*
operator|,
name|rtx
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|skip_copy_to_return_value
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|skip_use_of_return_value
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
expr|enum
name|rtx_code
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|skip_stack_adjustment
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|skip_pic_restore
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|skip_jump_insn
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|call_ends_block_p
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|uses_addressof
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sequence_uses_addressof
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|purge_reg_equiv_notes
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|purge_mem_unchanging_flag
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|skip_unreturned_value
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Examine a CALL_PLACEHOLDER pattern and determine where the call's    return value is located.  P_HARD_RETURN receives the hard register    that the function used; P_SOFT_RETURN receives the pseudo register    that the sequence used.  Return non-zero if the values were located.  */
end_comment

begin_function
specifier|static
name|int
name|identify_call_return_value
parameter_list|(
name|cp
parameter_list|,
name|p_hard_return
parameter_list|,
name|p_soft_return
parameter_list|)
name|rtx
name|cp
decl_stmt|;
name|rtx
modifier|*
name|p_hard_return
decl_stmt|,
decl|*
name|p_soft_return
decl_stmt|;
end_function

begin_block
block|{
name|rtx
name|insn
decl_stmt|,
name|set
decl_stmt|,
name|hard
decl_stmt|,
name|soft
decl_stmt|;
name|insn
operator|=
name|XEXP
argument_list|(
name|cp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Search backward through the "normal" call sequence to the CALL insn.  */
while|while
condition|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
condition|)
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|CALL_INSN
condition|)
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Assume the pattern is (set (dest) (call ...)), or that the first      member of a parallel is.  This is the hard return register used      by the function.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|CALL
condition|)
name|hard
operator|=
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|CALL
condition|)
name|hard
operator|=
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
return|return
literal|0
return|;
comment|/* If we didn't get a single hard register (e.g. a parallel), give up.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|hard
argument_list|)
operator|!=
name|REG
condition|)
return|return
literal|0
return|;
comment|/* Stack adjustment done after call may appear here.  */
name|insn
operator|=
name|skip_stack_adjustment
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|insn
condition|)
return|return
literal|0
return|;
comment|/* Restore of GP register may appear here.  */
name|insn
operator|=
name|skip_pic_restore
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|insn
condition|)
return|return
literal|0
return|;
comment|/* If there's nothing after, there's no soft return value.  */
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|insn
condition|)
return|return
literal|0
return|;
comment|/* We're looking for a source of the hard return register.  */
name|set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|set
operator|||
name|SET_SRC
argument_list|(
name|set
argument_list|)
operator|!=
name|hard
condition|)
return|return
literal|0
return|;
name|soft
operator|=
name|SET_DEST
argument_list|(
name|set
argument_list|)
expr_stmt|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Allow this first destination to be copied to a second register,      as might happen if the first register wasn't the particular pseudo      we'd been expecting.  */
if|if
condition|(
name|insn
operator|&&
operator|(
name|set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
operator|)
operator|!=
name|NULL_RTX
operator|&&
name|SET_SRC
argument_list|(
name|set
argument_list|)
operator|==
name|soft
condition|)
block|{
name|soft
operator|=
name|SET_DEST
argument_list|(
name|set
argument_list|)
expr_stmt|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
comment|/* Don't fool with anything but pseudo registers.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|soft
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO
argument_list|(
name|soft
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
return|return
literal|0
return|;
comment|/* This value must not be modified before the end of the sequence.  */
if|if
condition|(
name|reg_set_between_p
argument_list|(
name|soft
argument_list|,
name|insn
argument_list|,
name|NULL_RTX
argument_list|)
condition|)
return|return
literal|0
return|;
operator|*
name|p_hard_return
operator|=
name|hard
expr_stmt|;
operator|*
name|p_soft_return
operator|=
name|soft
expr_stmt|;
return|return
literal|1
return|;
block|}
end_block

begin_comment
comment|/* If the first real insn after ORIG_INSN copies to this function's    return value from RETVAL, then return the insn which performs the    copy.  Otherwise return ORIG_INSN.  */
end_comment

begin_function
specifier|static
name|rtx
name|skip_copy_to_return_value
parameter_list|(
name|orig_insn
parameter_list|)
name|rtx
name|orig_insn
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|,
name|set
init|=
name|NULL_RTX
decl_stmt|;
name|rtx
name|hardret
decl_stmt|,
name|softret
decl_stmt|;
comment|/* If there is no return value, we have nothing to do.  */
if|if
condition|(
operator|!
name|identify_call_return_value
argument_list|(
name|PATTERN
argument_list|(
name|orig_insn
argument_list|)
argument_list|,
operator|&
name|hardret
argument_list|,
operator|&
name|softret
argument_list|)
condition|)
return|return
name|orig_insn
return|;
name|insn
operator|=
name|next_nonnote_insn
argument_list|(
name|orig_insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|insn
condition|)
return|return
name|orig_insn
return|;
name|set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|set
condition|)
return|return
name|orig_insn
return|;
if|if
condition|(
name|return_value_pseudo
condition|)
block|{
if|if
condition|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
operator|==
name|return_value_pseudo
operator|&&
name|SET_SRC
argument_list|(
name|set
argument_list|)
operator|==
name|softret
condition|)
return|return
name|insn
return|;
return|return
name|orig_insn
return|;
block|}
comment|/* The destination must be the same as the called function's return      value to ensure that any return value is put in the same place by the      current function and the function we're calling.        Further, the source must be the same as the pseudo into which the      called function's return value was copied.  Otherwise we're returning      some other value.  */
ifndef|#
directive|ifndef
name|OUTGOING_REGNO
define|#
directive|define
name|OUTGOING_REGNO
parameter_list|(
name|N
parameter_list|)
value|(N)
endif|#
directive|endif
if|if
condition|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
operator|==
name|current_function_return_rtx
operator|&&
name|REG_P
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|&&
name|OUTGOING_REGNO
argument_list|(
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REGNO
argument_list|(
name|hardret
argument_list|)
operator|&&
name|SET_SRC
argument_list|(
name|set
argument_list|)
operator|==
name|softret
condition|)
return|return
name|insn
return|;
comment|/* Recognize the situation when the called function's return value      is copied in two steps: first into an intermediate pseudo, then      the into the calling functions return value register.  */
if|if
condition|(
name|REG_P
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|&&
name|SET_SRC
argument_list|(
name|set
argument_list|)
operator|==
name|softret
condition|)
block|{
name|rtx
name|x
init|=
name|SET_DEST
argument_list|(
name|set
argument_list|)
decl_stmt|;
name|insn
operator|=
name|next_nonnote_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|insn
condition|)
return|return
name|orig_insn
return|;
name|set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|set
condition|)
return|return
name|orig_insn
return|;
if|if
condition|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
operator|==
name|current_function_return_rtx
operator|&&
name|REG_P
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|&&
name|OUTGOING_REGNO
argument_list|(
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REGNO
argument_list|(
name|hardret
argument_list|)
operator|&&
name|SET_SRC
argument_list|(
name|set
argument_list|)
operator|==
name|x
condition|)
return|return
name|insn
return|;
block|}
comment|/* It did not look like a copy of the return value, so return the      same insn we were passed.  */
return|return
name|orig_insn
return|;
block|}
end_function

begin_comment
comment|/* If the first real insn after ORIG_INSN is a CODE of this function's return    value, return insn.  Otherwise return ORIG_INSN.  */
end_comment

begin_function
specifier|static
name|rtx
name|skip_use_of_return_value
parameter_list|(
name|orig_insn
parameter_list|,
name|code
parameter_list|)
name|rtx
name|orig_insn
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|;
name|insn
operator|=
name|next_nonnote_insn
argument_list|(
name|orig_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|code
operator|&&
operator|(
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|current_function_return_rtx
operator|||
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|const0_rtx
operator|)
condition|)
return|return
name|insn
return|;
return|return
name|orig_insn
return|;
block|}
end_function

begin_comment
comment|/* In case function does not return value,  we get clobber of pseudo followed    by set to hard return value.  */
end_comment

begin_function
specifier|static
name|rtx
name|skip_unreturned_value
parameter_list|(
name|orig_insn
parameter_list|)
name|rtx
name|orig_insn
decl_stmt|;
block|{
name|rtx
name|insn
init|=
name|next_nonnote_insn
argument_list|(
name|orig_insn
argument_list|)
decl_stmt|;
comment|/* Skip possible clobber of pseudo return register.  */
if|if
condition|(
name|insn
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|CLOBBER
operator|&&
name|REG_P
argument_list|(
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
operator|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
condition|)
block|{
name|rtx
name|set_insn
init|=
name|next_nonnote_insn
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|set
decl_stmt|;
if|if
condition|(
operator|!
name|set_insn
condition|)
return|return
name|insn
return|;
name|set
operator|=
name|single_set
argument_list|(
name|set_insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|set
operator|||
name|SET_SRC
argument_list|(
name|set
argument_list|)
operator|!=
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|||
name|SET_DEST
argument_list|(
name|set
argument_list|)
operator|!=
name|current_function_return_rtx
condition|)
return|return
name|insn
return|;
return|return
name|set_insn
return|;
block|}
return|return
name|orig_insn
return|;
block|}
end_function

begin_comment
comment|/* If the first real insn after ORIG_INSN adjusts the stack pointer    by a constant, return the insn with the stack pointer adjustment.    Otherwise return ORIG_INSN.  */
end_comment

begin_function
specifier|static
name|rtx
name|skip_stack_adjustment
parameter_list|(
name|orig_insn
parameter_list|)
name|rtx
name|orig_insn
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|,
name|set
init|=
name|NULL_RTX
decl_stmt|;
name|insn
operator|=
name|next_nonnote_insn
argument_list|(
name|orig_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
condition|)
name|set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|&&
name|set
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|stack_pointer_rtx
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|SET_DEST
argument_list|(
name|set
argument_list|)
operator|==
name|stack_pointer_rtx
condition|)
return|return
name|insn
return|;
return|return
name|orig_insn
return|;
block|}
end_function

begin_comment
comment|/* If the first real insn after ORIG_INSN sets the pic register,    return it.  Otherwise return ORIG_INSN.  */
end_comment

begin_function
specifier|static
name|rtx
name|skip_pic_restore
parameter_list|(
name|orig_insn
parameter_list|)
name|rtx
name|orig_insn
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|,
name|set
init|=
name|NULL_RTX
decl_stmt|;
name|insn
operator|=
name|next_nonnote_insn
argument_list|(
name|orig_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
condition|)
name|set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|&&
name|set
operator|&&
name|SET_DEST
argument_list|(
name|set
argument_list|)
operator|==
name|pic_offset_table_rtx
condition|)
return|return
name|insn
return|;
return|return
name|orig_insn
return|;
block|}
end_function

begin_comment
comment|/* If the first real insn after ORIG_INSN is a jump, return the JUMP_INSN.    Otherwise return ORIG_INSN.  */
end_comment

begin_function
specifier|static
name|rtx
name|skip_jump_insn
parameter_list|(
name|orig_insn
parameter_list|)
name|rtx
name|orig_insn
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|;
name|insn
operator|=
name|next_nonnote_insn
argument_list|(
name|orig_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|any_uncondjump_p
argument_list|(
name|insn
argument_list|)
condition|)
return|return
name|insn
return|;
return|return
name|orig_insn
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Using the above functions, see if INSN, skipping any of the above,    goes all the way to END, the end of a basic block.  Return 1 if so.  */
end_comment

begin_function
specifier|static
name|int
name|call_ends_block_p
parameter_list|(
name|insn
parameter_list|,
name|end
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|rtx
name|end
decl_stmt|;
block|{
name|rtx
name|new_insn
decl_stmt|;
comment|/* END might be a note, so get the last nonnote insn of the block.  */
name|end
operator|=
name|next_nonnote_insn
argument_list|(
name|PREV_INSN
argument_list|(
name|end
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the call was the end of the block, then we're OK.  */
if|if
condition|(
name|insn
operator|==
name|end
condition|)
return|return
literal|1
return|;
comment|/* Skip over copying from the call's return value pseudo into      this function's hard return register and if that's the end      of the block, we're OK.  */
name|new_insn
operator|=
name|skip_copy_to_return_value
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* In case we return value in pseudo, we must set the pseudo to      return value of called function, otherwise we are returning      something else.  */
if|if
condition|(
name|return_value_pseudo
operator|&&
name|insn
operator|==
name|new_insn
condition|)
return|return
literal|0
return|;
name|insn
operator|=
name|new_insn
expr_stmt|;
if|if
condition|(
name|insn
operator|==
name|end
condition|)
return|return
literal|1
return|;
comment|/* Skip any stack adjustment.  */
name|insn
operator|=
name|skip_stack_adjustment
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|==
name|end
condition|)
return|return
literal|1
return|;
comment|/* Skip over a CLOBBER of the return value as a hard reg.  */
name|insn
operator|=
name|skip_use_of_return_value
argument_list|(
name|insn
argument_list|,
name|CLOBBER
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|==
name|end
condition|)
return|return
literal|1
return|;
comment|/* Skip over a CLOBBER of the return value as a hard reg.  */
name|insn
operator|=
name|skip_unreturned_value
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|==
name|end
condition|)
return|return
literal|1
return|;
comment|/* Skip over a USE of the return value (as a hard reg).  */
name|insn
operator|=
name|skip_use_of_return_value
argument_list|(
name|insn
argument_list|,
name|USE
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|==
name|end
condition|)
return|return
literal|1
return|;
comment|/* Skip over a JUMP_INSN at the end of the block.  If that doesn't end the      block, the original CALL_INSN didn't.  */
name|insn
operator|=
name|skip_jump_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
return|return
name|insn
operator|==
name|end
return|;
block|}
end_function

begin_comment
comment|/* Scan the rtx X for ADDRESSOF expressions or    current_function_internal_arg_pointer registers.    Return nonzero if an ADDRESSOF or current_function_internal_arg_pointer    is found outside of some MEM expression, else return zero.  */
end_comment

begin_function
specifier|static
name|int
name|uses_addressof
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
name|RTX_CODE
name|code
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|x
operator|==
name|NULL_RTX
condition|)
return|return
literal|0
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|ADDRESSOF
operator|||
name|x
operator|==
name|current_function_internal_arg_pointer
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|code
operator|==
name|MEM
condition|)
return|return
literal|0
return|;
comment|/* Scan all subexpressions.  */
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
condition|;
name|i
operator|++
operator|,
name|fmt
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|fmt
operator|==
literal|'e'
condition|)
block|{
if|if
condition|(
name|uses_addressof
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
operator|*
name|fmt
operator|==
literal|'E'
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|uses_addressof
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Scan the sequence of insns in SEQ to see if any have an ADDRESSOF    rtl expression or current_function_internal_arg_pointer occurrences    not enclosed within a MEM.  If an ADDRESSOF expression or    current_function_internal_arg_pointer is found, return nonzero, otherwise    return zero.     This function handles CALL_PLACEHOLDERs which contain multiple sequences    of insns.  */
end_comment

begin_function
specifier|static
name|int
name|sequence_uses_addressof
parameter_list|(
name|seq
parameter_list|)
name|rtx
name|seq
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|seq
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
comment|/* If this is a CALL_PLACEHOLDER, then recursively call ourselves 	   with each nonempty sequence attached to the CALL_PLACEHOLDER.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|CALL_PLACEHOLDER
condition|)
block|{
if|if
condition|(
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|!=
name|NULL_RTX
operator|&&
name|sequence_uses_addressof
argument_list|(
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|!=
name|NULL_RTX
operator|&&
name|sequence_uses_addressof
argument_list|(
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|2
argument_list|)
operator|!=
name|NULL_RTX
operator|&&
name|sequence_uses_addressof
argument_list|(
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|2
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|uses_addressof
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|||
operator|(
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|&&
name|uses_addressof
argument_list|(
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Remove all REG_EQUIV notes found in the insn chain.  */
end_comment

begin_function
specifier|static
name|void
name|purge_reg_equiv_notes
parameter_list|()
block|{
name|rtx
name|insn
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
while|while
condition|(
literal|1
condition|)
block|{
name|rtx
name|note
init|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_EQUIV
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|note
condition|)
block|{
comment|/* Remove the note and keep looking at the notes for 		 this insn.  */
name|remove_note
argument_list|(
name|insn
argument_list|,
name|note
argument_list|)
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Clear RTX_UNCHANGING_P flag of incoming argument MEMs.  */
end_comment

begin_function
specifier|static
name|void
name|purge_mem_unchanging_flag
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
name|RTX_CODE
name|code
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|x
operator|==
name|NULL_RTX
condition|)
return|return;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|MEM
condition|)
block|{
if|if
condition|(
name|RTX_UNCHANGING_P
argument_list|(
name|x
argument_list|)
operator|&&
operator|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|current_function_internal_arg_pointer
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|current_function_internal_arg_pointer
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|)
operator|)
condition|)
name|RTX_UNCHANGING_P
argument_list|(
name|x
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return;
block|}
comment|/* Scan all subexpressions.  */
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
condition|;
name|i
operator|++
operator|,
name|fmt
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|fmt
operator|==
literal|'e'
condition|)
name|purge_mem_unchanging_flag
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|fmt
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|purge_mem_unchanging_flag
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Replace the CALL_PLACEHOLDER with one of its children.  INSN should be    the CALL_PLACEHOLDER insn; USE tells which child to use.  */
end_comment

begin_function
name|void
name|replace_call_placeholder
parameter_list|(
name|insn
parameter_list|,
name|use
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|sibcall_use_t
name|use
decl_stmt|;
block|{
if|if
condition|(
name|use
operator|==
name|sibcall_use_tail_recursion
condition|)
name|emit_insns_before
argument_list|(
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|2
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|use
operator|==
name|sibcall_use_sibcall
condition|)
name|emit_insns_before
argument_list|(
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|use
operator|==
name|sibcall_use_normal
condition|)
name|emit_insns_before
argument_list|(
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
comment|/* Turn off LABEL_PRESERVE_P for the tail recursion label if it      exists.  We only had to set it long enough to keep the jump      pass above from deleting it as unused.  */
if|if
condition|(
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|3
argument_list|)
condition|)
name|LABEL_PRESERVE_P
argument_list|(
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|3
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* "Delete" the placeholder insn.  */
name|remove_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given a (possibly empty) set of potential sibling or tail recursion call    sites, determine if optimization is possible.     Potential sibling or tail recursion calls are marked with CALL_PLACEHOLDER    insns.  The CALL_PLACEHOLDER insn holds chains of insns to implement a    normal call, sibling call or tail recursive call.     Replace the CALL_PLACEHOLDER with an appropriate insn chain.  */
end_comment

begin_function
name|void
name|optimize_sibling_and_tail_recursive_calls
parameter_list|()
block|{
name|rtx
name|insn
decl_stmt|,
name|insns
decl_stmt|;
name|basic_block
name|alternate_exit
init|=
name|EXIT_BLOCK_PTR
decl_stmt|;
name|bool
name|no_sibcalls_this_function
init|=
name|false
decl_stmt|;
name|int
name|successful_sibling_call
init|=
literal|0
decl_stmt|;
name|int
name|replaced_call_placeholder
init|=
literal|0
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
comment|/* We do not perform these calls when flag_exceptions is true, so this      is probably a NOP at the current time.  However, we may want to support      sibling and tail recursion optimizations in the future, so let's plan      ahead and find all the EH labels.  */
name|find_exception_handler_labels
argument_list|()
expr_stmt|;
name|rebuild_jump_labels
argument_list|(
name|insns
argument_list|)
expr_stmt|;
comment|/* We need cfg information to determine which blocks are succeeded      only by the epilogue.  */
name|find_basic_blocks
argument_list|(
name|insns
argument_list|,
name|max_reg_num
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cleanup_cfg
argument_list|(
name|CLEANUP_PRE_SIBCALL
operator||
name|CLEANUP_PRE_LOOP
argument_list|)
expr_stmt|;
comment|/* If there are no basic blocks, then there is nothing to do.  */
if|if
condition|(
name|n_basic_blocks
operator|==
literal|0
condition|)
return|return;
comment|/* If we are using sjlj exceptions, we may need to add a call to       _Unwind_SjLj_Unregister at exit of the function.  Which means      that we cannot do any sibcall transformations.  */
if|if
condition|(
name|USING_SJLJ_EXCEPTIONS
operator|&&
name|current_function_has_exception_handlers
argument_list|()
condition|)
name|no_sibcalls_this_function
operator|=
name|true
expr_stmt|;
name|return_value_pseudo
operator|=
name|NULL_RTX
expr_stmt|;
comment|/* Find the exit block.       It is possible that we have blocks which can reach the exit block      directly.  However, most of the time a block will jump (or fall into)      N_BASIC_BLOCKS - 1, which in turn falls into the exit block.  */
for|for
control|(
name|e
operator|=
name|EXIT_BLOCK_PTR
operator|->
name|pred
init|;
name|e
operator|&&
name|alternate_exit
operator|==
name|EXIT_BLOCK_PTR
condition|;
name|e
operator|=
name|e
operator|->
name|pred_next
control|)
block|{
name|rtx
name|insn
decl_stmt|;
if|if
condition|(
name|e
operator|->
name|dest
operator|!=
name|EXIT_BLOCK_PTR
operator|||
name|e
operator|->
name|succ_next
operator|!=
name|NULL
condition|)
continue|continue;
comment|/* Walk forwards through the last normal block and see if it 	 does nothing except fall into the exit block.  */
for|for
control|(
name|insn
operator|=
name|BLOCK_HEAD
argument_list|(
name|n_basic_blocks
operator|-
literal|1
argument_list|)
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|rtx
name|set
decl_stmt|;
comment|/* This should only happen once, at the start of this block.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
condition|)
continue|continue;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
continue|continue;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|USE
condition|)
continue|continue;
comment|/* Exit block also may contain copy from pseudo containing 	     return value to hard register.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
operator|(
name|set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
operator|)
operator|&&
name|SET_DEST
argument_list|(
name|set
argument_list|)
operator|==
name|current_function_return_rtx
operator|&&
name|REG_P
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|&&
operator|!
name|return_value_pseudo
condition|)
block|{
name|return_value_pseudo
operator|=
name|SET_SRC
argument_list|(
name|set
argument_list|)
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
comment|/* If INSN is zero, then the search walked all the way through the 	 block without hitting anything interesting.  This block is a 	 valid alternate exit block.  */
if|if
condition|(
name|insn
operator|==
name|NULL
condition|)
name|alternate_exit
operator|=
name|e
operator|->
name|src
expr_stmt|;
else|else
name|return_value_pseudo
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* If the function uses ADDRESSOF, we can't (easily) determine      at this point if the value will end up on the stack.  */
name|no_sibcalls_this_function
operator||=
name|sequence_uses_addressof
argument_list|(
name|insns
argument_list|)
expr_stmt|;
comment|/* Walk the insn chain and find any CALL_PLACEHOLDER insns.  We need to      select one of the insn sequences attached to each CALL_PLACEHOLDER.       The different sequences represent different ways to implement the call,      ie, tail recursion, sibling call or normal call.       Since we do not create nested CALL_PLACEHOLDERs, the scan      continues with the insn that was after a replaced CALL_PLACEHOLDER;      we don't rescan the replacement insns.  */
for|for
control|(
name|insn
operator|=
name|insns
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|CALL_PLACEHOLDER
condition|)
block|{
name|int
name|sibcall
init|=
operator|(
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|!=
name|NULL_RTX
operator|)
decl_stmt|;
name|int
name|tailrecursion
init|=
operator|(
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|2
argument_list|)
operator|!=
name|NULL_RTX
operator|)
decl_stmt|;
name|basic_block
name|call_block
init|=
name|BLOCK_FOR_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
comment|/* alloca (until we have stack slot life analysis) inhibits 	     sibling call optimizations, but not tail recursion. 	     Similarly if we use varargs or stdarg since they implicitly 	     may take the address of an argument.  */
if|if
condition|(
name|current_function_calls_alloca
operator|||
name|current_function_varargs
operator|||
name|current_function_stdarg
condition|)
name|sibcall
operator|=
literal|0
expr_stmt|;
comment|/* See if there are any reasons we can't perform either sibling or 	     tail call optimizations.  We must be careful with stack slots 	     which are live at potential optimization sites.  */
if|if
condition|(
name|no_sibcalls_this_function
comment|/* ??? Overly conservative.  */
operator|||
name|frame_offset
comment|/* Any function that calls setjmp might have longjmp called from 		 any called function.  ??? We really should represent this 		 properly in the CFG so that this needn't be special cased.  */
operator|||
name|current_function_calls_setjmp
comment|/* Can't if more than one successor or single successor is not 		 exit block.  These two tests prevent tail call optimization 		 in the presense of active exception handlers.  */
operator|||
name|call_block
operator|->
name|succ
operator|==
name|NULL
operator|||
name|call_block
operator|->
name|succ
operator|->
name|succ_next
operator|!=
name|NULL
operator|||
operator|(
name|call_block
operator|->
name|succ
operator|->
name|dest
operator|!=
name|EXIT_BLOCK_PTR
operator|&&
name|call_block
operator|->
name|succ
operator|->
name|dest
operator|!=
name|alternate_exit
operator|)
comment|/* If this call doesn't end the block, there are operations at 		 the end of the block which we must execute after returning.  */
operator|||
operator|!
name|call_ends_block_p
argument_list|(
name|insn
argument_list|,
name|call_block
operator|->
name|end
argument_list|)
condition|)
name|sibcall
operator|=
literal|0
operator|,
name|tailrecursion
operator|=
literal|0
expr_stmt|;
comment|/* Select a set of insns to implement the call and emit them. 	     Tail recursion is the most efficient, so select it over 	     a tail/sibling call.  */
if|if
condition|(
name|sibcall
condition|)
name|successful_sibling_call
operator|=
literal|1
expr_stmt|;
name|replaced_call_placeholder
operator|=
literal|1
expr_stmt|;
name|replace_call_placeholder
argument_list|(
name|insn
argument_list|,
name|tailrecursion
operator|!=
literal|0
condition|?
name|sibcall_use_tail_recursion
else|:
name|sibcall
operator|!=
literal|0
condition|?
name|sibcall_use_sibcall
else|:
name|sibcall_use_normal
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|successful_sibling_call
condition|)
block|{
name|rtx
name|insn
decl_stmt|;
name|tree
name|arg
decl_stmt|;
comment|/* A sibling call sequence invalidates any REG_EQUIV notes made for 	 this function's incoming arguments.   	 At the start of RTL generation we know the only REG_EQUIV notes 	 in the rtl chain are those for incoming arguments, so we can safely 	 flush any REG_EQUIV note.   	 This is (slight) overkill.  We could keep track of the highest 	 argument we clobber and be more selective in removing notes, but it 	 does not seem to be worth the effort.  */
name|purge_reg_equiv_notes
argument_list|()
expr_stmt|;
comment|/* A sibling call sequence also may invalidate RTX_UNCHANGING_P 	 flag of some incoming arguments MEM RTLs, because it can write into 	 those slots.  We clear all those bits now. 	  	 This is (slight) overkill, we could keep track of which arguments 	 we actually write into.  */
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
name|purge_mem_unchanging_flag
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Similarly, invalidate RTX_UNCHANGING_P for any incoming 	 arguments passed in registers. */
for|for
control|(
name|arg
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|current_function_decl
argument_list|)
init|;
name|arg
condition|;
name|arg
operator|=
name|TREE_CHAIN
argument_list|(
name|arg
argument_list|)
control|)
block|{
if|if
condition|(
name|REG_P
argument_list|(
name|DECL_RTL
argument_list|(
name|arg
argument_list|)
argument_list|)
condition|)
name|RTX_UNCHANGING_P
argument_list|(
name|DECL_RTL
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|=
name|false
expr_stmt|;
block|}
block|}
comment|/* There may have been NOTE_INSN_BLOCK_{BEGIN,END} notes in the       CALL_PLACEHOLDER alternatives that we didn't emit.  Rebuild the      lexical block tree to correspond to the notes that still exist.  */
if|if
condition|(
name|replaced_call_placeholder
condition|)
name|reorder_blocks
argument_list|()
expr_stmt|;
comment|/* This information will be invalid after inline expansion.  Kill it now.  */
name|free_basic_block_vars
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

