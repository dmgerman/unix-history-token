begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Utility routines for data type conversion for GNU C.    Copyright (C) 1987, 88, 91-95, 97, 1998 Free Software Foundation, Inc.  This file is part of GNU C.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* These routines are somewhat language-independent utility function    intended to be called by the language-specific convert () functions.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"convert.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_comment
comment|/* Convert EXPR to some pointer or reference type TYPE.     EXPR must be pointer, reference, integer, enumeral, or literal zero;    in other cases error is called.  */
end_comment

begin_function
name|tree
name|convert_to_pointer
parameter_list|(
name|type
parameter_list|,
name|expr
parameter_list|)
name|tree
name|type
decl_stmt|,
name|expr
decl_stmt|;
block|{
if|if
condition|(
name|integer_zerop
argument_list|(
name|expr
argument_list|)
condition|)
block|{
name|expr
operator|=
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
operator|=
name|type
expr_stmt|;
return|return
name|expr
return|;
block|}
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|POINTER_TYPE
case|:
case|case
name|REFERENCE_TYPE
case|:
return|return
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|type
argument_list|,
name|expr
argument_list|)
return|;
case|case
name|INTEGER_TYPE
case|:
case|case
name|ENUMERAL_TYPE
case|:
case|case
name|BOOLEAN_TYPE
case|:
case|case
name|CHAR_TYPE
case|:
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|POINTER_SIZE
condition|)
return|return
name|build1
argument_list|(
name|CONVERT_EXPR
argument_list|,
name|type
argument_list|,
name|expr
argument_list|)
return|;
return|return
name|convert_to_pointer
argument_list|(
name|type
argument_list|,
name|convert
argument_list|(
name|type_for_size
argument_list|(
name|POINTER_SIZE
argument_list|,
literal|0
argument_list|)
argument_list|,
name|expr
argument_list|)
argument_list|)
return|;
default|default:
name|error
argument_list|(
literal|"cannot convert to a pointer type"
argument_list|)
expr_stmt|;
return|return
name|convert_to_pointer
argument_list|(
name|type
argument_list|,
name|integer_zero_node
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Convert EXPR to some floating-point type TYPE.     EXPR must be float, integer, or enumeral;    in other cases error is called.  */
end_comment

begin_function
name|tree
name|convert_to_real
parameter_list|(
name|type
parameter_list|,
name|expr
parameter_list|)
name|tree
name|type
decl_stmt|,
name|expr
decl_stmt|;
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|REAL_TYPE
case|:
return|return
name|build1
argument_list|(
name|flag_float_store
condition|?
name|CONVERT_EXPR
else|:
name|NOP_EXPR
argument_list|,
name|type
argument_list|,
name|expr
argument_list|)
return|;
case|case
name|INTEGER_TYPE
case|:
case|case
name|ENUMERAL_TYPE
case|:
case|case
name|BOOLEAN_TYPE
case|:
case|case
name|CHAR_TYPE
case|:
return|return
name|build1
argument_list|(
name|FLOAT_EXPR
argument_list|,
name|type
argument_list|,
name|expr
argument_list|)
return|;
case|case
name|COMPLEX_TYPE
case|:
return|return
name|convert
argument_list|(
name|type
argument_list|,
name|fold
argument_list|(
name|build1
argument_list|(
name|REALPART_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|POINTER_TYPE
case|:
case|case
name|REFERENCE_TYPE
case|:
name|error
argument_list|(
literal|"pointer value used where a floating point value was expected"
argument_list|)
expr_stmt|;
return|return
name|convert_to_real
argument_list|(
name|type
argument_list|,
name|integer_zero_node
argument_list|)
return|;
default|default:
name|error
argument_list|(
literal|"aggregate value used where a float was expected"
argument_list|)
expr_stmt|;
return|return
name|convert_to_real
argument_list|(
name|type
argument_list|,
name|integer_zero_node
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Convert EXPR to some integer (or enum) type TYPE.     EXPR must be pointer, integer, discrete (enum, char, or bool), or float;    in other cases error is called.     The result of this is always supposed to be a newly created tree node    not in use in any existing structure.  */
end_comment

begin_function
name|tree
name|convert_to_integer
parameter_list|(
name|type
parameter_list|,
name|expr
parameter_list|)
name|tree
name|type
decl_stmt|,
name|expr
decl_stmt|;
block|{
name|enum
name|tree_code
name|ex_form
init|=
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
decl_stmt|;
name|tree
name|intype
init|=
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
decl_stmt|;
name|int
name|inprec
init|=
name|TYPE_PRECISION
argument_list|(
name|intype
argument_list|)
decl_stmt|;
name|int
name|outprec
init|=
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
decl_stmt|;
comment|/* An INTEGER_TYPE cannot be incomplete, but an ENUMERAL_TYPE can      be.  Consider `enum E = { a, b = (enum E) 3 };'.  */
if|if
condition|(
operator|!
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"conversion to incomplete type"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|intype
argument_list|)
condition|)
block|{
case|case
name|POINTER_TYPE
case|:
case|case
name|REFERENCE_TYPE
case|:
if|if
condition|(
name|integer_zerop
argument_list|(
name|expr
argument_list|)
condition|)
name|expr
operator|=
name|integer_zero_node
expr_stmt|;
else|else
name|expr
operator|=
name|fold
argument_list|(
name|build1
argument_list|(
name|CONVERT_EXPR
argument_list|,
name|type_for_size
argument_list|(
name|POINTER_SIZE
argument_list|,
literal|0
argument_list|)
argument_list|,
name|expr
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|convert_to_integer
argument_list|(
name|type
argument_list|,
name|expr
argument_list|)
return|;
case|case
name|INTEGER_TYPE
case|:
case|case
name|ENUMERAL_TYPE
case|:
case|case
name|BOOLEAN_TYPE
case|:
case|case
name|CHAR_TYPE
case|:
comment|/* If this is a logical operation, which just returns 0 or 1, we can 	 change the type of the expression.  For some logical operations, 	 we must also change the types of the operands to maintain type 	 correctness.  */
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|ex_form
argument_list|)
operator|==
literal|'<'
condition|)
block|{
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
operator|=
name|type
expr_stmt|;
return|return
name|expr
return|;
block|}
elseif|else
if|if
condition|(
name|ex_form
operator|==
name|TRUTH_AND_EXPR
operator|||
name|ex_form
operator|==
name|TRUTH_ANDIF_EXPR
operator|||
name|ex_form
operator|==
name|TRUTH_OR_EXPR
operator|||
name|ex_form
operator|==
name|TRUTH_ORIF_EXPR
operator|||
name|ex_form
operator|==
name|TRUTH_XOR_EXPR
condition|)
block|{
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
operator|=
name|convert
argument_list|(
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
operator|=
name|convert
argument_list|(
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
operator|=
name|type
expr_stmt|;
return|return
name|expr
return|;
block|}
elseif|else
if|if
condition|(
name|ex_form
operator|==
name|TRUTH_NOT_EXPR
condition|)
block|{
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
operator|=
name|convert
argument_list|(
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
operator|=
name|type
expr_stmt|;
return|return
name|expr
return|;
block|}
comment|/* If we are widening the type, put in an explicit conversion. 	 Similarly if we are not changing the width.  After this, we know 	 we are truncating EXPR.  */
elseif|else
if|if
condition|(
name|outprec
operator|>=
name|inprec
condition|)
return|return
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|type
argument_list|,
name|expr
argument_list|)
return|;
comment|/* If TYPE is an enumeral type or a type with a precision less 	 than the number of bits in its mode, do the conversion to the 	 type corresponding to its mode, then do a nop conversion 	 to TYPE.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|||
name|outprec
operator|!=
name|GET_MODE_BITSIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
return|return
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|type
argument_list|,
name|convert
argument_list|(
name|type_for_mode
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
argument_list|)
return|;
comment|/* Here detect when we can distribute the truncation down past some 	 arithmetic.  For example, if adding two longs and converting to an 	 int, we can equally well convert both to ints and then add. 	 For the operations handled here, such truncation distribution 	 is always safe. 	 It is desirable in these cases: 	 1) when truncating down to full-word from a larger size 	 2) when truncating takes no work. 	 3) when at least one operand of the arithmetic has been extended 	 (as by C's default conversions).  In this case we need two conversions 	 if we do the arithmetic as already requested, so we might as well 	 truncate both and then combine.  Perhaps that way we need only one.  	 Note that in general we cannot do the arithmetic in a type 	 shorter than the desired result of conversion, even if the operands 	 are both extended from a shorter type, because they might overflow 	 if combined in that type.  The exceptions to this--the times when 	 two narrow values can be combined in their narrow type even to 	 make a wider result--are handled by "shorten" in build_binary_op.  */
switch|switch
condition|(
name|ex_form
condition|)
block|{
case|case
name|RSHIFT_EXPR
case|:
comment|/* We can pass truncation down through right shifting 	     when the shift count is a nonpositive constant.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|tree_int_cst_lt
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|,
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|integer_one_node
argument_list|)
argument_list|)
condition|)
goto|goto
name|trunc1
goto|;
break|break;
case|case
name|LSHIFT_EXPR
case|:
comment|/* We can pass truncation down through left shifting 	     when the shift count is a nonnegative constant.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|tree_int_cst_sgn
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|>=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
comment|/* If shift count is less than the width of the truncated type, 		 really shift.  */
if|if
condition|(
name|tree_int_cst_lt
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|,
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
comment|/* In this case, shifting is like multiplication.  */
goto|goto
name|trunc1
goto|;
else|else
block|{
comment|/* If it is>= that width, result is zero. 		     Handling this with trunc1 would give the wrong result: 		     (int) ((long long) a<< 32) is well defined (as 0) 		     but (int) a<< 32 is undefined and would get a 		     warning.  */
name|tree
name|t
init|=
name|convert_to_integer
argument_list|(
name|type
argument_list|,
name|integer_zero_node
argument_list|)
decl_stmt|;
comment|/* If the original expression had side-effects, we must 		     preserve it.  */
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|expr
argument_list|)
condition|)
return|return
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|type
argument_list|,
name|expr
argument_list|,
name|t
argument_list|)
return|;
else|else
return|return
name|t
return|;
block|}
block|}
break|break;
case|case
name|MAX_EXPR
case|:
case|case
name|MIN_EXPR
case|:
case|case
name|MULT_EXPR
case|:
block|{
name|tree
name|arg0
init|=
name|get_unwidened
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|tree
name|arg1
init|=
name|get_unwidened
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|,
name|type
argument_list|)
decl_stmt|;
comment|/* Don't distribute unless the output precision is at least as big 	       as the actual inputs.  Otherwise, the comparison of the 	       truncated values will be wrong.  */
if|if
condition|(
name|outprec
operator|>=
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|&&
name|outprec
operator|>=
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
comment|/* If signedness of arg0 and arg1 don't match, 		   we can't necessarily find a type to compare them in.  */
operator|&&
operator|(
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|==
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|)
condition|)
goto|goto
name|trunc1
goto|;
break|break;
block|}
case|case
name|PLUS_EXPR
case|:
case|case
name|MINUS_EXPR
case|:
case|case
name|BIT_AND_EXPR
case|:
case|case
name|BIT_IOR_EXPR
case|:
case|case
name|BIT_XOR_EXPR
case|:
case|case
name|BIT_ANDTC_EXPR
case|:
name|trunc1
label|:
block|{
name|tree
name|arg0
init|=
name|get_unwidened
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|tree
name|arg1
init|=
name|get_unwidened
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|,
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|outprec
operator|>=
name|BITS_PER_WORD
operator|||
name|TRULY_NOOP_TRUNCATION
argument_list|(
name|outprec
argument_list|,
name|inprec
argument_list|)
operator|||
name|inprec
operator|>
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|||
name|inprec
operator|>
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Do the arithmetic in type TYPEX, 		   then convert result to TYPE.  */
specifier|register
name|tree
name|typex
init|=
name|type
decl_stmt|;
comment|/* Can't do arithmetic in enumeral types 		   so use an integer type that will hold the values.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|typex
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
name|typex
operator|=
name|type_for_size
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|typex
argument_list|)
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|typex
argument_list|)
argument_list|)
expr_stmt|;
comment|/* But now perhaps TYPEX is as wide as INPREC. 		   In that case, do nothing special here. 		   (Otherwise would recurse infinitely in convert.  */
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|typex
argument_list|)
operator|!=
name|inprec
condition|)
block|{
comment|/* Don't do unsigned arithmetic where signed was wanted, 		       or vice versa. 		       Exception: if either of the original operands were 		       unsigned then can safely do the work as unsigned. 		       And we may need to do it as unsigned 		       if we truncate to the original size.  */
name|typex
operator|=
operator|(
operator|(
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|||
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|||
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|)
condition|?
name|unsigned_type
argument_list|(
name|typex
argument_list|)
else|:
name|signed_type
argument_list|(
name|typex
argument_list|)
operator|)
expr_stmt|;
return|return
name|convert
argument_list|(
name|type
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|ex_form
argument_list|,
name|typex
argument_list|,
name|convert
argument_list|(
name|typex
argument_list|,
name|arg0
argument_list|)
argument_list|,
name|convert
argument_list|(
name|typex
argument_list|,
name|arg1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
block|}
block|}
break|break;
case|case
name|NEGATE_EXPR
case|:
case|case
name|BIT_NOT_EXPR
case|:
comment|/* This is not correct for ABS_EXPR, 	     since we must test the sign before truncation.  */
block|{
specifier|register
name|tree
name|typex
init|=
name|type
decl_stmt|;
comment|/* Can't do arithmetic in enumeral types 	       so use an integer type that will hold the values.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|typex
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
name|typex
operator|=
name|type_for_size
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|typex
argument_list|)
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|typex
argument_list|)
argument_list|)
expr_stmt|;
comment|/* But now perhaps TYPEX is as wide as INPREC. 	       In that case, do nothing special here. 	       (Otherwise would recurse infinitely in convert.  */
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|typex
argument_list|)
operator|!=
name|inprec
condition|)
block|{
comment|/* Don't do unsigned arithmetic where signed was wanted, 		   or vice versa.  */
name|typex
operator|=
operator|(
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|?
name|unsigned_type
argument_list|(
name|typex
argument_list|)
else|:
name|signed_type
argument_list|(
name|typex
argument_list|)
operator|)
expr_stmt|;
return|return
name|convert
argument_list|(
name|type
argument_list|,
name|fold
argument_list|(
name|build1
argument_list|(
name|ex_form
argument_list|,
name|typex
argument_list|,
name|convert
argument_list|(
name|typex
argument_list|,
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
block|}
case|case
name|NOP_EXPR
case|:
comment|/* If truncating after truncating, might as well do all at once. 	     If truncating after extending, we may get rid of wasted work.  */
return|return
name|convert
argument_list|(
name|type
argument_list|,
name|get_unwidened
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|type
argument_list|)
argument_list|)
return|;
case|case
name|COND_EXPR
case|:
comment|/* It is sometimes worthwhile to push the narrowing down through 	     the conditional and never loses.  */
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|COND_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|convert
argument_list|(
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|convert
argument_list|(
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|2
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
default|default:
break|break;
block|}
return|return
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|type
argument_list|,
name|expr
argument_list|)
return|;
case|case
name|REAL_TYPE
case|:
return|return
name|build1
argument_list|(
name|FIX_TRUNC_EXPR
argument_list|,
name|type
argument_list|,
name|expr
argument_list|)
return|;
case|case
name|COMPLEX_TYPE
case|:
return|return
name|convert
argument_list|(
name|type
argument_list|,
name|fold
argument_list|(
name|build1
argument_list|(
name|REALPART_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
argument_list|)
argument_list|)
return|;
default|default:
name|error
argument_list|(
literal|"aggregate value used where an integer was expected"
argument_list|)
expr_stmt|;
return|return
name|convert
argument_list|(
name|type
argument_list|,
name|integer_zero_node
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Convert EXPR to the complex type TYPE in the usual ways.  */
end_comment

begin_function
name|tree
name|convert_to_complex
parameter_list|(
name|type
parameter_list|,
name|expr
parameter_list|)
name|tree
name|type
decl_stmt|,
name|expr
decl_stmt|;
block|{
name|tree
name|subtype
init|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|REAL_TYPE
case|:
case|case
name|INTEGER_TYPE
case|:
case|case
name|ENUMERAL_TYPE
case|:
case|case
name|BOOLEAN_TYPE
case|:
case|case
name|CHAR_TYPE
case|:
return|return
name|build
argument_list|(
name|COMPLEX_EXPR
argument_list|,
name|type
argument_list|,
name|convert
argument_list|(
name|subtype
argument_list|,
name|expr
argument_list|)
argument_list|,
name|convert
argument_list|(
name|subtype
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|)
return|;
case|case
name|COMPLEX_TYPE
case|:
block|{
name|tree
name|elt_type
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|elt_type
argument_list|)
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|subtype
argument_list|)
condition|)
return|return
name|expr
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|COMPLEX_EXPR
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|COMPLEX_EXPR
argument_list|,
name|type
argument_list|,
name|convert
argument_list|(
name|subtype
argument_list|,
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|convert
argument_list|(
name|subtype
argument_list|,
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
else|else
block|{
name|expr
operator|=
name|save_expr
argument_list|(
name|expr
argument_list|)
expr_stmt|;
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|COMPLEX_EXPR
argument_list|,
name|type
argument_list|,
name|convert
argument_list|(
name|subtype
argument_list|,
name|fold
argument_list|(
name|build1
argument_list|(
name|REALPART_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|convert
argument_list|(
name|subtype
argument_list|,
name|fold
argument_list|(
name|build1
argument_list|(
name|IMAGPART_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
block|}
case|case
name|POINTER_TYPE
case|:
case|case
name|REFERENCE_TYPE
case|:
name|error
argument_list|(
literal|"pointer value used where a complex was expected"
argument_list|)
expr_stmt|;
return|return
name|convert_to_complex
argument_list|(
name|type
argument_list|,
name|integer_zero_node
argument_list|)
return|;
default|default:
name|error
argument_list|(
literal|"aggregate value used where a complex was expected"
argument_list|)
expr_stmt|;
return|return
name|convert_to_complex
argument_list|(
name|type
argument_list|,
name|integer_zero_node
argument_list|)
return|;
block|}
block|}
end_function

end_unit

