begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Utility routines for data type conversion for GCC.    Copyright (C) 1987, 1988, 1991, 1992, 1993, 1994, 1995, 1997, 1998,    2000, 2001, 2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* These routines are somewhat language-independent utility function    intended to be called by the language-specific convert () functions.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"convert.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_comment
comment|/* Convert EXPR to some pointer or reference type TYPE.    EXPR must be pointer, reference, integer, enumeral, or literal zero;    in other cases error is called.  */
end_comment

begin_function
name|tree
name|convert_to_pointer
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|expr
parameter_list|)
block|{
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
operator|==
name|type
condition|)
return|return
name|expr
return|;
if|if
condition|(
name|integer_zerop
argument_list|(
name|expr
argument_list|)
condition|)
block|{
name|tree
name|t
init|=
name|build_int_cst
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_OVERFLOW
argument_list|(
name|expr
argument_list|)
operator|||
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|expr
argument_list|)
condition|)
name|t
operator|=
name|force_fit_type
argument_list|(
name|t
argument_list|,
literal|0
argument_list|,
name|TREE_OVERFLOW
argument_list|(
name|expr
argument_list|)
argument_list|,
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|POINTER_TYPE
case|:
case|case
name|REFERENCE_TYPE
case|:
return|return
name|fold_build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|type
argument_list|,
name|expr
argument_list|)
return|;
case|case
name|INTEGER_TYPE
case|:
case|case
name|ENUMERAL_TYPE
case|:
case|case
name|BOOLEAN_TYPE
case|:
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|!=
name|POINTER_SIZE
condition|)
name|expr
operator|=
name|fold_build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|lang_hooks
operator|.
name|types
operator|.
name|type_for_size
argument_list|(
name|POINTER_SIZE
argument_list|,
literal|0
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
return|return
name|fold_build1
argument_list|(
name|CONVERT_EXPR
argument_list|,
name|type
argument_list|,
name|expr
argument_list|)
return|;
comment|/* APPLE LOCAL begin blocks (C++ ck) */
case|case
name|BLOCK_POINTER_TYPE
case|:
comment|/* APPLE LOCAL begin radar 5809099 */
if|if
condition|(
name|objc_is_id
argument_list|(
name|type
argument_list|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|VOID_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|)
condition|)
comment|/* APPLE LOCAL end radar 5809099 */
return|return
name|fold_build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|type
argument_list|,
name|expr
argument_list|)
return|;
comment|/* APPLE LOCAL end blocks (C++ ck) */
default|default:
name|error
argument_list|(
literal|"cannot convert to a pointer type"
argument_list|)
expr_stmt|;
return|return
name|convert_to_pointer
argument_list|(
name|type
argument_list|,
name|integer_zero_node
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* APPLE LOCAL begin blocks (C++ ck) */
end_comment

begin_function
name|tree
name|convert_to_block_pointer
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|expr
parameter_list|)
block|{
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
operator|==
name|type
condition|)
return|return
name|expr
return|;
if|if
condition|(
name|integer_zerop
argument_list|(
name|expr
argument_list|)
condition|)
block|{
name|tree
name|t
init|=
name|build_int_cst
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_OVERFLOW
argument_list|(
name|expr
argument_list|)
operator|||
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|expr
argument_list|)
condition|)
name|t
operator|=
name|force_fit_type
argument_list|(
name|t
argument_list|,
literal|0
argument_list|,
name|TREE_OVERFLOW
argument_list|(
name|expr
argument_list|)
argument_list|,
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|BLOCK_POINTER_TYPE
case|:
return|return
name|fold_build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|type
argument_list|,
name|expr
argument_list|)
return|;
case|case
name|INTEGER_TYPE
case|:
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|!=
name|POINTER_SIZE
condition|)
name|expr
operator|=
name|fold_build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|lang_hooks
operator|.
name|types
operator|.
name|type_for_size
argument_list|(
name|POINTER_SIZE
argument_list|,
literal|0
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
return|return
name|fold_build1
argument_list|(
name|CONVERT_EXPR
argument_list|,
name|type
argument_list|,
name|expr
argument_list|)
return|;
case|case
name|POINTER_TYPE
case|:
comment|/* APPLE LOCAL radar 5809099 */
if|if
condition|(
name|objc_is_id
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|||
name|VOID_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|type
argument_list|,
name|expr
argument_list|)
return|;
comment|/* fall thru */
default|default:
name|error
argument_list|(
literal|"cannot convert to a block pointer type"
argument_list|)
expr_stmt|;
return|return
name|convert_to_block_pointer
argument_list|(
name|type
argument_list|,
name|integer_zero_node
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* APPLE LOCAL end blocks (C++ ck) */
end_comment

begin_comment
comment|/* Avoid any floating point extensions from EXP.  */
end_comment

begin_function
name|tree
name|strip_float_extensions
parameter_list|(
name|tree
name|exp
parameter_list|)
block|{
name|tree
name|sub
decl_stmt|,
name|expt
decl_stmt|,
name|subt
decl_stmt|;
comment|/*  For floating point constant look up the narrowest type that can hold       it properly and handle it like (type)(narrowest_type)constant.       This way we can optimize for instance a=a*2.0 where "a" is float       but 2.0 is double constant.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|REAL_CST
condition|)
block|{
name|REAL_VALUE_TYPE
name|orig
decl_stmt|;
name|tree
name|type
init|=
name|NULL
decl_stmt|;
name|orig
operator|=
name|TREE_REAL_CST
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|>
name|TYPE_PRECISION
argument_list|(
name|float_type_node
argument_list|)
operator|&&
name|exact_real_truncate
argument_list|(
name|TYPE_MODE
argument_list|(
name|float_type_node
argument_list|)
argument_list|,
operator|&
name|orig
argument_list|)
condition|)
name|type
operator|=
name|float_type_node
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|>
name|TYPE_PRECISION
argument_list|(
name|double_type_node
argument_list|)
operator|&&
name|exact_real_truncate
argument_list|(
name|TYPE_MODE
argument_list|(
name|double_type_node
argument_list|)
argument_list|,
operator|&
name|orig
argument_list|)
condition|)
name|type
operator|=
name|double_type_node
expr_stmt|;
if|if
condition|(
name|type
condition|)
return|return
name|build_real
argument_list|(
name|type
argument_list|,
name|real_value_truncate
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
name|orig
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|!=
name|NOP_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|!=
name|CONVERT_EXPR
condition|)
return|return
name|exp
return|;
name|sub
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|subt
operator|=
name|TREE_TYPE
argument_list|(
name|sub
argument_list|)
expr_stmt|;
name|expt
operator|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|FLOAT_TYPE_P
argument_list|(
name|subt
argument_list|)
condition|)
return|return
name|exp
return|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|subt
argument_list|)
operator|>
name|TYPE_PRECISION
argument_list|(
name|expt
argument_list|)
condition|)
return|return
name|exp
return|;
return|return
name|strip_float_extensions
argument_list|(
name|sub
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Convert EXPR to some floating-point type TYPE.     EXPR must be float, integer, or enumeral;    in other cases error is called.  */
end_comment

begin_function
name|tree
name|convert_to_real
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|expr
parameter_list|)
block|{
name|enum
name|built_in_function
name|fcode
init|=
name|builtin_mathfn_code
argument_list|(
name|expr
argument_list|)
decl_stmt|;
name|tree
name|itype
init|=
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
decl_stmt|;
comment|/* Disable until we figure out how to decide whether the functions are      present in runtime.  */
comment|/* Convert (float)sqrt((double)x) where x is float into sqrtf(x) */
if|if
condition|(
name|optimize
operator|&&
operator|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_MODE
argument_list|(
name|double_type_node
argument_list|)
operator|||
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_MODE
argument_list|(
name|float_type_node
argument_list|)
operator|)
condition|)
block|{
switch|switch
condition|(
name|fcode
condition|)
block|{
define|#
directive|define
name|CASE_MATHFN
parameter_list|(
name|FN
parameter_list|)
value|case BUILT_IN_##FN: case BUILT_IN_##FN##L:
name|CASE_MATHFN
argument_list|(
argument|ACOS
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|ACOSH
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|ASIN
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|ASINH
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|ATAN
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|ATANH
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|CBRT
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|COS
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|COSH
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|ERF
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|ERFC
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|EXP
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|EXP10
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|EXP2
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|EXPM1
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|FABS
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|GAMMA
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|J0
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|J1
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|LGAMMA
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|LOG
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|LOG10
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|LOG1P
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|LOG2
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|LOGB
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|POW10
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|SIN
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|SINH
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|SQRT
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|TAN
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|TANH
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|TGAMMA
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|Y0
argument_list|)
name|CASE_MATHFN
argument_list|(
argument|Y1
argument_list|)
undef|#
directive|undef
name|CASE_MATHFN
block|{
name|tree
name|arg0
init|=
name|strip_float_extensions
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|newtype
init|=
name|type
decl_stmt|;
comment|/* We have (outertype)sqrt((innertype)x).  Choose the wider mode from 		 the both as the safe type for operation.  */
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|>
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
condition|)
name|newtype
operator|=
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
comment|/* Be careful about integer to fp conversions. 		 These may overflow still.  */
if|if
condition|(
name|FLOAT_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|&&
name|TYPE_PRECISION
argument_list|(
name|newtype
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|itype
argument_list|)
operator|&&
operator|(
name|TYPE_MODE
argument_list|(
name|newtype
argument_list|)
operator|==
name|TYPE_MODE
argument_list|(
name|double_type_node
argument_list|)
operator|||
name|TYPE_MODE
argument_list|(
name|newtype
argument_list|)
operator|==
name|TYPE_MODE
argument_list|(
name|float_type_node
argument_list|)
operator|)
condition|)
block|{
name|tree
name|arglist
decl_stmt|;
name|tree
name|fn
init|=
name|mathfn_built_in
argument_list|(
name|newtype
argument_list|,
name|fcode
argument_list|)
decl_stmt|;
if|if
condition|(
name|fn
condition|)
block|{
name|arglist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|fold
argument_list|(
name|convert_to_real
argument_list|(
name|newtype
argument_list|,
name|arg0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|build_function_call_expr
argument_list|(
name|fn
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
if|if
condition|(
name|newtype
operator|==
name|type
condition|)
return|return
name|expr
return|;
block|}
block|}
block|}
default|default:
break|break;
block|}
block|}
if|if
condition|(
name|optimize
operator|&&
operator|(
operator|(
operator|(
name|fcode
operator|==
name|BUILT_IN_FLOORL
operator|||
name|fcode
operator|==
name|BUILT_IN_CEILL
operator|||
name|fcode
operator|==
name|BUILT_IN_ROUNDL
operator|||
name|fcode
operator|==
name|BUILT_IN_RINTL
operator|||
name|fcode
operator|==
name|BUILT_IN_TRUNCL
operator|||
name|fcode
operator|==
name|BUILT_IN_NEARBYINTL
operator|)
operator|&&
operator|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_MODE
argument_list|(
name|double_type_node
argument_list|)
operator|||
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_MODE
argument_list|(
name|float_type_node
argument_list|)
operator|)
operator|)
operator|||
operator|(
operator|(
name|fcode
operator|==
name|BUILT_IN_FLOOR
operator|||
name|fcode
operator|==
name|BUILT_IN_CEIL
operator|||
name|fcode
operator|==
name|BUILT_IN_ROUND
operator|||
name|fcode
operator|==
name|BUILT_IN_RINT
operator|||
name|fcode
operator|==
name|BUILT_IN_TRUNC
operator|||
name|fcode
operator|==
name|BUILT_IN_NEARBYINT
operator|)
operator|&&
operator|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_MODE
argument_list|(
name|float_type_node
argument_list|)
operator|)
operator|)
operator|)
condition|)
block|{
name|tree
name|fn
init|=
name|mathfn_built_in
argument_list|(
name|type
argument_list|,
name|fcode
argument_list|)
decl_stmt|;
if|if
condition|(
name|fn
condition|)
block|{
name|tree
name|arg
init|=
name|strip_float_extensions
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Make sure (type)arg0 is an extension, otherwise we could end up 	     changing (float)floor(double d) into floorf((float)d), which is 	     incorrect because (float)d uses round-to-nearest and can round 	     up to the next integer.  */
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|>=
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
condition|)
return|return
name|build_function_call_expr
argument_list|(
name|fn
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|fold
argument_list|(
name|convert_to_real
argument_list|(
name|type
argument_list|,
name|arg
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
block|}
comment|/* Propagate the cast into the operation.  */
if|if
condition|(
name|itype
operator|!=
name|type
operator|&&
name|FLOAT_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
condition|)
block|{
comment|/* Convert (float)-x into -(float)x.  This is safe for 	   round-to-nearest rounding mode.  */
case|case
name|ABS_EXPR
case|:
case|case
name|NEGATE_EXPR
case|:
if|if
condition|(
operator|!
name|flag_rounding_math
operator|&&
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
return|return
name|build1
argument_list|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
argument_list|,
name|type
argument_list|,
name|fold
argument_list|(
name|convert_to_real
argument_list|(
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
break|break;
comment|/* Convert (outertype)((innertype0)a+(innertype1)b) 	   into ((newtype)a+(newtype)b) where newtype 	   is the widest mode from all of these.  */
case|case
name|PLUS_EXPR
case|:
case|case
name|MINUS_EXPR
case|:
case|case
name|MULT_EXPR
case|:
case|case
name|RDIV_EXPR
case|:
block|{
name|tree
name|arg0
init|=
name|strip_float_extensions
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|arg1
init|=
name|strip_float_extensions
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|FLOAT_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|&&
name|FLOAT_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|newtype
init|=
name|type
decl_stmt|;
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|==
name|SDmode
operator|||
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|==
name|SDmode
condition|)
name|newtype
operator|=
name|dfloat32_type_node
expr_stmt|;
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|==
name|DDmode
operator|||
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|==
name|DDmode
condition|)
name|newtype
operator|=
name|dfloat64_type_node
expr_stmt|;
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|==
name|TDmode
operator|||
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|==
name|TDmode
condition|)
name|newtype
operator|=
name|dfloat128_type_node
expr_stmt|;
if|if
condition|(
name|newtype
operator|==
name|dfloat32_type_node
operator|||
name|newtype
operator|==
name|dfloat64_type_node
operator|||
name|newtype
operator|==
name|dfloat128_type_node
condition|)
block|{
name|expr
operator|=
name|build2
argument_list|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
argument_list|,
name|newtype
argument_list|,
name|fold
argument_list|(
name|convert_to_real
argument_list|(
name|newtype
argument_list|,
name|arg0
argument_list|)
argument_list|)
argument_list|,
name|fold
argument_list|(
name|convert_to_real
argument_list|(
name|newtype
argument_list|,
name|arg1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|newtype
operator|==
name|type
condition|)
return|return
name|expr
return|;
break|break;
block|}
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|>
name|TYPE_PRECISION
argument_list|(
name|newtype
argument_list|)
condition|)
name|newtype
operator|=
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|>
name|TYPE_PRECISION
argument_list|(
name|newtype
argument_list|)
condition|)
name|newtype
operator|=
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|newtype
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|itype
argument_list|)
condition|)
block|{
name|expr
operator|=
name|build2
argument_list|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
argument_list|,
name|newtype
argument_list|,
name|fold
argument_list|(
name|convert_to_real
argument_list|(
name|newtype
argument_list|,
name|arg0
argument_list|)
argument_list|)
argument_list|,
name|fold
argument_list|(
name|convert_to_real
argument_list|(
name|newtype
argument_list|,
name|arg1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|newtype
operator|==
name|type
condition|)
return|return
name|expr
return|;
block|}
block|}
block|}
break|break;
default|default:
break|break;
block|}
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|REAL_TYPE
case|:
comment|/* Ignore the conversion if we don't need to store intermediate 	 results and neither type is a decimal float.  */
return|return
name|build1
argument_list|(
operator|(
name|flag_float_store
operator|||
name|DECIMAL_FLOAT_TYPE_P
argument_list|(
name|type
argument_list|)
operator|||
name|DECIMAL_FLOAT_TYPE_P
argument_list|(
name|itype
argument_list|)
operator|)
condition|?
name|CONVERT_EXPR
else|:
name|NOP_EXPR
argument_list|,
name|type
argument_list|,
name|expr
argument_list|)
return|;
case|case
name|INTEGER_TYPE
case|:
case|case
name|ENUMERAL_TYPE
case|:
case|case
name|BOOLEAN_TYPE
case|:
return|return
name|build1
argument_list|(
name|FLOAT_EXPR
argument_list|,
name|type
argument_list|,
name|expr
argument_list|)
return|;
case|case
name|COMPLEX_TYPE
case|:
return|return
name|convert
argument_list|(
name|type
argument_list|,
name|fold_build1
argument_list|(
name|REALPART_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
argument_list|)
return|;
case|case
name|POINTER_TYPE
case|:
case|case
name|REFERENCE_TYPE
case|:
name|error
argument_list|(
literal|"pointer value used where a floating point value was expected"
argument_list|)
expr_stmt|;
return|return
name|convert_to_real
argument_list|(
name|type
argument_list|,
name|integer_zero_node
argument_list|)
return|;
default|default:
name|error
argument_list|(
literal|"aggregate value used where a float was expected"
argument_list|)
expr_stmt|;
return|return
name|convert_to_real
argument_list|(
name|type
argument_list|,
name|integer_zero_node
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Convert EXPR to some integer (or enum) type TYPE.     EXPR must be pointer, integer, discrete (enum, char, or bool), float, or    vector; in other cases error is called.     The result of this is always supposed to be a newly created tree node    not in use in any existing structure.  */
end_comment

begin_function
name|tree
name|convert_to_integer
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|expr
parameter_list|)
block|{
name|enum
name|tree_code
name|ex_form
init|=
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
decl_stmt|;
name|tree
name|intype
init|=
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|inprec
init|=
name|TYPE_PRECISION
argument_list|(
name|intype
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|outprec
init|=
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
decl_stmt|;
comment|/* An INTEGER_TYPE cannot be incomplete, but an ENUMERAL_TYPE can      be.  Consider `enum E = { a, b = (enum E) 3 };'.  */
if|if
condition|(
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"conversion to incomplete type"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* Convert e.g. (long)round(d) -> lround(d).  */
comment|/* If we're converting to char, we may encounter differing behavior      between converting from double->char vs double->long->char.      We're in "undefined" territory but we prefer to be conservative,      so only proceed in "unsafe" math mode.  */
if|if
condition|(
name|optimize
operator|&&
operator|(
name|flag_unsafe_math_optimizations
operator|||
operator|(
name|long_integer_type_node
operator|&&
name|outprec
operator|>=
name|TYPE_PRECISION
argument_list|(
name|long_integer_type_node
argument_list|)
operator|)
operator|)
condition|)
block|{
name|tree
name|s_expr
init|=
name|strip_float_extensions
argument_list|(
name|expr
argument_list|)
decl_stmt|;
name|tree
name|s_intype
init|=
name|TREE_TYPE
argument_list|(
name|s_expr
argument_list|)
decl_stmt|;
specifier|const
name|enum
name|built_in_function
name|fcode
init|=
name|builtin_mathfn_code
argument_list|(
name|s_expr
argument_list|)
decl_stmt|;
name|tree
name|fn
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|fcode
condition|)
block|{
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_CEIL
argument_list|)
operator|:
comment|/* Only convert in ISO C99 mode.  */
if|if
condition|(
operator|!
name|TARGET_C99_FUNCTIONS
condition|)
break|break;
if|if
condition|(
name|outprec
operator|<
name|TYPE_PRECISION
argument_list|(
name|long_integer_type_node
argument_list|)
operator|||
operator|(
name|outprec
operator|==
name|TYPE_PRECISION
argument_list|(
name|long_integer_type_node
argument_list|)
operator|&&
operator|!
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
operator|)
condition|)
name|fn
operator|=
name|mathfn_built_in
argument_list|(
name|s_intype
argument_list|,
name|BUILT_IN_LCEIL
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|outprec
operator|==
name|TYPE_PRECISION
argument_list|(
name|long_long_integer_type_node
argument_list|)
operator|&&
operator|!
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|)
name|fn
operator|=
name|mathfn_built_in
argument_list|(
name|s_intype
argument_list|,
name|BUILT_IN_LLCEIL
argument_list|)
expr_stmt|;
break|break;
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_FLOOR
argument_list|)
operator|:
comment|/* Only convert in ISO C99 mode.  */
if|if
condition|(
operator|!
name|TARGET_C99_FUNCTIONS
condition|)
break|break;
if|if
condition|(
name|outprec
operator|<
name|TYPE_PRECISION
argument_list|(
name|long_integer_type_node
argument_list|)
operator|||
operator|(
name|outprec
operator|==
name|TYPE_PRECISION
argument_list|(
name|long_integer_type_node
argument_list|)
operator|&&
operator|!
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
operator|)
condition|)
name|fn
operator|=
name|mathfn_built_in
argument_list|(
name|s_intype
argument_list|,
name|BUILT_IN_LFLOOR
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|outprec
operator|==
name|TYPE_PRECISION
argument_list|(
name|long_long_integer_type_node
argument_list|)
operator|&&
operator|!
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|)
name|fn
operator|=
name|mathfn_built_in
argument_list|(
name|s_intype
argument_list|,
name|BUILT_IN_LLFLOOR
argument_list|)
expr_stmt|;
break|break;
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_ROUND
argument_list|)
operator|:
if|if
condition|(
name|outprec
operator|<
name|TYPE_PRECISION
argument_list|(
name|long_integer_type_node
argument_list|)
operator|||
operator|(
name|outprec
operator|==
name|TYPE_PRECISION
argument_list|(
name|long_integer_type_node
argument_list|)
operator|&&
operator|!
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
operator|)
condition|)
name|fn
operator|=
name|mathfn_built_in
argument_list|(
name|s_intype
argument_list|,
name|BUILT_IN_LROUND
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|outprec
operator|==
name|TYPE_PRECISION
argument_list|(
name|long_long_integer_type_node
argument_list|)
operator|&&
operator|!
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|)
name|fn
operator|=
name|mathfn_built_in
argument_list|(
name|s_intype
argument_list|,
name|BUILT_IN_LLROUND
argument_list|)
expr_stmt|;
break|break;
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_NEARBYINT
argument_list|)
operator|:
comment|/* Only convert nearbyint* if we can ignore math exceptions.  */
if|if
condition|(
name|flag_trapping_math
condition|)
break|break;
comment|/* ... Fall through ...  */
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_RINT
argument_list|)
operator|:
if|if
condition|(
name|outprec
operator|<
name|TYPE_PRECISION
argument_list|(
name|long_integer_type_node
argument_list|)
operator|||
operator|(
name|outprec
operator|==
name|TYPE_PRECISION
argument_list|(
name|long_integer_type_node
argument_list|)
operator|&&
operator|!
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
operator|)
condition|)
name|fn
operator|=
name|mathfn_built_in
argument_list|(
name|s_intype
argument_list|,
name|BUILT_IN_LRINT
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|outprec
operator|==
name|TYPE_PRECISION
argument_list|(
name|long_long_integer_type_node
argument_list|)
operator|&&
operator|!
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|)
name|fn
operator|=
name|mathfn_built_in
argument_list|(
name|s_intype
argument_list|,
name|BUILT_IN_LLRINT
argument_list|)
expr_stmt|;
break|break;
name|CASE_FLT_FN
argument_list|(
name|BUILT_IN_TRUNC
argument_list|)
operator|:
block|{
name|tree
name|arglist
operator|=
name|TREE_OPERAND
argument_list|(
name|s_expr
argument_list|,
literal|1
argument_list|)
block|;
return|return
name|convert_to_integer
argument_list|(
name|type
argument_list|,
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
return|;
block|}
default|default:
break|break;
block|}
if|if
condition|(
name|fn
condition|)
block|{
name|tree
name|arglist
init|=
name|TREE_OPERAND
argument_list|(
name|s_expr
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|newexpr
init|=
name|build_function_call_expr
argument_list|(
name|fn
argument_list|,
name|arglist
argument_list|)
decl_stmt|;
return|return
name|convert_to_integer
argument_list|(
name|type
argument_list|,
name|newexpr
argument_list|)
return|;
block|}
block|}
end_function

begin_switch
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|intype
argument_list|)
condition|)
block|{
case|case
name|POINTER_TYPE
case|:
case|case
name|REFERENCE_TYPE
case|:
comment|/* APPLE LOCAL radar 6035389 */
case|case
name|BLOCK_POINTER_TYPE
case|:
if|if
condition|(
name|integer_zerop
argument_list|(
name|expr
argument_list|)
condition|)
return|return
name|build_int_cst
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
return|;
comment|/* Convert to an unsigned integer of the correct width first, 	 and from there widen/truncate to the required type.  */
name|expr
operator|=
name|fold_build1
argument_list|(
name|CONVERT_EXPR
argument_list|,
name|lang_hooks
operator|.
name|types
operator|.
name|type_for_size
argument_list|(
name|POINTER_SIZE
argument_list|,
literal|0
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
return|return
name|fold_convert
argument_list|(
name|type
argument_list|,
name|expr
argument_list|)
return|;
case|case
name|INTEGER_TYPE
case|:
case|case
name|ENUMERAL_TYPE
case|:
case|case
name|BOOLEAN_TYPE
case|:
comment|/* If this is a logical operation, which just returns 0 or 1, we can 	 change the type of the expression.  */
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|ex_form
argument_list|)
operator|==
name|tcc_comparison
condition|)
block|{
name|expr
operator|=
name|copy_node
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
operator|=
name|type
expr_stmt|;
return|return
name|expr
return|;
block|}
comment|/* If we are widening the type, put in an explicit conversion. 	 Similarly if we are not changing the width.  After this, we know 	 we are truncating EXPR.  */
elseif|else
if|if
condition|(
name|outprec
operator|>=
name|inprec
condition|)
block|{
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|tem
decl_stmt|;
comment|/* If the precision of the EXPR's type is K bits and the 	     destination mode has more bits, and the sign is changing, 	     it is not safe to use a NOP_EXPR.  For example, suppose 	     that EXPR's type is a 3-bit unsigned integer type, the 	     TYPE is a 3-bit signed integer type, and the machine mode 	     for the types is 8-bit QImode.  In that case, the 	     conversion necessitates an explicit sign-extension.  In 	     the signed-to-unsigned case the high-order bits have to 	     be cleared.  */
if|if
condition|(
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|!=
name|GET_MODE_BITSIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
name|code
operator|=
name|CONVERT_EXPR
expr_stmt|;
else|else
name|code
operator|=
name|NOP_EXPR
expr_stmt|;
name|tem
operator|=
name|fold_unary
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
condition|)
return|return
name|tem
return|;
name|tem
operator|=
name|build1
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|expr
argument_list|)
expr_stmt|;
name|TREE_NO_WARNING
argument_list|(
name|tem
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|tem
return|;
block|}
comment|/* If TYPE is an enumeral type or a type with a precision less 	 than the number of bits in its mode, do the conversion to the 	 type corresponding to its mode, then do a nop conversion 	 to TYPE.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|||
name|outprec
operator|!=
name|GET_MODE_BITSIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
return|return
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|type
argument_list|,
name|convert
argument_list|(
name|lang_hooks
operator|.
name|types
operator|.
name|type_for_mode
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
argument_list|)
return|;
comment|/* Here detect when we can distribute the truncation down past some 	 arithmetic.  For example, if adding two longs and converting to an 	 int, we can equally well convert both to ints and then add. 	 For the operations handled here, such truncation distribution 	 is always safe. 	 It is desirable in these cases: 	 1) when truncating down to full-word from a larger size 	 2) when truncating takes no work. 	 3) when at least one operand of the arithmetic has been extended 	 (as by C's default conversions).  In this case we need two conversions 	 if we do the arithmetic as already requested, so we might as well 	 truncate both and then combine.  Perhaps that way we need only one.  	 Note that in general we cannot do the arithmetic in a type 	 shorter than the desired result of conversion, even if the operands 	 are both extended from a shorter type, because they might overflow 	 if combined in that type.  The exceptions to this--the times when 	 two narrow values can be combined in their narrow type even to 	 make a wider result--are handled by "shorten" in build_binary_op.  */
switch|switch
condition|(
name|ex_form
condition|)
block|{
case|case
name|RSHIFT_EXPR
case|:
comment|/* We can pass truncation down through right shifting 	     when the shift count is a nonpositive constant.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|tree_int_cst_sgn
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|<=
literal|0
condition|)
goto|goto
name|trunc1
goto|;
break|break;
case|case
name|LSHIFT_EXPR
case|:
comment|/* We can pass truncation down through left shifting 	     when the shift count is a nonnegative constant and 	     the target type is unsigned.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|tree_int_cst_sgn
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|>=
literal|0
operator|&&
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
comment|/* If shift count is less than the width of the truncated type, 		 really shift.  */
if|if
condition|(
name|tree_int_cst_lt
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|,
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
comment|/* In this case, shifting is like multiplication.  */
goto|goto
name|trunc1
goto|;
else|else
block|{
comment|/* If it is>= that width, result is zero. 		     Handling this with trunc1 would give the wrong result: 		     (int) ((long long) a<< 32) is well defined (as 0) 		     but (int) a<< 32 is undefined and would get a 		     warning.  */
name|tree
name|t
init|=
name|build_int_cst
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* If the original expression had side-effects, we must 		     preserve it.  */
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|expr
argument_list|)
condition|)
return|return
name|build2
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|type
argument_list|,
name|expr
argument_list|,
name|t
argument_list|)
return|;
else|else
return|return
name|t
return|;
block|}
block|}
break|break;
case|case
name|MAX_EXPR
case|:
case|case
name|MIN_EXPR
case|:
case|case
name|MULT_EXPR
case|:
block|{
name|tree
name|arg0
init|=
name|get_unwidened
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|tree
name|arg1
init|=
name|get_unwidened
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|,
name|type
argument_list|)
decl_stmt|;
comment|/* Don't distribute unless the output precision is at least as big 	       as the actual inputs.  Otherwise, the comparison of the 	       truncated values will be wrong.  */
if|if
condition|(
name|outprec
operator|>=
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|&&
name|outprec
operator|>=
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
comment|/* If signedness of arg0 and arg1 don't match, 		   we can't necessarily find a type to compare them in.  */
operator|&&
operator|(
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|==
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|)
condition|)
goto|goto
name|trunc1
goto|;
break|break;
block|}
case|case
name|PLUS_EXPR
case|:
case|case
name|MINUS_EXPR
case|:
case|case
name|BIT_AND_EXPR
case|:
case|case
name|BIT_IOR_EXPR
case|:
case|case
name|BIT_XOR_EXPR
case|:
name|trunc1
label|:
block|{
name|tree
name|arg0
init|=
name|get_unwidened
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|tree
name|arg1
init|=
name|get_unwidened
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|,
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|outprec
operator|>=
name|BITS_PER_WORD
operator|||
name|TRULY_NOOP_TRUNCATION
argument_list|(
name|outprec
argument_list|,
name|inprec
argument_list|)
operator|||
name|inprec
operator|>
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|||
name|inprec
operator|>
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Do the arithmetic in type TYPEX, 		   then convert result to TYPE.  */
name|tree
name|typex
init|=
name|type
decl_stmt|;
comment|/* Can't do arithmetic in enumeral types 		   so use an integer type that will hold the values.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|typex
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
name|typex
operator|=
name|lang_hooks
operator|.
name|types
operator|.
name|type_for_size
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|typex
argument_list|)
argument_list|,
name|TYPE_UNSIGNED
argument_list|(
name|typex
argument_list|)
argument_list|)
expr_stmt|;
comment|/* But now perhaps TYPEX is as wide as INPREC. 		   In that case, do nothing special here. 		   (Otherwise would recurse infinitely in convert.  */
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|typex
argument_list|)
operator|!=
name|inprec
condition|)
block|{
comment|/* Don't do unsigned arithmetic where signed was wanted, 		       or vice versa. 		       Exception: if both of the original operands were 		       unsigned then we can safely do the work as unsigned. 		       Exception: shift operations take their type solely 		       from the first argument. 		       Exception: the LSHIFT_EXPR case above requires that 		       we perform this operation unsigned lest we produce 		       signed-overflow undefinedness. 		       And we may need to do it as unsigned 		       if we truncate to the original size.  */
if|if
condition|(
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|||
operator|(
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|&&
operator|(
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|||
name|ex_form
operator|==
name|LSHIFT_EXPR
operator|||
name|ex_form
operator|==
name|RSHIFT_EXPR
operator|||
name|ex_form
operator|==
name|LROTATE_EXPR
operator|||
name|ex_form
operator|==
name|RROTATE_EXPR
operator|)
operator|)
operator|||
name|ex_form
operator|==
name|LSHIFT_EXPR
comment|/* If we have !flag_wrapv, and either ARG0 or 			   ARG1 is of a signed type, we have to do 			   PLUS_EXPR or MINUS_EXPR in an unsigned 			   type.  Otherwise, we would introduce 			   signed-overflow undefinedness.  */
operator|||
operator|(
operator|(
operator|!
name|TYPE_OVERFLOW_WRAPS
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|||
operator|!
name|TYPE_OVERFLOW_WRAPS
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
name|ex_form
operator|==
name|PLUS_EXPR
operator|||
name|ex_form
operator|==
name|MINUS_EXPR
operator|)
operator|)
condition|)
name|typex
operator|=
name|lang_hooks
operator|.
name|types
operator|.
name|unsigned_type
argument_list|(
name|typex
argument_list|)
expr_stmt|;
else|else
name|typex
operator|=
name|lang_hooks
operator|.
name|types
operator|.
name|signed_type
argument_list|(
name|typex
argument_list|)
expr_stmt|;
return|return
name|convert
argument_list|(
name|type
argument_list|,
name|fold_build2
argument_list|(
name|ex_form
argument_list|,
name|typex
argument_list|,
name|convert
argument_list|(
name|typex
argument_list|,
name|arg0
argument_list|)
argument_list|,
name|convert
argument_list|(
name|typex
argument_list|,
name|arg1
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
block|}
block|}
break|break;
case|case
name|NEGATE_EXPR
case|:
case|case
name|BIT_NOT_EXPR
case|:
comment|/* This is not correct for ABS_EXPR, 	     since we must test the sign before truncation.  */
block|{
name|tree
name|typex
decl_stmt|;
comment|/* Don't do unsigned arithmetic where signed was wanted, 	       or vice versa.  */
if|if
condition|(
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
name|typex
operator|=
name|lang_hooks
operator|.
name|types
operator|.
name|unsigned_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
else|else
name|typex
operator|=
name|lang_hooks
operator|.
name|types
operator|.
name|signed_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return
name|convert
argument_list|(
name|type
argument_list|,
name|fold_build1
argument_list|(
name|ex_form
argument_list|,
name|typex
argument_list|,
name|convert
argument_list|(
name|typex
argument_list|,
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
case|case
name|NOP_EXPR
case|:
comment|/* Don't introduce a 	     "can't convert between vector values of different size" error.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|VECTOR_TYPE
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|GET_MODE_SIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|)
condition|)
break|break;
comment|/* If truncating after truncating, might as well do all at once. 	     If truncating after extending, we may get rid of wasted work.  */
return|return
name|convert
argument_list|(
name|type
argument_list|,
name|get_unwidened
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|type
argument_list|)
argument_list|)
return|;
case|case
name|COND_EXPR
case|:
comment|/* It is sometimes worthwhile to push the narrowing down through 	     the conditional and never loses.  */
return|return
name|fold_build3
argument_list|(
name|COND_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|convert
argument_list|(
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|convert
argument_list|(
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|2
argument_list|)
argument_list|)
argument_list|)
return|;
default|default:
break|break;
block|}
return|return
name|build1
argument_list|(
name|CONVERT_EXPR
argument_list|,
name|type
argument_list|,
name|expr
argument_list|)
return|;
case|case
name|REAL_TYPE
case|:
return|return
name|build1
argument_list|(
name|FIX_TRUNC_EXPR
argument_list|,
name|type
argument_list|,
name|expr
argument_list|)
return|;
case|case
name|COMPLEX_TYPE
case|:
return|return
name|convert
argument_list|(
name|type
argument_list|,
name|fold_build1
argument_list|(
name|REALPART_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
argument_list|)
return|;
case|case
name|VECTOR_TYPE
case|:
if|if
condition|(
operator|!
name|tree_int_cst_equal
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"can't convert between vector values of different size"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
return|return
name|build1
argument_list|(
name|VIEW_CONVERT_EXPR
argument_list|,
name|type
argument_list|,
name|expr
argument_list|)
return|;
default|default:
name|error
argument_list|(
literal|"aggregate value used where an integer was expected"
argument_list|)
expr_stmt|;
return|return
name|convert
argument_list|(
name|type
argument_list|,
name|integer_zero_node
argument_list|)
return|;
block|}
end_switch

begin_comment
unit|}
comment|/* Convert EXPR to the complex type TYPE in the usual ways.  */
end_comment

begin_macro
unit|tree
name|convert_to_complex
argument_list|(
argument|tree type
argument_list|,
argument|tree expr
argument_list|)
end_macro

begin_block
block|{
name|tree
name|subtype
init|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|REAL_TYPE
case|:
case|case
name|INTEGER_TYPE
case|:
case|case
name|ENUMERAL_TYPE
case|:
case|case
name|BOOLEAN_TYPE
case|:
return|return
name|build2
argument_list|(
name|COMPLEX_EXPR
argument_list|,
name|type
argument_list|,
name|convert
argument_list|(
name|subtype
argument_list|,
name|expr
argument_list|)
argument_list|,
name|convert
argument_list|(
name|subtype
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|)
return|;
case|case
name|COMPLEX_TYPE
case|:
block|{
name|tree
name|elt_type
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|elt_type
argument_list|)
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|subtype
argument_list|)
condition|)
return|return
name|expr
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|COMPLEX_EXPR
condition|)
return|return
name|fold_build2
argument_list|(
name|COMPLEX_EXPR
argument_list|,
name|type
argument_list|,
name|convert
argument_list|(
name|subtype
argument_list|,
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|convert
argument_list|(
name|subtype
argument_list|,
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
return|;
else|else
block|{
name|expr
operator|=
name|save_expr
argument_list|(
name|expr
argument_list|)
expr_stmt|;
return|return
name|fold_build2
argument_list|(
name|COMPLEX_EXPR
argument_list|,
name|type
argument_list|,
name|convert
argument_list|(
name|subtype
argument_list|,
name|fold_build1
argument_list|(
name|REALPART_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
argument_list|)
argument_list|,
name|convert
argument_list|(
name|subtype
argument_list|,
name|fold_build1
argument_list|(
name|IMAGPART_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
block|}
case|case
name|POINTER_TYPE
case|:
case|case
name|REFERENCE_TYPE
case|:
name|error
argument_list|(
literal|"pointer value used where a complex was expected"
argument_list|)
expr_stmt|;
return|return
name|convert_to_complex
argument_list|(
name|type
argument_list|,
name|integer_zero_node
argument_list|)
return|;
default|default:
name|error
argument_list|(
literal|"aggregate value used where a complex was expected"
argument_list|)
expr_stmt|;
return|return
name|convert_to_complex
argument_list|(
name|type
argument_list|,
name|integer_zero_node
argument_list|)
return|;
block|}
block|}
end_block

begin_comment
comment|/* Convert EXPR to the vector type TYPE in the usual ways.  */
end_comment

begin_function
name|tree
name|convert_to_vector
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|expr
parameter_list|)
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|INTEGER_TYPE
case|:
case|case
name|VECTOR_TYPE
case|:
if|if
condition|(
operator|!
name|tree_int_cst_equal
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"can't convert between vector values of different size"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
return|return
name|build1
argument_list|(
name|VIEW_CONVERT_EXPR
argument_list|,
name|type
argument_list|,
name|expr
argument_list|)
return|;
default|default:
name|error
argument_list|(
literal|"can't convert value to a vector"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
end_function

end_unit

