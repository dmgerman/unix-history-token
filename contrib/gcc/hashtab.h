begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* An expandable hash tables datatype.      Copyright (C) 1999, 2000, 2002, 2003 Free Software Foundation, Inc.    Contributed by Vladimir Makarov (vmakarov@cygnus.com).  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* This package implements basic hash table functionality.  It is possible    to search for an entry, create an entry and destroy an entry.     Elements in the table are generic pointers.     The size of the table is not fixed; if the occupancy of the table    grows too high the hash table will be expanded.     The abstract data implementation is based on generalized Algorithm D    from Knuth's book "The art of computer programming".  Hash table is    expanded by creation of new hash table and transferring elements from    the old table to the new table.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__HASHTAB_H__
end_ifndef

begin_define
define|#
directive|define
name|__HASHTAB_H__
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef

begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
comment|/* __cplusplus */
include|#
directive|include
file|"ansidecl.h"
ifndef|#
directive|ifndef
name|GTY
define|#
directive|define
name|GTY
parameter_list|(
name|X
parameter_list|)
endif|#
directive|endif
comment|/* The type for a hash code.  */
typedef|typedef
name|unsigned
name|int
name|hashval_t
typedef|;
comment|/* Callback function pointer types.  */
comment|/* Calculate hash of a table entry.  */
typedef|typedef
name|hashval_t
argument_list|(
argument|*htab_hash
argument_list|)
name|PARAMS
argument_list|(
operator|(
specifier|const
name|void
operator|*
operator|)
argument_list|)
expr_stmt|;
comment|/* Compare a table entry with a possible entry.  The entry already in    the table always comes first, so the second element can be of a    different type (but in this case htab_find and htab_find_slot    cannot be used; instead the variants that accept a hash value    must be used).  */
typedef|typedef
name|int
argument_list|(
argument|*htab_eq
argument_list|)
name|PARAMS
argument_list|(
operator|(
specifier|const
name|void
operator|*
operator|,
specifier|const
name|void
operator|*
operator|)
argument_list|)
expr_stmt|;
comment|/* Cleanup function called whenever a live element is removed from    the hash table.  */
typedef|typedef
name|void
argument_list|(
argument|*htab_del
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
expr_stmt|;
comment|/* Function called by htab_traverse for each live element.  The first    arg is the slot of the element (which can be passed to htab_clear_slot    if desired), the second arg is the auxiliary pointer handed to    htab_traverse.  Return 1 to continue scan, 0 to stop.  */
typedef|typedef
name|int
argument_list|(
argument|*htab_trav
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
expr_stmt|;
comment|/* Memory-allocation function, with the same functionality as calloc().    Iff it returns NULL, the hash table implementation will pass an error    code back to the user, so if your code doesn't handle errors,    best if you use xcalloc instead.  */
typedef|typedef
name|PTR
argument_list|(
argument|*htab_alloc
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|size_t
operator|,
name|size_t
operator|)
argument_list|)
expr_stmt|;
comment|/* We also need a free() routine.  */
typedef|typedef
name|void
argument_list|(
argument|*htab_free
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|)
argument_list|)
expr_stmt|;
comment|/* Memory allocation and deallocation; variants which take an extra    argument.  */
typedef|typedef
name|PTR
argument_list|(
argument|*htab_alloc_with_arg
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|void
operator|*
operator|,
name|size_t
operator|,
name|size_t
operator|)
argument_list|)
expr_stmt|;
typedef|typedef
name|void
argument_list|(
argument|*htab_free_with_arg
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|void
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
expr_stmt|;
comment|/* Hash tables are of the following type.  The structure    (implementation) of this type is not needed for using the hash    tables.  All work with hash table should be executed only through    functions mentioned below.  The size of this structure is subject to    change.  */
name|struct
name|htab
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
block|{
comment|/* Pointer to hash function.  */
name|htab_hash
name|hash_f
decl_stmt|;
comment|/* Pointer to comparison function.  */
name|htab_eq
name|eq_f
decl_stmt|;
comment|/* Pointer to cleanup function.  */
name|htab_del
name|del_f
decl_stmt|;
comment|/* Table itself.  */
name|PTR
modifier|*
name|GTY
argument_list|(
operator|(
name|use_param
argument_list|(
literal|""
argument_list|)
operator|,
name|length
argument_list|(
literal|"%h.size"
argument_list|)
operator|)
argument_list|)
name|entries
decl_stmt|;
comment|/* Current size (in entries) of the hash table */
name|size_t
name|size
decl_stmt|;
comment|/* Current number of elements including also deleted elements */
name|size_t
name|n_elements
decl_stmt|;
comment|/* Current number of deleted elements in the table */
name|size_t
name|n_deleted
decl_stmt|;
comment|/* The following member is used for debugging. Its value is number      of all calls of `htab_find_slot' for the hash table. */
name|unsigned
name|int
name|searches
decl_stmt|;
comment|/* The following member is used for debugging.  Its value is number      of collisions fixed for time of work with the hash table. */
name|unsigned
name|int
name|collisions
decl_stmt|;
comment|/* Pointers to allocate/free functions.  */
name|htab_alloc
name|alloc_f
decl_stmt|;
name|htab_free
name|free_f
decl_stmt|;
comment|/* Alternate allocate/free functions, which take an extra argument.  */
name|PTR
name|GTY
argument_list|(
operator|(
name|skip
argument_list|(
literal|""
argument_list|)
operator|)
argument_list|)
name|alloc_arg
decl_stmt|;
name|htab_alloc_with_arg
name|alloc_with_arg_f
decl_stmt|;
name|htab_free_with_arg
name|free_with_arg_f
decl_stmt|;
block|}
empty_stmt|;
typedef|typedef
name|struct
name|htab
modifier|*
name|htab_t
typedef|;
comment|/* An enum saying whether we insert into the hash table or not.  */
enum|enum
name|insert_option
block|{
name|NO_INSERT
block|,
name|INSERT
block|}
enum|;
comment|/* The prototypes of the package functions. */
specifier|extern
name|htab_t
name|htab_create_alloc
name|PARAMS
argument_list|(
operator|(
name|size_t
operator|,
name|htab_hash
operator|,
name|htab_eq
operator|,
name|htab_del
operator|,
name|htab_alloc
operator|,
name|htab_free
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|htab_t
name|htab_create_alloc_ex
name|PARAMS
argument_list|(
operator|(
name|size_t
operator|,
name|htab_hash
operator|,
name|htab_eq
operator|,
name|htab_del
operator|,
name|PTR
operator|,
name|htab_alloc_with_arg
operator|,
name|htab_free_with_arg
operator|)
argument_list|)
decl_stmt|;
comment|/* Backward-compatibility functions.  */
specifier|extern
name|htab_t
name|htab_create
name|PARAMS
argument_list|(
operator|(
name|size_t
operator|,
name|htab_hash
operator|,
name|htab_eq
operator|,
name|htab_del
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|htab_t
name|htab_try_create
name|PARAMS
argument_list|(
operator|(
name|size_t
operator|,
name|htab_hash
operator|,
name|htab_eq
operator|,
name|htab_del
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|htab_set_functions_ex
name|PARAMS
argument_list|(
operator|(
name|htab_t
operator|,
name|htab_hash
operator|,
name|htab_eq
operator|,
name|htab_del
operator|,
name|PTR
operator|,
name|htab_alloc_with_arg
operator|,
name|htab_free_with_arg
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|htab_delete
name|PARAMS
argument_list|(
operator|(
name|htab_t
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|htab_empty
name|PARAMS
argument_list|(
operator|(
name|htab_t
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|PTR
name|htab_find
name|PARAMS
argument_list|(
operator|(
name|htab_t
operator|,
specifier|const
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|PTR
modifier|*
name|htab_find_slot
name|PARAMS
argument_list|(
operator|(
name|htab_t
operator|,
specifier|const
name|void
operator|*
operator|,
expr|enum
name|insert_option
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|PTR
name|htab_find_with_hash
name|PARAMS
argument_list|(
operator|(
name|htab_t
operator|,
specifier|const
name|void
operator|*
operator|,
name|hashval_t
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|PTR
modifier|*
name|htab_find_slot_with_hash
name|PARAMS
argument_list|(
operator|(
name|htab_t
operator|,
specifier|const
name|void
operator|*
operator|,
name|hashval_t
operator|,
expr|enum
name|insert_option
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|htab_clear_slot
name|PARAMS
argument_list|(
operator|(
name|htab_t
operator|,
name|void
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|htab_remove_elt
name|PARAMS
argument_list|(
operator|(
name|htab_t
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|htab_traverse
name|PARAMS
argument_list|(
operator|(
name|htab_t
operator|,
name|htab_trav
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|htab_traverse_noresize
name|PARAMS
argument_list|(
operator|(
name|htab_t
operator|,
name|htab_trav
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|size_t
name|htab_size
name|PARAMS
argument_list|(
operator|(
name|htab_t
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|size_t
name|htab_elements
name|PARAMS
argument_list|(
operator|(
name|htab_t
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|double
name|htab_collisions
name|PARAMS
argument_list|(
operator|(
name|htab_t
operator|)
argument_list|)
decl_stmt|;
comment|/* A hash function for pointers.  */
specifier|extern
name|htab_hash
name|htab_hash_pointer
decl_stmt|;
comment|/* An equality function for pointers.  */
specifier|extern
name|htab_eq
name|htab_eq_pointer
decl_stmt|;
comment|/* A hash function for null-terminated strings.  */
specifier|extern
name|hashval_t
name|htab_hash_string
name|PARAMS
argument_list|(
operator|(
specifier|const
name|PTR
operator|)
argument_list|)
decl_stmt|;
comment|/* An iterative hash function for arbitrary data.  */
specifier|extern
name|hashval_t
name|iterative_hash
name|PARAMS
argument_list|(
operator|(
specifier|const
name|PTR
operator|,
name|size_t
operator|,
name|hashval_t
operator|)
argument_list|)
decl_stmt|;
comment|/* Shorthand for hashing something with an intrinsic size.  */
define|#
directive|define
name|iterative_hash_object
parameter_list|(
name|OB
parameter_list|,
name|INIT
parameter_list|)
value|iterative_hash (&OB, sizeof (OB), INIT)
ifdef|#
directive|ifdef
name|__cplusplus
block|}
end_extern

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __cplusplus */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __HASHTAB_H */
end_comment

end_unit

