begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Pretty formatting of GENERIC trees in C syntax.    Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006     Free Software Foundation, Inc.    Adapted from c-pretty-print.c by Diego Novillo<dnovillo@redhat.com>  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"hashtab.h"
end_include

begin_include
include|#
directive|include
file|"tree-flow.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_include
include|#
directive|include
file|"tree-iterator.h"
end_include

begin_include
include|#
directive|include
file|"tree-chrec.h"
end_include

begin_include
include|#
directive|include
file|"tree-pass.h"
end_include

begin_comment
comment|/* Local functions, macros and variables.  */
end_comment

begin_function_decl
specifier|static
name|int
name|op_prio
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|op_symbol_1
parameter_list|(
name|enum
name|tree_code
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|op_symbol
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pretty_print_string
parameter_list|(
name|pretty_printer
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_call_name
parameter_list|(
name|pretty_printer
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|newline_and_indent
parameter_list|(
name|pretty_printer
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|maybe_init_pretty_print
parameter_list|(
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_declaration
parameter_list|(
name|pretty_printer
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_struct_decl
parameter_list|(
name|pretty_printer
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do_niy
parameter_list|(
name|pretty_printer
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_vops
parameter_list|(
name|pretty_printer
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_generic_bb_buff
parameter_list|(
name|pretty_printer
modifier|*
parameter_list|,
name|basic_block
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|INDENT
parameter_list|(
name|SPACE
parameter_list|)
value|do { \   int i; for (i = 0; i<SPACE; i++) pp_space (buffer); } while (0)
end_define

begin_define
define|#
directive|define
name|NIY
value|do_niy(buffer,node)
end_define

begin_define
define|#
directive|define
name|PRINT_FUNCTION_NAME
parameter_list|(
name|NODE
parameter_list|)
value|pp_printf             \   (buffer, "%s", TREE_CODE (NODE) == NOP_EXPR ?              \    lang_hooks.decl_printable_name (TREE_OPERAND (NODE, 0), 1) : \    lang_hooks.decl_printable_name (NODE, 1))
end_define

begin_decl_stmt
specifier|static
name|pretty_printer
name|buffer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|initialized
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Try to print something for an unknown tree code.  */
end_comment

begin_function
specifier|static
name|void
name|do_niy
parameter_list|(
name|pretty_printer
modifier|*
name|buffer
parameter_list|,
name|tree
name|node
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|len
decl_stmt|;
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"<<< Unknown tree: "
argument_list|)
expr_stmt|;
name|pp_string
argument_list|(
name|buffer
argument_list|,
name|tree_code_name
index|[
operator|(
name|int
operator|)
name|TREE_CODE
argument_list|(
name|node
argument_list|)
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|EXPR_P
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|len
operator|=
name|TREE_CODE_LENGTH
argument_list|(
name|TREE_CODE
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
block|{
name|newline_and_indent
argument_list|(
name|buffer
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
name|i
argument_list|)
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
block|}
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|">>>\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|debug_generic_expr
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|print_generic_expr
argument_list|(
name|stderr
argument_list|,
name|t
argument_list|,
name|TDF_VOPS
operator||
name|TDF_UID
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|debug_generic_stmt
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|print_generic_stmt
argument_list|(
name|stderr
argument_list|,
name|t
argument_list|,
name|TDF_VOPS
operator||
name|TDF_UID
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|debug_tree_chain
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
while|while
condition|(
name|t
condition|)
block|{
name|print_generic_expr
argument_list|(
name|stderr
argument_list|,
name|t
argument_list|,
name|TDF_VOPS
operator||
name|TDF_UID
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Prints declaration DECL to the FILE with details specified by FLAGS.  */
end_comment

begin_function
name|void
name|print_generic_decl
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|tree
name|decl
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|maybe_init_pretty_print
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|print_declaration
argument_list|(
operator|&
name|buffer
argument_list|,
name|decl
argument_list|,
literal|2
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|pp_write_text_to_stream
argument_list|(
operator|&
name|buffer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print tree T, and its successors, on file FILE.  FLAGS specifies details    to show in the dump.  See TDF_* in tree.h.  */
end_comment

begin_function
name|void
name|print_generic_stmt
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|tree
name|t
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|maybe_init_pretty_print
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
operator|&
name|buffer
argument_list|,
name|t
argument_list|,
literal|0
argument_list|,
name|flags
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|pp_flush
argument_list|(
operator|&
name|buffer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print tree T, and its successors, on file FILE.  FLAGS specifies details    to show in the dump.  See TDF_* in tree.h.  The output is indented by    INDENT spaces.  */
end_comment

begin_function
name|void
name|print_generic_stmt_indented
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|tree
name|t
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|indent
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|maybe_init_pretty_print
argument_list|(
name|file
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|indent
condition|;
name|i
operator|++
control|)
name|pp_space
argument_list|(
operator|&
name|buffer
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
operator|&
name|buffer
argument_list|,
name|t
argument_list|,
name|indent
argument_list|,
name|flags
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|pp_flush
argument_list|(
operator|&
name|buffer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print a single expression T on file FILE.  FLAGS specifies details to show    in the dump.  See TDF_* in tree.h.  */
end_comment

begin_function
name|void
name|print_generic_expr
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|tree
name|t
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|maybe_init_pretty_print
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
operator|&
name|buffer
argument_list|,
name|t
argument_list|,
literal|0
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dump the name of a _DECL node and its DECL_UID if TDF_UID is set    in FLAGS.  */
end_comment

begin_function
specifier|static
name|void
name|dump_decl_name
parameter_list|(
name|pretty_printer
modifier|*
name|buffer
parameter_list|,
name|tree
name|node
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|tree
name|t
init|=
name|node
decl_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|t
argument_list|)
condition|)
name|pp_tree_identifier
argument_list|(
name|buffer
argument_list|,
name|DECL_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|TDF_UID
operator|)
operator|||
name|DECL_NAME
argument_list|(
name|t
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|LABEL_DECL
operator|&&
name|LABEL_DECL_UID
argument_list|(
name|t
argument_list|)
operator|!=
operator|-
literal|1
condition|)
name|pp_printf
argument_list|(
name|buffer
argument_list|,
literal|"L."
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|LABEL_DECL_UID
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|char
name|c
init|=
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|CONST_DECL
condition|?
literal|'C'
else|:
literal|'D'
decl_stmt|;
name|pp_printf
argument_list|(
name|buffer
argument_list|,
literal|"%c.%u"
argument_list|,
name|c
argument_list|,
name|DECL_UID
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Like the above, but used for pretty printing function calls.  */
end_comment

begin_function
specifier|static
name|void
name|dump_function_name
parameter_list|(
name|pretty_printer
modifier|*
name|buffer
parameter_list|,
name|tree
name|node
parameter_list|)
block|{
if|if
condition|(
name|DECL_NAME
argument_list|(
name|node
argument_list|)
condition|)
name|PRINT_FUNCTION_NAME
argument_list|(
name|node
argument_list|)
expr_stmt|;
else|else
name|dump_decl_name
argument_list|(
name|buffer
argument_list|,
name|node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dump a function declaration.  NODE is the FUNCTION_TYPE.  BUFFER, SPC and    FLAGS are as in dump_generic_node.  */
end_comment

begin_function
specifier|static
name|void
name|dump_function_declaration
parameter_list|(
name|pretty_printer
modifier|*
name|buffer
parameter_list|,
name|tree
name|node
parameter_list|,
name|int
name|spc
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|bool
name|wrote_arg
init|=
name|false
decl_stmt|;
name|tree
name|arg
decl_stmt|;
name|pp_space
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|pp_character
argument_list|(
name|buffer
argument_list|,
literal|'('
argument_list|)
expr_stmt|;
comment|/* Print the argument types.  The last element in the list is a VOID_TYPE.      The following avoids printing the last element.  */
name|arg
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|node
argument_list|)
expr_stmt|;
while|while
condition|(
name|arg
operator|&&
name|TREE_CHAIN
argument_list|(
name|arg
argument_list|)
operator|&&
name|arg
operator|!=
name|error_mark_node
condition|)
block|{
name|wrote_arg
operator|=
name|true
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|TREE_VALUE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|arg
operator|=
name|TREE_CHAIN
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|arg
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
name|pp_character
argument_list|(
name|buffer
argument_list|,
literal|','
argument_list|)
expr_stmt|;
name|pp_space
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|wrote_arg
condition|)
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"void"
argument_list|)
expr_stmt|;
name|pp_character
argument_list|(
name|buffer
argument_list|,
literal|')'
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dump the domain associated with an array.  */
end_comment

begin_function
specifier|static
name|void
name|dump_array_domain
parameter_list|(
name|pretty_printer
modifier|*
name|buffer
parameter_list|,
name|tree
name|domain
parameter_list|,
name|int
name|spc
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|pp_character
argument_list|(
name|buffer
argument_list|,
literal|'['
argument_list|)
expr_stmt|;
if|if
condition|(
name|domain
condition|)
block|{
name|tree
name|min
init|=
name|TYPE_MIN_VALUE
argument_list|(
name|domain
argument_list|)
decl_stmt|;
name|tree
name|max
init|=
name|TYPE_MAX_VALUE
argument_list|(
name|domain
argument_list|)
decl_stmt|;
if|if
condition|(
name|min
operator|&&
name|max
operator|&&
name|integer_zerop
argument_list|(
name|min
argument_list|)
operator|&&
name|host_integerp
argument_list|(
name|max
argument_list|,
literal|0
argument_list|)
condition|)
name|pp_wide_integer
argument_list|(
name|buffer
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|max
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|min
condition|)
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|min
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|pp_character
argument_list|(
name|buffer
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|max
condition|)
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|max
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"<unknown>"
argument_list|)
expr_stmt|;
name|pp_character
argument_list|(
name|buffer
argument_list|,
literal|']'
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dump OpenMP clause CLAUSE.  BUFFER, CLAUSE, SPC and FLAGS are as in    dump_generic_node.  */
end_comment

begin_function
specifier|static
name|void
name|dump_omp_clause
parameter_list|(
name|pretty_printer
modifier|*
name|buffer
parameter_list|,
name|tree
name|clause
parameter_list|,
name|int
name|spc
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
switch|switch
condition|(
name|OMP_CLAUSE_CODE
argument_list|(
name|clause
argument_list|)
condition|)
block|{
case|case
name|OMP_CLAUSE_PRIVATE
case|:
name|name
operator|=
literal|"private"
expr_stmt|;
goto|goto
name|print_remap
goto|;
case|case
name|OMP_CLAUSE_SHARED
case|:
name|name
operator|=
literal|"shared"
expr_stmt|;
goto|goto
name|print_remap
goto|;
case|case
name|OMP_CLAUSE_FIRSTPRIVATE
case|:
name|name
operator|=
literal|"firstprivate"
expr_stmt|;
goto|goto
name|print_remap
goto|;
case|case
name|OMP_CLAUSE_LASTPRIVATE
case|:
name|name
operator|=
literal|"lastprivate"
expr_stmt|;
goto|goto
name|print_remap
goto|;
case|case
name|OMP_CLAUSE_COPYIN
case|:
name|name
operator|=
literal|"copyin"
expr_stmt|;
goto|goto
name|print_remap
goto|;
case|case
name|OMP_CLAUSE_COPYPRIVATE
case|:
name|name
operator|=
literal|"copyprivate"
expr_stmt|;
goto|goto
name|print_remap
goto|;
name|print_remap
label|:
name|pp_string
argument_list|(
name|buffer
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|pp_character
argument_list|(
name|buffer
argument_list|,
literal|'('
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|OMP_CLAUSE_DECL
argument_list|(
name|clause
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|pp_character
argument_list|(
name|buffer
argument_list|,
literal|')'
argument_list|)
expr_stmt|;
break|break;
case|case
name|OMP_CLAUSE_REDUCTION
case|:
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"reduction("
argument_list|)
expr_stmt|;
name|pp_string
argument_list|(
name|buffer
argument_list|,
name|op_symbol_1
argument_list|(
name|OMP_CLAUSE_REDUCTION_CODE
argument_list|(
name|clause
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|pp_character
argument_list|(
name|buffer
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|OMP_CLAUSE_DECL
argument_list|(
name|clause
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|pp_character
argument_list|(
name|buffer
argument_list|,
literal|')'
argument_list|)
expr_stmt|;
break|break;
case|case
name|OMP_CLAUSE_IF
case|:
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"if("
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|OMP_CLAUSE_IF_EXPR
argument_list|(
name|clause
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|pp_character
argument_list|(
name|buffer
argument_list|,
literal|')'
argument_list|)
expr_stmt|;
break|break;
case|case
name|OMP_CLAUSE_NUM_THREADS
case|:
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"num_threads("
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|OMP_CLAUSE_NUM_THREADS_EXPR
argument_list|(
name|clause
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|pp_character
argument_list|(
name|buffer
argument_list|,
literal|')'
argument_list|)
expr_stmt|;
break|break;
case|case
name|OMP_CLAUSE_NOWAIT
case|:
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"nowait"
argument_list|)
expr_stmt|;
break|break;
case|case
name|OMP_CLAUSE_ORDERED
case|:
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"ordered"
argument_list|)
expr_stmt|;
break|break;
case|case
name|OMP_CLAUSE_DEFAULT
case|:
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"default("
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|OMP_CLAUSE_DEFAULT_KIND
argument_list|(
name|clause
argument_list|)
condition|)
block|{
case|case
name|OMP_CLAUSE_DEFAULT_UNSPECIFIED
case|:
break|break;
case|case
name|OMP_CLAUSE_DEFAULT_SHARED
case|:
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"shared"
argument_list|)
expr_stmt|;
break|break;
case|case
name|OMP_CLAUSE_DEFAULT_NONE
case|:
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"none"
argument_list|)
expr_stmt|;
break|break;
case|case
name|OMP_CLAUSE_DEFAULT_PRIVATE
case|:
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"private"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|pp_character
argument_list|(
name|buffer
argument_list|,
literal|')'
argument_list|)
expr_stmt|;
break|break;
case|case
name|OMP_CLAUSE_SCHEDULE
case|:
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"schedule("
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|OMP_CLAUSE_SCHEDULE_KIND
argument_list|(
name|clause
argument_list|)
condition|)
block|{
case|case
name|OMP_CLAUSE_SCHEDULE_STATIC
case|:
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"static"
argument_list|)
expr_stmt|;
break|break;
case|case
name|OMP_CLAUSE_SCHEDULE_DYNAMIC
case|:
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"dynamic"
argument_list|)
expr_stmt|;
break|break;
case|case
name|OMP_CLAUSE_SCHEDULE_GUIDED
case|:
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"guided"
argument_list|)
expr_stmt|;
break|break;
case|case
name|OMP_CLAUSE_SCHEDULE_RUNTIME
case|:
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"runtime"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|OMP_CLAUSE_SCHEDULE_CHUNK_EXPR
argument_list|(
name|clause
argument_list|)
condition|)
block|{
name|pp_character
argument_list|(
name|buffer
argument_list|,
literal|','
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|OMP_CLAUSE_SCHEDULE_CHUNK_EXPR
argument_list|(
name|clause
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
name|pp_character
argument_list|(
name|buffer
argument_list|,
literal|')'
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Should never happen.  */
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|clause
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Dump the list of OpenMP clauses.  BUFFER, SPC and FLAGS are as in    dump_generic_node.  */
end_comment

begin_function
specifier|static
name|void
name|dump_omp_clauses
parameter_list|(
name|pretty_printer
modifier|*
name|buffer
parameter_list|,
name|tree
name|clause
parameter_list|,
name|int
name|spc
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
if|if
condition|(
name|clause
operator|==
name|NULL
condition|)
return|return;
name|pp_space
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|dump_omp_clause
argument_list|(
name|buffer
argument_list|,
name|clause
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|clause
operator|=
name|OMP_CLAUSE_CHAIN
argument_list|(
name|clause
argument_list|)
expr_stmt|;
if|if
condition|(
name|clause
operator|==
name|NULL
condition|)
return|return;
name|pp_space
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Dump the node NODE on the pretty_printer BUFFER, SPC spaces of indent.    FLAGS specifies details to show in the dump (see TDF_* in tree.h).  If    IS_STMT is true, the object printed is considered to be a statement    and it is terminated by ';' if appropriate.  */
end_comment

begin_function
name|int
name|dump_generic_node
parameter_list|(
name|pretty_printer
modifier|*
name|buffer
parameter_list|,
name|tree
name|node
parameter_list|,
name|int
name|spc
parameter_list|,
name|int
name|flags
parameter_list|,
name|bool
name|is_stmt
parameter_list|)
block|{
name|tree
name|type
decl_stmt|;
name|tree
name|op0
decl_stmt|,
name|op1
decl_stmt|;
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
name|bool
name|is_expr
decl_stmt|;
if|if
condition|(
name|node
operator|==
name|NULL_TREE
condition|)
return|return
name|spc
return|;
name|is_expr
operator|=
name|EXPR_P
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|node
argument_list|)
operator|!=
name|ERROR_MARK
operator|&&
name|is_gimple_stmt
argument_list|(
name|node
argument_list|)
operator|&&
operator|(
name|flags
operator|&
name|TDF_VOPS
operator|)
operator|&&
name|stmt_ann
argument_list|(
name|node
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|node
argument_list|)
operator|!=
name|PHI_NODE
condition|)
name|dump_vops
argument_list|(
name|buffer
argument_list|,
name|node
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_stmt
operator|&&
operator|(
name|flags
operator|&
name|TDF_STMTADDR
operator|)
condition|)
name|pp_printf
argument_list|(
name|buffer
argument_list|,
literal|"<&%p> "
argument_list|,
operator|(
name|void
operator|*
operator|)
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|TDF_LINENO
operator|)
operator|&&
name|EXPR_HAS_LOCATION
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|expanded_location
name|xloc
init|=
name|expand_location
argument_list|(
name|EXPR_LOCATION
argument_list|(
name|node
argument_list|)
argument_list|)
decl_stmt|;
name|pp_character
argument_list|(
name|buffer
argument_list|,
literal|'['
argument_list|)
expr_stmt|;
if|if
condition|(
name|xloc
operator|.
name|file
condition|)
block|{
name|pp_string
argument_list|(
name|buffer
argument_list|,
name|xloc
operator|.
name|file
argument_list|)
expr_stmt|;
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|" : "
argument_list|)
expr_stmt|;
block|}
name|pp_decimal_int
argument_list|(
name|buffer
argument_list|,
name|xloc
operator|.
name|line
argument_list|)
expr_stmt|;
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"] "
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|node
argument_list|)
condition|)
block|{
case|case
name|ERROR_MARK
case|:
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"<<< error>>>"
argument_list|)
expr_stmt|;
break|break;
case|case
name|IDENTIFIER_NODE
case|:
name|pp_tree_identifier
argument_list|(
name|buffer
argument_list|,
name|node
argument_list|)
expr_stmt|;
break|break;
case|case
name|TREE_LIST
case|:
while|while
condition|(
name|node
operator|&&
name|node
operator|!=
name|error_mark_node
condition|)
block|{
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|node
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|pp_space
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|TREE_VALUE
argument_list|(
name|node
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|node
operator|=
name|TREE_CHAIN
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|&&
name|TREE_CODE
argument_list|(
name|node
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
name|pp_character
argument_list|(
name|buffer
argument_list|,
literal|','
argument_list|)
expr_stmt|;
name|pp_space
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|TREE_BINFO
case|:
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|BINFO_TYPE
argument_list|(
name|node
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
case|case
name|TREE_VEC
case|:
block|{
name|size_t
name|i
decl_stmt|;
if|if
condition|(
name|TREE_VEC_LENGTH
argument_list|(
name|node
argument_list|)
operator|>
literal|0
condition|)
block|{
name|size_t
name|len
init|=
name|TREE_VEC_LENGTH
argument_list|(
name|node
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|TREE_VEC_ELT
argument_list|(
name|node
argument_list|,
name|i
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|pp_character
argument_list|(
name|buffer
argument_list|,
literal|','
argument_list|)
expr_stmt|;
name|pp_space
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|TREE_VEC_ELT
argument_list|(
name|node
argument_list|,
name|len
operator|-
literal|1
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|VOID_TYPE
case|:
case|case
name|INTEGER_TYPE
case|:
case|case
name|REAL_TYPE
case|:
case|case
name|COMPLEX_TYPE
case|:
case|case
name|VECTOR_TYPE
case|:
case|case
name|ENUMERAL_TYPE
case|:
case|case
name|BOOLEAN_TYPE
case|:
block|{
name|unsigned
name|int
name|quals
init|=
name|TYPE_QUALS
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|enum
name|tree_code_class
name|class
decl_stmt|;
if|if
condition|(
name|quals
operator|&
name|TYPE_QUAL_CONST
condition|)
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"const "
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|quals
operator|&
name|TYPE_QUAL_VOLATILE
condition|)
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"volatile "
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|quals
operator|&
name|TYPE_QUAL_RESTRICT
condition|)
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"restrict "
argument_list|)
expr_stmt|;
name|class
operator|=
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|class
operator|==
name|tcc_declaration
condition|)
block|{
if|if
condition|(
name|DECL_NAME
argument_list|(
name|node
argument_list|)
condition|)
name|dump_decl_name
argument_list|(
name|buffer
argument_list|,
name|node
argument_list|,
name|flags
argument_list|)
expr_stmt|;
else|else
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"<unnamed type decl>"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|class
operator|==
name|tcc_type
condition|)
block|{
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|node
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|node
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
name|pp_tree_identifier
argument_list|(
name|buffer
argument_list|,
name|TYPE_NAME
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|node
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|node
argument_list|)
argument_list|)
condition|)
name|dump_decl_name
argument_list|(
name|buffer
argument_list|,
name|TYPE_NAME
argument_list|(
name|node
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
else|else
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"<unnamed type>"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|node
argument_list|)
operator|==
name|VECTOR_TYPE
condition|)
block|{
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"vector "
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|TREE_TYPE
argument_list|(
name|node
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
else|else
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"<unnamed type>"
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|POINTER_TYPE
case|:
case|case
name|REFERENCE_TYPE
case|:
name|str
operator|=
operator|(
name|TREE_CODE
argument_list|(
name|node
argument_list|)
operator|==
name|POINTER_TYPE
condition|?
literal|"*"
else|:
literal|"&"
operator|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|node
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
name|tree
name|fnode
init|=
name|TREE_TYPE
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|TREE_TYPE
argument_list|(
name|fnode
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|pp_space
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|pp_character
argument_list|(
name|buffer
argument_list|,
literal|'('
argument_list|)
expr_stmt|;
name|pp_string
argument_list|(
name|buffer
argument_list|,
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|node
argument_list|)
operator|&&
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|node
argument_list|)
argument_list|)
condition|)
name|dump_decl_name
argument_list|(
name|buffer
argument_list|,
name|TYPE_NAME
argument_list|(
name|node
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
else|else
name|pp_printf
argument_list|(
name|buffer
argument_list|,
literal|"<T%x>"
argument_list|,
name|TYPE_UID
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|pp_character
argument_list|(
name|buffer
argument_list|,
literal|')'
argument_list|)
expr_stmt|;
name|dump_function_declaration
argument_list|(
name|buffer
argument_list|,
name|fnode
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|unsigned
name|int
name|quals
init|=
name|TYPE_QUALS
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|TREE_TYPE
argument_list|(
name|node
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|pp_space
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|pp_string
argument_list|(
name|buffer
argument_list|,
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|quals
operator|&
name|TYPE_QUAL_CONST
condition|)
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|" const"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|quals
operator|&
name|TYPE_QUAL_VOLATILE
condition|)
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"volatile"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|quals
operator|&
name|TYPE_QUAL_RESTRICT
condition|)
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|" restrict"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_REF_CAN_ALIAS_ALL
argument_list|(
name|node
argument_list|)
condition|)
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|" {ref-all}"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|OFFSET_TYPE
case|:
name|NIY
expr_stmt|;
break|break;
case|case
name|METHOD_TYPE
case|:
name|dump_decl_name
argument_list|(
name|buffer
argument_list|,
name|TYPE_NAME
argument_list|(
name|TYPE_METHOD_BASETYPE
argument_list|(
name|node
argument_list|)
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"::"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TARGET_MEM_REF
case|:
block|{
specifier|const
name|char
modifier|*
name|sep
init|=
literal|""
decl_stmt|;
name|tree
name|tmp
decl_stmt|;
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"MEM["
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|TMR_SYMBOL
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
condition|)
block|{
name|pp_string
argument_list|(
name|buffer
argument_list|,
name|sep
argument_list|)
expr_stmt|;
name|sep
operator|=
literal|", "
expr_stmt|;
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"symbol: "
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|tmp
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
name|tmp
operator|=
name|TMR_BASE
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
condition|)
block|{
name|pp_string
argument_list|(
name|buffer
argument_list|,
name|sep
argument_list|)
expr_stmt|;
name|sep
operator|=
literal|", "
expr_stmt|;
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"base: "
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|tmp
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
name|tmp
operator|=
name|TMR_INDEX
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
condition|)
block|{
name|pp_string
argument_list|(
name|buffer
argument_list|,
name|sep
argument_list|)
expr_stmt|;
name|sep
operator|=
literal|", "
expr_stmt|;
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"index: "
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|tmp
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
name|tmp
operator|=
name|TMR_STEP
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
condition|)
block|{
name|pp_string
argument_list|(
name|buffer
argument_list|,
name|sep
argument_list|)
expr_stmt|;
name|sep
operator|=
literal|", "
expr_stmt|;
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"step: "
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|tmp
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
name|tmp
operator|=
name|TMR_OFFSET
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
condition|)
block|{
name|pp_string
argument_list|(
name|buffer
argument_list|,
name|sep
argument_list|)
expr_stmt|;
name|sep
operator|=
literal|", "
expr_stmt|;
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"offset: "
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|tmp
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"]"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|TDF_DETAILS
condition|)
block|{
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"{"
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|TMR_ORIGINAL
argument_list|(
name|node
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"}"
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|ARRAY_TYPE
case|:
block|{
name|tree
name|tmp
decl_stmt|;
comment|/* Print the innermost component type.  */
for|for
control|(
name|tmp
operator|=
name|TREE_TYPE
argument_list|(
name|node
argument_list|)
init|;
name|TREE_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|ARRAY_TYPE
condition|;
name|tmp
operator|=
name|TREE_TYPE
argument_list|(
name|tmp
argument_list|)
control|)
empty_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|tmp
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
comment|/* Print the dimensions.  */
for|for
control|(
name|tmp
operator|=
name|node
init|;
name|TREE_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|ARRAY_TYPE
condition|;
name|tmp
operator|=
name|TREE_TYPE
argument_list|(
name|tmp
argument_list|)
control|)
name|dump_array_domain
argument_list|(
name|buffer
argument_list|,
name|TYPE_DOMAIN
argument_list|(
name|tmp
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
case|case
name|QUAL_UNION_TYPE
case|:
comment|/* Print the name of the structure.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|node
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"struct "
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|node
argument_list|)
operator|==
name|UNION_TYPE
condition|)
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"union "
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|node
argument_list|)
condition|)
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|TYPE_NAME
argument_list|(
name|node
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
else|else
name|print_struct_decl
argument_list|(
name|buffer
argument_list|,
name|node
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|LANG_TYPE
case|:
name|NIY
expr_stmt|;
break|break;
case|case
name|INTEGER_CST
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|node
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
block|{
comment|/* In the case of a pointer, one may want to divide by the 	     size of the pointed-to type.  Unfortunately, this not 	     straightforward.  The C front-end maps expressions  	     (int *) 5 	     int *p; (p + 5)  	     in such a way that the two INTEGER_CST nodes for "5" have 	     different values but identical types.  In the latter 	     case, the 5 is multiplied by sizeof (int) in c-common.c 	     (pointer_int_sum) to convert it to a byte address, and 	     yet the type of the node is left unchanged.  Argh.  What 	     is consistent though is that the number value corresponds 	     to bytes (UNITS) offset.               NB: Neither of the following divisors can be trivially              used to recover the original literal:               TREE_INT_CST_LOW (TYPE_SIZE_UNIT (TREE_TYPE (node))) 	     TYPE_PRECISION (TREE_TYPE (TREE_TYPE (node)))  */
name|pp_wide_integer
argument_list|(
name|buffer
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"B"
argument_list|)
expr_stmt|;
comment|/* pseudo-unit */
block|}
elseif|else
if|if
condition|(
operator|!
name|host_integerp
argument_list|(
name|node
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|tree
name|val
init|=
name|node
decl_stmt|;
if|if
condition|(
name|tree_int_cst_sgn
argument_list|(
name|val
argument_list|)
operator|<
literal|0
condition|)
block|{
name|pp_character
argument_list|(
name|buffer
argument_list|,
literal|'-'
argument_list|)
expr_stmt|;
name|val
operator|=
name|build_int_cst_wide
argument_list|(
name|NULL_TREE
argument_list|,
operator|-
name|TREE_INT_CST_LOW
argument_list|(
name|val
argument_list|)
argument_list|,
operator|~
name|TREE_INT_CST_HIGH
argument_list|(
name|val
argument_list|)
operator|+
operator|!
name|TREE_INT_CST_LOW
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Would "%x%0*x" or "%x%*0x" get zero-padding on all 	     systems?  */
block|{
specifier|static
name|char
name|format
index|[
literal|10
index|]
decl_stmt|;
comment|/* "%x%09999x\0" */
if|if
condition|(
operator|!
name|format
index|[
literal|0
index|]
condition|)
name|sprintf
argument_list|(
name|format
argument_list|,
literal|"%%x%%0%dx"
argument_list|,
name|HOST_BITS_PER_INT
operator|/
literal|4
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|pp_buffer
argument_list|(
name|buffer
argument_list|)
operator|->
name|digit_buffer
argument_list|,
name|format
argument_list|,
name|TREE_INT_CST_HIGH
argument_list|(
name|val
argument_list|)
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
name|pp_string
argument_list|(
name|buffer
argument_list|,
name|pp_buffer
argument_list|(
name|buffer
argument_list|)
operator|->
name|digit_buffer
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|pp_wide_integer
argument_list|(
name|buffer
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|REAL_CST
case|:
comment|/* Code copied from print_node.  */
block|{
name|REAL_VALUE_TYPE
name|d
decl_stmt|;
if|if
condition|(
name|TREE_OVERFLOW
argument_list|(
name|node
argument_list|)
condition|)
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|" overflow"
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|REAL_IS_NOT_DOUBLE
argument_list|)
operator|||
name|defined
argument_list|(
name|REAL_ARITHMETIC
argument_list|)
name|d
operator|=
name|TREE_REAL_CST
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|REAL_VALUE_ISINF
argument_list|(
name|d
argument_list|)
condition|)
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|" Inf"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|REAL_VALUE_ISNAN
argument_list|(
name|d
argument_list|)
condition|)
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|" Nan"
argument_list|)
expr_stmt|;
else|else
block|{
name|char
name|string
index|[
literal|100
index|]
decl_stmt|;
name|real_to_decimal
argument_list|(
name|string
argument_list|,
operator|&
name|d
argument_list|,
sizeof|sizeof
argument_list|(
name|string
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pp_string
argument_list|(
name|buffer
argument_list|,
name|string
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
block|{
name|HOST_WIDE_INT
name|i
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|TREE_REAL_CST
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"0x"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
name|TREE_REAL_CST
operator|(
name|node
operator|)
condition|;
name|i
operator|++
control|)
name|output_formatted_integer
argument_list|(
name|buffer
argument_list|,
literal|"%02x"
argument_list|,
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
break|break;
block|}
case|case
name|COMPLEX_CST
case|:
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"__complex__ ("
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|TREE_REALPART
argument_list|(
name|node
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|TREE_IMAGPART
argument_list|(
name|node
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|STRING_CST
case|:
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"\""
argument_list|)
expr_stmt|;
name|pretty_print_string
argument_list|(
name|buffer
argument_list|,
name|TREE_STRING_POINTER
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"\""
argument_list|)
expr_stmt|;
break|break;
case|case
name|VECTOR_CST
case|:
block|{
name|tree
name|elt
decl_stmt|;
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"{ "
argument_list|)
expr_stmt|;
for|for
control|(
name|elt
operator|=
name|TREE_VECTOR_CST_ELTS
argument_list|(
name|node
argument_list|)
init|;
name|elt
condition|;
name|elt
operator|=
name|TREE_CHAIN
argument_list|(
name|elt
argument_list|)
control|)
block|{
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|TREE_VALUE
argument_list|(
name|elt
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|elt
argument_list|)
condition|)
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
block|}
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|" }"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|FUNCTION_TYPE
case|:
break|break;
case|case
name|FUNCTION_DECL
case|:
case|case
name|CONST_DECL
case|:
name|dump_decl_name
argument_list|(
name|buffer
argument_list|,
name|node
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|LABEL_DECL
case|:
if|if
condition|(
name|DECL_NAME
argument_list|(
name|node
argument_list|)
condition|)
name|dump_decl_name
argument_list|(
name|buffer
argument_list|,
name|node
argument_list|,
name|flags
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|LABEL_DECL_UID
argument_list|(
name|node
argument_list|)
operator|!=
operator|-
literal|1
condition|)
name|pp_printf
argument_list|(
name|buffer
argument_list|,
literal|"<L"
name|HOST_WIDE_INT_PRINT_DEC
literal|">"
argument_list|,
name|LABEL_DECL_UID
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|pp_printf
argument_list|(
name|buffer
argument_list|,
literal|"<D%u>"
argument_list|,
name|DECL_UID
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_DECL
case|:
if|if
condition|(
name|DECL_IS_BUILTIN
argument_list|(
name|node
argument_list|)
condition|)
block|{
comment|/* Don't print the declaration of built-in types.  */
break|break;
block|}
if|if
condition|(
name|DECL_NAME
argument_list|(
name|node
argument_list|)
condition|)
name|dump_decl_name
argument_list|(
name|buffer
argument_list|,
name|node
argument_list|,
name|flags
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|node
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|node
argument_list|)
argument_list|)
operator|==
name|UNION_TYPE
operator|)
operator|&&
name|TYPE_METHODS
argument_list|(
name|TREE_TYPE
argument_list|(
name|node
argument_list|)
argument_list|)
condition|)
block|{
comment|/* The type is a c++ class: all structures have at least 		 4 methods.  */
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"class "
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|TREE_TYPE
argument_list|(
name|node
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pp_string
argument_list|(
name|buffer
argument_list|,
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|node
argument_list|)
argument_list|)
operator|==
name|UNION_TYPE
condition|?
literal|"union"
else|:
literal|"struct "
operator|)
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|TREE_TYPE
argument_list|(
name|node
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|SYMBOL_MEMORY_TAG
case|:
case|case
name|NAME_MEMORY_TAG
case|:
case|case
name|STRUCT_FIELD_TAG
case|:
case|case
name|VAR_DECL
case|:
case|case
name|PARM_DECL
case|:
case|case
name|FIELD_DECL
case|:
case|case
name|NAMESPACE_DECL
case|:
name|dump_decl_name
argument_list|(
name|buffer
argument_list|,
name|node
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|RESULT_DECL
case|:
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"<retval>"
argument_list|)
expr_stmt|;
break|break;
case|case
name|COMPONENT_REF
case|:
name|op0
operator|=
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|str
operator|=
literal|"."
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|INDIRECT_REF
condition|)
block|{
name|op0
operator|=
name|TREE_OPERAND
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|str
operator|=
literal|"->"
expr_stmt|;
block|}
if|if
condition|(
name|op_prio
argument_list|(
name|op0
argument_list|)
operator|<
name|op_prio
argument_list|(
name|node
argument_list|)
condition|)
name|pp_character
argument_list|(
name|buffer
argument_list|,
literal|'('
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|op0
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|op_prio
argument_list|(
name|op0
argument_list|)
operator|<
name|op_prio
argument_list|(
name|node
argument_list|)
condition|)
name|pp_character
argument_list|(
name|buffer
argument_list|,
literal|')'
argument_list|)
expr_stmt|;
name|pp_string
argument_list|(
name|buffer
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|1
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|VALUE_HANDLE
condition|)
block|{
name|op0
operator|=
name|component_ref_field_offset
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|op0
operator|&&
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
block|{
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"{off: "
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|op0
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|pp_character
argument_list|(
name|buffer
argument_list|,
literal|'}'
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|BIT_FIELD_REF
case|:
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"BIT_FIELD_REF<"
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|0
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|1
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|2
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|">"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARRAY_REF
case|:
case|case
name|ARRAY_RANGE_REF
case|:
name|op0
operator|=
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|op_prio
argument_list|(
name|op0
argument_list|)
operator|<
name|op_prio
argument_list|(
name|node
argument_list|)
condition|)
name|pp_character
argument_list|(
name|buffer
argument_list|,
literal|'('
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|op0
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|op_prio
argument_list|(
name|op0
argument_list|)
operator|<
name|op_prio
argument_list|(
name|node
argument_list|)
condition|)
name|pp_character
argument_list|(
name|buffer
argument_list|,
literal|')'
argument_list|)
expr_stmt|;
name|pp_character
argument_list|(
name|buffer
argument_list|,
literal|'['
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|1
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|node
argument_list|)
operator|==
name|ARRAY_RANGE_REF
condition|)
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|" ..."
argument_list|)
expr_stmt|;
name|pp_character
argument_list|(
name|buffer
argument_list|,
literal|']'
argument_list|)
expr_stmt|;
name|op0
operator|=
name|array_ref_low_bound
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|op1
operator|=
name|array_ref_element_size
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|integer_zerop
argument_list|(
name|op0
argument_list|)
operator|||
operator|(
name|TYPE_SIZE_UNIT
argument_list|(
name|TREE_TYPE
argument_list|(
name|node
argument_list|)
argument_list|)
operator|&&
operator|!
name|operand_equal_p
argument_list|(
name|op1
argument_list|,
name|TYPE_SIZE_UNIT
argument_list|(
name|TREE_TYPE
argument_list|(
name|node
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
block|{
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"{lb: "
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|op0
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|" sz: "
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|op1
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|pp_character
argument_list|(
name|buffer
argument_list|,
literal|'}'
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CONSTRUCTOR
case|:
block|{
name|unsigned
name|HOST_WIDE_INT
name|ix
decl_stmt|;
name|tree
name|field
decl_stmt|,
name|val
decl_stmt|;
name|bool
name|is_struct_init
init|=
name|FALSE
decl_stmt|;
name|pp_character
argument_list|(
name|buffer
argument_list|,
literal|'{'
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|node
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|node
argument_list|)
argument_list|)
operator|==
name|UNION_TYPE
condition|)
name|is_struct_init
operator|=
name|TRUE
expr_stmt|;
name|FOR_EACH_CONSTRUCTOR_ELT
argument_list|(
argument|CONSTRUCTOR_ELTS (node)
argument_list|,
argument|ix
argument_list|,
argument|field
argument_list|,
argument|val
argument_list|)
block|{
if|if
condition|(
name|field
operator|&&
name|is_struct_init
condition|)
block|{
name|pp_character
argument_list|(
name|buffer
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|field
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"="
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|&&
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|val
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|val
operator|=
name|TREE_OPERAND
argument_list|(
name|val
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&&
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|dump_decl_name
argument_list|(
name|buffer
argument_list|,
name|val
argument_list|,
name|flags
argument_list|)
expr_stmt|;
else|else
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|val
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|ix
operator|!=
name|VEC_length
argument_list|(
name|constructor_elt
argument_list|,
name|CONSTRUCTOR_ELTS
argument_list|(
name|node
argument_list|)
argument_list|)
operator|-
literal|1
condition|)
block|{
name|pp_character
argument_list|(
name|buffer
argument_list|,
literal|','
argument_list|)
expr_stmt|;
name|pp_space
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
block|}
name|pp_character
argument_list|(
name|buffer
argument_list|,
literal|'}'
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|COMPOUND_EXPR
case|:
block|{
name|tree
modifier|*
name|tp
decl_stmt|;
if|if
condition|(
name|flags
operator|&
name|TDF_SLIM
condition|)
block|{
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"<COMPOUND_EXPR>"
argument_list|)
expr_stmt|;
break|break;
block|}
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|0
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
operator|!
operator|(
name|flags
operator|&
name|TDF_SLIM
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|TDF_SLIM
condition|)
name|newline_and_indent
argument_list|(
name|buffer
argument_list|,
name|spc
argument_list|)
expr_stmt|;
else|else
block|{
name|pp_character
argument_list|(
name|buffer
argument_list|,
literal|','
argument_list|)
expr_stmt|;
name|pp_space
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|tp
operator|=
operator|&
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|1
argument_list|)
init|;
name|TREE_CODE
argument_list|(
operator|*
name|tp
argument_list|)
operator|==
name|COMPOUND_EXPR
condition|;
name|tp
operator|=
operator|&
name|TREE_OPERAND
argument_list|(
operator|*
name|tp
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|TREE_OPERAND
argument_list|(
operator|*
name|tp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
operator|!
operator|(
name|flags
operator|&
name|TDF_SLIM
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|TDF_SLIM
condition|)
name|newline_and_indent
argument_list|(
name|buffer
argument_list|,
name|spc
argument_list|)
expr_stmt|;
else|else
block|{
name|pp_character
argument_list|(
name|buffer
argument_list|,
literal|','
argument_list|)
expr_stmt|;
name|pp_space
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
block|}
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
operator|*
name|tp
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
operator|!
operator|(
name|flags
operator|&
name|TDF_SLIM
operator|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|STATEMENT_LIST
case|:
block|{
name|tree_stmt_iterator
name|si
decl_stmt|;
name|bool
name|first
init|=
name|true
decl_stmt|;
if|if
condition|(
name|flags
operator|&
name|TDF_SLIM
condition|)
block|{
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"<STATEMENT_LIST>"
argument_list|)
expr_stmt|;
break|break;
block|}
for|for
control|(
name|si
operator|=
name|tsi_start
argument_list|(
name|node
argument_list|)
init|;
operator|!
name|tsi_end_p
argument_list|(
name|si
argument_list|)
condition|;
name|tsi_next
argument_list|(
operator|&
name|si
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|first
condition|)
name|newline_and_indent
argument_list|(
name|buffer
argument_list|,
name|spc
argument_list|)
expr_stmt|;
else|else
name|first
operator|=
name|false
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|tsi_stmt
argument_list|(
name|si
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|MODIFY_EXPR
case|:
case|case
name|INIT_EXPR
case|:
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|0
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|pp_space
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|pp_character
argument_list|(
name|buffer
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
name|pp_space
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|1
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
break|break;
case|case
name|TARGET_EXPR
case|:
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"TARGET_EXPR<"
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|TARGET_EXPR_SLOT
argument_list|(
name|node
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|pp_character
argument_list|(
name|buffer
argument_list|,
literal|','
argument_list|)
expr_stmt|;
name|pp_space
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|TARGET_EXPR_INITIAL
argument_list|(
name|node
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|pp_character
argument_list|(
name|buffer
argument_list|,
literal|'>'
argument_list|)
expr_stmt|;
break|break;
case|case
name|DECL_EXPR
case|:
name|print_declaration
argument_list|(
name|buffer
argument_list|,
name|DECL_EXPR_DECL
argument_list|(
name|node
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|is_stmt
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|COND_EXPR
case|:
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|node
argument_list|)
operator|==
name|NULL
operator|||
name|TREE_TYPE
argument_list|(
name|node
argument_list|)
operator|==
name|void_type_node
condition|)
block|{
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"if ("
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|COND_EXPR_COND
argument_list|(
name|node
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|pp_character
argument_list|(
name|buffer
argument_list|,
literal|')'
argument_list|)
expr_stmt|;
comment|/* The lowered cond_exprs should always be printed in full.  */
if|if
condition|(
name|COND_EXPR_THEN
argument_list|(
name|node
argument_list|)
operator|&&
operator|(
name|IS_EMPTY_STMT
argument_list|(
name|COND_EXPR_THEN
argument_list|(
name|node
argument_list|)
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|COND_EXPR_THEN
argument_list|(
name|node
argument_list|)
argument_list|)
operator|==
name|GOTO_EXPR
operator|)
operator|&&
name|COND_EXPR_ELSE
argument_list|(
name|node
argument_list|)
operator|&&
operator|(
name|IS_EMPTY_STMT
argument_list|(
name|COND_EXPR_ELSE
argument_list|(
name|node
argument_list|)
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|COND_EXPR_ELSE
argument_list|(
name|node
argument_list|)
argument_list|)
operator|==
name|GOTO_EXPR
operator|)
condition|)
block|{
name|pp_space
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|COND_EXPR_THEN
argument_list|(
name|node
argument_list|)
argument_list|,
literal|0
argument_list|,
name|flags
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|" else "
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|COND_EXPR_ELSE
argument_list|(
name|node
argument_list|)
argument_list|,
literal|0
argument_list|,
name|flags
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|TDF_SLIM
operator|)
condition|)
block|{
comment|/* Output COND_EXPR_THEN.  */
if|if
condition|(
name|COND_EXPR_THEN
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|newline_and_indent
argument_list|(
name|buffer
argument_list|,
name|spc
operator|+
literal|2
argument_list|)
expr_stmt|;
name|pp_character
argument_list|(
name|buffer
argument_list|,
literal|'{'
argument_list|)
expr_stmt|;
name|newline_and_indent
argument_list|(
name|buffer
argument_list|,
name|spc
operator|+
literal|4
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|COND_EXPR_THEN
argument_list|(
name|node
argument_list|)
argument_list|,
name|spc
operator|+
literal|4
argument_list|,
name|flags
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|newline_and_indent
argument_list|(
name|buffer
argument_list|,
name|spc
operator|+
literal|2
argument_list|)
expr_stmt|;
name|pp_character
argument_list|(
name|buffer
argument_list|,
literal|'}'
argument_list|)
expr_stmt|;
block|}
comment|/* Output COND_EXPR_ELSE.  */
if|if
condition|(
name|COND_EXPR_ELSE
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|newline_and_indent
argument_list|(
name|buffer
argument_list|,
name|spc
argument_list|)
expr_stmt|;
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"else"
argument_list|)
expr_stmt|;
name|newline_and_indent
argument_list|(
name|buffer
argument_list|,
name|spc
operator|+
literal|2
argument_list|)
expr_stmt|;
name|pp_character
argument_list|(
name|buffer
argument_list|,
literal|'{'
argument_list|)
expr_stmt|;
name|newline_and_indent
argument_list|(
name|buffer
argument_list|,
name|spc
operator|+
literal|4
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|COND_EXPR_ELSE
argument_list|(
name|node
argument_list|)
argument_list|,
name|spc
operator|+
literal|4
argument_list|,
name|flags
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|newline_and_indent
argument_list|(
name|buffer
argument_list|,
name|spc
operator|+
literal|2
argument_list|)
expr_stmt|;
name|pp_character
argument_list|(
name|buffer
argument_list|,
literal|'}'
argument_list|)
expr_stmt|;
block|}
block|}
name|is_expr
operator|=
name|false
expr_stmt|;
block|}
else|else
block|{
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|0
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|pp_space
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|pp_character
argument_list|(
name|buffer
argument_list|,
literal|'?'
argument_list|)
expr_stmt|;
name|pp_space
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|1
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|pp_space
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|pp_character
argument_list|(
name|buffer
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
name|pp_space
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|2
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|BIND_EXPR
case|:
name|pp_character
argument_list|(
name|buffer
argument_list|,
literal|'{'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|TDF_SLIM
operator|)
condition|)
block|{
if|if
condition|(
name|BIND_EXPR_VARS
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|pp_newline
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
for|for
control|(
name|op0
operator|=
name|BIND_EXPR_VARS
argument_list|(
name|node
argument_list|)
init|;
name|op0
condition|;
name|op0
operator|=
name|TREE_CHAIN
argument_list|(
name|op0
argument_list|)
control|)
block|{
name|print_declaration
argument_list|(
name|buffer
argument_list|,
name|op0
argument_list|,
name|spc
operator|+
literal|2
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|pp_newline
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
block|}
name|newline_and_indent
argument_list|(
name|buffer
argument_list|,
name|spc
operator|+
literal|2
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|BIND_EXPR_BODY
argument_list|(
name|node
argument_list|)
argument_list|,
name|spc
operator|+
literal|2
argument_list|,
name|flags
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|newline_and_indent
argument_list|(
name|buffer
argument_list|,
name|spc
argument_list|)
expr_stmt|;
name|pp_character
argument_list|(
name|buffer
argument_list|,
literal|'}'
argument_list|)
expr_stmt|;
block|}
name|is_expr
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|CALL_EXPR
case|:
name|print_call_name
argument_list|(
name|buffer
argument_list|,
name|node
argument_list|)
expr_stmt|;
comment|/* Print parameters.  */
name|pp_space
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|pp_character
argument_list|(
name|buffer
argument_list|,
literal|'('
argument_list|)
expr_stmt|;
name|op1
operator|=
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|op1
condition|)
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|op1
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|pp_character
argument_list|(
name|buffer
argument_list|,
literal|')'
argument_list|)
expr_stmt|;
name|op1
operator|=
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|op1
condition|)
block|{
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|" [static-chain: "
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|op1
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|pp_character
argument_list|(
name|buffer
argument_list|,
literal|']'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|CALL_EXPR_RETURN_SLOT_OPT
argument_list|(
name|node
argument_list|)
condition|)
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|" [return slot optimization]"
argument_list|)
expr_stmt|;
if|if
condition|(
name|CALL_EXPR_TAILCALL
argument_list|(
name|node
argument_list|)
condition|)
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|" [tail call]"
argument_list|)
expr_stmt|;
break|break;
case|case
name|WITH_CLEANUP_EXPR
case|:
name|NIY
expr_stmt|;
break|break;
case|case
name|CLEANUP_POINT_EXPR
case|:
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"<<cleanup_point "
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|0
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|">>"
argument_list|)
expr_stmt|;
break|break;
case|case
name|PLACEHOLDER_EXPR
case|:
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"<PLACEHOLDER_EXPR "
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|TREE_TYPE
argument_list|(
name|node
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|pp_character
argument_list|(
name|buffer
argument_list|,
literal|'>'
argument_list|)
expr_stmt|;
break|break;
comment|/* Binary arithmetic and logic expressions.  */
case|case
name|WIDEN_SUM_EXPR
case|:
case|case
name|WIDEN_MULT_EXPR
case|:
case|case
name|MULT_EXPR
case|:
case|case
name|PLUS_EXPR
case|:
case|case
name|MINUS_EXPR
case|:
case|case
name|TRUNC_DIV_EXPR
case|:
case|case
name|CEIL_DIV_EXPR
case|:
case|case
name|FLOOR_DIV_EXPR
case|:
case|case
name|ROUND_DIV_EXPR
case|:
case|case
name|TRUNC_MOD_EXPR
case|:
case|case
name|CEIL_MOD_EXPR
case|:
case|case
name|FLOOR_MOD_EXPR
case|:
case|case
name|ROUND_MOD_EXPR
case|:
case|case
name|RDIV_EXPR
case|:
case|case
name|EXACT_DIV_EXPR
case|:
case|case
name|LSHIFT_EXPR
case|:
case|case
name|RSHIFT_EXPR
case|:
case|case
name|LROTATE_EXPR
case|:
case|case
name|RROTATE_EXPR
case|:
case|case
name|VEC_LSHIFT_EXPR
case|:
case|case
name|VEC_RSHIFT_EXPR
case|:
case|case
name|BIT_IOR_EXPR
case|:
case|case
name|BIT_XOR_EXPR
case|:
case|case
name|BIT_AND_EXPR
case|:
case|case
name|TRUTH_ANDIF_EXPR
case|:
case|case
name|TRUTH_ORIF_EXPR
case|:
case|case
name|TRUTH_AND_EXPR
case|:
case|case
name|TRUTH_OR_EXPR
case|:
case|case
name|TRUTH_XOR_EXPR
case|:
case|case
name|LT_EXPR
case|:
case|case
name|LE_EXPR
case|:
case|case
name|GT_EXPR
case|:
case|case
name|GE_EXPR
case|:
case|case
name|EQ_EXPR
case|:
case|case
name|NE_EXPR
case|:
case|case
name|UNLT_EXPR
case|:
case|case
name|UNLE_EXPR
case|:
case|case
name|UNGT_EXPR
case|:
case|case
name|UNGE_EXPR
case|:
case|case
name|UNEQ_EXPR
case|:
case|case
name|LTGT_EXPR
case|:
case|case
name|ORDERED_EXPR
case|:
case|case
name|UNORDERED_EXPR
case|:
block|{
specifier|const
name|char
modifier|*
name|op
init|=
name|op_symbol
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|op0
operator|=
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* When the operands are expressions with less priority, 	   keep semantics of the tree representation.  */
if|if
condition|(
name|op_prio
argument_list|(
name|op0
argument_list|)
operator|<
name|op_prio
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|pp_character
argument_list|(
name|buffer
argument_list|,
literal|'('
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|op0
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|pp_character
argument_list|(
name|buffer
argument_list|,
literal|')'
argument_list|)
expr_stmt|;
block|}
else|else
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|op0
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|pp_space
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|pp_string
argument_list|(
name|buffer
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|pp_space
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
comment|/* When the operands are expressions with less priority, 	   keep semantics of the tree representation.  */
if|if
condition|(
name|op_prio
argument_list|(
name|op1
argument_list|)
operator|<
name|op_prio
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|pp_character
argument_list|(
name|buffer
argument_list|,
literal|'('
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|op1
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|pp_character
argument_list|(
name|buffer
argument_list|,
literal|')'
argument_list|)
expr_stmt|;
block|}
else|else
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|op1
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* Unary arithmetic and logic expressions.  */
case|case
name|NEGATE_EXPR
case|:
case|case
name|BIT_NOT_EXPR
case|:
case|case
name|TRUTH_NOT_EXPR
case|:
case|case
name|ADDR_EXPR
case|:
case|case
name|PREDECREMENT_EXPR
case|:
case|case
name|PREINCREMENT_EXPR
case|:
case|case
name|ALIGN_INDIRECT_REF
case|:
case|case
name|MISALIGNED_INDIRECT_REF
case|:
case|case
name|INDIRECT_REF
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|node
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|STRING_CST
operator|||
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
operator|)
condition|)
empty_stmt|;
comment|/* Do not output '&' for strings and function pointers.  */
else|else
name|pp_string
argument_list|(
name|buffer
argument_list|,
name|op_symbol
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|op_prio
argument_list|(
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|<
name|op_prio
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|pp_character
argument_list|(
name|buffer
argument_list|,
literal|'('
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|0
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|pp_character
argument_list|(
name|buffer
argument_list|,
literal|')'
argument_list|)
expr_stmt|;
block|}
else|else
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|0
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|node
argument_list|)
operator|==
name|MISALIGNED_INDIRECT_REF
condition|)
block|{
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"{misalignment: "
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|1
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|pp_character
argument_list|(
name|buffer
argument_list|,
literal|'}'
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|POSTDECREMENT_EXPR
case|:
case|case
name|POSTINCREMENT_EXPR
case|:
if|if
condition|(
name|op_prio
argument_list|(
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|<
name|op_prio
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|pp_character
argument_list|(
name|buffer
argument_list|,
literal|'('
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|0
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|pp_character
argument_list|(
name|buffer
argument_list|,
literal|')'
argument_list|)
expr_stmt|;
block|}
else|else
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|0
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|pp_string
argument_list|(
name|buffer
argument_list|,
name|op_symbol
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|MIN_EXPR
case|:
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"MIN_EXPR<"
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|0
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|1
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|pp_character
argument_list|(
name|buffer
argument_list|,
literal|'>'
argument_list|)
expr_stmt|;
break|break;
case|case
name|MAX_EXPR
case|:
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"MAX_EXPR<"
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|0
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|1
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|pp_character
argument_list|(
name|buffer
argument_list|,
literal|'>'
argument_list|)
expr_stmt|;
break|break;
case|case
name|ABS_EXPR
case|:
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"ABS_EXPR<"
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|0
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|pp_character
argument_list|(
name|buffer
argument_list|,
literal|'>'
argument_list|)
expr_stmt|;
break|break;
case|case
name|RANGE_EXPR
case|:
name|NIY
expr_stmt|;
break|break;
case|case
name|FIX_TRUNC_EXPR
case|:
case|case
name|FIX_CEIL_EXPR
case|:
case|case
name|FIX_FLOOR_EXPR
case|:
case|case
name|FIX_ROUND_EXPR
case|:
case|case
name|FLOAT_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
case|case
name|NOP_EXPR
case|:
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|op0
operator|=
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
condition|)
block|{
name|pp_character
argument_list|(
name|buffer
argument_list|,
literal|'('
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|type
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|") "
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|op_prio
argument_list|(
name|op0
argument_list|)
operator|<
name|op_prio
argument_list|(
name|node
argument_list|)
condition|)
name|pp_character
argument_list|(
name|buffer
argument_list|,
literal|'('
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|op0
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|op_prio
argument_list|(
name|op0
argument_list|)
operator|<
name|op_prio
argument_list|(
name|node
argument_list|)
condition|)
name|pp_character
argument_list|(
name|buffer
argument_list|,
literal|')'
argument_list|)
expr_stmt|;
break|break;
case|case
name|VIEW_CONVERT_EXPR
case|:
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"VIEW_CONVERT_EXPR<"
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|TREE_TYPE
argument_list|(
name|node
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|">("
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|0
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|pp_character
argument_list|(
name|buffer
argument_list|,
literal|')'
argument_list|)
expr_stmt|;
break|break;
case|case
name|NON_LVALUE_EXPR
case|:
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"NON_LVALUE_EXPR<"
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|0
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|pp_character
argument_list|(
name|buffer
argument_list|,
literal|'>'
argument_list|)
expr_stmt|;
break|break;
case|case
name|SAVE_EXPR
case|:
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"SAVE_EXPR<"
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|0
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|pp_character
argument_list|(
name|buffer
argument_list|,
literal|'>'
argument_list|)
expr_stmt|;
break|break;
case|case
name|COMPLEX_EXPR
case|:
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"COMPLEX_EXPR<"
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|0
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|1
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|">"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONJ_EXPR
case|:
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"CONJ_EXPR<"
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|0
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|">"
argument_list|)
expr_stmt|;
break|break;
case|case
name|REALPART_EXPR
case|:
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"REALPART_EXPR<"
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|0
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|">"
argument_list|)
expr_stmt|;
break|break;
case|case
name|IMAGPART_EXPR
case|:
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"IMAGPART_EXPR<"
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|0
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|">"
argument_list|)
expr_stmt|;
break|break;
case|case
name|VA_ARG_EXPR
case|:
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"VA_ARG_EXPR<"
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|0
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|">"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TRY_FINALLY_EXPR
case|:
case|case
name|TRY_CATCH_EXPR
case|:
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"try"
argument_list|)
expr_stmt|;
name|newline_and_indent
argument_list|(
name|buffer
argument_list|,
name|spc
operator|+
literal|2
argument_list|)
expr_stmt|;
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"{"
argument_list|)
expr_stmt|;
name|newline_and_indent
argument_list|(
name|buffer
argument_list|,
name|spc
operator|+
literal|4
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|0
argument_list|)
argument_list|,
name|spc
operator|+
literal|4
argument_list|,
name|flags
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|newline_and_indent
argument_list|(
name|buffer
argument_list|,
name|spc
operator|+
literal|2
argument_list|)
expr_stmt|;
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"}"
argument_list|)
expr_stmt|;
name|newline_and_indent
argument_list|(
name|buffer
argument_list|,
name|spc
argument_list|)
expr_stmt|;
name|pp_string
argument_list|(
name|buffer
argument_list|,
operator|(
name|TREE_CODE
argument_list|(
name|node
argument_list|)
operator|==
name|TRY_CATCH_EXPR
operator|)
condition|?
literal|"catch"
else|:
literal|"finally"
argument_list|)
expr_stmt|;
name|newline_and_indent
argument_list|(
name|buffer
argument_list|,
name|spc
operator|+
literal|2
argument_list|)
expr_stmt|;
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"{"
argument_list|)
expr_stmt|;
name|newline_and_indent
argument_list|(
name|buffer
argument_list|,
name|spc
operator|+
literal|4
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|1
argument_list|)
argument_list|,
name|spc
operator|+
literal|4
argument_list|,
name|flags
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|newline_and_indent
argument_list|(
name|buffer
argument_list|,
name|spc
operator|+
literal|2
argument_list|)
expr_stmt|;
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"}"
argument_list|)
expr_stmt|;
name|is_expr
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|CATCH_EXPR
case|:
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"catch ("
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|CATCH_TYPES
argument_list|(
name|node
argument_list|)
argument_list|,
name|spc
operator|+
literal|2
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
name|newline_and_indent
argument_list|(
name|buffer
argument_list|,
name|spc
operator|+
literal|2
argument_list|)
expr_stmt|;
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"{"
argument_list|)
expr_stmt|;
name|newline_and_indent
argument_list|(
name|buffer
argument_list|,
name|spc
operator|+
literal|4
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|CATCH_BODY
argument_list|(
name|node
argument_list|)
argument_list|,
name|spc
operator|+
literal|4
argument_list|,
name|flags
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|newline_and_indent
argument_list|(
name|buffer
argument_list|,
name|spc
operator|+
literal|2
argument_list|)
expr_stmt|;
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"}"
argument_list|)
expr_stmt|;
name|is_expr
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|EH_FILTER_EXPR
case|:
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"<<<eh_filter ("
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|EH_FILTER_TYPES
argument_list|(
name|node
argument_list|)
argument_list|,
name|spc
operator|+
literal|2
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|")>>>"
argument_list|)
expr_stmt|;
name|newline_and_indent
argument_list|(
name|buffer
argument_list|,
name|spc
operator|+
literal|2
argument_list|)
expr_stmt|;
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"{"
argument_list|)
expr_stmt|;
name|newline_and_indent
argument_list|(
name|buffer
argument_list|,
name|spc
operator|+
literal|4
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|EH_FILTER_FAILURE
argument_list|(
name|node
argument_list|)
argument_list|,
name|spc
operator|+
literal|4
argument_list|,
name|flags
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|newline_and_indent
argument_list|(
name|buffer
argument_list|,
name|spc
operator|+
literal|2
argument_list|)
expr_stmt|;
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"}"
argument_list|)
expr_stmt|;
name|is_expr
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|CHANGE_DYNAMIC_TYPE_EXPR
case|:
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"<<<change_dynamic_type ("
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|CHANGE_DYNAMIC_TYPE_NEW_TYPE
argument_list|(
name|node
argument_list|)
argument_list|,
name|spc
operator|+
literal|2
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|") "
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|CHANGE_DYNAMIC_TYPE_LOCATION
argument_list|(
name|node
argument_list|)
argument_list|,
name|spc
operator|+
literal|2
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|")>>>"
argument_list|)
expr_stmt|;
name|is_expr
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|LABEL_EXPR
case|:
name|op0
operator|=
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If this is for break or continue, don't bother printing it.  */
if|if
condition|(
name|DECL_NAME
argument_list|(
name|op0
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|op0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"break"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"continue"
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|op0
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|pp_character
argument_list|(
name|buffer
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_NONLOCAL
argument_list|(
name|op0
argument_list|)
condition|)
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|" [non-local]"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EXC_PTR_EXPR
case|:
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"<<<exception object>>>"
argument_list|)
expr_stmt|;
break|break;
case|case
name|FILTER_EXPR
case|:
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"<<<filter object>>>"
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOOP_EXPR
case|:
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"while (1)"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|TDF_SLIM
operator|)
condition|)
block|{
name|newline_and_indent
argument_list|(
name|buffer
argument_list|,
name|spc
operator|+
literal|2
argument_list|)
expr_stmt|;
name|pp_character
argument_list|(
name|buffer
argument_list|,
literal|'{'
argument_list|)
expr_stmt|;
name|newline_and_indent
argument_list|(
name|buffer
argument_list|,
name|spc
operator|+
literal|4
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|LOOP_EXPR_BODY
argument_list|(
name|node
argument_list|)
argument_list|,
name|spc
operator|+
literal|4
argument_list|,
name|flags
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|newline_and_indent
argument_list|(
name|buffer
argument_list|,
name|spc
operator|+
literal|2
argument_list|)
expr_stmt|;
name|pp_character
argument_list|(
name|buffer
argument_list|,
literal|'}'
argument_list|)
expr_stmt|;
block|}
name|is_expr
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|RETURN_EXPR
case|:
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"return"
argument_list|)
expr_stmt|;
name|op0
operator|=
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|op0
condition|)
block|{
name|pp_space
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|MODIFY_EXPR
condition|)
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|TREE_OPERAND
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
else|else
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|op0
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|EXIT_EXPR
case|:
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"if ("
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|0
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|") break"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SWITCH_EXPR
case|:
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"switch ("
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|SWITCH_COND
argument_list|(
name|node
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|pp_character
argument_list|(
name|buffer
argument_list|,
literal|')'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|TDF_SLIM
operator|)
condition|)
block|{
name|newline_and_indent
argument_list|(
name|buffer
argument_list|,
name|spc
operator|+
literal|2
argument_list|)
expr_stmt|;
name|pp_character
argument_list|(
name|buffer
argument_list|,
literal|'{'
argument_list|)
expr_stmt|;
if|if
condition|(
name|SWITCH_BODY
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|newline_and_indent
argument_list|(
name|buffer
argument_list|,
name|spc
operator|+
literal|4
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|SWITCH_BODY
argument_list|(
name|node
argument_list|)
argument_list|,
name|spc
operator|+
literal|4
argument_list|,
name|flags
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tree
name|vec
init|=
name|SWITCH_LABELS
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|size_t
name|i
decl_stmt|,
name|n
init|=
name|TREE_VEC_LENGTH
argument_list|(
name|vec
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|elt
init|=
name|TREE_VEC_ELT
argument_list|(
name|vec
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|newline_and_indent
argument_list|(
name|buffer
argument_list|,
name|spc
operator|+
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|elt
condition|)
block|{
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|elt
argument_list|,
name|spc
operator|+
literal|4
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|" goto "
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|CASE_LABEL
argument_list|(
name|elt
argument_list|)
argument_list|,
name|spc
operator|+
literal|4
argument_list|,
name|flags
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|pp_semicolon
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
else|else
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"case ???: goto ???;"
argument_list|)
expr_stmt|;
block|}
block|}
name|newline_and_indent
argument_list|(
name|buffer
argument_list|,
name|spc
operator|+
literal|2
argument_list|)
expr_stmt|;
name|pp_character
argument_list|(
name|buffer
argument_list|,
literal|'}'
argument_list|)
expr_stmt|;
block|}
name|is_expr
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|GOTO_EXPR
case|:
name|op0
operator|=
name|GOTO_DESTINATION
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|SSA_NAME
operator|&&
name|DECL_P
argument_list|(
name|op0
argument_list|)
operator|&&
name|DECL_NAME
argument_list|(
name|op0
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|op0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"break"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"continue"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|pp_string
argument_list|(
name|buffer
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"goto "
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|op0
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
break|break;
case|case
name|RESX_EXPR
case|:
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"resx "
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|0
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
break|break;
case|case
name|ASM_EXPR
case|:
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"__asm__"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ASM_VOLATILE_P
argument_list|(
name|node
argument_list|)
condition|)
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|" __volatile__"
argument_list|)
expr_stmt|;
name|pp_character
argument_list|(
name|buffer
argument_list|,
literal|'('
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|ASM_STRING
argument_list|(
name|node
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|pp_character
argument_list|(
name|buffer
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|ASM_OUTPUTS
argument_list|(
name|node
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|pp_character
argument_list|(
name|buffer
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|ASM_INPUTS
argument_list|(
name|node
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|ASM_CLOBBERS
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|pp_character
argument_list|(
name|buffer
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|ASM_CLOBBERS
argument_list|(
name|node
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CASE_LABEL_EXPR
case|:
if|if
condition|(
name|CASE_LOW
argument_list|(
name|node
argument_list|)
operator|&&
name|CASE_HIGH
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"case "
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|CASE_LOW
argument_list|(
name|node
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|" ... "
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|CASE_HIGH
argument_list|(
name|node
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CASE_LOW
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"case "
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|CASE_LOW
argument_list|(
name|node
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
else|else
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"default "
argument_list|)
expr_stmt|;
name|pp_character
argument_list|(
name|buffer
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
break|break;
case|case
name|OBJ_TYPE_REF
case|:
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"OBJ_TYPE_REF("
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|OBJ_TYPE_REF_EXPR
argument_list|(
name|node
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|pp_character
argument_list|(
name|buffer
argument_list|,
literal|';'
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|OBJ_TYPE_REF_OBJECT
argument_list|(
name|node
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|pp_character
argument_list|(
name|buffer
argument_list|,
literal|'-'
argument_list|)
expr_stmt|;
name|pp_character
argument_list|(
name|buffer
argument_list|,
literal|'>'
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|OBJ_TYPE_REF_TOKEN
argument_list|(
name|node
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|pp_character
argument_list|(
name|buffer
argument_list|,
literal|')'
argument_list|)
expr_stmt|;
break|break;
case|case
name|PHI_NODE
case|:
block|{
name|int
name|i
decl_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|PHI_RESULT
argument_list|(
name|node
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|" = PHI<"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PHI_NUM_ARGS
argument_list|(
name|node
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|PHI_ARG_DEF
argument_list|(
name|node
argument_list|,
name|i
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|pp_decimal_int
argument_list|(
name|buffer
argument_list|,
name|PHI_ARG_EDGE
argument_list|(
name|node
argument_list|,
name|i
argument_list|)
operator|->
name|src
operator|->
name|index
argument_list|)
expr_stmt|;
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|PHI_NUM_ARGS
argument_list|(
name|node
argument_list|)
operator|-
literal|1
condition|)
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
block|}
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|">;"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SSA_NAME
case|:
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|SSA_NAME_VAR
argument_list|(
name|node
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"_"
argument_list|)
expr_stmt|;
name|pp_decimal_int
argument_list|(
name|buffer
argument_list|,
name|SSA_NAME_VERSION
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SSA_NAME_OCCURS_IN_ABNORMAL_PHI
argument_list|(
name|node
argument_list|)
condition|)
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"(ab)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|WITH_SIZE_EXPR
case|:
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"WITH_SIZE_EXPR<"
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|0
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|1
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|">"
argument_list|)
expr_stmt|;
break|break;
case|case
name|VALUE_HANDLE
case|:
name|pp_printf
argument_list|(
name|buffer
argument_list|,
literal|"VH.%d"
argument_list|,
name|VALUE_HANDLE_ID
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ASSERT_EXPR
case|:
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"ASSERT_EXPR<"
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|ASSERT_EXPR_VAR
argument_list|(
name|node
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|ASSERT_EXPR_COND
argument_list|(
name|node
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|">"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCEV_KNOWN
case|:
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"scev_known"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCEV_NOT_KNOWN
case|:
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"scev_not_known"
argument_list|)
expr_stmt|;
break|break;
case|case
name|POLYNOMIAL_CHREC
case|:
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"{"
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|CHREC_LEFT
argument_list|(
name|node
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|", +, "
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|CHREC_RIGHT
argument_list|(
name|node
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"}_"
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|CHREC_VAR
argument_list|(
name|node
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|is_stmt
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|REALIGN_LOAD_EXPR
case|:
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"REALIGN_LOAD<"
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|0
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|1
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|2
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|">"
argument_list|)
expr_stmt|;
break|break;
case|case
name|VEC_COND_EXPR
case|:
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|" VEC_COND_EXPR< "
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|0
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|" , "
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|1
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|" , "
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|2
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"> "
argument_list|)
expr_stmt|;
break|break;
case|case
name|DOT_PROD_EXPR
case|:
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|" DOT_PROD_EXPR< "
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|0
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|" , "
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|1
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|" , "
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|2
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"> "
argument_list|)
expr_stmt|;
break|break;
case|case
name|OMP_PARALLEL
case|:
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"#pragma omp parallel"
argument_list|)
expr_stmt|;
name|dump_omp_clauses
argument_list|(
name|buffer
argument_list|,
name|OMP_PARALLEL_CLAUSES
argument_list|(
name|node
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|OMP_PARALLEL_FN
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|" [child fn: "
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|OMP_PARALLEL_FN
argument_list|(
name|node
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|" ("
argument_list|)
expr_stmt|;
if|if
condition|(
name|OMP_PARALLEL_DATA_ARG
argument_list|(
name|node
argument_list|)
condition|)
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|OMP_PARALLEL_DATA_ARG
argument_list|(
name|node
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
else|else
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"???"
argument_list|)
expr_stmt|;
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|")]"
argument_list|)
expr_stmt|;
block|}
name|dump_omp_body
label|:
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|TDF_SLIM
operator|)
operator|&&
name|OMP_BODY
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|newline_and_indent
argument_list|(
name|buffer
argument_list|,
name|spc
operator|+
literal|2
argument_list|)
expr_stmt|;
name|pp_character
argument_list|(
name|buffer
argument_list|,
literal|'{'
argument_list|)
expr_stmt|;
name|newline_and_indent
argument_list|(
name|buffer
argument_list|,
name|spc
operator|+
literal|4
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|OMP_BODY
argument_list|(
name|node
argument_list|)
argument_list|,
name|spc
operator|+
literal|4
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|newline_and_indent
argument_list|(
name|buffer
argument_list|,
name|spc
operator|+
literal|2
argument_list|)
expr_stmt|;
name|pp_character
argument_list|(
name|buffer
argument_list|,
literal|'}'
argument_list|)
expr_stmt|;
block|}
name|is_expr
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|OMP_FOR
case|:
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"#pragma omp for"
argument_list|)
expr_stmt|;
name|dump_omp_clauses
argument_list|(
name|buffer
argument_list|,
name|OMP_FOR_CLAUSES
argument_list|(
name|node
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|TDF_SLIM
operator|)
condition|)
block|{
if|if
condition|(
name|OMP_FOR_PRE_BODY
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|newline_and_indent
argument_list|(
name|buffer
argument_list|,
name|spc
operator|+
literal|2
argument_list|)
expr_stmt|;
name|pp_character
argument_list|(
name|buffer
argument_list|,
literal|'{'
argument_list|)
expr_stmt|;
name|spc
operator|+=
literal|4
expr_stmt|;
name|newline_and_indent
argument_list|(
name|buffer
argument_list|,
name|spc
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|OMP_FOR_PRE_BODY
argument_list|(
name|node
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
name|newline_and_indent
argument_list|(
name|buffer
argument_list|,
name|spc
argument_list|)
expr_stmt|;
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"for ("
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|OMP_FOR_INIT
argument_list|(
name|node
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"; "
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|OMP_FOR_COND
argument_list|(
name|node
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"; "
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|OMP_FOR_INCR
argument_list|(
name|node
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
if|if
condition|(
name|OMP_FOR_BODY
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|newline_and_indent
argument_list|(
name|buffer
argument_list|,
name|spc
operator|+
literal|2
argument_list|)
expr_stmt|;
name|pp_character
argument_list|(
name|buffer
argument_list|,
literal|'{'
argument_list|)
expr_stmt|;
name|newline_and_indent
argument_list|(
name|buffer
argument_list|,
name|spc
operator|+
literal|4
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|OMP_FOR_BODY
argument_list|(
name|node
argument_list|)
argument_list|,
name|spc
operator|+
literal|4
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|newline_and_indent
argument_list|(
name|buffer
argument_list|,
name|spc
operator|+
literal|2
argument_list|)
expr_stmt|;
name|pp_character
argument_list|(
name|buffer
argument_list|,
literal|'}'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|OMP_FOR_PRE_BODY
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|spc
operator|-=
literal|4
expr_stmt|;
name|newline_and_indent
argument_list|(
name|buffer
argument_list|,
name|spc
operator|+
literal|2
argument_list|)
expr_stmt|;
name|pp_character
argument_list|(
name|buffer
argument_list|,
literal|'}'
argument_list|)
expr_stmt|;
block|}
block|}
name|is_expr
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|OMP_SECTIONS
case|:
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"#pragma omp sections"
argument_list|)
expr_stmt|;
name|dump_omp_clauses
argument_list|(
name|buffer
argument_list|,
name|OMP_SECTIONS_CLAUSES
argument_list|(
name|node
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|)
expr_stmt|;
goto|goto
name|dump_omp_body
goto|;
case|case
name|OMP_SECTION
case|:
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"#pragma omp section"
argument_list|)
expr_stmt|;
goto|goto
name|dump_omp_body
goto|;
case|case
name|OMP_MASTER
case|:
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"#pragma omp master"
argument_list|)
expr_stmt|;
goto|goto
name|dump_omp_body
goto|;
case|case
name|OMP_ORDERED
case|:
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"#pragma omp ordered"
argument_list|)
expr_stmt|;
goto|goto
name|dump_omp_body
goto|;
case|case
name|OMP_CRITICAL
case|:
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"#pragma omp critical"
argument_list|)
expr_stmt|;
if|if
condition|(
name|OMP_CRITICAL_NAME
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|pp_space
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|pp_character
argument_list|(
name|buffer
argument_list|,
literal|'('
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|OMP_CRITICAL_NAME
argument_list|(
name|node
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|pp_character
argument_list|(
name|buffer
argument_list|,
literal|')'
argument_list|)
expr_stmt|;
block|}
goto|goto
name|dump_omp_body
goto|;
case|case
name|OMP_ATOMIC
case|:
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"#pragma omp atomic"
argument_list|)
expr_stmt|;
name|newline_and_indent
argument_list|(
name|buffer
argument_list|,
name|spc
operator|+
literal|2
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|0
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|pp_space
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|pp_character
argument_list|(
name|buffer
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
name|pp_space
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|1
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
break|break;
case|case
name|OMP_SINGLE
case|:
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"#pragma omp single"
argument_list|)
expr_stmt|;
name|dump_omp_clauses
argument_list|(
name|buffer
argument_list|,
name|OMP_SINGLE_CLAUSES
argument_list|(
name|node
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|)
expr_stmt|;
goto|goto
name|dump_omp_body
goto|;
case|case
name|OMP_RETURN
case|:
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"OMP_RETURN"
argument_list|)
expr_stmt|;
if|if
condition|(
name|OMP_RETURN_NOWAIT
argument_list|(
name|node
argument_list|)
condition|)
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|" [nowait]"
argument_list|)
expr_stmt|;
name|is_expr
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|OMP_CONTINUE
case|:
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"OMP_CONTINUE"
argument_list|)
expr_stmt|;
name|is_expr
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|OMP_CLAUSE
case|:
name|dump_omp_clause
argument_list|(
name|buffer
argument_list|,
name|node
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|is_expr
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|REDUC_MAX_EXPR
case|:
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|" REDUC_MAX_EXPR< "
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|0
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"> "
argument_list|)
expr_stmt|;
break|break;
case|case
name|REDUC_MIN_EXPR
case|:
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|" REDUC_MIN_EXPR< "
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|0
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"> "
argument_list|)
expr_stmt|;
break|break;
case|case
name|REDUC_PLUS_EXPR
case|:
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|" REDUC_PLUS_EXPR< "
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|0
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"> "
argument_list|)
expr_stmt|;
break|break;
case|case
name|BLOCK
case|:
block|{
name|tree
name|t
decl_stmt|;
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"BLOCK"
argument_list|)
expr_stmt|;
if|if
condition|(
name|BLOCK_ABSTRACT
argument_list|(
name|node
argument_list|)
condition|)
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|" [abstract]"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_ASM_WRITTEN
argument_list|(
name|node
argument_list|)
condition|)
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|" [written]"
argument_list|)
expr_stmt|;
name|newline_and_indent
argument_list|(
name|buffer
argument_list|,
name|spc
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|BLOCK_SUPERCONTEXT
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"SUPERCONTEXT: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|BLOCK_SUPERCONTEXT
argument_list|(
name|node
argument_list|)
argument_list|)
operator|==
name|BLOCK
condition|)
name|pp_printf
argument_list|(
name|buffer
argument_list|,
literal|"BLOCK %p"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|BLOCK_SUPERCONTEXT
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|BLOCK_SUPERCONTEXT
argument_list|(
name|node
argument_list|)
argument_list|,
literal|0
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|newline_and_indent
argument_list|(
name|buffer
argument_list|,
name|spc
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|BLOCK_SUBBLOCKS
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"SUBBLOCKS: "
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|BLOCK_SUBBLOCKS
argument_list|(
name|node
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|BLOCK_CHAIN
argument_list|(
name|t
argument_list|)
control|)
name|pp_printf
argument_list|(
name|buffer
argument_list|,
literal|"%p "
argument_list|,
operator|(
name|void
operator|*
operator|)
name|t
argument_list|)
expr_stmt|;
name|newline_and_indent
argument_list|(
name|buffer
argument_list|,
name|spc
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|BLOCK_VARS
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"VARS: "
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|BLOCK_VARS
argument_list|(
name|node
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|t
argument_list|,
literal|0
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
block|}
name|newline_and_indent
argument_list|(
name|buffer
argument_list|,
name|spc
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|BLOCK_ABSTRACT_ORIGIN
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"ABSTRACT_ORIGIN: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|BLOCK_ABSTRACT_ORIGIN
argument_list|(
name|node
argument_list|)
argument_list|)
operator|==
name|BLOCK
condition|)
name|pp_printf
argument_list|(
name|buffer
argument_list|,
literal|"BLOCK %p"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|BLOCK_ABSTRACT_ORIGIN
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|BLOCK_ABSTRACT_ORIGIN
argument_list|(
name|node
argument_list|)
argument_list|,
literal|0
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|newline_and_indent
argument_list|(
name|buffer
argument_list|,
name|spc
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
default|default:
name|NIY
expr_stmt|;
block|}
if|if
condition|(
name|is_stmt
operator|&&
name|is_expr
condition|)
name|pp_semicolon
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|pp_write_text_to_stream
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
return|return
name|spc
return|;
block|}
end_function

begin_comment
comment|/* Print the declaration of a variable.  */
end_comment

begin_function
specifier|static
name|void
name|print_declaration
parameter_list|(
name|pretty_printer
modifier|*
name|buffer
parameter_list|,
name|tree
name|t
parameter_list|,
name|int
name|spc
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|INDENT
argument_list|(
name|spc
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"typedef "
argument_list|)
expr_stmt|;
if|if
condition|(
name|CODE_CONTAINS_STRUCT
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
argument_list|,
name|TS_DECL_WRTL
argument_list|)
operator|&&
name|DECL_REGISTER
argument_list|(
name|t
argument_list|)
condition|)
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"register "
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|t
argument_list|)
operator|&&
name|DECL_EXTERNAL
argument_list|(
name|t
argument_list|)
condition|)
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"extern "
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|t
argument_list|)
condition|)
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"static "
argument_list|)
expr_stmt|;
comment|/* Print the type and name.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|tree
name|tmp
decl_stmt|;
comment|/* Print array's type.  */
name|tmp
operator|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
expr_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|tmp
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|tmp
operator|=
name|TREE_TYPE
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|TREE_TYPE
argument_list|(
name|tmp
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
comment|/* Print variable's name.  */
name|pp_space
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|t
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
comment|/* Print the dimensions.  */
name|tmp
operator|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
expr_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|dump_array_domain
argument_list|(
name|buffer
argument_list|,
name|TYPE_DOMAIN
argument_list|(
name|tmp
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|TREE_TYPE
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|pp_space
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|dump_decl_name
argument_list|(
name|buffer
argument_list|,
name|t
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|dump_function_declaration
argument_list|(
name|buffer
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Print type declaration.  */
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
comment|/* Print variable's name.  */
name|pp_space
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|t
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_HARD_REGISTER
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|" __asm__ "
argument_list|)
expr_stmt|;
name|pp_character
argument_list|(
name|buffer
argument_list|,
literal|'('
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|DECL_ASSEMBLER_NAME
argument_list|(
name|t
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|pp_character
argument_list|(
name|buffer
argument_list|,
literal|')'
argument_list|)
expr_stmt|;
block|}
comment|/* The initial value of a function serves to determine wether the function      is declared or defined.  So the following does not apply to function      nodes.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
block|{
comment|/* Print the initial value.  */
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|pp_space
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|pp_character
argument_list|(
name|buffer
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
name|pp_space
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|DECL_INITIAL
argument_list|(
name|t
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_HAS_VALUE_EXPR_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|" [value-expr: "
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|DECL_VALUE_EXPR
argument_list|(
name|t
argument_list|)
argument_list|,
name|spc
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|pp_character
argument_list|(
name|buffer
argument_list|,
literal|']'
argument_list|)
expr_stmt|;
block|}
name|pp_character
argument_list|(
name|buffer
argument_list|,
literal|';'
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Prints a structure: name, fields, and methods.    FIXME: Still incomplete.  */
end_comment

begin_function
specifier|static
name|void
name|print_struct_decl
parameter_list|(
name|pretty_printer
modifier|*
name|buffer
parameter_list|,
name|tree
name|node
parameter_list|,
name|int
name|spc
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
comment|/* Print the name of the structure.  */
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|INDENT
argument_list|(
name|spc
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|node
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"struct "
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|node
argument_list|)
operator|==
name|UNION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|node
argument_list|)
operator|==
name|QUAL_UNION_TYPE
operator|)
condition|)
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"union "
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|TYPE_NAME
argument_list|(
name|node
argument_list|)
argument_list|,
name|spc
argument_list|,
literal|0
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
comment|/* Print the contents of the structure.  */
name|pp_newline
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|INDENT
argument_list|(
name|spc
argument_list|)
expr_stmt|;
name|pp_character
argument_list|(
name|buffer
argument_list|,
literal|'{'
argument_list|)
expr_stmt|;
name|pp_newline
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
comment|/* Print the fields of the structure.  */
block|{
name|tree
name|tmp
decl_stmt|;
name|tmp
operator|=
name|TYPE_FIELDS
argument_list|(
name|node
argument_list|)
expr_stmt|;
while|while
condition|(
name|tmp
condition|)
block|{
comment|/* Avoid to print recursively the structure.  */
comment|/* FIXME : Not implemented correctly..., 	   what about the case when we have a cycle in the contain graph? ... 	   Maybe this could be solved by looking at the scope in which the 	   structure was declared.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|tmp
argument_list|)
operator|!=
name|node
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|tmp
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|tmp
argument_list|)
argument_list|)
operator|!=
name|node
operator|)
condition|)
block|{
name|print_declaration
argument_list|(
name|buffer
argument_list|,
name|tmp
argument_list|,
name|spc
operator|+
literal|2
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|pp_newline
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
name|tmp
operator|=
name|TREE_CHAIN
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
block|}
name|INDENT
argument_list|(
name|spc
argument_list|)
expr_stmt|;
name|pp_character
argument_list|(
name|buffer
argument_list|,
literal|'}'
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the priority of the operator OP.     From lowest to highest precedence with either left-to-right (L-R)    or right-to-left (R-L) associativity]:       1	[L-R] ,      2	[R-L] = += -= *= /= %=&= ^= |=<<=>>=      3	[R-L] ?:      4	[L-R] ||      5	[L-R]&&      6	[L-R] |      7	[L-R] ^      8	[L-R]&      9	[L-R] == !=     10	[L-R]<<=>>=     11	[L-R]<<>>     12	[L-R] + -     13	[L-R] * / %     14	[R-L] ! ~ ++ -- + - *& (type) sizeof     15	[L-R] fn() [] -> .     unary +, - and * have higher precedence than the corresponding binary    operators.  */
end_comment

begin_function
specifier|static
name|int
name|op_prio
parameter_list|(
name|tree
name|op
parameter_list|)
block|{
if|if
condition|(
name|op
operator|==
name|NULL
condition|)
return|return
literal|9999
return|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|TREE_LIST
case|:
case|case
name|COMPOUND_EXPR
case|:
case|case
name|BIND_EXPR
case|:
return|return
literal|1
return|;
case|case
name|MODIFY_EXPR
case|:
case|case
name|INIT_EXPR
case|:
return|return
literal|2
return|;
case|case
name|COND_EXPR
case|:
return|return
literal|3
return|;
case|case
name|TRUTH_OR_EXPR
case|:
case|case
name|TRUTH_ORIF_EXPR
case|:
return|return
literal|4
return|;
case|case
name|TRUTH_AND_EXPR
case|:
case|case
name|TRUTH_ANDIF_EXPR
case|:
return|return
literal|5
return|;
case|case
name|BIT_IOR_EXPR
case|:
return|return
literal|6
return|;
case|case
name|BIT_XOR_EXPR
case|:
case|case
name|TRUTH_XOR_EXPR
case|:
return|return
literal|7
return|;
case|case
name|BIT_AND_EXPR
case|:
return|return
literal|8
return|;
case|case
name|EQ_EXPR
case|:
case|case
name|NE_EXPR
case|:
return|return
literal|9
return|;
case|case
name|UNLT_EXPR
case|:
case|case
name|UNLE_EXPR
case|:
case|case
name|UNGT_EXPR
case|:
case|case
name|UNGE_EXPR
case|:
case|case
name|UNEQ_EXPR
case|:
case|case
name|LTGT_EXPR
case|:
case|case
name|ORDERED_EXPR
case|:
case|case
name|UNORDERED_EXPR
case|:
case|case
name|LT_EXPR
case|:
case|case
name|LE_EXPR
case|:
case|case
name|GT_EXPR
case|:
case|case
name|GE_EXPR
case|:
return|return
literal|10
return|;
case|case
name|LSHIFT_EXPR
case|:
case|case
name|RSHIFT_EXPR
case|:
case|case
name|LROTATE_EXPR
case|:
case|case
name|RROTATE_EXPR
case|:
return|return
literal|11
return|;
case|case
name|WIDEN_SUM_EXPR
case|:
case|case
name|PLUS_EXPR
case|:
case|case
name|MINUS_EXPR
case|:
return|return
literal|12
return|;
case|case
name|WIDEN_MULT_EXPR
case|:
case|case
name|DOT_PROD_EXPR
case|:
case|case
name|MULT_EXPR
case|:
case|case
name|TRUNC_DIV_EXPR
case|:
case|case
name|CEIL_DIV_EXPR
case|:
case|case
name|FLOOR_DIV_EXPR
case|:
case|case
name|ROUND_DIV_EXPR
case|:
case|case
name|RDIV_EXPR
case|:
case|case
name|EXACT_DIV_EXPR
case|:
case|case
name|TRUNC_MOD_EXPR
case|:
case|case
name|CEIL_MOD_EXPR
case|:
case|case
name|FLOOR_MOD_EXPR
case|:
case|case
name|ROUND_MOD_EXPR
case|:
return|return
literal|13
return|;
case|case
name|TRUTH_NOT_EXPR
case|:
case|case
name|BIT_NOT_EXPR
case|:
case|case
name|POSTINCREMENT_EXPR
case|:
case|case
name|POSTDECREMENT_EXPR
case|:
case|case
name|PREINCREMENT_EXPR
case|:
case|case
name|PREDECREMENT_EXPR
case|:
case|case
name|NEGATE_EXPR
case|:
case|case
name|ALIGN_INDIRECT_REF
case|:
case|case
name|MISALIGNED_INDIRECT_REF
case|:
case|case
name|INDIRECT_REF
case|:
case|case
name|ADDR_EXPR
case|:
case|case
name|FLOAT_EXPR
case|:
case|case
name|NOP_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
case|case
name|FIX_TRUNC_EXPR
case|:
case|case
name|FIX_CEIL_EXPR
case|:
case|case
name|FIX_FLOOR_EXPR
case|:
case|case
name|FIX_ROUND_EXPR
case|:
case|case
name|TARGET_EXPR
case|:
return|return
literal|14
return|;
case|case
name|CALL_EXPR
case|:
case|case
name|ARRAY_REF
case|:
case|case
name|ARRAY_RANGE_REF
case|:
case|case
name|COMPONENT_REF
case|:
return|return
literal|15
return|;
comment|/* Special expressions.  */
case|case
name|MIN_EXPR
case|:
case|case
name|MAX_EXPR
case|:
case|case
name|ABS_EXPR
case|:
case|case
name|REALPART_EXPR
case|:
case|case
name|IMAGPART_EXPR
case|:
case|case
name|REDUC_MAX_EXPR
case|:
case|case
name|REDUC_MIN_EXPR
case|:
case|case
name|REDUC_PLUS_EXPR
case|:
case|case
name|VEC_LSHIFT_EXPR
case|:
case|case
name|VEC_RSHIFT_EXPR
case|:
return|return
literal|16
return|;
case|case
name|SAVE_EXPR
case|:
case|case
name|NON_LVALUE_EXPR
case|:
return|return
name|op_prio
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
default|default:
comment|/* Return an arbitrarily high precedence to avoid surrounding single 	 VAR_DECLs in ()s.  */
return|return
literal|9999
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return the symbol associated with operator OP.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|op_symbol_1
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|)
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|MODIFY_EXPR
case|:
return|return
literal|"="
return|;
case|case
name|TRUTH_OR_EXPR
case|:
case|case
name|TRUTH_ORIF_EXPR
case|:
return|return
literal|"||"
return|;
case|case
name|TRUTH_AND_EXPR
case|:
case|case
name|TRUTH_ANDIF_EXPR
case|:
return|return
literal|"&&"
return|;
case|case
name|BIT_IOR_EXPR
case|:
return|return
literal|"|"
return|;
case|case
name|TRUTH_XOR_EXPR
case|:
case|case
name|BIT_XOR_EXPR
case|:
return|return
literal|"^"
return|;
case|case
name|ADDR_EXPR
case|:
case|case
name|BIT_AND_EXPR
case|:
return|return
literal|"&"
return|;
case|case
name|ORDERED_EXPR
case|:
return|return
literal|"ord"
return|;
case|case
name|UNORDERED_EXPR
case|:
return|return
literal|"unord"
return|;
case|case
name|EQ_EXPR
case|:
return|return
literal|"=="
return|;
case|case
name|UNEQ_EXPR
case|:
return|return
literal|"u=="
return|;
case|case
name|NE_EXPR
case|:
return|return
literal|"!="
return|;
case|case
name|LT_EXPR
case|:
return|return
literal|"<"
return|;
case|case
name|UNLT_EXPR
case|:
return|return
literal|"u<"
return|;
case|case
name|LE_EXPR
case|:
return|return
literal|"<="
return|;
case|case
name|UNLE_EXPR
case|:
return|return
literal|"u<="
return|;
case|case
name|GT_EXPR
case|:
return|return
literal|">"
return|;
case|case
name|UNGT_EXPR
case|:
return|return
literal|"u>"
return|;
case|case
name|GE_EXPR
case|:
return|return
literal|">="
return|;
case|case
name|UNGE_EXPR
case|:
return|return
literal|"u>="
return|;
case|case
name|LTGT_EXPR
case|:
return|return
literal|"<>"
return|;
case|case
name|LSHIFT_EXPR
case|:
return|return
literal|"<<"
return|;
case|case
name|RSHIFT_EXPR
case|:
return|return
literal|">>"
return|;
case|case
name|LROTATE_EXPR
case|:
return|return
literal|"r<<"
return|;
case|case
name|RROTATE_EXPR
case|:
return|return
literal|"r>>"
return|;
case|case
name|VEC_LSHIFT_EXPR
case|:
return|return
literal|"v<<"
return|;
case|case
name|VEC_RSHIFT_EXPR
case|:
return|return
literal|"v>>"
return|;
case|case
name|PLUS_EXPR
case|:
return|return
literal|"+"
return|;
case|case
name|REDUC_PLUS_EXPR
case|:
return|return
literal|"r+"
return|;
case|case
name|WIDEN_SUM_EXPR
case|:
return|return
literal|"w+"
return|;
case|case
name|WIDEN_MULT_EXPR
case|:
return|return
literal|"w*"
return|;
case|case
name|NEGATE_EXPR
case|:
case|case
name|MINUS_EXPR
case|:
return|return
literal|"-"
return|;
case|case
name|BIT_NOT_EXPR
case|:
return|return
literal|"~"
return|;
case|case
name|TRUTH_NOT_EXPR
case|:
return|return
literal|"!"
return|;
case|case
name|MULT_EXPR
case|:
case|case
name|INDIRECT_REF
case|:
return|return
literal|"*"
return|;
case|case
name|ALIGN_INDIRECT_REF
case|:
return|return
literal|"A*"
return|;
case|case
name|MISALIGNED_INDIRECT_REF
case|:
return|return
literal|"M*"
return|;
case|case
name|TRUNC_DIV_EXPR
case|:
case|case
name|RDIV_EXPR
case|:
return|return
literal|"/"
return|;
case|case
name|CEIL_DIV_EXPR
case|:
return|return
literal|"/[cl]"
return|;
case|case
name|FLOOR_DIV_EXPR
case|:
return|return
literal|"/[fl]"
return|;
case|case
name|ROUND_DIV_EXPR
case|:
return|return
literal|"/[rd]"
return|;
case|case
name|EXACT_DIV_EXPR
case|:
return|return
literal|"/[ex]"
return|;
case|case
name|TRUNC_MOD_EXPR
case|:
return|return
literal|"%"
return|;
case|case
name|CEIL_MOD_EXPR
case|:
return|return
literal|"%[cl]"
return|;
case|case
name|FLOOR_MOD_EXPR
case|:
return|return
literal|"%[fl]"
return|;
case|case
name|ROUND_MOD_EXPR
case|:
return|return
literal|"%[rd]"
return|;
case|case
name|PREDECREMENT_EXPR
case|:
return|return
literal|" --"
return|;
case|case
name|PREINCREMENT_EXPR
case|:
return|return
literal|" ++"
return|;
case|case
name|POSTDECREMENT_EXPR
case|:
return|return
literal|"-- "
return|;
case|case
name|POSTINCREMENT_EXPR
case|:
return|return
literal|"++ "
return|;
case|case
name|MAX_EXPR
case|:
return|return
literal|"max"
return|;
case|case
name|MIN_EXPR
case|:
return|return
literal|"min"
return|;
default|default:
return|return
literal|"<<< ???>>>"
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|op_symbol
parameter_list|(
name|tree
name|op
parameter_list|)
block|{
return|return
name|op_symbol_1
argument_list|(
name|TREE_CODE
argument_list|(
name|op
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Prints the name of a CALL_EXPR.  */
end_comment

begin_function
specifier|static
name|void
name|print_call_name
parameter_list|(
name|pretty_printer
modifier|*
name|buffer
parameter_list|,
name|tree
name|node
parameter_list|)
block|{
name|tree
name|op0
decl_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|node
argument_list|)
operator|==
name|CALL_EXPR
argument_list|)
expr_stmt|;
name|op0
operator|=
name|TREE_OPERAND
argument_list|(
name|node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|NON_LVALUE_EXPR
condition|)
name|op0
operator|=
name|TREE_OPERAND
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
condition|)
block|{
case|case
name|VAR_DECL
case|:
case|case
name|PARM_DECL
case|:
name|dump_function_name
argument_list|(
name|buffer
argument_list|,
name|op0
argument_list|)
expr_stmt|;
break|break;
case|case
name|ADDR_EXPR
case|:
case|case
name|INDIRECT_REF
case|:
case|case
name|NOP_EXPR
case|:
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|TREE_OPERAND
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|false
argument_list|)
expr_stmt|;
break|break;
case|case
name|COND_EXPR
case|:
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|TREE_OPERAND
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|") ? "
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|TREE_OPERAND
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|" : "
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|TREE_OPERAND
argument_list|(
name|op0
argument_list|,
literal|2
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|false
argument_list|)
expr_stmt|;
break|break;
case|case
name|COMPONENT_REF
case|:
comment|/* The function is a pointer contained in a structure.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|INDIRECT_REF
operator|||
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|VAR_DECL
condition|)
name|dump_function_name
argument_list|(
name|buffer
argument_list|,
name|TREE_OPERAND
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|TREE_OPERAND
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|false
argument_list|)
expr_stmt|;
comment|/* else 	 We can have several levels of structures and a function 	 pointer inside.  This is not implemented yet...  */
comment|/*		  NIY;*/
break|break;
case|case
name|ARRAY_REF
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|VAR_DECL
condition|)
name|dump_function_name
argument_list|(
name|buffer
argument_list|,
name|TREE_OPERAND
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|op0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|false
argument_list|)
expr_stmt|;
break|break;
case|case
name|SSA_NAME
case|:
case|case
name|OBJ_TYPE_REF
case|:
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|op0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|false
argument_list|)
expr_stmt|;
break|break;
default|default:
name|NIY
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Parses the string STR and replaces new-lines by '\n', tabs by '\t', ...  */
end_comment

begin_function
specifier|static
name|void
name|pretty_print_string
parameter_list|(
name|pretty_printer
modifier|*
name|buffer
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
if|if
condition|(
name|str
operator|==
name|NULL
condition|)
return|return;
while|while
condition|(
operator|*
name|str
condition|)
block|{
switch|switch
condition|(
name|str
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'\b'
case|:
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"\\b"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\f'
case|:
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"\\f"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"\\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\r'
case|:
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"\\r"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\t'
case|:
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"\\t"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\v'
case|:
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"\\v"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"\\\\"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\"'
case|:
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"\\\""
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\''
case|:
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"\\'"
argument_list|)
expr_stmt|;
break|break;
comment|/* No need to handle \0; the loop terminates on \0.  */
case|case
literal|'\1'
case|:
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"\\1"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\2'
case|:
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"\\2"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\3'
case|:
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"\\3"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\4'
case|:
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"\\4"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\5'
case|:
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"\\5"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\6'
case|:
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"\\6"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\7'
case|:
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"\\7"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|pp_character
argument_list|(
name|buffer
argument_list|,
name|str
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
name|str
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|maybe_init_pretty_print
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|)
block|{
if|if
condition|(
operator|!
name|initialized
condition|)
block|{
name|pp_construct
argument_list|(
operator|&
name|buffer
argument_list|,
comment|/* prefix */
name|NULL
argument_list|,
comment|/* line-width */
literal|0
argument_list|)
expr_stmt|;
name|pp_needs_newline
argument_list|(
operator|&
name|buffer
argument_list|)
operator|=
name|true
expr_stmt|;
name|initialized
operator|=
literal|1
expr_stmt|;
block|}
name|buffer
operator|.
name|buffer
operator|->
name|stream
operator|=
name|file
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|newline_and_indent
parameter_list|(
name|pretty_printer
modifier|*
name|buffer
parameter_list|,
name|int
name|spc
parameter_list|)
block|{
name|pp_newline
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|INDENT
argument_list|(
name|spc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dump_vops
parameter_list|(
name|pretty_printer
modifier|*
name|buffer
parameter_list|,
name|tree
name|stmt
parameter_list|,
name|int
name|spc
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|tree
name|use
decl_stmt|;
name|use_operand_p
name|use_p
decl_stmt|;
name|def_operand_p
name|def_p
decl_stmt|;
name|use_operand_p
name|kill_p
decl_stmt|;
name|ssa_op_iter
name|iter
decl_stmt|;
if|if
condition|(
operator|!
name|ssa_operands_active
argument_list|()
condition|)
return|return;
name|FOR_EACH_SSA_MAYDEF_OPERAND
argument_list|(
argument|def_p
argument_list|,
argument|use_p
argument_list|,
argument|stmt
argument_list|,
argument|iter
argument_list|)
block|{
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"#   "
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|DEF_FROM_PTR
argument_list|(
name|def_p
argument_list|)
argument_list|,
name|spc
operator|+
literal|2
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|" = V_MAY_DEF<"
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|USE_FROM_PTR
argument_list|(
name|use_p
argument_list|)
argument_list|,
name|spc
operator|+
literal|2
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|">;"
argument_list|)
expr_stmt|;
name|newline_and_indent
argument_list|(
name|buffer
argument_list|,
name|spc
argument_list|)
expr_stmt|;
block|}
name|FOR_EACH_SSA_MUSTDEF_OPERAND
argument_list|(
argument|def_p
argument_list|,
argument|kill_p
argument_list|,
argument|stmt
argument_list|,
argument|iter
argument_list|)
block|{
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"#   "
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|DEF_FROM_PTR
argument_list|(
name|def_p
argument_list|)
argument_list|,
name|spc
operator|+
literal|2
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|" = V_MUST_DEF<"
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|USE_FROM_PTR
argument_list|(
name|kill_p
argument_list|)
argument_list|,
name|spc
operator|+
literal|2
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|">;"
argument_list|)
expr_stmt|;
name|newline_and_indent
argument_list|(
name|buffer
argument_list|,
name|spc
argument_list|)
expr_stmt|;
block|}
name|FOR_EACH_SSA_TREE_OPERAND
argument_list|(
argument|use
argument_list|,
argument|stmt
argument_list|,
argument|iter
argument_list|,
argument|SSA_OP_VUSE
argument_list|)
block|{
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"#   VUSE<"
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|use
argument_list|,
name|spc
operator|+
literal|2
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|">;"
argument_list|)
expr_stmt|;
name|newline_and_indent
argument_list|(
name|buffer
argument_list|,
name|spc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Dumps basic block BB to FILE with details described by FLAGS and    indented by INDENT spaces.  */
end_comment

begin_function
name|void
name|dump_generic_bb
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|basic_block
name|bb
parameter_list|,
name|int
name|indent
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|maybe_init_pretty_print
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|dump_generic_bb_buff
argument_list|(
operator|&
name|buffer
argument_list|,
name|bb
argument_list|,
name|indent
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|pp_flush
argument_list|(
operator|&
name|buffer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dumps header of basic block BB to buffer BUFFER indented by INDENT    spaces and details described by flags.  */
end_comment

begin_function
specifier|static
name|void
name|dump_bb_header
parameter_list|(
name|pretty_printer
modifier|*
name|buffer
parameter_list|,
name|basic_block
name|bb
parameter_list|,
name|int
name|indent
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|edge
name|e
decl_stmt|;
name|tree
name|stmt
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
if|if
condition|(
name|flags
operator|&
name|TDF_BLOCKS
condition|)
block|{
name|INDENT
argument_list|(
name|indent
argument_list|)
expr_stmt|;
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"# BLOCK "
argument_list|)
expr_stmt|;
name|pp_decimal_int
argument_list|(
name|buffer
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|bb
operator|->
name|frequency
condition|)
block|{
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|" freq:"
argument_list|)
expr_stmt|;
name|pp_decimal_int
argument_list|(
name|buffer
argument_list|,
name|bb
operator|->
name|frequency
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bb
operator|->
name|count
condition|)
block|{
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|" count:"
argument_list|)
expr_stmt|;
name|pp_widest_integer
argument_list|(
name|buffer
argument_list|,
name|bb
operator|->
name|count
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|TDF_LINENO
condition|)
block|{
name|block_stmt_iterator
name|bsi
decl_stmt|;
for|for
control|(
name|bsi
operator|=
name|bsi_start
argument_list|(
name|bb
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|;
name|bsi_next
argument_list|(
operator|&
name|bsi
argument_list|)
control|)
if|if
condition|(
name|get_lineno
argument_list|(
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|", starting at line "
argument_list|)
expr_stmt|;
name|pp_decimal_int
argument_list|(
name|buffer
argument_list|,
name|get_lineno
argument_list|(
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|newline_and_indent
argument_list|(
name|buffer
argument_list|,
name|indent
argument_list|)
expr_stmt|;
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"# PRED:"
argument_list|)
expr_stmt|;
name|pp_write_text_to_stream
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->preds
argument_list|)
if|if
condition|(
name|flags
operator|&
name|TDF_SLIM
condition|)
block|{
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|src
operator|==
name|ENTRY_BLOCK_PTR
condition|)
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"ENTRY"
argument_list|)
expr_stmt|;
else|else
name|pp_decimal_int
argument_list|(
name|buffer
argument_list|,
name|e
operator|->
name|src
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
else|else
name|dump_edge_info
argument_list|(
name|buffer
operator|->
name|buffer
operator|->
name|stream
argument_list|,
name|e
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pp_newline
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|stmt
operator|=
name|first_stmt
argument_list|(
name|bb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stmt
operator|||
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|!=
name|LABEL_EXPR
condition|)
block|{
name|INDENT
argument_list|(
name|indent
operator|-
literal|2
argument_list|)
expr_stmt|;
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"<bb "
argument_list|)
expr_stmt|;
name|pp_decimal_int
argument_list|(
name|buffer
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|">:"
argument_list|)
expr_stmt|;
name|pp_newline
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
block|}
name|pp_write_text_to_stream
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|check_bb_profile
argument_list|(
name|bb
argument_list|,
name|buffer
operator|->
name|buffer
operator|->
name|stream
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dumps end of basic block BB to buffer BUFFER indented by INDENT    spaces.  */
end_comment

begin_function
specifier|static
name|void
name|dump_bb_end
parameter_list|(
name|pretty_printer
modifier|*
name|buffer
parameter_list|,
name|basic_block
name|bb
parameter_list|,
name|int
name|indent
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|INDENT
argument_list|(
name|indent
argument_list|)
expr_stmt|;
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"# SUCC:"
argument_list|)
expr_stmt|;
name|pp_write_text_to_stream
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
if|if
condition|(
name|flags
operator|&
name|TDF_SLIM
condition|)
block|{
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|dest
operator|==
name|EXIT_BLOCK_PTR
condition|)
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"EXIT"
argument_list|)
expr_stmt|;
else|else
name|pp_decimal_int
argument_list|(
name|buffer
argument_list|,
name|e
operator|->
name|dest
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
else|else
name|dump_edge_info
argument_list|(
name|buffer
operator|->
name|buffer
operator|->
name|stream
argument_list|,
name|e
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pp_newline
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dumps phi nodes of basic block BB to buffer BUFFER with details described by    FLAGS indented by INDENT spaces.  */
end_comment

begin_function
specifier|static
name|void
name|dump_phi_nodes
parameter_list|(
name|pretty_printer
modifier|*
name|buffer
parameter_list|,
name|basic_block
name|bb
parameter_list|,
name|int
name|indent
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|tree
name|phi
init|=
name|phi_nodes
argument_list|(
name|bb
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|phi
condition|)
return|return;
for|for
control|(
init|;
name|phi
condition|;
name|phi
operator|=
name|PHI_CHAIN
argument_list|(
name|phi
argument_list|)
control|)
block|{
if|if
condition|(
name|is_gimple_reg
argument_list|(
name|PHI_RESULT
argument_list|(
name|phi
argument_list|)
argument_list|)
operator|||
operator|(
name|flags
operator|&
name|TDF_VOPS
operator|)
condition|)
block|{
name|INDENT
argument_list|(
name|indent
argument_list|)
expr_stmt|;
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"# "
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|phi
argument_list|,
name|indent
argument_list|,
name|flags
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|pp_newline
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Dump jump to basic block BB that is represented implicitly in the cfg    to BUFFER.  */
end_comment

begin_function
specifier|static
name|void
name|pp_cfg_jump
parameter_list|(
name|pretty_printer
modifier|*
name|buffer
parameter_list|,
name|basic_block
name|bb
parameter_list|)
block|{
name|tree
name|stmt
decl_stmt|;
name|stmt
operator|=
name|first_stmt
argument_list|(
name|bb
argument_list|)
expr_stmt|;
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"goto<bb "
argument_list|)
expr_stmt|;
name|pp_decimal_int
argument_list|(
name|buffer
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|">"
argument_list|)
expr_stmt|;
if|if
condition|(
name|stmt
operator|&&
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|LABEL_EXPR
condition|)
block|{
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|" ("
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|LABEL_EXPR_LABEL
argument_list|(
name|stmt
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
name|pp_semicolon
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dump edges represented implicitly in basic block BB to BUFFER, indented    by INDENT spaces, with details given by FLAGS.  */
end_comment

begin_function
specifier|static
name|void
name|dump_implicit_edges
parameter_list|(
name|pretty_printer
modifier|*
name|buffer
parameter_list|,
name|basic_block
name|bb
parameter_list|,
name|int
name|indent
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
comment|/* If there is a fallthru edge, we may need to add an artificial goto to the      dump.  */
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
condition|)
break|break;
if|if
condition|(
name|e
operator|&&
name|e
operator|->
name|dest
operator|!=
name|bb
operator|->
name|next_bb
condition|)
block|{
name|INDENT
argument_list|(
name|indent
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|TDF_LINENO
operator|)
ifdef|#
directive|ifdef
name|USE_MAPPED_LOCATION
operator|&&
name|e
operator|->
name|goto_locus
operator|!=
name|UNKNOWN_LOCATION
else|#
directive|else
operator|&&
name|e
operator|->
name|goto_locus
endif|#
directive|endif
condition|)
block|{
name|expanded_location
name|goto_xloc
decl_stmt|;
ifdef|#
directive|ifdef
name|USE_MAPPED_LOCATION
name|goto_xloc
operator|=
name|expand_location
argument_list|(
name|e
operator|->
name|goto_locus
argument_list|)
expr_stmt|;
else|#
directive|else
name|goto_xloc
operator|=
operator|*
name|e
operator|->
name|goto_locus
expr_stmt|;
endif|#
directive|endif
name|pp_character
argument_list|(
name|buffer
argument_list|,
literal|'['
argument_list|)
expr_stmt|;
if|if
condition|(
name|goto_xloc
operator|.
name|file
condition|)
block|{
name|pp_string
argument_list|(
name|buffer
argument_list|,
name|goto_xloc
operator|.
name|file
argument_list|)
expr_stmt|;
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|" : "
argument_list|)
expr_stmt|;
block|}
name|pp_decimal_int
argument_list|(
name|buffer
argument_list|,
name|goto_xloc
operator|.
name|line
argument_list|)
expr_stmt|;
name|pp_string
argument_list|(
name|buffer
argument_list|,
literal|"] "
argument_list|)
expr_stmt|;
block|}
name|pp_cfg_jump
argument_list|(
name|buffer
argument_list|,
name|e
operator|->
name|dest
argument_list|)
expr_stmt|;
name|pp_newline
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Dumps basic block BB to buffer BUFFER with details described by FLAGS and    indented by INDENT spaces.  */
end_comment

begin_function
specifier|static
name|void
name|dump_generic_bb_buff
parameter_list|(
name|pretty_printer
modifier|*
name|buffer
parameter_list|,
name|basic_block
name|bb
parameter_list|,
name|int
name|indent
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|block_stmt_iterator
name|bsi
decl_stmt|;
name|tree
name|stmt
decl_stmt|;
name|int
name|label_indent
init|=
name|indent
operator|-
literal|2
decl_stmt|;
if|if
condition|(
name|label_indent
operator|<
literal|0
condition|)
name|label_indent
operator|=
literal|0
expr_stmt|;
name|dump_bb_header
argument_list|(
name|buffer
argument_list|,
name|bb
argument_list|,
name|indent
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|dump_phi_nodes
argument_list|(
name|buffer
argument_list|,
name|bb
argument_list|,
name|indent
argument_list|,
name|flags
argument_list|)
expr_stmt|;
for|for
control|(
name|bsi
operator|=
name|bsi_start
argument_list|(
name|bb
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|;
name|bsi_next
argument_list|(
operator|&
name|bsi
argument_list|)
control|)
block|{
name|int
name|curr_indent
decl_stmt|;
name|stmt
operator|=
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
expr_stmt|;
name|curr_indent
operator|=
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|LABEL_EXPR
condition|?
name|label_indent
else|:
name|indent
expr_stmt|;
name|INDENT
argument_list|(
name|curr_indent
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|buffer
argument_list|,
name|stmt
argument_list|,
name|curr_indent
argument_list|,
name|flags
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|pp_newline
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
name|dump_implicit_edges
argument_list|(
name|buffer
argument_list|,
name|bb
argument_list|,
name|indent
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|TDF_BLOCKS
condition|)
name|dump_bb_end
argument_list|(
name|buffer
argument_list|,
name|bb
argument_list|,
name|indent
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

