begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Instruction scheduling pass.    Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2000, 2001, 2002 Free Software Foundation, Inc.    Contributed by Michael Tiemann (tiemann@cygnus.com) Enhanced by,    and currently maintained by, Jim Wilson (wilson@cygnus.com)  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* Instruction scheduling pass.  This file, along with sched-deps.c,    contains the generic parts.  The actual entry point is found for    the normal instruction scheduling pass is found in sched-rgn.c.     We compute insn priorities based on data dependencies.  Flow    analysis only creates a fraction of the data-dependencies we must    observe: namely, only those dependencies which the combiner can be    expected to use.  For this pass, we must therefore create the    remaining dependencies we need to observe: register dependencies,    memory dependencies, dependencies to keep function calls in order,    and the dependence between a conditional branch and the setting of    condition codes are all dealt with here.     The scheduler first traverses the data flow graph, starting with    the last instruction, and proceeding to the first, assigning values    to insn_priority as it goes.  This sorts the instructions    topologically by data dependence.     Once priorities have been established, we order the insns using    list scheduling.  This works as follows: starting with a list of    all the ready insns, and sorted according to priority number, we    schedule the insn from the end of the list by placing its    predecessors in the list according to their priority order.  We    consider this insn scheduled by setting the pointer to the "end" of    the list to point to the previous insn.  When an insn has no    predecessors, we either queue it until sufficient time has elapsed    or add it to the ready list.  As the instructions are scheduled or    when stalls are introduced, the queue advances and dumps insns into    the ready list.  When all insns down to the lowest priority have    been scheduled, the critical path of the basic block has been made    as short as possible.  The remaining insns are then scheduled in    remaining slots.     Function unit conflicts are resolved during forward list scheduling    by tracking the time when each insn is committed to the schedule    and from that, the time the function units it uses must be free.    As insns on the ready list are considered for scheduling, those    that would result in a blockage of the already committed insns are    queued until no blockage will result.     The following list shows the order in which we want to break ties    among insns in the ready list:     1.  choose insn with the longest path to end of bb, ties    broken by    2.  choose insn with least contribution to register pressure,    ties broken by    3.  prefer in-block upon interblock motion, ties broken by    4.  prefer useful upon speculative motion, ties broken by    5.  choose insn with largest control flow probability, ties    broken by    6.  choose insn with the least dependences upon the previously    scheduled insn, or finally    7   choose the insn which has the most insns dependent on it.    8.  choose insn with lowest UID.     Memory references complicate matters.  Only if we can be certain    that memory references are not part of the data dependency graph    (via true, anti, or output dependence), can we move operations past    memory references.  To first approximation, reads can be done    independently, while writes introduce dependencies.  Better    approximations will yield fewer dependencies.     Before reload, an extended analysis of interblock data dependences    is required for interblock scheduling.  This is performed in    compute_block_backward_dependences ().     Dependencies set up by memory references are treated in exactly the    same way as other dependencies, by using LOG_LINKS backward    dependences.  LOG_LINKS are translated into INSN_DEPEND forward    dependences for the purpose of forward list scheduling.     Having optimized the critical path, we may have also unduly    extended the lifetimes of some registers.  If an operation requires    that constants be loaded into registers, it is certainly desirable    to load those constants as early as necessary, but no earlier.    I.e., it will not do to load up a bunch of registers at the    beginning of a basic block only to use them at the end, if they    could be loaded later, since this may result in excessive register    utilization.     Note that since branches are never in basic blocks, but only end    basic blocks, this pass will not move branches.  But that is ok,    since we can use GNU's delayed branch scheduling pass to take care    of this case.     Also note that no further optimizations based on algebraic    identities are performed, so this pass would be a good one to    perform instruction splitting, such as breaking up a multiply    instruction into shifts and adds where that is profitable.     Given the memory aliasing analysis that this pass should perform,    it should be possible to remove redundant stores to memory, and to    load values from registers instead of hitting memory.     Before reload, speculative insns are moved only if a 'proof' exists    that no exception will be caused by this, and if no live registers    exist that inhibit the motion (live registers constraints are not    represented by data dependence edges).     This pass must update information that subsequent passes expect to    be correct.  Namely: reg_n_refs, reg_n_sets, reg_n_deaths,    reg_n_calls_crossed, and reg_live_length.  Also, BLOCK_HEAD,    BLOCK_END.     The information in the line number notes is carefully retained by    this pass.  Notes that refer to the starting and ending of    exception regions are also carefully retained by this pass.  All    other NOTE insns are grouped in their same relative order at the    beginning of basic blocks and regions that have been scheduled.  */
end_comment

begin_escape
end_escape

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"insn-attr.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"sched-int.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INSN_SCHEDULING
end_ifdef

begin_comment
comment|/* issue_rate is the number of insns that can be scheduled in the same    machine cycle.  It can be defined in the config/mach/mach.h file,    otherwise we set it to 1.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|issue_rate
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* sched-verbose controls the amount of debugging output the    scheduler prints.  It is controlled by -fsched-verbose=N:    N>0 and no -DSR : the output is directed to stderr.    N>=10 will direct the printouts to stderr (regardless of -dSR).    N=1: same as -dSR.    N=2: bb's probabilities, detailed ready list info, unit/insn info.    N=3: rtl at abort point, control-flow, regions info.    N=5: dependences info.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|sched_verbose_param
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|sched_verbose
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Debugging file.  All printouts are sent to dump, which is always set,    either to stderr, or to the dump listing file (-dRS).  */
end_comment

begin_decl_stmt
name|FILE
modifier|*
name|sched_dump
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Highest uid before scheduling.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|old_max_uid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* fix_sched_param() is called from toplev.c upon detection    of the -fsched-verbose=N option.  */
end_comment

begin_function
name|void
name|fix_sched_param
parameter_list|(
name|param
parameter_list|,
name|val
parameter_list|)
specifier|const
name|char
modifier|*
name|param
decl_stmt|,
decl|*
name|val
decl_stmt|;
end_function

begin_block
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|param
argument_list|,
literal|"verbose"
argument_list|)
condition|)
name|sched_verbose_param
operator|=
name|atoi
argument_list|(
name|val
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
literal|"fix_sched_param: unknown param: %s"
argument_list|,
name|param
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|struct
name|haifa_insn_data
modifier|*
name|h_i_d
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|DONE_PRIORITY
value|-1
end_define

begin_define
define|#
directive|define
name|MAX_PRIORITY
value|0x7fffffff
end_define

begin_define
define|#
directive|define
name|TAIL_PRIORITY
value|0x7ffffffe
end_define

begin_define
define|#
directive|define
name|LAUNCH_PRIORITY
value|0x7f000001
end_define

begin_define
define|#
directive|define
name|DONE_PRIORITY_P
parameter_list|(
name|INSN
parameter_list|)
value|(INSN_PRIORITY (INSN)< 0)
end_define

begin_define
define|#
directive|define
name|LOW_PRIORITY_P
parameter_list|(
name|INSN
parameter_list|)
value|((INSN_PRIORITY (INSN)& 0x7f000000) == 0)
end_define

begin_define
define|#
directive|define
name|LINE_NOTE
parameter_list|(
name|INSN
parameter_list|)
value|(h_i_d[INSN_UID (INSN)].line_note)
end_define

begin_define
define|#
directive|define
name|INSN_TICK
parameter_list|(
name|INSN
parameter_list|)
value|(h_i_d[INSN_UID (INSN)].tick)
end_define

begin_comment
comment|/* Vector indexed by basic block number giving the starting line-number    for each basic block.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
modifier|*
name|line_note_head
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List of important notes we must keep around.  This is a pointer to the    last element in the list.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|note_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Queues, etc.  */
end_comment

begin_comment
comment|/* An instruction is ready to be scheduled when all insns preceding it    have already been scheduled.  It is important to ensure that all    insns which use its result will not be executed until its result    has been computed.  An insn is maintained in one of four structures:     (P) the "Pending" set of insns which cannot be scheduled until    their dependencies have been satisfied.    (Q) the "Queued" set of insns that can be scheduled when sufficient    time has passed.    (R) the "Ready" list of unscheduled, uncommitted insns.    (S) the "Scheduled" list of insns.     Initially, all insns are either "Pending" or "Ready" depending on    whether their dependencies are satisfied.     Insns move from the "Ready" list to the "Scheduled" list as they    are committed to the schedule.  As this occurs, the insns in the    "Pending" list have their dependencies satisfied and move to either    the "Ready" list or the "Queued" set depending on whether    sufficient time has passed to make them ready.  As time passes,    insns move from the "Queued" set to the "Ready" list.  Insns may    move from the "Ready" list to the "Queued" set if they are blocked    due to a function unit conflict.     The "Pending" list (P) are the insns in the INSN_DEPEND of the unscheduled    insns, i.e., those that are ready, queued, and pending.    The "Queued" set (Q) is implemented by the variable `insn_queue'.    The "Ready" list (R) is implemented by the variables `ready' and    `n_ready'.    The "Scheduled" list (S) is the new insn chain built by this pass.     The transition (R->S) is implemented in the scheduling loop in    `schedule_block' when the best insn to schedule is chosen.    The transition (R->Q) is implemented in `queue_insn' when an    insn is found to have a function unit conflict with the already    committed insns.    The transitions (P->R and P->Q) are implemented in `schedule_insn' as    insns move from the ready list to the scheduled list.    The transition (Q->R) is implemented in 'queue_to_insn' as time    passes or stalls are introduced.  */
end_comment

begin_comment
comment|/* Implement a circular buffer to delay instructions until sufficient    time has passed.  INSN_QUEUE_SIZE is a power of two larger than    MAX_BLOCKAGE and MAX_READY_COST computed by genattr.c.  This is the    longest time an isnsn may be queued.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|insn_queue
index|[
name|INSN_QUEUE_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|q_ptr
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|q_size
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NEXT_Q
parameter_list|(
name|X
parameter_list|)
value|(((X)+1)& (INSN_QUEUE_SIZE-1))
end_define

begin_define
define|#
directive|define
name|NEXT_Q_AFTER
parameter_list|(
name|X
parameter_list|,
name|C
parameter_list|)
value|(((X)+C)& (INSN_QUEUE_SIZE-1))
end_define

begin_comment
comment|/* Describe the ready list of the scheduler.    VEC holds space enough for all insns in the current region.  VECLEN    says how many exactly.    FIRST is the index of the element with the highest priority; i.e. the    last one in the ready list, since elements are ordered by ascending    priority.    N_READY determines how many insns are on the ready list.  */
end_comment

begin_struct
struct|struct
name|ready_list
block|{
name|rtx
modifier|*
name|vec
decl_stmt|;
name|int
name|veclen
decl_stmt|;
name|int
name|first
decl_stmt|;
name|int
name|n_ready
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Forward declarations.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|blockage_range
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|clear_units
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|schedule_unit
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|actual_hazard
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|rtx
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|potential_hazard
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|priority
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|rank_for_schedule
name|PARAMS
argument_list|(
operator|(
specifier|const
name|PTR
operator|,
specifier|const
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|swap_sort
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|queue_insn
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|schedule_insn
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
expr|struct
name|ready_list
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|find_insn_reg_weight
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|adjust_priority
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Notes handling mechanism:    =========================    Generally, NOTES are saved before scheduling and restored after scheduling.    The scheduler distinguishes between three types of notes:     (1) LINE_NUMBER notes, generated and used for debugging.  Here,    before scheduling a region, a pointer to the LINE_NUMBER note is    added to the insn following it (in save_line_notes()), and the note    is removed (in rm_line_notes() and unlink_line_notes()).  After    scheduling the region, this pointer is used for regeneration of    the LINE_NUMBER note (in restore_line_notes()).     (2) LOOP_BEGIN, LOOP_END, SETJMP, EHREGION_BEG, EHREGION_END notes:    Before scheduling a region, a pointer to the note is added to the insn    that follows or precedes it.  (This happens as part of the data dependence    computation).  After scheduling an insn, the pointer contained in it is    used for regenerating the corresponding note (in reemit_notes).     (3) All other notes (e.g. INSN_DELETED):  Before scheduling a block,    these notes are put in a list (in rm_other_notes() and    unlink_other_notes ()).  After scheduling the block, these notes are    inserted at the beginning of the block (in schedule_block()).  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|unlink_other_notes
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|unlink_line_notes
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|reemit_notes
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
modifier|*
name|ready_lastpos
name|PARAMS
argument_list|(
operator|(
expr|struct
name|ready_list
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ready_sort
name|PARAMS
argument_list|(
operator|(
expr|struct
name|ready_list
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|ready_remove_first
name|PARAMS
argument_list|(
operator|(
expr|struct
name|ready_list
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|queue_to_ready
name|PARAMS
argument_list|(
operator|(
expr|struct
name|ready_list
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|debug_ready_list
name|PARAMS
argument_list|(
operator|(
expr|struct
name|ready_list
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|move_insn1
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|move_insn
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INSN_SCHEDULING */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Point to state used for the current scheduling pass.  */
end_comment

begin_decl_stmt
name|struct
name|sched_info
modifier|*
name|current_sched_info
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_ifndef
ifndef|#
directive|ifndef
name|INSN_SCHEDULING
end_ifndef

begin_function
name|void
name|schedule_insns
parameter_list|(
name|dump_file
parameter_list|)
name|FILE
modifier|*
name|dump_file
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{ }
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* Pointer to the last instruction scheduled.  Used by rank_for_schedule,    so that insns independent of the last scheduled insn will be preferred    over dependent instructions.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|last_scheduled_insn
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Compute the function units used by INSN.  This caches the value    returned by function_units_used.  A function unit is encoded as the    unit number if the value is non-negative and the compliment of a    mask if the value is negative.  A function unit index is the    non-negative encoding.  */
end_comment

begin_function
name|HAIFA_INLINE
name|int
name|insn_unit
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|int
name|unit
init|=
name|INSN_UNIT
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|unit
operator|==
literal|0
condition|)
block|{
name|recog_memoized
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* A USE insn, or something else we don't need to understand.          We can't pass these directly to function_units_used because it will          trigger a fatal error for unrecognizable insns.  */
if|if
condition|(
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|<
literal|0
condition|)
name|unit
operator|=
operator|-
literal|1
expr_stmt|;
else|else
block|{
name|unit
operator|=
name|function_units_used
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Increment non-negative values so we can cache zero.  */
if|if
condition|(
name|unit
operator|>=
literal|0
condition|)
name|unit
operator|++
expr_stmt|;
block|}
comment|/* We only cache 16 bits of the result, so if the value is out of          range, don't cache it.  */
if|if
condition|(
name|FUNCTION_UNITS_SIZE
operator|<
name|HOST_BITS_PER_SHORT
operator|||
name|unit
operator|>=
literal|0
operator|||
operator|(
name|unit
operator|&
operator|~
operator|(
operator|(
literal|1
operator|<<
operator|(
name|HOST_BITS_PER_SHORT
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
condition|)
name|INSN_UNIT
argument_list|(
name|insn
argument_list|)
operator|=
name|unit
expr_stmt|;
block|}
return|return
operator|(
name|unit
operator|>
literal|0
condition|?
name|unit
operator|-
literal|1
else|:
name|unit
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Compute the blockage range for executing INSN on UNIT.  This caches    the value returned by the blockage_range_function for the unit.    These values are encoded in an int where the upper half gives the    minimum value and the lower half gives the maximum value.  */
end_comment

begin_function
name|HAIFA_INLINE
specifier|static
name|unsigned
name|int
name|blockage_range
parameter_list|(
name|unit
parameter_list|,
name|insn
parameter_list|)
name|int
name|unit
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
name|unsigned
name|int
name|blockage
init|=
name|INSN_BLOCKAGE
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|range
decl_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|UNIT_BLOCKED
argument_list|(
name|blockage
argument_list|)
operator|!=
name|unit
operator|+
literal|1
condition|)
block|{
name|range
operator|=
name|function_units
index|[
name|unit
index|]
operator|.
name|blockage_range_function
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* We only cache the blockage range for one unit and then only if          the values fit.  */
if|if
condition|(
name|HOST_BITS_PER_INT
operator|>=
name|UNIT_BITS
operator|+
literal|2
operator|*
name|BLOCKAGE_BITS
condition|)
name|INSN_BLOCKAGE
argument_list|(
name|insn
argument_list|)
operator|=
name|ENCODE_BLOCKAGE
argument_list|(
name|unit
operator|+
literal|1
argument_list|,
name|range
argument_list|)
expr_stmt|;
block|}
else|else
name|range
operator|=
name|BLOCKAGE_RANGE
argument_list|(
name|blockage
argument_list|)
expr_stmt|;
return|return
name|range
return|;
block|}
end_function

begin_comment
comment|/* A vector indexed by function unit instance giving the last insn to use    the unit.  The value of the function unit instance index for unit U    instance I is (U + I * FUNCTION_UNITS_SIZE).  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|unit_last_insn
index|[
name|FUNCTION_UNITS_SIZE
operator|*
name|MAX_MULTIPLICITY
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A vector indexed by function unit instance giving the minimum time when    the unit will unblock based on the maximum blockage cost.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|unit_tick
index|[
name|FUNCTION_UNITS_SIZE
operator|*
name|MAX_MULTIPLICITY
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A vector indexed by function unit number giving the number of insns    that remain to use the unit.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|unit_n_insns
index|[
name|FUNCTION_UNITS_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Access the unit_last_insn array.  Used by the visualization code.  */
end_comment

begin_function
name|rtx
name|get_unit_last_insn
parameter_list|(
name|instance
parameter_list|)
name|int
name|instance
decl_stmt|;
block|{
return|return
name|unit_last_insn
index|[
name|instance
index|]
return|;
block|}
end_function

begin_comment
comment|/* Reset the function unit state to the null state.  */
end_comment

begin_function
specifier|static
name|void
name|clear_units
parameter_list|()
block|{
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|unit_last_insn
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|unit_last_insn
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|unit_tick
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|unit_tick
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|unit_n_insns
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|unit_n_insns
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the issue-delay of an insn.  */
end_comment

begin_function
name|HAIFA_INLINE
name|int
name|insn_issue_delay
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|delay
init|=
literal|0
decl_stmt|;
name|int
name|unit
init|=
name|insn_unit
argument_list|(
name|insn
argument_list|)
decl_stmt|;
comment|/* Efficiency note: in fact, we are working 'hard' to compute a      value that was available in md file, and is not available in      function_units[] structure.  It would be nice to have this      value there, too.  */
if|if
condition|(
name|unit
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|function_units
index|[
name|unit
index|]
operator|.
name|blockage_range_function
operator|&&
name|function_units
index|[
name|unit
index|]
operator|.
name|blockage_function
condition|)
name|delay
operator|=
name|function_units
index|[
name|unit
index|]
operator|.
name|blockage_function
argument_list|(
name|insn
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
else|else
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|unit
operator|=
operator|~
name|unit
init|;
name|unit
condition|;
name|i
operator|++
operator|,
name|unit
operator|>>=
literal|1
control|)
if|if
condition|(
operator|(
name|unit
operator|&
literal|1
operator|)
operator|!=
literal|0
operator|&&
name|function_units
index|[
name|i
index|]
operator|.
name|blockage_range_function
operator|&&
name|function_units
index|[
name|i
index|]
operator|.
name|blockage_function
condition|)
name|delay
operator|=
name|MAX
argument_list|(
name|delay
argument_list|,
name|function_units
index|[
name|i
index|]
operator|.
name|blockage_function
argument_list|(
name|insn
argument_list|,
name|insn
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|delay
return|;
block|}
end_function

begin_comment
comment|/* Return the actual hazard cost of executing INSN on the unit UNIT,    instance INSTANCE at time CLOCK if the previous actual hazard cost    was COST.  */
end_comment

begin_function
name|HAIFA_INLINE
name|int
name|actual_hazard_this_instance
parameter_list|(
name|unit
parameter_list|,
name|instance
parameter_list|,
name|insn
parameter_list|,
name|clock
parameter_list|,
name|cost
parameter_list|)
name|int
name|unit
decl_stmt|,
name|instance
decl_stmt|,
name|clock
decl_stmt|,
name|cost
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
name|int
name|tick
init|=
name|unit_tick
index|[
name|instance
index|]
decl_stmt|;
comment|/* Issue time of the last issued insn.  */
if|if
condition|(
name|tick
operator|-
name|clock
operator|>
name|cost
condition|)
block|{
comment|/* The scheduler is operating forward, so unit's last insn is the          executing insn and INSN is the candidate insn.  We want a          more exact measure of the blockage if we execute INSN at CLOCK          given when we committed the execution of the unit's last insn.           The blockage value is given by either the unit's max blockage          constant, blockage range function, or blockage function.  Use          the most exact form for the given unit.  */
if|if
condition|(
name|function_units
index|[
name|unit
index|]
operator|.
name|blockage_range_function
condition|)
block|{
if|if
condition|(
name|function_units
index|[
name|unit
index|]
operator|.
name|blockage_function
condition|)
name|tick
operator|+=
operator|(
name|function_units
index|[
name|unit
index|]
operator|.
name|blockage_function
argument_list|(
name|unit_last_insn
index|[
name|instance
index|]
argument_list|,
name|insn
argument_list|)
operator|-
name|function_units
index|[
name|unit
index|]
operator|.
name|max_blockage
operator|)
expr_stmt|;
else|else
name|tick
operator|+=
operator|(
operator|(
name|int
operator|)
name|MAX_BLOCKAGE_COST
argument_list|(
name|blockage_range
argument_list|(
name|unit
argument_list|,
name|insn
argument_list|)
argument_list|)
operator|-
name|function_units
index|[
name|unit
index|]
operator|.
name|max_blockage
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|tick
operator|-
name|clock
operator|>
name|cost
condition|)
name|cost
operator|=
name|tick
operator|-
name|clock
expr_stmt|;
block|}
return|return
name|cost
return|;
block|}
end_function

begin_comment
comment|/* Record INSN as having begun execution on the units encoded by UNIT at    time CLOCK.  */
end_comment

begin_function
name|HAIFA_INLINE
specifier|static
name|void
name|schedule_unit
parameter_list|(
name|unit
parameter_list|,
name|insn
parameter_list|,
name|clock
parameter_list|)
name|int
name|unit
decl_stmt|,
name|clock
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
literal|0
condition|)
block|{
name|int
name|instance
init|=
name|unit
decl_stmt|;
if|#
directive|if
name|MAX_MULTIPLICITY
operator|>
literal|1
comment|/* Find the first free instance of the function unit and use that          one.  We assume that one is free.  */
for|for
control|(
name|i
operator|=
name|function_units
index|[
name|unit
index|]
operator|.
name|multiplicity
operator|-
literal|1
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
operator|!
name|actual_hazard_this_instance
argument_list|(
name|unit
argument_list|,
name|instance
argument_list|,
name|insn
argument_list|,
name|clock
argument_list|,
literal|0
argument_list|)
condition|)
break|break;
name|instance
operator|+=
name|FUNCTION_UNITS_SIZE
expr_stmt|;
block|}
endif|#
directive|endif
name|unit_last_insn
index|[
name|instance
index|]
operator|=
name|insn
expr_stmt|;
name|unit_tick
index|[
name|instance
index|]
operator|=
operator|(
name|clock
operator|+
name|function_units
index|[
name|unit
index|]
operator|.
name|max_blockage
operator|)
expr_stmt|;
block|}
else|else
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|unit
operator|=
operator|~
name|unit
init|;
name|unit
condition|;
name|i
operator|++
operator|,
name|unit
operator|>>=
literal|1
control|)
if|if
condition|(
operator|(
name|unit
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
name|schedule_unit
argument_list|(
name|i
argument_list|,
name|insn
argument_list|,
name|clock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the actual hazard cost of executing INSN on the units encoded by    UNIT at time CLOCK if the previous actual hazard cost was COST.  */
end_comment

begin_function
name|HAIFA_INLINE
specifier|static
name|int
name|actual_hazard
parameter_list|(
name|unit
parameter_list|,
name|insn
parameter_list|,
name|clock
parameter_list|,
name|cost
parameter_list|)
name|int
name|unit
decl_stmt|,
name|clock
decl_stmt|,
name|cost
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
literal|0
condition|)
block|{
comment|/* Find the instance of the function unit with the minimum hazard.  */
name|int
name|instance
init|=
name|unit
decl_stmt|;
name|int
name|best_cost
init|=
name|actual_hazard_this_instance
argument_list|(
name|unit
argument_list|,
name|instance
argument_list|,
name|insn
argument_list|,
name|clock
argument_list|,
name|cost
argument_list|)
decl_stmt|;
if|#
directive|if
name|MAX_MULTIPLICITY
operator|>
literal|1
name|int
name|this_cost
decl_stmt|;
if|if
condition|(
name|best_cost
operator|>
name|cost
condition|)
block|{
for|for
control|(
name|i
operator|=
name|function_units
index|[
name|unit
index|]
operator|.
name|multiplicity
operator|-
literal|1
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|instance
operator|+=
name|FUNCTION_UNITS_SIZE
expr_stmt|;
name|this_cost
operator|=
name|actual_hazard_this_instance
argument_list|(
name|unit
argument_list|,
name|instance
argument_list|,
name|insn
argument_list|,
name|clock
argument_list|,
name|cost
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_cost
operator|<
name|best_cost
condition|)
block|{
name|best_cost
operator|=
name|this_cost
expr_stmt|;
if|if
condition|(
name|this_cost
operator|<=
name|cost
condition|)
break|break;
block|}
block|}
block|}
endif|#
directive|endif
name|cost
operator|=
name|MAX
argument_list|(
name|cost
argument_list|,
name|best_cost
argument_list|)
expr_stmt|;
block|}
else|else
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|unit
operator|=
operator|~
name|unit
init|;
name|unit
condition|;
name|i
operator|++
operator|,
name|unit
operator|>>=
literal|1
control|)
if|if
condition|(
operator|(
name|unit
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
name|cost
operator|=
name|actual_hazard
argument_list|(
name|i
argument_list|,
name|insn
argument_list|,
name|clock
argument_list|,
name|cost
argument_list|)
expr_stmt|;
return|return
name|cost
return|;
block|}
end_function

begin_comment
comment|/* Return the potential hazard cost of executing an instruction on the    units encoded by UNIT if the previous potential hazard cost was COST.    An insn with a large blockage time is chosen in preference to one    with a smaller time; an insn that uses a unit that is more likely    to be used is chosen in preference to one with a unit that is less    used.  We are trying to minimize a subsequent actual hazard.  */
end_comment

begin_function
name|HAIFA_INLINE
specifier|static
name|int
name|potential_hazard
parameter_list|(
name|unit
parameter_list|,
name|insn
parameter_list|,
name|cost
parameter_list|)
name|int
name|unit
decl_stmt|,
name|cost
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|ncost
decl_stmt|;
name|unsigned
name|int
name|minb
decl_stmt|,
name|maxb
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
literal|0
condition|)
block|{
name|minb
operator|=
name|maxb
operator|=
name|function_units
index|[
name|unit
index|]
operator|.
name|max_blockage
expr_stmt|;
if|if
condition|(
name|maxb
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|function_units
index|[
name|unit
index|]
operator|.
name|blockage_range_function
condition|)
block|{
name|maxb
operator|=
name|minb
operator|=
name|blockage_range
argument_list|(
name|unit
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|maxb
operator|=
name|MAX_BLOCKAGE_COST
argument_list|(
name|maxb
argument_list|)
expr_stmt|;
name|minb
operator|=
name|MIN_BLOCKAGE_COST
argument_list|(
name|minb
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|maxb
operator|>
literal|1
condition|)
block|{
comment|/* Make the number of instructions left dominate.  Make the 	         minimum delay dominate the maximum delay.  If all these 	         are the same, use the unit number to add an arbitrary 	         ordering.  Other terms can be added.  */
name|ncost
operator|=
name|minb
operator|*
literal|0x40
operator|+
name|maxb
expr_stmt|;
name|ncost
operator|*=
operator|(
name|unit_n_insns
index|[
name|unit
index|]
operator|-
literal|1
operator|)
operator|*
literal|0x1000
operator|+
name|unit
expr_stmt|;
if|if
condition|(
name|ncost
operator|>
name|cost
condition|)
name|cost
operator|=
name|ncost
expr_stmt|;
block|}
block|}
block|}
else|else
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|unit
operator|=
operator|~
name|unit
init|;
name|unit
condition|;
name|i
operator|++
operator|,
name|unit
operator|>>=
literal|1
control|)
if|if
condition|(
operator|(
name|unit
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
name|cost
operator|=
name|potential_hazard
argument_list|(
name|i
argument_list|,
name|insn
argument_list|,
name|cost
argument_list|)
expr_stmt|;
return|return
name|cost
return|;
block|}
end_function

begin_comment
comment|/* Compute cost of executing INSN given the dependence LINK on the insn USED.    This is the number of cycles between instruction issue and    instruction results.  */
end_comment

begin_function
name|HAIFA_INLINE
name|int
name|insn_cost
parameter_list|(
name|insn
parameter_list|,
name|link
parameter_list|,
name|used
parameter_list|)
name|rtx
name|insn
decl_stmt|,
name|link
decl_stmt|,
name|used
decl_stmt|;
block|{
name|int
name|cost
init|=
name|INSN_COST
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|cost
operator|==
literal|0
condition|)
block|{
name|recog_memoized
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* A USE insn, or something else we don't need to understand.          We can't pass these directly to result_ready_cost because it will          trigger a fatal error for unrecognizable insns.  */
if|if
condition|(
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|<
literal|0
condition|)
block|{
name|INSN_COST
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
block|{
name|cost
operator|=
name|result_ready_cost
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|cost
operator|<
literal|1
condition|)
name|cost
operator|=
literal|1
expr_stmt|;
name|INSN_COST
argument_list|(
name|insn
argument_list|)
operator|=
name|cost
expr_stmt|;
block|}
block|}
comment|/* In this case estimate cost without caring how insn is used.  */
if|if
condition|(
name|link
operator|==
literal|0
operator|&&
name|used
operator|==
literal|0
condition|)
return|return
name|cost
return|;
comment|/* A USE insn should never require the value used to be computed.  This      allows the computation of a function's result and parameter values to      overlap the return and call.  */
name|recog_memoized
argument_list|(
name|used
argument_list|)
expr_stmt|;
if|if
condition|(
name|INSN_CODE
argument_list|(
name|used
argument_list|)
operator|<
literal|0
condition|)
name|LINK_COST_FREE
argument_list|(
name|link
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* If some dependencies vary the cost, compute the adjustment.  Most      commonly, the adjustment is complete: either the cost is ignored      (in the case of an output- or anti-dependence), or the cost is      unchanged.  These values are cached in the link as LINK_COST_FREE      and LINK_COST_ZERO.  */
if|if
condition|(
name|LINK_COST_FREE
argument_list|(
name|link
argument_list|)
condition|)
name|cost
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|LINK_COST_ZERO
argument_list|(
name|link
argument_list|)
operator|&&
name|targetm
operator|.
name|sched
operator|.
name|adjust_cost
condition|)
block|{
name|int
name|ncost
init|=
call|(
modifier|*
name|targetm
operator|.
name|sched
operator|.
name|adjust_cost
call|)
argument_list|(
name|used
argument_list|,
name|link
argument_list|,
name|insn
argument_list|,
name|cost
argument_list|)
decl_stmt|;
if|if
condition|(
name|ncost
operator|<
literal|1
condition|)
block|{
name|LINK_COST_FREE
argument_list|(
name|link
argument_list|)
operator|=
literal|1
expr_stmt|;
name|ncost
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|cost
operator|==
name|ncost
condition|)
name|LINK_COST_ZERO
argument_list|(
name|link
argument_list|)
operator|=
literal|1
expr_stmt|;
name|cost
operator|=
name|ncost
expr_stmt|;
block|}
return|return
name|cost
return|;
block|}
end_function

begin_comment
comment|/* Compute the priority number for INSN.  */
end_comment

begin_function
specifier|static
name|int
name|priority
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|rtx
name|link
decl_stmt|;
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|INSN_PRIORITY_KNOWN
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|int
name|this_priority
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|INSN_DEPEND
argument_list|(
name|insn
argument_list|)
operator|==
literal|0
condition|)
name|this_priority
operator|=
name|insn_cost
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
for|for
control|(
name|link
operator|=
name|INSN_DEPEND
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|rtx
name|next
decl_stmt|;
name|int
name|next_priority
decl_stmt|;
if|if
condition|(
name|RTX_INTEGRATED_P
argument_list|(
name|link
argument_list|)
condition|)
continue|continue;
name|next
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Critical path is meaningful in block boundaries only.  */
if|if
condition|(
operator|!
call|(
modifier|*
name|current_sched_info
operator|->
name|contributes_to_priority
call|)
argument_list|(
name|next
argument_list|,
name|insn
argument_list|)
condition|)
continue|continue;
name|next_priority
operator|=
name|insn_cost
argument_list|(
name|insn
argument_list|,
name|link
argument_list|,
name|next
argument_list|)
operator|+
name|priority
argument_list|(
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_priority
operator|>
name|this_priority
condition|)
name|this_priority
operator|=
name|next_priority
expr_stmt|;
block|}
block|}
name|INSN_PRIORITY
argument_list|(
name|insn
argument_list|)
operator|=
name|this_priority
expr_stmt|;
name|INSN_PRIORITY_KNOWN
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|INSN_PRIORITY
argument_list|(
name|insn
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Macros and functions for keeping the priority queue sorted, and    dealing with queueing and dequeueing of instructions.  */
end_comment

begin_define
define|#
directive|define
name|SCHED_SORT
parameter_list|(
name|READY
parameter_list|,
name|N_READY
parameter_list|)
define|\
value|do { if ((N_READY) == 2)				             \        swap_sort (READY, N_READY);			             \      else if ((N_READY)> 2)                                         \          qsort (READY, N_READY, sizeof (rtx), rank_for_schedule); }  \ while (0)
end_define

begin_comment
comment|/* Returns a positive value if x is preferred; returns a negative value if    y is preferred.  Should never return 0, since that will make the sort    unstable.  */
end_comment

begin_function
specifier|static
name|int
name|rank_for_schedule
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
specifier|const
name|PTR
name|x
decl_stmt|;
specifier|const
name|PTR
name|y
decl_stmt|;
block|{
name|rtx
name|tmp
init|=
operator|*
operator|(
specifier|const
name|rtx
operator|*
operator|)
name|y
decl_stmt|;
name|rtx
name|tmp2
init|=
operator|*
operator|(
specifier|const
name|rtx
operator|*
operator|)
name|x
decl_stmt|;
name|rtx
name|link
decl_stmt|;
name|int
name|tmp_class
decl_stmt|,
name|tmp2_class
decl_stmt|,
name|depend_count1
decl_stmt|,
name|depend_count2
decl_stmt|;
name|int
name|val
decl_stmt|,
name|priority_val
decl_stmt|,
name|weight_val
decl_stmt|,
name|info_val
decl_stmt|;
comment|/* Prefer insn with higher priority.  */
name|priority_val
operator|=
name|INSN_PRIORITY
argument_list|(
name|tmp2
argument_list|)
operator|-
name|INSN_PRIORITY
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|priority_val
condition|)
return|return
name|priority_val
return|;
comment|/* Prefer an insn with smaller contribution to registers-pressure.  */
if|if
condition|(
operator|!
name|reload_completed
operator|&&
operator|(
name|weight_val
operator|=
name|INSN_REG_WEIGHT
argument_list|(
name|tmp
argument_list|)
operator|-
name|INSN_REG_WEIGHT
argument_list|(
name|tmp2
argument_list|)
operator|)
condition|)
return|return
operator|(
name|weight_val
operator|)
return|;
name|info_val
operator|=
call|(
modifier|*
name|current_sched_info
operator|->
name|rank
call|)
argument_list|(
name|tmp
argument_list|,
name|tmp2
argument_list|)
expr_stmt|;
if|if
condition|(
name|info_val
condition|)
return|return
name|info_val
return|;
comment|/* Compare insns based on their relation to the last-scheduled-insn.  */
if|if
condition|(
name|last_scheduled_insn
condition|)
block|{
comment|/* Classify the instructions into three classes:          1) Data dependent on last schedule insn.          2) Anti/Output dependent on last scheduled insn.          3) Independent of last scheduled insn, or has latency of one.          Choose the insn from the highest numbered class if different.  */
name|link
operator|=
name|find_insn_list
argument_list|(
name|tmp
argument_list|,
name|INSN_DEPEND
argument_list|(
name|last_scheduled_insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|link
operator|==
literal|0
operator|||
name|insn_cost
argument_list|(
name|last_scheduled_insn
argument_list|,
name|link
argument_list|,
name|tmp
argument_list|)
operator|==
literal|1
condition|)
name|tmp_class
operator|=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
literal|0
condition|)
comment|/* Data dependence.  */
name|tmp_class
operator|=
literal|1
expr_stmt|;
else|else
name|tmp_class
operator|=
literal|2
expr_stmt|;
name|link
operator|=
name|find_insn_list
argument_list|(
name|tmp2
argument_list|,
name|INSN_DEPEND
argument_list|(
name|last_scheduled_insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|link
operator|==
literal|0
operator|||
name|insn_cost
argument_list|(
name|last_scheduled_insn
argument_list|,
name|link
argument_list|,
name|tmp2
argument_list|)
operator|==
literal|1
condition|)
name|tmp2_class
operator|=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
literal|0
condition|)
comment|/* Data dependence.  */
name|tmp2_class
operator|=
literal|1
expr_stmt|;
else|else
name|tmp2_class
operator|=
literal|2
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|=
name|tmp2_class
operator|-
name|tmp_class
operator|)
condition|)
return|return
name|val
return|;
block|}
comment|/* Prefer the insn which has more later insns that depend on it.      This gives the scheduler more freedom when scheduling later      instructions at the expense of added register pressure.  */
name|depend_count1
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|link
operator|=
name|INSN_DEPEND
argument_list|(
name|tmp
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
name|depend_count1
operator|++
expr_stmt|;
name|depend_count2
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|link
operator|=
name|INSN_DEPEND
argument_list|(
name|tmp2
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
name|depend_count2
operator|++
expr_stmt|;
name|val
operator|=
name|depend_count2
operator|-
name|depend_count1
expr_stmt|;
if|if
condition|(
name|val
condition|)
return|return
name|val
return|;
comment|/* If insns are equally good, sort by INSN_LUID (original insn order),      so that we make the sort stable.  This minimizes instruction movement,      thus minimizing sched's effect on debugging and cross-jumping.  */
return|return
name|INSN_LUID
argument_list|(
name|tmp
argument_list|)
operator|-
name|INSN_LUID
argument_list|(
name|tmp2
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Resort the array A in which only element at index N may be out of order.  */
end_comment

begin_function
name|HAIFA_INLINE
specifier|static
name|void
name|swap_sort
parameter_list|(
name|a
parameter_list|,
name|n
parameter_list|)
name|rtx
modifier|*
name|a
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
name|rtx
name|insn
init|=
name|a
index|[
name|n
operator|-
literal|1
index|]
decl_stmt|;
name|int
name|i
init|=
name|n
operator|-
literal|2
decl_stmt|;
while|while
condition|(
name|i
operator|>=
literal|0
operator|&&
name|rank_for_schedule
argument_list|(
name|a
operator|+
name|i
argument_list|,
operator|&
name|insn
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|a
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|a
index|[
name|i
index|]
expr_stmt|;
name|i
operator|-=
literal|1
expr_stmt|;
block|}
name|a
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|insn
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add INSN to the insn queue so that it can be executed at least    N_CYCLES after the currently executing insn.  Preserve insns    chain for debugging purposes.  */
end_comment

begin_function
name|HAIFA_INLINE
specifier|static
name|void
name|queue_insn
parameter_list|(
name|insn
parameter_list|,
name|n_cycles
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|int
name|n_cycles
decl_stmt|;
block|{
name|int
name|next_q
init|=
name|NEXT_Q_AFTER
argument_list|(
name|q_ptr
argument_list|,
name|n_cycles
argument_list|)
decl_stmt|;
name|rtx
name|link
init|=
name|alloc_INSN_LIST
argument_list|(
name|insn
argument_list|,
name|insn_queue
index|[
name|next_q
index|]
argument_list|)
decl_stmt|;
name|insn_queue
index|[
name|next_q
index|]
operator|=
name|link
expr_stmt|;
name|q_size
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|sched_verbose
operator|>=
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|";;\t\tReady-->Q: insn %s: "
argument_list|,
call|(
modifier|*
name|current_sched_info
operator|->
name|print_insn
call|)
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|"queued for %d cycles.\n"
argument_list|,
name|n_cycles
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return a pointer to the bottom of the ready list, i.e. the insn    with the lowest priority.  */
end_comment

begin_function
name|HAIFA_INLINE
specifier|static
name|rtx
modifier|*
name|ready_lastpos
parameter_list|(
name|ready
parameter_list|)
name|struct
name|ready_list
modifier|*
name|ready
decl_stmt|;
block|{
if|if
condition|(
name|ready
operator|->
name|n_ready
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|ready
operator|->
name|vec
operator|+
name|ready
operator|->
name|first
operator|-
name|ready
operator|->
name|n_ready
operator|+
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Add an element INSN to the ready list so that it ends up with the lowest    priority.  */
end_comment

begin_function
name|HAIFA_INLINE
name|void
name|ready_add
parameter_list|(
name|ready
parameter_list|,
name|insn
parameter_list|)
name|struct
name|ready_list
modifier|*
name|ready
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
if|if
condition|(
name|ready
operator|->
name|first
operator|==
name|ready
operator|->
name|n_ready
condition|)
block|{
name|memmove
argument_list|(
name|ready
operator|->
name|vec
operator|+
name|ready
operator|->
name|veclen
operator|-
name|ready
operator|->
name|n_ready
argument_list|,
name|ready_lastpos
argument_list|(
name|ready
argument_list|)
argument_list|,
name|ready
operator|->
name|n_ready
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|ready
operator|->
name|first
operator|=
name|ready
operator|->
name|veclen
operator|-
literal|1
expr_stmt|;
block|}
name|ready
operator|->
name|vec
index|[
name|ready
operator|->
name|first
operator|-
name|ready
operator|->
name|n_ready
index|]
operator|=
name|insn
expr_stmt|;
name|ready
operator|->
name|n_ready
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Remove the element with the highest priority from the ready list and    return it.  */
end_comment

begin_function
name|HAIFA_INLINE
specifier|static
name|rtx
name|ready_remove_first
parameter_list|(
name|ready
parameter_list|)
name|struct
name|ready_list
modifier|*
name|ready
decl_stmt|;
block|{
name|rtx
name|t
decl_stmt|;
if|if
condition|(
name|ready
operator|->
name|n_ready
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|t
operator|=
name|ready
operator|->
name|vec
index|[
name|ready
operator|->
name|first
operator|--
index|]
expr_stmt|;
name|ready
operator|->
name|n_ready
operator|--
expr_stmt|;
comment|/* If the queue becomes empty, reset it.  */
if|if
condition|(
name|ready
operator|->
name|n_ready
operator|==
literal|0
condition|)
name|ready
operator|->
name|first
operator|=
name|ready
operator|->
name|veclen
operator|-
literal|1
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Sort the ready list READY by ascending priority, using the SCHED_SORT    macro.  */
end_comment

begin_function
name|HAIFA_INLINE
specifier|static
name|void
name|ready_sort
parameter_list|(
name|ready
parameter_list|)
name|struct
name|ready_list
modifier|*
name|ready
decl_stmt|;
block|{
name|rtx
modifier|*
name|first
init|=
name|ready_lastpos
argument_list|(
name|ready
argument_list|)
decl_stmt|;
name|SCHED_SORT
argument_list|(
name|first
argument_list|,
name|ready
operator|->
name|n_ready
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* PREV is an insn that is ready to execute.  Adjust its priority if that    will help shorten or lengthen register lifetimes as appropriate.  Also    provide a hook for the target to tweek itself.  */
end_comment

begin_function
name|HAIFA_INLINE
specifier|static
name|void
name|adjust_priority
parameter_list|(
name|prev
parameter_list|)
name|rtx
name|prev
decl_stmt|;
block|{
comment|/* ??? There used to be code here to try and estimate how an insn      affected register lifetimes, but it did it by looking at REG_DEAD      notes, which we removed in schedule_region.  Nor did it try to      take into account register pressure or anything useful like that.       Revisit when we have a machine model to work with and not before.  */
if|if
condition|(
name|targetm
operator|.
name|sched
operator|.
name|adjust_priority
condition|)
name|INSN_PRIORITY
argument_list|(
name|prev
argument_list|)
operator|=
call|(
modifier|*
name|targetm
operator|.
name|sched
operator|.
name|adjust_priority
call|)
argument_list|(
name|prev
argument_list|,
name|INSN_PRIORITY
argument_list|(
name|prev
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Clock at which the previous instruction was issued.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|last_clock_var
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* INSN is the "currently executing insn".  Launch each insn which was    waiting on INSN.  READY is the ready list which contains the insns    that are ready to fire.  CLOCK is the current cycle.    */
end_comment

begin_function
specifier|static
name|void
name|schedule_insn
parameter_list|(
name|insn
parameter_list|,
name|ready
parameter_list|,
name|clock
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|struct
name|ready_list
modifier|*
name|ready
decl_stmt|;
name|int
name|clock
decl_stmt|;
block|{
name|rtx
name|link
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|unit
operator|=
name|insn_unit
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|sched_verbose
operator|>=
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|";;\t\t--> scheduling insn<<<%d>>> on unit "
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|insn_print_units
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sched_verbose
operator|&&
name|unit
operator|==
operator|-
literal|1
condition|)
name|visualize_no_unit
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|MAX_BLOCKAGE
operator|>
literal|1
operator|||
name|issue_rate
operator|>
literal|1
operator|||
name|sched_verbose
condition|)
name|schedule_unit
argument_list|(
name|unit
argument_list|,
name|insn
argument_list|,
name|clock
argument_list|)
expr_stmt|;
if|if
condition|(
name|INSN_DEPEND
argument_list|(
name|insn
argument_list|)
operator|==
literal|0
condition|)
return|return;
for|for
control|(
name|link
operator|=
name|INSN_DEPEND
argument_list|(
name|insn
argument_list|)
init|;
name|link
operator|!=
literal|0
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|rtx
name|next
init|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|cost
init|=
name|insn_cost
argument_list|(
name|insn
argument_list|,
name|link
argument_list|,
name|next
argument_list|)
decl_stmt|;
name|INSN_TICK
argument_list|(
name|next
argument_list|)
operator|=
name|MAX
argument_list|(
name|INSN_TICK
argument_list|(
name|next
argument_list|)
argument_list|,
name|clock
operator|+
name|cost
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|INSN_DEP_COUNT
argument_list|(
name|next
argument_list|)
operator|-=
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
name|int
name|effective_cost
init|=
name|INSN_TICK
argument_list|(
name|next
argument_list|)
operator|-
name|clock
decl_stmt|;
if|if
condition|(
operator|!
call|(
modifier|*
name|current_sched_info
operator|->
name|new_ready
call|)
argument_list|(
name|next
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|sched_verbose
operator|>=
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|";;\t\tdependences resolved: insn %s "
argument_list|,
call|(
modifier|*
name|current_sched_info
operator|->
name|print_insn
call|)
argument_list|(
name|next
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|effective_cost
operator|<
literal|1
condition|)
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|"into ready\n"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|"into queue with cost=%d\n"
argument_list|,
name|effective_cost
argument_list|)
expr_stmt|;
block|}
comment|/* Adjust the priority of NEXT and either put it on the ready 	     list or queue it.  */
name|adjust_priority
argument_list|(
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|effective_cost
operator|<
literal|1
condition|)
name|ready_add
argument_list|(
name|ready
argument_list|,
name|next
argument_list|)
expr_stmt|;
else|else
name|queue_insn
argument_list|(
name|next
argument_list|,
name|effective_cost
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Annotate the instruction with issue information -- TImode      indicates that the instruction is expected not to be able      to issue on the same cycle as the previous insn.  A machine      may use this information to decide how the instruction should      be aligned.  */
if|if
condition|(
name|reload_completed
operator|&&
name|issue_rate
operator|>
literal|1
condition|)
block|{
name|PUT_MODE
argument_list|(
name|insn
argument_list|,
name|clock
operator|>
name|last_clock_var
condition|?
name|TImode
else|:
name|VOIDmode
argument_list|)
expr_stmt|;
name|last_clock_var
operator|=
name|clock
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Functions for handling of notes.  */
end_comment

begin_comment
comment|/* Delete notes beginning with INSN and put them in the chain    of notes ended by NOTE_LIST.    Returns the insn following the notes.  */
end_comment

begin_function
specifier|static
name|rtx
name|unlink_other_notes
parameter_list|(
name|insn
parameter_list|,
name|tail
parameter_list|)
name|rtx
name|insn
decl_stmt|,
name|tail
decl_stmt|;
block|{
name|rtx
name|prev
init|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
while|while
condition|(
name|insn
operator|!=
name|tail
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
block|{
name|rtx
name|next
init|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
comment|/* Delete the note from its current position.  */
if|if
condition|(
name|prev
condition|)
name|NEXT_INSN
argument_list|(
name|prev
argument_list|)
operator|=
name|next
expr_stmt|;
if|if
condition|(
name|next
condition|)
name|PREV_INSN
argument_list|(
name|next
argument_list|)
operator|=
name|prev
expr_stmt|;
comment|/* See sched_analyze to see how these are handled.  */
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE_INSN_LOOP_BEG
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE_INSN_LOOP_END
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE_INSN_RANGE_BEG
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE_INSN_RANGE_END
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE_INSN_EH_REGION_BEG
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE_INSN_EH_REGION_END
condition|)
block|{
comment|/* Insert the note at the end of the notes list.  */
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
operator|=
name|note_list
expr_stmt|;
if|if
condition|(
name|note_list
condition|)
name|NEXT_INSN
argument_list|(
name|note_list
argument_list|)
operator|=
name|insn
expr_stmt|;
name|note_list
operator|=
name|insn
expr_stmt|;
block|}
name|insn
operator|=
name|next
expr_stmt|;
block|}
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Delete line notes beginning with INSN. Record line-number notes so    they can be reused.  Returns the insn following the notes.  */
end_comment

begin_function
specifier|static
name|rtx
name|unlink_line_notes
parameter_list|(
name|insn
parameter_list|,
name|tail
parameter_list|)
name|rtx
name|insn
decl_stmt|,
name|tail
decl_stmt|;
block|{
name|rtx
name|prev
init|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
while|while
condition|(
name|insn
operator|!=
name|tail
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
block|{
name|rtx
name|next
init|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|write_symbols
operator|!=
name|NO_DEBUG
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|>
literal|0
condition|)
block|{
comment|/* Delete the note from its current position.  */
if|if
condition|(
name|prev
condition|)
name|NEXT_INSN
argument_list|(
name|prev
argument_list|)
operator|=
name|next
expr_stmt|;
if|if
condition|(
name|next
condition|)
name|PREV_INSN
argument_list|(
name|next
argument_list|)
operator|=
name|prev
expr_stmt|;
comment|/* Record line-number notes so they can be reused.  */
name|LINE_NOTE
argument_list|(
name|insn
argument_list|)
operator|=
name|insn
expr_stmt|;
block|}
else|else
name|prev
operator|=
name|insn
expr_stmt|;
name|insn
operator|=
name|next
expr_stmt|;
block|}
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Return the head and tail pointers of BB.  */
end_comment

begin_function
name|void
name|get_block_head_tail
parameter_list|(
name|b
parameter_list|,
name|headp
parameter_list|,
name|tailp
parameter_list|)
name|int
name|b
decl_stmt|;
name|rtx
modifier|*
name|headp
decl_stmt|;
name|rtx
modifier|*
name|tailp
decl_stmt|;
block|{
comment|/* HEAD and TAIL delimit the basic block being scheduled.  */
name|rtx
name|head
init|=
name|BLOCK_HEAD
argument_list|(
name|b
argument_list|)
decl_stmt|;
name|rtx
name|tail
init|=
name|BLOCK_END
argument_list|(
name|b
argument_list|)
decl_stmt|;
comment|/* Don't include any notes or labels at the beginning of the      basic block, or notes at the ends of basic blocks.  */
while|while
condition|(
name|head
operator|!=
name|tail
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|head
argument_list|)
operator|==
name|NOTE
condition|)
name|head
operator|=
name|NEXT_INSN
argument_list|(
name|head
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|tail
argument_list|)
operator|==
name|NOTE
condition|)
name|tail
operator|=
name|PREV_INSN
argument_list|(
name|tail
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|head
argument_list|)
operator|==
name|CODE_LABEL
condition|)
name|head
operator|=
name|NEXT_INSN
argument_list|(
name|head
argument_list|)
expr_stmt|;
else|else
break|break;
block|}
operator|*
name|headp
operator|=
name|head
expr_stmt|;
operator|*
name|tailp
operator|=
name|tail
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return nonzero if there are no real insns in the range [ HEAD, TAIL ].  */
end_comment

begin_function
name|int
name|no_real_insns_p
parameter_list|(
name|head
parameter_list|,
name|tail
parameter_list|)
name|rtx
name|head
decl_stmt|,
name|tail
decl_stmt|;
block|{
while|while
condition|(
name|head
operator|!=
name|NEXT_INSN
argument_list|(
name|tail
argument_list|)
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|head
argument_list|)
operator|!=
name|NOTE
operator|&&
name|GET_CODE
argument_list|(
name|head
argument_list|)
operator|!=
name|CODE_LABEL
condition|)
return|return
literal|0
return|;
name|head
operator|=
name|NEXT_INSN
argument_list|(
name|head
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Delete line notes from one block. Save them so they can be later restored    (in restore_line_notes).  HEAD and TAIL are the boundaries of the    block in which notes should be processed.  */
end_comment

begin_function
name|void
name|rm_line_notes
parameter_list|(
name|head
parameter_list|,
name|tail
parameter_list|)
name|rtx
name|head
decl_stmt|,
name|tail
decl_stmt|;
block|{
name|rtx
name|next_tail
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|next_tail
operator|=
name|NEXT_INSN
argument_list|(
name|tail
argument_list|)
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|head
init|;
name|insn
operator|!=
name|next_tail
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|rtx
name|prev
decl_stmt|;
comment|/* Farm out notes, and maybe save them in NOTE_LIST.          This is needed to keep the debugger from          getting completely deranged.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
block|{
name|prev
operator|=
name|insn
expr_stmt|;
name|insn
operator|=
name|unlink_line_notes
argument_list|(
name|insn
argument_list|,
name|next_tail
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev
operator|==
name|tail
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|prev
operator|==
name|head
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|insn
operator|==
name|next_tail
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Save line number notes for each insn in block B.  HEAD and TAIL are    the boundaries of the block in which notes should be processed.  */
end_comment

begin_function
name|void
name|save_line_notes
parameter_list|(
name|b
parameter_list|,
name|head
parameter_list|,
name|tail
parameter_list|)
name|int
name|b
decl_stmt|;
name|rtx
name|head
decl_stmt|,
name|tail
decl_stmt|;
block|{
name|rtx
name|next_tail
decl_stmt|;
comment|/* We must use the true line number for the first insn in the block      that was computed and saved at the start of this pass.  We can't      use the current line number, because scheduling of the previous      block may have changed the current line number.  */
name|rtx
name|line
init|=
name|line_note_head
index|[
name|b
index|]
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|next_tail
operator|=
name|NEXT_INSN
argument_list|(
name|tail
argument_list|)
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|head
init|;
name|insn
operator|!=
name|next_tail
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|>
literal|0
condition|)
name|line
operator|=
name|insn
expr_stmt|;
else|else
name|LINE_NOTE
argument_list|(
name|insn
argument_list|)
operator|=
name|line
expr_stmt|;
block|}
end_function

begin_comment
comment|/* After a block was scheduled, insert line notes into the insns list.    HEAD and TAIL are the boundaries of the block in which notes should    be processed.  */
end_comment

begin_function
name|void
name|restore_line_notes
parameter_list|(
name|head
parameter_list|,
name|tail
parameter_list|)
name|rtx
name|head
decl_stmt|,
name|tail
decl_stmt|;
block|{
name|rtx
name|line
decl_stmt|,
name|note
decl_stmt|,
name|prev
decl_stmt|,
name|new
decl_stmt|;
name|int
name|added_notes
init|=
literal|0
decl_stmt|;
name|rtx
name|next_tail
decl_stmt|,
name|insn
decl_stmt|;
name|head
operator|=
name|head
expr_stmt|;
name|next_tail
operator|=
name|NEXT_INSN
argument_list|(
name|tail
argument_list|)
expr_stmt|;
comment|/* Determine the current line-number.  We want to know the current      line number of the first insn of the block here, in case it is      different from the true line number that was saved earlier.  If      different, then we need a line number note before the first insn      of this block.  If it happens to be the same, then we don't want to      emit another line number note here.  */
for|for
control|(
name|line
operator|=
name|head
init|;
name|line
condition|;
name|line
operator|=
name|PREV_INSN
argument_list|(
name|line
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|line
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|line
argument_list|)
operator|>
literal|0
condition|)
break|break;
comment|/* Walk the insns keeping track of the current line-number and inserting      the line-number notes as needed.  */
for|for
control|(
name|insn
operator|=
name|head
init|;
name|insn
operator|!=
name|next_tail
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|>
literal|0
condition|)
name|line
operator|=
name|insn
expr_stmt|;
comment|/* This used to emit line number notes before every non-deleted note.      However, this confuses a debugger, because line notes not separated      by real instructions all end up at the same address.  I can find no      use for line number notes before other notes, so none are emitted.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE
operator|&&
name|INSN_UID
argument_list|(
name|insn
argument_list|)
operator|<
name|old_max_uid
operator|&&
operator|(
name|note
operator|=
name|LINE_NOTE
argument_list|(
name|insn
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|note
operator|!=
name|line
operator|&&
operator|(
name|line
operator|==
literal|0
operator|||
name|NOTE_LINE_NUMBER
argument_list|(
name|note
argument_list|)
operator|!=
name|NOTE_LINE_NUMBER
argument_list|(
name|line
argument_list|)
operator|||
name|NOTE_SOURCE_FILE
argument_list|(
name|note
argument_list|)
operator|!=
name|NOTE_SOURCE_FILE
argument_list|(
name|line
argument_list|)
operator|)
condition|)
block|{
name|line
operator|=
name|note
expr_stmt|;
name|prev
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|LINE_NOTE
argument_list|(
name|note
argument_list|)
condition|)
block|{
comment|/* Re-use the original line-number note.  */
name|LINE_NOTE
argument_list|(
name|note
argument_list|)
operator|=
literal|0
expr_stmt|;
name|PREV_INSN
argument_list|(
name|note
argument_list|)
operator|=
name|prev
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|prev
argument_list|)
operator|=
name|note
expr_stmt|;
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
operator|=
name|note
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|note
argument_list|)
operator|=
name|insn
expr_stmt|;
block|}
else|else
block|{
name|added_notes
operator|++
expr_stmt|;
name|new
operator|=
name|emit_note_after
argument_list|(
name|NOTE_LINE_NUMBER
argument_list|(
name|note
argument_list|)
argument_list|,
name|prev
argument_list|)
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|new
argument_list|)
operator|=
name|NOTE_SOURCE_FILE
argument_list|(
name|note
argument_list|)
expr_stmt|;
name|RTX_INTEGRATED_P
argument_list|(
name|new
argument_list|)
operator|=
name|RTX_INTEGRATED_P
argument_list|(
name|note
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sched_verbose
operator|&&
name|added_notes
condition|)
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|";; added %d line-number notes\n"
argument_list|,
name|added_notes
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* After scheduling the function, delete redundant line notes from the    insns list.  */
end_comment

begin_function
name|void
name|rm_redundant_line_notes
parameter_list|()
block|{
name|rtx
name|line
init|=
literal|0
decl_stmt|;
name|rtx
name|insn
init|=
name|get_insns
argument_list|()
decl_stmt|;
name|int
name|active_insn
init|=
literal|0
decl_stmt|;
name|int
name|notes
init|=
literal|0
decl_stmt|;
comment|/* Walk the insns deleting redundant line-number notes.  Many of these      are already present.  The remainder tend to occur at basic      block boundaries.  */
for|for
control|(
name|insn
operator|=
name|get_last_insn
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|>
literal|0
condition|)
block|{
comment|/* If there are no active insns following, INSN is redundant.  */
if|if
condition|(
name|active_insn
operator|==
literal|0
condition|)
block|{
name|notes
operator|++
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
operator|=
literal|0
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
block|}
comment|/* If the line number is unchanged, LINE is redundant.  */
elseif|else
if|if
condition|(
name|line
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|line
argument_list|)
operator|==
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|&&
name|NOTE_SOURCE_FILE
argument_list|(
name|line
argument_list|)
operator|==
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|notes
operator|++
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|line
argument_list|)
operator|=
literal|0
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|line
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
name|line
operator|=
name|insn
expr_stmt|;
block|}
else|else
name|line
operator|=
name|insn
expr_stmt|;
name|active_insn
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_DELETED
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|USE
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|CLOBBER
operator|)
operator|)
operator|)
condition|)
name|active_insn
operator|++
expr_stmt|;
if|if
condition|(
name|sched_verbose
operator|&&
name|notes
condition|)
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|";; deleted %d line-number notes\n"
argument_list|,
name|notes
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Delete notes between HEAD and TAIL and put them in the chain    of notes ended by NOTE_LIST.  */
end_comment

begin_function
name|void
name|rm_other_notes
parameter_list|(
name|head
parameter_list|,
name|tail
parameter_list|)
name|rtx
name|head
decl_stmt|;
name|rtx
name|tail
decl_stmt|;
block|{
name|rtx
name|next_tail
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|note_list
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|head
operator|==
name|tail
operator|&&
operator|(
operator|!
name|INSN_P
argument_list|(
name|head
argument_list|)
operator|)
condition|)
return|return;
name|next_tail
operator|=
name|NEXT_INSN
argument_list|(
name|tail
argument_list|)
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|head
init|;
name|insn
operator|!=
name|next_tail
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|rtx
name|prev
decl_stmt|;
comment|/* Farm out notes, and maybe save them in NOTE_LIST.          This is needed to keep the debugger from          getting completely deranged.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
block|{
name|prev
operator|=
name|insn
expr_stmt|;
name|insn
operator|=
name|unlink_other_notes
argument_list|(
name|insn
argument_list|,
name|next_tail
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev
operator|==
name|tail
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|prev
operator|==
name|head
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|insn
operator|==
name|next_tail
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Functions for computation of registers live/usage info.  */
end_comment

begin_comment
comment|/* Calculate INSN_REG_WEIGHT for all insns of a block.  */
end_comment

begin_function
specifier|static
name|void
name|find_insn_reg_weight
parameter_list|(
name|b
parameter_list|)
name|int
name|b
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|,
name|next_tail
decl_stmt|,
name|head
decl_stmt|,
name|tail
decl_stmt|;
name|get_block_head_tail
argument_list|(
name|b
argument_list|,
operator|&
name|head
argument_list|,
operator|&
name|tail
argument_list|)
expr_stmt|;
name|next_tail
operator|=
name|NEXT_INSN
argument_list|(
name|tail
argument_list|)
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|head
init|;
name|insn
operator|!=
name|next_tail
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|int
name|reg_weight
init|=
literal|0
decl_stmt|;
name|rtx
name|x
decl_stmt|;
comment|/* Handle register life information.  */
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
continue|continue;
comment|/* Increment weight for each register born here.  */
name|x
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SET
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CLOBBER
operator|)
operator|&&
name|register_operand
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
name|VOIDmode
argument_list|)
condition|)
name|reg_weight
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
block|{
name|x
operator|=
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SET
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CLOBBER
operator|)
operator|&&
name|register_operand
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
name|VOIDmode
argument_list|)
condition|)
name|reg_weight
operator|++
expr_stmt|;
block|}
block|}
comment|/* Decrement weight for each register that dies here.  */
for|for
control|(
name|x
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|x
condition|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
control|)
block|{
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|x
argument_list|)
operator|==
name|REG_DEAD
operator|||
name|REG_NOTE_KIND
argument_list|(
name|x
argument_list|)
operator|==
name|REG_UNUSED
condition|)
name|reg_weight
operator|--
expr_stmt|;
block|}
name|INSN_REG_WEIGHT
argument_list|(
name|insn
argument_list|)
operator|=
name|reg_weight
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Scheduling clock, modified in schedule_block() and queue_to_ready ().  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|clock_var
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Move insns that became ready to fire from queue to ready list.  */
end_comment

begin_function
specifier|static
name|void
name|queue_to_ready
parameter_list|(
name|ready
parameter_list|)
name|struct
name|ready_list
modifier|*
name|ready
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|;
name|rtx
name|link
decl_stmt|;
name|q_ptr
operator|=
name|NEXT_Q
argument_list|(
name|q_ptr
argument_list|)
expr_stmt|;
comment|/* Add all pending insns that can be scheduled without stalls to the      ready list.  */
for|for
control|(
name|link
operator|=
name|insn_queue
index|[
name|q_ptr
index|]
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|insn
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|q_size
operator|-=
literal|1
expr_stmt|;
if|if
condition|(
name|sched_verbose
operator|>=
literal|2
condition|)
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|";;\t\tQ-->Ready: insn %s: "
argument_list|,
call|(
modifier|*
name|current_sched_info
operator|->
name|print_insn
call|)
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|ready_add
argument_list|(
name|ready
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|sched_verbose
operator|>=
literal|2
condition|)
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|"moving to ready without stalls\n"
argument_list|)
expr_stmt|;
block|}
name|insn_queue
index|[
name|q_ptr
index|]
operator|=
literal|0
expr_stmt|;
comment|/* If there are no ready insns, stall until one is ready and add all      of the pending insns at that point to the ready list.  */
if|if
condition|(
name|ready
operator|->
name|n_ready
operator|==
literal|0
condition|)
block|{
name|int
name|stalls
decl_stmt|;
for|for
control|(
name|stalls
operator|=
literal|1
init|;
name|stalls
operator|<
name|INSN_QUEUE_SIZE
condition|;
name|stalls
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|link
operator|=
name|insn_queue
index|[
name|NEXT_Q_AFTER
argument_list|(
name|q_ptr
argument_list|,
name|stalls
argument_list|)
index|]
operator|)
condition|)
block|{
for|for
control|(
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|insn
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|q_size
operator|-=
literal|1
expr_stmt|;
if|if
condition|(
name|sched_verbose
operator|>=
literal|2
condition|)
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|";;\t\tQ-->Ready: insn %s: "
argument_list|,
call|(
modifier|*
name|current_sched_info
operator|->
name|print_insn
call|)
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|ready_add
argument_list|(
name|ready
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|sched_verbose
operator|>=
literal|2
condition|)
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|"moving to ready with %d stalls\n"
argument_list|,
name|stalls
argument_list|)
expr_stmt|;
block|}
name|insn_queue
index|[
name|NEXT_Q_AFTER
argument_list|(
name|q_ptr
argument_list|,
name|stalls
argument_list|)
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ready
operator|->
name|n_ready
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|sched_verbose
operator|&&
name|stalls
condition|)
name|visualize_stall_cycles
argument_list|(
name|stalls
argument_list|)
expr_stmt|;
name|q_ptr
operator|=
name|NEXT_Q_AFTER
argument_list|(
name|q_ptr
argument_list|,
name|stalls
argument_list|)
expr_stmt|;
name|clock_var
operator|+=
name|stalls
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print the ready list for debugging purposes.  Callable from debugger.  */
end_comment

begin_function
specifier|static
name|void
name|debug_ready_list
parameter_list|(
name|ready
parameter_list|)
name|struct
name|ready_list
modifier|*
name|ready
decl_stmt|;
block|{
name|rtx
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|ready
operator|->
name|n_ready
operator|==
literal|0
condition|)
return|return;
name|p
operator|=
name|ready_lastpos
argument_list|(
name|ready
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ready
operator|->
name|n_ready
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|"  %s"
argument_list|,
call|(
modifier|*
name|current_sched_info
operator|->
name|print_insn
call|)
argument_list|(
name|p
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* move_insn1: Remove INSN from insn chain, and link it after LAST insn.  */
end_comment

begin_function
specifier|static
name|rtx
name|move_insn1
parameter_list|(
name|insn
parameter_list|,
name|last
parameter_list|)
name|rtx
name|insn
decl_stmt|,
name|last
decl_stmt|;
block|{
name|NEXT_INSN
argument_list|(
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|PREV_INSN
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
operator|=
name|NEXT_INSN
argument_list|(
name|last
argument_list|)
expr_stmt|;
name|PREV_INSN
argument_list|(
name|NEXT_INSN
argument_list|(
name|last
argument_list|)
argument_list|)
operator|=
name|insn
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|last
argument_list|)
operator|=
name|insn
expr_stmt|;
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
operator|=
name|last
expr_stmt|;
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Search INSN for REG_SAVE_NOTE note pairs for    NOTE_INSN_{LOOP,EHREGION}_{BEG,END}; and convert them back into    NOTEs.  The REG_SAVE_NOTE note following first one is contains the    saved value for NOTE_BLOCK_NUMBER which is useful for    NOTE_INSN_EH_REGION_{BEG,END} NOTEs.  LAST is the last instruction    output by the instruction scheduler.  Return the new value of LAST.  */
end_comment

begin_function
specifier|static
name|rtx
name|reemit_notes
parameter_list|(
name|insn
parameter_list|,
name|last
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|rtx
name|last
decl_stmt|;
block|{
name|rtx
name|note
decl_stmt|,
name|retval
decl_stmt|;
name|retval
operator|=
name|last
expr_stmt|;
for|for
control|(
name|note
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|note
condition|;
name|note
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
control|)
block|{
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
operator|==
name|REG_SAVE_NOTE
condition|)
block|{
name|enum
name|insn_note
name|note_type
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|note_type
operator|==
name|NOTE_INSN_RANGE_BEG
operator|||
name|note_type
operator|==
name|NOTE_INSN_RANGE_END
condition|)
block|{
name|last
operator|=
name|emit_note_before
argument_list|(
name|note_type
argument_list|,
name|last
argument_list|)
expr_stmt|;
name|remove_note
argument_list|(
name|insn
argument_list|,
name|note
argument_list|)
expr_stmt|;
name|note
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|NOTE_RANGE_INFO
argument_list|(
name|last
argument_list|)
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|last
operator|=
name|emit_note_before
argument_list|(
name|note_type
argument_list|,
name|last
argument_list|)
expr_stmt|;
name|remove_note
argument_list|(
name|insn
argument_list|,
name|note
argument_list|)
expr_stmt|;
name|note
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|note_type
operator|==
name|NOTE_INSN_EH_REGION_BEG
operator|||
name|note_type
operator|==
name|NOTE_INSN_EH_REGION_END
condition|)
name|NOTE_EH_HANDLER
argument_list|(
name|last
argument_list|)
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|remove_note
argument_list|(
name|insn
argument_list|,
name|note
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* Move INSN, and all insns which should be issued before it,    due to SCHED_GROUP_P flag.  Reemit notes if needed.     Return the last insn emitted by the scheduler, which is the    return value from the first call to reemit_notes.  */
end_comment

begin_function
specifier|static
name|rtx
name|move_insn
parameter_list|(
name|insn
parameter_list|,
name|last
parameter_list|)
name|rtx
name|insn
decl_stmt|,
name|last
decl_stmt|;
block|{
name|rtx
name|retval
init|=
name|NULL
decl_stmt|;
comment|/* If INSN has SCHED_GROUP_P set, then issue it and any other      insns with SCHED_GROUP_P set first.  */
while|while
condition|(
name|SCHED_GROUP_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|rtx
name|prev
init|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
comment|/* Move a SCHED_GROUP_P insn.  */
name|move_insn1
argument_list|(
name|insn
argument_list|,
name|last
argument_list|)
expr_stmt|;
comment|/* If this is the first call to reemit_notes, then record 	 its return value.  */
if|if
condition|(
name|retval
operator|==
name|NULL_RTX
condition|)
name|retval
operator|=
name|reemit_notes
argument_list|(
name|insn
argument_list|,
name|insn
argument_list|)
expr_stmt|;
else|else
name|reemit_notes
argument_list|(
name|insn
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|insn
operator|=
name|prev
expr_stmt|;
block|}
comment|/* Now move the first non SCHED_GROUP_P insn.  */
name|move_insn1
argument_list|(
name|insn
argument_list|,
name|last
argument_list|)
expr_stmt|;
comment|/* If this is the first call to reemit_notes, then record      its return value.  */
if|if
condition|(
name|retval
operator|==
name|NULL_RTX
condition|)
name|retval
operator|=
name|reemit_notes
argument_list|(
name|insn
argument_list|,
name|insn
argument_list|)
expr_stmt|;
else|else
name|reemit_notes
argument_list|(
name|insn
argument_list|,
name|insn
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* Use forward list scheduling to rearrange insns of block B in region RGN,    possibly bringing insns from subsequent blocks in the same region.  */
end_comment

begin_function
name|void
name|schedule_block
parameter_list|(
name|b
parameter_list|,
name|rgn_n_insns
parameter_list|)
name|int
name|b
decl_stmt|;
name|int
name|rgn_n_insns
decl_stmt|;
block|{
name|rtx
name|last
decl_stmt|;
name|struct
name|ready_list
name|ready
decl_stmt|;
name|int
name|can_issue_more
decl_stmt|;
comment|/* Head/tail info for this block.  */
name|rtx
name|prev_head
init|=
name|current_sched_info
operator|->
name|prev_head
decl_stmt|;
name|rtx
name|next_tail
init|=
name|current_sched_info
operator|->
name|next_tail
decl_stmt|;
name|rtx
name|head
init|=
name|NEXT_INSN
argument_list|(
name|prev_head
argument_list|)
decl_stmt|;
name|rtx
name|tail
init|=
name|PREV_INSN
argument_list|(
name|next_tail
argument_list|)
decl_stmt|;
comment|/* We used to have code to avoid getting parameters moved from hard      argument registers into pseudos.       However, it was removed when it proved to be of marginal benefit      and caused problems because schedule_block and compute_forward_dependences      had different notions of what the "head" insn was.  */
if|if
condition|(
name|head
operator|==
name|tail
operator|&&
operator|(
operator|!
name|INSN_P
argument_list|(
name|head
argument_list|)
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Debug info.  */
if|if
condition|(
name|sched_verbose
condition|)
block|{
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|";;   ======================================================\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|";;   -- basic block %d from %d to %d -- %s reload\n"
argument_list|,
name|b
argument_list|,
name|INSN_UID
argument_list|(
name|head
argument_list|)
argument_list|,
name|INSN_UID
argument_list|(
name|tail
argument_list|)
argument_list|,
operator|(
name|reload_completed
condition|?
literal|"after"
else|:
literal|"before"
operator|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|";;   ======================================================\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|visualize_alloc
argument_list|()
expr_stmt|;
name|init_block_visualization
argument_list|()
expr_stmt|;
block|}
name|clear_units
argument_list|()
expr_stmt|;
comment|/* Allocate the ready list.  */
name|ready
operator|.
name|veclen
operator|=
name|rgn_n_insns
operator|+
literal|1
operator|+
name|issue_rate
expr_stmt|;
name|ready
operator|.
name|first
operator|=
name|ready
operator|.
name|veclen
operator|-
literal|1
expr_stmt|;
name|ready
operator|.
name|vec
operator|=
operator|(
name|rtx
operator|*
operator|)
name|xmalloc
argument_list|(
name|ready
operator|.
name|veclen
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|ready
operator|.
name|n_ready
operator|=
literal|0
expr_stmt|;
call|(
modifier|*
name|current_sched_info
operator|->
name|init_ready_list
call|)
argument_list|(
operator|&
name|ready
argument_list|)
expr_stmt|;
if|if
condition|(
name|targetm
operator|.
name|sched
operator|.
name|md_init
condition|)
call|(
modifier|*
name|targetm
operator|.
name|sched
operator|.
name|md_init
call|)
argument_list|(
name|sched_dump
argument_list|,
name|sched_verbose
argument_list|,
name|ready
operator|.
name|veclen
argument_list|)
expr_stmt|;
comment|/* No insns scheduled in this block yet.  */
name|last_scheduled_insn
operator|=
literal|0
expr_stmt|;
comment|/* Initialize INSN_QUEUE.  Q_SIZE is the total number of insns in the      queue.  */
name|q_ptr
operator|=
literal|0
expr_stmt|;
name|q_size
operator|=
literal|0
expr_stmt|;
name|last_clock_var
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|insn_queue
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|insn_queue
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Start just before the beginning of time.  */
name|clock_var
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* We start inserting insns after PREV_HEAD.  */
name|last
operator|=
name|prev_head
expr_stmt|;
comment|/* Loop until all the insns in BB are scheduled.  */
while|while
condition|(
call|(
modifier|*
name|current_sched_info
operator|->
name|schedule_more_p
call|)
argument_list|()
condition|)
block|{
name|clock_var
operator|++
expr_stmt|;
comment|/* Add to the ready list all pending insns that can be issued now.          If there are no ready insns, increment clock until one          is ready and add all pending insns at that point to the ready          list.  */
name|queue_to_ready
argument_list|(
operator|&
name|ready
argument_list|)
expr_stmt|;
if|if
condition|(
name|sched_verbose
operator|&&
name|targetm
operator|.
name|sched
operator|.
name|cycle_display
condition|)
name|last
operator|=
call|(
modifier|*
name|targetm
operator|.
name|sched
operator|.
name|cycle_display
call|)
argument_list|(
name|clock_var
argument_list|,
name|last
argument_list|)
expr_stmt|;
if|if
condition|(
name|ready
operator|.
name|n_ready
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|sched_verbose
operator|>=
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|";;\t\tReady list after queue_to_ready:  "
argument_list|)
expr_stmt|;
name|debug_ready_list
argument_list|(
operator|&
name|ready
argument_list|)
expr_stmt|;
block|}
comment|/* Sort the ready list based on priority.  */
name|ready_sort
argument_list|(
operator|&
name|ready
argument_list|)
expr_stmt|;
comment|/* Allow the target to reorder the list, typically for 	 better instruction bundling.  */
if|if
condition|(
name|targetm
operator|.
name|sched
operator|.
name|reorder
condition|)
name|can_issue_more
operator|=
call|(
modifier|*
name|targetm
operator|.
name|sched
operator|.
name|reorder
call|)
argument_list|(
name|sched_dump
argument_list|,
name|sched_verbose
argument_list|,
name|ready_lastpos
argument_list|(
operator|&
name|ready
argument_list|)
argument_list|,
operator|&
name|ready
operator|.
name|n_ready
argument_list|,
name|clock_var
argument_list|)
expr_stmt|;
else|else
name|can_issue_more
operator|=
name|issue_rate
expr_stmt|;
if|if
condition|(
name|sched_verbose
condition|)
block|{
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|"\n;;\tReady list (t =%3d):  "
argument_list|,
name|clock_var
argument_list|)
expr_stmt|;
name|debug_ready_list
argument_list|(
operator|&
name|ready
argument_list|)
expr_stmt|;
block|}
comment|/* Issue insns from ready list.  */
while|while
condition|(
name|ready
operator|.
name|n_ready
operator|!=
literal|0
operator|&&
name|can_issue_more
operator|&&
call|(
modifier|*
name|current_sched_info
operator|->
name|schedule_more_p
call|)
argument_list|()
condition|)
block|{
comment|/* Select and remove the insn from the ready list.  */
name|rtx
name|insn
init|=
name|ready_remove_first
argument_list|(
operator|&
name|ready
argument_list|)
decl_stmt|;
name|int
name|cost
init|=
name|actual_hazard
argument_list|(
name|insn_unit
argument_list|(
name|insn
argument_list|)
argument_list|,
name|insn
argument_list|,
name|clock_var
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|cost
operator|>=
literal|1
condition|)
block|{
name|queue_insn
argument_list|(
name|insn
argument_list|,
name|cost
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
call|(
modifier|*
name|current_sched_info
operator|->
name|can_schedule_ready_p
call|)
argument_list|(
name|insn
argument_list|)
condition|)
goto|goto
name|next
goto|;
name|last_scheduled_insn
operator|=
name|insn
expr_stmt|;
name|last
operator|=
name|move_insn
argument_list|(
name|insn
argument_list|,
name|last
argument_list|)
expr_stmt|;
if|if
condition|(
name|targetm
operator|.
name|sched
operator|.
name|variable_issue
condition|)
name|can_issue_more
operator|=
call|(
modifier|*
name|targetm
operator|.
name|sched
operator|.
name|variable_issue
call|)
argument_list|(
name|sched_dump
argument_list|,
name|sched_verbose
argument_list|,
name|insn
argument_list|,
name|can_issue_more
argument_list|)
expr_stmt|;
else|else
name|can_issue_more
operator|--
expr_stmt|;
name|schedule_insn
argument_list|(
name|insn
argument_list|,
operator|&
name|ready
argument_list|,
name|clock_var
argument_list|)
expr_stmt|;
name|next
label|:
if|if
condition|(
name|targetm
operator|.
name|sched
operator|.
name|reorder2
condition|)
block|{
comment|/* Sort the ready list based on priority.  */
if|if
condition|(
name|ready
operator|.
name|n_ready
operator|>
literal|0
condition|)
name|ready_sort
argument_list|(
operator|&
name|ready
argument_list|)
expr_stmt|;
name|can_issue_more
operator|=
call|(
modifier|*
name|targetm
operator|.
name|sched
operator|.
name|reorder2
call|)
argument_list|(
name|sched_dump
argument_list|,
name|sched_verbose
argument_list|,
name|ready
operator|.
name|n_ready
condition|?
name|ready_lastpos
argument_list|(
operator|&
name|ready
argument_list|)
else|:
name|NULL
argument_list|,
operator|&
name|ready
operator|.
name|n_ready
argument_list|,
name|clock_var
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Debug info.  */
if|if
condition|(
name|sched_verbose
condition|)
name|visualize_scheduled_insns
argument_list|(
name|clock_var
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|targetm
operator|.
name|sched
operator|.
name|md_finish
condition|)
call|(
modifier|*
name|targetm
operator|.
name|sched
operator|.
name|md_finish
call|)
argument_list|(
name|sched_dump
argument_list|,
name|sched_verbose
argument_list|)
expr_stmt|;
comment|/* Debug info.  */
if|if
condition|(
name|sched_verbose
condition|)
block|{
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|";;\tReady list (final):  "
argument_list|)
expr_stmt|;
name|debug_ready_list
argument_list|(
operator|&
name|ready
argument_list|)
expr_stmt|;
name|print_block_visualization
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
comment|/* Sanity check -- queue must be empty now.  Meaningless if region has      multiple bbs.  */
if|if
condition|(
name|current_sched_info
operator|->
name|queue_must_finish_empty
operator|&&
name|q_size
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Update head/tail boundaries.  */
name|head
operator|=
name|NEXT_INSN
argument_list|(
name|prev_head
argument_list|)
expr_stmt|;
name|tail
operator|=
name|last
expr_stmt|;
comment|/* Restore-other-notes: NOTE_LIST is the end of a chain of notes      previously found among the insns.  Insert them at the beginning      of the insns.  */
if|if
condition|(
name|note_list
operator|!=
literal|0
condition|)
block|{
name|rtx
name|note_head
init|=
name|note_list
decl_stmt|;
while|while
condition|(
name|PREV_INSN
argument_list|(
name|note_head
argument_list|)
condition|)
block|{
name|note_head
operator|=
name|PREV_INSN
argument_list|(
name|note_head
argument_list|)
expr_stmt|;
block|}
name|PREV_INSN
argument_list|(
name|note_head
argument_list|)
operator|=
name|PREV_INSN
argument_list|(
name|head
argument_list|)
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|PREV_INSN
argument_list|(
name|head
argument_list|)
argument_list|)
operator|=
name|note_head
expr_stmt|;
name|PREV_INSN
argument_list|(
name|head
argument_list|)
operator|=
name|note_list
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|note_list
argument_list|)
operator|=
name|head
expr_stmt|;
name|head
operator|=
name|note_head
expr_stmt|;
block|}
comment|/* Debugging.  */
if|if
condition|(
name|sched_verbose
condition|)
block|{
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|";;   total time = %d\n;;   new head = %d\n"
argument_list|,
name|clock_var
argument_list|,
name|INSN_UID
argument_list|(
name|head
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|";;   new tail = %d\n\n"
argument_list|,
name|INSN_UID
argument_list|(
name|tail
argument_list|)
argument_list|)
expr_stmt|;
name|visualize_free
argument_list|()
expr_stmt|;
block|}
name|current_sched_info
operator|->
name|head
operator|=
name|head
expr_stmt|;
name|current_sched_info
operator|->
name|tail
operator|=
name|tail
expr_stmt|;
name|free
argument_list|(
name|ready
operator|.
name|vec
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Set_priorities: compute priority of each insn in the block.  */
end_comment

begin_function
name|int
name|set_priorities
parameter_list|(
name|head
parameter_list|,
name|tail
parameter_list|)
name|rtx
name|head
decl_stmt|,
name|tail
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|;
name|int
name|n_insn
decl_stmt|;
name|rtx
name|prev_head
decl_stmt|;
name|prev_head
operator|=
name|PREV_INSN
argument_list|(
name|head
argument_list|)
expr_stmt|;
if|if
condition|(
name|head
operator|==
name|tail
operator|&&
operator|(
operator|!
name|INSN_P
argument_list|(
name|head
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
name|n_insn
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|tail
init|;
name|insn
operator|!=
name|prev_head
condition|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
continue|continue;
if|if
condition|(
operator|!
operator|(
name|SCHED_GROUP_P
argument_list|(
name|insn
argument_list|)
operator|)
condition|)
name|n_insn
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|priority
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
return|return
name|n_insn
return|;
block|}
end_function

begin_comment
comment|/* Initialize some global state for the scheduler.  DUMP_FILE is to be used    for debugging output.  */
end_comment

begin_function
name|void
name|sched_init
parameter_list|(
name|dump_file
parameter_list|)
name|FILE
modifier|*
name|dump_file
decl_stmt|;
block|{
name|int
name|luid
decl_stmt|,
name|b
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
comment|/* Disable speculative loads in their presence if cc0 defined.  */
ifdef|#
directive|ifdef
name|HAVE_cc0
name|flag_schedule_speculative_load
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* Set dump and sched_verbose for the desired debugging output.  If no      dump-file was specified, but -fsched-verbose=N (any N), print to stderr.      For -fsched-verbose=N, N>=10, print everything to stderr.  */
name|sched_verbose
operator|=
name|sched_verbose_param
expr_stmt|;
if|if
condition|(
name|sched_verbose_param
operator|==
literal|0
operator|&&
name|dump_file
condition|)
name|sched_verbose
operator|=
literal|1
expr_stmt|;
name|sched_dump
operator|=
operator|(
operator|(
name|sched_verbose_param
operator|>=
literal|10
operator|||
operator|!
name|dump_file
operator|)
condition|?
name|stderr
else|:
name|dump_file
operator|)
expr_stmt|;
comment|/* Initialize issue_rate.  */
if|if
condition|(
name|targetm
operator|.
name|sched
operator|.
name|issue_rate
condition|)
name|issue_rate
operator|=
call|(
modifier|*
name|targetm
operator|.
name|sched
operator|.
name|issue_rate
call|)
argument_list|()
expr_stmt|;
else|else
name|issue_rate
operator|=
literal|1
expr_stmt|;
comment|/* We use LUID 0 for the fake insn (UID 0) which holds dependencies for      pseudos which do not cross calls.  */
name|old_max_uid
operator|=
name|get_max_uid
argument_list|()
operator|+
literal|1
expr_stmt|;
name|h_i_d
operator|=
operator|(
expr|struct
name|haifa_insn_data
operator|*
operator|)
name|xcalloc
argument_list|(
name|old_max_uid
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|h_i_d
argument_list|)
argument_list|)
expr_stmt|;
name|h_i_d
index|[
literal|0
index|]
operator|.
name|luid
operator|=
literal|0
expr_stmt|;
name|luid
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|n_basic_blocks
condition|;
name|b
operator|++
control|)
for|for
control|(
name|insn
operator|=
name|BLOCK_HEAD
argument_list|(
name|b
argument_list|)
init|;
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|INSN_LUID
argument_list|(
name|insn
argument_list|)
operator|=
name|luid
expr_stmt|;
comment|/* Increment the next luid, unless this is a note.  We don't 	   really need separate IDs for notes and we don't want to 	   schedule differently depending on whether or not there are 	   line-number notes, i.e., depending on whether or not we're 	   generating debugging information.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE
condition|)
operator|++
name|luid
expr_stmt|;
if|if
condition|(
name|insn
operator|==
name|BLOCK_END
argument_list|(
name|b
argument_list|)
condition|)
break|break;
block|}
name|init_dependency_caches
argument_list|(
name|luid
argument_list|)
expr_stmt|;
name|compute_bb_for_insn
argument_list|(
name|old_max_uid
argument_list|)
expr_stmt|;
name|init_alias_analysis
argument_list|()
expr_stmt|;
if|if
condition|(
name|write_symbols
operator|!=
name|NO_DEBUG
condition|)
block|{
name|rtx
name|line
decl_stmt|;
name|line_note_head
operator|=
operator|(
name|rtx
operator|*
operator|)
name|xcalloc
argument_list|(
name|n_basic_blocks
argument_list|,
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Save-line-note-head:          Determine the line-number at the start of each basic block.          This must be computed and saved now, because after a basic block's          predecessor has been scheduled, it is impossible to accurately          determine the correct line number for the first insn of the block.  */
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|n_basic_blocks
condition|;
name|b
operator|++
control|)
block|{
for|for
control|(
name|line
operator|=
name|BLOCK_HEAD
argument_list|(
name|b
argument_list|)
init|;
name|line
condition|;
name|line
operator|=
name|PREV_INSN
argument_list|(
name|line
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|line
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|line
argument_list|)
operator|>
literal|0
condition|)
block|{
name|line_note_head
index|[
name|b
index|]
operator|=
name|line
expr_stmt|;
break|break;
block|}
comment|/* Do a forward search as well, since we won't get to see the first 	     notes in a basic block.  */
for|for
control|(
name|line
operator|=
name|BLOCK_HEAD
argument_list|(
name|b
argument_list|)
init|;
name|line
condition|;
name|line
operator|=
name|NEXT_INSN
argument_list|(
name|line
argument_list|)
control|)
block|{
if|if
condition|(
name|INSN_P
argument_list|(
name|line
argument_list|)
condition|)
break|break;
if|if
condition|(
name|GET_CODE
argument_list|(
name|line
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|line
argument_list|)
operator|>
literal|0
condition|)
name|line_note_head
index|[
name|b
index|]
operator|=
name|line
expr_stmt|;
block|}
block|}
block|}
comment|/* Find units used in this function, for visualization.  */
if|if
condition|(
name|sched_verbose
condition|)
name|init_target_units
argument_list|()
expr_stmt|;
comment|/* ??? Add a NOTE after the last insn of the last basic block.  It is not      known why this is done.  */
name|insn
operator|=
name|BLOCK_END
argument_list|(
name|n_basic_blocks
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
operator|==
literal|0
operator|||
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|CODE_LABEL
comment|/* Don't emit a NOTE if it would end up before a BARRIER.  */
operator|&&
name|GET_CODE
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|BARRIER
operator|)
condition|)
block|{
name|emit_note_after
argument_list|(
name|NOTE_INSN_DELETED
argument_list|,
name|BLOCK_END
argument_list|(
name|n_basic_blocks
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make insn to appear outside BB.  */
name|BLOCK_END
argument_list|(
name|n_basic_blocks
operator|-
literal|1
argument_list|)
operator|=
name|PREV_INSN
argument_list|(
name|BLOCK_END
argument_list|(
name|n_basic_blocks
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Compute INSN_REG_WEIGHT for all blocks.  We must do this before      removing death notes.  */
for|for
control|(
name|b
operator|=
name|n_basic_blocks
operator|-
literal|1
init|;
name|b
operator|>=
literal|0
condition|;
name|b
operator|--
control|)
name|find_insn_reg_weight
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Free global data used during insn scheduling.  */
end_comment

begin_function
name|void
name|sched_finish
parameter_list|()
block|{
name|free
argument_list|(
name|h_i_d
argument_list|)
expr_stmt|;
name|free_dependency_caches
argument_list|()
expr_stmt|;
name|end_alias_analysis
argument_list|()
expr_stmt|;
if|if
condition|(
name|write_symbols
operator|!=
name|NO_DEBUG
condition|)
name|free
argument_list|(
name|line_note_head
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INSN_SCHEDULING */
end_comment

end_unit

