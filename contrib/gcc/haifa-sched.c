begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Instruction scheduling pass.    Copyright (C) 1992, 93-98, 1999 Free Software Foundation, Inc.    Contributed by Michael Tiemann (tiemann@cygnus.com) Enhanced by,    and currently maintained by, Jim Wilson (wilson@cygnus.com)     This file is part of GNU CC.     GNU CC is free software; you can redistribute it and/or modify it    under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GNU CC is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    General Public License for more details.     You should have received a copy of the GNU General Public License    along with GNU CC; see the file COPYING.  If not, write to the Free    the Free Software Foundation, 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* Instruction scheduling pass.     This pass implements list scheduling within basic blocks.  It is    run twice: (1) after flow analysis, but before register allocation,    and (2) after register allocation.     The first run performs interblock scheduling, moving insns between    different blocks in the same "region", and the second runs only    basic block scheduling.     Interblock motions performed are useful motions and speculative    motions, including speculative loads.  Motions requiring code    duplication are not supported.  The identification of motion type    and the check for validity of speculative motions requires    construction and analysis of the function's control flow graph.    The scheduler works as follows:     We compute insn priorities based on data dependencies.  Flow    analysis only creates a fraction of the data-dependencies we must    observe: namely, only those dependencies which the combiner can be    expected to use.  For this pass, we must therefore create the    remaining dependencies we need to observe: register dependencies,    memory dependencies, dependencies to keep function calls in order,    and the dependence between a conditional branch and the setting of    condition codes are all dealt with here.     The scheduler first traverses the data flow graph, starting with    the last instruction, and proceeding to the first, assigning values    to insn_priority as it goes.  This sorts the instructions    topologically by data dependence.     Once priorities have been established, we order the insns using    list scheduling.  This works as follows: starting with a list of    all the ready insns, and sorted according to priority number, we    schedule the insn from the end of the list by placing its    predecessors in the list according to their priority order.  We    consider this insn scheduled by setting the pointer to the "end" of    the list to point to the previous insn.  When an insn has no    predecessors, we either queue it until sufficient time has elapsed    or add it to the ready list.  As the instructions are scheduled or    when stalls are introduced, the queue advances and dumps insns into    the ready list.  When all insns down to the lowest priority have    been scheduled, the critical path of the basic block has been made    as short as possible.  The remaining insns are then scheduled in    remaining slots.     Function unit conflicts are resolved during forward list scheduling    by tracking the time when each insn is committed to the schedule    and from that, the time the function units it uses must be free.    As insns on the ready list are considered for scheduling, those    that would result in a blockage of the already committed insns are    queued until no blockage will result.     The following list shows the order in which we want to break ties    among insns in the ready list:     1.  choose insn with the longest path to end of bb, ties    broken by    2.  choose insn with least contribution to register pressure,    ties broken by    3.  prefer in-block upon interblock motion, ties broken by    4.  prefer useful upon speculative motion, ties broken by    5.  choose insn with largest control flow probability, ties    broken by    6.  choose insn with the least dependences upon the previously    scheduled insn, or finally    7   choose the insn which has the most insns dependent on it.    8.  choose insn with lowest UID.     Memory references complicate matters.  Only if we can be certain    that memory references are not part of the data dependency graph    (via true, anti, or output dependence), can we move operations past    memory references.  To first approximation, reads can be done    independently, while writes introduce dependencies.  Better    approximations will yield fewer dependencies.     Before reload, an extended analysis of interblock data dependences    is required for interblock scheduling.  This is performed in    compute_block_backward_dependences ().     Dependencies set up by memory references are treated in exactly the    same way as other dependencies, by using LOG_LINKS backward    dependences.  LOG_LINKS are translated into INSN_DEPEND forward    dependences for the purpose of forward list scheduling.     Having optimized the critical path, we may have also unduly    extended the lifetimes of some registers.  If an operation requires    that constants be loaded into registers, it is certainly desirable    to load those constants as early as necessary, but no earlier.    I.e., it will not do to load up a bunch of registers at the    beginning of a basic block only to use them at the end, if they    could be loaded later, since this may result in excessive register    utilization.     Note that since branches are never in basic blocks, but only end    basic blocks, this pass will not move branches.  But that is ok,    since we can use GNU's delayed branch scheduling pass to take care    of this case.     Also note that no further optimizations based on algebraic    identities are performed, so this pass would be a good one to    perform instruction splitting, such as breaking up a multiply    instruction into shifts and adds where that is profitable.     Given the memory aliasing analysis that this pass should perform,    it should be possible to remove redundant stores to memory, and to    load values from registers instead of hitting memory.     Before reload, speculative insns are moved only if a 'proof' exists    that no exception will be caused by this, and if no live registers    exist that inhibit the motion (live registers constraints are not    represented by data dependence edges).     This pass must update information that subsequent passes expect to    be correct.  Namely: reg_n_refs, reg_n_sets, reg_n_deaths,    reg_n_calls_crossed, and reg_live_length.  Also, BLOCK_HEAD,    BLOCK_END.     The information in the line number notes is carefully retained by    this pass.  Notes that refer to the starting and ending of    exception regions are also carefully retained by this pass.  All    other NOTE insns are grouped in their same relative order at the    beginning of basic blocks and regions that have been scheduled.     The main entry point for this pass is schedule_insns(), called for    each function.  The work of the scheduler is organized in three    levels: (1) function level: insns are subject to splitting,    control-flow-graph is constructed, regions are computed (after    reload, each region is of one block), (2) region level: control    flow graph attributes required for interblock scheduling are    computed (dominators, reachability, etc.), data dependences and    priorities are computed, and (3) block level: insns in the block    are actually scheduled.  */
end_comment

begin_escape
end_escape

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"insn-attr.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|reg_known_equiv_p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|rtx
modifier|*
name|reg_known_value
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|INSN_SCHEDULING
end_ifdef

begin_comment
comment|/* target_units bitmask has 1 for each unit in the cpu.  It should be    possible to compute this variable from the machine description.    But currently it is computed by examinning the insn list.  Since    this is only needed for visualization, it seems an acceptable    solution.  (For understanding the mapping of bits to units, see    definition of function_units[] in "insn-attrtab.c") */
end_comment

begin_decl_stmt
specifier|static
name|int
name|target_units
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* issue_rate is the number of insns that can be scheduled in the same    machine cycle.  It can be defined in the config/mach/mach.h file,    otherwise we set it to 1.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|issue_rate
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|ISSUE_RATE
end_ifndef

begin_define
define|#
directive|define
name|ISSUE_RATE
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* sched-verbose controls the amount of debugging output the    scheduler prints.  It is controlled by -fsched-verbose-N:    N>0 and no -DSR : the output is directed to stderr.    N>=10 will direct the printouts to stderr (regardless of -dSR).    N=1: same as -dSR.    N=2: bb's probabilities, detailed ready list info, unit/insn info.    N=3: rtl at abort point, control-flow, regions info.    N=5: dependences info.  */
end_comment

begin_define
define|#
directive|define
name|MAX_RGN_BLOCKS
value|10
end_define

begin_define
define|#
directive|define
name|MAX_RGN_INSNS
value|100
end_define

begin_decl_stmt
specifier|static
name|int
name|sched_verbose_param
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sched_verbose
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* nr_inter/spec counts interblock/speculative motion for the function */
end_comment

begin_decl_stmt
specifier|static
name|int
name|nr_inter
decl_stmt|,
name|nr_spec
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* debugging file. all printouts are sent to dump, which is always set,    either to stderr, or to the dump listing file (-dRS).  */
end_comment

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|dump
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* fix_sched_param() is called from toplev.c upon detection    of the -fsched-***-N options.  */
end_comment

begin_function
name|void
name|fix_sched_param
parameter_list|(
name|param
parameter_list|,
name|val
parameter_list|)
name|char
modifier|*
name|param
decl_stmt|,
decl|*
name|val
decl_stmt|;
end_function

begin_block
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|param
argument_list|,
literal|"verbose"
argument_list|)
condition|)
name|sched_verbose_param
operator|=
name|atoi
argument_list|(
name|val
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
literal|"fix_sched_param: unknown param: %s"
argument_list|,
name|param
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Arrays set up by scheduling for the same respective purposes as    similar-named arrays set up by flow analysis.  We work with these    arrays during the scheduling pass so we can compare values against    unscheduled code.     Values of these arrays are copied at the end of this pass into the    arrays set up by flow analysis.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|sched_reg_n_calls_crossed
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
modifier|*
name|sched_reg_live_length
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
modifier|*
name|sched_reg_basic_block
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We need to know the current block number during the post scheduling    update of live register information so that we can also update    REG_BASIC_BLOCK if a register changes blocks.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|current_block_num
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Element N is the next insn that sets (hard or pseudo) register    N within the current basic block; or zero, if there is no    such insn.  Needed for new registers which may be introduced    by splitting insns.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
modifier|*
name|reg_last_uses
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
modifier|*
name|reg_last_sets
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
modifier|*
name|reg_last_clobbers
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|regset
name|reg_pending_sets
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|regset
name|reg_pending_clobbers
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|reg_pending_sets_all
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Vector indexed by INSN_UID giving the original ordering of the insns.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|insn_luid
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|INSN_LUID
parameter_list|(
name|INSN
parameter_list|)
value|(insn_luid[INSN_UID (INSN)])
end_define

begin_comment
comment|/* Vector indexed by INSN_UID giving each instruction a priority.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|insn_priority
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|INSN_PRIORITY
parameter_list|(
name|INSN
parameter_list|)
value|(insn_priority[INSN_UID (INSN)])
end_define

begin_decl_stmt
specifier|static
name|short
modifier|*
name|insn_costs
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|INSN_COST
parameter_list|(
name|INSN
parameter_list|)
value|insn_costs[INSN_UID (INSN)]
end_define

begin_comment
comment|/* Vector indexed by INSN_UID giving an encoding of the function units    used.  */
end_comment

begin_decl_stmt
specifier|static
name|short
modifier|*
name|insn_units
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|INSN_UNIT
parameter_list|(
name|INSN
parameter_list|)
value|insn_units[INSN_UID (INSN)]
end_define

begin_comment
comment|/* Vector indexed by INSN_UID giving each instruction a register-weight.    This weight is an estimation of the insn contribution to registers pressure.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|insn_reg_weight
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|INSN_REG_WEIGHT
parameter_list|(
name|INSN
parameter_list|)
value|(insn_reg_weight[INSN_UID (INSN)])
end_define

begin_comment
comment|/* Vector indexed by INSN_UID giving list of insns which    depend upon INSN.  Unlike LOG_LINKS, it represents forward dependences.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
modifier|*
name|insn_depend
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|INSN_DEPEND
parameter_list|(
name|INSN
parameter_list|)
value|insn_depend[INSN_UID (INSN)]
end_define

begin_comment
comment|/* Vector indexed by INSN_UID. Initialized to the number of incoming    edges in forward dependence graph (= number of LOG_LINKS).  As    scheduling procedes, dependence counts are decreased.  An    instruction moves to the ready list when its counter is zero.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|insn_dep_count
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|INSN_DEP_COUNT
parameter_list|(
name|INSN
parameter_list|)
value|(insn_dep_count[INSN_UID (INSN)])
end_define

begin_comment
comment|/* Vector indexed by INSN_UID giving an encoding of the blockage range    function.  The unit and the range are encoded.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
modifier|*
name|insn_blockage
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|INSN_BLOCKAGE
parameter_list|(
name|INSN
parameter_list|)
value|insn_blockage[INSN_UID (INSN)]
end_define

begin_define
define|#
directive|define
name|UNIT_BITS
value|5
end_define

begin_define
define|#
directive|define
name|BLOCKAGE_MASK
value|((1<< BLOCKAGE_BITS) - 1)
end_define

begin_define
define|#
directive|define
name|ENCODE_BLOCKAGE
parameter_list|(
name|U
parameter_list|,
name|R
parameter_list|)
define|\
value|(((U)<< BLOCKAGE_BITS					\   | MIN_BLOCKAGE_COST (R))<< BLOCKAGE_BITS		\  | MAX_BLOCKAGE_COST (R))
end_define

begin_define
define|#
directive|define
name|UNIT_BLOCKED
parameter_list|(
name|B
parameter_list|)
value|((B)>> (2 * BLOCKAGE_BITS))
end_define

begin_define
define|#
directive|define
name|BLOCKAGE_RANGE
parameter_list|(
name|B
parameter_list|)
define|\
value|(((((B)>> BLOCKAGE_BITS)& BLOCKAGE_MASK)<< (HOST_BITS_PER_INT / 2)) \    | ((B)& BLOCKAGE_MASK))
end_define

begin_comment
comment|/* Encodings of the `<name>_unit_blockage_range' function.  */
end_comment

begin_define
define|#
directive|define
name|MIN_BLOCKAGE_COST
parameter_list|(
name|R
parameter_list|)
value|((R)>> (HOST_BITS_PER_INT / 2))
end_define

begin_define
define|#
directive|define
name|MAX_BLOCKAGE_COST
parameter_list|(
name|R
parameter_list|)
value|((R)& ((1<< (HOST_BITS_PER_INT / 2)) - 1))
end_define

begin_define
define|#
directive|define
name|DONE_PRIORITY
value|-1
end_define

begin_define
define|#
directive|define
name|MAX_PRIORITY
value|0x7fffffff
end_define

begin_define
define|#
directive|define
name|TAIL_PRIORITY
value|0x7ffffffe
end_define

begin_define
define|#
directive|define
name|LAUNCH_PRIORITY
value|0x7f000001
end_define

begin_define
define|#
directive|define
name|DONE_PRIORITY_P
parameter_list|(
name|INSN
parameter_list|)
value|(INSN_PRIORITY (INSN)< 0)
end_define

begin_define
define|#
directive|define
name|LOW_PRIORITY_P
parameter_list|(
name|INSN
parameter_list|)
value|((INSN_PRIORITY (INSN)& 0x7f000000) == 0)
end_define

begin_comment
comment|/* Vector indexed by INSN_UID giving number of insns referring to this insn.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|insn_ref_count
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|INSN_REF_COUNT
parameter_list|(
name|INSN
parameter_list|)
value|(insn_ref_count[INSN_UID (INSN)])
end_define

begin_comment
comment|/* Vector indexed by INSN_UID giving line-number note in effect for each    insn.  For line-number notes, this indicates whether the note may be    reused.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
modifier|*
name|line_note
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|LINE_NOTE
parameter_list|(
name|INSN
parameter_list|)
value|(line_note[INSN_UID (INSN)])
end_define

begin_comment
comment|/* Vector indexed by basic block number giving the starting line-number    for each basic block.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
modifier|*
name|line_note_head
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List of important notes we must keep around.  This is a pointer to the    last element in the list.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|note_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Regsets telling whether a given register is live or dead before the last    scheduled insn.  Must scan the instructions once before scheduling to    determine what registers are live or dead at the end of the block.  */
end_comment

begin_decl_stmt
specifier|static
name|regset
name|bb_live_regs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Regset telling whether a given register is live after the insn currently    being scheduled.  Before processing an insn, this is equal to bb_live_regs    above.  This is used so that we can find registers that are newly born/dead    after processing an insn.  */
end_comment

begin_decl_stmt
specifier|static
name|regset
name|old_live_regs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The chain of REG_DEAD notes.  REG_DEAD notes are removed from all insns    during the initial scan and reused later.  If there are not exactly as    many REG_DEAD notes in the post scheduled code as there were in the    prescheduled code then we trigger an abort because this indicates a bug.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|dead_notes
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Queues, etc.  */
end_comment

begin_comment
comment|/* An instruction is ready to be scheduled when all insns preceding it    have already been scheduled.  It is important to ensure that all    insns which use its result will not be executed until its result    has been computed.  An insn is maintained in one of four structures:     (P) the "Pending" set of insns which cannot be scheduled until    their dependencies have been satisfied.    (Q) the "Queued" set of insns that can be scheduled when sufficient    time has passed.    (R) the "Ready" list of unscheduled, uncommitted insns.    (S) the "Scheduled" list of insns.     Initially, all insns are either "Pending" or "Ready" depending on    whether their dependencies are satisfied.     Insns move from the "Ready" list to the "Scheduled" list as they    are committed to the schedule.  As this occurs, the insns in the    "Pending" list have their dependencies satisfied and move to either    the "Ready" list or the "Queued" set depending on whether    sufficient time has passed to make them ready.  As time passes,    insns move from the "Queued" set to the "Ready" list.  Insns may    move from the "Ready" list to the "Queued" set if they are blocked    due to a function unit conflict.     The "Pending" list (P) are the insns in the INSN_DEPEND of the unscheduled    insns, i.e., those that are ready, queued, and pending.    The "Queued" set (Q) is implemented by the variable `insn_queue'.    The "Ready" list (R) is implemented by the variables `ready' and    `n_ready'.    The "Scheduled" list (S) is the new insn chain built by this pass.     The transition (R->S) is implemented in the scheduling loop in    `schedule_block' when the best insn to schedule is chosen.    The transition (R->Q) is implemented in `queue_insn' when an    insn is found to have a function unit conflict with the already    committed insns.    The transitions (P->R and P->Q) are implemented in `schedule_insn' as    insns move from the ready list to the scheduled list.    The transition (Q->R) is implemented in 'queue_to_insn' as time    passes or stalls are introduced.  */
end_comment

begin_comment
comment|/* Implement a circular buffer to delay instructions until sufficient    time has passed.  INSN_QUEUE_SIZE is a power of two larger than    MAX_BLOCKAGE and MAX_READY_COST computed by genattr.c.  This is the    longest time an isnsn may be queued.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|insn_queue
index|[
name|INSN_QUEUE_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|q_ptr
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|q_size
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NEXT_Q
parameter_list|(
name|X
parameter_list|)
value|(((X)+1)& (INSN_QUEUE_SIZE-1))
end_define

begin_define
define|#
directive|define
name|NEXT_Q_AFTER
parameter_list|(
name|X
parameter_list|,
name|C
parameter_list|)
value|(((X)+C)& (INSN_QUEUE_SIZE-1))
end_define

begin_comment
comment|/* Vector indexed by INSN_UID giving the minimum clock tick at which    the insn becomes ready.  This is used to note timing constraints for    insns in the pending list.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|insn_tick
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|INSN_TICK
parameter_list|(
name|INSN
parameter_list|)
value|(insn_tick[INSN_UID (INSN)])
end_define

begin_comment
comment|/* Data structure for keeping track of register information    during that register's life.  */
end_comment

begin_struct
struct|struct
name|sometimes
block|{
name|int
name|regno
decl_stmt|;
name|int
name|live_length
decl_stmt|;
name|int
name|calls_crossed
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Forward declarations.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|add_dependence
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
expr|enum
name|reg_note
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|remove_dependence
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|find_insn_list
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|insn_unit
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|blockage_range
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|clear_units
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|actual_hazard_this_instance
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
name|rtx
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|schedule_unit
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|actual_hazard
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|rtx
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|potential_hazard
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|insn_cost
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|priority
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|free_pending_lists
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_insn_mem_dependence
name|PROTO
argument_list|(
operator|(
name|rtx
operator|*
operator|,
name|rtx
operator|*
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|flush_pending_lists
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|sched_analyze_1
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|sched_analyze_2
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|sched_analyze_insn
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|sched_analyze
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|sched_note_set
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|rank_for_schedule
name|PROTO
argument_list|(
operator|(
specifier|const
name|GENERIC_PTR
operator|,
specifier|const
name|GENERIC_PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|swap_sort
name|PROTO
argument_list|(
operator|(
name|rtx
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|queue_insn
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|schedule_insn
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|create_reg_dead_note
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|attach_deaths
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|attach_deaths_insn
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|new_sometimes_live
name|PROTO
argument_list|(
operator|(
expr|struct
name|sometimes
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|finish_sometimes_live
name|PROTO
argument_list|(
operator|(
expr|struct
name|sometimes
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|schedule_block
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|split_hard_reg_notes
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|new_insn_dead_notes
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|update_n_sets
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|safe_concat
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|insn_issue_delay
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|birthing_insn_p
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|adjust_priority
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Mapping of insns to their original block prior to scheduling.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|insn_orig_block
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|INSN_BLOCK
parameter_list|(
name|insn
parameter_list|)
value|(insn_orig_block[INSN_UID (insn)])
end_define

begin_comment
comment|/* Some insns (e.g. call) are not allowed to move across blocks.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|cant_move
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CANT_MOVE
parameter_list|(
name|insn
parameter_list|)
value|(cant_move[INSN_UID (insn)])
end_define

begin_comment
comment|/* Control flow graph edges are kept in circular lists.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|int
name|from_block
decl_stmt|;
name|int
name|to_block
decl_stmt|;
name|int
name|next_in
decl_stmt|;
name|int
name|next_out
decl_stmt|;
block|}
name|haifa_edge
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|haifa_edge
modifier|*
name|edge_table
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NEXT_IN
parameter_list|(
name|edge
parameter_list|)
value|(edge_table[edge].next_in)
end_define

begin_define
define|#
directive|define
name|NEXT_OUT
parameter_list|(
name|edge
parameter_list|)
value|(edge_table[edge].next_out)
end_define

begin_define
define|#
directive|define
name|FROM_BLOCK
parameter_list|(
name|edge
parameter_list|)
value|(edge_table[edge].from_block)
end_define

begin_define
define|#
directive|define
name|TO_BLOCK
parameter_list|(
name|edge
parameter_list|)
value|(edge_table[edge].to_block)
end_define

begin_comment
comment|/* Number of edges in the control flow graph.  (in fact larger than    that by 1, since edge 0 is unused.) */
end_comment

begin_decl_stmt
specifier|static
name|int
name|nr_edges
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Circular list of incoming/outgoing edges of a block */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|in_edges
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
modifier|*
name|out_edges
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|IN_EDGES
parameter_list|(
name|block
parameter_list|)
value|(in_edges[block])
end_define

begin_define
define|#
directive|define
name|OUT_EDGES
parameter_list|(
name|block
parameter_list|)
value|(out_edges[block])
end_define

begin_comment
comment|/* List of labels which cannot be deleted, needed for control    flow graph construction.  */
end_comment

begin_decl_stmt
specifier|extern
name|rtx
name|forced_labels
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|is_cfg_nonregular
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|build_control_flow
name|PROTO
argument_list|(
operator|(
name|int_list_ptr
operator|*
operator|,
name|int_list_ptr
operator|*
operator|,
name|int
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|new_edge
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A region is the main entity for interblock scheduling: insns    are allowed to move between blocks in the same region, along    control flow graph edges, in the 'up' direction.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|int
name|rgn_nr_blocks
decl_stmt|;
comment|/* number of blocks in region */
name|int
name|rgn_blocks
decl_stmt|;
comment|/* blocks in the region (actually index in rgn_bb_table) */
block|}
name|region
typedef|;
end_typedef

begin_comment
comment|/* Number of regions in the procedure */
end_comment

begin_decl_stmt
specifier|static
name|int
name|nr_regions
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Table of region descriptions */
end_comment

begin_decl_stmt
specifier|static
name|region
modifier|*
name|rgn_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Array of lists of regions' blocks */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|rgn_bb_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Topological order of blocks in the region (if b2 is reachable from    b1, block_to_bb[b2]> block_to_bb[b1]).    Note: A basic block is always referred to by either block or b,    while its topological order name (in the region) is refered to by    bb.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|block_to_bb
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of the region containing a block.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|containing_rgn
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|RGN_NR_BLOCKS
parameter_list|(
name|rgn
parameter_list|)
value|(rgn_table[rgn].rgn_nr_blocks)
end_define

begin_define
define|#
directive|define
name|RGN_BLOCKS
parameter_list|(
name|rgn
parameter_list|)
value|(rgn_table[rgn].rgn_blocks)
end_define

begin_define
define|#
directive|define
name|BLOCK_TO_BB
parameter_list|(
name|block
parameter_list|)
value|(block_to_bb[block])
end_define

begin_define
define|#
directive|define
name|CONTAINING_RGN
parameter_list|(
name|block
parameter_list|)
value|(containing_rgn[block])
end_define

begin_decl_stmt
name|void
name|debug_regions
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|find_single_block_region
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|find_rgns
name|PROTO
argument_list|(
operator|(
name|int_list_ptr
operator|*
operator|,
name|int_list_ptr
operator|*
operator|,
name|int
operator|*
operator|,
name|int
operator|*
operator|,
name|sbitmap
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|too_large
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|int
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|debug_live
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Blocks of the current region being scheduled.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|current_nr_blocks
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|current_blocks
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The mapping from bb to block */
end_comment

begin_define
define|#
directive|define
name|BB_TO_BLOCK
parameter_list|(
name|bb
parameter_list|)
value|(rgn_bb_table[current_blocks + (bb)])
end_define

begin_comment
comment|/* Bit vectors and bitset operations are needed for computations on    the control flow graph.  */
end_comment

begin_typedef
typedef|typedef
name|unsigned
name|HOST_WIDE_INT
modifier|*
name|bitset
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|int
modifier|*
name|first_member
decl_stmt|;
comment|/* pointer to the list start in bitlst_table.  */
name|int
name|nr_members
decl_stmt|;
comment|/* the number of members of the bit list.     */
block|}
name|bitlst
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|int
name|bitlst_table_last
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|bitlst_table_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
modifier|*
name|bitlst_table
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|bitset_member
name|PROTO
argument_list|(
operator|(
name|bitset
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|extract_bitlst
name|PROTO
argument_list|(
operator|(
name|bitset
operator|,
name|int
operator|,
name|bitlst
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* target info declarations.     The block currently being scheduled is referred to as the "target" block,    while other blocks in the region from which insns can be moved to the    target are called "source" blocks.  The candidate structure holds info    about such sources: are they valid?  Speculative?  Etc.  */
end_comment

begin_typedef
typedef|typedef
name|bitlst
name|bblst
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|char
name|is_valid
decl_stmt|;
name|char
name|is_speculative
decl_stmt|;
name|int
name|src_prob
decl_stmt|;
name|bblst
name|split_bbs
decl_stmt|;
name|bblst
name|update_bbs
decl_stmt|;
block|}
name|candidate
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|candidate
modifier|*
name|candidate_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A speculative motion requires checking live information on the path    from 'source' to 'target'.  The split blocks are those to be checked.    After a speculative motion, live information should be modified in    the 'update' blocks.     Lists of split and update blocks for  each candidate of the current    target  are  in  array bblst_table */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|bblst_table
decl_stmt|,
name|bblst_size
decl_stmt|,
name|bblst_last
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|IS_VALID
parameter_list|(
name|src
parameter_list|)
value|( candidate_table[src].is_valid )
end_define

begin_define
define|#
directive|define
name|IS_SPECULATIVE
parameter_list|(
name|src
parameter_list|)
value|( candidate_table[src].is_speculative )
end_define

begin_define
define|#
directive|define
name|SRC_PROB
parameter_list|(
name|src
parameter_list|)
value|( candidate_table[src].src_prob )
end_define

begin_comment
comment|/* The bb being currently scheduled.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|target_bb
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List of edges.  */
end_comment

begin_typedef
typedef|typedef
name|bitlst
name|edgelst
typedef|;
end_typedef

begin_comment
comment|/* target info functions */
end_comment

begin_decl_stmt
specifier|static
name|void
name|split_edges
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
name|edgelst
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|compute_trg_info
name|PROTO
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|debug_candidate
name|PROTO
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|debug_candidates
name|PROTO
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Bit-set of bbs, where bit 'i' stands for bb 'i'.  */
end_comment

begin_typedef
typedef|typedef
name|bitset
name|bbset
typedef|;
end_typedef

begin_comment
comment|/* Number of words of the bbset.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|bbset_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Dominators array: dom[i] contains the bbset of dominators of    bb i in the region.  */
end_comment

begin_decl_stmt
specifier|static
name|bbset
modifier|*
name|dom
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* bb 0 is the only region entry */
end_comment

begin_define
define|#
directive|define
name|IS_RGN_ENTRY
parameter_list|(
name|bb
parameter_list|)
value|(!bb)
end_define

begin_comment
comment|/* Is bb_src dominated by bb_trg.  */
end_comment

begin_define
define|#
directive|define
name|IS_DOMINATED
parameter_list|(
name|bb_src
parameter_list|,
name|bb_trg
parameter_list|)
define|\
value|( bitset_member (dom[bb_src], bb_trg, bbset_size) )
end_define

begin_comment
comment|/* Probability: Prob[i] is a float in [0, 1] which is the probability    of bb i relative to the region entry.  */
end_comment

begin_decl_stmt
specifier|static
name|float
modifier|*
name|prob
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  The probability of bb_src, relative to bb_trg.  Note, that while the    'prob[bb]' is a float in [0, 1], this macro returns an integer    in [0, 100].  */
end_comment

begin_define
define|#
directive|define
name|GET_SRC_PROB
parameter_list|(
name|bb_src
parameter_list|,
name|bb_trg
parameter_list|)
value|((int) (100.0 * (prob[bb_src] / \ 						      prob[bb_trg])))
end_define

begin_comment
comment|/* Bit-set of edges, where bit i stands for edge i.  */
end_comment

begin_typedef
typedef|typedef
name|bitset
name|edgeset
typedef|;
end_typedef

begin_comment
comment|/* Number of edges in the region.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|rgn_nr_edges
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Array of size rgn_nr_edges.    */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|rgn_edges
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of words in an edgeset.    */
end_comment

begin_decl_stmt
specifier|static
name|int
name|edgeset_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Mapping from each edge in the graph to its number in the rgn.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|edge_to_bit
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|EDGE_TO_BIT
parameter_list|(
name|edge
parameter_list|)
value|(edge_to_bit[edge])
end_define

begin_comment
comment|/* The split edges of a source bb is different for each target    bb.  In order to compute this efficiently, the 'potential-split edges'    are computed for each bb prior to scheduling a region.  This is actually    the split edges of each bb relative to the region entry.     pot_split[bb] is the set of potential split edges of bb.  */
end_comment

begin_decl_stmt
specifier|static
name|edgeset
modifier|*
name|pot_split
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For every bb, a set of its ancestor edges.  */
end_comment

begin_decl_stmt
specifier|static
name|edgeset
modifier|*
name|ancestor_edges
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|compute_dom_prob_ps
name|PROTO
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ABS_VALUE
parameter_list|(
name|x
parameter_list|)
value|(((x)<0)?(-(x)):(x))
end_define

begin_define
define|#
directive|define
name|INSN_PROBABILITY
parameter_list|(
name|INSN
parameter_list|)
value|(SRC_PROB (BLOCK_TO_BB (INSN_BLOCK (INSN))))
end_define

begin_define
define|#
directive|define
name|IS_SPECULATIVE_INSN
parameter_list|(
name|INSN
parameter_list|)
value|(IS_SPECULATIVE (BLOCK_TO_BB (INSN_BLOCK (INSN))))
end_define

begin_define
define|#
directive|define
name|INSN_BB
parameter_list|(
name|INSN
parameter_list|)
value|(BLOCK_TO_BB (INSN_BLOCK (INSN)))
end_define

begin_comment
comment|/* parameters affecting the decision of rank_for_schedule() */
end_comment

begin_define
define|#
directive|define
name|MIN_DIFF_PRIORITY
value|2
end_define

begin_define
define|#
directive|define
name|MIN_PROBABILITY
value|40
end_define

begin_define
define|#
directive|define
name|MIN_PROB_DIFF
value|10
end_define

begin_comment
comment|/* speculative scheduling functions */
end_comment

begin_decl_stmt
specifier|static
name|int
name|check_live_1
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|update_live_1
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|check_live
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|update_live
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_spec_fed
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|is_pfree
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|find_conditional_protection
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|is_conditionally_protected
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|may_trap_exp
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|haifa_classify_insn
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|is_prisky
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|is_exception_free
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|find_insn_mem_list
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|compute_block_forward_dependences
name|PROTO
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|init_rgn_data_dependences
name|PROTO
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_branch_dependences
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|compute_block_backward_dependences
name|PROTO
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|debug_dependencies
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Notes handling mechanism:    =========================    Generally, NOTES are saved before scheduling and restored after scheduling.    The scheduler distinguishes between three types of notes:     (1) LINE_NUMBER notes, generated and used for debugging.  Here,    before scheduling a region, a pointer to the LINE_NUMBER note is    added to the insn following it (in save_line_notes()), and the note    is removed (in rm_line_notes() and unlink_line_notes()).  After    scheduling the region, this pointer is used for regeneration of    the LINE_NUMBER note (in restore_line_notes()).     (2) LOOP_BEGIN, LOOP_END, SETJMP, EHREGION_BEG, EHREGION_END notes:    Before scheduling a region, a pointer to the note is added to the insn    that follows or precedes it.  (This happens as part of the data dependence    computation).  After scheduling an insn, the pointer contained in it is    used for regenerating the corresponding note (in reemit_notes).     (3) All other notes (e.g. INSN_DELETED):  Before scheduling a block,    these notes are put in a list (in rm_other_notes() and    unlink_other_notes ()).  After scheduling the block, these notes are    inserted at the beginning of the block (in schedule_block()).  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|unlink_other_notes
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|unlink_line_notes
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|rm_line_notes
name|PROTO
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|save_line_notes
name|PROTO
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|restore_line_notes
name|PROTO
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|rm_redundant_line_notes
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|rm_other_notes
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|reemit_notes
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|get_block_head_tail
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|rtx
operator|*
operator|,
name|rtx
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|find_pre_sched_live
name|PROTO
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|find_post_sched_live
name|PROTO
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|update_reg_usage
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|queue_to_ready
name|PROTO
argument_list|(
operator|(
name|rtx
index|[]
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|debug_ready_list
name|PROTO
argument_list|(
operator|(
name|rtx
index|[]
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|init_target_units
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|insn_print_units
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|get_visual_tbl_length
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|init_block_visualization
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_block_visualization
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|visualize_scheduled_insns
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|visualize_no_unit
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|visualize_stall_cycles
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_exp
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_value
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_pattern
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_insn
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|debug_reg_vector
name|PROTO
argument_list|(
operator|(
name|regset
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|move_insn1
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|move_insn
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|group_leader
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|set_priorities
name|PROTO
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|init_rtx_vector
name|PROTO
argument_list|(
operator|(
name|rtx
operator|*
operator|*
operator|,
name|rtx
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|schedule_region
name|PROTO
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INSN_SCHEDULING */
end_comment

begin_escape
end_escape

begin_define
define|#
directive|define
name|SIZE_FOR_MODE
parameter_list|(
name|X
parameter_list|)
value|(GET_MODE_SIZE (GET_MODE (X)))
end_define

begin_comment
comment|/* Helper functions for instruction scheduling.  */
end_comment

begin_comment
comment|/* An INSN_LIST containing all INSN_LISTs allocated but currently unused.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|unused_insn_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* An EXPR_LIST containing all EXPR_LISTs allocated but currently unused.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|unused_expr_list
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|free_list
name|PROTO
argument_list|(
operator|(
name|rtx
operator|*
operator|,
name|rtx
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|alloc_INSN_LIST
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|alloc_EXPR_LIST
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|free_list
parameter_list|(
name|listp
parameter_list|,
name|unused_listp
parameter_list|)
name|rtx
modifier|*
name|listp
decl_stmt|,
decl|*
name|unused_listp
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|rtx
name|link
decl_stmt|,
name|prev_link
decl_stmt|;
if|if
condition|(
operator|*
name|listp
operator|==
literal|0
condition|)
return|return;
name|prev_link
operator|=
operator|*
name|listp
expr_stmt|;
name|link
operator|=
name|XEXP
argument_list|(
name|prev_link
argument_list|,
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|link
condition|)
block|{
name|prev_link
operator|=
name|link
expr_stmt|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|XEXP
argument_list|(
name|prev_link
argument_list|,
literal|1
argument_list|)
operator|=
operator|*
name|unused_listp
expr_stmt|;
operator|*
name|unused_listp
operator|=
operator|*
name|listp
expr_stmt|;
operator|*
name|listp
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_function
specifier|static
name|rtx
name|alloc_INSN_LIST
parameter_list|(
name|val
parameter_list|,
name|next
parameter_list|)
name|rtx
name|val
decl_stmt|,
name|next
decl_stmt|;
block|{
name|rtx
name|r
decl_stmt|;
if|if
condition|(
name|unused_insn_list
condition|)
block|{
name|r
operator|=
name|unused_insn_list
expr_stmt|;
name|unused_insn_list
operator|=
name|XEXP
argument_list|(
name|r
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|r
argument_list|,
literal|0
argument_list|)
operator|=
name|val
expr_stmt|;
name|XEXP
argument_list|(
name|r
argument_list|,
literal|1
argument_list|)
operator|=
name|next
expr_stmt|;
name|PUT_REG_NOTE_KIND
argument_list|(
name|r
argument_list|,
name|VOIDmode
argument_list|)
expr_stmt|;
block|}
else|else
name|r
operator|=
name|gen_rtx_INSN_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|val
argument_list|,
name|next
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
specifier|static
name|rtx
name|alloc_EXPR_LIST
parameter_list|(
name|kind
parameter_list|,
name|val
parameter_list|,
name|next
parameter_list|)
name|int
name|kind
decl_stmt|;
name|rtx
name|val
decl_stmt|,
name|next
decl_stmt|;
block|{
name|rtx
name|r
decl_stmt|;
if|if
condition|(
name|unused_expr_list
condition|)
block|{
name|r
operator|=
name|unused_expr_list
expr_stmt|;
name|unused_expr_list
operator|=
name|XEXP
argument_list|(
name|r
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|r
argument_list|,
literal|0
argument_list|)
operator|=
name|val
expr_stmt|;
name|XEXP
argument_list|(
name|r
argument_list|,
literal|1
argument_list|)
operator|=
name|next
expr_stmt|;
name|PUT_REG_NOTE_KIND
argument_list|(
name|r
argument_list|,
name|kind
argument_list|)
expr_stmt|;
block|}
else|else
name|r
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|kind
argument_list|,
name|val
argument_list|,
name|next
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Add ELEM wrapped in an INSN_LIST with reg note kind DEP_TYPE to the    LOG_LINKS of INSN, if not already there.  DEP_TYPE indicates the type    of dependence that this link represents.  */
end_comment

begin_function
specifier|static
name|void
name|add_dependence
parameter_list|(
name|insn
parameter_list|,
name|elem
parameter_list|,
name|dep_type
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|rtx
name|elem
decl_stmt|;
name|enum
name|reg_note
name|dep_type
decl_stmt|;
block|{
name|rtx
name|link
decl_stmt|,
name|next
decl_stmt|;
comment|/* Don't depend an insn on itself.  */
if|if
condition|(
name|insn
operator|==
name|elem
condition|)
return|return;
comment|/* We can get a dependency on deleted insns due to optimizations in      the register allocation and reloading or due to splitting.  Any      such dependency is useless and can be ignored.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|elem
argument_list|)
operator|==
name|NOTE
condition|)
return|return;
comment|/* If elem is part of a sequence that must be scheduled together, then      make the dependence point to the last insn of the sequence.      When HAVE_cc0, it is possible for NOTEs to exist between users and      setters of the condition codes, so we must skip past notes here.      Otherwise, NOTEs are impossible here.  */
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|elem
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_cc0
while|while
condition|(
name|next
operator|&&
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|NOTE
condition|)
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|next
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|next
operator|&&
name|SCHED_GROUP_P
argument_list|(
name|next
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|!=
name|CODE_LABEL
condition|)
block|{
comment|/* Notes will never intervene here though, so don't bother checking          for them.  */
comment|/* We must reject CODE_LABELs, so that we don't get confused by one          that has LABEL_PRESERVE_P set, which is represented by the same          bit in the rtl as SCHED_GROUP_P.  A CODE_LABEL can never be          SCHED_GROUP_P.  */
while|while
condition|(
name|NEXT_INSN
argument_list|(
name|next
argument_list|)
operator|&&
name|SCHED_GROUP_P
argument_list|(
name|NEXT_INSN
argument_list|(
name|next
argument_list|)
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|NEXT_INSN
argument_list|(
name|next
argument_list|)
argument_list|)
operator|!=
name|CODE_LABEL
condition|)
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|next
argument_list|)
expr_stmt|;
comment|/* Again, don't depend an insn on itself.  */
if|if
condition|(
name|insn
operator|==
name|next
condition|)
return|return;
comment|/* Make the dependence to NEXT, the last insn of the group, instead          of the original ELEM.  */
name|elem
operator|=
name|next
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|INSN_SCHEDULING
comment|/* (This code is guarded by INSN_SCHEDULING, otherwise INSN_BB is undefined.)      No need for interblock dependences with calls, since      calls are not moved between blocks.   Note: the edge where      elem is a CALL is still required.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
operator|&&
operator|(
name|INSN_BB
argument_list|(
name|elem
argument_list|)
operator|!=
name|INSN_BB
argument_list|(
name|insn
argument_list|)
operator|)
condition|)
return|return;
endif|#
directive|endif
comment|/* Check that we don't already have this dependence.  */
for|for
control|(
name|link
operator|=
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
operator|==
name|elem
condition|)
block|{
comment|/* If this is a more restrictive type of dependence than the existing 	   one, then change the existing dependence to this type.  */
if|if
condition|(
operator|(
name|int
operator|)
name|dep_type
operator|<
operator|(
name|int
operator|)
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
condition|)
name|PUT_REG_NOTE_KIND
argument_list|(
name|link
argument_list|,
name|dep_type
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Might want to check one level of transitivity to save conses.  */
name|link
operator|=
name|alloc_INSN_LIST
argument_list|(
name|elem
argument_list|,
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
operator|=
name|link
expr_stmt|;
comment|/* Insn dependency, not data dependency.  */
name|PUT_REG_NOTE_KIND
argument_list|(
name|link
argument_list|,
name|dep_type
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Remove ELEM wrapped in an INSN_LIST from the LOG_LINKS    of INSN.  Abort if not found.  */
end_comment

begin_function
specifier|static
name|void
name|remove_dependence
parameter_list|(
name|insn
parameter_list|,
name|elem
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|rtx
name|elem
decl_stmt|;
block|{
name|rtx
name|prev
decl_stmt|,
name|link
decl_stmt|,
name|next
decl_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|;
for|for
control|(
name|prev
operator|=
literal|0
operator|,
name|link
operator|=
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|next
control|)
block|{
name|next
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
operator|==
name|elem
condition|)
block|{
if|if
condition|(
name|prev
condition|)
name|XEXP
argument_list|(
name|prev
argument_list|,
literal|1
argument_list|)
operator|=
name|next
expr_stmt|;
else|else
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
operator|=
name|next
expr_stmt|;
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
operator|=
name|unused_insn_list
expr_stmt|;
name|unused_insn_list
operator|=
name|link
expr_stmt|;
name|found
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|prev
operator|=
name|link
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|found
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return;
block|}
end_function

begin_escape
end_escape

begin_ifndef
ifndef|#
directive|ifndef
name|INSN_SCHEDULING
end_ifndef

begin_function
name|void
name|schedule_insns
parameter_list|(
name|dump_file
parameter_list|)
name|FILE
modifier|*
name|dump_file
decl_stmt|;
block|{ }
end_function

begin_else
else|#
directive|else
end_else

begin_ifndef
ifndef|#
directive|ifndef
name|__GNUC__
end_ifndef

begin_define
define|#
directive|define
name|__inline
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|HAIFA_INLINE
end_ifndef

begin_define
define|#
directive|define
name|HAIFA_INLINE
value|__inline
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Computation of memory dependencies.  */
end_comment

begin_comment
comment|/* The *_insns and *_mems are paired lists.  Each pending memory operation    will have a pointer to the MEM rtx on one list and a pointer to the    containing insn on the other list in the same place in the list.  */
end_comment

begin_comment
comment|/* We can't use add_dependence like the old code did, because a single insn    may have multiple memory accesses, and hence needs to be on the list    once for each memory access.  Add_dependence won't let you add an insn    to a list more than once.  */
end_comment

begin_comment
comment|/* An INSN_LIST containing all insns with pending read operations.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|pending_read_insns
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* An EXPR_LIST containing all MEM rtx's which are pending reads.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|pending_read_mems
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* An INSN_LIST containing all insns with pending write operations.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|pending_write_insns
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* An EXPR_LIST containing all MEM rtx's which are pending writes.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|pending_write_mems
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indicates the combined length of the two pending lists.  We must prevent    these lists from ever growing too large since the number of dependencies    produced is at least O(N*N), and execution time is at least O(4*N*N), as    a function of the length of these pending lists.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|pending_lists_length
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The last insn upon which all memory references must depend.    This is an insn which flushed the pending lists, creating a dependency    between it and all previously pending memory references.  This creates    a barrier (or a checkpoint) which no memory reference is allowed to cross.     This includes all non constant CALL_INSNs.  When we do interprocedural    alias analysis, this restriction can be relaxed.    This may also be an INSN that writes memory if the pending lists grow    too large.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|last_pending_memory_flush
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The last function call we have seen.  All hard regs, and, of course,    the last function call, must depend on this.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|last_function_call
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The LOG_LINKS field of this is a list of insns which use a pseudo register    that does not already cross a call.  We create dependencies between each    of those insn and the next call insn, to ensure that they won't cross a call    after scheduling is done.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|sched_before_next_call
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer to the last instruction scheduled.  Used by rank_for_schedule,    so that insns independent of the last scheduled insn will be preferred    over dependent instructions.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|last_scheduled_insn
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Data structures for the computation of data dependences in a regions.  We    keep one copy of each of the declared above variables for each bb in the    region.  Before analyzing the data dependences for a bb, its variables    are initialized as a function of the variables of its predecessors.  When    the analysis for a bb completes, we save the contents of each variable X    to a corresponding bb_X[bb] variable.  For example, pending_read_insns is    copied to bb_pending_read_insns[bb].  Another change is that few    variables are now a list of insns rather than a single insn:    last_pending_memory_flash, last_function_call, reg_last_sets.  The    manipulation of these variables was changed appropriately.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
modifier|*
modifier|*
name|bb_reg_last_uses
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
modifier|*
modifier|*
name|bb_reg_last_sets
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
modifier|*
modifier|*
name|bb_reg_last_clobbers
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
modifier|*
name|bb_pending_read_insns
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
modifier|*
name|bb_pending_read_mems
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
modifier|*
name|bb_pending_write_insns
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
modifier|*
name|bb_pending_write_mems
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
modifier|*
name|bb_pending_lists_length
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
modifier|*
name|bb_last_pending_memory_flush
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
modifier|*
name|bb_last_function_call
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
modifier|*
name|bb_sched_before_next_call
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* functions for construction of the control flow graph.  */
end_comment

begin_comment
comment|/* Return 1 if control flow graph should not be constructed, 0 otherwise.     We decide not to build the control flow graph if there is possibly more    than one entry to the function, if computed branches exist, of if we    have nonlocal gotos.  */
end_comment

begin_function
specifier|static
name|int
name|is_cfg_nonregular
parameter_list|()
block|{
name|int
name|b
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|RTX_CODE
name|code
decl_stmt|;
comment|/* If we have a label that could be the target of a nonlocal goto, then      the cfg is not well structured.  */
if|if
condition|(
name|nonlocal_goto_handler_labels
condition|)
return|return
literal|1
return|;
comment|/* If we have any forced labels, then the cfg is not well structured.  */
if|if
condition|(
name|forced_labels
condition|)
return|return
literal|1
return|;
comment|/* If this function has a computed jump, then we consider the cfg      not well structured.  */
if|if
condition|(
name|current_function_has_computed_jump
condition|)
return|return
literal|1
return|;
comment|/* If we have exception handlers, then we consider the cfg not well      structured.  ?!?  We should be able to handle this now that flow.c      computes an accurate cfg for EH.  */
if|if
condition|(
name|exception_handler_labels
condition|)
return|return
literal|1
return|;
comment|/* If we have non-jumping insns which refer to labels, then we consider      the cfg not well structured.  */
comment|/* check for labels referred to other thn by jumps */
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|n_basic_blocks
condition|;
name|b
operator|++
control|)
for|for
control|(
name|insn
operator|=
name|BLOCK_HEAD
argument_list|(
name|b
argument_list|)
init|;
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|code
operator|=
name|GET_CODE
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'i'
condition|)
block|{
name|rtx
name|note
decl_stmt|;
for|for
control|(
name|note
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|note
condition|;
name|note
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
operator|==
name|REG_LABEL
condition|)
return|return
literal|1
return|;
block|}
if|if
condition|(
name|insn
operator|==
name|BLOCK_END
argument_list|(
name|b
argument_list|)
condition|)
break|break;
block|}
comment|/* All the tests passed.  Consider the cfg well structured.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Build the control flow graph and set nr_edges.     Instead of trying to build a cfg ourselves, we rely on flow to    do it for us.  Stamp out useless code (and bug) duplication.     Return nonzero if an irregularity in the cfg is found which would    prevent cross block scheduling.  */
end_comment

begin_function
specifier|static
name|int
name|build_control_flow
parameter_list|(
name|s_preds
parameter_list|,
name|s_succs
parameter_list|,
name|num_preds
parameter_list|,
name|num_succs
parameter_list|)
name|int_list_ptr
modifier|*
name|s_preds
decl_stmt|;
name|int_list_ptr
modifier|*
name|s_succs
decl_stmt|;
name|int
modifier|*
name|num_preds
decl_stmt|;
name|int
modifier|*
name|num_succs
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int_list_ptr
name|succ
decl_stmt|;
name|int
name|unreachable
decl_stmt|;
comment|/* Count the number of edges in the cfg.  */
name|nr_edges
operator|=
literal|0
expr_stmt|;
name|unreachable
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
name|i
operator|++
control|)
block|{
name|nr_edges
operator|+=
name|num_succs
index|[
name|i
index|]
expr_stmt|;
comment|/* Unreachable loops with more than one basic block are detected 	 during the DFS traversal in find_rgns.  	 Unreachable loops with a single block are detected here.  This 	 test is redundant with the one in find_rgns, but it's much 	 cheaper to go ahead and catch the trivial case here.  */
if|if
condition|(
name|num_preds
index|[
name|i
index|]
operator|==
literal|0
operator|||
operator|(
name|num_preds
index|[
name|i
index|]
operator|==
literal|1
operator|&&
name|INT_LIST_VAL
argument_list|(
name|s_preds
index|[
name|i
index|]
argument_list|)
operator|==
name|i
operator|)
condition|)
name|unreachable
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Account for entry/exit edges.  */
name|nr_edges
operator|+=
literal|2
expr_stmt|;
name|in_edges
operator|=
operator|(
name|int
operator|*
operator|)
name|xmalloc
argument_list|(
name|n_basic_blocks
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|out_edges
operator|=
operator|(
name|int
operator|*
operator|)
name|xmalloc
argument_list|(
name|n_basic_blocks
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|in_edges
argument_list|,
name|n_basic_blocks
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|out_edges
argument_list|,
name|n_basic_blocks
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|edge_table
operator|=
operator|(
name|haifa_edge
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|nr_edges
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|haifa_edge
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|edge_table
argument_list|,
operator|(
operator|(
name|nr_edges
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|haifa_edge
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|nr_edges
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
name|i
operator|++
control|)
for|for
control|(
name|succ
operator|=
name|s_succs
index|[
name|i
index|]
init|;
name|succ
condition|;
name|succ
operator|=
name|succ
operator|->
name|next
control|)
block|{
if|if
condition|(
name|INT_LIST_VAL
argument_list|(
name|succ
argument_list|)
operator|!=
name|EXIT_BLOCK
condition|)
name|new_edge
argument_list|(
name|i
argument_list|,
name|INT_LIST_VAL
argument_list|(
name|succ
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* increment by 1, since edge 0 is unused.  */
name|nr_edges
operator|++
expr_stmt|;
return|return
name|unreachable
return|;
block|}
end_function

begin_comment
comment|/* Record an edge in the control flow graph from SOURCE to TARGET.     In theory, this is redundant with the s_succs computed above, but    we have not converted all of haifa to use information from the    integer lists.  */
end_comment

begin_function
specifier|static
name|void
name|new_edge
parameter_list|(
name|source
parameter_list|,
name|target
parameter_list|)
name|int
name|source
decl_stmt|,
name|target
decl_stmt|;
block|{
name|int
name|e
decl_stmt|,
name|next_edge
decl_stmt|;
name|int
name|curr_edge
decl_stmt|,
name|fst_edge
decl_stmt|;
comment|/* check for duplicates */
name|fst_edge
operator|=
name|curr_edge
operator|=
name|OUT_EDGES
argument_list|(
name|source
argument_list|)
expr_stmt|;
while|while
condition|(
name|curr_edge
condition|)
block|{
if|if
condition|(
name|FROM_BLOCK
argument_list|(
name|curr_edge
argument_list|)
operator|==
name|source
operator|&&
name|TO_BLOCK
argument_list|(
name|curr_edge
argument_list|)
operator|==
name|target
condition|)
block|{
return|return;
block|}
name|curr_edge
operator|=
name|NEXT_OUT
argument_list|(
name|curr_edge
argument_list|)
expr_stmt|;
if|if
condition|(
name|fst_edge
operator|==
name|curr_edge
condition|)
break|break;
block|}
name|e
operator|=
operator|++
name|nr_edges
expr_stmt|;
name|FROM_BLOCK
argument_list|(
name|e
argument_list|)
operator|=
name|source
expr_stmt|;
name|TO_BLOCK
argument_list|(
name|e
argument_list|)
operator|=
name|target
expr_stmt|;
if|if
condition|(
name|OUT_EDGES
argument_list|(
name|source
argument_list|)
condition|)
block|{
name|next_edge
operator|=
name|NEXT_OUT
argument_list|(
name|OUT_EDGES
argument_list|(
name|source
argument_list|)
argument_list|)
expr_stmt|;
name|NEXT_OUT
argument_list|(
name|OUT_EDGES
argument_list|(
name|source
argument_list|)
argument_list|)
operator|=
name|e
expr_stmt|;
name|NEXT_OUT
argument_list|(
name|e
argument_list|)
operator|=
name|next_edge
expr_stmt|;
block|}
else|else
block|{
name|OUT_EDGES
argument_list|(
name|source
argument_list|)
operator|=
name|e
expr_stmt|;
name|NEXT_OUT
argument_list|(
name|e
argument_list|)
operator|=
name|e
expr_stmt|;
block|}
if|if
condition|(
name|IN_EDGES
argument_list|(
name|target
argument_list|)
condition|)
block|{
name|next_edge
operator|=
name|NEXT_IN
argument_list|(
name|IN_EDGES
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
name|NEXT_IN
argument_list|(
name|IN_EDGES
argument_list|(
name|target
argument_list|)
argument_list|)
operator|=
name|e
expr_stmt|;
name|NEXT_IN
argument_list|(
name|e
argument_list|)
operator|=
name|next_edge
expr_stmt|;
block|}
else|else
block|{
name|IN_EDGES
argument_list|(
name|target
argument_list|)
operator|=
name|e
expr_stmt|;
name|NEXT_IN
argument_list|(
name|e
argument_list|)
operator|=
name|e
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* BITSET macros for operations on the control flow graph.  */
end_comment

begin_comment
comment|/* Compute  bitwise union  of two  bitsets.  */
end_comment

begin_define
define|#
directive|define
name|BITSET_UNION
parameter_list|(
name|set1
parameter_list|,
name|set2
parameter_list|,
name|len
parameter_list|)
define|\
value|do { register bitset tp = set1, sp = set2;                           \      register int i;                                                 \      for (i = 0; i< len; i++)                                       \        *(tp++) |= *(sp++); } while (0)
end_define

begin_comment
comment|/* Compute  bitwise intersection  of two  bitsets.  */
end_comment

begin_define
define|#
directive|define
name|BITSET_INTER
parameter_list|(
name|set1
parameter_list|,
name|set2
parameter_list|,
name|len
parameter_list|)
define|\
value|do { register bitset tp = set1, sp = set2;                           \      register int i;                                                 \      for (i = 0; i< len; i++)                                       \        *(tp++)&= *(sp++); } while (0)
end_define

begin_comment
comment|/* Compute bitwise   difference of  two bitsets.  */
end_comment

begin_define
define|#
directive|define
name|BITSET_DIFFER
parameter_list|(
name|set1
parameter_list|,
name|set2
parameter_list|,
name|len
parameter_list|)
define|\
value|do { register bitset tp = set1, sp = set2;                           \      register int i;                                                 \      for (i = 0; i< len; i++)                                       \        *(tp++)&= ~*(sp++); } while (0)
end_define

begin_comment
comment|/* Inverts every bit of bitset 'set' */
end_comment

begin_define
define|#
directive|define
name|BITSET_INVERT
parameter_list|(
name|set
parameter_list|,
name|len
parameter_list|)
define|\
value|do { register bitset tmpset = set;                                   \      register int i;                                                 \      for (i = 0; i< len; i++, tmpset++)                             \        *tmpset = ~*tmpset; } while (0)
end_define

begin_comment
comment|/* Turn on the index'th bit in bitset set.  */
end_comment

begin_define
define|#
directive|define
name|BITSET_ADD
parameter_list|(
name|set
parameter_list|,
name|index
parameter_list|,
name|len
parameter_list|)
define|\
value|{                                                                    \   if (index>= HOST_BITS_PER_WIDE_INT * len)                         \     abort ();                                                        \   else                                                               \     set[index/HOST_BITS_PER_WIDE_INT] |=			     \       1<< (index % HOST_BITS_PER_WIDE_INT);                         \ }
end_define

begin_comment
comment|/* Turn off the index'th bit in set.  */
end_comment

begin_define
define|#
directive|define
name|BITSET_REMOVE
parameter_list|(
name|set
parameter_list|,
name|index
parameter_list|,
name|len
parameter_list|)
define|\
value|{                                                                    \   if (index>= HOST_BITS_PER_WIDE_INT * len)                         \     abort ();                                                        \   else                                                               \     set[index/HOST_BITS_PER_WIDE_INT]&=			     \       ~(1<< (index%HOST_BITS_PER_WIDE_INT));                        \ }
end_define

begin_comment
comment|/* Check if the index'th bit in bitset  set is on.  */
end_comment

begin_function
specifier|static
name|char
name|bitset_member
parameter_list|(
name|set
parameter_list|,
name|index
parameter_list|,
name|len
parameter_list|)
name|bitset
name|set
decl_stmt|;
name|int
name|index
decl_stmt|,
name|len
decl_stmt|;
block|{
if|if
condition|(
name|index
operator|>=
name|HOST_BITS_PER_WIDE_INT
operator|*
name|len
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
operator|(
name|set
index|[
name|index
operator|/
name|HOST_BITS_PER_WIDE_INT
index|]
operator|&
literal|1
operator|<<
operator|(
name|index
operator|%
name|HOST_BITS_PER_WIDE_INT
operator|)
operator|)
condition|?
literal|1
else|:
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Translate a bit-set SET to a list BL of the bit-set members.  */
end_comment

begin_function
specifier|static
name|void
name|extract_bitlst
parameter_list|(
name|set
parameter_list|,
name|len
parameter_list|,
name|bl
parameter_list|)
name|bitset
name|set
decl_stmt|;
name|int
name|len
decl_stmt|;
name|bitlst
modifier|*
name|bl
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|offset
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|word
decl_stmt|;
comment|/* bblst table space is reused in each call to extract_bitlst */
name|bitlst_table_last
operator|=
literal|0
expr_stmt|;
name|bl
operator|->
name|first_member
operator|=
operator|&
name|bitlst_table
index|[
name|bitlst_table_last
index|]
expr_stmt|;
name|bl
operator|->
name|nr_members
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|word
operator|=
name|set
index|[
name|i
index|]
expr_stmt|;
name|offset
operator|=
name|i
operator|*
name|HOST_BITS_PER_WIDE_INT
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|word
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|word
operator|&
literal|1
condition|)
block|{
name|bitlst_table
index|[
name|bitlst_table_last
operator|++
index|]
operator|=
name|offset
expr_stmt|;
operator|(
name|bl
operator|->
name|nr_members
operator|)
operator|++
expr_stmt|;
block|}
name|word
operator|>>=
literal|1
expr_stmt|;
operator|++
name|offset
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* functions for the construction of regions */
end_comment

begin_comment
comment|/* Print the regions, for debugging purposes.  Callable from debugger.  */
end_comment

begin_function
name|void
name|debug_regions
parameter_list|()
block|{
name|int
name|rgn
decl_stmt|,
name|bb
decl_stmt|;
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|"\n;;   ------------ REGIONS ----------\n\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|rgn
operator|=
literal|0
init|;
name|rgn
operator|<
name|nr_regions
condition|;
name|rgn
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|";;\trgn %d nr_blocks %d:\n"
argument_list|,
name|rgn
argument_list|,
name|rgn_table
index|[
name|rgn
index|]
operator|.
name|rgn_nr_blocks
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|";;\tbb/block: "
argument_list|)
expr_stmt|;
for|for
control|(
name|bb
operator|=
literal|0
init|;
name|bb
operator|<
name|rgn_table
index|[
name|rgn
index|]
operator|.
name|rgn_nr_blocks
condition|;
name|bb
operator|++
control|)
block|{
name|current_blocks
operator|=
name|RGN_BLOCKS
argument_list|(
name|rgn
argument_list|)
expr_stmt|;
if|if
condition|(
name|bb
operator|!=
name|BLOCK_TO_BB
argument_list|(
name|BB_TO_BLOCK
argument_list|(
name|bb
argument_list|)
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|" %d/%d "
argument_list|,
name|bb
argument_list|,
name|BB_TO_BLOCK
argument_list|(
name|bb
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|"\n\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Build a single block region for each basic block in the function.    This allows for using the same code for interblock and basic block    scheduling.  */
end_comment

begin_function
specifier|static
name|void
name|find_single_block_region
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
name|i
operator|++
control|)
block|{
name|rgn_bb_table
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
name|RGN_NR_BLOCKS
argument_list|(
name|i
argument_list|)
operator|=
literal|1
expr_stmt|;
name|RGN_BLOCKS
argument_list|(
name|i
argument_list|)
operator|=
name|i
expr_stmt|;
name|CONTAINING_RGN
argument_list|(
name|i
argument_list|)
operator|=
name|i
expr_stmt|;
name|BLOCK_TO_BB
argument_list|(
name|i
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
name|nr_regions
operator|=
name|n_basic_blocks
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Update number of blocks and the estimate for number of insns    in the region.  Return 1 if the region is "too large" for interblock    scheduling (compile time considerations), otherwise return 0.  */
end_comment

begin_function
specifier|static
name|int
name|too_large
parameter_list|(
name|block
parameter_list|,
name|num_bbs
parameter_list|,
name|num_insns
parameter_list|)
name|int
name|block
decl_stmt|,
decl|*
name|num_bbs
decl_stmt|,
modifier|*
name|num_insns
decl_stmt|;
end_function

begin_block
block|{
operator|(
operator|*
name|num_bbs
operator|)
operator|++
expr_stmt|;
operator|(
operator|*
name|num_insns
operator|)
operator|+=
operator|(
name|INSN_LUID
argument_list|(
name|BLOCK_END
argument_list|(
name|block
argument_list|)
argument_list|)
operator|-
name|INSN_LUID
argument_list|(
name|BLOCK_HEAD
argument_list|(
name|block
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|num_bbs
operator|>
name|MAX_RGN_BLOCKS
operator|)
operator|||
operator|(
operator|*
name|num_insns
operator|>
name|MAX_RGN_INSNS
operator|)
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* Update_loop_relations(blk, hdr): Check if the loop headed by max_hdr[blk]    is still an inner loop.  Put in max_hdr[blk] the header of the most inner    loop containing blk.  */
end_comment

begin_define
define|#
directive|define
name|UPDATE_LOOP_RELATIONS
parameter_list|(
name|blk
parameter_list|,
name|hdr
parameter_list|)
define|\
value|{                                                                    \   if (max_hdr[blk] == -1)                                            \     max_hdr[blk] = hdr;                                              \   else if (dfs_nr[max_hdr[blk]]> dfs_nr[hdr])                       \          RESET_BIT (inner, hdr);                                     \   else if (dfs_nr[max_hdr[blk]]< dfs_nr[hdr])                       \          {                                                           \             RESET_BIT (inner,max_hdr[blk]);			     \             max_hdr[blk] = hdr;                                      \          }                                                           \ }
end_define

begin_comment
comment|/* Find regions for interblock scheduling.     A region for scheduling can be:       * A loop-free procedure, or       * A reducible inner loop, or       * A basic block not contained in any other region.      ?!? In theory we could build other regions based on extended basic    blocks or reverse extended basic blocks.  Is it worth the trouble?     Loop blocks that form a region are put into the region's block list    in topological order.     This procedure stores its results into the following global (ick) variables       * rgn_nr      * rgn_table      * rgn_bb_table      * block_to_bb      * containing region      We use dominator relationships to avoid making regions out of non-reducible    loops.     This procedure needs to be converted to work on pred/succ lists instead    of edge tables.  That would simplify it somewhat.  */
end_comment

begin_function
specifier|static
name|void
name|find_rgns
parameter_list|(
name|s_preds
parameter_list|,
name|s_succs
parameter_list|,
name|num_preds
parameter_list|,
name|num_succs
parameter_list|,
name|dom
parameter_list|)
name|int_list_ptr
modifier|*
name|s_preds
decl_stmt|;
name|int_list_ptr
modifier|*
name|s_succs
decl_stmt|;
name|int
modifier|*
name|num_preds
decl_stmt|;
name|int
modifier|*
name|num_succs
decl_stmt|;
name|sbitmap
modifier|*
name|dom
decl_stmt|;
block|{
name|int
modifier|*
name|max_hdr
decl_stmt|,
modifier|*
name|dfs_nr
decl_stmt|,
modifier|*
name|stack
decl_stmt|,
modifier|*
name|queue
decl_stmt|,
modifier|*
name|degree
decl_stmt|;
name|char
name|no_loops
init|=
literal|1
decl_stmt|;
name|int
name|node
decl_stmt|,
name|child
decl_stmt|,
name|loop_head
decl_stmt|,
name|i
decl_stmt|,
name|head
decl_stmt|,
name|tail
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|,
name|sp
decl_stmt|,
name|idx
init|=
literal|0
decl_stmt|,
name|current_edge
init|=
name|out_edges
index|[
literal|0
index|]
decl_stmt|;
name|int
name|num_bbs
decl_stmt|,
name|num_insns
decl_stmt|,
name|unreachable
decl_stmt|;
name|int
name|too_large_failure
decl_stmt|;
comment|/* Note if an edge has been passed.  */
name|sbitmap
name|passed
decl_stmt|;
comment|/* Note if a block is a natural loop header.  */
name|sbitmap
name|header
decl_stmt|;
comment|/* Note if a block is an natural inner loop header.  */
name|sbitmap
name|inner
decl_stmt|;
comment|/* Note if a block is in the block queue. */
name|sbitmap
name|in_queue
decl_stmt|;
comment|/* Note if a block is in the block queue. */
name|sbitmap
name|in_stack
decl_stmt|;
comment|/* Perform a DFS traversal of the cfg.  Identify loop headers, inner loops      and a mapping from block to its loop header (if the block is contained      in a loop, else -1).       Store results in HEADER, INNER, and MAX_HDR respectively, these will      be used as inputs to the second traversal.       STACK, SP and DFS_NR are only used during the first traversal.  */
comment|/* Allocate and initialize variables for the first traversal.  */
name|max_hdr
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|n_basic_blocks
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|dfs_nr
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|n_basic_blocks
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dfs_nr
argument_list|,
name|n_basic_blocks
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|stack
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|nr_edges
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|inner
operator|=
name|sbitmap_alloc
argument_list|(
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|sbitmap_ones
argument_list|(
name|inner
argument_list|)
expr_stmt|;
name|header
operator|=
name|sbitmap_alloc
argument_list|(
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|header
argument_list|)
expr_stmt|;
name|passed
operator|=
name|sbitmap_alloc
argument_list|(
name|nr_edges
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|passed
argument_list|)
expr_stmt|;
name|in_queue
operator|=
name|sbitmap_alloc
argument_list|(
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|in_queue
argument_list|)
expr_stmt|;
name|in_stack
operator|=
name|sbitmap_alloc
argument_list|(
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|in_stack
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
name|i
operator|++
control|)
name|max_hdr
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* DFS traversal to find inner loops in the cfg.  */
name|sp
operator|=
operator|-
literal|1
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|current_edge
operator|==
literal|0
operator|||
name|TEST_BIT
argument_list|(
name|passed
argument_list|,
name|current_edge
argument_list|)
condition|)
block|{
comment|/* We have reached a leaf node or a node that was already 	     processed.  Pop edges off the stack until we find 	     an edge that has not yet been processed.  */
while|while
condition|(
name|sp
operator|>=
literal|0
operator|&&
operator|(
name|current_edge
operator|==
literal|0
operator|||
name|TEST_BIT
argument_list|(
name|passed
argument_list|,
name|current_edge
argument_list|)
operator|)
condition|)
block|{
comment|/* Pop entry off the stack.  */
name|current_edge
operator|=
name|stack
index|[
name|sp
operator|--
index|]
expr_stmt|;
name|node
operator|=
name|FROM_BLOCK
argument_list|(
name|current_edge
argument_list|)
expr_stmt|;
name|child
operator|=
name|TO_BLOCK
argument_list|(
name|current_edge
argument_list|)
expr_stmt|;
name|RESET_BIT
argument_list|(
name|in_stack
argument_list|,
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
name|max_hdr
index|[
name|child
index|]
operator|>=
literal|0
operator|&&
name|TEST_BIT
argument_list|(
name|in_stack
argument_list|,
name|max_hdr
index|[
name|child
index|]
argument_list|)
condition|)
name|UPDATE_LOOP_RELATIONS
argument_list|(
name|node
argument_list|,
name|max_hdr
index|[
name|child
index|]
argument_list|)
expr_stmt|;
name|current_edge
operator|=
name|NEXT_OUT
argument_list|(
name|current_edge
argument_list|)
expr_stmt|;
block|}
comment|/* See if have finished the DFS tree traversal.  */
if|if
condition|(
name|sp
operator|<
literal|0
operator|&&
name|TEST_BIT
argument_list|(
name|passed
argument_list|,
name|current_edge
argument_list|)
condition|)
break|break;
comment|/* Nope, continue the traversal with the popped node.  */
continue|continue;
block|}
comment|/* Process a node.  */
name|node
operator|=
name|FROM_BLOCK
argument_list|(
name|current_edge
argument_list|)
expr_stmt|;
name|child
operator|=
name|TO_BLOCK
argument_list|(
name|current_edge
argument_list|)
expr_stmt|;
name|SET_BIT
argument_list|(
name|in_stack
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|dfs_nr
index|[
name|node
index|]
operator|=
operator|++
name|count
expr_stmt|;
comment|/* If the successor is in the stack, then we've found a loop. 	 Mark the loop, if it is not a natural loop, then it will 	 be rejected during the second traversal.  */
if|if
condition|(
name|TEST_BIT
argument_list|(
name|in_stack
argument_list|,
name|child
argument_list|)
condition|)
block|{
name|no_loops
operator|=
literal|0
expr_stmt|;
name|SET_BIT
argument_list|(
name|header
argument_list|,
name|child
argument_list|)
expr_stmt|;
name|UPDATE_LOOP_RELATIONS
argument_list|(
name|node
argument_list|,
name|child
argument_list|)
expr_stmt|;
name|SET_BIT
argument_list|(
name|passed
argument_list|,
name|current_edge
argument_list|)
expr_stmt|;
name|current_edge
operator|=
name|NEXT_OUT
argument_list|(
name|current_edge
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* If the child was already visited, then there is no need to visit 	 it again.  Just update the loop relationships and restart 	 with a new edge.  */
if|if
condition|(
name|dfs_nr
index|[
name|child
index|]
condition|)
block|{
if|if
condition|(
name|max_hdr
index|[
name|child
index|]
operator|>=
literal|0
operator|&&
name|TEST_BIT
argument_list|(
name|in_stack
argument_list|,
name|max_hdr
index|[
name|child
index|]
argument_list|)
condition|)
name|UPDATE_LOOP_RELATIONS
argument_list|(
name|node
argument_list|,
name|max_hdr
index|[
name|child
index|]
argument_list|)
expr_stmt|;
name|SET_BIT
argument_list|(
name|passed
argument_list|,
name|current_edge
argument_list|)
expr_stmt|;
name|current_edge
operator|=
name|NEXT_OUT
argument_list|(
name|current_edge
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Push an entry on the stack and continue DFS traversal.  */
name|stack
index|[
operator|++
name|sp
index|]
operator|=
name|current_edge
expr_stmt|;
name|SET_BIT
argument_list|(
name|passed
argument_list|,
name|current_edge
argument_list|)
expr_stmt|;
name|current_edge
operator|=
name|OUT_EDGES
argument_list|(
name|child
argument_list|)
expr_stmt|;
block|}
comment|/* Another check for unreachable blocks.  The earlier test in      is_cfg_nonregular only finds unreachable blocks that do not      form a loop.       The DFS traversal will mark every block that is reachable from      the entry node by placing a nonzero value in dfs_nr.  Thus if      dfs_nr is zero for any block, then it must be unreachable.  */
name|unreachable
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|dfs_nr
index|[
name|i
index|]
operator|==
literal|0
condition|)
block|{
name|unreachable
operator|=
literal|1
expr_stmt|;
break|break;
block|}
comment|/* Gross.  To avoid wasting memory, the second pass uses the dfs_nr array      to hold degree counts.  */
name|degree
operator|=
name|dfs_nr
expr_stmt|;
comment|/* Compute the in-degree of every block in the graph */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
name|i
operator|++
control|)
name|degree
index|[
name|i
index|]
operator|=
name|num_preds
index|[
name|i
index|]
expr_stmt|;
comment|/* Do not perform region scheduling if there are any unreachable      blocks.  */
if|if
condition|(
operator|!
name|unreachable
condition|)
block|{
if|if
condition|(
name|no_loops
condition|)
name|SET_BIT
argument_list|(
name|header
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Second travsersal:find reducible inner loops and topologically sort 	 block of each region.  */
name|queue
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|n_basic_blocks
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Find blocks which are inner loop headers.  We still have non-reducible 	 loops to consider at this point.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|TEST_BIT
argument_list|(
name|header
argument_list|,
name|i
argument_list|)
operator|&&
name|TEST_BIT
argument_list|(
name|inner
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|int_list_ptr
name|ps
decl_stmt|;
name|int
name|j
decl_stmt|;
comment|/* Now check that the loop is reducible.  We do this separate 		 from finding inner loops so that we do not find a reducible 		 loop which contains an inner  non-reducible loop.  		 A simple way to find reducible/natrual loops is to verify 		 that each block in the loop is dominated by the loop 		 header.  		 If there exists a block that is not dominated by the loop 		 header, then the block is reachable from outside the loop 		 and thus the loop is not a natural loop.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n_basic_blocks
condition|;
name|j
operator|++
control|)
block|{
comment|/* First identify blocks in the loop, except for the loop 		     entry block.  */
if|if
condition|(
name|i
operator|==
name|max_hdr
index|[
name|j
index|]
operator|&&
name|i
operator|!=
name|j
condition|)
block|{
comment|/* Now verify that the block is dominated by the loop 			 header.  */
if|if
condition|(
operator|!
name|TEST_BIT
argument_list|(
name|dom
index|[
name|j
index|]
argument_list|,
name|i
argument_list|)
condition|)
break|break;
block|}
block|}
comment|/* If we exited the loop early, then I is the header of a non 		 reducible loop and we should quit processing it now.  */
if|if
condition|(
name|j
operator|!=
name|n_basic_blocks
condition|)
continue|continue;
comment|/* I is a header of an inner loop, or block 0 in a subroutine 		 with no loops at all.  */
name|head
operator|=
name|tail
operator|=
operator|-
literal|1
expr_stmt|;
name|too_large_failure
operator|=
literal|0
expr_stmt|;
name|loop_head
operator|=
name|max_hdr
index|[
name|i
index|]
expr_stmt|;
comment|/* Decrease degree of all I's successors for topological 		 ordering.  */
for|for
control|(
name|ps
operator|=
name|s_succs
index|[
name|i
index|]
init|;
name|ps
condition|;
name|ps
operator|=
name|ps
operator|->
name|next
control|)
if|if
condition|(
name|INT_LIST_VAL
argument_list|(
name|ps
argument_list|)
operator|!=
name|EXIT_BLOCK
operator|&&
name|INT_LIST_VAL
argument_list|(
name|ps
argument_list|)
operator|!=
name|ENTRY_BLOCK
condition|)
operator|--
name|degree
index|[
name|INT_LIST_VAL
argument_list|(
name|ps
argument_list|)
index|]
expr_stmt|;
comment|/* Estimate # insns, and count # blocks in the region.  */
name|num_bbs
operator|=
literal|1
expr_stmt|;
name|num_insns
operator|=
operator|(
name|INSN_LUID
argument_list|(
name|BLOCK_END
argument_list|(
name|i
argument_list|)
argument_list|)
operator|-
name|INSN_LUID
argument_list|(
name|BLOCK_HEAD
argument_list|(
name|i
argument_list|)
argument_list|)
operator|)
expr_stmt|;
comment|/* Find all loop latches (blocks which back edges to the loop 		 header) or all the leaf blocks in the cfg has no loops.  		 Place those blocks into the queue.  */
if|if
condition|(
name|no_loops
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n_basic_blocks
condition|;
name|j
operator|++
control|)
comment|/* Leaf nodes have only a single successor which must 		       be EXIT_BLOCK.  */
if|if
condition|(
name|num_succs
index|[
name|j
index|]
operator|==
literal|1
operator|&&
name|INT_LIST_VAL
argument_list|(
name|s_succs
index|[
name|j
index|]
argument_list|)
operator|==
name|EXIT_BLOCK
condition|)
block|{
name|queue
index|[
operator|++
name|tail
index|]
operator|=
name|j
expr_stmt|;
name|SET_BIT
argument_list|(
name|in_queue
argument_list|,
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|too_large
argument_list|(
name|j
argument_list|,
operator|&
name|num_bbs
argument_list|,
operator|&
name|num_insns
argument_list|)
condition|)
block|{
name|too_large_failure
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
else|else
block|{
name|int_list_ptr
name|ps
decl_stmt|;
for|for
control|(
name|ps
operator|=
name|s_preds
index|[
name|i
index|]
init|;
name|ps
condition|;
name|ps
operator|=
name|ps
operator|->
name|next
control|)
block|{
name|node
operator|=
name|INT_LIST_VAL
argument_list|(
name|ps
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|==
name|ENTRY_BLOCK
operator|||
name|node
operator|==
name|EXIT_BLOCK
condition|)
continue|continue;
if|if
condition|(
name|max_hdr
index|[
name|node
index|]
operator|==
name|loop_head
operator|&&
name|node
operator|!=
name|i
condition|)
block|{
comment|/* This is a loop latch.  */
name|queue
index|[
operator|++
name|tail
index|]
operator|=
name|node
expr_stmt|;
name|SET_BIT
argument_list|(
name|in_queue
argument_list|,
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|too_large
argument_list|(
name|node
argument_list|,
operator|&
name|num_bbs
argument_list|,
operator|&
name|num_insns
argument_list|)
condition|)
block|{
name|too_large_failure
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
comment|/* Now add all the blocks in the loop to the queue.  	     We know the loop is a natural loop; however the algorithm 	     above will not always mark certain blocks as being in the 	     loop.  Consider: 		node   children 		 a	  b,c 		 b	  c 		 c	  a,d 		 d	  b   	     The algorithm in the DFS traversal may not mark B& D as part 	     of the loop (ie they will not have max_hdr set to A).  	     We know they can not be loop latches (else they would have 	     had max_hdr set since they'd have a backedge to a dominator 	     block).  So we don't need them on the initial queue.  	     We know they are part of the loop because they are dominated 	     by the loop header and can be reached by a backwards walk of 	     the edges starting with nodes on the initial queue.  	     It is safe and desirable to include those nodes in the 	     loop/scheduling region.  To do so we would need to decrease 	     the degree of a node if it is the target of a backedge 	     within the loop itself as the node is placed in the queue.  	     We do not do this because I'm not sure that the actual 	     scheduling code will properly handle this case. ?!? */
while|while
condition|(
name|head
operator|<
name|tail
operator|&&
operator|!
name|too_large_failure
condition|)
block|{
name|int_list_ptr
name|ps
decl_stmt|;
name|child
operator|=
name|queue
index|[
operator|++
name|head
index|]
expr_stmt|;
for|for
control|(
name|ps
operator|=
name|s_preds
index|[
name|child
index|]
init|;
name|ps
condition|;
name|ps
operator|=
name|ps
operator|->
name|next
control|)
block|{
name|node
operator|=
name|INT_LIST_VAL
argument_list|(
name|ps
argument_list|)
expr_stmt|;
comment|/* See discussion above about nodes not marked as in 			 this loop during the initial DFS traversal.  */
if|if
condition|(
name|node
operator|==
name|ENTRY_BLOCK
operator|||
name|node
operator|==
name|EXIT_BLOCK
operator|||
name|max_hdr
index|[
name|node
index|]
operator|!=
name|loop_head
condition|)
block|{
name|tail
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
operator|!
name|TEST_BIT
argument_list|(
name|in_queue
argument_list|,
name|node
argument_list|)
operator|&&
name|node
operator|!=
name|i
condition|)
block|{
name|queue
index|[
operator|++
name|tail
index|]
operator|=
name|node
expr_stmt|;
name|SET_BIT
argument_list|(
name|in_queue
argument_list|,
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|too_large
argument_list|(
name|node
argument_list|,
operator|&
name|num_bbs
argument_list|,
operator|&
name|num_insns
argument_list|)
condition|)
block|{
name|too_large_failure
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
if|if
condition|(
name|tail
operator|>=
literal|0
operator|&&
operator|!
name|too_large_failure
condition|)
block|{
comment|/* Place the loop header into list of region blocks.  */
name|degree
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|rgn_bb_table
index|[
name|idx
index|]
operator|=
name|i
expr_stmt|;
name|RGN_NR_BLOCKS
argument_list|(
name|nr_regions
argument_list|)
operator|=
name|num_bbs
expr_stmt|;
name|RGN_BLOCKS
argument_list|(
name|nr_regions
argument_list|)
operator|=
name|idx
operator|++
expr_stmt|;
name|CONTAINING_RGN
argument_list|(
name|i
argument_list|)
operator|=
name|nr_regions
expr_stmt|;
name|BLOCK_TO_BB
argument_list|(
name|i
argument_list|)
operator|=
name|count
operator|=
literal|0
expr_stmt|;
comment|/* Remove blocks from queue[] when their in degree becomes 		 zero.  Repeat until no blocks are left on the list.  This 		 produces a topological list of blocks in the region.  */
while|while
condition|(
name|tail
operator|>=
literal|0
condition|)
block|{
name|int_list_ptr
name|ps
decl_stmt|;
if|if
condition|(
name|head
operator|<
literal|0
condition|)
name|head
operator|=
name|tail
expr_stmt|;
name|child
operator|=
name|queue
index|[
name|head
index|]
expr_stmt|;
if|if
condition|(
name|degree
index|[
name|child
index|]
operator|==
literal|0
condition|)
block|{
name|degree
index|[
name|child
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|rgn_bb_table
index|[
name|idx
operator|++
index|]
operator|=
name|child
expr_stmt|;
name|BLOCK_TO_BB
argument_list|(
name|child
argument_list|)
operator|=
operator|++
name|count
expr_stmt|;
name|CONTAINING_RGN
argument_list|(
name|child
argument_list|)
operator|=
name|nr_regions
expr_stmt|;
name|queue
index|[
name|head
index|]
operator|=
name|queue
index|[
name|tail
operator|--
index|]
expr_stmt|;
for|for
control|(
name|ps
operator|=
name|s_succs
index|[
name|child
index|]
init|;
name|ps
condition|;
name|ps
operator|=
name|ps
operator|->
name|next
control|)
if|if
condition|(
name|INT_LIST_VAL
argument_list|(
name|ps
argument_list|)
operator|!=
name|ENTRY_BLOCK
operator|&&
name|INT_LIST_VAL
argument_list|(
name|ps
argument_list|)
operator|!=
name|EXIT_BLOCK
condition|)
operator|--
name|degree
index|[
name|INT_LIST_VAL
argument_list|(
name|ps
argument_list|)
index|]
expr_stmt|;
block|}
else|else
operator|--
name|head
expr_stmt|;
block|}
operator|++
name|nr_regions
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* Any block that did not end up in a region is placed into a region      by itself.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|degree
index|[
name|i
index|]
operator|>=
literal|0
condition|)
block|{
name|rgn_bb_table
index|[
name|idx
index|]
operator|=
name|i
expr_stmt|;
name|RGN_NR_BLOCKS
argument_list|(
name|nr_regions
argument_list|)
operator|=
literal|1
expr_stmt|;
name|RGN_BLOCKS
argument_list|(
name|nr_regions
argument_list|)
operator|=
name|idx
operator|++
expr_stmt|;
name|CONTAINING_RGN
argument_list|(
name|i
argument_list|)
operator|=
name|nr_regions
operator|++
expr_stmt|;
name|BLOCK_TO_BB
argument_list|(
name|i
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
name|free
argument_list|(
name|passed
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|header
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|inner
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|in_queue
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|in_stack
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* functions for regions scheduling information */
end_comment

begin_comment
comment|/* Compute dominators, probability, and potential-split-edges of bb.    Assume that these values were already computed for bb's predecessors.  */
end_comment

begin_function
specifier|static
name|void
name|compute_dom_prob_ps
parameter_list|(
name|bb
parameter_list|)
name|int
name|bb
decl_stmt|;
block|{
name|int
name|nxt_in_edge
decl_stmt|,
name|fst_in_edge
decl_stmt|,
name|pred
decl_stmt|;
name|int
name|fst_out_edge
decl_stmt|,
name|nxt_out_edge
decl_stmt|,
name|nr_out_edges
decl_stmt|,
name|nr_rgn_out_edges
decl_stmt|;
name|prob
index|[
name|bb
index|]
operator|=
literal|0.0
expr_stmt|;
if|if
condition|(
name|IS_RGN_ENTRY
argument_list|(
name|bb
argument_list|)
condition|)
block|{
name|BITSET_ADD
argument_list|(
name|dom
index|[
name|bb
index|]
argument_list|,
literal|0
argument_list|,
name|bbset_size
argument_list|)
expr_stmt|;
name|prob
index|[
name|bb
index|]
operator|=
literal|1.0
expr_stmt|;
return|return;
block|}
name|fst_in_edge
operator|=
name|nxt_in_edge
operator|=
name|IN_EDGES
argument_list|(
name|BB_TO_BLOCK
argument_list|(
name|bb
argument_list|)
argument_list|)
expr_stmt|;
comment|/* intialize dom[bb] to '111..1' */
name|BITSET_INVERT
argument_list|(
name|dom
index|[
name|bb
index|]
argument_list|,
name|bbset_size
argument_list|)
expr_stmt|;
do|do
block|{
name|pred
operator|=
name|FROM_BLOCK
argument_list|(
name|nxt_in_edge
argument_list|)
expr_stmt|;
name|BITSET_INTER
argument_list|(
name|dom
index|[
name|bb
index|]
argument_list|,
name|dom
index|[
name|BLOCK_TO_BB
argument_list|(
name|pred
argument_list|)
index|]
argument_list|,
name|bbset_size
argument_list|)
expr_stmt|;
name|BITSET_UNION
argument_list|(
name|ancestor_edges
index|[
name|bb
index|]
argument_list|,
name|ancestor_edges
index|[
name|BLOCK_TO_BB
argument_list|(
name|pred
argument_list|)
index|]
argument_list|,
name|edgeset_size
argument_list|)
expr_stmt|;
name|BITSET_ADD
argument_list|(
name|ancestor_edges
index|[
name|bb
index|]
argument_list|,
name|EDGE_TO_BIT
argument_list|(
name|nxt_in_edge
argument_list|)
argument_list|,
name|edgeset_size
argument_list|)
expr_stmt|;
name|nr_out_edges
operator|=
literal|1
expr_stmt|;
name|nr_rgn_out_edges
operator|=
literal|0
expr_stmt|;
name|fst_out_edge
operator|=
name|OUT_EDGES
argument_list|(
name|pred
argument_list|)
expr_stmt|;
name|nxt_out_edge
operator|=
name|NEXT_OUT
argument_list|(
name|fst_out_edge
argument_list|)
expr_stmt|;
name|BITSET_UNION
argument_list|(
name|pot_split
index|[
name|bb
index|]
argument_list|,
name|pot_split
index|[
name|BLOCK_TO_BB
argument_list|(
name|pred
argument_list|)
index|]
argument_list|,
name|edgeset_size
argument_list|)
expr_stmt|;
name|BITSET_ADD
argument_list|(
name|pot_split
index|[
name|bb
index|]
argument_list|,
name|EDGE_TO_BIT
argument_list|(
name|fst_out_edge
argument_list|)
argument_list|,
name|edgeset_size
argument_list|)
expr_stmt|;
comment|/* the successor doesn't belong the region? */
if|if
condition|(
name|CONTAINING_RGN
argument_list|(
name|TO_BLOCK
argument_list|(
name|fst_out_edge
argument_list|)
argument_list|)
operator|!=
name|CONTAINING_RGN
argument_list|(
name|BB_TO_BLOCK
argument_list|(
name|bb
argument_list|)
argument_list|)
condition|)
operator|++
name|nr_rgn_out_edges
expr_stmt|;
while|while
condition|(
name|fst_out_edge
operator|!=
name|nxt_out_edge
condition|)
block|{
operator|++
name|nr_out_edges
expr_stmt|;
comment|/* the successor doesn't belong the region? */
if|if
condition|(
name|CONTAINING_RGN
argument_list|(
name|TO_BLOCK
argument_list|(
name|nxt_out_edge
argument_list|)
argument_list|)
operator|!=
name|CONTAINING_RGN
argument_list|(
name|BB_TO_BLOCK
argument_list|(
name|bb
argument_list|)
argument_list|)
condition|)
operator|++
name|nr_rgn_out_edges
expr_stmt|;
name|BITSET_ADD
argument_list|(
name|pot_split
index|[
name|bb
index|]
argument_list|,
name|EDGE_TO_BIT
argument_list|(
name|nxt_out_edge
argument_list|)
argument_list|,
name|edgeset_size
argument_list|)
expr_stmt|;
name|nxt_out_edge
operator|=
name|NEXT_OUT
argument_list|(
name|nxt_out_edge
argument_list|)
expr_stmt|;
block|}
comment|/* now nr_rgn_out_edges is the number of region-exit edges from pred,          and nr_out_edges will be the number of pred out edges not leaving          the region.  */
name|nr_out_edges
operator|-=
name|nr_rgn_out_edges
expr_stmt|;
if|if
condition|(
name|nr_rgn_out_edges
operator|>
literal|0
condition|)
name|prob
index|[
name|bb
index|]
operator|+=
literal|0.9
operator|*
name|prob
index|[
name|BLOCK_TO_BB
argument_list|(
name|pred
argument_list|)
index|]
operator|/
name|nr_out_edges
expr_stmt|;
else|else
name|prob
index|[
name|bb
index|]
operator|+=
name|prob
index|[
name|BLOCK_TO_BB
argument_list|(
name|pred
argument_list|)
index|]
operator|/
name|nr_out_edges
expr_stmt|;
name|nxt_in_edge
operator|=
name|NEXT_IN
argument_list|(
name|nxt_in_edge
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|fst_in_edge
operator|!=
name|nxt_in_edge
condition|)
do|;
name|BITSET_ADD
argument_list|(
name|dom
index|[
name|bb
index|]
argument_list|,
name|bb
argument_list|,
name|bbset_size
argument_list|)
expr_stmt|;
name|BITSET_DIFFER
argument_list|(
name|pot_split
index|[
name|bb
index|]
argument_list|,
name|ancestor_edges
index|[
name|bb
index|]
argument_list|,
name|edgeset_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|sched_verbose
operator|>=
literal|2
condition|)
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|";;  bb_prob(%d, %d) = %3d\n"
argument_list|,
name|bb
argument_list|,
name|BB_TO_BLOCK
argument_list|(
name|bb
argument_list|)
argument_list|,
call|(
name|int
call|)
argument_list|(
literal|100.0
operator|*
name|prob
index|[
name|bb
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* compute_dom_prob_ps */
end_comment

begin_comment
comment|/* functions for target info */
end_comment

begin_comment
comment|/* Compute in BL the list of split-edges of bb_src relatively to bb_trg.    Note that bb_trg dominates bb_src.  */
end_comment

begin_function
specifier|static
name|void
name|split_edges
parameter_list|(
name|bb_src
parameter_list|,
name|bb_trg
parameter_list|,
name|bl
parameter_list|)
name|int
name|bb_src
decl_stmt|;
name|int
name|bb_trg
decl_stmt|;
name|edgelst
modifier|*
name|bl
decl_stmt|;
block|{
name|int
name|es
init|=
name|edgeset_size
decl_stmt|;
name|edgeset
name|src
init|=
operator|(
name|edgeset
operator|)
name|alloca
argument_list|(
name|es
operator|*
sizeof|sizeof
argument_list|(
name|HOST_WIDE_INT
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
name|es
operator|--
condition|)
name|src
index|[
name|es
index|]
operator|=
operator|(
name|pot_split
index|[
name|bb_src
index|]
operator|)
index|[
name|es
index|]
expr_stmt|;
name|BITSET_DIFFER
argument_list|(
name|src
argument_list|,
name|pot_split
index|[
name|bb_trg
index|]
argument_list|,
name|edgeset_size
argument_list|)
expr_stmt|;
name|extract_bitlst
argument_list|(
name|src
argument_list|,
name|edgeset_size
argument_list|,
name|bl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Find the valid candidate-source-blocks for the target block TRG, compute    their probability, and check if they are speculative or not.    For speculative sources, compute their update-blocks and split-blocks.  */
end_comment

begin_function
specifier|static
name|void
name|compute_trg_info
parameter_list|(
name|trg
parameter_list|)
name|int
name|trg
decl_stmt|;
block|{
specifier|register
name|candidate
modifier|*
name|sp
decl_stmt|;
name|edgelst
name|el
decl_stmt|;
name|int
name|check_block
decl_stmt|,
name|update_idx
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|fst_edge
decl_stmt|,
name|nxt_edge
decl_stmt|;
comment|/* define some of the fields for the target bb as well */
name|sp
operator|=
name|candidate_table
operator|+
name|trg
expr_stmt|;
name|sp
operator|->
name|is_valid
operator|=
literal|1
expr_stmt|;
name|sp
operator|->
name|is_speculative
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|src_prob
operator|=
literal|100
expr_stmt|;
for|for
control|(
name|i
operator|=
name|trg
operator|+
literal|1
init|;
name|i
operator|<
name|current_nr_blocks
condition|;
name|i
operator|++
control|)
block|{
name|sp
operator|=
name|candidate_table
operator|+
name|i
expr_stmt|;
name|sp
operator|->
name|is_valid
operator|=
name|IS_DOMINATED
argument_list|(
name|i
argument_list|,
name|trg
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|is_valid
condition|)
block|{
name|sp
operator|->
name|src_prob
operator|=
name|GET_SRC_PROB
argument_list|(
name|i
argument_list|,
name|trg
argument_list|)
expr_stmt|;
name|sp
operator|->
name|is_valid
operator|=
operator|(
name|sp
operator|->
name|src_prob
operator|>=
name|MIN_PROBABILITY
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|sp
operator|->
name|is_valid
condition|)
block|{
name|split_edges
argument_list|(
name|i
argument_list|,
name|trg
argument_list|,
operator|&
name|el
argument_list|)
expr_stmt|;
name|sp
operator|->
name|is_speculative
operator|=
operator|(
name|el
operator|.
name|nr_members
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|is_speculative
operator|&&
operator|!
name|flag_schedule_speculative
condition|)
name|sp
operator|->
name|is_valid
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|sp
operator|->
name|is_valid
condition|)
block|{
name|sp
operator|->
name|split_bbs
operator|.
name|first_member
operator|=
operator|&
name|bblst_table
index|[
name|bblst_last
index|]
expr_stmt|;
name|sp
operator|->
name|split_bbs
operator|.
name|nr_members
operator|=
name|el
operator|.
name|nr_members
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|el
operator|.
name|nr_members
condition|;
name|bblst_last
operator|++
operator|,
name|j
operator|++
control|)
name|bblst_table
index|[
name|bblst_last
index|]
operator|=
name|TO_BLOCK
argument_list|(
name|rgn_edges
index|[
name|el
operator|.
name|first_member
index|[
name|j
index|]
index|]
argument_list|)
expr_stmt|;
name|sp
operator|->
name|update_bbs
operator|.
name|first_member
operator|=
operator|&
name|bblst_table
index|[
name|bblst_last
index|]
expr_stmt|;
name|update_idx
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|el
operator|.
name|nr_members
condition|;
name|j
operator|++
control|)
block|{
name|check_block
operator|=
name|FROM_BLOCK
argument_list|(
name|rgn_edges
index|[
name|el
operator|.
name|first_member
index|[
name|j
index|]
index|]
argument_list|)
expr_stmt|;
name|fst_edge
operator|=
name|nxt_edge
operator|=
name|OUT_EDGES
argument_list|(
name|check_block
argument_list|)
expr_stmt|;
do|do
block|{
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|el
operator|.
name|nr_members
condition|;
name|k
operator|++
control|)
if|if
condition|(
name|EDGE_TO_BIT
argument_list|(
name|nxt_edge
argument_list|)
operator|==
name|el
operator|.
name|first_member
index|[
name|k
index|]
condition|)
break|break;
if|if
condition|(
name|k
operator|>=
name|el
operator|.
name|nr_members
condition|)
block|{
name|bblst_table
index|[
name|bblst_last
operator|++
index|]
operator|=
name|TO_BLOCK
argument_list|(
name|nxt_edge
argument_list|)
expr_stmt|;
name|update_idx
operator|++
expr_stmt|;
block|}
name|nxt_edge
operator|=
name|NEXT_OUT
argument_list|(
name|nxt_edge
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|fst_edge
operator|!=
name|nxt_edge
condition|)
do|;
block|}
name|sp
operator|->
name|update_bbs
operator|.
name|nr_members
operator|=
name|update_idx
expr_stmt|;
block|}
else|else
block|{
name|sp
operator|->
name|split_bbs
operator|.
name|nr_members
operator|=
name|sp
operator|->
name|update_bbs
operator|.
name|nr_members
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|is_speculative
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|src_prob
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* compute_trg_info */
end_comment

begin_comment
comment|/* Print candidates info, for debugging purposes.  Callable from debugger.  */
end_comment

begin_function
name|void
name|debug_candidate
parameter_list|(
name|i
parameter_list|)
name|int
name|i
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|candidate_table
index|[
name|i
index|]
operator|.
name|is_valid
condition|)
return|return;
if|if
condition|(
name|candidate_table
index|[
name|i
index|]
operator|.
name|is_speculative
condition|)
block|{
name|int
name|j
decl_stmt|;
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|"src b %d bb %d speculative \n"
argument_list|,
name|BB_TO_BLOCK
argument_list|(
name|i
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|"split path: "
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|candidate_table
index|[
name|i
index|]
operator|.
name|split_bbs
operator|.
name|nr_members
condition|;
name|j
operator|++
control|)
block|{
name|int
name|b
init|=
name|candidate_table
index|[
name|i
index|]
operator|.
name|split_bbs
operator|.
name|first_member
index|[
name|j
index|]
decl_stmt|;
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|" %d "
argument_list|,
name|b
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|"update path: "
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|candidate_table
index|[
name|i
index|]
operator|.
name|update_bbs
operator|.
name|nr_members
condition|;
name|j
operator|++
control|)
block|{
name|int
name|b
init|=
name|candidate_table
index|[
name|i
index|]
operator|.
name|update_bbs
operator|.
name|first_member
index|[
name|j
index|]
decl_stmt|;
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|" %d "
argument_list|,
name|b
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|" src %d equivalent\n"
argument_list|,
name|BB_TO_BLOCK
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print candidates info, for debugging purposes.  Callable from debugger.  */
end_comment

begin_function
name|void
name|debug_candidates
parameter_list|(
name|trg
parameter_list|)
name|int
name|trg
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|"----------- candidate table: target: b=%d bb=%d ---\n"
argument_list|,
name|BB_TO_BLOCK
argument_list|(
name|trg
argument_list|)
argument_list|,
name|trg
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|trg
operator|+
literal|1
init|;
name|i
operator|<
name|current_nr_blocks
condition|;
name|i
operator|++
control|)
name|debug_candidate
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* functions for speculative scheduing */
end_comment

begin_comment
comment|/* Return 0 if x is a set of a register alive in the beginning of one    of the split-blocks of src, otherwise return 1.  */
end_comment

begin_function
specifier|static
name|int
name|check_live_1
parameter_list|(
name|src
parameter_list|,
name|x
parameter_list|)
name|int
name|src
decl_stmt|;
name|rtx
name|x
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|regno
decl_stmt|;
specifier|register
name|rtx
name|reg
init|=
name|SET_DEST
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|reg
operator|==
literal|0
condition|)
return|return
literal|1
return|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SIGN_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|STRICT_LOW_PART
condition|)
name|reg
operator|=
name|XEXP
argument_list|(
name|reg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|GET_MODE
argument_list|(
name|reg
argument_list|)
operator|==
name|BLKmode
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|reg
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|check_live_1
argument_list|(
name|src
argument_list|,
name|XVECEXP
argument_list|(
name|reg
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|!=
name|REG
condition|)
return|return
literal|1
return|;
name|regno
operator|=
name|REGNO
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|global_regs
index|[
name|regno
index|]
condition|)
block|{
comment|/* Global registers are assumed live */
return|return
literal|0
return|;
block|}
else|else
block|{
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
comment|/* check for hard registers */
name|int
name|j
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
operator|--
name|j
operator|>=
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|candidate_table
index|[
name|src
index|]
operator|.
name|split_bbs
operator|.
name|nr_members
condition|;
name|i
operator|++
control|)
block|{
name|int
name|b
init|=
name|candidate_table
index|[
name|src
index|]
operator|.
name|split_bbs
operator|.
name|first_member
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|REGNO_REG_SET_P
argument_list|(
name|BASIC_BLOCK
argument_list|(
name|b
argument_list|)
operator|->
name|global_live_at_start
argument_list|,
name|regno
operator|+
name|j
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
block|}
block|}
block|}
block|}
else|else
block|{
comment|/* check for psuedo registers */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|candidate_table
index|[
name|src
index|]
operator|.
name|split_bbs
operator|.
name|nr_members
condition|;
name|i
operator|++
control|)
block|{
name|int
name|b
init|=
name|candidate_table
index|[
name|src
index|]
operator|.
name|split_bbs
operator|.
name|first_member
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|REGNO_REG_SET_P
argument_list|(
name|BASIC_BLOCK
argument_list|(
name|b
argument_list|)
operator|->
name|global_live_at_start
argument_list|,
name|regno
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
block|}
block|}
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* If x is a set of a register R, mark that R is alive in the beginning    of every update-block of src.  */
end_comment

begin_function
specifier|static
name|void
name|update_live_1
parameter_list|(
name|src
parameter_list|,
name|x
parameter_list|)
name|int
name|src
decl_stmt|;
name|rtx
name|x
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|regno
decl_stmt|;
specifier|register
name|rtx
name|reg
init|=
name|SET_DEST
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|reg
operator|==
literal|0
condition|)
return|return;
while|while
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SIGN_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|STRICT_LOW_PART
condition|)
name|reg
operator|=
name|XEXP
argument_list|(
name|reg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|GET_MODE
argument_list|(
name|reg
argument_list|)
operator|==
name|BLKmode
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|reg
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|update_live_1
argument_list|(
name|src
argument_list|,
name|XVECEXP
argument_list|(
name|reg
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|!=
name|REG
condition|)
return|return;
comment|/* Global registers are always live, so the code below does not apply      to them.  */
name|regno
operator|=
name|REGNO
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|||
operator|!
name|global_regs
index|[
name|regno
index|]
condition|)
block|{
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|int
name|j
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
operator|--
name|j
operator|>=
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|candidate_table
index|[
name|src
index|]
operator|.
name|update_bbs
operator|.
name|nr_members
condition|;
name|i
operator|++
control|)
block|{
name|int
name|b
init|=
name|candidate_table
index|[
name|src
index|]
operator|.
name|update_bbs
operator|.
name|first_member
index|[
name|i
index|]
decl_stmt|;
name|SET_REGNO_REG_SET
argument_list|(
name|BASIC_BLOCK
argument_list|(
name|b
argument_list|)
operator|->
name|global_live_at_start
argument_list|,
name|regno
operator|+
name|j
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|candidate_table
index|[
name|src
index|]
operator|.
name|update_bbs
operator|.
name|nr_members
condition|;
name|i
operator|++
control|)
block|{
name|int
name|b
init|=
name|candidate_table
index|[
name|src
index|]
operator|.
name|update_bbs
operator|.
name|first_member
index|[
name|i
index|]
decl_stmt|;
name|SET_REGNO_REG_SET
argument_list|(
name|BASIC_BLOCK
argument_list|(
name|b
argument_list|)
operator|->
name|global_live_at_start
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Return 1 if insn can be speculatively moved from block src to trg,    otherwise return 0.  Called before first insertion of insn to    ready-list or before the scheduling.  */
end_comment

begin_function
specifier|static
name|int
name|check_live
parameter_list|(
name|insn
parameter_list|,
name|src
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|int
name|src
decl_stmt|;
block|{
comment|/* find the registers set by instruction */
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|CLOBBER
condition|)
return|return
name|check_live_1
argument_list|(
name|src
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
argument_list|)
operator|==
name|SET
operator|||
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
argument_list|)
operator|==
name|CLOBBER
operator|)
operator|&&
operator|!
name|check_live_1
argument_list|(
name|src
argument_list|,
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Update the live registers info after insn was moved speculatively from    block src to trg.  */
end_comment

begin_function
specifier|static
name|void
name|update_live
parameter_list|(
name|insn
parameter_list|,
name|src
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|int
name|src
decl_stmt|;
block|{
comment|/* find the registers set by instruction */
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|CLOBBER
condition|)
name|update_live_1
argument_list|(
name|src
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
argument_list|)
operator|==
name|SET
operator|||
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
argument_list|)
operator|==
name|CLOBBER
condition|)
name|update_live_1
argument_list|(
name|src
argument_list|,
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Exception Free Loads:     We define five classes of speculative loads: IFREE, IRISKY,    PFREE, PRISKY, and MFREE.     IFREE loads are loads that are proved to be exception-free, just    by examining the load insn.  Examples for such loads are loads    from TOC and loads of global data.     IRISKY loads are loads that are proved to be exception-risky,    just by examining the load insn.  Examples for such loads are    volatile loads and loads from shared memory.     PFREE loads are loads for which we can prove, by examining other    insns, that they are exception-free.  Currently, this class consists    of loads for which we are able to find a "similar load", either in    the target block, or, if only one split-block exists, in that split    block.  Load2 is similar to load1 if both have same single base    register.  We identify only part of the similar loads, by finding    an insn upon which both load1 and load2 have a DEF-USE dependence.     PRISKY loads are loads for which we can prove, by examining other    insns, that they are exception-risky.  Currently we have two proofs for    such loads.  The first proof detects loads that are probably guarded by a    test on the memory address.  This proof is based on the    backward and forward data dependence information for the region.    Let load-insn be the examined load.    Load-insn is PRISKY iff ALL the following hold:     - insn1 is not in the same block as load-insn    - there is a DEF-USE dependence chain (insn1, ..., load-insn)    - test-insn is either a compare or a branch, not in the same block as load-insn    - load-insn is reachable from test-insn    - there is a DEF-USE dependence chain (insn1, ..., test-insn)     This proof might fail when the compare and the load are fed    by an insn not in the region.  To solve this, we will add to this    group all loads that have no input DEF-USE dependence.     The second proof detects loads that are directly or indirectly    fed by a speculative load.  This proof is affected by the    scheduling process.  We will use the flag  fed_by_spec_load.    Initially, all insns have this flag reset.  After a speculative    motion of an insn, if insn is either a load, or marked as    fed_by_spec_load, we will also mark as fed_by_spec_load every    insn1 for which a DEF-USE dependence (insn, insn1) exists.  A    load which is fed_by_spec_load is also PRISKY.     MFREE (maybe-free) loads are all the remaining loads. They may be    exception-free, but we cannot prove it.     Now, all loads in IFREE and PFREE classes are considered    exception-free, while all loads in IRISKY and PRISKY classes are    considered exception-risky.  As for loads in the MFREE class,    these are considered either exception-free or exception-risky,    depending on whether we are pessimistic or optimistic.  We have    to take the pessimistic approach to assure the safety of    speculative scheduling, but we can take the optimistic approach    by invoking the -fsched_spec_load_dangerous option.  */
end_comment

begin_enum
enum|enum
name|INSN_TRAP_CLASS
block|{
name|TRAP_FREE
init|=
literal|0
block|,
name|IFREE
init|=
literal|1
block|,
name|PFREE_CANDIDATE
init|=
literal|2
block|,
name|PRISKY_CANDIDATE
init|=
literal|3
block|,
name|IRISKY
init|=
literal|4
block|,
name|TRAP_RISKY
init|=
literal|5
block|}
enum|;
end_enum

begin_define
define|#
directive|define
name|WORST_CLASS
parameter_list|(
name|class1
parameter_list|,
name|class2
parameter_list|)
define|\
value|((class1> class2) ? class1 : class2)
end_define

begin_comment
comment|/* Indexed by INSN_UID, and set if there's DEF-USE dependence between */
end_comment

begin_comment
comment|/* some speculatively moved load insn and this one.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|fed_by_spec_load
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|is_load_insn
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero if block bb_to is equal to, or reachable from block bb_from.  */
end_comment

begin_define
define|#
directive|define
name|IS_REACHABLE
parameter_list|(
name|bb_from
parameter_list|,
name|bb_to
parameter_list|)
define|\
value|(bb_from == bb_to                                                       \    || IS_RGN_ENTRY (bb_from)						\    || (bitset_member (ancestor_edges[bb_to],				\ 		      EDGE_TO_BIT (IN_EDGES (BB_TO_BLOCK (bb_from))),	\ 		      edgeset_size)))
end_define

begin_define
define|#
directive|define
name|FED_BY_SPEC_LOAD
parameter_list|(
name|insn
parameter_list|)
value|(fed_by_spec_load[INSN_UID (insn)])
end_define

begin_define
define|#
directive|define
name|IS_LOAD_INSN
parameter_list|(
name|insn
parameter_list|)
value|(is_load_insn[INSN_UID (insn)])
end_define

begin_comment
comment|/* Non-zero iff the address is comprised from at most 1 register */
end_comment

begin_define
define|#
directive|define
name|CONST_BASED_ADDRESS_P
parameter_list|(
name|x
parameter_list|)
define|\
value|(GET_CODE (x) == REG					\    || ((GET_CODE (x) == PLUS || GET_CODE (x) == MINUS   \ 	|| (GET_CODE (x) == LO_SUM))	                \&& (GET_CODE (XEXP (x, 0)) == CONST_INT		\ 	   || GET_CODE (XEXP (x, 1)) == CONST_INT)))
end_define

begin_comment
comment|/* Turns on the fed_by_spec_load flag for insns fed by load_insn.  */
end_comment

begin_function
specifier|static
name|void
name|set_spec_fed
parameter_list|(
name|load_insn
parameter_list|)
name|rtx
name|load_insn
decl_stmt|;
block|{
name|rtx
name|link
decl_stmt|;
for|for
control|(
name|link
operator|=
name|INSN_DEPEND
argument_list|(
name|load_insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|GET_MODE
argument_list|(
name|link
argument_list|)
operator|==
name|VOIDmode
condition|)
name|FED_BY_SPEC_LOAD
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* set_spec_fed */
end_comment

begin_comment
comment|/* On the path from the insn to load_insn_bb, find a conditional branch */
end_comment

begin_comment
comment|/* depending on insn, that guards the speculative load.  */
end_comment

begin_function
specifier|static
name|int
name|find_conditional_protection
parameter_list|(
name|insn
parameter_list|,
name|load_insn_bb
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|int
name|load_insn_bb
decl_stmt|;
block|{
name|rtx
name|link
decl_stmt|;
comment|/* iterate through DEF-USE forward dependences */
for|for
control|(
name|link
operator|=
name|INSN_DEPEND
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|rtx
name|next
init|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|CONTAINING_RGN
argument_list|(
name|INSN_BLOCK
argument_list|(
name|next
argument_list|)
argument_list|)
operator|==
name|CONTAINING_RGN
argument_list|(
name|BB_TO_BLOCK
argument_list|(
name|load_insn_bb
argument_list|)
argument_list|)
operator|)
operator|&&
name|IS_REACHABLE
argument_list|(
name|INSN_BB
argument_list|(
name|next
argument_list|)
argument_list|,
name|load_insn_bb
argument_list|)
operator|&&
name|load_insn_bb
operator|!=
name|INSN_BB
argument_list|(
name|next
argument_list|)
operator|&&
name|GET_MODE
argument_list|(
name|link
argument_list|)
operator|==
name|VOIDmode
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|JUMP_INSN
operator|||
name|find_conditional_protection
argument_list|(
name|next
argument_list|,
name|load_insn_bb
argument_list|)
operator|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* find_conditional_protection */
end_comment

begin_comment
comment|/* Returns 1 if the same insn1 that participates in the computation    of load_insn's address is feeding a conditional branch that is    guarding on load_insn. This is true if we find a the two DEF-USE    chains:    insn1 -> ... -> conditional-branch    insn1 -> ... -> load_insn,    and if a flow path exist:    insn1 -> ... -> conditional-branch -> ... -> load_insn,    and if insn1 is on the path    region-entry -> ... -> bb_trg -> ... load_insn.     Locate insn1 by climbing on LOG_LINKS from load_insn.    Locate the branch by following INSN_DEPEND from insn1.  */
end_comment

begin_function
specifier|static
name|int
name|is_conditionally_protected
parameter_list|(
name|load_insn
parameter_list|,
name|bb_src
parameter_list|,
name|bb_trg
parameter_list|)
name|rtx
name|load_insn
decl_stmt|;
name|int
name|bb_src
decl_stmt|,
name|bb_trg
decl_stmt|;
block|{
name|rtx
name|link
decl_stmt|;
for|for
control|(
name|link
operator|=
name|LOG_LINKS
argument_list|(
name|load_insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|rtx
name|insn1
init|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* must be a DEF-USE dependence upon non-branch */
if|if
condition|(
name|GET_MODE
argument_list|(
name|link
argument_list|)
operator|!=
name|VOIDmode
operator|||
name|GET_CODE
argument_list|(
name|insn1
argument_list|)
operator|==
name|JUMP_INSN
condition|)
continue|continue;
comment|/* must exist a path: region-entry -> ... -> bb_trg -> ... load_insn */
if|if
condition|(
name|INSN_BB
argument_list|(
name|insn1
argument_list|)
operator|==
name|bb_src
operator|||
operator|(
name|CONTAINING_RGN
argument_list|(
name|INSN_BLOCK
argument_list|(
name|insn1
argument_list|)
argument_list|)
operator|!=
name|CONTAINING_RGN
argument_list|(
name|BB_TO_BLOCK
argument_list|(
name|bb_src
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|IS_REACHABLE
argument_list|(
name|bb_trg
argument_list|,
name|INSN_BB
argument_list|(
name|insn1
argument_list|)
argument_list|)
operator|&&
operator|!
name|IS_REACHABLE
argument_list|(
name|INSN_BB
argument_list|(
name|insn1
argument_list|)
argument_list|,
name|bb_trg
argument_list|)
operator|)
condition|)
continue|continue;
comment|/* now search for the conditional-branch */
if|if
condition|(
name|find_conditional_protection
argument_list|(
name|insn1
argument_list|,
name|bb_src
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* recursive step: search another insn1, "above" current insn1.  */
return|return
name|is_conditionally_protected
argument_list|(
name|insn1
argument_list|,
name|bb_src
argument_list|,
name|bb_trg
argument_list|)
return|;
block|}
comment|/* the chain does not exsist */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* is_conditionally_protected */
end_comment

begin_comment
comment|/* Returns 1 if a clue for "similar load" 'insn2' is found, and hence    load_insn can move speculatively from bb_src to bb_trg.  All the    following must hold:     (1) both loads have 1 base register (PFREE_CANDIDATEs).    (2) load_insn and load1 have a def-use dependence upon    the same insn 'insn1'.    (3) either load2 is in bb_trg, or:    - there's only one split-block, and    - load1 is on the escape path, and     From all these we can conclude that the two loads access memory    addresses that differ at most by a constant, and hence if moving    load_insn would cause an exception, it would have been caused by    load2 anyhow.  */
end_comment

begin_function
specifier|static
name|int
name|is_pfree
parameter_list|(
name|load_insn
parameter_list|,
name|bb_src
parameter_list|,
name|bb_trg
parameter_list|)
name|rtx
name|load_insn
decl_stmt|;
name|int
name|bb_src
decl_stmt|,
name|bb_trg
decl_stmt|;
block|{
name|rtx
name|back_link
decl_stmt|;
specifier|register
name|candidate
modifier|*
name|candp
init|=
name|candidate_table
operator|+
name|bb_src
decl_stmt|;
if|if
condition|(
name|candp
operator|->
name|split_bbs
operator|.
name|nr_members
operator|!=
literal|1
condition|)
comment|/* must have exactly one escape block */
return|return
literal|0
return|;
for|for
control|(
name|back_link
operator|=
name|LOG_LINKS
argument_list|(
name|load_insn
argument_list|)
init|;
name|back_link
condition|;
name|back_link
operator|=
name|XEXP
argument_list|(
name|back_link
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|rtx
name|insn1
init|=
name|XEXP
argument_list|(
name|back_link
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|back_link
argument_list|)
operator|==
name|VOIDmode
condition|)
block|{
comment|/* found a DEF-USE dependence (insn1, load_insn) */
name|rtx
name|fore_link
decl_stmt|;
for|for
control|(
name|fore_link
operator|=
name|INSN_DEPEND
argument_list|(
name|insn1
argument_list|)
init|;
name|fore_link
condition|;
name|fore_link
operator|=
name|XEXP
argument_list|(
name|fore_link
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|rtx
name|insn2
init|=
name|XEXP
argument_list|(
name|fore_link
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|fore_link
argument_list|)
operator|==
name|VOIDmode
condition|)
block|{
comment|/* found a DEF-USE dependence (insn1, insn2) */
if|if
condition|(
name|haifa_classify_insn
argument_list|(
name|insn2
argument_list|)
operator|!=
name|PFREE_CANDIDATE
condition|)
comment|/* insn2 not guaranteed to be a 1 base reg load */
continue|continue;
if|if
condition|(
name|INSN_BB
argument_list|(
name|insn2
argument_list|)
operator|==
name|bb_trg
condition|)
comment|/* insn2 is the similar load, in the target block */
return|return
literal|1
return|;
if|if
condition|(
operator|*
operator|(
name|candp
operator|->
name|split_bbs
operator|.
name|first_member
operator|)
operator|==
name|INSN_BLOCK
argument_list|(
name|insn2
argument_list|)
condition|)
comment|/* insn2 is a similar load, in a split-block */
return|return
literal|1
return|;
block|}
block|}
block|}
block|}
comment|/* couldn't find a similar load */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* is_pfree */
end_comment

begin_comment
comment|/* Returns a class that insn with GET_DEST(insn)=x may belong to,    as found by analyzing insn's expression.  */
end_comment

begin_function
specifier|static
name|int
name|may_trap_exp
parameter_list|(
name|x
parameter_list|,
name|is_store
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|int
name|is_store
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return
name|TRAP_FREE
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_store
condition|)
block|{
if|if
condition|(
name|code
operator|==
name|MEM
condition|)
return|return
name|TRAP_RISKY
return|;
else|else
return|return
name|TRAP_FREE
return|;
block|}
if|if
condition|(
name|code
operator|==
name|MEM
condition|)
block|{
comment|/* The insn uses memory */
comment|/* a volatile load */
if|if
condition|(
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|IRISKY
return|;
comment|/* an exception-free load */
if|if
condition|(
operator|!
name|may_trap_p
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|IFREE
return|;
comment|/* a load with 1 base register, to be further checked */
if|if
condition|(
name|CONST_BASED_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|PFREE_CANDIDATE
return|;
comment|/* no info on the load, to be further checked */
return|return
name|PRISKY_CANDIDATE
return|;
block|}
else|else
block|{
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|i
decl_stmt|,
name|insn_class
init|=
name|TRAP_FREE
decl_stmt|;
comment|/* neither store nor load, check if it may cause a trap */
if|if
condition|(
name|may_trap_p
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|TRAP_RISKY
return|;
comment|/* recursive step: walk the insn...  */
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
name|int
name|tmp_class
init|=
name|may_trap_exp
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|is_store
argument_list|)
decl_stmt|;
name|insn_class
operator|=
name|WORST_CLASS
argument_list|(
name|insn_class
argument_list|,
name|tmp_class
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
name|int
name|tmp_class
init|=
name|may_trap_exp
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|is_store
argument_list|)
decl_stmt|;
name|insn_class
operator|=
name|WORST_CLASS
argument_list|(
name|insn_class
argument_list|,
name|tmp_class
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn_class
operator|==
name|TRAP_RISKY
operator|||
name|insn_class
operator|==
name|IRISKY
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|insn_class
operator|==
name|TRAP_RISKY
operator|||
name|insn_class
operator|==
name|IRISKY
condition|)
break|break;
block|}
return|return
name|insn_class
return|;
block|}
block|}
end_function

begin_comment
comment|/* may_trap_exp */
end_comment

begin_comment
comment|/* Classifies insn for the purpose of verifying that it can be    moved speculatively, by examining it's patterns, returning:    TRAP_RISKY: store, or risky non-load insn (e.g. division by variable).    TRAP_FREE: non-load insn.    IFREE: load from a globaly safe location.    IRISKY: volatile load.    PFREE_CANDIDATE, PRISKY_CANDIDATE: load that need to be checked for    being either PFREE or PRISKY.  */
end_comment

begin_function
specifier|static
name|int
name|haifa_classify_insn
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|int
name|tmp_class
init|=
name|TRAP_FREE
decl_stmt|;
name|int
name|insn_class
init|=
name|TRAP_FREE
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
name|int
name|i
decl_stmt|,
name|len
init|=
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
name|len
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|code
operator|=
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CLOBBER
case|:
comment|/* test if it is a 'store' */
name|tmp_class
operator|=
name|may_trap_exp
argument_list|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|SET
case|:
comment|/* test if it is a store */
name|tmp_class
operator|=
name|may_trap_exp
argument_list|(
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp_class
operator|==
name|TRAP_RISKY
condition|)
break|break;
comment|/* test if it is a load  */
name|tmp_class
operator|=
name|WORST_CLASS
argument_list|(
name|tmp_class
argument_list|,
name|may_trap_exp
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TRAP_IF
case|:
name|tmp_class
operator|=
name|TRAP_RISKY
expr_stmt|;
break|break;
default|default:
empty_stmt|;
block|}
name|insn_class
operator|=
name|WORST_CLASS
argument_list|(
name|insn_class
argument_list|,
name|tmp_class
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn_class
operator|==
name|TRAP_RISKY
operator|||
name|insn_class
operator|==
name|IRISKY
condition|)
break|break;
block|}
block|}
else|else
block|{
name|code
operator|=
name|GET_CODE
argument_list|(
name|pat
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CLOBBER
case|:
comment|/* test if it is a 'store' */
name|tmp_class
operator|=
name|may_trap_exp
argument_list|(
name|XEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|SET
case|:
comment|/* test if it is a store */
name|tmp_class
operator|=
name|may_trap_exp
argument_list|(
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp_class
operator|==
name|TRAP_RISKY
condition|)
break|break;
comment|/* test if it is a load  */
name|tmp_class
operator|=
name|WORST_CLASS
argument_list|(
name|tmp_class
argument_list|,
name|may_trap_exp
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TRAP_IF
case|:
name|tmp_class
operator|=
name|TRAP_RISKY
expr_stmt|;
break|break;
default|default:
empty_stmt|;
block|}
name|insn_class
operator|=
name|tmp_class
expr_stmt|;
block|}
return|return
name|insn_class
return|;
block|}
end_function

begin_comment
comment|/* haifa_classify_insn */
end_comment

begin_comment
comment|/* Return 1 if load_insn is prisky (i.e. if load_insn is fed by    a load moved speculatively, or if load_insn is protected by    a compare on load_insn's address).  */
end_comment

begin_function
specifier|static
name|int
name|is_prisky
parameter_list|(
name|load_insn
parameter_list|,
name|bb_src
parameter_list|,
name|bb_trg
parameter_list|)
name|rtx
name|load_insn
decl_stmt|;
name|int
name|bb_src
decl_stmt|,
name|bb_trg
decl_stmt|;
block|{
if|if
condition|(
name|FED_BY_SPEC_LOAD
argument_list|(
name|load_insn
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|LOG_LINKS
argument_list|(
name|load_insn
argument_list|)
operator|==
name|NULL
condition|)
comment|/* dependence may 'hide' out of the region.  */
return|return
literal|1
return|;
if|if
condition|(
name|is_conditionally_protected
argument_list|(
name|load_insn
argument_list|,
name|bb_src
argument_list|,
name|bb_trg
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* is_prisky */
end_comment

begin_comment
comment|/* Insn is a candidate to be moved speculatively from bb_src to bb_trg.    Return 1 if insn is exception-free (and the motion is valid)    and 0 otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|is_exception_free
parameter_list|(
name|insn
parameter_list|,
name|bb_src
parameter_list|,
name|bb_trg
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|int
name|bb_src
decl_stmt|,
name|bb_trg
decl_stmt|;
block|{
name|int
name|insn_class
init|=
name|haifa_classify_insn
argument_list|(
name|insn
argument_list|)
decl_stmt|;
comment|/* handle non-load insns */
switch|switch
condition|(
name|insn_class
condition|)
block|{
case|case
name|TRAP_FREE
case|:
return|return
literal|1
return|;
case|case
name|TRAP_RISKY
case|:
return|return
literal|0
return|;
default|default:
empty_stmt|;
block|}
comment|/* handle loads */
if|if
condition|(
operator|!
name|flag_schedule_speculative_load
condition|)
return|return
literal|0
return|;
name|IS_LOAD_INSN
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
switch|switch
condition|(
name|insn_class
condition|)
block|{
case|case
name|IFREE
case|:
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|IRISKY
case|:
return|return
literal|0
return|;
case|case
name|PFREE_CANDIDATE
case|:
if|if
condition|(
name|is_pfree
argument_list|(
name|insn
argument_list|,
name|bb_src
argument_list|,
name|bb_trg
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* don't 'break' here: PFREE-candidate is also PRISKY-candidate */
case|case
name|PRISKY_CANDIDATE
case|:
if|if
condition|(
operator|!
name|flag_schedule_speculative_load_dangerous
operator|||
name|is_prisky
argument_list|(
name|insn
argument_list|,
name|bb_src
argument_list|,
name|bb_trg
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
default|default:
empty_stmt|;
block|}
return|return
name|flag_schedule_speculative_load_dangerous
return|;
block|}
end_function

begin_comment
comment|/* is_exception_free */
end_comment

begin_comment
comment|/* Process an insn's memory dependencies.  There are four kinds of    dependencies:     (0) read dependence: read follows read    (1) true dependence: read follows write    (2) anti dependence: write follows read    (3) output dependence: write follows write     We are careful to build only dependencies which actually exist, and    use transitivity to avoid building too many links.  */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Return the INSN_LIST containing INSN in LIST, or NULL    if LIST does not contain INSN.  */
end_comment

begin_function
name|HAIFA_INLINE
specifier|static
name|rtx
name|find_insn_list
parameter_list|(
name|insn
parameter_list|,
name|list
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|rtx
name|list
decl_stmt|;
block|{
while|while
condition|(
name|list
condition|)
block|{
if|if
condition|(
name|XEXP
argument_list|(
name|list
argument_list|,
literal|0
argument_list|)
operator|==
name|insn
condition|)
return|return
name|list
return|;
name|list
operator|=
name|XEXP
argument_list|(
name|list
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if the pair (insn, x) is found in (LIST, LIST1), or 0 otherwise.  */
end_comment

begin_function
name|HAIFA_INLINE
specifier|static
name|char
name|find_insn_mem_list
parameter_list|(
name|insn
parameter_list|,
name|x
parameter_list|,
name|list
parameter_list|,
name|list1
parameter_list|)
name|rtx
name|insn
decl_stmt|,
name|x
decl_stmt|;
name|rtx
name|list
decl_stmt|,
name|list1
decl_stmt|;
block|{
while|while
condition|(
name|list
condition|)
block|{
if|if
condition|(
name|XEXP
argument_list|(
name|list
argument_list|,
literal|0
argument_list|)
operator|==
name|insn
operator|&&
name|XEXP
argument_list|(
name|list1
argument_list|,
literal|0
argument_list|)
operator|==
name|x
condition|)
return|return
literal|1
return|;
name|list
operator|=
name|XEXP
argument_list|(
name|list
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|list1
operator|=
name|XEXP
argument_list|(
name|list1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Compute the function units used by INSN.  This caches the value    returned by function_units_used.  A function unit is encoded as the    unit number if the value is non-negative and the compliment of a    mask if the value is negative.  A function unit index is the    non-negative encoding.  */
end_comment

begin_function
name|HAIFA_INLINE
specifier|static
name|int
name|insn_unit
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
specifier|register
name|int
name|unit
init|=
name|INSN_UNIT
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|unit
operator|==
literal|0
condition|)
block|{
name|recog_memoized
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* A USE insn, or something else we don't need to understand.          We can't pass these directly to function_units_used because it will          trigger a fatal error for unrecognizable insns.  */
if|if
condition|(
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|<
literal|0
condition|)
name|unit
operator|=
operator|-
literal|1
expr_stmt|;
else|else
block|{
name|unit
operator|=
name|function_units_used
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Increment non-negative values so we can cache zero.  */
if|if
condition|(
name|unit
operator|>=
literal|0
condition|)
name|unit
operator|++
expr_stmt|;
block|}
comment|/* We only cache 16 bits of the result, so if the value is out of          range, don't cache it.  */
if|if
condition|(
name|FUNCTION_UNITS_SIZE
operator|<
name|HOST_BITS_PER_SHORT
operator|||
name|unit
operator|>=
literal|0
operator|||
operator|(
operator|~
name|unit
operator|&
operator|(
operator|(
literal|1
operator|<<
operator|(
name|HOST_BITS_PER_SHORT
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
condition|)
name|INSN_UNIT
argument_list|(
name|insn
argument_list|)
operator|=
name|unit
expr_stmt|;
block|}
return|return
operator|(
name|unit
operator|>
literal|0
condition|?
name|unit
operator|-
literal|1
else|:
name|unit
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Compute the blockage range for executing INSN on UNIT.  This caches    the value returned by the blockage_range_function for the unit.    These values are encoded in an int where the upper half gives the    minimum value and the lower half gives the maximum value.  */
end_comment

begin_function
name|HAIFA_INLINE
specifier|static
name|unsigned
name|int
name|blockage_range
parameter_list|(
name|unit
parameter_list|,
name|insn
parameter_list|)
name|int
name|unit
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
name|unsigned
name|int
name|blockage
init|=
name|INSN_BLOCKAGE
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|range
decl_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|UNIT_BLOCKED
argument_list|(
name|blockage
argument_list|)
operator|!=
name|unit
operator|+
literal|1
condition|)
block|{
name|range
operator|=
name|function_units
index|[
name|unit
index|]
operator|.
name|blockage_range_function
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* We only cache the blockage range for one unit and then only if          the values fit.  */
if|if
condition|(
name|HOST_BITS_PER_INT
operator|>=
name|UNIT_BITS
operator|+
literal|2
operator|*
name|BLOCKAGE_BITS
condition|)
name|INSN_BLOCKAGE
argument_list|(
name|insn
argument_list|)
operator|=
name|ENCODE_BLOCKAGE
argument_list|(
name|unit
operator|+
literal|1
argument_list|,
name|range
argument_list|)
expr_stmt|;
block|}
else|else
name|range
operator|=
name|BLOCKAGE_RANGE
argument_list|(
name|blockage
argument_list|)
expr_stmt|;
return|return
name|range
return|;
block|}
end_function

begin_comment
comment|/* A vector indexed by function unit instance giving the last insn to use    the unit.  The value of the function unit instance index for unit U    instance I is (U + I * FUNCTION_UNITS_SIZE).  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|unit_last_insn
index|[
name|FUNCTION_UNITS_SIZE
operator|*
name|MAX_MULTIPLICITY
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A vector indexed by function unit instance giving the minimum time when    the unit will unblock based on the maximum blockage cost.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|unit_tick
index|[
name|FUNCTION_UNITS_SIZE
operator|*
name|MAX_MULTIPLICITY
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A vector indexed by function unit number giving the number of insns    that remain to use the unit.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|unit_n_insns
index|[
name|FUNCTION_UNITS_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Reset the function unit state to the null state.  */
end_comment

begin_function
specifier|static
name|void
name|clear_units
parameter_list|()
block|{
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|unit_last_insn
argument_list|,
sizeof|sizeof
argument_list|(
name|unit_last_insn
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|unit_tick
argument_list|,
sizeof|sizeof
argument_list|(
name|unit_tick
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|unit_n_insns
argument_list|,
sizeof|sizeof
argument_list|(
name|unit_n_insns
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the issue-delay of an insn */
end_comment

begin_function
name|HAIFA_INLINE
specifier|static
name|int
name|insn_issue_delay
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|delay
init|=
literal|0
decl_stmt|;
name|int
name|unit
init|=
name|insn_unit
argument_list|(
name|insn
argument_list|)
decl_stmt|;
comment|/* efficiency note: in fact, we are working 'hard' to compute a      value that was available in md file, and is not available in      function_units[] structure.  It would be nice to have this      value there, too.  */
if|if
condition|(
name|unit
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|function_units
index|[
name|unit
index|]
operator|.
name|blockage_range_function
operator|&&
name|function_units
index|[
name|unit
index|]
operator|.
name|blockage_function
condition|)
name|delay
operator|=
name|function_units
index|[
name|unit
index|]
operator|.
name|blockage_function
argument_list|(
name|insn
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
else|else
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|unit
operator|=
operator|~
name|unit
init|;
name|unit
condition|;
name|i
operator|++
operator|,
name|unit
operator|>>=
literal|1
control|)
if|if
condition|(
operator|(
name|unit
operator|&
literal|1
operator|)
operator|!=
literal|0
operator|&&
name|function_units
index|[
name|i
index|]
operator|.
name|blockage_range_function
operator|&&
name|function_units
index|[
name|i
index|]
operator|.
name|blockage_function
condition|)
name|delay
operator|=
name|MAX
argument_list|(
name|delay
argument_list|,
name|function_units
index|[
name|i
index|]
operator|.
name|blockage_function
argument_list|(
name|insn
argument_list|,
name|insn
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|delay
return|;
block|}
end_function

begin_comment
comment|/* Return the actual hazard cost of executing INSN on the unit UNIT,    instance INSTANCE at time CLOCK if the previous actual hazard cost    was COST.  */
end_comment

begin_function
name|HAIFA_INLINE
specifier|static
name|int
name|actual_hazard_this_instance
parameter_list|(
name|unit
parameter_list|,
name|instance
parameter_list|,
name|insn
parameter_list|,
name|clock
parameter_list|,
name|cost
parameter_list|)
name|int
name|unit
decl_stmt|,
name|instance
decl_stmt|,
name|clock
decl_stmt|,
name|cost
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
name|int
name|tick
init|=
name|unit_tick
index|[
name|instance
index|]
decl_stmt|;
comment|/* issue time of the last issued insn */
if|if
condition|(
name|tick
operator|-
name|clock
operator|>
name|cost
condition|)
block|{
comment|/* The scheduler is operating forward, so unit's last insn is the          executing insn and INSN is the candidate insn.  We want a          more exact measure of the blockage if we execute INSN at CLOCK          given when we committed the execution of the unit's last insn.           The blockage value is given by either the unit's max blockage          constant, blockage range function, or blockage function.  Use          the most exact form for the given unit.  */
if|if
condition|(
name|function_units
index|[
name|unit
index|]
operator|.
name|blockage_range_function
condition|)
block|{
if|if
condition|(
name|function_units
index|[
name|unit
index|]
operator|.
name|blockage_function
condition|)
name|tick
operator|+=
operator|(
name|function_units
index|[
name|unit
index|]
operator|.
name|blockage_function
argument_list|(
name|unit_last_insn
index|[
name|instance
index|]
argument_list|,
name|insn
argument_list|)
operator|-
name|function_units
index|[
name|unit
index|]
operator|.
name|max_blockage
operator|)
expr_stmt|;
else|else
name|tick
operator|+=
operator|(
operator|(
name|int
operator|)
name|MAX_BLOCKAGE_COST
argument_list|(
name|blockage_range
argument_list|(
name|unit
argument_list|,
name|insn
argument_list|)
argument_list|)
operator|-
name|function_units
index|[
name|unit
index|]
operator|.
name|max_blockage
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|tick
operator|-
name|clock
operator|>
name|cost
condition|)
name|cost
operator|=
name|tick
operator|-
name|clock
expr_stmt|;
block|}
return|return
name|cost
return|;
block|}
end_function

begin_comment
comment|/* Record INSN as having begun execution on the units encoded by UNIT at    time CLOCK.  */
end_comment

begin_function
name|HAIFA_INLINE
specifier|static
name|void
name|schedule_unit
parameter_list|(
name|unit
parameter_list|,
name|insn
parameter_list|,
name|clock
parameter_list|)
name|int
name|unit
decl_stmt|,
name|clock
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
literal|0
condition|)
block|{
name|int
name|instance
init|=
name|unit
decl_stmt|;
if|#
directive|if
name|MAX_MULTIPLICITY
operator|>
literal|1
comment|/* Find the first free instance of the function unit and use that          one.  We assume that one is free.  */
for|for
control|(
name|i
operator|=
name|function_units
index|[
name|unit
index|]
operator|.
name|multiplicity
operator|-
literal|1
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
operator|!
name|actual_hazard_this_instance
argument_list|(
name|unit
argument_list|,
name|instance
argument_list|,
name|insn
argument_list|,
name|clock
argument_list|,
literal|0
argument_list|)
condition|)
break|break;
name|instance
operator|+=
name|FUNCTION_UNITS_SIZE
expr_stmt|;
block|}
endif|#
directive|endif
name|unit_last_insn
index|[
name|instance
index|]
operator|=
name|insn
expr_stmt|;
name|unit_tick
index|[
name|instance
index|]
operator|=
operator|(
name|clock
operator|+
name|function_units
index|[
name|unit
index|]
operator|.
name|max_blockage
operator|)
expr_stmt|;
block|}
else|else
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|unit
operator|=
operator|~
name|unit
init|;
name|unit
condition|;
name|i
operator|++
operator|,
name|unit
operator|>>=
literal|1
control|)
if|if
condition|(
operator|(
name|unit
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
name|schedule_unit
argument_list|(
name|i
argument_list|,
name|insn
argument_list|,
name|clock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the actual hazard cost of executing INSN on the units encoded by    UNIT at time CLOCK if the previous actual hazard cost was COST.  */
end_comment

begin_function
name|HAIFA_INLINE
specifier|static
name|int
name|actual_hazard
parameter_list|(
name|unit
parameter_list|,
name|insn
parameter_list|,
name|clock
parameter_list|,
name|cost
parameter_list|)
name|int
name|unit
decl_stmt|,
name|clock
decl_stmt|,
name|cost
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
literal|0
condition|)
block|{
comment|/* Find the instance of the function unit with the minimum hazard.  */
name|int
name|instance
init|=
name|unit
decl_stmt|;
name|int
name|best_cost
init|=
name|actual_hazard_this_instance
argument_list|(
name|unit
argument_list|,
name|instance
argument_list|,
name|insn
argument_list|,
name|clock
argument_list|,
name|cost
argument_list|)
decl_stmt|;
name|int
name|this_cost
decl_stmt|;
if|#
directive|if
name|MAX_MULTIPLICITY
operator|>
literal|1
if|if
condition|(
name|best_cost
operator|>
name|cost
condition|)
block|{
for|for
control|(
name|i
operator|=
name|function_units
index|[
name|unit
index|]
operator|.
name|multiplicity
operator|-
literal|1
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|instance
operator|+=
name|FUNCTION_UNITS_SIZE
expr_stmt|;
name|this_cost
operator|=
name|actual_hazard_this_instance
argument_list|(
name|unit
argument_list|,
name|instance
argument_list|,
name|insn
argument_list|,
name|clock
argument_list|,
name|cost
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_cost
operator|<
name|best_cost
condition|)
block|{
name|best_cost
operator|=
name|this_cost
expr_stmt|;
if|if
condition|(
name|this_cost
operator|<=
name|cost
condition|)
break|break;
block|}
block|}
block|}
endif|#
directive|endif
name|cost
operator|=
name|MAX
argument_list|(
name|cost
argument_list|,
name|best_cost
argument_list|)
expr_stmt|;
block|}
else|else
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|unit
operator|=
operator|~
name|unit
init|;
name|unit
condition|;
name|i
operator|++
operator|,
name|unit
operator|>>=
literal|1
control|)
if|if
condition|(
operator|(
name|unit
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
name|cost
operator|=
name|actual_hazard
argument_list|(
name|i
argument_list|,
name|insn
argument_list|,
name|clock
argument_list|,
name|cost
argument_list|)
expr_stmt|;
return|return
name|cost
return|;
block|}
end_function

begin_comment
comment|/* Return the potential hazard cost of executing an instruction on the    units encoded by UNIT if the previous potential hazard cost was COST.    An insn with a large blockage time is chosen in preference to one    with a smaller time; an insn that uses a unit that is more likely    to be used is chosen in preference to one with a unit that is less    used.  We are trying to minimize a subsequent actual hazard.  */
end_comment

begin_function
name|HAIFA_INLINE
specifier|static
name|int
name|potential_hazard
parameter_list|(
name|unit
parameter_list|,
name|insn
parameter_list|,
name|cost
parameter_list|)
name|int
name|unit
decl_stmt|,
name|cost
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|ncost
decl_stmt|;
name|unsigned
name|int
name|minb
decl_stmt|,
name|maxb
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
literal|0
condition|)
block|{
name|minb
operator|=
name|maxb
operator|=
name|function_units
index|[
name|unit
index|]
operator|.
name|max_blockage
expr_stmt|;
if|if
condition|(
name|maxb
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|function_units
index|[
name|unit
index|]
operator|.
name|blockage_range_function
condition|)
block|{
name|maxb
operator|=
name|minb
operator|=
name|blockage_range
argument_list|(
name|unit
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|maxb
operator|=
name|MAX_BLOCKAGE_COST
argument_list|(
name|maxb
argument_list|)
expr_stmt|;
name|minb
operator|=
name|MIN_BLOCKAGE_COST
argument_list|(
name|minb
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|maxb
operator|>
literal|1
condition|)
block|{
comment|/* Make the number of instructions left dominate.  Make the 	         minimum delay dominate the maximum delay.  If all these 	         are the same, use the unit number to add an arbitrary 	         ordering.  Other terms can be added.  */
name|ncost
operator|=
name|minb
operator|*
literal|0x40
operator|+
name|maxb
expr_stmt|;
name|ncost
operator|*=
operator|(
name|unit_n_insns
index|[
name|unit
index|]
operator|-
literal|1
operator|)
operator|*
literal|0x1000
operator|+
name|unit
expr_stmt|;
if|if
condition|(
name|ncost
operator|>
name|cost
condition|)
name|cost
operator|=
name|ncost
expr_stmt|;
block|}
block|}
block|}
else|else
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|unit
operator|=
operator|~
name|unit
init|;
name|unit
condition|;
name|i
operator|++
operator|,
name|unit
operator|>>=
literal|1
control|)
if|if
condition|(
operator|(
name|unit
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
name|cost
operator|=
name|potential_hazard
argument_list|(
name|i
argument_list|,
name|insn
argument_list|,
name|cost
argument_list|)
expr_stmt|;
return|return
name|cost
return|;
block|}
end_function

begin_comment
comment|/* Compute cost of executing INSN given the dependence LINK on the insn USED.    This is the number of cycles between instruction issue and    instruction results.  */
end_comment

begin_function
name|HAIFA_INLINE
specifier|static
name|int
name|insn_cost
parameter_list|(
name|insn
parameter_list|,
name|link
parameter_list|,
name|used
parameter_list|)
name|rtx
name|insn
decl_stmt|,
name|link
decl_stmt|,
name|used
decl_stmt|;
block|{
specifier|register
name|int
name|cost
init|=
name|INSN_COST
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|cost
operator|==
literal|0
condition|)
block|{
name|recog_memoized
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* A USE insn, or something else we don't need to understand.          We can't pass these directly to result_ready_cost because it will          trigger a fatal error for unrecognizable insns.  */
if|if
condition|(
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|<
literal|0
condition|)
block|{
name|INSN_COST
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
block|{
name|cost
operator|=
name|result_ready_cost
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|cost
operator|<
literal|1
condition|)
name|cost
operator|=
literal|1
expr_stmt|;
name|INSN_COST
argument_list|(
name|insn
argument_list|)
operator|=
name|cost
expr_stmt|;
block|}
block|}
comment|/* in this case estimate cost without caring how insn is used.  */
if|if
condition|(
name|link
operator|==
literal|0
operator|&&
name|used
operator|==
literal|0
condition|)
return|return
name|cost
return|;
comment|/* A USE insn should never require the value used to be computed.  This      allows the computation of a function's result and parameter values to      overlap the return and call.  */
name|recog_memoized
argument_list|(
name|used
argument_list|)
expr_stmt|;
if|if
condition|(
name|INSN_CODE
argument_list|(
name|used
argument_list|)
operator|<
literal|0
condition|)
name|LINK_COST_FREE
argument_list|(
name|link
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* If some dependencies vary the cost, compute the adjustment.  Most      commonly, the adjustment is complete: either the cost is ignored      (in the case of an output- or anti-dependence), or the cost is      unchanged.  These values are cached in the link as LINK_COST_FREE      and LINK_COST_ZERO.  */
if|if
condition|(
name|LINK_COST_FREE
argument_list|(
name|link
argument_list|)
condition|)
name|cost
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|ADJUST_COST
elseif|else
if|if
condition|(
operator|!
name|LINK_COST_ZERO
argument_list|(
name|link
argument_list|)
condition|)
block|{
name|int
name|ncost
init|=
name|cost
decl_stmt|;
name|ADJUST_COST
argument_list|(
name|used
argument_list|,
name|link
argument_list|,
name|insn
argument_list|,
name|ncost
argument_list|)
expr_stmt|;
if|if
condition|(
name|ncost
operator|<=
literal|1
condition|)
name|LINK_COST_FREE
argument_list|(
name|link
argument_list|)
operator|=
name|ncost
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|cost
operator|==
name|ncost
condition|)
name|LINK_COST_ZERO
argument_list|(
name|link
argument_list|)
operator|=
literal|1
expr_stmt|;
name|cost
operator|=
name|ncost
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|cost
return|;
block|}
end_function

begin_comment
comment|/* Compute the priority number for INSN.  */
end_comment

begin_function
specifier|static
name|int
name|priority
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|int
name|this_priority
decl_stmt|;
name|rtx
name|link
decl_stmt|;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
literal|'i'
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|this_priority
operator|=
name|INSN_PRIORITY
argument_list|(
name|insn
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|INSN_DEPEND
argument_list|(
name|insn
argument_list|)
operator|==
literal|0
condition|)
name|this_priority
operator|=
name|insn_cost
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
for|for
control|(
name|link
operator|=
name|INSN_DEPEND
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|rtx
name|next
decl_stmt|;
name|int
name|next_priority
decl_stmt|;
if|if
condition|(
name|RTX_INTEGRATED_P
argument_list|(
name|link
argument_list|)
condition|)
continue|continue;
name|next
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* critical path is meaningful in block boundaries only */
if|if
condition|(
name|INSN_BLOCK
argument_list|(
name|next
argument_list|)
operator|!=
name|INSN_BLOCK
argument_list|(
name|insn
argument_list|)
condition|)
continue|continue;
name|next_priority
operator|=
name|insn_cost
argument_list|(
name|insn
argument_list|,
name|link
argument_list|,
name|next
argument_list|)
operator|+
name|priority
argument_list|(
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_priority
operator|>
name|this_priority
condition|)
name|this_priority
operator|=
name|next_priority
expr_stmt|;
block|}
name|INSN_PRIORITY
argument_list|(
name|insn
argument_list|)
operator|=
name|this_priority
expr_stmt|;
block|}
return|return
name|this_priority
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Remove all INSN_LISTs and EXPR_LISTs from the pending lists and add    them to the unused_*_list variables, so that they can be reused.  */
end_comment

begin_function
specifier|static
name|void
name|free_pending_lists
parameter_list|()
block|{
if|if
condition|(
name|current_nr_blocks
operator|<=
literal|1
condition|)
block|{
name|free_list
argument_list|(
operator|&
name|pending_read_insns
argument_list|,
operator|&
name|unused_insn_list
argument_list|)
expr_stmt|;
name|free_list
argument_list|(
operator|&
name|pending_write_insns
argument_list|,
operator|&
name|unused_insn_list
argument_list|)
expr_stmt|;
name|free_list
argument_list|(
operator|&
name|pending_read_mems
argument_list|,
operator|&
name|unused_expr_list
argument_list|)
expr_stmt|;
name|free_list
argument_list|(
operator|&
name|pending_write_mems
argument_list|,
operator|&
name|unused_expr_list
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* interblock scheduling */
name|int
name|bb
decl_stmt|;
for|for
control|(
name|bb
operator|=
literal|0
init|;
name|bb
operator|<
name|current_nr_blocks
condition|;
name|bb
operator|++
control|)
block|{
name|free_list
argument_list|(
operator|&
name|bb_pending_read_insns
index|[
name|bb
index|]
argument_list|,
operator|&
name|unused_insn_list
argument_list|)
expr_stmt|;
name|free_list
argument_list|(
operator|&
name|bb_pending_write_insns
index|[
name|bb
index|]
argument_list|,
operator|&
name|unused_insn_list
argument_list|)
expr_stmt|;
name|free_list
argument_list|(
operator|&
name|bb_pending_read_mems
index|[
name|bb
index|]
argument_list|,
operator|&
name|unused_expr_list
argument_list|)
expr_stmt|;
name|free_list
argument_list|(
operator|&
name|bb_pending_write_mems
index|[
name|bb
index|]
argument_list|,
operator|&
name|unused_expr_list
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Add an INSN and MEM reference pair to a pending INSN_LIST and MEM_LIST.    The MEM is a memory reference contained within INSN, which we are saving    so that we can do memory aliasing on it.  */
end_comment

begin_function
specifier|static
name|void
name|add_insn_mem_dependence
parameter_list|(
name|insn_list
parameter_list|,
name|mem_list
parameter_list|,
name|insn
parameter_list|,
name|mem
parameter_list|)
name|rtx
modifier|*
name|insn_list
decl_stmt|,
decl|*
name|mem_list
decl_stmt|,
name|insn
decl_stmt|,
name|mem
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|rtx
name|link
decl_stmt|;
name|link
operator|=
name|alloc_INSN_LIST
argument_list|(
name|insn
argument_list|,
operator|*
name|insn_list
argument_list|)
expr_stmt|;
operator|*
name|insn_list
operator|=
name|link
expr_stmt|;
name|link
operator|=
name|alloc_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|mem
argument_list|,
operator|*
name|mem_list
argument_list|)
expr_stmt|;
operator|*
name|mem_list
operator|=
name|link
expr_stmt|;
name|pending_lists_length
operator|++
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Make a dependency between every memory reference on the pending lists    and INSN, thus flushing the pending lists.  If ONLY_WRITE, don't flush    the read list.  */
end_comment

begin_function
specifier|static
name|void
name|flush_pending_lists
parameter_list|(
name|insn
parameter_list|,
name|only_write
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|int
name|only_write
decl_stmt|;
block|{
name|rtx
name|u
decl_stmt|;
name|rtx
name|link
decl_stmt|;
while|while
condition|(
name|pending_read_insns
operator|&&
operator|!
name|only_write
condition|)
block|{
name|add_dependence
argument_list|(
name|insn
argument_list|,
name|XEXP
argument_list|(
name|pending_read_insns
argument_list|,
literal|0
argument_list|)
argument_list|,
name|REG_DEP_ANTI
argument_list|)
expr_stmt|;
name|link
operator|=
name|pending_read_insns
expr_stmt|;
name|pending_read_insns
operator|=
name|XEXP
argument_list|(
name|pending_read_insns
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
operator|=
name|unused_insn_list
expr_stmt|;
name|unused_insn_list
operator|=
name|link
expr_stmt|;
name|link
operator|=
name|pending_read_mems
expr_stmt|;
name|pending_read_mems
operator|=
name|XEXP
argument_list|(
name|pending_read_mems
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
operator|=
name|unused_expr_list
expr_stmt|;
name|unused_expr_list
operator|=
name|link
expr_stmt|;
block|}
while|while
condition|(
name|pending_write_insns
condition|)
block|{
name|add_dependence
argument_list|(
name|insn
argument_list|,
name|XEXP
argument_list|(
name|pending_write_insns
argument_list|,
literal|0
argument_list|)
argument_list|,
name|REG_DEP_ANTI
argument_list|)
expr_stmt|;
name|link
operator|=
name|pending_write_insns
expr_stmt|;
name|pending_write_insns
operator|=
name|XEXP
argument_list|(
name|pending_write_insns
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
operator|=
name|unused_insn_list
expr_stmt|;
name|unused_insn_list
operator|=
name|link
expr_stmt|;
name|link
operator|=
name|pending_write_mems
expr_stmt|;
name|pending_write_mems
operator|=
name|XEXP
argument_list|(
name|pending_write_mems
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
operator|=
name|unused_expr_list
expr_stmt|;
name|unused_expr_list
operator|=
name|link
expr_stmt|;
block|}
name|pending_lists_length
operator|=
literal|0
expr_stmt|;
comment|/* last_pending_memory_flush is now a list of insns */
for|for
control|(
name|u
operator|=
name|last_pending_memory_flush
init|;
name|u
condition|;
name|u
operator|=
name|XEXP
argument_list|(
name|u
argument_list|,
literal|1
argument_list|)
control|)
name|add_dependence
argument_list|(
name|insn
argument_list|,
name|XEXP
argument_list|(
name|u
argument_list|,
literal|0
argument_list|)
argument_list|,
name|REG_DEP_ANTI
argument_list|)
expr_stmt|;
name|free_list
argument_list|(
operator|&
name|last_pending_memory_flush
argument_list|,
operator|&
name|unused_insn_list
argument_list|)
expr_stmt|;
name|last_pending_memory_flush
operator|=
name|alloc_INSN_LIST
argument_list|(
name|insn
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Analyze a single SET or CLOBBER rtx, X, creating all dependencies generated    by the write to the destination of X, and reads of everything mentioned.  */
end_comment

begin_function
specifier|static
name|void
name|sched_analyze_1
parameter_list|(
name|x
parameter_list|,
name|insn
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
specifier|register
name|int
name|regno
decl_stmt|;
specifier|register
name|rtx
name|dest
init|=
name|SET_DEST
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|dest
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|GET_MODE
argument_list|(
name|dest
argument_list|)
operator|==
name|BLKmode
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|sched_analyze_1
argument_list|(
name|XVECEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SET
condition|)
name|sched_analyze_2
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|STRICT_LOW_PART
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SIGN_EXTRACT
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SIGN_EXTRACT
condition|)
block|{
comment|/* The second and third arguments are values read by this insn.  */
name|sched_analyze_2
argument_list|(
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|1
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|sched_analyze_2
argument_list|(
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|2
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
name|dest
operator|=
name|SUBREG_REG
argument_list|(
name|dest
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|regno
operator|=
name|REGNO
argument_list|(
name|dest
argument_list|)
expr_stmt|;
comment|/* A hard reg in a wide mode may really be multiple registers.          If so, mark all of them just like the first.  */
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|i
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|i
operator|>=
literal|0
condition|)
block|{
name|rtx
name|u
decl_stmt|;
for|for
control|(
name|u
operator|=
name|reg_last_uses
index|[
name|regno
operator|+
name|i
index|]
init|;
name|u
condition|;
name|u
operator|=
name|XEXP
argument_list|(
name|u
argument_list|,
literal|1
argument_list|)
control|)
name|add_dependence
argument_list|(
name|insn
argument_list|,
name|XEXP
argument_list|(
name|u
argument_list|,
literal|0
argument_list|)
argument_list|,
name|REG_DEP_ANTI
argument_list|)
expr_stmt|;
for|for
control|(
name|u
operator|=
name|reg_last_sets
index|[
name|regno
operator|+
name|i
index|]
init|;
name|u
condition|;
name|u
operator|=
name|XEXP
argument_list|(
name|u
argument_list|,
literal|1
argument_list|)
control|)
name|add_dependence
argument_list|(
name|insn
argument_list|,
name|XEXP
argument_list|(
name|u
argument_list|,
literal|0
argument_list|)
argument_list|,
name|REG_DEP_OUTPUT
argument_list|)
expr_stmt|;
comment|/* Clobbers need not be ordered with respect to one another, 		 but sets must be ordered with respect to a pending clobber. */
if|if
condition|(
name|code
operator|==
name|SET
condition|)
block|{
name|reg_last_uses
index|[
name|regno
operator|+
name|i
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|u
operator|=
name|reg_last_clobbers
index|[
name|regno
operator|+
name|i
index|]
init|;
name|u
condition|;
name|u
operator|=
name|XEXP
argument_list|(
name|u
argument_list|,
literal|1
argument_list|)
control|)
name|add_dependence
argument_list|(
name|insn
argument_list|,
name|XEXP
argument_list|(
name|u
argument_list|,
literal|0
argument_list|)
argument_list|,
name|REG_DEP_OUTPUT
argument_list|)
expr_stmt|;
name|SET_REGNO_REG_SET
argument_list|(
name|reg_pending_sets
argument_list|,
name|regno
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
else|else
name|SET_REGNO_REG_SET
argument_list|(
name|reg_pending_clobbers
argument_list|,
name|regno
operator|+
name|i
argument_list|)
expr_stmt|;
comment|/* Function calls clobber all call_used regs.  */
if|if
condition|(
name|global_regs
index|[
name|regno
operator|+
name|i
index|]
operator|||
operator|(
name|code
operator|==
name|SET
operator|&&
name|call_used_regs
index|[
name|regno
operator|+
name|i
index|]
operator|)
condition|)
for|for
control|(
name|u
operator|=
name|last_function_call
init|;
name|u
condition|;
name|u
operator|=
name|XEXP
argument_list|(
name|u
argument_list|,
literal|1
argument_list|)
control|)
name|add_dependence
argument_list|(
name|insn
argument_list|,
name|XEXP
argument_list|(
name|u
argument_list|,
literal|0
argument_list|)
argument_list|,
name|REG_DEP_ANTI
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|rtx
name|u
decl_stmt|;
for|for
control|(
name|u
operator|=
name|reg_last_uses
index|[
name|regno
index|]
init|;
name|u
condition|;
name|u
operator|=
name|XEXP
argument_list|(
name|u
argument_list|,
literal|1
argument_list|)
control|)
name|add_dependence
argument_list|(
name|insn
argument_list|,
name|XEXP
argument_list|(
name|u
argument_list|,
literal|0
argument_list|)
argument_list|,
name|REG_DEP_ANTI
argument_list|)
expr_stmt|;
for|for
control|(
name|u
operator|=
name|reg_last_sets
index|[
name|regno
index|]
init|;
name|u
condition|;
name|u
operator|=
name|XEXP
argument_list|(
name|u
argument_list|,
literal|1
argument_list|)
control|)
name|add_dependence
argument_list|(
name|insn
argument_list|,
name|XEXP
argument_list|(
name|u
argument_list|,
literal|0
argument_list|)
argument_list|,
name|REG_DEP_OUTPUT
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|SET
condition|)
block|{
name|reg_last_uses
index|[
name|regno
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|u
operator|=
name|reg_last_clobbers
index|[
name|regno
index|]
init|;
name|u
condition|;
name|u
operator|=
name|XEXP
argument_list|(
name|u
argument_list|,
literal|1
argument_list|)
control|)
name|add_dependence
argument_list|(
name|insn
argument_list|,
name|XEXP
argument_list|(
name|u
argument_list|,
literal|0
argument_list|)
argument_list|,
name|REG_DEP_OUTPUT
argument_list|)
expr_stmt|;
name|SET_REGNO_REG_SET
argument_list|(
name|reg_pending_sets
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
else|else
name|SET_REGNO_REG_SET
argument_list|(
name|reg_pending_clobbers
argument_list|,
name|regno
argument_list|)
expr_stmt|;
comment|/* Pseudos that are REG_EQUIV to something may be replaced 	     by that during reloading.  We need only add dependencies for 	     the address in the REG_EQUIV note.  */
if|if
condition|(
operator|!
name|reload_completed
operator|&&
name|reg_known_equiv_p
index|[
name|regno
index|]
operator|&&
name|GET_CODE
argument_list|(
name|reg_known_value
index|[
name|regno
index|]
argument_list|)
operator|==
name|MEM
condition|)
name|sched_analyze_2
argument_list|(
name|XEXP
argument_list|(
name|reg_known_value
index|[
name|regno
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* Don't let it cross a call after scheduling if it doesn't 	     already cross one.  */
if|if
condition|(
name|REG_N_CALLS_CROSSED
argument_list|(
name|regno
argument_list|)
operator|==
literal|0
condition|)
for|for
control|(
name|u
operator|=
name|last_function_call
init|;
name|u
condition|;
name|u
operator|=
name|XEXP
argument_list|(
name|u
argument_list|,
literal|1
argument_list|)
control|)
name|add_dependence
argument_list|(
name|insn
argument_list|,
name|XEXP
argument_list|(
name|u
argument_list|,
literal|0
argument_list|)
argument_list|,
name|REG_DEP_ANTI
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|MEM
condition|)
block|{
comment|/* Writing memory.  */
if|if
condition|(
name|pending_lists_length
operator|>
literal|32
condition|)
block|{
comment|/* Flush all pending reads and writes to prevent the pending lists 	     from getting any larger.  Insn scheduling runs too slowly when 	     these lists get long.  The number 32 was chosen because it 	     seems like a reasonable number.  When compiling GCC with itself, 	     this flush occurs 8 times for sparc, and 10 times for m88k using 	     the number 32.  */
name|flush_pending_lists
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|u
decl_stmt|;
name|rtx
name|pending
decl_stmt|,
name|pending_mem
decl_stmt|;
name|pending
operator|=
name|pending_read_insns
expr_stmt|;
name|pending_mem
operator|=
name|pending_read_mems
expr_stmt|;
while|while
condition|(
name|pending
condition|)
block|{
comment|/* If a dependency already exists, don't create a new one.  */
if|if
condition|(
operator|!
name|find_insn_list
argument_list|(
name|XEXP
argument_list|(
name|pending
argument_list|,
literal|0
argument_list|)
argument_list|,
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
if|if
condition|(
name|anti_dependence
argument_list|(
name|XEXP
argument_list|(
name|pending_mem
argument_list|,
literal|0
argument_list|)
argument_list|,
name|dest
argument_list|)
condition|)
name|add_dependence
argument_list|(
name|insn
argument_list|,
name|XEXP
argument_list|(
name|pending
argument_list|,
literal|0
argument_list|)
argument_list|,
name|REG_DEP_ANTI
argument_list|)
expr_stmt|;
name|pending
operator|=
name|XEXP
argument_list|(
name|pending
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pending_mem
operator|=
name|XEXP
argument_list|(
name|pending_mem
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|pending
operator|=
name|pending_write_insns
expr_stmt|;
name|pending_mem
operator|=
name|pending_write_mems
expr_stmt|;
while|while
condition|(
name|pending
condition|)
block|{
comment|/* If a dependency already exists, don't create a new one.  */
if|if
condition|(
operator|!
name|find_insn_list
argument_list|(
name|XEXP
argument_list|(
name|pending
argument_list|,
literal|0
argument_list|)
argument_list|,
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
if|if
condition|(
name|output_dependence
argument_list|(
name|XEXP
argument_list|(
name|pending_mem
argument_list|,
literal|0
argument_list|)
argument_list|,
name|dest
argument_list|)
condition|)
name|add_dependence
argument_list|(
name|insn
argument_list|,
name|XEXP
argument_list|(
name|pending
argument_list|,
literal|0
argument_list|)
argument_list|,
name|REG_DEP_OUTPUT
argument_list|)
expr_stmt|;
name|pending
operator|=
name|XEXP
argument_list|(
name|pending
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pending_mem
operator|=
name|XEXP
argument_list|(
name|pending_mem
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|u
operator|=
name|last_pending_memory_flush
init|;
name|u
condition|;
name|u
operator|=
name|XEXP
argument_list|(
name|u
argument_list|,
literal|1
argument_list|)
control|)
name|add_dependence
argument_list|(
name|insn
argument_list|,
name|XEXP
argument_list|(
name|u
argument_list|,
literal|0
argument_list|)
argument_list|,
name|REG_DEP_ANTI
argument_list|)
expr_stmt|;
name|add_insn_mem_dependence
argument_list|(
operator|&
name|pending_write_insns
argument_list|,
operator|&
name|pending_write_mems
argument_list|,
name|insn
argument_list|,
name|dest
argument_list|)
expr_stmt|;
block|}
name|sched_analyze_2
argument_list|(
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
comment|/* Analyze reads.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SET
condition|)
name|sched_analyze_2
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Analyze the uses of memory and registers in rtx X in INSN.  */
end_comment

begin_function
specifier|static
name|void
name|sched_analyze_2
parameter_list|(
name|x
parameter_list|,
name|insn
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
specifier|register
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|CONST
case|:
case|case
name|LABEL_REF
case|:
comment|/* Ignore constants.  Note that we must handle CONST_DOUBLE here          because it may have a cc0_rtx in its CONST_DOUBLE_CHAIN field, but          this does not mean that this insn is using cc0.  */
return|return;
ifdef|#
directive|ifdef
name|HAVE_cc0
case|case
name|CC0
case|:
block|{
name|rtx
name|link
decl_stmt|,
name|prev
decl_stmt|;
comment|/* User of CC0 depends on immediately preceding insn.  */
name|SCHED_GROUP_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* There may be a note before this insn now, but all notes will 	   be removed before we actually try to schedule the insns, so 	   it won't cause a problem later.  We must avoid it here though.  */
name|prev
operator|=
name|prev_nonnote_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Make a copy of all dependencies on the immediately previous insn, 	   and add to this insn.  This is so that all the dependencies will 	   apply to the group.  Remove an explicit dependence on this insn 	   as SCHED_GROUP_P now represents it.  */
if|if
condition|(
name|find_insn_list
argument_list|(
name|prev
argument_list|,
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
name|remove_dependence
argument_list|(
name|insn
argument_list|,
name|prev
argument_list|)
expr_stmt|;
for|for
control|(
name|link
operator|=
name|LOG_LINKS
argument_list|(
name|prev
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
name|add_dependence
argument_list|(
name|insn
argument_list|,
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|,
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
case|case
name|REG
case|:
block|{
name|rtx
name|u
decl_stmt|;
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|int
name|i
decl_stmt|;
name|i
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|i
operator|>=
literal|0
condition|)
block|{
name|reg_last_uses
index|[
name|regno
operator|+
name|i
index|]
operator|=
name|alloc_INSN_LIST
argument_list|(
name|insn
argument_list|,
name|reg_last_uses
index|[
name|regno
operator|+
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|u
operator|=
name|reg_last_sets
index|[
name|regno
operator|+
name|i
index|]
init|;
name|u
condition|;
name|u
operator|=
name|XEXP
argument_list|(
name|u
argument_list|,
literal|1
argument_list|)
control|)
name|add_dependence
argument_list|(
name|insn
argument_list|,
name|XEXP
argument_list|(
name|u
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* ??? This should never happen.  */
for|for
control|(
name|u
operator|=
name|reg_last_clobbers
index|[
name|regno
operator|+
name|i
index|]
init|;
name|u
condition|;
name|u
operator|=
name|XEXP
argument_list|(
name|u
argument_list|,
literal|1
argument_list|)
control|)
name|add_dependence
argument_list|(
name|insn
argument_list|,
name|XEXP
argument_list|(
name|u
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|call_used_regs
index|[
name|regno
operator|+
name|i
index|]
operator|||
name|global_regs
index|[
name|regno
operator|+
name|i
index|]
operator|)
condition|)
comment|/* Function calls clobber all call_used regs.  */
for|for
control|(
name|u
operator|=
name|last_function_call
init|;
name|u
condition|;
name|u
operator|=
name|XEXP
argument_list|(
name|u
argument_list|,
literal|1
argument_list|)
control|)
name|add_dependence
argument_list|(
name|insn
argument_list|,
name|XEXP
argument_list|(
name|u
argument_list|,
literal|0
argument_list|)
argument_list|,
name|REG_DEP_ANTI
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|reg_last_uses
index|[
name|regno
index|]
operator|=
name|alloc_INSN_LIST
argument_list|(
name|insn
argument_list|,
name|reg_last_uses
index|[
name|regno
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|u
operator|=
name|reg_last_sets
index|[
name|regno
index|]
init|;
name|u
condition|;
name|u
operator|=
name|XEXP
argument_list|(
name|u
argument_list|,
literal|1
argument_list|)
control|)
name|add_dependence
argument_list|(
name|insn
argument_list|,
name|XEXP
argument_list|(
name|u
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* ??? This should never happen.  */
for|for
control|(
name|u
operator|=
name|reg_last_clobbers
index|[
name|regno
index|]
init|;
name|u
condition|;
name|u
operator|=
name|XEXP
argument_list|(
name|u
argument_list|,
literal|1
argument_list|)
control|)
name|add_dependence
argument_list|(
name|insn
argument_list|,
name|XEXP
argument_list|(
name|u
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Pseudos that are REG_EQUIV to something may be replaced 	       by that during reloading.  We need only add dependencies for 	       the address in the REG_EQUIV note.  */
if|if
condition|(
operator|!
name|reload_completed
operator|&&
name|reg_known_equiv_p
index|[
name|regno
index|]
operator|&&
name|GET_CODE
argument_list|(
name|reg_known_value
index|[
name|regno
index|]
argument_list|)
operator|==
name|MEM
condition|)
name|sched_analyze_2
argument_list|(
name|XEXP
argument_list|(
name|reg_known_value
index|[
name|regno
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* If the register does not already cross any calls, then add this 	       insn to the sched_before_next_call list so that it will still 	       not cross calls after scheduling.  */
if|if
condition|(
name|REG_N_CALLS_CROSSED
argument_list|(
name|regno
argument_list|)
operator|==
literal|0
condition|)
name|add_dependence
argument_list|(
name|sched_before_next_call
argument_list|,
name|insn
argument_list|,
name|REG_DEP_ANTI
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
case|case
name|MEM
case|:
block|{
comment|/* Reading memory.  */
name|rtx
name|u
decl_stmt|;
name|rtx
name|pending
decl_stmt|,
name|pending_mem
decl_stmt|;
name|pending
operator|=
name|pending_read_insns
expr_stmt|;
name|pending_mem
operator|=
name|pending_read_mems
expr_stmt|;
while|while
condition|(
name|pending
condition|)
block|{
comment|/* If a dependency already exists, don't create a new one.  */
if|if
condition|(
operator|!
name|find_insn_list
argument_list|(
name|XEXP
argument_list|(
name|pending
argument_list|,
literal|0
argument_list|)
argument_list|,
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
if|if
condition|(
name|read_dependence
argument_list|(
name|XEXP
argument_list|(
name|pending_mem
argument_list|,
literal|0
argument_list|)
argument_list|,
name|x
argument_list|)
condition|)
name|add_dependence
argument_list|(
name|insn
argument_list|,
name|XEXP
argument_list|(
name|pending
argument_list|,
literal|0
argument_list|)
argument_list|,
name|REG_DEP_ANTI
argument_list|)
expr_stmt|;
name|pending
operator|=
name|XEXP
argument_list|(
name|pending
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pending_mem
operator|=
name|XEXP
argument_list|(
name|pending_mem
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|pending
operator|=
name|pending_write_insns
expr_stmt|;
name|pending_mem
operator|=
name|pending_write_mems
expr_stmt|;
while|while
condition|(
name|pending
condition|)
block|{
comment|/* If a dependency already exists, don't create a new one.  */
if|if
condition|(
operator|!
name|find_insn_list
argument_list|(
name|XEXP
argument_list|(
name|pending
argument_list|,
literal|0
argument_list|)
argument_list|,
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
if|if
condition|(
name|true_dependence
argument_list|(
name|XEXP
argument_list|(
name|pending_mem
argument_list|,
literal|0
argument_list|)
argument_list|,
name|VOIDmode
argument_list|,
name|x
argument_list|,
name|rtx_varies_p
argument_list|)
condition|)
name|add_dependence
argument_list|(
name|insn
argument_list|,
name|XEXP
argument_list|(
name|pending
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pending
operator|=
name|XEXP
argument_list|(
name|pending
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pending_mem
operator|=
name|XEXP
argument_list|(
name|pending_mem
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|u
operator|=
name|last_pending_memory_flush
init|;
name|u
condition|;
name|u
operator|=
name|XEXP
argument_list|(
name|u
argument_list|,
literal|1
argument_list|)
control|)
name|add_dependence
argument_list|(
name|insn
argument_list|,
name|XEXP
argument_list|(
name|u
argument_list|,
literal|0
argument_list|)
argument_list|,
name|REG_DEP_ANTI
argument_list|)
expr_stmt|;
comment|/* Always add these dependencies to pending_reads, since 	   this insn may be followed by a write.  */
name|add_insn_mem_dependence
argument_list|(
operator|&
name|pending_read_insns
argument_list|,
operator|&
name|pending_read_mems
argument_list|,
name|insn
argument_list|,
name|x
argument_list|)
expr_stmt|;
comment|/* Take advantage of tail recursion here.  */
name|sched_analyze_2
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Force pending stores to memory in case a trap handler needs them.  */
case|case
name|TRAP_IF
case|:
name|flush_pending_lists
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|ASM_OPERANDS
case|:
case|case
name|ASM_INPUT
case|:
case|case
name|UNSPEC_VOLATILE
case|:
block|{
name|rtx
name|u
decl_stmt|;
comment|/* Traditional and volatile asm instructions must be considered to use 	   and clobber all hard registers, all pseudo-registers and all of 	   memory.  So must TRAP_IF and UNSPEC_VOLATILE operations.  	   Consider for instance a volatile asm that changes the fpu rounding 	   mode.  An insn should not be moved across this even if it only uses 	   pseudo-regs because it might give an incorrectly rounded result.  */
if|if
condition|(
name|code
operator|!=
name|ASM_OPERANDS
operator|||
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|int
name|max_reg
init|=
name|max_reg_num
argument_list|()
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_reg
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|u
operator|=
name|reg_last_uses
index|[
name|i
index|]
init|;
name|u
condition|;
name|u
operator|=
name|XEXP
argument_list|(
name|u
argument_list|,
literal|1
argument_list|)
control|)
name|add_dependence
argument_list|(
name|insn
argument_list|,
name|XEXP
argument_list|(
name|u
argument_list|,
literal|0
argument_list|)
argument_list|,
name|REG_DEP_ANTI
argument_list|)
expr_stmt|;
name|reg_last_uses
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|u
operator|=
name|reg_last_sets
index|[
name|i
index|]
init|;
name|u
condition|;
name|u
operator|=
name|XEXP
argument_list|(
name|u
argument_list|,
literal|1
argument_list|)
control|)
name|add_dependence
argument_list|(
name|insn
argument_list|,
name|XEXP
argument_list|(
name|u
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|u
operator|=
name|reg_last_clobbers
index|[
name|i
index|]
init|;
name|u
condition|;
name|u
operator|=
name|XEXP
argument_list|(
name|u
argument_list|,
literal|1
argument_list|)
control|)
name|add_dependence
argument_list|(
name|insn
argument_list|,
name|XEXP
argument_list|(
name|u
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|reg_pending_sets_all
operator|=
literal|1
expr_stmt|;
name|flush_pending_lists
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* For all ASM_OPERANDS, we must traverse the vector of input operands. 	   We can not just fall through here since then we would be confused 	   by the ASM_INPUT rtx inside ASM_OPERANDS, which do not indicate 	   traditional asms unlike their normal usage.  */
if|if
condition|(
name|code
operator|==
name|ASM_OPERANDS
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ASM_OPERANDS_INPUT_LENGTH
argument_list|(
name|x
argument_list|)
condition|;
name|j
operator|++
control|)
name|sched_analyze_2
argument_list|(
name|ASM_OPERANDS_INPUT
argument_list|(
name|x
argument_list|,
name|j
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
block|}
case|case
name|PRE_DEC
case|:
case|case
name|POST_DEC
case|:
case|case
name|PRE_INC
case|:
case|case
name|POST_INC
case|:
comment|/* These both read and modify the result.  We must handle them as writes          to get proper dependencies for following instructions.  We must handle          them as reads to get proper dependencies from this to previous          instructions.  Thus we need to pass them to both sched_analyze_1          and sched_analyze_2.  We must call sched_analyze_2 first in order          to get the proper antecedent for the read.  */
name|sched_analyze_2
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|sched_analyze_1
argument_list|(
name|x
argument_list|,
name|insn
argument_list|)
expr_stmt|;
return|return;
default|default:
break|break;
block|}
comment|/* Other cases: walk the insn.  */
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|sched_analyze_2
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|sched_analyze_2
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Analyze an INSN with pattern X to find all dependencies.  */
end_comment

begin_function
specifier|static
name|void
name|sched_analyze_insn
parameter_list|(
name|x
parameter_list|,
name|insn
parameter_list|,
name|loop_notes
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|insn
decl_stmt|;
name|rtx
name|loop_notes
decl_stmt|;
block|{
specifier|register
name|RTX_CODE
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|rtx
name|link
decl_stmt|;
name|int
name|maxreg
init|=
name|max_reg_num
argument_list|()
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|SET
operator|||
name|code
operator|==
name|CLOBBER
condition|)
name|sched_analyze_1
argument_list|(
name|x
argument_list|,
name|insn
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|PARALLEL
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|code
operator|=
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|SET
operator|||
name|code
operator|==
name|CLOBBER
condition|)
name|sched_analyze_1
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
else|else
name|sched_analyze_2
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|sched_analyze_2
argument_list|(
name|x
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* Mark registers CLOBBERED or used by called function.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
for|for
control|(
name|link
operator|=
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CLOBBER
condition|)
name|sched_analyze_1
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
else|else
name|sched_analyze_2
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
comment|/* If there is a {LOOP,EHREGION}_{BEG,END} note in the middle of a basic      block, then we must be sure that no instructions are scheduled across it.      Otherwise, the reg_n_refs info (which depends on loop_depth) would      become incorrect.  */
if|if
condition|(
name|loop_notes
condition|)
block|{
name|int
name|max_reg
init|=
name|max_reg_num
argument_list|()
decl_stmt|;
name|int
name|schedule_barrier_found
init|=
literal|0
decl_stmt|;
name|rtx
name|link
decl_stmt|;
comment|/* Update loop_notes with any notes from this insn.  Also determine 	 if any of the notes on the list correspond to instruction scheduling 	 barriers (loop, eh& setjmp notes, but not range notes.  */
name|link
operator|=
name|loop_notes
expr_stmt|;
while|while
condition|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|NOTE_INSN_LOOP_BEG
operator|||
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|NOTE_INSN_LOOP_END
operator|||
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|NOTE_INSN_EH_REGION_BEG
operator|||
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|NOTE_INSN_EH_REGION_END
operator|||
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|NOTE_INSN_SETJMP
condition|)
name|schedule_barrier_found
operator|=
literal|1
expr_stmt|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|loop_notes
expr_stmt|;
comment|/* Add dependencies if a scheduling barrier was found.  */
if|if
condition|(
name|schedule_barrier_found
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_reg
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|u
decl_stmt|;
for|for
control|(
name|u
operator|=
name|reg_last_uses
index|[
name|i
index|]
init|;
name|u
condition|;
name|u
operator|=
name|XEXP
argument_list|(
name|u
argument_list|,
literal|1
argument_list|)
control|)
name|add_dependence
argument_list|(
name|insn
argument_list|,
name|XEXP
argument_list|(
name|u
argument_list|,
literal|0
argument_list|)
argument_list|,
name|REG_DEP_ANTI
argument_list|)
expr_stmt|;
name|reg_last_uses
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|u
operator|=
name|reg_last_sets
index|[
name|i
index|]
init|;
name|u
condition|;
name|u
operator|=
name|XEXP
argument_list|(
name|u
argument_list|,
literal|1
argument_list|)
control|)
name|add_dependence
argument_list|(
name|insn
argument_list|,
name|XEXP
argument_list|(
name|u
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|u
operator|=
name|reg_last_clobbers
index|[
name|i
index|]
init|;
name|u
condition|;
name|u
operator|=
name|XEXP
argument_list|(
name|u
argument_list|,
literal|1
argument_list|)
control|)
name|add_dependence
argument_list|(
name|insn
argument_list|,
name|XEXP
argument_list|(
name|u
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|reg_pending_sets_all
operator|=
literal|1
expr_stmt|;
name|flush_pending_lists
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Accumulate clobbers until the next set so that it will be output dependant      on all of them.  At the next set we can clear the clobber list, since      subsequent sets will be output dependant on it.  */
name|EXECUTE_IF_SET_IN_REG_SET
argument_list|(
argument|reg_pending_sets
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|{ 			       free_list (&reg_last_sets[i],&unused_insn_list); 			       free_list (&reg_last_clobbers[i],&unused_insn_list); 			       reg_last_sets[i] 				 = alloc_INSN_LIST (insn, NULL_RTX); 			     }
argument_list|)
empty_stmt|;
name|EXECUTE_IF_SET_IN_REG_SET
argument_list|(
argument|reg_pending_clobbers
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|{ 			       reg_last_clobbers[i] 				 = alloc_INSN_LIST (insn, reg_last_clobbers[i]); 			     }
argument_list|)
empty_stmt|;
name|CLEAR_REG_SET
argument_list|(
name|reg_pending_sets
argument_list|)
expr_stmt|;
name|CLEAR_REG_SET
argument_list|(
name|reg_pending_clobbers
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_pending_sets_all
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|maxreg
condition|;
name|i
operator|++
control|)
block|{
name|free_list
argument_list|(
operator|&
name|reg_last_sets
index|[
name|i
index|]
argument_list|,
operator|&
name|unused_insn_list
argument_list|)
expr_stmt|;
name|reg_last_sets
index|[
name|i
index|]
operator|=
name|alloc_INSN_LIST
argument_list|(
name|insn
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
block|}
name|reg_pending_sets_all
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Handle function calls and function returns created by the epilogue      threading code.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
block|{
name|rtx
name|dep_insn
decl_stmt|;
name|rtx
name|prev_dep_insn
decl_stmt|;
comment|/* When scheduling instructions, we make sure calls don't lose their          accompanying USE insns by depending them one on another in order.           Also, we must do the same thing for returns created by the epilogue          threading code.  Note this code works only in this special case,          because other passes make no guarantee that they will never emit          an instruction between a USE and a RETURN.  There is such a guarantee          for USE instructions immediately before a call.  */
name|prev_dep_insn
operator|=
name|insn
expr_stmt|;
name|dep_insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|dep_insn
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|dep_insn
argument_list|)
argument_list|)
operator|==
name|USE
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|dep_insn
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|SCHED_GROUP_P
argument_list|(
name|prev_dep_insn
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Make a copy of all dependencies on dep_insn, and add to insn. 	     This is so that all of the dependencies will apply to the 	     group.  */
for|for
control|(
name|link
operator|=
name|LOG_LINKS
argument_list|(
name|dep_insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
name|add_dependence
argument_list|(
name|insn
argument_list|,
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|,
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
argument_list|)
expr_stmt|;
name|prev_dep_insn
operator|=
name|dep_insn
expr_stmt|;
name|dep_insn
operator|=
name|PREV_INSN
argument_list|(
name|dep_insn
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Analyze every insn between HEAD and TAIL inclusive, creating LOG_LINKS    for every dependency.  */
end_comment

begin_function
specifier|static
name|void
name|sched_analyze
parameter_list|(
name|head
parameter_list|,
name|tail
parameter_list|)
name|rtx
name|head
decl_stmt|,
name|tail
decl_stmt|;
block|{
specifier|register
name|rtx
name|insn
decl_stmt|;
specifier|register
name|rtx
name|u
decl_stmt|;
name|rtx
name|loop_notes
init|=
literal|0
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|head
init|;
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
block|{
comment|/* Make each JUMP_INSN a scheduling barrier for memory references.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
name|last_pending_memory_flush
operator|=
name|alloc_INSN_LIST
argument_list|(
name|insn
argument_list|,
name|last_pending_memory_flush
argument_list|)
expr_stmt|;
name|sched_analyze_insn
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|insn
argument_list|,
name|loop_notes
argument_list|)
expr_stmt|;
name|loop_notes
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
name|rtx
name|x
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|CANT_MOVE
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Any instruction using a hard register which may get clobbered 	     by a call needs to be marked as dependent on this call. 	     This prevents a use of a hard return reg from being moved 	     past a void call (i.e. it does not explicitly set the hard 	     return reg).  */
comment|/* If this call is followed by a NOTE_INSN_SETJMP, then assume that 	     all registers, not just hard registers, may be clobbered by this 	     call.  */
comment|/* Insn, being a CALL_INSN, magically depends on 	     `last_function_call' already.  */
if|if
condition|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|NOTE_INSN_SETJMP
condition|)
block|{
name|int
name|max_reg
init|=
name|max_reg_num
argument_list|()
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_reg
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|u
operator|=
name|reg_last_uses
index|[
name|i
index|]
init|;
name|u
condition|;
name|u
operator|=
name|XEXP
argument_list|(
name|u
argument_list|,
literal|1
argument_list|)
control|)
name|add_dependence
argument_list|(
name|insn
argument_list|,
name|XEXP
argument_list|(
name|u
argument_list|,
literal|0
argument_list|)
argument_list|,
name|REG_DEP_ANTI
argument_list|)
expr_stmt|;
name|reg_last_uses
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|u
operator|=
name|reg_last_sets
index|[
name|i
index|]
init|;
name|u
condition|;
name|u
operator|=
name|XEXP
argument_list|(
name|u
argument_list|,
literal|1
argument_list|)
control|)
name|add_dependence
argument_list|(
name|insn
argument_list|,
name|XEXP
argument_list|(
name|u
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|u
operator|=
name|reg_last_clobbers
index|[
name|i
index|]
init|;
name|u
condition|;
name|u
operator|=
name|XEXP
argument_list|(
name|u
argument_list|,
literal|1
argument_list|)
control|)
name|add_dependence
argument_list|(
name|insn
argument_list|,
name|XEXP
argument_list|(
name|u
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|reg_pending_sets_all
operator|=
literal|1
expr_stmt|;
comment|/* Add a pair of fake REG_NOTE which we will later 		 convert back into a NOTE_INSN_SETJMP note.  See 		 reemit_notes for why we use a pair of NOTEs.  */
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|alloc_EXPR_LIST
argument_list|(
name|REG_DEAD
argument_list|,
name|GEN_INT
argument_list|(
literal|0
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|alloc_EXPR_LIST
argument_list|(
name|REG_DEAD
argument_list|,
name|GEN_INT
argument_list|(
name|NOTE_INSN_SETJMP
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|call_used_regs
index|[
name|i
index|]
operator|||
name|global_regs
index|[
name|i
index|]
condition|)
block|{
for|for
control|(
name|u
operator|=
name|reg_last_uses
index|[
name|i
index|]
init|;
name|u
condition|;
name|u
operator|=
name|XEXP
argument_list|(
name|u
argument_list|,
literal|1
argument_list|)
control|)
name|add_dependence
argument_list|(
name|insn
argument_list|,
name|XEXP
argument_list|(
name|u
argument_list|,
literal|0
argument_list|)
argument_list|,
name|REG_DEP_ANTI
argument_list|)
expr_stmt|;
for|for
control|(
name|u
operator|=
name|reg_last_sets
index|[
name|i
index|]
init|;
name|u
condition|;
name|u
operator|=
name|XEXP
argument_list|(
name|u
argument_list|,
literal|1
argument_list|)
control|)
name|add_dependence
argument_list|(
name|insn
argument_list|,
name|XEXP
argument_list|(
name|u
argument_list|,
literal|0
argument_list|)
argument_list|,
name|REG_DEP_ANTI
argument_list|)
expr_stmt|;
name|SET_REGNO_REG_SET
argument_list|(
name|reg_pending_clobbers
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* For each insn which shouldn't cross a call, add a dependence 	     between that insn and this call insn.  */
name|x
operator|=
name|LOG_LINKS
argument_list|(
name|sched_before_next_call
argument_list|)
expr_stmt|;
while|while
condition|(
name|x
condition|)
block|{
name|add_dependence
argument_list|(
name|insn
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|REG_DEP_ANTI
argument_list|)
expr_stmt|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|LOG_LINKS
argument_list|(
name|sched_before_next_call
argument_list|)
operator|=
literal|0
expr_stmt|;
name|sched_analyze_insn
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|insn
argument_list|,
name|loop_notes
argument_list|)
expr_stmt|;
name|loop_notes
operator|=
literal|0
expr_stmt|;
comment|/* In the absence of interprocedural alias analysis, we must flush 	     all pending reads and writes, and start new dependencies starting 	     from here.  But only flush writes for constant calls (which may 	     be passed a pointer to something we haven't written yet).  */
name|flush_pending_lists
argument_list|(
name|insn
argument_list|,
name|CONST_CALL_P
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Depend this function call (actually, the user of this 	     function call) on all hard register clobberage.  */
comment|/* last_function_call is now a list of insns */
name|free_list
argument_list|(
operator|&
name|last_function_call
argument_list|,
operator|&
name|unused_insn_list
argument_list|)
expr_stmt|;
name|last_function_call
operator|=
name|alloc_INSN_LIST
argument_list|(
name|insn
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
block|}
comment|/* See comments on reemit_notes as to why we do this.  */
comment|/* ??? Actually, the reemit_notes just say what is done, not why.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
operator|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_RANGE_START
operator|||
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_RANGE_END
operator|)
condition|)
block|{
name|loop_notes
operator|=
name|alloc_EXPR_LIST
argument_list|(
name|REG_DEAD
argument_list|,
name|NOTE_RANGE_INFO
argument_list|(
name|insn
argument_list|)
argument_list|,
name|loop_notes
argument_list|)
expr_stmt|;
name|loop_notes
operator|=
name|alloc_EXPR_LIST
argument_list|(
name|REG_DEAD
argument_list|,
name|GEN_INT
argument_list|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|,
name|loop_notes
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
operator|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_LOOP_BEG
operator|||
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_LOOP_END
operator|||
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_EH_REGION_BEG
operator|||
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_EH_REGION_END
operator|||
operator|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_SETJMP
operator|&&
name|GET_CODE
argument_list|(
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|CALL_INSN
operator|)
operator|)
condition|)
block|{
name|loop_notes
operator|=
name|alloc_EXPR_LIST
argument_list|(
name|REG_DEAD
argument_list|,
name|GEN_INT
argument_list|(
name|NOTE_BLOCK_NUMBER
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|,
name|loop_notes
argument_list|)
expr_stmt|;
name|loop_notes
operator|=
name|alloc_EXPR_LIST
argument_list|(
name|REG_DEAD
argument_list|,
name|GEN_INT
argument_list|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|,
name|loop_notes
argument_list|)
expr_stmt|;
name|CONST_CALL_P
argument_list|(
name|loop_notes
argument_list|)
operator|=
name|CONST_CALL_P
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|insn
operator|==
name|tail
condition|)
return|return;
block|}
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Called when we see a set of a register.  If death is true, then we are    scanning backwards.  Mark that register as unborn.  If nobody says    otherwise, that is how things will remain.  If death is false, then we    are scanning forwards.  Mark that register as being born.  */
end_comment

begin_function
specifier|static
name|void
name|sched_note_set
parameter_list|(
name|x
parameter_list|,
name|death
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|int
name|death
decl_stmt|;
block|{
specifier|register
name|int
name|regno
decl_stmt|;
specifier|register
name|rtx
name|reg
init|=
name|SET_DEST
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|int
name|subreg_p
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|reg
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|GET_MODE
argument_list|(
name|reg
argument_list|)
operator|==
name|BLKmode
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|reg
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|sched_note_set
argument_list|(
name|XVECEXP
argument_list|(
name|reg
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|death
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|STRICT_LOW_PART
operator|||
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SIGN_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|ZERO_EXTRACT
condition|)
block|{
comment|/* Must treat modification of just one hardware register of a multi-reg          value or just a byte field of a register exactly the same way that          mark_set_1 in flow.c does, i.e. anything except a paradoxical subreg          does not kill the entire register.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|!=
name|SUBREG
operator|||
name|REG_SIZE
argument_list|(
name|SUBREG_REG
argument_list|(
name|reg
argument_list|)
argument_list|)
operator|>
name|REG_SIZE
argument_list|(
name|reg
argument_list|)
condition|)
name|subreg_p
operator|=
literal|1
expr_stmt|;
name|reg
operator|=
name|SUBREG_REG
argument_list|(
name|reg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|!=
name|REG
condition|)
return|return;
comment|/* Global registers are always live, so the code below does not apply      to them.  */
name|regno
operator|=
name|REGNO
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|||
operator|!
name|global_regs
index|[
name|regno
index|]
condition|)
block|{
if|if
condition|(
name|death
condition|)
block|{
comment|/* If we only set part of the register, then this set does not 	     kill it.  */
if|if
condition|(
name|subreg_p
condition|)
return|return;
comment|/* Try killing this register.  */
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|int
name|j
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
operator|--
name|j
operator|>=
literal|0
condition|)
block|{
name|CLEAR_REGNO_REG_SET
argument_list|(
name|bb_live_regs
argument_list|,
name|regno
operator|+
name|j
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Recompute REG_BASIC_BLOCK as we update all the other 		 dataflow information.  */
if|if
condition|(
name|sched_reg_basic_block
index|[
name|regno
index|]
operator|==
name|REG_BLOCK_UNKNOWN
condition|)
name|sched_reg_basic_block
index|[
name|regno
index|]
operator|=
name|current_block_num
expr_stmt|;
elseif|else
if|if
condition|(
name|sched_reg_basic_block
index|[
name|regno
index|]
operator|!=
name|current_block_num
condition|)
name|sched_reg_basic_block
index|[
name|regno
index|]
operator|=
name|REG_BLOCK_GLOBAL
expr_stmt|;
name|CLEAR_REGNO_REG_SET
argument_list|(
name|bb_live_regs
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Make the register live again.  */
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|int
name|j
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
operator|--
name|j
operator|>=
literal|0
condition|)
block|{
name|SET_REGNO_REG_SET
argument_list|(
name|bb_live_regs
argument_list|,
name|regno
operator|+
name|j
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|SET_REGNO_REG_SET
argument_list|(
name|bb_live_regs
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Macros and functions for keeping the priority queue sorted, and    dealing with queueing and dequeueing of instructions.  */
end_comment

begin_define
define|#
directive|define
name|SCHED_SORT
parameter_list|(
name|READY
parameter_list|,
name|N_READY
parameter_list|)
define|\
value|do { if ((N_READY) == 2)				             \        swap_sort (READY, N_READY);			             \      else if ((N_READY)> 2)                                         \          qsort (READY, N_READY, sizeof (rtx), rank_for_schedule); }  \ while (0)
end_define

begin_comment
comment|/* Returns a positive value if x is preferred; returns a negative value if    y is preferred.  Should never return 0, since that will make the sort    unstable.  */
end_comment

begin_function
specifier|static
name|int
name|rank_for_schedule
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
specifier|const
name|GENERIC_PTR
name|x
decl_stmt|;
specifier|const
name|GENERIC_PTR
name|y
decl_stmt|;
block|{
name|rtx
name|tmp
init|=
operator|*
operator|(
name|rtx
operator|*
operator|)
name|y
decl_stmt|;
name|rtx
name|tmp2
init|=
operator|*
operator|(
name|rtx
operator|*
operator|)
name|x
decl_stmt|;
name|rtx
name|link
decl_stmt|;
name|int
name|tmp_class
decl_stmt|,
name|tmp2_class
decl_stmt|,
name|depend_count1
decl_stmt|,
name|depend_count2
decl_stmt|;
name|int
name|val
decl_stmt|,
name|priority_val
decl_stmt|,
name|spec_val
decl_stmt|,
name|prob_val
decl_stmt|,
name|weight_val
decl_stmt|;
comment|/* prefer insn with higher priority */
name|priority_val
operator|=
name|INSN_PRIORITY
argument_list|(
name|tmp2
argument_list|)
operator|-
name|INSN_PRIORITY
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|priority_val
condition|)
return|return
name|priority_val
return|;
comment|/* prefer an insn with smaller contribution to registers-pressure */
if|if
condition|(
operator|!
name|reload_completed
operator|&&
operator|(
name|weight_val
operator|=
name|INSN_REG_WEIGHT
argument_list|(
name|tmp
argument_list|)
operator|-
name|INSN_REG_WEIGHT
argument_list|(
name|tmp2
argument_list|)
operator|)
condition|)
return|return
operator|(
name|weight_val
operator|)
return|;
comment|/* some comparison make sense in interblock scheduling only */
if|if
condition|(
name|INSN_BB
argument_list|(
name|tmp
argument_list|)
operator|!=
name|INSN_BB
argument_list|(
name|tmp2
argument_list|)
condition|)
block|{
comment|/* prefer an inblock motion on an interblock motion */
if|if
condition|(
operator|(
name|INSN_BB
argument_list|(
name|tmp2
argument_list|)
operator|==
name|target_bb
operator|)
operator|&&
operator|(
name|INSN_BB
argument_list|(
name|tmp
argument_list|)
operator|!=
name|target_bb
operator|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|(
name|INSN_BB
argument_list|(
name|tmp
argument_list|)
operator|==
name|target_bb
operator|)
operator|&&
operator|(
name|INSN_BB
argument_list|(
name|tmp2
argument_list|)
operator|!=
name|target_bb
operator|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* prefer a useful motion on a speculative one */
if|if
condition|(
operator|(
name|spec_val
operator|=
name|IS_SPECULATIVE_INSN
argument_list|(
name|tmp
argument_list|)
operator|-
name|IS_SPECULATIVE_INSN
argument_list|(
name|tmp2
argument_list|)
operator|)
condition|)
return|return
operator|(
name|spec_val
operator|)
return|;
comment|/* prefer a more probable (speculative) insn */
name|prob_val
operator|=
name|INSN_PROBABILITY
argument_list|(
name|tmp2
argument_list|)
operator|-
name|INSN_PROBABILITY
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|prob_val
condition|)
return|return
operator|(
name|prob_val
operator|)
return|;
block|}
comment|/* compare insns based on their relation to the last-scheduled-insn */
if|if
condition|(
name|last_scheduled_insn
condition|)
block|{
comment|/* Classify the instructions into three classes:          1) Data dependent on last schedule insn.          2) Anti/Output dependent on last scheduled insn.          3) Independent of last scheduled insn, or has latency of one.          Choose the insn from the highest numbered class if different.  */
name|link
operator|=
name|find_insn_list
argument_list|(
name|tmp
argument_list|,
name|INSN_DEPEND
argument_list|(
name|last_scheduled_insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|link
operator|==
literal|0
operator|||
name|insn_cost
argument_list|(
name|last_scheduled_insn
argument_list|,
name|link
argument_list|,
name|tmp
argument_list|)
operator|==
literal|1
condition|)
name|tmp_class
operator|=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
literal|0
condition|)
comment|/* Data dependence.  */
name|tmp_class
operator|=
literal|1
expr_stmt|;
else|else
name|tmp_class
operator|=
literal|2
expr_stmt|;
name|link
operator|=
name|find_insn_list
argument_list|(
name|tmp2
argument_list|,
name|INSN_DEPEND
argument_list|(
name|last_scheduled_insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|link
operator|==
literal|0
operator|||
name|insn_cost
argument_list|(
name|last_scheduled_insn
argument_list|,
name|link
argument_list|,
name|tmp2
argument_list|)
operator|==
literal|1
condition|)
name|tmp2_class
operator|=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
literal|0
condition|)
comment|/* Data dependence.  */
name|tmp2_class
operator|=
literal|1
expr_stmt|;
else|else
name|tmp2_class
operator|=
literal|2
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|=
name|tmp2_class
operator|-
name|tmp_class
operator|)
condition|)
return|return
name|val
return|;
block|}
comment|/* Prefer the insn which has more later insns that depend on it.       This gives the scheduler more freedom when scheduling later      instructions at the expense of added register pressure.  */
name|depend_count1
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|link
operator|=
name|INSN_DEPEND
argument_list|(
name|tmp
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
name|depend_count1
operator|++
expr_stmt|;
name|depend_count2
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|link
operator|=
name|INSN_DEPEND
argument_list|(
name|tmp2
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
name|depend_count2
operator|++
expr_stmt|;
name|val
operator|=
name|depend_count2
operator|-
name|depend_count1
expr_stmt|;
if|if
condition|(
name|val
condition|)
return|return
name|val
return|;
comment|/* If insns are equally good, sort by INSN_LUID (original insn order),      so that we make the sort stable.  This minimizes instruction movement,      thus minimizing sched's effect on debugging and cross-jumping.  */
return|return
name|INSN_LUID
argument_list|(
name|tmp
argument_list|)
operator|-
name|INSN_LUID
argument_list|(
name|tmp2
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Resort the array A in which only element at index N may be out of order.  */
end_comment

begin_function
name|HAIFA_INLINE
specifier|static
name|void
name|swap_sort
parameter_list|(
name|a
parameter_list|,
name|n
parameter_list|)
name|rtx
modifier|*
name|a
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
name|rtx
name|insn
init|=
name|a
index|[
name|n
operator|-
literal|1
index|]
decl_stmt|;
name|int
name|i
init|=
name|n
operator|-
literal|2
decl_stmt|;
while|while
condition|(
name|i
operator|>=
literal|0
operator|&&
name|rank_for_schedule
argument_list|(
name|a
operator|+
name|i
argument_list|,
operator|&
name|insn
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|a
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|a
index|[
name|i
index|]
expr_stmt|;
name|i
operator|-=
literal|1
expr_stmt|;
block|}
name|a
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|insn
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|max_priority
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Add INSN to the insn queue so that it can be executed at least    N_CYCLES after the currently executing insn.  Preserve insns    chain for debugging purposes.  */
end_comment

begin_function
name|HAIFA_INLINE
specifier|static
name|void
name|queue_insn
parameter_list|(
name|insn
parameter_list|,
name|n_cycles
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|int
name|n_cycles
decl_stmt|;
block|{
name|int
name|next_q
init|=
name|NEXT_Q_AFTER
argument_list|(
name|q_ptr
argument_list|,
name|n_cycles
argument_list|)
decl_stmt|;
name|rtx
name|link
init|=
name|alloc_INSN_LIST
argument_list|(
name|insn
argument_list|,
name|insn_queue
index|[
name|next_q
index|]
argument_list|)
decl_stmt|;
name|insn_queue
index|[
name|next_q
index|]
operator|=
name|link
expr_stmt|;
name|q_size
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|sched_verbose
operator|>=
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|";;\t\tReady-->Q: insn %d: "
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|INSN_BB
argument_list|(
name|insn
argument_list|)
operator|!=
name|target_bb
condition|)
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|"(b%d) "
argument_list|,
name|INSN_BLOCK
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|"queued for %d cycles.\n"
argument_list|,
name|n_cycles
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return nonzero if PAT is the pattern of an insn which makes a    register live.  */
end_comment

begin_function
name|HAIFA_INLINE
specifier|static
name|int
name|birthing_insn_p
parameter_list|(
name|pat
parameter_list|)
name|rtx
name|pat
decl_stmt|;
block|{
name|int
name|j
decl_stmt|;
if|if
condition|(
name|reload_completed
operator|==
literal|1
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|SET
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|==
name|REG
operator|||
operator|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|==
name|BLKmode
operator|)
operator|)
condition|)
block|{
name|rtx
name|dest
init|=
name|SET_DEST
argument_list|(
name|pat
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* It would be more accurate to use refers_to_regno_p or 	 reg_mentioned_p to determine when the dest is not live before this 	 insn.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
condition|)
block|{
name|i
operator|=
name|REGNO
argument_list|(
name|dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|REGNO_REG_SET_P
argument_list|(
name|bb_live_regs
argument_list|,
name|i
argument_list|)
condition|)
return|return
operator|(
name|REG_N_SETS
argument_list|(
name|i
argument_list|)
operator|==
literal|1
operator|)
return|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|REGNO_REG_SET_P
argument_list|(
name|bb_live_regs
argument_list|,
name|regno
argument_list|)
condition|)
return|return
operator|(
name|REG_N_SETS
argument_list|(
name|regno
argument_list|)
operator|==
literal|1
operator|)
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|birthing_insn_p
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* PREV is an insn that is ready to execute.  Adjust its priority if that    will help shorten register lifetimes.  */
end_comment

begin_function
name|HAIFA_INLINE
specifier|static
name|void
name|adjust_priority
parameter_list|(
name|prev
parameter_list|)
name|rtx
name|prev
decl_stmt|;
block|{
comment|/* Trying to shorten register lives after reload has completed      is useless and wrong.  It gives inaccurate schedules.  */
if|if
condition|(
name|reload_completed
operator|==
literal|0
condition|)
block|{
name|rtx
name|note
decl_stmt|;
name|int
name|n_deaths
init|=
literal|0
decl_stmt|;
comment|/* ??? This code has no effect, because REG_DEAD notes are removed 	 before we ever get here.  */
for|for
control|(
name|note
operator|=
name|REG_NOTES
argument_list|(
name|prev
argument_list|)
init|;
name|note
condition|;
name|note
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
operator|==
name|REG_DEAD
condition|)
name|n_deaths
operator|+=
literal|1
expr_stmt|;
comment|/* Defer scheduling insns which kill registers, since that 	 shortens register lives.  Prefer scheduling insns which 	 make registers live for the same reason.  */
switch|switch
condition|(
name|n_deaths
condition|)
block|{
default|default:
name|INSN_PRIORITY
argument_list|(
name|prev
argument_list|)
operator|>>=
literal|3
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|INSN_PRIORITY
argument_list|(
name|prev
argument_list|)
operator|>>=
literal|2
expr_stmt|;
break|break;
case|case
literal|2
case|:
case|case
literal|1
case|:
name|INSN_PRIORITY
argument_list|(
name|prev
argument_list|)
operator|>>=
literal|1
expr_stmt|;
break|break;
case|case
literal|0
case|:
if|if
condition|(
name|birthing_insn_p
argument_list|(
name|PATTERN
argument_list|(
name|prev
argument_list|)
argument_list|)
condition|)
block|{
name|int
name|max
init|=
name|max_priority
decl_stmt|;
if|if
condition|(
name|max
operator|>
name|INSN_PRIORITY
argument_list|(
name|prev
argument_list|)
condition|)
name|INSN_PRIORITY
argument_list|(
name|prev
argument_list|)
operator|=
name|max
expr_stmt|;
block|}
break|break;
block|}
ifdef|#
directive|ifdef
name|ADJUST_PRIORITY
name|ADJUST_PRIORITY
argument_list|(
name|prev
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_comment
comment|/* Clock at which the previous instruction was issued.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|last_clock_var
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* INSN is the "currently executing insn".  Launch each insn which was    waiting on INSN.  READY is a vector of insns which are ready to fire.    N_READY is the number of elements in READY.  CLOCK is the current    cycle.  */
end_comment

begin_function
specifier|static
name|int
name|schedule_insn
parameter_list|(
name|insn
parameter_list|,
name|ready
parameter_list|,
name|n_ready
parameter_list|,
name|clock
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|rtx
modifier|*
name|ready
decl_stmt|;
name|int
name|n_ready
decl_stmt|;
name|int
name|clock
decl_stmt|;
block|{
name|rtx
name|link
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|unit
operator|=
name|insn_unit
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|sched_verbose
operator|>=
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|";;\t\t--> scheduling insn<<<%d>>> on unit "
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|insn_print_units
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sched_verbose
operator|&&
name|unit
operator|==
operator|-
literal|1
condition|)
name|visualize_no_unit
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|MAX_BLOCKAGE
operator|>
literal|1
operator|||
name|issue_rate
operator|>
literal|1
operator|||
name|sched_verbose
condition|)
name|schedule_unit
argument_list|(
name|unit
argument_list|,
name|insn
argument_list|,
name|clock
argument_list|)
expr_stmt|;
if|if
condition|(
name|INSN_DEPEND
argument_list|(
name|insn
argument_list|)
operator|==
literal|0
condition|)
return|return
name|n_ready
return|;
comment|/* This is used by the function adjust_priority above.  */
if|if
condition|(
name|n_ready
operator|>
literal|0
condition|)
name|max_priority
operator|=
name|MAX
argument_list|(
name|INSN_PRIORITY
argument_list|(
name|ready
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|INSN_PRIORITY
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|max_priority
operator|=
name|INSN_PRIORITY
argument_list|(
name|insn
argument_list|)
expr_stmt|;
for|for
control|(
name|link
operator|=
name|INSN_DEPEND
argument_list|(
name|insn
argument_list|)
init|;
name|link
operator|!=
literal|0
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|rtx
name|next
init|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|cost
init|=
name|insn_cost
argument_list|(
name|insn
argument_list|,
name|link
argument_list|,
name|next
argument_list|)
decl_stmt|;
name|INSN_TICK
argument_list|(
name|next
argument_list|)
operator|=
name|MAX
argument_list|(
name|INSN_TICK
argument_list|(
name|next
argument_list|)
argument_list|,
name|clock
operator|+
name|cost
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|INSN_DEP_COUNT
argument_list|(
name|next
argument_list|)
operator|-=
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
name|int
name|effective_cost
init|=
name|INSN_TICK
argument_list|(
name|next
argument_list|)
operator|-
name|clock
decl_stmt|;
comment|/* For speculative insns, before inserting to ready/queue, 	     check live, exception-free, and issue-delay */
if|if
condition|(
name|INSN_BB
argument_list|(
name|next
argument_list|)
operator|!=
name|target_bb
operator|&&
operator|(
operator|!
name|IS_VALID
argument_list|(
name|INSN_BB
argument_list|(
name|next
argument_list|)
argument_list|)
operator|||
name|CANT_MOVE
argument_list|(
name|next
argument_list|)
operator|||
operator|(
name|IS_SPECULATIVE_INSN
argument_list|(
name|next
argument_list|)
operator|&&
operator|(
name|insn_issue_delay
argument_list|(
name|next
argument_list|)
operator|>
literal|3
operator|||
operator|!
name|check_live
argument_list|(
name|next
argument_list|,
name|INSN_BB
argument_list|(
name|next
argument_list|)
argument_list|)
operator|||
operator|!
name|is_exception_free
argument_list|(
name|next
argument_list|,
name|INSN_BB
argument_list|(
name|next
argument_list|)
argument_list|,
name|target_bb
argument_list|)
operator|)
operator|)
operator|)
condition|)
continue|continue;
if|if
condition|(
name|sched_verbose
operator|>=
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|";;\t\tdependences resolved: insn %d "
argument_list|,
name|INSN_UID
argument_list|(
name|next
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_nr_blocks
operator|>
literal|1
operator|&&
name|INSN_BB
argument_list|(
name|next
argument_list|)
operator|!=
name|target_bb
condition|)
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|"/b%d "
argument_list|,
name|INSN_BLOCK
argument_list|(
name|next
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|effective_cost
operator|<=
literal|1
condition|)
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|"into ready\n"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|"into queue with cost=%d\n"
argument_list|,
name|effective_cost
argument_list|)
expr_stmt|;
block|}
comment|/* Adjust the priority of NEXT and either put it on the ready 	     list or queue it.  */
name|adjust_priority
argument_list|(
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|effective_cost
operator|<=
literal|1
condition|)
name|ready
index|[
name|n_ready
operator|++
index|]
operator|=
name|next
expr_stmt|;
else|else
name|queue_insn
argument_list|(
name|next
argument_list|,
name|effective_cost
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Annotate the instruction with issue information -- TImode       indicates that the instruction is expected not to be able      to issue on the same cycle as the previous insn.  A machine      may use this information to decide how the instruction should      be aligned.  */
if|if
condition|(
name|reload_completed
operator|&&
name|issue_rate
operator|>
literal|1
condition|)
block|{
name|PUT_MODE
argument_list|(
name|insn
argument_list|,
name|clock
operator|>
name|last_clock_var
condition|?
name|TImode
else|:
name|VOIDmode
argument_list|)
expr_stmt|;
name|last_clock_var
operator|=
name|clock
expr_stmt|;
block|}
return|return
name|n_ready
return|;
block|}
end_function

begin_comment
comment|/* Add a REG_DEAD note for REG to INSN, reusing a REG_DEAD note from the    dead_notes list.  */
end_comment

begin_function
specifier|static
name|void
name|create_reg_dead_note
parameter_list|(
name|reg
parameter_list|,
name|insn
parameter_list|)
name|rtx
name|reg
decl_stmt|,
name|insn
decl_stmt|;
block|{
name|rtx
name|link
decl_stmt|;
comment|/* The number of registers killed after scheduling must be the same as the      number of registers killed before scheduling.  The number of REG_DEAD      notes may not be conserved, i.e. two SImode hard register REG_DEAD notes      might become one DImode hard register REG_DEAD note, but the number of      registers killed will be conserved.       We carefully remove REG_DEAD notes from the dead_notes list, so that      there will be none left at the end.  If we run out early, then there      is a bug somewhere in flow, combine and/or sched.  */
if|if
condition|(
name|dead_notes
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|current_nr_blocks
operator|<=
literal|1
condition|)
name|abort
argument_list|()
expr_stmt|;
else|else
name|link
operator|=
name|alloc_EXPR_LIST
argument_list|(
name|REG_DEAD
argument_list|,
name|NULL_RTX
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Number of regs killed by REG.  */
name|int
name|regs_killed
init|=
operator|(
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|?
literal|1
else|:
name|HARD_REGNO_NREGS
argument_list|(
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
operator|)
decl_stmt|;
comment|/* Number of regs killed by REG_DEAD notes taken off the list.  */
name|int
name|reg_note_regs
decl_stmt|;
name|link
operator|=
name|dead_notes
expr_stmt|;
name|reg_note_regs
operator|=
operator|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|?
literal|1
else|:
name|HARD_REGNO_NREGS
argument_list|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
expr_stmt|;
while|while
condition|(
name|reg_note_regs
operator|<
name|regs_killed
condition|)
block|{
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* LINK might be zero if we killed more registers after scheduling 	     than before, and the last hard register we kill is actually 	     multiple hard regs.   	     This is normal for interblock scheduling, so deal with it in 	     that case, else abort.  */
if|if
condition|(
name|link
operator|==
name|NULL_RTX
operator|&&
name|current_nr_blocks
operator|<=
literal|1
condition|)
name|abort
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|link
operator|==
name|NULL_RTX
condition|)
name|link
operator|=
name|alloc_EXPR_LIST
argument_list|(
name|REG_DEAD
argument_list|,
name|gen_rtx_REG
argument_list|(
name|word_mode
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|reg_note_regs
operator|+=
operator|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|?
literal|1
else|:
name|HARD_REGNO_NREGS
argument_list|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
expr_stmt|;
block|}
name|dead_notes
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* If we took too many regs kills off, put the extra ones back.  */
while|while
condition|(
name|reg_note_regs
operator|>
name|regs_killed
condition|)
block|{
name|rtx
name|temp_reg
decl_stmt|,
name|temp_link
decl_stmt|;
name|temp_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|word_mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|temp_link
operator|=
name|alloc_EXPR_LIST
argument_list|(
name|REG_DEAD
argument_list|,
name|temp_reg
argument_list|,
name|dead_notes
argument_list|)
expr_stmt|;
name|dead_notes
operator|=
name|temp_link
expr_stmt|;
name|reg_note_regs
operator|--
expr_stmt|;
block|}
block|}
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
operator|=
name|reg
expr_stmt|;
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|link
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Subroutine on attach_deaths_insn--handles the recursive search    through INSN.  If SET_P is true, then x is being modified by the insn.  */
end_comment

begin_function
specifier|static
name|void
name|attach_deaths
parameter_list|(
name|x
parameter_list|,
name|insn
parameter_list|,
name|set_p
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|int
name|set_p
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
specifier|register
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|LABEL_REF
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|CONST
case|:
case|case
name|CODE_LABEL
case|:
case|case
name|PC
case|:
case|case
name|CC0
case|:
comment|/* Get rid of the easy cases first.  */
return|return;
case|case
name|REG
case|:
block|{
comment|/* If the register dies in this insn, queue that note, and mark 	   this register as needing to die.  */
comment|/* This code is very similar to mark_used_1 (if set_p is false) 	   and mark_set_1 (if set_p is true) in flow.c.  */
specifier|register
name|int
name|regno
decl_stmt|;
name|int
name|some_needed
decl_stmt|;
name|int
name|all_needed
decl_stmt|;
if|if
condition|(
name|set_p
condition|)
return|return;
name|regno
operator|=
name|REGNO
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|all_needed
operator|=
name|some_needed
operator|=
name|REGNO_REG_SET_P
argument_list|(
name|old_live_regs
argument_list|,
name|regno
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|int
name|n
decl_stmt|;
name|n
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|n
operator|>
literal|0
condition|)
block|{
name|int
name|needed
init|=
operator|(
name|REGNO_REG_SET_P
argument_list|(
name|old_live_regs
argument_list|,
name|regno
operator|+
name|n
argument_list|)
operator|)
decl_stmt|;
name|some_needed
operator||=
name|needed
expr_stmt|;
name|all_needed
operator|&=
name|needed
expr_stmt|;
block|}
block|}
comment|/* If it wasn't live before we started, then add a REG_DEAD note. 	   We must check the previous lifetime info not the current info, 	   because we may have to execute this code several times, e.g. 	   once for a clobber (which doesn't add a note) and later 	   for a use (which does add a note).  	   Always make the register live.  We must do this even if it was 	   live before, because this may be an insn which sets and uses 	   the same register, in which case the register has already been 	   killed, so we must make it live again.  	   Global registers are always live, and should never have a REG_DEAD 	   note added for them, so none of the code below applies to them.  */
if|if
condition|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|||
operator|!
name|global_regs
index|[
name|regno
index|]
condition|)
block|{
comment|/* Never add REG_DEAD notes for STACK_POINTER_REGNUM 	       since it's always considered to be live.  Similarly 	       for FRAME_POINTER_REGNUM if a frame pointer is needed 	       and for ARG_POINTER_REGNUM if it is fixed.  */
if|if
condition|(
operator|!
operator|(
name|regno
operator|==
name|FRAME_POINTER_REGNUM
operator|&&
operator|(
operator|!
name|reload_completed
operator|||
name|frame_pointer_needed
operator|)
operator|)
if|#
directive|if
name|HARD_FRAME_POINTER_REGNUM
operator|!=
name|FRAME_POINTER_REGNUM
operator|&&
operator|!
operator|(
name|regno
operator|==
name|HARD_FRAME_POINTER_REGNUM
operator|&&
operator|(
operator|!
name|reload_completed
operator|||
name|frame_pointer_needed
operator|)
operator|)
endif|#
directive|endif
if|#
directive|if
name|ARG_POINTER_REGNUM
operator|!=
name|FRAME_POINTER_REGNUM
operator|&&
operator|!
operator|(
name|regno
operator|==
name|ARG_POINTER_REGNUM
operator|&&
name|fixed_regs
index|[
name|regno
index|]
operator|)
endif|#
directive|endif
operator|&&
name|regno
operator|!=
name|STACK_POINTER_REGNUM
condition|)
block|{
if|if
condition|(
operator|!
name|all_needed
operator|&&
operator|!
name|dead_or_set_p
argument_list|(
name|insn
argument_list|,
name|x
argument_list|)
condition|)
block|{
comment|/* Check for the case where the register dying partially 		       overlaps the register set by this insn.  */
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|>
literal|1
condition|)
block|{
name|int
name|n
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
operator|--
name|n
operator|>=
literal|0
condition|)
name|some_needed
operator||=
name|dead_or_set_regno_p
argument_list|(
name|insn
argument_list|,
name|regno
operator|+
name|n
argument_list|)
expr_stmt|;
block|}
comment|/* If none of the words in X is needed, make a REG_DEAD 		       note.  Otherwise, we must make partial REG_DEAD 		       notes.  */
if|if
condition|(
operator|!
name|some_needed
condition|)
name|create_reg_dead_note
argument_list|(
name|x
argument_list|,
name|insn
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|i
decl_stmt|;
comment|/* Don't make a REG_DEAD note for a part of a 			   register that is set in the insn.  */
for|for
control|(
name|i
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
operator|!
name|REGNO_REG_SET_P
argument_list|(
name|old_live_regs
argument_list|,
name|regno
operator|+
name|i
argument_list|)
operator|&&
operator|!
name|dead_or_set_regno_p
argument_list|(
name|insn
argument_list|,
name|regno
operator|+
name|i
argument_list|)
condition|)
name|create_reg_dead_note
argument_list|(
name|gen_rtx_REG
argument_list|(
name|reg_raw_mode
index|[
name|regno
operator|+
name|i
index|]
argument_list|,
name|regno
operator|+
name|i
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|int
name|j
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
operator|--
name|j
operator|>=
literal|0
condition|)
block|{
name|SET_REGNO_REG_SET
argument_list|(
name|bb_live_regs
argument_list|,
name|regno
operator|+
name|j
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Recompute REG_BASIC_BLOCK as we update all the other 		   dataflow information.  */
if|if
condition|(
name|sched_reg_basic_block
index|[
name|regno
index|]
operator|==
name|REG_BLOCK_UNKNOWN
condition|)
name|sched_reg_basic_block
index|[
name|regno
index|]
operator|=
name|current_block_num
expr_stmt|;
elseif|else
if|if
condition|(
name|sched_reg_basic_block
index|[
name|regno
index|]
operator|!=
name|current_block_num
condition|)
name|sched_reg_basic_block
index|[
name|regno
index|]
operator|=
name|REG_BLOCK_GLOBAL
expr_stmt|;
name|SET_REGNO_REG_SET
argument_list|(
name|bb_live_regs
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
case|case
name|MEM
case|:
comment|/* Handle tail-recursive case.  */
name|attach_deaths
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
case|case
name|SUBREG
case|:
name|attach_deaths
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|,
name|insn
argument_list|,
name|set_p
operator|&&
operator|(
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|<=
name|UNITS_PER_WORD
operator|)
operator|||
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|==
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
operator|(
name|x
operator|)
argument_list|)
argument_list|)
operator|)
operator|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|STRICT_LOW_PART
case|:
name|attach_deaths
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
case|case
name|ZERO_EXTRACT
case|:
case|case
name|SIGN_EXTRACT
case|:
name|attach_deaths
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|attach_deaths
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|attach_deaths
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
case|case
name|PARALLEL
case|:
if|if
condition|(
name|set_p
operator|&&
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|BLKmode
condition|)
block|{
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|attach_deaths
argument_list|(
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|,
name|insn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* fallthrough */
default|default:
comment|/* Other cases: walk the insn.  */
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|attach_deaths
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|attach_deaths
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* After INSN has executed, add register death notes for each register    that is dead after INSN.  */
end_comment

begin_function
specifier|static
name|void
name|attach_deaths_insn
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|rtx
name|x
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
specifier|register
name|RTX_CODE
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|rtx
name|link
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|SET
condition|)
block|{
name|attach_deaths
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* A register might die here even if it is the destination, e.g.          it is the target of a volatile read and is otherwise unused.          Hence we must always call attach_deaths for the SET_DEST.  */
name|attach_deaths
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
name|insn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|PARALLEL
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|code
operator|=
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|SET
condition|)
block|{
name|attach_deaths
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|attach_deaths
argument_list|(
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|,
name|insn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Flow does not add REG_DEAD notes to registers that die in 	     clobbers, so we can't either.  */
elseif|else
if|if
condition|(
name|code
operator|!=
name|CLOBBER
condition|)
name|attach_deaths
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If this is a CLOBBER, only add REG_DEAD notes to registers inside a      MEM being clobbered, just like flow.  */
elseif|else
if|if
condition|(
name|code
operator|==
name|CLOBBER
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
name|attach_deaths
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Otherwise don't add a death note to things being clobbered.  */
elseif|else
if|if
condition|(
name|code
operator|!=
name|CLOBBER
condition|)
name|attach_deaths
argument_list|(
name|x
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Make death notes for things used in the called function.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
for|for
control|(
name|link
operator|=
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
name|attach_deaths
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn
argument_list|,
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CLOBBER
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* functions for handlnig of notes */
end_comment

begin_comment
comment|/* Delete notes beginning with INSN and put them in the chain    of notes ended by NOTE_LIST.    Returns the insn following the notes.  */
end_comment

begin_function
specifier|static
name|rtx
name|unlink_other_notes
parameter_list|(
name|insn
parameter_list|,
name|tail
parameter_list|)
name|rtx
name|insn
decl_stmt|,
name|tail
decl_stmt|;
block|{
name|rtx
name|prev
init|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
while|while
condition|(
name|insn
operator|!=
name|tail
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
block|{
name|rtx
name|next
init|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
comment|/* Delete the note from its current position.  */
if|if
condition|(
name|prev
condition|)
name|NEXT_INSN
argument_list|(
name|prev
argument_list|)
operator|=
name|next
expr_stmt|;
if|if
condition|(
name|next
condition|)
name|PREV_INSN
argument_list|(
name|next
argument_list|)
operator|=
name|prev
expr_stmt|;
comment|/* Don't save away NOTE_INSN_SETJMPs, because they must remain          immediately after the call they follow.  We use a fake          (REG_DEAD (const_int -1)) note to remember them.          Likewise with NOTE_INSN_{LOOP,EHREGION}_{BEG, END}.  */
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE_INSN_SETJMP
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE_INSN_LOOP_BEG
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE_INSN_LOOP_END
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE_INSN_RANGE_START
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE_INSN_RANGE_END
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE_INSN_EH_REGION_BEG
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE_INSN_EH_REGION_END
condition|)
block|{
comment|/* Insert the note at the end of the notes list.  */
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
operator|=
name|note_list
expr_stmt|;
if|if
condition|(
name|note_list
condition|)
name|NEXT_INSN
argument_list|(
name|note_list
argument_list|)
operator|=
name|insn
expr_stmt|;
name|note_list
operator|=
name|insn
expr_stmt|;
block|}
name|insn
operator|=
name|next
expr_stmt|;
block|}
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Delete line notes beginning with INSN. Record line-number notes so    they can be reused.  Returns the insn following the notes.  */
end_comment

begin_function
specifier|static
name|rtx
name|unlink_line_notes
parameter_list|(
name|insn
parameter_list|,
name|tail
parameter_list|)
name|rtx
name|insn
decl_stmt|,
name|tail
decl_stmt|;
block|{
name|rtx
name|prev
init|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
while|while
condition|(
name|insn
operator|!=
name|tail
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
block|{
name|rtx
name|next
init|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|write_symbols
operator|!=
name|NO_DEBUG
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|>
literal|0
condition|)
block|{
comment|/* Delete the note from its current position.  */
if|if
condition|(
name|prev
condition|)
name|NEXT_INSN
argument_list|(
name|prev
argument_list|)
operator|=
name|next
expr_stmt|;
if|if
condition|(
name|next
condition|)
name|PREV_INSN
argument_list|(
name|next
argument_list|)
operator|=
name|prev
expr_stmt|;
comment|/* Record line-number notes so they can be reused.  */
name|LINE_NOTE
argument_list|(
name|insn
argument_list|)
operator|=
name|insn
expr_stmt|;
block|}
else|else
name|prev
operator|=
name|insn
expr_stmt|;
name|insn
operator|=
name|next
expr_stmt|;
block|}
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Return the head and tail pointers of BB.  */
end_comment

begin_function
name|HAIFA_INLINE
specifier|static
name|void
name|get_block_head_tail
parameter_list|(
name|bb
parameter_list|,
name|headp
parameter_list|,
name|tailp
parameter_list|)
name|int
name|bb
decl_stmt|;
name|rtx
modifier|*
name|headp
decl_stmt|;
name|rtx
modifier|*
name|tailp
decl_stmt|;
block|{
name|rtx
name|head
decl_stmt|;
name|rtx
name|tail
decl_stmt|;
name|int
name|b
decl_stmt|;
name|b
operator|=
name|BB_TO_BLOCK
argument_list|(
name|bb
argument_list|)
expr_stmt|;
comment|/* HEAD and TAIL delimit the basic block being scheduled.  */
name|head
operator|=
name|BLOCK_HEAD
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|tail
operator|=
name|BLOCK_END
argument_list|(
name|b
argument_list|)
expr_stmt|;
comment|/* Don't include any notes or labels at the beginning of the      basic block, or notes at the ends of basic blocks.  */
while|while
condition|(
name|head
operator|!=
name|tail
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|head
argument_list|)
operator|==
name|NOTE
condition|)
name|head
operator|=
name|NEXT_INSN
argument_list|(
name|head
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|tail
argument_list|)
operator|==
name|NOTE
condition|)
name|tail
operator|=
name|PREV_INSN
argument_list|(
name|tail
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|head
argument_list|)
operator|==
name|CODE_LABEL
condition|)
name|head
operator|=
name|NEXT_INSN
argument_list|(
name|head
argument_list|)
expr_stmt|;
else|else
break|break;
block|}
operator|*
name|headp
operator|=
name|head
expr_stmt|;
operator|*
name|tailp
operator|=
name|tail
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Delete line notes from bb. Save them so they can be later restored    (in restore_line_notes ()).  */
end_comment

begin_function
specifier|static
name|void
name|rm_line_notes
parameter_list|(
name|bb
parameter_list|)
name|int
name|bb
decl_stmt|;
block|{
name|rtx
name|next_tail
decl_stmt|;
name|rtx
name|tail
decl_stmt|;
name|rtx
name|head
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|get_block_head_tail
argument_list|(
name|bb
argument_list|,
operator|&
name|head
argument_list|,
operator|&
name|tail
argument_list|)
expr_stmt|;
if|if
condition|(
name|head
operator|==
name|tail
operator|&&
operator|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|head
argument_list|)
argument_list|)
operator|!=
literal|'i'
operator|)
condition|)
return|return;
name|next_tail
operator|=
name|NEXT_INSN
argument_list|(
name|tail
argument_list|)
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|head
init|;
name|insn
operator|!=
name|next_tail
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|rtx
name|prev
decl_stmt|;
comment|/* Farm out notes, and maybe save them in NOTE_LIST.          This is needed to keep the debugger from          getting completely deranged.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
block|{
name|prev
operator|=
name|insn
expr_stmt|;
name|insn
operator|=
name|unlink_line_notes
argument_list|(
name|insn
argument_list|,
name|next_tail
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev
operator|==
name|tail
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|prev
operator|==
name|head
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|insn
operator|==
name|next_tail
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Save line number notes for each insn in bb.  */
end_comment

begin_function
specifier|static
name|void
name|save_line_notes
parameter_list|(
name|bb
parameter_list|)
name|int
name|bb
decl_stmt|;
block|{
name|rtx
name|head
decl_stmt|,
name|tail
decl_stmt|;
name|rtx
name|next_tail
decl_stmt|;
comment|/* We must use the true line number for the first insn in the block      that was computed and saved at the start of this pass.  We can't      use the current line number, because scheduling of the previous      block may have changed the current line number.  */
name|rtx
name|line
init|=
name|line_note_head
index|[
name|BB_TO_BLOCK
argument_list|(
name|bb
argument_list|)
index|]
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|get_block_head_tail
argument_list|(
name|bb
argument_list|,
operator|&
name|head
argument_list|,
operator|&
name|tail
argument_list|)
expr_stmt|;
name|next_tail
operator|=
name|NEXT_INSN
argument_list|(
name|tail
argument_list|)
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|BLOCK_HEAD
argument_list|(
name|BB_TO_BLOCK
argument_list|(
name|bb
argument_list|)
argument_list|)
init|;
name|insn
operator|!=
name|next_tail
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|>
literal|0
condition|)
name|line
operator|=
name|insn
expr_stmt|;
else|else
name|LINE_NOTE
argument_list|(
name|insn
argument_list|)
operator|=
name|line
expr_stmt|;
block|}
end_function

begin_comment
comment|/* After bb was scheduled, insert line notes into the insns list.  */
end_comment

begin_function
specifier|static
name|void
name|restore_line_notes
parameter_list|(
name|bb
parameter_list|)
name|int
name|bb
decl_stmt|;
block|{
name|rtx
name|line
decl_stmt|,
name|note
decl_stmt|,
name|prev
decl_stmt|,
name|new
decl_stmt|;
name|int
name|added_notes
init|=
literal|0
decl_stmt|;
name|int
name|b
decl_stmt|;
name|rtx
name|head
decl_stmt|,
name|next_tail
decl_stmt|,
name|insn
decl_stmt|;
name|b
operator|=
name|BB_TO_BLOCK
argument_list|(
name|bb
argument_list|)
expr_stmt|;
name|head
operator|=
name|BLOCK_HEAD
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|next_tail
operator|=
name|NEXT_INSN
argument_list|(
name|BLOCK_END
argument_list|(
name|b
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Determine the current line-number.  We want to know the current      line number of the first insn of the block here, in case it is      different from the true line number that was saved earlier.  If      different, then we need a line number note before the first insn      of this block.  If it happens to be the same, then we don't want to      emit another line number note here.  */
for|for
control|(
name|line
operator|=
name|head
init|;
name|line
condition|;
name|line
operator|=
name|PREV_INSN
argument_list|(
name|line
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|line
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|line
argument_list|)
operator|>
literal|0
condition|)
break|break;
comment|/* Walk the insns keeping track of the current line-number and inserting      the line-number notes as needed.  */
for|for
control|(
name|insn
operator|=
name|head
init|;
name|insn
operator|!=
name|next_tail
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|>
literal|0
condition|)
name|line
operator|=
name|insn
expr_stmt|;
comment|/* This used to emit line number notes before every non-deleted note.      However, this confuses a debugger, because line notes not separated      by real instructions all end up at the same address.  I can find no      use for line number notes before other notes, so none are emitted.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE
operator|&&
operator|(
name|note
operator|=
name|LINE_NOTE
argument_list|(
name|insn
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|note
operator|!=
name|line
operator|&&
operator|(
name|line
operator|==
literal|0
operator|||
name|NOTE_LINE_NUMBER
argument_list|(
name|note
argument_list|)
operator|!=
name|NOTE_LINE_NUMBER
argument_list|(
name|line
argument_list|)
operator|||
name|NOTE_SOURCE_FILE
argument_list|(
name|note
argument_list|)
operator|!=
name|NOTE_SOURCE_FILE
argument_list|(
name|line
argument_list|)
operator|)
condition|)
block|{
name|line
operator|=
name|note
expr_stmt|;
name|prev
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|LINE_NOTE
argument_list|(
name|note
argument_list|)
condition|)
block|{
comment|/* Re-use the original line-number note.  */
name|LINE_NOTE
argument_list|(
name|note
argument_list|)
operator|=
literal|0
expr_stmt|;
name|PREV_INSN
argument_list|(
name|note
argument_list|)
operator|=
name|prev
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|prev
argument_list|)
operator|=
name|note
expr_stmt|;
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
operator|=
name|note
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|note
argument_list|)
operator|=
name|insn
expr_stmt|;
block|}
else|else
block|{
name|added_notes
operator|++
expr_stmt|;
name|new
operator|=
name|emit_note_after
argument_list|(
name|NOTE_LINE_NUMBER
argument_list|(
name|note
argument_list|)
argument_list|,
name|prev
argument_list|)
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|new
argument_list|)
operator|=
name|NOTE_SOURCE_FILE
argument_list|(
name|note
argument_list|)
expr_stmt|;
name|RTX_INTEGRATED_P
argument_list|(
name|new
argument_list|)
operator|=
name|RTX_INTEGRATED_P
argument_list|(
name|note
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sched_verbose
operator|&&
name|added_notes
condition|)
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|";; added %d line-number notes\n"
argument_list|,
name|added_notes
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* After scheduling the function, delete redundant line notes from the    insns list.  */
end_comment

begin_function
specifier|static
name|void
name|rm_redundant_line_notes
parameter_list|()
block|{
name|rtx
name|line
init|=
literal|0
decl_stmt|;
name|rtx
name|insn
init|=
name|get_insns
argument_list|()
decl_stmt|;
name|int
name|active_insn
init|=
literal|0
decl_stmt|;
name|int
name|notes
init|=
literal|0
decl_stmt|;
comment|/* Walk the insns deleting redundant line-number notes.  Many of these      are already present.  The remainder tend to occur at basic      block boundaries.  */
for|for
control|(
name|insn
operator|=
name|get_last_insn
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|>
literal|0
condition|)
block|{
comment|/* If there are no active insns following, INSN is redundant.  */
if|if
condition|(
name|active_insn
operator|==
literal|0
condition|)
block|{
name|notes
operator|++
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
operator|=
literal|0
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
block|}
comment|/* If the line number is unchanged, LINE is redundant.  */
elseif|else
if|if
condition|(
name|line
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|line
argument_list|)
operator|==
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|&&
name|NOTE_SOURCE_FILE
argument_list|(
name|line
argument_list|)
operator|==
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|notes
operator|++
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|line
argument_list|)
operator|=
literal|0
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|line
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
name|line
operator|=
name|insn
expr_stmt|;
block|}
else|else
name|line
operator|=
name|insn
expr_stmt|;
name|active_insn
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_DELETED
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|USE
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|CLOBBER
operator|)
operator|)
operator|)
condition|)
name|active_insn
operator|++
expr_stmt|;
if|if
condition|(
name|sched_verbose
operator|&&
name|notes
condition|)
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|";; deleted %d line-number notes\n"
argument_list|,
name|notes
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Delete notes between head and tail and put them in the chain    of notes ended by NOTE_LIST.  */
end_comment

begin_function
specifier|static
name|void
name|rm_other_notes
parameter_list|(
name|head
parameter_list|,
name|tail
parameter_list|)
name|rtx
name|head
decl_stmt|;
name|rtx
name|tail
decl_stmt|;
block|{
name|rtx
name|next_tail
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
if|if
condition|(
name|head
operator|==
name|tail
operator|&&
operator|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|head
argument_list|)
argument_list|)
operator|!=
literal|'i'
operator|)
condition|)
return|return;
name|next_tail
operator|=
name|NEXT_INSN
argument_list|(
name|tail
argument_list|)
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|head
init|;
name|insn
operator|!=
name|next_tail
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|rtx
name|prev
decl_stmt|;
comment|/* Farm out notes, and maybe save them in NOTE_LIST.          This is needed to keep the debugger from          getting completely deranged.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
block|{
name|prev
operator|=
name|insn
expr_stmt|;
name|insn
operator|=
name|unlink_other_notes
argument_list|(
name|insn
argument_list|,
name|next_tail
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev
operator|==
name|tail
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|prev
operator|==
name|head
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|insn
operator|==
name|next_tail
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Constructor for `sometimes' data structure.  */
end_comment

begin_function
specifier|static
name|int
name|new_sometimes_live
parameter_list|(
name|regs_sometimes_live
parameter_list|,
name|regno
parameter_list|,
name|sometimes_max
parameter_list|)
name|struct
name|sometimes
modifier|*
name|regs_sometimes_live
decl_stmt|;
name|int
name|regno
decl_stmt|;
name|int
name|sometimes_max
decl_stmt|;
block|{
specifier|register
name|struct
name|sometimes
modifier|*
name|p
decl_stmt|;
comment|/* There should never be a register greater than max_regno here.  If there      is, it means that a define_split has created a new pseudo reg.  This      is not allowed, since there will not be flow info available for any      new register, so catch the error here.  */
if|if
condition|(
name|regno
operator|>=
name|max_regno
condition|)
name|abort
argument_list|()
expr_stmt|;
name|p
operator|=
operator|&
name|regs_sometimes_live
index|[
name|sometimes_max
index|]
expr_stmt|;
name|p
operator|->
name|regno
operator|=
name|regno
expr_stmt|;
name|p
operator|->
name|live_length
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|calls_crossed
operator|=
literal|0
expr_stmt|;
name|sometimes_max
operator|++
expr_stmt|;
return|return
name|sometimes_max
return|;
block|}
end_function

begin_comment
comment|/* Count lengths of all regs we are currently tracking,    and find new registers no longer live.  */
end_comment

begin_function
specifier|static
name|void
name|finish_sometimes_live
parameter_list|(
name|regs_sometimes_live
parameter_list|,
name|sometimes_max
parameter_list|)
name|struct
name|sometimes
modifier|*
name|regs_sometimes_live
decl_stmt|;
name|int
name|sometimes_max
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sometimes_max
condition|;
name|i
operator|++
control|)
block|{
specifier|register
name|struct
name|sometimes
modifier|*
name|p
init|=
operator|&
name|regs_sometimes_live
index|[
name|i
index|]
decl_stmt|;
name|int
name|regno
init|=
name|p
operator|->
name|regno
decl_stmt|;
name|sched_reg_live_length
index|[
name|regno
index|]
operator|+=
name|p
operator|->
name|live_length
expr_stmt|;
name|sched_reg_n_calls_crossed
index|[
name|regno
index|]
operator|+=
name|p
operator|->
name|calls_crossed
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* functions for computation of registers live/usage info */
end_comment

begin_comment
comment|/* It is assumed that prior to scheduling BASIC_BLOCK (b)->global_live_at_start    contains the registers that are alive at the entry to b.     Two passes follow: The first pass is performed before the scheduling    of a region. It scans each block of the region forward, computing    the set of registers alive at the end of the basic block and    discard REG_DEAD notes (done by find_pre_sched_live ()).     The second path is invoked after scheduling all region blocks.    It scans each block of the region backward, a block being traversed    only after its succesors in the region. When the set of registers    live at the end of a basic block may be changed by the scheduling    (this may happen for multiple blocks region), it is computed as    the union of the registers live at the start of its succesors.    The last-use information is updated by inserting REG_DEAD notes.    (done by find_post_sched_live ()) */
end_comment

begin_comment
comment|/* Scan all the insns to be scheduled, removing register death notes.    Register death notes end up in DEAD_NOTES.    Recreate the register life information for the end of this basic    block.  */
end_comment

begin_function
specifier|static
name|void
name|find_pre_sched_live
parameter_list|(
name|bb
parameter_list|)
name|int
name|bb
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|,
name|next_tail
decl_stmt|,
name|head
decl_stmt|,
name|tail
decl_stmt|;
name|int
name|b
init|=
name|BB_TO_BLOCK
argument_list|(
name|bb
argument_list|)
decl_stmt|;
name|get_block_head_tail
argument_list|(
name|bb
argument_list|,
operator|&
name|head
argument_list|,
operator|&
name|tail
argument_list|)
expr_stmt|;
name|COPY_REG_SET
argument_list|(
name|bb_live_regs
argument_list|,
name|BASIC_BLOCK
argument_list|(
name|b
argument_list|)
operator|->
name|global_live_at_start
argument_list|)
expr_stmt|;
name|next_tail
operator|=
name|NEXT_INSN
argument_list|(
name|tail
argument_list|)
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|head
init|;
name|insn
operator|!=
name|next_tail
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|rtx
name|prev
decl_stmt|,
name|next
decl_stmt|,
name|link
decl_stmt|;
name|int
name|reg_weight
init|=
literal|0
decl_stmt|;
comment|/* Handle register life information.  */
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
literal|'i'
condition|)
block|{
comment|/* See if the register gets born here.  */
comment|/* We must check for registers being born before we check for 	     registers dying.  It is possible for a register to be born and 	     die in the same insn, e.g. reading from a volatile memory 	     location into an otherwise unused register.  Such a register 	     must be marked as dead after this insn.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|CLOBBER
condition|)
block|{
name|sched_note_set
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|reg_weight
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
argument_list|)
operator|==
name|SET
operator|||
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
argument_list|)
operator|==
name|CLOBBER
condition|)
block|{
name|sched_note_set
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|reg_weight
operator|++
expr_stmt|;
block|}
comment|/* ??? This code is obsolete and should be deleted.  It 	         is harmless though, so we will leave it in for now.  */
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
argument_list|)
operator|==
name|USE
condition|)
name|sched_note_set
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Each call cobbers (makes live) all call-clobbered regs 	     that are not global or fixed.  Note that the function-value 	     reg is a call_clobbered reg.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|call_used_regs
index|[
name|j
index|]
operator|&&
operator|!
name|global_regs
index|[
name|j
index|]
operator|&&
operator|!
name|fixed_regs
index|[
name|j
index|]
condition|)
block|{
name|SET_REGNO_REG_SET
argument_list|(
name|bb_live_regs
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Need to know what registers this insn kills.  */
for|for
control|(
name|prev
operator|=
literal|0
operator|,
name|link
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|next
control|)
block|{
name|next
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
name|REG_DEAD
operator|||
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
name|REG_UNUSED
operator|)
comment|/* Verify that the REG_NOTE has a valid value.  */
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
specifier|register
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|reg_weight
operator|--
expr_stmt|;
comment|/* Only unlink REG_DEAD notes; leave REG_UNUSED notes 		     alone.  */
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
name|REG_DEAD
condition|)
block|{
if|if
condition|(
name|prev
condition|)
name|XEXP
argument_list|(
name|prev
argument_list|,
literal|1
argument_list|)
operator|=
name|next
expr_stmt|;
else|else
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|next
expr_stmt|;
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
operator|=
name|dead_notes
expr_stmt|;
name|dead_notes
operator|=
name|link
expr_stmt|;
block|}
else|else
name|prev
operator|=
name|link
expr_stmt|;
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|int
name|j
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
operator|--
name|j
operator|>=
literal|0
condition|)
block|{
name|CLEAR_REGNO_REG_SET
argument_list|(
name|bb_live_regs
argument_list|,
name|regno
operator|+
name|j
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|CLEAR_REGNO_REG_SET
argument_list|(
name|bb_live_regs
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|prev
operator|=
name|link
expr_stmt|;
block|}
block|}
name|INSN_REG_WEIGHT
argument_list|(
name|insn
argument_list|)
operator|=
name|reg_weight
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Update register life and usage information for block bb    after scheduling.  Put register dead notes back in the code.  */
end_comment

begin_function
specifier|static
name|void
name|find_post_sched_live
parameter_list|(
name|bb
parameter_list|)
name|int
name|bb
decl_stmt|;
block|{
name|int
name|sometimes_max
decl_stmt|;
name|int
name|j
decl_stmt|,
name|i
decl_stmt|;
name|int
name|b
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|rtx
name|head
decl_stmt|,
name|tail
decl_stmt|,
name|prev_head
decl_stmt|,
name|next_tail
decl_stmt|;
specifier|register
name|struct
name|sometimes
modifier|*
name|regs_sometimes_live
decl_stmt|;
name|b
operator|=
name|BB_TO_BLOCK
argument_list|(
name|bb
argument_list|)
expr_stmt|;
comment|/* compute live regs at the end of bb as a function of its successors.  */
if|if
condition|(
name|current_nr_blocks
operator|>
literal|1
condition|)
block|{
name|int
name|e
decl_stmt|;
name|int
name|first_edge
decl_stmt|;
name|first_edge
operator|=
name|e
operator|=
name|OUT_EDGES
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|CLEAR_REG_SET
argument_list|(
name|bb_live_regs
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
condition|)
do|do
block|{
name|int
name|b_succ
decl_stmt|;
name|b_succ
operator|=
name|TO_BLOCK
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|IOR_REG_SET
argument_list|(
name|bb_live_regs
argument_list|,
name|BASIC_BLOCK
argument_list|(
name|b_succ
argument_list|)
operator|->
name|global_live_at_start
argument_list|)
expr_stmt|;
name|e
operator|=
name|NEXT_OUT
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|e
operator|!=
name|first_edge
condition|)
do|;
block|}
name|get_block_head_tail
argument_list|(
name|bb
argument_list|,
operator|&
name|head
argument_list|,
operator|&
name|tail
argument_list|)
expr_stmt|;
name|next_tail
operator|=
name|NEXT_INSN
argument_list|(
name|tail
argument_list|)
expr_stmt|;
name|prev_head
operator|=
name|PREV_INSN
argument_list|(
name|head
argument_list|)
expr_stmt|;
name|EXECUTE_IF_SET_IN_REG_SET
argument_list|(
argument|bb_live_regs
argument_list|,
argument|FIRST_PSEUDO_REGISTER
argument_list|,
argument|i
argument_list|,
argument|{ 			       sched_reg_basic_block[i] = REG_BLOCK_GLOBAL; 			     }
argument_list|)
empty_stmt|;
comment|/* if the block is empty, same regs are alive at its end and its start.      since this is not guaranteed after interblock scheduling, make sure they      are truly identical.  */
if|if
condition|(
name|NEXT_INSN
argument_list|(
name|prev_head
argument_list|)
operator|==
name|tail
operator|&&
operator|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|tail
argument_list|)
argument_list|)
operator|!=
literal|'i'
operator|)
condition|)
block|{
if|if
condition|(
name|current_nr_blocks
operator|>
literal|1
condition|)
name|COPY_REG_SET
argument_list|(
name|BASIC_BLOCK
argument_list|(
name|b
argument_list|)
operator|->
name|global_live_at_start
argument_list|,
name|bb_live_regs
argument_list|)
expr_stmt|;
return|return;
block|}
name|b
operator|=
name|BB_TO_BLOCK
argument_list|(
name|bb
argument_list|)
expr_stmt|;
name|current_block_num
operator|=
name|b
expr_stmt|;
comment|/* Keep track of register lives.  */
name|old_live_regs
operator|=
name|ALLOCA_REG_SET
argument_list|()
expr_stmt|;
name|regs_sometimes_live
operator|=
operator|(
expr|struct
name|sometimes
operator|*
operator|)
name|alloca
argument_list|(
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sometimes
argument_list|)
argument_list|)
expr_stmt|;
name|sometimes_max
operator|=
literal|0
expr_stmt|;
comment|/* initiate "sometimes" data, starting with registers live at end */
name|sometimes_max
operator|=
literal|0
expr_stmt|;
name|COPY_REG_SET
argument_list|(
name|old_live_regs
argument_list|,
name|bb_live_regs
argument_list|)
expr_stmt|;
name|EXECUTE_IF_SET_IN_REG_SET
argument_list|(
argument|bb_live_regs
argument_list|,
literal|0
argument_list|,
argument|j
argument_list|,
argument|{ 			       sometimes_max 				 = new_sometimes_live (regs_sometimes_live, 						       j, sometimes_max); 			     }
argument_list|)
empty_stmt|;
comment|/* scan insns back, computing regs live info */
for|for
control|(
name|insn
operator|=
name|tail
init|;
name|insn
operator|!=
name|prev_head
condition|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
comment|/* First we kill registers set by this insn, and then we          make registers used by this insn live.  This is the opposite          order used above because we are traversing the instructions          backwards.  */
comment|/* Strictly speaking, we should scan REG_UNUSED notes and make          every register mentioned there live, however, we will just          kill them again immediately below, so there doesn't seem to          be any reason why we bother to do this.  */
comment|/* See if this is the last notice we must take of a register.  */
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
literal|'i'
condition|)
continue|continue;
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|CLOBBER
condition|)
name|sched_note_set
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
argument_list|)
operator|==
name|SET
operator|||
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
argument_list|)
operator|==
name|CLOBBER
condition|)
name|sched_note_set
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* This code keeps life analysis information up to date.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
specifier|register
name|struct
name|sometimes
modifier|*
name|p
decl_stmt|;
comment|/* A call kills all call used registers that are not 	     global or fixed, except for those mentioned in the call 	     pattern which will be made live again later.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|call_used_regs
index|[
name|i
index|]
operator|&&
operator|!
name|global_regs
index|[
name|i
index|]
operator|&&
operator|!
name|fixed_regs
index|[
name|i
index|]
condition|)
block|{
name|CLEAR_REGNO_REG_SET
argument_list|(
name|bb_live_regs
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
comment|/* Regs live at the time of a call instruction must not 	     go in a register clobbered by calls.  Record this for 	     all regs now live.  Note that insns which are born or 	     die in a call do not cross a call, so this must be done 	     after the killings (above) and before the births 	     (below).  */
name|p
operator|=
name|regs_sometimes_live
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sometimes_max
condition|;
name|i
operator|++
operator|,
name|p
operator|++
control|)
if|if
condition|(
name|REGNO_REG_SET_P
argument_list|(
name|bb_live_regs
argument_list|,
name|p
operator|->
name|regno
argument_list|)
condition|)
name|p
operator|->
name|calls_crossed
operator|+=
literal|1
expr_stmt|;
block|}
comment|/* Make every register used live, and add REG_DEAD notes for          registers which were not live before we started.  */
name|attach_deaths_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Find registers now made live by that instruction.  */
name|EXECUTE_IF_AND_COMPL_IN_REG_SET
argument_list|(
argument|bb_live_regs
argument_list|,
argument|old_live_regs
argument_list|,
literal|0
argument_list|,
argument|j
argument_list|,
argument|{ 				   sometimes_max 				     = new_sometimes_live (regs_sometimes_live, 							   j, sometimes_max); 				 }
argument_list|)
empty_stmt|;
name|IOR_REG_SET
argument_list|(
name|old_live_regs
argument_list|,
name|bb_live_regs
argument_list|)
expr_stmt|;
comment|/* Count lengths of all regs we are worrying about now,          and handle registers no longer live.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sometimes_max
condition|;
name|i
operator|++
control|)
block|{
specifier|register
name|struct
name|sometimes
modifier|*
name|p
init|=
operator|&
name|regs_sometimes_live
index|[
name|i
index|]
decl_stmt|;
name|int
name|regno
init|=
name|p
operator|->
name|regno
decl_stmt|;
name|p
operator|->
name|live_length
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|REGNO_REG_SET_P
argument_list|(
name|bb_live_regs
argument_list|,
name|regno
argument_list|)
condition|)
block|{
comment|/* This is the end of one of this register's lifetime 	         segments.  Save the lifetime info collected so far, 	         and clear its bit in the old_live_regs entry.  */
name|sched_reg_live_length
index|[
name|regno
index|]
operator|+=
name|p
operator|->
name|live_length
expr_stmt|;
name|sched_reg_n_calls_crossed
index|[
name|regno
index|]
operator|+=
name|p
operator|->
name|calls_crossed
expr_stmt|;
name|CLEAR_REGNO_REG_SET
argument_list|(
name|old_live_regs
argument_list|,
name|p
operator|->
name|regno
argument_list|)
expr_stmt|;
comment|/* Delete the reg_sometimes_live entry for this reg by 	         copying the last entry over top of it.  */
operator|*
name|p
operator|=
name|regs_sometimes_live
index|[
operator|--
name|sometimes_max
index|]
expr_stmt|;
comment|/* ...and decrement i so that this newly copied entry 	         will be processed.  */
name|i
operator|--
expr_stmt|;
block|}
block|}
block|}
name|finish_sometimes_live
argument_list|(
name|regs_sometimes_live
argument_list|,
name|sometimes_max
argument_list|)
expr_stmt|;
comment|/* In interblock scheduling, global_live_at_start may have changed.  */
if|if
condition|(
name|current_nr_blocks
operator|>
literal|1
condition|)
name|COPY_REG_SET
argument_list|(
name|BASIC_BLOCK
argument_list|(
name|b
argument_list|)
operator|->
name|global_live_at_start
argument_list|,
name|bb_live_regs
argument_list|)
expr_stmt|;
name|FREE_REG_SET
argument_list|(
name|old_live_regs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* find_post_sched_live */
end_comment

begin_comment
comment|/* After scheduling the subroutine, restore information about uses of    registers.  */
end_comment

begin_function
specifier|static
name|void
name|update_reg_usage
parameter_list|()
block|{
name|int
name|regno
decl_stmt|;
if|if
condition|(
name|n_basic_blocks
operator|>
literal|0
condition|)
name|EXECUTE_IF_SET_IN_REG_SET
argument_list|(
argument|bb_live_regs
argument_list|,
argument|FIRST_PSEUDO_REGISTER
argument_list|,
argument|regno
argument_list|,
argument|{ 				 sched_reg_basic_block[regno] 				   = REG_BLOCK_GLOBAL; 			       }
argument_list|)
empty_stmt|;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|max_regno
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|sched_reg_live_length
index|[
name|regno
index|]
condition|)
block|{
if|if
condition|(
name|sched_verbose
condition|)
block|{
if|if
condition|(
name|REG_LIVE_LENGTH
argument_list|(
name|regno
argument_list|)
operator|>
name|sched_reg_live_length
index|[
name|regno
index|]
condition|)
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|";; register %d life shortened from %d to %d\n"
argument_list|,
name|regno
argument_list|,
name|REG_LIVE_LENGTH
argument_list|(
name|regno
argument_list|)
argument_list|,
name|sched_reg_live_length
index|[
name|regno
index|]
argument_list|)
expr_stmt|;
comment|/* Negative values are special; don't overwrite the current 	       reg_live_length value if it is negative.  */
elseif|else
if|if
condition|(
name|REG_LIVE_LENGTH
argument_list|(
name|regno
argument_list|)
operator|<
name|sched_reg_live_length
index|[
name|regno
index|]
operator|&&
name|REG_LIVE_LENGTH
argument_list|(
name|regno
argument_list|)
operator|>=
literal|0
condition|)
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|";; register %d life extended from %d to %d\n"
argument_list|,
name|regno
argument_list|,
name|REG_LIVE_LENGTH
argument_list|(
name|regno
argument_list|)
argument_list|,
name|sched_reg_live_length
index|[
name|regno
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|REG_N_CALLS_CROSSED
argument_list|(
name|regno
argument_list|)
operator|&&
name|sched_reg_n_calls_crossed
index|[
name|regno
index|]
condition|)
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|";; register %d now crosses calls\n"
argument_list|,
name|regno
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|REG_N_CALLS_CROSSED
argument_list|(
name|regno
argument_list|)
operator|&&
operator|!
name|sched_reg_n_calls_crossed
index|[
name|regno
index|]
operator|&&
name|REG_BASIC_BLOCK
argument_list|(
name|regno
argument_list|)
operator|!=
name|REG_BLOCK_GLOBAL
condition|)
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|";; register %d no longer crosses calls\n"
argument_list|,
name|regno
argument_list|)
expr_stmt|;
if|if
condition|(
name|REG_BASIC_BLOCK
argument_list|(
name|regno
argument_list|)
operator|!=
name|sched_reg_basic_block
index|[
name|regno
index|]
operator|&&
name|sched_reg_basic_block
index|[
name|regno
index|]
operator|!=
name|REG_BLOCK_UNKNOWN
operator|&&
name|REG_BASIC_BLOCK
argument_list|(
name|regno
argument_list|)
operator|!=
name|REG_BLOCK_UNKNOWN
condition|)
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|";; register %d changed basic block from %d to %d\n"
argument_list|,
name|regno
argument_list|,
name|REG_BASIC_BLOCK
argument_list|(
name|regno
argument_list|)
argument_list|,
name|sched_reg_basic_block
index|[
name|regno
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Negative values are special; don't overwrite the current 	   reg_live_length value if it is negative.  */
if|if
condition|(
name|REG_LIVE_LENGTH
argument_list|(
name|regno
argument_list|)
operator|>=
literal|0
condition|)
name|REG_LIVE_LENGTH
argument_list|(
name|regno
argument_list|)
operator|=
name|sched_reg_live_length
index|[
name|regno
index|]
expr_stmt|;
if|if
condition|(
name|sched_reg_basic_block
index|[
name|regno
index|]
operator|!=
name|REG_BLOCK_UNKNOWN
operator|&&
name|REG_BASIC_BLOCK
argument_list|(
name|regno
argument_list|)
operator|!=
name|REG_BLOCK_UNKNOWN
condition|)
name|REG_BASIC_BLOCK
argument_list|(
name|regno
argument_list|)
operator|=
name|sched_reg_basic_block
index|[
name|regno
index|]
expr_stmt|;
comment|/* We can't change the value of reg_n_calls_crossed to zero for 	   pseudos which are live in more than one block.  	   This is because combine might have made an optimization which 	   invalidated global_live_at_start and reg_n_calls_crossed, 	   but it does not update them.  If we update reg_n_calls_crossed 	   here, the two variables are now inconsistent, and this might 	   confuse the caller-save code into saving a register that doesn't 	   need to be saved.  This is only a problem when we zero calls 	   crossed for a pseudo live in multiple basic blocks.  	   Alternatively, we could try to correctly update basic block live 	   at start here in sched, but that seems complicated.  	   Note: it is possible that a global register became local, as result 	   of interblock motion, but will remain marked as a global register.  */
if|if
condition|(
name|sched_reg_n_calls_crossed
index|[
name|regno
index|]
operator|||
name|REG_BASIC_BLOCK
argument_list|(
name|regno
argument_list|)
operator|!=
name|REG_BLOCK_GLOBAL
condition|)
name|REG_N_CALLS_CROSSED
argument_list|(
name|regno
argument_list|)
operator|=
name|sched_reg_n_calls_crossed
index|[
name|regno
index|]
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Scheduling clock, modified in schedule_block() and queue_to_ready () */
end_comment

begin_decl_stmt
specifier|static
name|int
name|clock_var
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Move insns that became ready to fire from queue to ready list.  */
end_comment

begin_function
specifier|static
name|int
name|queue_to_ready
parameter_list|(
name|ready
parameter_list|,
name|n_ready
parameter_list|)
name|rtx
name|ready
index|[]
decl_stmt|;
name|int
name|n_ready
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|;
name|rtx
name|link
decl_stmt|;
name|q_ptr
operator|=
name|NEXT_Q
argument_list|(
name|q_ptr
argument_list|)
expr_stmt|;
comment|/* Add all pending insns that can be scheduled without stalls to the      ready list.  */
for|for
control|(
name|link
operator|=
name|insn_queue
index|[
name|q_ptr
index|]
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|insn
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|q_size
operator|-=
literal|1
expr_stmt|;
if|if
condition|(
name|sched_verbose
operator|>=
literal|2
condition|)
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|";;\t\tQ-->Ready: insn %d: "
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sched_verbose
operator|>=
literal|2
operator|&&
name|INSN_BB
argument_list|(
name|insn
argument_list|)
operator|!=
name|target_bb
condition|)
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|"(b%d) "
argument_list|,
name|INSN_BLOCK
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|ready
index|[
name|n_ready
operator|++
index|]
operator|=
name|insn
expr_stmt|;
if|if
condition|(
name|sched_verbose
operator|>=
literal|2
condition|)
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|"moving to ready without stalls\n"
argument_list|)
expr_stmt|;
block|}
name|insn_queue
index|[
name|q_ptr
index|]
operator|=
literal|0
expr_stmt|;
comment|/* If there are no ready insns, stall until one is ready and add all      of the pending insns at that point to the ready list.  */
if|if
condition|(
name|n_ready
operator|==
literal|0
condition|)
block|{
specifier|register
name|int
name|stalls
decl_stmt|;
for|for
control|(
name|stalls
operator|=
literal|1
init|;
name|stalls
operator|<
name|INSN_QUEUE_SIZE
condition|;
name|stalls
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|link
operator|=
name|insn_queue
index|[
name|NEXT_Q_AFTER
argument_list|(
name|q_ptr
argument_list|,
name|stalls
argument_list|)
index|]
operator|)
condition|)
block|{
for|for
control|(
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|insn
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|q_size
operator|-=
literal|1
expr_stmt|;
if|if
condition|(
name|sched_verbose
operator|>=
literal|2
condition|)
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|";;\t\tQ-->Ready: insn %d: "
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sched_verbose
operator|>=
literal|2
operator|&&
name|INSN_BB
argument_list|(
name|insn
argument_list|)
operator|!=
name|target_bb
condition|)
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|"(b%d) "
argument_list|,
name|INSN_BLOCK
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|ready
index|[
name|n_ready
operator|++
index|]
operator|=
name|insn
expr_stmt|;
if|if
condition|(
name|sched_verbose
operator|>=
literal|2
condition|)
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|"moving to ready with %d stalls\n"
argument_list|,
name|stalls
argument_list|)
expr_stmt|;
block|}
name|insn_queue
index|[
name|NEXT_Q_AFTER
argument_list|(
name|q_ptr
argument_list|,
name|stalls
argument_list|)
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|n_ready
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|sched_verbose
operator|&&
name|stalls
condition|)
name|visualize_stall_cycles
argument_list|(
name|BB_TO_BLOCK
argument_list|(
name|target_bb
argument_list|)
argument_list|,
name|stalls
argument_list|)
expr_stmt|;
name|q_ptr
operator|=
name|NEXT_Q_AFTER
argument_list|(
name|q_ptr
argument_list|,
name|stalls
argument_list|)
expr_stmt|;
name|clock_var
operator|+=
name|stalls
expr_stmt|;
block|}
return|return
name|n_ready
return|;
block|}
end_function

begin_comment
comment|/* Print the ready list for debugging purposes. Callable from debugger.  */
end_comment

begin_function
specifier|static
name|void
name|debug_ready_list
parameter_list|(
name|ready
parameter_list|,
name|n_ready
parameter_list|)
name|rtx
name|ready
index|[]
decl_stmt|;
name|int
name|n_ready
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_ready
condition|;
name|i
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|"  %d"
argument_list|,
name|INSN_UID
argument_list|(
name|ready
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_nr_blocks
operator|>
literal|1
operator|&&
name|INSN_BB
argument_list|(
name|ready
index|[
name|i
index|]
argument_list|)
operator|!=
name|target_bb
condition|)
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|"/b%d"
argument_list|,
name|INSN_BLOCK
argument_list|(
name|ready
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print names of units on which insn can/should execute, for debugging.  */
end_comment

begin_function
specifier|static
name|void
name|insn_print_units
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|unit
init|=
name|insn_unit
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|unit
operator|==
operator|-
literal|1
condition|)
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|"none"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|unit
operator|>=
literal|0
condition|)
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|"%s"
argument_list|,
name|function_units
index|[
name|unit
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
else|else
block|{
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|"["
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|unit
operator|=
operator|~
name|unit
init|;
name|unit
condition|;
name|i
operator|++
operator|,
name|unit
operator|>>=
literal|1
control|)
if|if
condition|(
name|unit
operator|&
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|"%s"
argument_list|,
name|function_units
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|!=
literal|1
condition|)
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|"]"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* MAX_VISUAL_LINES is the maximum number of lines in visualization table    of a basic block.  If more lines are needed, table is splitted to two.    n_visual_lines is the number of lines printed so far for a block.    visual_tbl contains the block visualization info.    vis_no_unit holds insns in a cycle that are not mapped to any unit.  */
end_comment

begin_define
define|#
directive|define
name|MAX_VISUAL_LINES
value|100
end_define

begin_define
define|#
directive|define
name|INSN_LEN
value|30
end_define

begin_decl_stmt
name|int
name|n_visual_lines
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|visual_tbl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|n_vis_no_unit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|vis_no_unit
index|[
literal|10
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Finds units that are in use in this fuction. Required only    for visualization.  */
end_comment

begin_function
specifier|static
name|void
name|init_target_units
parameter_list|()
block|{
name|rtx
name|insn
decl_stmt|;
name|int
name|unit
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|get_last_insn
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
literal|'i'
condition|)
continue|continue;
name|unit
operator|=
name|insn_unit
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|<
literal|0
condition|)
name|target_units
operator||=
operator|~
name|unit
expr_stmt|;
else|else
name|target_units
operator||=
operator|(
literal|1
operator|<<
name|unit
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return the length of the visualization table */
end_comment

begin_function
specifier|static
name|int
name|get_visual_tbl_length
parameter_list|()
block|{
name|int
name|unit
decl_stmt|,
name|i
decl_stmt|;
name|int
name|n
decl_stmt|,
name|n1
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
comment|/* compute length of one field in line */
name|s
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|INSN_LEN
operator|+
literal|5
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|s
argument_list|,
literal|"  %33s"
argument_list|,
literal|"uname"
argument_list|)
expr_stmt|;
name|n1
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* compute length of one line */
name|n
operator|=
name|strlen
argument_list|(
literal|";; "
argument_list|)
expr_stmt|;
name|n
operator|+=
name|n1
expr_stmt|;
for|for
control|(
name|unit
operator|=
literal|0
init|;
name|unit
operator|<
name|FUNCTION_UNITS_SIZE
condition|;
name|unit
operator|++
control|)
if|if
condition|(
name|function_units
index|[
name|unit
index|]
operator|.
name|bitmask
operator|&
name|target_units
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|function_units
index|[
name|unit
index|]
operator|.
name|multiplicity
condition|;
name|i
operator|++
control|)
name|n
operator|+=
name|n1
expr_stmt|;
name|n
operator|+=
name|n1
expr_stmt|;
name|n
operator|+=
name|strlen
argument_list|(
literal|"\n"
argument_list|)
operator|+
literal|2
expr_stmt|;
comment|/* compute length of visualization string */
return|return
operator|(
name|MAX_VISUAL_LINES
operator|*
name|n
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Init block visualization debugging info */
end_comment

begin_function
specifier|static
name|void
name|init_block_visualization
parameter_list|()
block|{
name|strcpy
argument_list|(
name|visual_tbl
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|n_visual_lines
operator|=
literal|0
expr_stmt|;
name|n_vis_no_unit
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|BUF_LEN
value|256
end_define

begin_function
specifier|static
name|char
modifier|*
name|safe_concat
parameter_list|(
name|buf
parameter_list|,
name|cur
parameter_list|,
name|str
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
name|char
modifier|*
name|cur
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|char
modifier|*
name|end
init|=
name|buf
operator|+
name|BUF_LEN
operator|-
literal|2
decl_stmt|;
comment|/* leave room for null */
name|int
name|c
decl_stmt|;
if|if
condition|(
name|cur
operator|>
name|end
condition|)
block|{
operator|*
name|end
operator|=
literal|'\0'
expr_stmt|;
return|return
name|end
return|;
block|}
while|while
condition|(
name|cur
operator|<
name|end
operator|&&
operator|(
name|c
operator|=
operator|*
name|str
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
operator|*
name|cur
operator|++
operator|=
name|c
expr_stmt|;
operator|*
name|cur
operator|=
literal|'\0'
expr_stmt|;
return|return
name|cur
return|;
block|}
end_function

begin_comment
comment|/* This recognizes rtx, I classified as expressions. These are always */
end_comment

begin_comment
comment|/* represent some action on values or results of other expression, */
end_comment

begin_comment
comment|/* that may be stored in objects representing values.  */
end_comment

begin_function
specifier|static
name|void
name|print_exp
parameter_list|(
name|buf
parameter_list|,
name|x
parameter_list|,
name|verbose
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|int
name|verbose
decl_stmt|;
block|{
name|char
name|tmp
index|[
name|BUF_LEN
index|]
decl_stmt|;
name|char
modifier|*
name|st
index|[
literal|4
index|]
decl_stmt|;
name|char
modifier|*
name|cur
init|=
name|buf
decl_stmt|;
name|char
modifier|*
name|fun
init|=
operator|(
name|char
operator|*
operator|)
literal|0
decl_stmt|;
name|char
modifier|*
name|sep
decl_stmt|;
name|rtx
name|op
index|[
literal|4
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|st
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
name|op
index|[
name|i
index|]
operator|=
name|NULL_RTX
expr_stmt|;
block|}
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|PLUS
case|:
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|st
index|[
literal|1
index|]
operator|=
literal|"-"
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|GEN_INT
argument_list|(
operator|-
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|st
index|[
literal|1
index|]
operator|=
literal|"+"
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|LO_SUM
case|:
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|st
index|[
literal|1
index|]
operator|=
literal|"+low("
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|st
index|[
literal|2
index|]
operator|=
literal|")"
expr_stmt|;
break|break;
case|case
name|MINUS
case|:
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|st
index|[
literal|1
index|]
operator|=
literal|"-"
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|COMPARE
case|:
name|fun
operator|=
literal|"cmp"
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|NEG
case|:
name|st
index|[
literal|0
index|]
operator|=
literal|"-"
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|MULT
case|:
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|st
index|[
literal|1
index|]
operator|=
literal|"*"
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIV
case|:
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|st
index|[
literal|1
index|]
operator|=
literal|"/"
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|UDIV
case|:
name|fun
operator|=
literal|"udiv"
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOD
case|:
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|st
index|[
literal|1
index|]
operator|=
literal|"%"
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|UMOD
case|:
name|fun
operator|=
literal|"umod"
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|SMIN
case|:
name|fun
operator|=
literal|"smin"
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|SMAX
case|:
name|fun
operator|=
literal|"smax"
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|UMIN
case|:
name|fun
operator|=
literal|"umin"
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|UMAX
case|:
name|fun
operator|=
literal|"umax"
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|NOT
case|:
name|st
index|[
literal|0
index|]
operator|=
literal|"!"
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|AND
case|:
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|st
index|[
literal|1
index|]
operator|=
literal|"&"
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|IOR
case|:
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|st
index|[
literal|1
index|]
operator|=
literal|"|"
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|XOR
case|:
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|st
index|[
literal|1
index|]
operator|=
literal|"^"
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|ASHIFT
case|:
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|st
index|[
literal|1
index|]
operator|=
literal|"<<"
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|LSHIFTRT
case|:
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|st
index|[
literal|1
index|]
operator|=
literal|" 0>>"
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|ASHIFTRT
case|:
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|st
index|[
literal|1
index|]
operator|=
literal|">>"
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|ROTATE
case|:
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|st
index|[
literal|1
index|]
operator|=
literal|"<-<"
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|ROTATERT
case|:
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|st
index|[
literal|1
index|]
operator|=
literal|">->"
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|ABS
case|:
name|fun
operator|=
literal|"abs"
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|SQRT
case|:
name|fun
operator|=
literal|"sqrt"
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFS
case|:
name|fun
operator|=
literal|"ffs"
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|EQ
case|:
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|st
index|[
literal|1
index|]
operator|=
literal|"=="
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|NE
case|:
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|st
index|[
literal|1
index|]
operator|=
literal|"!="
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|GT
case|:
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|st
index|[
literal|1
index|]
operator|=
literal|">"
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|GTU
case|:
name|fun
operator|=
literal|"gtu"
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|LT
case|:
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|st
index|[
literal|1
index|]
operator|=
literal|"<"
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|LTU
case|:
name|fun
operator|=
literal|"ltu"
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|GE
case|:
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|st
index|[
literal|1
index|]
operator|=
literal|">="
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|GEU
case|:
name|fun
operator|=
literal|"geu"
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|LE
case|:
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|st
index|[
literal|1
index|]
operator|=
literal|"<="
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|LEU
case|:
name|fun
operator|=
literal|"leu"
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIGN_EXTRACT
case|:
name|fun
operator|=
operator|(
name|verbose
operator|)
condition|?
literal|"sign_extract"
else|:
literal|"sxt"
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|op
index|[
literal|2
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZERO_EXTRACT
case|:
name|fun
operator|=
operator|(
name|verbose
operator|)
condition|?
literal|"zero_extract"
else|:
literal|"zxt"
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|op
index|[
literal|2
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIGN_EXTEND
case|:
name|fun
operator|=
operator|(
name|verbose
operator|)
condition|?
literal|"sign_extend"
else|:
literal|"sxn"
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZERO_EXTEND
case|:
name|fun
operator|=
operator|(
name|verbose
operator|)
condition|?
literal|"zero_extend"
else|:
literal|"zxn"
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|FLOAT_EXTEND
case|:
name|fun
operator|=
operator|(
name|verbose
operator|)
condition|?
literal|"float_extend"
else|:
literal|"fxn"
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|TRUNCATE
case|:
name|fun
operator|=
operator|(
name|verbose
operator|)
condition|?
literal|"trunc"
else|:
literal|"trn"
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|FLOAT_TRUNCATE
case|:
name|fun
operator|=
operator|(
name|verbose
operator|)
condition|?
literal|"float_trunc"
else|:
literal|"ftr"
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|FLOAT
case|:
name|fun
operator|=
operator|(
name|verbose
operator|)
condition|?
literal|"float"
else|:
literal|"flt"
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNSIGNED_FLOAT
case|:
name|fun
operator|=
operator|(
name|verbose
operator|)
condition|?
literal|"uns_float"
else|:
literal|"ufl"
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|FIX
case|:
name|fun
operator|=
literal|"fix"
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNSIGNED_FIX
case|:
name|fun
operator|=
operator|(
name|verbose
operator|)
condition|?
literal|"uns_fix"
else|:
literal|"ufx"
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRE_DEC
case|:
name|st
index|[
literal|0
index|]
operator|=
literal|"--"
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRE_INC
case|:
name|st
index|[
literal|0
index|]
operator|=
literal|"++"
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|POST_DEC
case|:
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|st
index|[
literal|1
index|]
operator|=
literal|"--"
expr_stmt|;
break|break;
case|case
name|POST_INC
case|:
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|st
index|[
literal|1
index|]
operator|=
literal|"++"
expr_stmt|;
break|break;
case|case
name|CALL
case|:
name|st
index|[
literal|0
index|]
operator|=
literal|"call "
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
block|{
name|st
index|[
literal|1
index|]
operator|=
literal|" argc:"
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|IF_THEN_ELSE
case|:
name|st
index|[
literal|0
index|]
operator|=
literal|"{("
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|st
index|[
literal|1
index|]
operator|=
literal|")?"
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|st
index|[
literal|2
index|]
operator|=
literal|":"
expr_stmt|;
name|op
index|[
literal|2
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|st
index|[
literal|3
index|]
operator|=
literal|"}"
expr_stmt|;
break|break;
case|case
name|TRAP_IF
case|:
name|fun
operator|=
literal|"trap_if"
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|TRAP_CONDITION
argument_list|(
name|x
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNSPEC
case|:
case|case
name|UNSPEC_VOLATILE
case|:
block|{
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
literal|"unspec"
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|UNSPEC_VOLATILE
condition|)
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
literal|"/v"
argument_list|)
expr_stmt|;
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
literal|"["
argument_list|)
expr_stmt|;
name|sep
operator|=
literal|""
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|print_pattern
argument_list|(
name|tmp
argument_list|,
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
name|sep
argument_list|)
expr_stmt|;
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|sep
operator|=
literal|","
expr_stmt|;
block|}
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
literal|"] "
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"%d"
argument_list|,
name|XINT
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
comment|/* if (verbose) debug_rtx (x); */
name|st
index|[
literal|0
index|]
operator|=
name|GET_RTX_NAME
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Print this as a function? */
if|if
condition|(
name|fun
condition|)
block|{
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
name|fun
argument_list|)
expr_stmt|;
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|st
index|[
name|i
index|]
condition|)
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
name|st
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
index|[
name|i
index|]
condition|)
block|{
if|if
condition|(
name|fun
operator|&&
name|i
operator|!=
literal|0
condition|)
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
literal|","
argument_list|)
expr_stmt|;
name|print_value
argument_list|(
name|tmp
argument_list|,
name|op
index|[
name|i
index|]
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fun
condition|)
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* print_exp */
end_comment

begin_comment
comment|/* Prints rtxes, i customly classified as values. They're constants, */
end_comment

begin_comment
comment|/* registers, labels, symbols and memory accesses.  */
end_comment

begin_function
specifier|static
name|void
name|print_value
parameter_list|(
name|buf
parameter_list|,
name|x
parameter_list|,
name|verbose
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|int
name|verbose
decl_stmt|;
block|{
name|char
name|t
index|[
name|BUF_LEN
index|]
decl_stmt|;
name|char
modifier|*
name|cur
init|=
name|buf
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|CONST_INT
case|:
name|sprintf
argument_list|(
name|t
argument_list|,
name|HOST_WIDE_INT_PRINT_HEX
argument_list|,
name|INTVAL
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONST_DOUBLE
case|:
name|sprintf
argument_list|(
name|t
argument_list|,
literal|"<0x%lx,0x%lx>"
argument_list|,
operator|(
name|long
operator|)
name|XWINT
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|XWINT
argument_list|(
name|x
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONST_STRING
case|:
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
literal|"\""
argument_list|)
expr_stmt|;
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
literal|"\""
argument_list|)
expr_stmt|;
break|break;
case|case
name|SYMBOL_REF
case|:
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
literal|"`"
argument_list|)
expr_stmt|;
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
literal|"'"
argument_list|)
expr_stmt|;
break|break;
case|case
name|LABEL_REF
case|:
name|sprintf
argument_list|(
name|t
argument_list|,
literal|"L%d"
argument_list|,
name|INSN_UID
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONST
case|:
name|print_value
argument_list|(
name|t
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
literal|"const("
argument_list|)
expr_stmt|;
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|HIGH
case|:
name|print_value
argument_list|(
name|t
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
literal|"high("
argument_list|)
expr_stmt|;
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|REG
case|:
if|if
condition|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|int
name|c
init|=
name|reg_names
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
index|[
literal|0
index|]
decl_stmt|;
if|if
condition|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
literal|"%"
argument_list|)
expr_stmt|;
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|t
argument_list|,
literal|"r%d"
argument_list|,
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SUBREG
case|:
name|print_value
argument_list|(
name|t
argument_list|,
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|t
argument_list|,
literal|"#%d"
argument_list|,
name|SUBREG_WORD
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCRATCH
case|:
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
literal|"scratch"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CC0
case|:
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
literal|"cc0"
argument_list|)
expr_stmt|;
break|break;
case|case
name|PC
case|:
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
literal|"pc"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEM
case|:
name|print_value
argument_list|(
name|t
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
literal|"["
argument_list|)
expr_stmt|;
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
literal|"]"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|print_exp
argument_list|(
name|t
argument_list|,
name|x
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* print_value */
end_comment

begin_comment
comment|/* The next step in insn detalization, its pattern recognition */
end_comment

begin_function
specifier|static
name|void
name|print_pattern
parameter_list|(
name|buf
parameter_list|,
name|x
parameter_list|,
name|verbose
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|int
name|verbose
decl_stmt|;
block|{
name|char
name|t1
index|[
name|BUF_LEN
index|]
decl_stmt|,
name|t2
index|[
name|BUF_LEN
index|]
decl_stmt|,
name|t3
index|[
name|BUF_LEN
index|]
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|SET
case|:
name|print_value
argument_list|(
name|t1
argument_list|,
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
name|print_value
argument_list|(
name|t2
argument_list|,
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s=%s"
argument_list|,
name|t1
argument_list|,
name|t2
argument_list|)
expr_stmt|;
break|break;
case|case
name|RETURN
case|:
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"return"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CALL
case|:
name|print_exp
argument_list|(
name|buf
argument_list|,
name|x
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
break|break;
case|case
name|CLOBBER
case|:
name|print_value
argument_list|(
name|t1
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"clobber %s"
argument_list|,
name|t1
argument_list|)
expr_stmt|;
break|break;
case|case
name|USE
case|:
name|print_value
argument_list|(
name|t1
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"use %s"
argument_list|,
name|t1
argument_list|)
expr_stmt|;
break|break;
case|case
name|PARALLEL
case|:
block|{
name|int
name|i
decl_stmt|;
name|sprintf
argument_list|(
name|t1
argument_list|,
literal|"{"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|print_pattern
argument_list|(
name|t2
argument_list|,
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|t3
argument_list|,
literal|"%s%s;"
argument_list|,
name|t1
argument_list|,
name|t2
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|t1
argument_list|,
name|t3
argument_list|)
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s}"
argument_list|,
name|t1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SEQUENCE
case|:
block|{
name|int
name|i
decl_stmt|;
name|sprintf
argument_list|(
name|t1
argument_list|,
literal|"%%{"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|print_insn
argument_list|(
name|t2
argument_list|,
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|t3
argument_list|,
literal|"%s%s;"
argument_list|,
name|t1
argument_list|,
name|t2
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|t1
argument_list|,
name|t3
argument_list|)
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s%%}"
argument_list|,
name|t1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ASM_INPUT
case|:
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"asm {%s}"
argument_list|,
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ADDR_VEC
case|:
break|break;
case|case
name|ADDR_DIFF_VEC
case|:
name|print_value
argument_list|(
name|buf
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
break|break;
case|case
name|TRAP_IF
case|:
name|print_value
argument_list|(
name|t1
argument_list|,
name|TRAP_CONDITION
argument_list|(
name|x
argument_list|)
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"trap_if %s"
argument_list|,
name|t1
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNSPEC
case|:
block|{
name|int
name|i
decl_stmt|;
name|sprintf
argument_list|(
name|t1
argument_list|,
literal|"unspec{"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|print_pattern
argument_list|(
name|t2
argument_list|,
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|t3
argument_list|,
literal|"%s%s;"
argument_list|,
name|t1
argument_list|,
name|t2
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|t1
argument_list|,
name|t3
argument_list|)
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s}"
argument_list|,
name|t1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|UNSPEC_VOLATILE
case|:
block|{
name|int
name|i
decl_stmt|;
name|sprintf
argument_list|(
name|t1
argument_list|,
literal|"unspec/v{"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|print_pattern
argument_list|(
name|t2
argument_list|,
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|t3
argument_list|,
literal|"%s%s;"
argument_list|,
name|t1
argument_list|,
name|t2
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|t1
argument_list|,
name|t3
argument_list|)
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s}"
argument_list|,
name|t1
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|print_value
argument_list|(
name|buf
argument_list|,
name|x
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* print_pattern */
end_comment

begin_comment
comment|/* This is the main function in rtl visualization mechanism. It    accepts an rtx and tries to recognize it as an insn, then prints it    properly in human readable form, resembling assembler mnemonics.  */
end_comment

begin_comment
comment|/* For every insn it prints its UID and BB the insn belongs */
end_comment

begin_comment
comment|/* too. (probably the last "option" should be extended somehow, since */
end_comment

begin_comment
comment|/* it depends now on sched.c inner variables ...) */
end_comment

begin_function
specifier|static
name|void
name|print_insn
parameter_list|(
name|buf
parameter_list|,
name|x
parameter_list|,
name|verbose
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|int
name|verbose
decl_stmt|;
block|{
name|char
name|t
index|[
name|BUF_LEN
index|]
decl_stmt|;
name|rtx
name|insn
init|=
name|x
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|INSN
case|:
name|print_pattern
argument_list|(
name|t
argument_list|,
name|PATTERN
argument_list|(
name|x
argument_list|)
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"b%d: i% 4d: %s"
argument_list|,
name|INSN_BB
argument_list|(
name|x
argument_list|)
argument_list|,
name|INSN_UID
argument_list|(
name|x
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%-4d %s"
argument_list|,
name|INSN_UID
argument_list|(
name|x
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|JUMP_INSN
case|:
name|print_pattern
argument_list|(
name|t
argument_list|,
name|PATTERN
argument_list|(
name|x
argument_list|)
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"b%d: i% 4d: jump %s"
argument_list|,
name|INSN_BB
argument_list|(
name|x
argument_list|)
argument_list|,
name|INSN_UID
argument_list|(
name|x
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%-4d %s"
argument_list|,
name|INSN_UID
argument_list|(
name|x
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|CALL_INSN
case|:
name|x
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
name|x
operator|=
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|print_pattern
argument_list|(
name|t
argument_list|,
name|x
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
block|}
else|else
name|strcpy
argument_list|(
name|t
argument_list|,
literal|"call<...>"
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"b%d: i% 4d: %s"
argument_list|,
name|INSN_BB
argument_list|(
name|insn
argument_list|)
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%-4d %s"
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|CODE_LABEL
case|:
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"L%d:"
argument_list|,
name|INSN_UID
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|BARRIER
case|:
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"i% 4d: barrier"
argument_list|,
name|INSN_UID
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|NOTE
case|:
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|x
argument_list|)
operator|>
literal|0
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%4d note \"%s\" %d"
argument_list|,
name|INSN_UID
argument_list|(
name|x
argument_list|)
argument_list|,
name|NOTE_SOURCE_FILE
argument_list|(
name|x
argument_list|)
argument_list|,
name|NOTE_LINE_NUMBER
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%4d %s"
argument_list|,
name|INSN_UID
argument_list|(
name|x
argument_list|)
argument_list|,
name|GET_NOTE_INSN_NAME
argument_list|(
name|NOTE_LINE_NUMBER
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|verbose
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"Not an INSN at all\n"
argument_list|)
expr_stmt|;
name|debug_rtx
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
else|else
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"i%-4d<What?>"
argument_list|,
name|INSN_UID
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* print_insn */
end_comment

begin_comment
comment|/* Print visualization debugging info */
end_comment

begin_function
specifier|static
name|void
name|print_block_visualization
parameter_list|(
name|b
parameter_list|,
name|s
parameter_list|)
name|int
name|b
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|int
name|unit
decl_stmt|,
name|i
decl_stmt|;
comment|/* print header */
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|"\n;;   ==================== scheduling visualization for block %d %s \n"
argument_list|,
name|b
argument_list|,
name|s
argument_list|)
expr_stmt|;
comment|/* Print names of units */
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|";;   %-8s"
argument_list|,
literal|"clock"
argument_list|)
expr_stmt|;
for|for
control|(
name|unit
operator|=
literal|0
init|;
name|unit
operator|<
name|FUNCTION_UNITS_SIZE
condition|;
name|unit
operator|++
control|)
if|if
condition|(
name|function_units
index|[
name|unit
index|]
operator|.
name|bitmask
operator|&
name|target_units
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|function_units
index|[
name|unit
index|]
operator|.
name|multiplicity
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|"  %-33s"
argument_list|,
name|function_units
index|[
name|unit
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|"  %-8s\n"
argument_list|,
literal|"no-unit"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|";;   %-8s"
argument_list|,
literal|"====="
argument_list|)
expr_stmt|;
for|for
control|(
name|unit
operator|=
literal|0
init|;
name|unit
operator|<
name|FUNCTION_UNITS_SIZE
condition|;
name|unit
operator|++
control|)
if|if
condition|(
name|function_units
index|[
name|unit
index|]
operator|.
name|bitmask
operator|&
name|target_units
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|function_units
index|[
name|unit
index|]
operator|.
name|multiplicity
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|"  %-33s"
argument_list|,
literal|"=============================="
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|"  %-8s\n"
argument_list|,
literal|"======="
argument_list|)
expr_stmt|;
comment|/* Print insns in each cycle */
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|"%s\n"
argument_list|,
name|visual_tbl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print insns in the 'no_unit' column of visualization */
end_comment

begin_function
specifier|static
name|void
name|visualize_no_unit
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|vis_no_unit
index|[
name|n_vis_no_unit
index|]
operator|=
name|insn
expr_stmt|;
name|n_vis_no_unit
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print insns scheduled in clock, for visualization.  */
end_comment

begin_function
specifier|static
name|void
name|visualize_scheduled_insns
parameter_list|(
name|b
parameter_list|,
name|clock
parameter_list|)
name|int
name|b
decl_stmt|,
name|clock
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|unit
decl_stmt|;
comment|/* if no more room, split table into two */
if|if
condition|(
name|n_visual_lines
operator|>=
name|MAX_VISUAL_LINES
condition|)
block|{
name|print_block_visualization
argument_list|(
name|b
argument_list|,
literal|"(incomplete)"
argument_list|)
expr_stmt|;
name|init_block_visualization
argument_list|()
expr_stmt|;
block|}
name|n_visual_lines
operator|++
expr_stmt|;
name|sprintf
argument_list|(
name|visual_tbl
operator|+
name|strlen
argument_list|(
name|visual_tbl
argument_list|)
argument_list|,
literal|";;   %-8d"
argument_list|,
name|clock
argument_list|)
expr_stmt|;
for|for
control|(
name|unit
operator|=
literal|0
init|;
name|unit
operator|<
name|FUNCTION_UNITS_SIZE
condition|;
name|unit
operator|++
control|)
if|if
condition|(
name|function_units
index|[
name|unit
index|]
operator|.
name|bitmask
operator|&
name|target_units
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|function_units
index|[
name|unit
index|]
operator|.
name|multiplicity
condition|;
name|i
operator|++
control|)
block|{
name|int
name|instance
init|=
name|unit
operator|+
name|i
operator|*
name|FUNCTION_UNITS_SIZE
decl_stmt|;
name|rtx
name|insn
init|=
name|unit_last_insn
index|[
name|instance
index|]
decl_stmt|;
comment|/* print insns that still keep the unit busy */
if|if
condition|(
name|insn
operator|&&
name|actual_hazard_this_instance
argument_list|(
name|unit
argument_list|,
name|instance
argument_list|,
name|insn
argument_list|,
name|clock
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|char
name|str
index|[
name|BUF_LEN
index|]
decl_stmt|;
name|print_insn
argument_list|(
name|str
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|str
index|[
name|INSN_LEN
index|]
operator|=
literal|'\0'
expr_stmt|;
name|sprintf
argument_list|(
name|visual_tbl
operator|+
name|strlen
argument_list|(
name|visual_tbl
argument_list|)
argument_list|,
literal|"  %-33s"
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
else|else
name|sprintf
argument_list|(
name|visual_tbl
operator|+
name|strlen
argument_list|(
name|visual_tbl
argument_list|)
argument_list|,
literal|"  %-33s"
argument_list|,
literal|"------------------------------"
argument_list|)
expr_stmt|;
block|}
comment|/* print insns that are not assigned to any unit */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_vis_no_unit
condition|;
name|i
operator|++
control|)
name|sprintf
argument_list|(
name|visual_tbl
operator|+
name|strlen
argument_list|(
name|visual_tbl
argument_list|)
argument_list|,
literal|"  %-8d"
argument_list|,
name|INSN_UID
argument_list|(
name|vis_no_unit
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|n_vis_no_unit
operator|=
literal|0
expr_stmt|;
name|sprintf
argument_list|(
name|visual_tbl
operator|+
name|strlen
argument_list|(
name|visual_tbl
argument_list|)
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print stalled cycles */
end_comment

begin_function
specifier|static
name|void
name|visualize_stall_cycles
parameter_list|(
name|b
parameter_list|,
name|stalls
parameter_list|)
name|int
name|b
decl_stmt|,
name|stalls
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
comment|/* if no more room, split table into two */
if|if
condition|(
name|n_visual_lines
operator|>=
name|MAX_VISUAL_LINES
condition|)
block|{
name|print_block_visualization
argument_list|(
name|b
argument_list|,
literal|"(incomplete)"
argument_list|)
expr_stmt|;
name|init_block_visualization
argument_list|()
expr_stmt|;
block|}
name|n_visual_lines
operator|++
expr_stmt|;
name|sprintf
argument_list|(
name|visual_tbl
operator|+
name|strlen
argument_list|(
name|visual_tbl
argument_list|)
argument_list|,
literal|";;       "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|stalls
condition|;
name|i
operator|++
control|)
name|sprintf
argument_list|(
name|visual_tbl
operator|+
name|strlen
argument_list|(
name|visual_tbl
argument_list|)
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|visual_tbl
operator|+
name|strlen
argument_list|(
name|visual_tbl
argument_list|)
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* move_insn1: Remove INSN from insn chain, and link it after LAST insn */
end_comment

begin_function
specifier|static
name|rtx
name|move_insn1
parameter_list|(
name|insn
parameter_list|,
name|last
parameter_list|)
name|rtx
name|insn
decl_stmt|,
name|last
decl_stmt|;
block|{
name|NEXT_INSN
argument_list|(
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|PREV_INSN
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
operator|=
name|NEXT_INSN
argument_list|(
name|last
argument_list|)
expr_stmt|;
name|PREV_INSN
argument_list|(
name|NEXT_INSN
argument_list|(
name|last
argument_list|)
argument_list|)
operator|=
name|insn
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|last
argument_list|)
operator|=
name|insn
expr_stmt|;
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
operator|=
name|last
expr_stmt|;
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Search INSN for fake REG_DEAD note pairs for NOTE_INSN_SETJMP,    NOTE_INSN_{LOOP,EHREGION}_{BEG,END}; and convert them back into    NOTEs.  The REG_DEAD note following first one is contains the saved    value for NOTE_BLOCK_NUMBER which is useful for    NOTE_INSN_EH_REGION_{BEG,END} NOTEs.  LAST is the last instruction    output by the instruction scheduler.  Return the new value of LAST.  */
end_comment

begin_function
specifier|static
name|rtx
name|reemit_notes
parameter_list|(
name|insn
parameter_list|,
name|last
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|rtx
name|last
decl_stmt|;
block|{
name|rtx
name|note
decl_stmt|,
name|retval
decl_stmt|;
name|retval
operator|=
name|last
expr_stmt|;
for|for
control|(
name|note
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|note
condition|;
name|note
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
control|)
block|{
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
operator|==
name|REG_DEAD
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|int
name|note_type
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|note_type
operator|==
name|NOTE_INSN_SETJMP
condition|)
block|{
name|retval
operator|=
name|emit_note_after
argument_list|(
name|NOTE_INSN_SETJMP
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|CONST_CALL_P
argument_list|(
name|retval
argument_list|)
operator|=
name|CONST_CALL_P
argument_list|(
name|note
argument_list|)
expr_stmt|;
name|remove_note
argument_list|(
name|insn
argument_list|,
name|note
argument_list|)
expr_stmt|;
name|note
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|note_type
operator|==
name|NOTE_INSN_RANGE_START
operator|||
name|note_type
operator|==
name|NOTE_INSN_RANGE_END
condition|)
block|{
name|last
operator|=
name|emit_note_before
argument_list|(
name|note_type
argument_list|,
name|last
argument_list|)
expr_stmt|;
name|remove_note
argument_list|(
name|insn
argument_list|,
name|note
argument_list|)
expr_stmt|;
name|note
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|NOTE_RANGE_INFO
argument_list|(
name|last
argument_list|)
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|last
operator|=
name|emit_note_before
argument_list|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|last
argument_list|)
expr_stmt|;
name|remove_note
argument_list|(
name|insn
argument_list|,
name|note
argument_list|)
expr_stmt|;
name|note
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|NOTE_BLOCK_NUMBER
argument_list|(
name|last
argument_list|)
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|remove_note
argument_list|(
name|insn
argument_list|,
name|note
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* Move INSN, and all insns which should be issued before it,    due to SCHED_GROUP_P flag.  Reemit notes if needed.     Return the last insn emitted by the scheduler, which is the    return value from the first call to reemit_notes.  */
end_comment

begin_function
specifier|static
name|rtx
name|move_insn
parameter_list|(
name|insn
parameter_list|,
name|last
parameter_list|)
name|rtx
name|insn
decl_stmt|,
name|last
decl_stmt|;
block|{
name|rtx
name|retval
init|=
name|NULL
decl_stmt|;
comment|/* If INSN has SCHED_GROUP_P set, then issue it and any other      insns with SCHED_GROUP_P set first.  */
while|while
condition|(
name|SCHED_GROUP_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|rtx
name|prev
init|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
comment|/* Move a SCHED_GROUP_P insn.  */
name|move_insn1
argument_list|(
name|insn
argument_list|,
name|last
argument_list|)
expr_stmt|;
comment|/* If this is the first call to reemit_notes, then record 	 its return value.  */
if|if
condition|(
name|retval
operator|==
name|NULL_RTX
condition|)
name|retval
operator|=
name|reemit_notes
argument_list|(
name|insn
argument_list|,
name|insn
argument_list|)
expr_stmt|;
else|else
name|reemit_notes
argument_list|(
name|insn
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|insn
operator|=
name|prev
expr_stmt|;
block|}
comment|/* Now move the first non SCHED_GROUP_P insn.  */
name|move_insn1
argument_list|(
name|insn
argument_list|,
name|last
argument_list|)
expr_stmt|;
comment|/* If this is the first call to reemit_notes, then record      its return value.  */
if|if
condition|(
name|retval
operator|==
name|NULL_RTX
condition|)
name|retval
operator|=
name|reemit_notes
argument_list|(
name|insn
argument_list|,
name|insn
argument_list|)
expr_stmt|;
else|else
name|reemit_notes
argument_list|(
name|insn
argument_list|,
name|insn
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* Return an insn which represents a SCHED_GROUP, which is    the last insn in the group.  */
end_comment

begin_function
specifier|static
name|rtx
name|group_leader
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|rtx
name|prev
decl_stmt|;
do|do
block|{
name|prev
operator|=
name|insn
expr_stmt|;
name|insn
operator|=
name|next_nonnote_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|insn
operator|&&
name|SCHED_GROUP_P
argument_list|(
name|insn
argument_list|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|CODE_LABEL
operator|)
condition|)
do|;
return|return
name|prev
return|;
block|}
end_function

begin_comment
comment|/* Use forward list scheduling to rearrange insns of block BB in region RGN,    possibly bringing insns from subsequent blocks in the same region.    Return number of insns scheduled.  */
end_comment

begin_function
specifier|static
name|int
name|schedule_block
parameter_list|(
name|bb
parameter_list|,
name|rgn_n_insns
parameter_list|)
name|int
name|bb
decl_stmt|;
name|int
name|rgn_n_insns
decl_stmt|;
block|{
comment|/* Local variables.  */
name|rtx
name|insn
decl_stmt|,
name|last
decl_stmt|;
name|rtx
modifier|*
name|ready
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|n_ready
init|=
literal|0
decl_stmt|;
name|int
name|can_issue_more
decl_stmt|;
comment|/* flow block of this bb */
name|int
name|b
init|=
name|BB_TO_BLOCK
argument_list|(
name|bb
argument_list|)
decl_stmt|;
comment|/* target_n_insns == number of insns in b before scheduling starts.      sched_target_n_insns == how many of b's insns were scheduled.      sched_n_insns == how many insns were scheduled in b */
name|int
name|target_n_insns
init|=
literal|0
decl_stmt|;
name|int
name|sched_target_n_insns
init|=
literal|0
decl_stmt|;
name|int
name|sched_n_insns
init|=
literal|0
decl_stmt|;
define|#
directive|define
name|NEED_NOTHING
value|0
define|#
directive|define
name|NEED_HEAD
value|1
define|#
directive|define
name|NEED_TAIL
value|2
name|int
name|new_needs
decl_stmt|;
comment|/* head/tail info for this block */
name|rtx
name|prev_head
decl_stmt|;
name|rtx
name|next_tail
decl_stmt|;
name|rtx
name|head
decl_stmt|;
name|rtx
name|tail
decl_stmt|;
name|int
name|bb_src
decl_stmt|;
comment|/* We used to have code to avoid getting parameters moved from hard      argument registers into pseudos.       However, it was removed when it proved to be of marginal benefit      and caused problems because schedule_block and compute_forward_dependences      had different notions of what the "head" insn was.  */
name|get_block_head_tail
argument_list|(
name|bb
argument_list|,
operator|&
name|head
argument_list|,
operator|&
name|tail
argument_list|)
expr_stmt|;
comment|/* Interblock scheduling could have moved the original head insn from this      block into a proceeding block.  This may also cause schedule_block and      compute_forward_dependences to have different notions of what the      "head" insn was.       If the interblock movement happened to make this block start with      some notes (LOOP, EH or SETJMP) before the first real insn, then      HEAD will have various special notes attached to it which must be      removed so that we don't end up with extra copies of the notes.  */
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|head
argument_list|)
argument_list|)
operator|==
literal|'i'
condition|)
block|{
name|rtx
name|note
decl_stmt|;
for|for
control|(
name|note
operator|=
name|REG_NOTES
argument_list|(
name|head
argument_list|)
init|;
name|note
condition|;
name|note
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
operator|==
name|REG_DEAD
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
name|remove_note
argument_list|(
name|head
argument_list|,
name|note
argument_list|)
expr_stmt|;
block|}
name|next_tail
operator|=
name|NEXT_INSN
argument_list|(
name|tail
argument_list|)
expr_stmt|;
name|prev_head
operator|=
name|PREV_INSN
argument_list|(
name|head
argument_list|)
expr_stmt|;
comment|/* If the only insn left is a NOTE or a CODE_LABEL, then there is no need      to schedule this block.  */
if|if
condition|(
name|head
operator|==
name|tail
operator|&&
operator|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|head
argument_list|)
argument_list|)
operator|!=
literal|'i'
operator|)
condition|)
return|return
operator|(
name|sched_n_insns
operator|)
return|;
comment|/* debug info */
if|if
condition|(
name|sched_verbose
condition|)
block|{
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|";;   ======================================================\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|";;   -- basic block %d from %d to %d -- %s reload\n"
argument_list|,
name|b
argument_list|,
name|INSN_UID
argument_list|(
name|BLOCK_HEAD
argument_list|(
name|b
argument_list|)
argument_list|)
argument_list|,
name|INSN_UID
argument_list|(
name|BLOCK_END
argument_list|(
name|b
argument_list|)
argument_list|)
argument_list|,
operator|(
name|reload_completed
condition|?
literal|"after"
else|:
literal|"before"
operator|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|";;   ======================================================\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|visual_tbl
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|get_visual_tbl_length
argument_list|()
argument_list|)
expr_stmt|;
name|init_block_visualization
argument_list|()
expr_stmt|;
block|}
comment|/* remove remaining note insns from the block, save them in      note_list.  These notes are restored at the end of      schedule_block ().  */
name|note_list
operator|=
literal|0
expr_stmt|;
name|rm_other_notes
argument_list|(
name|head
argument_list|,
name|tail
argument_list|)
expr_stmt|;
name|target_bb
operator|=
name|bb
expr_stmt|;
comment|/* prepare current target block info */
if|if
condition|(
name|current_nr_blocks
operator|>
literal|1
condition|)
block|{
name|candidate_table
operator|=
operator|(
name|candidate
operator|*
operator|)
name|alloca
argument_list|(
name|current_nr_blocks
operator|*
sizeof|sizeof
argument_list|(
name|candidate
argument_list|)
argument_list|)
expr_stmt|;
name|bblst_last
operator|=
literal|0
expr_stmt|;
comment|/* ??? It is not clear why bblst_size is computed this way.  The original 	 number was clearly too small as it resulted in compiler failures. 	 Multiplying by the original number by 2 (to account for update_bbs 	 members) seems to be a reasonable solution.  */
comment|/* ??? Or perhaps there is a bug somewhere else in this file?  */
name|bblst_size
operator|=
operator|(
name|current_nr_blocks
operator|-
name|bb
operator|)
operator|*
name|rgn_nr_edges
operator|*
literal|2
expr_stmt|;
name|bblst_table
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|bblst_size
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|bitlst_table_last
operator|=
literal|0
expr_stmt|;
name|bitlst_table_size
operator|=
name|rgn_nr_edges
expr_stmt|;
name|bitlst_table
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|rgn_nr_edges
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|compute_trg_info
argument_list|(
name|bb
argument_list|)
expr_stmt|;
block|}
name|clear_units
argument_list|()
expr_stmt|;
comment|/* Allocate the ready list */
name|ready
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|rgn_n_insns
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Print debugging information.  */
if|if
condition|(
name|sched_verbose
operator|>=
literal|5
condition|)
name|debug_dependencies
argument_list|()
expr_stmt|;
comment|/* Initialize ready list with all 'ready' insns in target block.      Count number of insns in the target block being scheduled.  */
name|n_ready
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|head
init|;
name|insn
operator|!=
name|next_tail
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|rtx
name|next
decl_stmt|;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
literal|'i'
condition|)
continue|continue;
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|INSN_DEP_COUNT
argument_list|(
name|insn
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|SCHED_GROUP_P
argument_list|(
name|next
argument_list|)
operator|==
literal|0
operator|||
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|next
argument_list|)
argument_list|)
operator|!=
literal|'i'
operator|)
condition|)
name|ready
index|[
name|n_ready
operator|++
index|]
operator|=
name|insn
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|SCHED_GROUP_P
argument_list|(
name|insn
argument_list|)
operator|)
condition|)
name|target_n_insns
operator|++
expr_stmt|;
block|}
comment|/* Add to ready list all 'ready' insns in valid source blocks.      For speculative insns, check-live, exception-free, and      issue-delay.  */
for|for
control|(
name|bb_src
operator|=
name|bb
operator|+
literal|1
init|;
name|bb_src
operator|<
name|current_nr_blocks
condition|;
name|bb_src
operator|++
control|)
if|if
condition|(
name|IS_VALID
argument_list|(
name|bb_src
argument_list|)
condition|)
block|{
name|rtx
name|src_head
decl_stmt|;
name|rtx
name|src_next_tail
decl_stmt|;
name|rtx
name|tail
decl_stmt|,
name|head
decl_stmt|;
name|get_block_head_tail
argument_list|(
name|bb_src
argument_list|,
operator|&
name|head
argument_list|,
operator|&
name|tail
argument_list|)
expr_stmt|;
name|src_next_tail
operator|=
name|NEXT_INSN
argument_list|(
name|tail
argument_list|)
expr_stmt|;
name|src_head
operator|=
name|head
expr_stmt|;
if|if
condition|(
name|head
operator|==
name|tail
operator|&&
operator|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|head
argument_list|)
argument_list|)
operator|!=
literal|'i'
operator|)
condition|)
continue|continue;
for|for
control|(
name|insn
operator|=
name|src_head
init|;
name|insn
operator|!=
name|src_next_tail
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
literal|'i'
condition|)
continue|continue;
if|if
condition|(
operator|!
name|CANT_MOVE
argument_list|(
name|insn
argument_list|)
operator|&&
operator|(
operator|!
name|IS_SPECULATIVE_INSN
argument_list|(
name|insn
argument_list|)
operator|||
operator|(
name|insn_issue_delay
argument_list|(
name|insn
argument_list|)
operator|<=
literal|3
operator|&&
name|check_live
argument_list|(
name|insn
argument_list|,
name|bb_src
argument_list|)
operator|&&
name|is_exception_free
argument_list|(
name|insn
argument_list|,
name|bb_src
argument_list|,
name|target_bb
argument_list|)
operator|)
operator|)
condition|)
block|{
name|rtx
name|next
decl_stmt|;
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|INSN_DEP_COUNT
argument_list|(
name|insn
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|SCHED_GROUP_P
argument_list|(
name|next
argument_list|)
operator|==
literal|0
operator|||
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|next
argument_list|)
argument_list|)
operator|!=
literal|'i'
operator|)
condition|)
name|ready
index|[
name|n_ready
operator|++
index|]
operator|=
name|insn
expr_stmt|;
block|}
block|}
block|}
ifdef|#
directive|ifdef
name|MD_SCHED_INIT
name|MD_SCHED_INIT
argument_list|(
name|dump
argument_list|,
name|sched_verbose
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* no insns scheduled in this block yet */
name|last_scheduled_insn
operator|=
literal|0
expr_stmt|;
comment|/* Sort the ready list */
name|SCHED_SORT
argument_list|(
name|ready
argument_list|,
name|n_ready
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MD_SCHED_REORDER
name|MD_SCHED_REORDER
argument_list|(
name|dump
argument_list|,
name|sched_verbose
argument_list|,
name|ready
argument_list|,
name|n_ready
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sched_verbose
operator|>=
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|";;\t\tReady list initially:             "
argument_list|)
expr_stmt|;
name|debug_ready_list
argument_list|(
name|ready
argument_list|,
name|n_ready
argument_list|)
expr_stmt|;
block|}
comment|/* Q_SIZE is the total number of insns in the queue.  */
name|q_ptr
operator|=
literal|0
expr_stmt|;
name|q_size
operator|=
literal|0
expr_stmt|;
name|clock_var
operator|=
literal|0
expr_stmt|;
name|last_clock_var
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|insn_queue
argument_list|,
sizeof|sizeof
argument_list|(
name|insn_queue
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We start inserting insns after PREV_HEAD.  */
name|last
operator|=
name|prev_head
expr_stmt|;
comment|/* Initialize INSN_QUEUE, LIST and NEW_NEEDS.  */
name|new_needs
operator|=
operator|(
name|NEXT_INSN
argument_list|(
name|prev_head
argument_list|)
operator|==
name|BLOCK_HEAD
argument_list|(
name|b
argument_list|)
condition|?
name|NEED_HEAD
else|:
name|NEED_NOTHING
operator|)
expr_stmt|;
if|if
condition|(
name|PREV_INSN
argument_list|(
name|next_tail
argument_list|)
operator|==
name|BLOCK_END
argument_list|(
name|b
argument_list|)
condition|)
name|new_needs
operator||=
name|NEED_TAIL
expr_stmt|;
comment|/* loop until all the insns in BB are scheduled.  */
while|while
condition|(
name|sched_target_n_insns
operator|<
name|target_n_insns
condition|)
block|{
name|int
name|b1
decl_stmt|;
name|clock_var
operator|++
expr_stmt|;
comment|/* Add to the ready list all pending insns that can be issued now.          If there are no ready insns, increment clock until one          is ready and add all pending insns at that point to the ready          list.  */
name|n_ready
operator|=
name|queue_to_ready
argument_list|(
name|ready
argument_list|,
name|n_ready
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_ready
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|sched_verbose
operator|>=
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|";;\t\tReady list after queue_to_ready:  "
argument_list|)
expr_stmt|;
name|debug_ready_list
argument_list|(
name|ready
argument_list|,
name|n_ready
argument_list|)
expr_stmt|;
block|}
comment|/* Sort the ready list.  */
name|SCHED_SORT
argument_list|(
name|ready
argument_list|,
name|n_ready
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MD_SCHED_REORDER
name|MD_SCHED_REORDER
argument_list|(
name|dump
argument_list|,
name|sched_verbose
argument_list|,
name|ready
argument_list|,
name|n_ready
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sched_verbose
condition|)
block|{
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|"\n;;\tReady list (t =%3d):  "
argument_list|,
name|clock_var
argument_list|)
expr_stmt|;
name|debug_ready_list
argument_list|(
name|ready
argument_list|,
name|n_ready
argument_list|)
expr_stmt|;
block|}
comment|/* Issue insns from ready list.          It is important to count down from n_ready, because n_ready may change          as insns are issued.  */
name|can_issue_more
operator|=
name|issue_rate
expr_stmt|;
for|for
control|(
name|i
operator|=
name|n_ready
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
operator|&&
name|can_issue_more
condition|;
name|i
operator|--
control|)
block|{
name|rtx
name|insn
init|=
name|ready
index|[
name|i
index|]
decl_stmt|;
name|int
name|cost
init|=
name|actual_hazard
argument_list|(
name|insn_unit
argument_list|(
name|insn
argument_list|)
argument_list|,
name|insn
argument_list|,
name|clock_var
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|cost
operator|>
literal|1
condition|)
block|{
name|queue_insn
argument_list|(
name|insn
argument_list|,
name|cost
argument_list|)
expr_stmt|;
name|ready
index|[
name|i
index|]
operator|=
name|ready
index|[
operator|--
name|n_ready
index|]
expr_stmt|;
comment|/* remove insn from ready list */
block|}
elseif|else
if|if
condition|(
name|cost
operator|==
literal|0
condition|)
block|{
comment|/* an interblock motion? */
if|if
condition|(
name|INSN_BB
argument_list|(
name|insn
argument_list|)
operator|!=
name|target_bb
condition|)
block|{
name|rtx
name|temp
decl_stmt|;
if|if
condition|(
name|IS_SPECULATIVE_INSN
argument_list|(
name|insn
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|check_live
argument_list|(
name|insn
argument_list|,
name|INSN_BB
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
block|{
comment|/* speculative motion, live check failed, remove 			     insn from ready list */
name|ready
index|[
name|i
index|]
operator|=
name|ready
index|[
operator|--
name|n_ready
index|]
expr_stmt|;
continue|continue;
block|}
name|update_live
argument_list|(
name|insn
argument_list|,
name|INSN_BB
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* for speculative load, mark insns fed by it.  */
if|if
condition|(
name|IS_LOAD_INSN
argument_list|(
name|insn
argument_list|)
operator|||
name|FED_BY_SPEC_LOAD
argument_list|(
name|insn
argument_list|)
condition|)
name|set_spec_fed
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|nr_spec
operator|++
expr_stmt|;
block|}
name|nr_inter
operator|++
expr_stmt|;
name|temp
operator|=
name|insn
expr_stmt|;
while|while
condition|(
name|SCHED_GROUP_P
argument_list|(
name|temp
argument_list|)
condition|)
name|temp
operator|=
name|PREV_INSN
argument_list|(
name|temp
argument_list|)
expr_stmt|;
comment|/* Update source block boundaries.   */
name|b1
operator|=
name|INSN_BLOCK
argument_list|(
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|==
name|BLOCK_HEAD
argument_list|(
name|b1
argument_list|)
operator|&&
name|insn
operator|==
name|BLOCK_END
argument_list|(
name|b1
argument_list|)
condition|)
block|{
comment|/* We moved all the insns in the basic block. 			 Emit a note after the last insn and update the 			 begin/end boundaries to point to the note.  */
name|emit_note_after
argument_list|(
name|NOTE_INSN_DELETED
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|BLOCK_END
argument_list|(
name|b1
argument_list|)
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|BLOCK_HEAD
argument_list|(
name|b1
argument_list|)
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|insn
operator|==
name|BLOCK_END
argument_list|(
name|b1
argument_list|)
condition|)
block|{
comment|/* We took insns from the end of the basic block, 			 so update the end of block boundary so that it 			 points to the first insn we did not move.  */
name|BLOCK_END
argument_list|(
name|b1
argument_list|)
operator|=
name|PREV_INSN
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|temp
operator|==
name|BLOCK_HEAD
argument_list|(
name|b1
argument_list|)
condition|)
block|{
comment|/* We took insns from the start of the basic block, 			 so update the start of block boundary so that 			 it points to the first insn we did not move.  */
name|BLOCK_HEAD
argument_list|(
name|b1
argument_list|)
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* in block motion */
name|sched_target_n_insns
operator|++
expr_stmt|;
block|}
name|last_scheduled_insn
operator|=
name|insn
expr_stmt|;
name|last
operator|=
name|move_insn
argument_list|(
name|insn
argument_list|,
name|last
argument_list|)
expr_stmt|;
name|sched_n_insns
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|MD_SCHED_VARIABLE_ISSUE
name|MD_SCHED_VARIABLE_ISSUE
argument_list|(
name|dump
argument_list|,
name|sched_verbose
argument_list|,
name|insn
argument_list|,
name|can_issue_more
argument_list|)
expr_stmt|;
else|#
directive|else
name|can_issue_more
operator|--
expr_stmt|;
endif|#
directive|endif
name|n_ready
operator|=
name|schedule_insn
argument_list|(
name|insn
argument_list|,
name|ready
argument_list|,
name|n_ready
argument_list|,
name|clock_var
argument_list|)
expr_stmt|;
comment|/* remove insn from ready list */
name|ready
index|[
name|i
index|]
operator|=
name|ready
index|[
operator|--
name|n_ready
index|]
expr_stmt|;
comment|/* close this block after scheduling its jump */
if|if
condition|(
name|GET_CODE
argument_list|(
name|last_scheduled_insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
break|break;
block|}
block|}
comment|/* debug info */
if|if
condition|(
name|sched_verbose
condition|)
block|{
name|visualize_scheduled_insns
argument_list|(
name|b
argument_list|,
name|clock_var
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* debug info */
if|if
condition|(
name|sched_verbose
condition|)
block|{
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|";;\tReady list (final):  "
argument_list|)
expr_stmt|;
name|debug_ready_list
argument_list|(
name|ready
argument_list|,
name|n_ready
argument_list|)
expr_stmt|;
name|print_block_visualization
argument_list|(
name|b
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
comment|/* Sanity check -- queue must be empty now.  Meaningless if region has      multiple bbs.  */
if|if
condition|(
name|current_nr_blocks
operator|>
literal|1
condition|)
if|if
condition|(
operator|!
name|flag_schedule_interblock
operator|&&
name|q_size
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* update head/tail boundaries.  */
name|head
operator|=
name|NEXT_INSN
argument_list|(
name|prev_head
argument_list|)
expr_stmt|;
name|tail
operator|=
name|last
expr_stmt|;
comment|/* Restore-other-notes: NOTE_LIST is the end of a chain of notes      previously found among the insns.  Insert them at the beginning      of the insns.  */
if|if
condition|(
name|note_list
operator|!=
literal|0
condition|)
block|{
name|rtx
name|note_head
init|=
name|note_list
decl_stmt|;
while|while
condition|(
name|PREV_INSN
argument_list|(
name|note_head
argument_list|)
condition|)
block|{
name|note_head
operator|=
name|PREV_INSN
argument_list|(
name|note_head
argument_list|)
expr_stmt|;
block|}
name|PREV_INSN
argument_list|(
name|note_head
argument_list|)
operator|=
name|PREV_INSN
argument_list|(
name|head
argument_list|)
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|PREV_INSN
argument_list|(
name|head
argument_list|)
argument_list|)
operator|=
name|note_head
expr_stmt|;
name|PREV_INSN
argument_list|(
name|head
argument_list|)
operator|=
name|note_list
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|note_list
argument_list|)
operator|=
name|head
expr_stmt|;
name|head
operator|=
name|note_head
expr_stmt|;
block|}
comment|/* update target block boundaries.  */
if|if
condition|(
name|new_needs
operator|&
name|NEED_HEAD
condition|)
name|BLOCK_HEAD
argument_list|(
name|b
argument_list|)
operator|=
name|head
expr_stmt|;
if|if
condition|(
name|new_needs
operator|&
name|NEED_TAIL
condition|)
name|BLOCK_END
argument_list|(
name|b
argument_list|)
operator|=
name|tail
expr_stmt|;
comment|/* debugging */
if|if
condition|(
name|sched_verbose
condition|)
block|{
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|";;   total time = %d\n;;   new basic block head = %d\n"
argument_list|,
name|clock_var
argument_list|,
name|INSN_UID
argument_list|(
name|BLOCK_HEAD
argument_list|(
name|b
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|";;   new basic block end = %d\n\n"
argument_list|,
name|INSN_UID
argument_list|(
name|BLOCK_END
argument_list|(
name|b
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|sched_n_insns
operator|)
return|;
block|}
end_function

begin_comment
comment|/* schedule_block () */
end_comment

begin_escape
end_escape

begin_comment
comment|/* print the bit-set of registers, S.  callable from debugger */
end_comment

begin_function
specifier|extern
name|void
name|debug_reg_vector
parameter_list|(
name|s
parameter_list|)
name|regset
name|s
decl_stmt|;
block|{
name|int
name|regno
decl_stmt|;
name|EXECUTE_IF_SET_IN_REG_SET
argument_list|(
argument|s
argument_list|,
literal|0
argument_list|,
argument|regno
argument_list|,
argument|{ 			       fprintf (dump,
literal|" %d"
argument|, regno); 			     }
argument_list|)
empty_stmt|;
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Use the backward dependences from LOG_LINKS to build    forward dependences in INSN_DEPEND.  */
end_comment

begin_function
specifier|static
name|void
name|compute_block_forward_dependences
parameter_list|(
name|bb
parameter_list|)
name|int
name|bb
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|,
name|link
decl_stmt|;
name|rtx
name|tail
decl_stmt|,
name|head
decl_stmt|;
name|rtx
name|next_tail
decl_stmt|;
name|enum
name|reg_note
name|dep_type
decl_stmt|;
name|get_block_head_tail
argument_list|(
name|bb
argument_list|,
operator|&
name|head
argument_list|,
operator|&
name|tail
argument_list|)
expr_stmt|;
name|next_tail
operator|=
name|NEXT_INSN
argument_list|(
name|tail
argument_list|)
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|head
init|;
name|insn
operator|!=
name|next_tail
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
literal|'i'
condition|)
continue|continue;
name|insn
operator|=
name|group_leader
argument_list|(
name|insn
argument_list|)
expr_stmt|;
for|for
control|(
name|link
operator|=
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|rtx
name|x
init|=
name|group_leader
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|new_link
decl_stmt|;
if|if
condition|(
name|x
operator|!=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
condition|)
continue|continue;
comment|/* Ignore dependences upon deleted insn */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|NOTE
operator|||
name|INSN_DELETED_P
argument_list|(
name|x
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|find_insn_list
argument_list|(
name|insn
argument_list|,
name|INSN_DEPEND
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
continue|continue;
name|new_link
operator|=
name|alloc_INSN_LIST
argument_list|(
name|insn
argument_list|,
name|INSN_DEPEND
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|dep_type
operator|=
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
expr_stmt|;
name|PUT_REG_NOTE_KIND
argument_list|(
name|new_link
argument_list|,
name|dep_type
argument_list|)
expr_stmt|;
name|INSN_DEPEND
argument_list|(
name|x
argument_list|)
operator|=
name|new_link
expr_stmt|;
name|INSN_DEP_COUNT
argument_list|(
name|insn
argument_list|)
operator|+=
literal|1
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Initialize variables for region data dependence analysis.    n_bbs is the number of region blocks */
end_comment

begin_function
name|__inline
specifier|static
name|void
name|init_rgn_data_dependences
parameter_list|(
name|n_bbs
parameter_list|)
name|int
name|n_bbs
decl_stmt|;
block|{
name|int
name|bb
decl_stmt|;
comment|/* variables for which one copy exists for each block */
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|bb_pending_read_insns
argument_list|,
name|n_bbs
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|bb_pending_read_mems
argument_list|,
name|n_bbs
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|bb_pending_write_insns
argument_list|,
name|n_bbs
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|bb_pending_write_mems
argument_list|,
name|n_bbs
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|bb_pending_lists_length
argument_list|,
name|n_bbs
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|bb_last_pending_memory_flush
argument_list|,
name|n_bbs
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|bb_last_function_call
argument_list|,
name|n_bbs
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|bb_sched_before_next_call
argument_list|,
name|n_bbs
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create an insn here so that we can hang dependencies off of it later.  */
for|for
control|(
name|bb
operator|=
literal|0
init|;
name|bb
operator|<
name|n_bbs
condition|;
name|bb
operator|++
control|)
block|{
name|bb_sched_before_next_call
index|[
name|bb
index|]
operator|=
name|gen_rtx_INSN
argument_list|(
name|VOIDmode
argument_list|,
literal|0
argument_list|,
name|NULL_RTX
argument_list|,
name|NULL_RTX
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|,
name|NULL_RTX
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|LOG_LINKS
argument_list|(
name|bb_sched_before_next_call
index|[
name|bb
index|]
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Add dependences so that branches are scheduled to run last in their block */
end_comment

begin_function
specifier|static
name|void
name|add_branch_dependences
parameter_list|(
name|head
parameter_list|,
name|tail
parameter_list|)
name|rtx
name|head
decl_stmt|,
name|tail
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|,
name|last
decl_stmt|;
comment|/* For all branches, calls, uses, and cc0 setters, force them to remain      in order at the end of the block by adding dependencies and giving      the last a high priority.  There may be notes present, and prev_head      may also be a note.       Branches must obviously remain at the end.  Calls should remain at the      end since moving them results in worse register allocation.  Uses remain      at the end to ensure proper register allocation.  cc0 setters remaim      at the end because they can't be moved away from their cc0 user.  */
name|insn
operator|=
name|tail
expr_stmt|;
name|last
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|||
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|USE
ifdef|#
directive|ifdef
name|HAVE_cc0
operator|||
name|sets_cc0_p
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
endif|#
directive|endif
operator|)
operator|)
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE
condition|)
block|{
if|if
condition|(
name|last
operator|!=
literal|0
operator|&&
operator|!
name|find_insn_list
argument_list|(
name|insn
argument_list|,
name|LOG_LINKS
argument_list|(
name|last
argument_list|)
argument_list|)
condition|)
block|{
name|add_dependence
argument_list|(
name|last
argument_list|,
name|insn
argument_list|,
name|REG_DEP_ANTI
argument_list|)
expr_stmt|;
name|INSN_REF_COUNT
argument_list|(
name|insn
argument_list|)
operator|++
expr_stmt|;
block|}
name|CANT_MOVE
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|last
operator|=
name|insn
expr_stmt|;
comment|/* Skip over insns that are part of a group. 	     Make each insn explicitly depend on the previous insn. 	     This ensures that only the group header will ever enter 	     the ready queue (and, when scheduled, will automatically 	     schedule the SCHED_GROUP_P block).  */
while|while
condition|(
name|SCHED_GROUP_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|rtx
name|temp
init|=
name|prev_nonnote_insn
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|add_dependence
argument_list|(
name|insn
argument_list|,
name|temp
argument_list|,
name|REG_DEP_ANTI
argument_list|)
expr_stmt|;
name|insn
operator|=
name|temp
expr_stmt|;
block|}
block|}
comment|/* Don't overrun the bounds of the basic block.  */
if|if
condition|(
name|insn
operator|==
name|head
condition|)
break|break;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
comment|/* make sure these insns are scheduled last in their block */
name|insn
operator|=
name|last
expr_stmt|;
if|if
condition|(
name|insn
operator|!=
literal|0
condition|)
while|while
condition|(
name|insn
operator|!=
name|head
condition|)
block|{
name|insn
operator|=
name|prev_nonnote_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|INSN_REF_COUNT
argument_list|(
name|insn
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|!
name|find_insn_list
argument_list|(
name|last
argument_list|,
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
name|add_dependence
argument_list|(
name|last
argument_list|,
name|insn
argument_list|,
name|REG_DEP_ANTI
argument_list|)
expr_stmt|;
name|INSN_REF_COUNT
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Skip over insns that are part of a group.  */
while|while
condition|(
name|SCHED_GROUP_P
argument_list|(
name|insn
argument_list|)
condition|)
name|insn
operator|=
name|prev_nonnote_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Compute bacward dependences inside BB.  In a multiple blocks region:    (1) a bb is analyzed after its predecessors, and (2) the lists in    effect at the end of bb (after analyzing for bb) are inherited by    bb's successrs.     Specifically for reg-reg data dependences, the block insns are    scanned by sched_analyze () top-to-bottom.  Two lists are    naintained by sched_analyze (): reg_last_defs[] for register DEFs,    and reg_last_uses[] for register USEs.     When analysis is completed for bb, we update for its successors:    ;  - DEFS[succ] = Union (DEFS [succ], DEFS [bb])    ;  - USES[succ] = Union (USES [succ], DEFS [bb])     The mechanism for computing mem-mem data dependence is very    similar, and the result is interblock dependences in the region.  */
end_comment

begin_function
specifier|static
name|void
name|compute_block_backward_dependences
parameter_list|(
name|bb
parameter_list|)
name|int
name|bb
decl_stmt|;
block|{
name|int
name|b
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|rtx
name|head
decl_stmt|,
name|tail
decl_stmt|;
name|int
name|max_reg
init|=
name|max_reg_num
argument_list|()
decl_stmt|;
name|b
operator|=
name|BB_TO_BLOCK
argument_list|(
name|bb
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_nr_blocks
operator|==
literal|1
condition|)
block|{
name|reg_last_uses
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|max_reg
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|reg_last_sets
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|max_reg
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|reg_last_clobbers
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|max_reg
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|reg_last_uses
argument_list|,
name|max_reg
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|reg_last_sets
argument_list|,
name|max_reg
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|reg_last_clobbers
argument_list|,
name|max_reg
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|pending_read_insns
operator|=
literal|0
expr_stmt|;
name|pending_read_mems
operator|=
literal|0
expr_stmt|;
name|pending_write_insns
operator|=
literal|0
expr_stmt|;
name|pending_write_mems
operator|=
literal|0
expr_stmt|;
name|pending_lists_length
operator|=
literal|0
expr_stmt|;
name|last_function_call
operator|=
literal|0
expr_stmt|;
name|last_pending_memory_flush
operator|=
literal|0
expr_stmt|;
name|sched_before_next_call
operator|=
name|gen_rtx_INSN
argument_list|(
name|VOIDmode
argument_list|,
literal|0
argument_list|,
name|NULL_RTX
argument_list|,
name|NULL_RTX
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|,
name|NULL_RTX
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|LOG_LINKS
argument_list|(
name|sched_before_next_call
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|reg_last_uses
operator|=
name|bb_reg_last_uses
index|[
name|bb
index|]
expr_stmt|;
name|reg_last_sets
operator|=
name|bb_reg_last_sets
index|[
name|bb
index|]
expr_stmt|;
name|reg_last_clobbers
operator|=
name|bb_reg_last_clobbers
index|[
name|bb
index|]
expr_stmt|;
name|pending_read_insns
operator|=
name|bb_pending_read_insns
index|[
name|bb
index|]
expr_stmt|;
name|pending_read_mems
operator|=
name|bb_pending_read_mems
index|[
name|bb
index|]
expr_stmt|;
name|pending_write_insns
operator|=
name|bb_pending_write_insns
index|[
name|bb
index|]
expr_stmt|;
name|pending_write_mems
operator|=
name|bb_pending_write_mems
index|[
name|bb
index|]
expr_stmt|;
name|pending_lists_length
operator|=
name|bb_pending_lists_length
index|[
name|bb
index|]
expr_stmt|;
name|last_function_call
operator|=
name|bb_last_function_call
index|[
name|bb
index|]
expr_stmt|;
name|last_pending_memory_flush
operator|=
name|bb_last_pending_memory_flush
index|[
name|bb
index|]
expr_stmt|;
name|sched_before_next_call
operator|=
name|bb_sched_before_next_call
index|[
name|bb
index|]
expr_stmt|;
block|}
comment|/* do the analysis for this block */
name|get_block_head_tail
argument_list|(
name|bb
argument_list|,
operator|&
name|head
argument_list|,
operator|&
name|tail
argument_list|)
expr_stmt|;
name|sched_analyze
argument_list|(
name|head
argument_list|,
name|tail
argument_list|)
expr_stmt|;
name|add_branch_dependences
argument_list|(
name|head
argument_list|,
name|tail
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_nr_blocks
operator|>
literal|1
condition|)
block|{
name|int
name|e
decl_stmt|,
name|first_edge
decl_stmt|;
name|int
name|b_succ
decl_stmt|,
name|bb_succ
decl_stmt|;
name|int
name|reg
decl_stmt|;
name|rtx
name|link_insn
decl_stmt|,
name|link_mem
decl_stmt|;
name|rtx
name|u
decl_stmt|;
comment|/* these lists should point to the right place, for correct freeing later.  */
name|bb_pending_read_insns
index|[
name|bb
index|]
operator|=
name|pending_read_insns
expr_stmt|;
name|bb_pending_read_mems
index|[
name|bb
index|]
operator|=
name|pending_read_mems
expr_stmt|;
name|bb_pending_write_insns
index|[
name|bb
index|]
operator|=
name|pending_write_insns
expr_stmt|;
name|bb_pending_write_mems
index|[
name|bb
index|]
operator|=
name|pending_write_mems
expr_stmt|;
comment|/* bb's structures are inherited by it's successors */
name|first_edge
operator|=
name|e
operator|=
name|OUT_EDGES
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|>
literal|0
condition|)
do|do
block|{
name|b_succ
operator|=
name|TO_BLOCK
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|bb_succ
operator|=
name|BLOCK_TO_BB
argument_list|(
name|b_succ
argument_list|)
expr_stmt|;
comment|/* only bbs "below" bb, in the same region, are interesting */
if|if
condition|(
name|CONTAINING_RGN
argument_list|(
name|b
argument_list|)
operator|!=
name|CONTAINING_RGN
argument_list|(
name|b_succ
argument_list|)
operator|||
name|bb_succ
operator|<=
name|bb
condition|)
block|{
name|e
operator|=
name|NEXT_OUT
argument_list|(
name|e
argument_list|)
expr_stmt|;
continue|continue;
block|}
for|for
control|(
name|reg
operator|=
literal|0
init|;
name|reg
operator|<
name|max_reg
condition|;
name|reg
operator|++
control|)
block|{
comment|/* reg-last-uses lists are inherited by bb_succ */
for|for
control|(
name|u
operator|=
name|reg_last_uses
index|[
name|reg
index|]
init|;
name|u
condition|;
name|u
operator|=
name|XEXP
argument_list|(
name|u
argument_list|,
literal|1
argument_list|)
control|)
block|{
if|if
condition|(
name|find_insn_list
argument_list|(
name|XEXP
argument_list|(
name|u
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|(
name|bb_reg_last_uses
index|[
name|bb_succ
index|]
operator|)
index|[
name|reg
index|]
argument_list|)
condition|)
continue|continue;
operator|(
name|bb_reg_last_uses
index|[
name|bb_succ
index|]
operator|)
index|[
name|reg
index|]
operator|=
name|alloc_INSN_LIST
argument_list|(
name|XEXP
argument_list|(
name|u
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|(
name|bb_reg_last_uses
index|[
name|bb_succ
index|]
operator|)
index|[
name|reg
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* reg-last-defs lists are inherited by bb_succ */
for|for
control|(
name|u
operator|=
name|reg_last_sets
index|[
name|reg
index|]
init|;
name|u
condition|;
name|u
operator|=
name|XEXP
argument_list|(
name|u
argument_list|,
literal|1
argument_list|)
control|)
block|{
if|if
condition|(
name|find_insn_list
argument_list|(
name|XEXP
argument_list|(
name|u
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|(
name|bb_reg_last_sets
index|[
name|bb_succ
index|]
operator|)
index|[
name|reg
index|]
argument_list|)
condition|)
continue|continue;
operator|(
name|bb_reg_last_sets
index|[
name|bb_succ
index|]
operator|)
index|[
name|reg
index|]
operator|=
name|alloc_INSN_LIST
argument_list|(
name|XEXP
argument_list|(
name|u
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|(
name|bb_reg_last_sets
index|[
name|bb_succ
index|]
operator|)
index|[
name|reg
index|]
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|u
operator|=
name|reg_last_clobbers
index|[
name|reg
index|]
init|;
name|u
condition|;
name|u
operator|=
name|XEXP
argument_list|(
name|u
argument_list|,
literal|1
argument_list|)
control|)
block|{
if|if
condition|(
name|find_insn_list
argument_list|(
name|XEXP
argument_list|(
name|u
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|(
name|bb_reg_last_clobbers
index|[
name|bb_succ
index|]
operator|)
index|[
name|reg
index|]
argument_list|)
condition|)
continue|continue;
operator|(
name|bb_reg_last_clobbers
index|[
name|bb_succ
index|]
operator|)
index|[
name|reg
index|]
operator|=
name|alloc_INSN_LIST
argument_list|(
name|XEXP
argument_list|(
name|u
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|(
name|bb_reg_last_clobbers
index|[
name|bb_succ
index|]
operator|)
index|[
name|reg
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* mem read/write lists are inherited by bb_succ */
name|link_insn
operator|=
name|pending_read_insns
expr_stmt|;
name|link_mem
operator|=
name|pending_read_mems
expr_stmt|;
while|while
condition|(
name|link_insn
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|find_insn_mem_list
argument_list|(
name|XEXP
argument_list|(
name|link_insn
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|link_mem
argument_list|,
literal|0
argument_list|)
argument_list|,
name|bb_pending_read_insns
index|[
name|bb_succ
index|]
argument_list|,
name|bb_pending_read_mems
index|[
name|bb_succ
index|]
argument_list|)
operator|)
condition|)
name|add_insn_mem_dependence
argument_list|(
operator|&
name|bb_pending_read_insns
index|[
name|bb_succ
index|]
argument_list|,
operator|&
name|bb_pending_read_mems
index|[
name|bb_succ
index|]
argument_list|,
name|XEXP
argument_list|(
name|link_insn
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|link_mem
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|link_insn
operator|=
name|XEXP
argument_list|(
name|link_insn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|link_mem
operator|=
name|XEXP
argument_list|(
name|link_mem
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|link_insn
operator|=
name|pending_write_insns
expr_stmt|;
name|link_mem
operator|=
name|pending_write_mems
expr_stmt|;
while|while
condition|(
name|link_insn
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|find_insn_mem_list
argument_list|(
name|XEXP
argument_list|(
name|link_insn
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|link_mem
argument_list|,
literal|0
argument_list|)
argument_list|,
name|bb_pending_write_insns
index|[
name|bb_succ
index|]
argument_list|,
name|bb_pending_write_mems
index|[
name|bb_succ
index|]
argument_list|)
operator|)
condition|)
name|add_insn_mem_dependence
argument_list|(
operator|&
name|bb_pending_write_insns
index|[
name|bb_succ
index|]
argument_list|,
operator|&
name|bb_pending_write_mems
index|[
name|bb_succ
index|]
argument_list|,
name|XEXP
argument_list|(
name|link_insn
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|link_mem
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|link_insn
operator|=
name|XEXP
argument_list|(
name|link_insn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|link_mem
operator|=
name|XEXP
argument_list|(
name|link_mem
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* last_function_call is inherited by bb_succ */
for|for
control|(
name|u
operator|=
name|last_function_call
init|;
name|u
condition|;
name|u
operator|=
name|XEXP
argument_list|(
name|u
argument_list|,
literal|1
argument_list|)
control|)
block|{
if|if
condition|(
name|find_insn_list
argument_list|(
name|XEXP
argument_list|(
name|u
argument_list|,
literal|0
argument_list|)
argument_list|,
name|bb_last_function_call
index|[
name|bb_succ
index|]
argument_list|)
condition|)
continue|continue;
name|bb_last_function_call
index|[
name|bb_succ
index|]
operator|=
name|alloc_INSN_LIST
argument_list|(
name|XEXP
argument_list|(
name|u
argument_list|,
literal|0
argument_list|)
argument_list|,
name|bb_last_function_call
index|[
name|bb_succ
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* last_pending_memory_flush is inherited by bb_succ */
for|for
control|(
name|u
operator|=
name|last_pending_memory_flush
init|;
name|u
condition|;
name|u
operator|=
name|XEXP
argument_list|(
name|u
argument_list|,
literal|1
argument_list|)
control|)
block|{
if|if
condition|(
name|find_insn_list
argument_list|(
name|XEXP
argument_list|(
name|u
argument_list|,
literal|0
argument_list|)
argument_list|,
name|bb_last_pending_memory_flush
index|[
name|bb_succ
index|]
argument_list|)
condition|)
continue|continue;
name|bb_last_pending_memory_flush
index|[
name|bb_succ
index|]
operator|=
name|alloc_INSN_LIST
argument_list|(
name|XEXP
argument_list|(
name|u
argument_list|,
literal|0
argument_list|)
argument_list|,
name|bb_last_pending_memory_flush
index|[
name|bb_succ
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* sched_before_next_call is inherited by bb_succ */
name|x
operator|=
name|LOG_LINKS
argument_list|(
name|sched_before_next_call
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|x
condition|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
control|)
name|add_dependence
argument_list|(
name|bb_sched_before_next_call
index|[
name|bb_succ
index|]
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|REG_DEP_ANTI
argument_list|)
expr_stmt|;
name|e
operator|=
name|NEXT_OUT
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|e
operator|!=
name|first_edge
condition|)
do|;
block|}
comment|/* Free up the INSN_LISTs        Note this loop is executed max_reg * nr_regions times.  It's first       implementation accounted for over 90% of the calls to free_list.      The list was empty for the vast majority of those calls.  On the PA,      not calling free_list in those cases improves -O2 compile times by      3-5% on average.  */
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|max_reg
condition|;
operator|++
name|b
control|)
block|{
if|if
condition|(
name|reg_last_clobbers
index|[
name|b
index|]
condition|)
name|free_list
argument_list|(
operator|&
name|reg_last_clobbers
index|[
name|b
index|]
argument_list|,
operator|&
name|unused_insn_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_last_sets
index|[
name|b
index|]
condition|)
name|free_list
argument_list|(
operator|&
name|reg_last_sets
index|[
name|b
index|]
argument_list|,
operator|&
name|unused_insn_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_last_uses
index|[
name|b
index|]
condition|)
name|free_list
argument_list|(
operator|&
name|reg_last_uses
index|[
name|b
index|]
argument_list|,
operator|&
name|unused_insn_list
argument_list|)
expr_stmt|;
block|}
comment|/* Assert that we won't need bb_reg_last_* for this block anymore.  */
if|if
condition|(
name|current_nr_blocks
operator|>
literal|1
condition|)
block|{
name|bb_reg_last_uses
index|[
name|bb
index|]
operator|=
operator|(
name|rtx
operator|*
operator|)
name|NULL_RTX
expr_stmt|;
name|bb_reg_last_sets
index|[
name|bb
index|]
operator|=
operator|(
name|rtx
operator|*
operator|)
name|NULL_RTX
expr_stmt|;
name|bb_reg_last_clobbers
index|[
name|bb
index|]
operator|=
operator|(
name|rtx
operator|*
operator|)
name|NULL_RTX
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print dependences for debugging, callable from debugger */
end_comment

begin_function
name|void
name|debug_dependencies
parameter_list|()
block|{
name|int
name|bb
decl_stmt|;
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|";;   --------------- forward dependences: ------------ \n"
argument_list|)
expr_stmt|;
for|for
control|(
name|bb
operator|=
literal|0
init|;
name|bb
operator|<
name|current_nr_blocks
condition|;
name|bb
operator|++
control|)
block|{
if|if
condition|(
literal|1
condition|)
block|{
name|rtx
name|head
decl_stmt|,
name|tail
decl_stmt|;
name|rtx
name|next_tail
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|get_block_head_tail
argument_list|(
name|bb
argument_list|,
operator|&
name|head
argument_list|,
operator|&
name|tail
argument_list|)
expr_stmt|;
name|next_tail
operator|=
name|NEXT_INSN
argument_list|(
name|tail
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|"\n;;   --- Region Dependences --- b %d bb %d \n"
argument_list|,
name|BB_TO_BLOCK
argument_list|(
name|bb
argument_list|)
argument_list|,
name|bb
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|";;   %7s%6s%6s%6s%6s%6s%11s%6s\n"
argument_list|,
literal|"insn"
argument_list|,
literal|"code"
argument_list|,
literal|"bb"
argument_list|,
literal|"dep"
argument_list|,
literal|"prio"
argument_list|,
literal|"cost"
argument_list|,
literal|"blockage"
argument_list|,
literal|"units"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|";;   %7s%6s%6s%6s%6s%6s%11s%6s\n"
argument_list|,
literal|"----"
argument_list|,
literal|"----"
argument_list|,
literal|"--"
argument_list|,
literal|"---"
argument_list|,
literal|"----"
argument_list|,
literal|"----"
argument_list|,
literal|"--------"
argument_list|,
literal|"-----"
argument_list|)
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|head
init|;
name|insn
operator|!=
name|next_tail
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|rtx
name|link
decl_stmt|;
name|int
name|unit
decl_stmt|,
name|range
decl_stmt|;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
literal|'i'
condition|)
block|{
name|int
name|n
decl_stmt|;
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|";;   %6d "
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
block|{
name|n
operator|=
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|"%s\n"
argument_list|,
name|GET_NOTE_INSN_NAME
argument_list|(
name|n
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|"line %d, file %s\n"
argument_list|,
name|n
argument_list|,
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|" {%s}\n"
argument_list|,
name|GET_RTX_NAME
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|unit
operator|=
name|insn_unit
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|range
operator|=
operator|(
name|unit
operator|<
literal|0
operator|||
name|function_units
index|[
name|unit
index|]
operator|.
name|blockage_range_function
operator|==
literal|0
operator|)
condition|?
literal|0
else|:
name|function_units
index|[
name|unit
index|]
operator|.
name|blockage_range_function
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|";;   %s%5d%6d%6d%6d%6d%6d  %3d -%3d   "
argument_list|,
operator|(
name|SCHED_GROUP_P
argument_list|(
name|insn
argument_list|)
condition|?
literal|"+"
else|:
literal|" "
operator|)
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|,
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
argument_list|,
name|INSN_BB
argument_list|(
name|insn
argument_list|)
argument_list|,
name|INSN_DEP_COUNT
argument_list|(
name|insn
argument_list|)
argument_list|,
name|INSN_PRIORITY
argument_list|(
name|insn
argument_list|)
argument_list|,
name|insn_cost
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|MIN_BLOCKAGE_COST
argument_list|(
name|range
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|MAX_BLOCKAGE_COST
argument_list|(
name|range
argument_list|)
argument_list|)
expr_stmt|;
name|insn_print_units
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|"\t: "
argument_list|)
expr_stmt|;
for|for
control|(
name|link
operator|=
name|INSN_DEPEND
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|"%d "
argument_list|,
name|INSN_UID
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set_priorities: compute priority of each insn in the block */
end_comment

begin_function
specifier|static
name|int
name|set_priorities
parameter_list|(
name|bb
parameter_list|)
name|int
name|bb
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|;
name|int
name|n_insn
decl_stmt|;
name|rtx
name|tail
decl_stmt|;
name|rtx
name|prev_head
decl_stmt|;
name|rtx
name|head
decl_stmt|;
name|get_block_head_tail
argument_list|(
name|bb
argument_list|,
operator|&
name|head
argument_list|,
operator|&
name|tail
argument_list|)
expr_stmt|;
name|prev_head
operator|=
name|PREV_INSN
argument_list|(
name|head
argument_list|)
expr_stmt|;
if|if
condition|(
name|head
operator|==
name|tail
operator|&&
operator|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|head
argument_list|)
argument_list|)
operator|!=
literal|'i'
operator|)
condition|)
return|return
literal|0
return|;
name|n_insn
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|tail
init|;
name|insn
operator|!=
name|prev_head
condition|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
continue|continue;
if|if
condition|(
operator|!
operator|(
name|SCHED_GROUP_P
argument_list|(
name|insn
argument_list|)
operator|)
condition|)
name|n_insn
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|priority
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
return|return
name|n_insn
return|;
block|}
end_function

begin_comment
comment|/* Make each element of VECTOR point at an rtx-vector,    taking the space for all those rtx-vectors from SPACE.    SPACE is of type (rtx *), but it is really as long as NELTS rtx-vectors.    BYTES_PER_ELT is the number of bytes in one rtx-vector.    (this is the same as init_regset_vector () in flow.c) */
end_comment

begin_function
specifier|static
name|void
name|init_rtx_vector
parameter_list|(
name|vector
parameter_list|,
name|space
parameter_list|,
name|nelts
parameter_list|,
name|bytes_per_elt
parameter_list|)
name|rtx
modifier|*
modifier|*
name|vector
decl_stmt|;
name|rtx
modifier|*
name|space
decl_stmt|;
name|int
name|nelts
decl_stmt|;
name|int
name|bytes_per_elt
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|rtx
modifier|*
name|p
init|=
name|space
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|vector
index|[
name|i
index|]
operator|=
name|p
expr_stmt|;
name|p
operator|+=
name|bytes_per_elt
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Schedule a region.  A region is either an inner loop, a loop-free    subroutine, or a single basic block.  Each bb in the region is    scheduled after its flow predecessors.  */
end_comment

begin_function
specifier|static
name|void
name|schedule_region
parameter_list|(
name|rgn
parameter_list|)
name|int
name|rgn
decl_stmt|;
block|{
name|int
name|bb
decl_stmt|;
name|int
name|rgn_n_insns
init|=
literal|0
decl_stmt|;
name|int
name|sched_rgn_n_insns
init|=
literal|0
decl_stmt|;
comment|/* set variables for the current region */
name|current_nr_blocks
operator|=
name|RGN_NR_BLOCKS
argument_list|(
name|rgn
argument_list|)
expr_stmt|;
name|current_blocks
operator|=
name|RGN_BLOCKS
argument_list|(
name|rgn
argument_list|)
expr_stmt|;
name|reg_pending_sets
operator|=
name|ALLOCA_REG_SET
argument_list|()
expr_stmt|;
name|reg_pending_clobbers
operator|=
name|ALLOCA_REG_SET
argument_list|()
expr_stmt|;
name|reg_pending_sets_all
operator|=
literal|0
expr_stmt|;
comment|/* initializations for region data dependence analyisis */
if|if
condition|(
name|current_nr_blocks
operator|>
literal|1
condition|)
block|{
name|rtx
modifier|*
name|space
decl_stmt|;
name|int
name|maxreg
init|=
name|max_reg_num
argument_list|()
decl_stmt|;
name|bb_reg_last_uses
operator|=
operator|(
name|rtx
operator|*
operator|*
operator|)
name|alloca
argument_list|(
name|current_nr_blocks
operator|*
sizeof|sizeof
argument_list|(
name|rtx
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|space
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|current_nr_blocks
operator|*
name|maxreg
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|space
argument_list|,
name|current_nr_blocks
operator|*
name|maxreg
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|init_rtx_vector
argument_list|(
name|bb_reg_last_uses
argument_list|,
name|space
argument_list|,
name|current_nr_blocks
argument_list|,
name|maxreg
operator|*
sizeof|sizeof
argument_list|(
name|rtx
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|bb_reg_last_sets
operator|=
operator|(
name|rtx
operator|*
operator|*
operator|)
name|alloca
argument_list|(
name|current_nr_blocks
operator|*
sizeof|sizeof
argument_list|(
name|rtx
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|space
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|current_nr_blocks
operator|*
name|maxreg
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|space
argument_list|,
name|current_nr_blocks
operator|*
name|maxreg
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|init_rtx_vector
argument_list|(
name|bb_reg_last_sets
argument_list|,
name|space
argument_list|,
name|current_nr_blocks
argument_list|,
name|maxreg
operator|*
sizeof|sizeof
argument_list|(
name|rtx
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|bb_reg_last_clobbers
operator|=
operator|(
name|rtx
operator|*
operator|*
operator|)
name|alloca
argument_list|(
name|current_nr_blocks
operator|*
sizeof|sizeof
argument_list|(
name|rtx
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|space
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|current_nr_blocks
operator|*
name|maxreg
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|space
argument_list|,
name|current_nr_blocks
operator|*
name|maxreg
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|init_rtx_vector
argument_list|(
name|bb_reg_last_clobbers
argument_list|,
name|space
argument_list|,
name|current_nr_blocks
argument_list|,
name|maxreg
operator|*
sizeof|sizeof
argument_list|(
name|rtx
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|bb_pending_read_insns
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|current_nr_blocks
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|bb_pending_read_mems
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|current_nr_blocks
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|bb_pending_write_insns
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|current_nr_blocks
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|bb_pending_write_mems
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|current_nr_blocks
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|bb_pending_lists_length
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|current_nr_blocks
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|bb_last_pending_memory_flush
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|current_nr_blocks
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|bb_last_function_call
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|current_nr_blocks
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|bb_sched_before_next_call
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|current_nr_blocks
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|init_rgn_data_dependences
argument_list|(
name|current_nr_blocks
argument_list|)
expr_stmt|;
block|}
comment|/* compute LOG_LINKS */
for|for
control|(
name|bb
operator|=
literal|0
init|;
name|bb
operator|<
name|current_nr_blocks
condition|;
name|bb
operator|++
control|)
name|compute_block_backward_dependences
argument_list|(
name|bb
argument_list|)
expr_stmt|;
comment|/* compute INSN_DEPEND */
for|for
control|(
name|bb
operator|=
name|current_nr_blocks
operator|-
literal|1
init|;
name|bb
operator|>=
literal|0
condition|;
name|bb
operator|--
control|)
name|compute_block_forward_dependences
argument_list|(
name|bb
argument_list|)
expr_stmt|;
comment|/* Delete line notes, compute live-regs at block end, and set priorities.  */
name|dead_notes
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|bb
operator|=
literal|0
init|;
name|bb
operator|<
name|current_nr_blocks
condition|;
name|bb
operator|++
control|)
block|{
if|if
condition|(
name|reload_completed
operator|==
literal|0
condition|)
name|find_pre_sched_live
argument_list|(
name|bb
argument_list|)
expr_stmt|;
if|if
condition|(
name|write_symbols
operator|!=
name|NO_DEBUG
condition|)
block|{
name|save_line_notes
argument_list|(
name|bb
argument_list|)
expr_stmt|;
name|rm_line_notes
argument_list|(
name|bb
argument_list|)
expr_stmt|;
block|}
name|rgn_n_insns
operator|+=
name|set_priorities
argument_list|(
name|bb
argument_list|)
expr_stmt|;
block|}
comment|/* compute interblock info: probabilities, split-edges, dominators, etc.  */
if|if
condition|(
name|current_nr_blocks
operator|>
literal|1
condition|)
block|{
name|int
name|i
decl_stmt|;
name|prob
operator|=
operator|(
name|float
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|current_nr_blocks
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|float
argument_list|)
argument_list|)
expr_stmt|;
name|bbset_size
operator|=
name|current_nr_blocks
operator|/
name|HOST_BITS_PER_WIDE_INT
operator|+
literal|1
expr_stmt|;
name|dom
operator|=
operator|(
name|bbset
operator|*
operator|)
name|alloca
argument_list|(
name|current_nr_blocks
operator|*
sizeof|sizeof
argument_list|(
name|bbset
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|current_nr_blocks
condition|;
name|i
operator|++
control|)
block|{
name|dom
index|[
name|i
index|]
operator|=
operator|(
name|bbset
operator|)
name|alloca
argument_list|(
name|bbset_size
operator|*
sizeof|sizeof
argument_list|(
name|HOST_WIDE_INT
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dom
index|[
name|i
index|]
argument_list|,
name|bbset_size
operator|*
sizeof|sizeof
argument_list|(
name|HOST_WIDE_INT
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* edge to bit */
name|rgn_nr_edges
operator|=
literal|0
expr_stmt|;
name|edge_to_bit
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|nr_edges
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nr_edges
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|CONTAINING_RGN
argument_list|(
name|FROM_BLOCK
argument_list|(
name|i
argument_list|)
argument_list|)
operator|==
name|rgn
condition|)
name|EDGE_TO_BIT
argument_list|(
name|i
argument_list|)
operator|=
name|rgn_nr_edges
operator|++
expr_stmt|;
name|rgn_edges
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|rgn_nr_edges
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|rgn_nr_edges
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nr_edges
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|CONTAINING_RGN
argument_list|(
name|FROM_BLOCK
argument_list|(
name|i
argument_list|)
argument_list|)
operator|==
operator|(
name|rgn
operator|)
condition|)
name|rgn_edges
index|[
name|rgn_nr_edges
operator|++
index|]
operator|=
name|i
expr_stmt|;
comment|/* split edges */
name|edgeset_size
operator|=
name|rgn_nr_edges
operator|/
name|HOST_BITS_PER_WIDE_INT
operator|+
literal|1
expr_stmt|;
name|pot_split
operator|=
operator|(
name|edgeset
operator|*
operator|)
name|alloca
argument_list|(
name|current_nr_blocks
operator|*
sizeof|sizeof
argument_list|(
name|edgeset
argument_list|)
argument_list|)
expr_stmt|;
name|ancestor_edges
operator|=
operator|(
name|edgeset
operator|*
operator|)
name|alloca
argument_list|(
name|current_nr_blocks
operator|*
sizeof|sizeof
argument_list|(
name|edgeset
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|current_nr_blocks
condition|;
name|i
operator|++
control|)
block|{
name|pot_split
index|[
name|i
index|]
operator|=
operator|(
name|edgeset
operator|)
name|alloca
argument_list|(
name|edgeset_size
operator|*
sizeof|sizeof
argument_list|(
name|HOST_WIDE_INT
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pot_split
index|[
name|i
index|]
argument_list|,
name|edgeset_size
operator|*
sizeof|sizeof
argument_list|(
name|HOST_WIDE_INT
argument_list|)
argument_list|)
expr_stmt|;
name|ancestor_edges
index|[
name|i
index|]
operator|=
operator|(
name|edgeset
operator|)
name|alloca
argument_list|(
name|edgeset_size
operator|*
sizeof|sizeof
argument_list|(
name|HOST_WIDE_INT
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ancestor_edges
index|[
name|i
index|]
argument_list|,
name|edgeset_size
operator|*
sizeof|sizeof
argument_list|(
name|HOST_WIDE_INT
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* compute probabilities, dominators, split_edges */
for|for
control|(
name|bb
operator|=
literal|0
init|;
name|bb
operator|<
name|current_nr_blocks
condition|;
name|bb
operator|++
control|)
name|compute_dom_prob_ps
argument_list|(
name|bb
argument_list|)
expr_stmt|;
block|}
comment|/* now we can schedule all blocks */
for|for
control|(
name|bb
operator|=
literal|0
init|;
name|bb
operator|<
name|current_nr_blocks
condition|;
name|bb
operator|++
control|)
block|{
name|sched_rgn_n_insns
operator|+=
name|schedule_block
argument_list|(
name|bb
argument_list|,
name|rgn_n_insns
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_C_ALLOCA
name|alloca
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* sanity check: verify that all region insns were scheduled */
if|if
condition|(
name|sched_rgn_n_insns
operator|!=
name|rgn_n_insns
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* update register life and usage information */
if|if
condition|(
name|reload_completed
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|bb
operator|=
name|current_nr_blocks
operator|-
literal|1
init|;
name|bb
operator|>=
literal|0
condition|;
name|bb
operator|--
control|)
name|find_post_sched_live
argument_list|(
name|bb
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_nr_blocks
operator|<=
literal|1
condition|)
comment|/* Sanity check.  There should be no REG_DEAD notes leftover at the end. 	   In practice, this can occur as the result of bugs in flow, combine.c, 	   and/or sched.c.  The values of the REG_DEAD notes remaining are 	   meaningless, because dead_notes is just used as a free list.  */
if|if
condition|(
name|dead_notes
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* restore line notes.  */
if|if
condition|(
name|write_symbols
operator|!=
name|NO_DEBUG
condition|)
block|{
for|for
control|(
name|bb
operator|=
literal|0
init|;
name|bb
operator|<
name|current_nr_blocks
condition|;
name|bb
operator|++
control|)
name|restore_line_notes
argument_list|(
name|bb
argument_list|)
expr_stmt|;
block|}
comment|/* Done with this region */
name|free_pending_lists
argument_list|()
expr_stmt|;
name|FREE_REG_SET
argument_list|(
name|reg_pending_sets
argument_list|)
expr_stmt|;
name|FREE_REG_SET
argument_list|(
name|reg_pending_clobbers
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Subroutine of update_flow_info.  Determines whether any new REG_NOTEs are    needed for the hard register mentioned in the note.  This can happen    if the reference to the hard register in the original insn was split into    several smaller hard register references in the split insns.  */
end_comment

begin_function
specifier|static
name|void
name|split_hard_reg_notes
parameter_list|(
name|note
parameter_list|,
name|first
parameter_list|,
name|last
parameter_list|)
name|rtx
name|note
decl_stmt|,
name|first
decl_stmt|,
name|last
decl_stmt|;
block|{
name|rtx
name|reg
decl_stmt|,
name|temp
decl_stmt|,
name|link
decl_stmt|;
name|int
name|n_regs
decl_stmt|,
name|i
decl_stmt|,
name|new_reg
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
comment|/* Assume that this is a REG_DEAD note.  */
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
operator|!=
name|REG_DEAD
condition|)
name|abort
argument_list|()
expr_stmt|;
name|reg
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|n_regs
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_regs
condition|;
name|i
operator|++
control|)
block|{
name|new_reg
operator|=
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|+
name|i
expr_stmt|;
comment|/* Check for references to new_reg in the split insns.  */
for|for
control|(
name|insn
operator|=
name|last
init|;
condition|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
literal|'i'
operator|&&
operator|(
name|temp
operator|=
name|regno_use_in
argument_list|(
name|new_reg
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|)
condition|)
block|{
comment|/* Create a new reg dead note ere.  */
name|link
operator|=
name|alloc_EXPR_LIST
argument_list|(
name|REG_DEAD
argument_list|,
name|temp
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|link
expr_stmt|;
comment|/* If killed multiple registers here, then add in the excess.  */
name|i
operator|+=
name|HARD_REGNO_NREGS
argument_list|(
name|REGNO
argument_list|(
name|temp
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|temp
argument_list|)
argument_list|)
operator|-
literal|1
expr_stmt|;
break|break;
block|}
comment|/* It isn't mentioned anywhere, so no new reg note is needed for 	     this register.  */
if|if
condition|(
name|insn
operator|==
name|first
condition|)
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Subroutine of update_flow_info.  Determines whether a SET or CLOBBER in an    insn created by splitting needs a REG_DEAD or REG_UNUSED note added.  */
end_comment

begin_function
specifier|static
name|void
name|new_insn_dead_notes
parameter_list|(
name|pat
parameter_list|,
name|insn
parameter_list|,
name|last
parameter_list|,
name|orig_insn
parameter_list|)
name|rtx
name|pat
decl_stmt|,
name|insn
decl_stmt|,
name|last
decl_stmt|,
name|orig_insn
decl_stmt|;
block|{
name|rtx
name|dest
decl_stmt|,
name|tem
decl_stmt|,
name|set
decl_stmt|;
comment|/* PAT is either a CLOBBER or a SET here.  */
name|dest
operator|=
name|XEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|STRICT_LOW_PART
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SIGN_EXTRACT
condition|)
name|dest
operator|=
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
condition|)
block|{
comment|/* If the original insn already used this register, we may not add new          notes for it.  One example for a split that needs this test is 	 when a multi-word memory access with register-indirect addressing 	 is split into multiple memory accesses with auto-increment and 	 one adjusting add instruction for the address register.  */
if|if
condition|(
name|reg_referenced_p
argument_list|(
name|dest
argument_list|,
name|PATTERN
argument_list|(
name|orig_insn
argument_list|)
argument_list|)
condition|)
return|return;
for|for
control|(
name|tem
operator|=
name|last
init|;
name|tem
operator|!=
name|insn
condition|;
name|tem
operator|=
name|PREV_INSN
argument_list|(
name|tem
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|tem
argument_list|)
argument_list|)
operator|==
literal|'i'
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|dest
argument_list|,
name|PATTERN
argument_list|(
name|tem
argument_list|)
argument_list|)
operator|&&
operator|(
name|set
operator|=
name|single_set
argument_list|(
name|tem
argument_list|)
operator|)
condition|)
block|{
name|rtx
name|tem_dest
init|=
name|SET_DEST
argument_list|(
name|set
argument_list|)
decl_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|tem_dest
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|tem_dest
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|tem_dest
argument_list|)
operator|==
name|STRICT_LOW_PART
operator|||
name|GET_CODE
argument_list|(
name|tem_dest
argument_list|)
operator|==
name|SIGN_EXTRACT
condition|)
name|tem_dest
operator|=
name|XEXP
argument_list|(
name|tem_dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rtx_equal_p
argument_list|(
name|tem_dest
argument_list|,
name|dest
argument_list|)
condition|)
block|{
comment|/* Use the same scheme as combine.c, don't put both REG_DEAD 		     and REG_UNUSED notes on the same insn.  */
if|if
condition|(
operator|!
name|find_regno_note
argument_list|(
name|tem
argument_list|,
name|REG_UNUSED
argument_list|,
name|REGNO
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|&&
operator|!
name|find_regno_note
argument_list|(
name|tem
argument_list|,
name|REG_DEAD
argument_list|,
name|REGNO
argument_list|(
name|dest
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|note
init|=
name|alloc_EXPR_LIST
argument_list|(
name|REG_DEAD
argument_list|,
name|dest
argument_list|,
name|REG_NOTES
argument_list|(
name|tem
argument_list|)
argument_list|)
decl_stmt|;
name|REG_NOTES
argument_list|(
name|tem
argument_list|)
operator|=
name|note
expr_stmt|;
block|}
comment|/* The reg only dies in one insn, the last one that uses 		     it.  */
break|break;
block|}
elseif|else
if|if
condition|(
name|reg_overlap_mentioned_p
argument_list|(
name|dest
argument_list|,
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
condition|)
comment|/* We found an instruction that both uses the register, 		   and sets it, so no new REG_NOTE is needed for this set.  */
break|break;
block|}
block|}
comment|/* If this is a set, it must die somewhere, unless it is the dest of          the original insn, and hence is live after the original insn.  Abort          if it isn't supposed to be live after the original insn.           If this is a clobber, then just add a REG_UNUSED note.  */
if|if
condition|(
name|tem
operator|==
name|insn
condition|)
block|{
name|int
name|live_after_orig_insn
init|=
literal|0
decl_stmt|;
name|rtx
name|pattern
init|=
name|PATTERN
argument_list|(
name|orig_insn
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|CLOBBER
condition|)
block|{
name|rtx
name|note
init|=
name|alloc_EXPR_LIST
argument_list|(
name|REG_UNUSED
argument_list|,
name|dest
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
decl_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|note
expr_stmt|;
return|return;
block|}
comment|/* The original insn could have multiple sets, so search the 	     insn for all sets.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|pattern
argument_list|)
operator|==
name|SET
condition|)
block|{
if|if
condition|(
name|reg_overlap_mentioned_p
argument_list|(
name|dest
argument_list|,
name|SET_DEST
argument_list|(
name|pattern
argument_list|)
argument_list|)
condition|)
name|live_after_orig_insn
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|pattern
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|dest
argument_list|,
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
condition|)
name|live_after_orig_insn
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|live_after_orig_insn
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Subroutine of update_flow_info.  Update the value of reg_n_sets for all    registers modified by X.  INC is -1 if the containing insn is being deleted,    and is 1 if the containing insn is a newly generated insn.  */
end_comment

begin_function
specifier|static
name|void
name|update_n_sets
parameter_list|(
name|x
parameter_list|,
name|inc
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|int
name|inc
decl_stmt|;
block|{
name|rtx
name|dest
init|=
name|SET_DEST
argument_list|(
name|x
argument_list|)
decl_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|STRICT_LOW_PART
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SIGN_EXTRACT
condition|)
name|dest
operator|=
name|SUBREG_REG
argument_list|(
name|dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
condition|)
block|{
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|dest
argument_list|)
decl_stmt|;
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|endregno
init|=
name|regno
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
name|regno
init|;
name|i
operator|<
name|endregno
condition|;
name|i
operator|++
control|)
name|REG_N_SETS
argument_list|(
name|i
argument_list|)
operator|+=
name|inc
expr_stmt|;
block|}
else|else
name|REG_N_SETS
argument_list|(
name|regno
argument_list|)
operator|+=
name|inc
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Updates all flow-analysis related quantities (including REG_NOTES) for    the insns from FIRST to LAST inclusive that were created by splitting    ORIG_INSN.  NOTES are the original REG_NOTES.  */
end_comment

begin_function
name|void
name|update_flow_info
parameter_list|(
name|notes
parameter_list|,
name|first
parameter_list|,
name|last
parameter_list|,
name|orig_insn
parameter_list|)
name|rtx
name|notes
decl_stmt|;
name|rtx
name|first
decl_stmt|,
name|last
decl_stmt|;
name|rtx
name|orig_insn
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|,
name|note
decl_stmt|;
name|rtx
name|next
decl_stmt|;
name|rtx
name|orig_dest
decl_stmt|,
name|temp
decl_stmt|;
name|rtx
name|set
decl_stmt|;
comment|/* Get and save the destination set by the original insn.  */
name|orig_dest
operator|=
name|single_set
argument_list|(
name|orig_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|orig_dest
condition|)
name|orig_dest
operator|=
name|SET_DEST
argument_list|(
name|orig_dest
argument_list|)
expr_stmt|;
comment|/* Move REG_NOTES from the original insn to where they now belong.  */
for|for
control|(
name|note
operator|=
name|notes
init|;
name|note
condition|;
name|note
operator|=
name|next
control|)
block|{
name|next
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
condition|)
block|{
case|case
name|REG_DEAD
case|:
case|case
name|REG_UNUSED
case|:
comment|/* Move these notes from the original insn to the last new insn where 	     the register is now set.  */
for|for
control|(
name|insn
operator|=
name|last
init|;
condition|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
literal|'i'
operator|&&
name|reg_mentioned_p
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
block|{
comment|/* If this note refers to a multiple word hard register, it 		     may have been split into several smaller hard register 		     references, so handle it specially.  */
name|temp
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
operator|==
name|REG_DEAD
operator|&&
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|temp
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|HARD_REGNO_NREGS
argument_list|(
name|REGNO
argument_list|(
name|temp
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|temp
argument_list|)
argument_list|)
operator|>
literal|1
condition|)
name|split_hard_reg_notes
argument_list|(
name|note
argument_list|,
name|first
argument_list|,
name|last
argument_list|)
expr_stmt|;
else|else
block|{
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|note
expr_stmt|;
block|}
comment|/* Sometimes need to convert REG_UNUSED notes to REG_DEAD 		     notes.  */
comment|/* ??? This won't handle multiple word registers correctly, 		     but should be good enough for now.  */
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
operator|==
name|REG_UNUSED
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|SCRATCH
operator|&&
operator|!
name|dead_or_set_p
argument_list|(
name|insn
argument_list|,
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|PUT_REG_NOTE_KIND
argument_list|(
name|note
argument_list|,
name|REG_DEAD
argument_list|)
expr_stmt|;
comment|/* The reg only dies in one insn, the last one that uses 		     it.  */
break|break;
block|}
comment|/* It must die somewhere, fail it we couldn't find where it died.  	         If this is a REG_UNUSED note, then it must be a temporary 	         register that was not needed by this instantiation of the 	         pattern, so we can safely ignore it.  */
if|if
condition|(
name|insn
operator|==
name|first
condition|)
block|{
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
operator|!=
name|REG_UNUSED
condition|)
name|abort
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
break|break;
case|case
name|REG_WAS_0
case|:
comment|/* If the insn that set the register to 0 was deleted, this 	     note cannot be relied on any longer.  The destination might 	     even have been moved to memory.              This was observed for SH4 with execute/920501-6.c compilation, 	     -O2 -fomit-frame-pointer -finline-functions .  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|NOTE
operator|||
name|INSN_DELETED_P
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
break|break;
comment|/* This note applies to the dest of the original insn.  Find the 	     first new insn that now has the same dest, and move the note 	     there.  */
if|if
condition|(
operator|!
name|orig_dest
condition|)
name|abort
argument_list|()
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|first
init|;
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
literal|'i'
operator|&&
operator|(
name|temp
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
operator|)
operator|&&
name|rtx_equal_p
argument_list|(
name|SET_DEST
argument_list|(
name|temp
argument_list|)
argument_list|,
name|orig_dest
argument_list|)
condition|)
block|{
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|note
expr_stmt|;
comment|/* The reg is only zero before one insn, the first that 		     uses it.  */
break|break;
block|}
comment|/* If this note refers to a multiple word hard 		 register, it may have been split into several smaller 		 hard register references.  We could split the notes, 		 but simply dropping them is good enough.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|orig_dest
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|orig_dest
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|HARD_REGNO_NREGS
argument_list|(
name|REGNO
argument_list|(
name|orig_dest
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|orig_dest
argument_list|)
argument_list|)
operator|>
literal|1
condition|)
break|break;
comment|/* It must be set somewhere, fail if we couldn't find where it 	         was set.  */
if|if
condition|(
name|insn
operator|==
name|last
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|REG_EQUAL
case|:
case|case
name|REG_EQUIV
case|:
comment|/* A REG_EQUIV or REG_EQUAL note on an insn with more than one 	     set is meaningless.  Just drop the note.  */
if|if
condition|(
operator|!
name|orig_dest
condition|)
break|break;
case|case
name|REG_NO_CONFLICT
case|:
comment|/* These notes apply to the dest of the original insn.  Find the last 	     new insn that now has the same dest, and move the note there.  */
if|if
condition|(
operator|!
name|orig_dest
condition|)
name|abort
argument_list|()
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|last
init|;
condition|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
literal|'i'
operator|&&
operator|(
name|temp
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
operator|)
operator|&&
name|rtx_equal_p
argument_list|(
name|SET_DEST
argument_list|(
name|temp
argument_list|)
argument_list|,
name|orig_dest
argument_list|)
condition|)
block|{
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|note
expr_stmt|;
comment|/* Only put this note on one of the new insns.  */
break|break;
block|}
comment|/* The original dest must still be set someplace.  Abort if we 	         couldn't find it.  */
if|if
condition|(
name|insn
operator|==
name|first
condition|)
block|{
comment|/* However, if this note refers to a multiple word hard 		     register, it may have been split into several smaller 		     hard register references.  We could split the notes, 		     but simply dropping them is good enough.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|orig_dest
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|orig_dest
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|HARD_REGNO_NREGS
argument_list|(
name|REGNO
argument_list|(
name|orig_dest
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|orig_dest
argument_list|)
argument_list|)
operator|>
literal|1
condition|)
break|break;
comment|/* Likewise for multi-word memory references.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|orig_dest
argument_list|)
operator|==
name|MEM
operator|&&
name|SIZE_FOR_MODE
argument_list|(
name|orig_dest
argument_list|)
operator|>
name|UNITS_PER_WORD
condition|)
break|break;
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
break|break;
case|case
name|REG_LIBCALL
case|:
comment|/* Move a REG_LIBCALL note to the first insn created, and update 	     the corresponding REG_RETVAL note.  */
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
operator|=
name|REG_NOTES
argument_list|(
name|first
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|first
argument_list|)
operator|=
name|note
expr_stmt|;
name|insn
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|note
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_RETVAL
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
if|if
condition|(
name|note
condition|)
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
operator|=
name|first
expr_stmt|;
break|break;
case|case
name|REG_EXEC_COUNT
case|:
comment|/* Move a REG_EXEC_COUNT note to the first insn created.  */
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
operator|=
name|REG_NOTES
argument_list|(
name|first
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|first
argument_list|)
operator|=
name|note
expr_stmt|;
break|break;
case|case
name|REG_RETVAL
case|:
comment|/* Move a REG_RETVAL note to the last insn created, and update 	     the corresponding REG_LIBCALL note.  */
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
operator|=
name|REG_NOTES
argument_list|(
name|last
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|last
argument_list|)
operator|=
name|note
expr_stmt|;
name|insn
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|note
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_LIBCALL
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
if|if
condition|(
name|note
condition|)
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
operator|=
name|last
expr_stmt|;
break|break;
case|case
name|REG_NONNEG
case|:
case|case
name|REG_BR_PROB
case|:
comment|/* This should be moved to whichever instruction is a JUMP_INSN.  */
for|for
control|(
name|insn
operator|=
name|last
init|;
condition|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
block|{
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|note
expr_stmt|;
comment|/* Only put this note on one of the new insns.  */
break|break;
block|}
comment|/* Fail if we couldn't find a JUMP_INSN.  */
if|if
condition|(
name|insn
operator|==
name|first
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|REG_INC
case|:
comment|/* reload sometimes leaves obsolete REG_INC notes around.  */
if|if
condition|(
name|reload_completed
condition|)
break|break;
comment|/* This should be moved to whichever instruction now has the 	     increment operation.  */
name|abort
argument_list|()
expr_stmt|;
case|case
name|REG_LABEL
case|:
comment|/* Should be moved to the new insn(s) which use the label.  */
for|for
control|(
name|insn
operator|=
name|first
init|;
name|insn
operator|!=
name|NEXT_INSN
argument_list|(
name|last
argument_list|)
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
literal|'i'
operator|&&
name|reg_mentioned_p
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
block|{
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|alloc_EXPR_LIST
argument_list|(
name|REG_LABEL
argument_list|,
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|REG_CC_SETTER
case|:
case|case
name|REG_CC_USER
case|:
comment|/* These two notes will never appear until after reorg, so we don't 	     have to handle them here.  */
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* Each new insn created, except the last, has a new set.  If the destination      is a register, then this reg is now live across several insns, whereas      previously the dest reg was born and died within the same insn.  To      reflect this, we now need a REG_DEAD note on the insn where this      dest reg dies.       Similarly, the new insns may have clobbers that need REG_UNUSED notes.  */
for|for
control|(
name|insn
operator|=
name|first
init|;
name|insn
operator|!=
name|last
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|rtx
name|pat
decl_stmt|;
name|int
name|i
decl_stmt|;
name|pat
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|SET
operator|||
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|CLOBBER
condition|)
name|new_insn_dead_notes
argument_list|(
name|pat
argument_list|,
name|insn
argument_list|,
name|last
argument_list|,
name|orig_insn
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|SET
operator|||
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|CLOBBER
condition|)
name|new_insn_dead_notes
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|insn
argument_list|,
name|last
argument_list|,
name|orig_insn
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If any insn, except the last, uses the register set by the last insn,      then we need a new REG_DEAD note on that insn.  In this case, there      would not have been a REG_DEAD note for this register in the original      insn because it was used and set within one insn.  */
name|set
operator|=
name|single_set
argument_list|(
name|last
argument_list|)
expr_stmt|;
if|if
condition|(
name|set
condition|)
block|{
name|rtx
name|dest
init|=
name|SET_DEST
argument_list|(
name|set
argument_list|)
decl_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|STRICT_LOW_PART
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SIGN_EXTRACT
condition|)
name|dest
operator|=
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
comment|/* Global registers are always live, so the code below does not 	     apply to them.  */
operator|&&
operator|(
name|REGNO
argument_list|(
name|dest
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|||
operator|!
name|global_regs
index|[
name|REGNO
argument_list|(
name|dest
argument_list|)
index|]
operator|)
condition|)
block|{
name|rtx
name|stop_insn
init|=
name|PREV_INSN
argument_list|(
name|first
argument_list|)
decl_stmt|;
comment|/* If the last insn uses the register that it is setting, then 	     we don't want to put a REG_DEAD note there.  Search backwards 	     to find the first insn that sets but does not use DEST.  */
name|insn
operator|=
name|last
expr_stmt|;
if|if
condition|(
name|reg_overlap_mentioned_p
argument_list|(
name|dest
argument_list|,
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
condition|)
block|{
for|for
control|(
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
init|;
name|insn
operator|!=
name|first
condition|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
operator|(
name|set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
operator|)
operator|&&
name|reg_mentioned_p
argument_list|(
name|dest
argument_list|,
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|&&
operator|!
name|reg_overlap_mentioned_p
argument_list|(
name|dest
argument_list|,
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
condition|)
break|break;
block|}
block|}
comment|/* Now find the first insn that uses but does not set DEST.  */
for|for
control|(
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
init|;
name|insn
operator|!=
name|stop_insn
condition|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
literal|'i'
operator|&&
name|reg_mentioned_p
argument_list|(
name|dest
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|&&
operator|(
name|set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
operator|)
condition|)
block|{
name|rtx
name|insn_dest
init|=
name|SET_DEST
argument_list|(
name|set
argument_list|)
decl_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|insn_dest
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|insn_dest
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|insn_dest
argument_list|)
operator|==
name|STRICT_LOW_PART
operator|||
name|GET_CODE
argument_list|(
name|insn_dest
argument_list|)
operator|==
name|SIGN_EXTRACT
condition|)
name|insn_dest
operator|=
name|XEXP
argument_list|(
name|insn_dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn_dest
operator|!=
name|dest
condition|)
block|{
name|note
operator|=
name|alloc_EXPR_LIST
argument_list|(
name|REG_DEAD
argument_list|,
name|dest
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|note
expr_stmt|;
comment|/* The reg only dies in one insn, the last one 			 that uses it.  */
break|break;
block|}
block|}
block|}
block|}
block|}
comment|/* If the original dest is modifying a multiple register target, and the      original instruction was split such that the original dest is now set      by two or more SUBREG sets, then the split insns no longer kill the      destination of the original insn.       In this case, if there exists an instruction in the same basic block,      before the split insn, which uses the original dest, and this use is      killed by the original insn, then we must remove the REG_DEAD note on      this insn, because it is now superfluous.       This does not apply when a hard register gets split, because the code      knows how to handle overlapping hard registers properly.  */
if|if
condition|(
name|orig_dest
operator|&&
name|GET_CODE
argument_list|(
name|orig_dest
argument_list|)
operator|==
name|REG
condition|)
block|{
name|int
name|found_orig_dest
init|=
literal|0
decl_stmt|;
name|int
name|found_split_dest
init|=
literal|0
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|first
init|;
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|rtx
name|pat
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* I'm not sure if this can happen, but let's be safe.  */
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
literal|'i'
condition|)
continue|continue;
name|pat
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|i
operator|=
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|PARALLEL
condition|?
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
else|:
literal|0
expr_stmt|;
name|set
operator|=
name|pat
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|set
argument_list|)
operator|==
name|SET
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|REGNO
argument_list|(
name|orig_dest
argument_list|)
condition|)
block|{
name|found_orig_dest
operator|=
literal|1
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
name|SUBREG_REG
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|orig_dest
condition|)
block|{
name|found_split_dest
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|--
name|i
operator|<
literal|0
condition|)
break|break;
name|set
operator|=
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|insn
operator|==
name|last
condition|)
break|break;
block|}
if|if
condition|(
name|found_split_dest
condition|)
block|{
comment|/* Search backwards from FIRST, looking for the first insn that uses 	     the original dest.  Stop if we pass a CODE_LABEL or a JUMP_INSN. 	     If we find an insn, and it has a REG_DEAD note, then delete the 	     note.  */
for|for
control|(
name|insn
operator|=
name|first
init|;
name|insn
condition|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
break|break;
elseif|else
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
literal|'i'
operator|&&
name|reg_mentioned_p
argument_list|(
name|orig_dest
argument_list|,
name|insn
argument_list|)
condition|)
block|{
name|note
operator|=
name|find_regno_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|REGNO
argument_list|(
name|orig_dest
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|note
condition|)
name|remove_note
argument_list|(
name|insn
argument_list|,
name|note
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|found_orig_dest
condition|)
block|{
name|int
name|i
decl_stmt|,
name|regno
decl_stmt|;
comment|/* Should never reach here for a pseudo reg.  */
if|if
condition|(
name|REGNO
argument_list|(
name|orig_dest
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* This can happen for a hard register, if the splitter 	     does not bother to emit instructions which would be no-ops. 	     We try to verify that this is the case by checking to see if 	     the original instruction uses all of the registers that it 	     set.  This case is OK, because deleting a no-op can not affect 	     REG_DEAD notes on other insns.  If this is not the case, then 	     abort.  */
name|regno
operator|=
name|REGNO
argument_list|(
name|orig_dest
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|orig_dest
argument_list|)
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
operator|!
name|refers_to_regno_p
argument_list|(
name|regno
operator|+
name|i
argument_list|,
name|regno
operator|+
name|i
operator|+
literal|1
argument_list|,
name|orig_insn
argument_list|,
name|NULL_PTR
argument_list|)
condition|)
break|break;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* Update reg_n_sets.  This is necessary to prevent local alloc from      converting REG_EQUAL notes to REG_EQUIV when splitting has modified      a reg from set once to set multiple times.  */
block|{
name|rtx
name|x
init|=
name|PATTERN
argument_list|(
name|orig_insn
argument_list|)
decl_stmt|;
name|RTX_CODE
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|SET
operator|||
name|code
operator|==
name|CLOBBER
condition|)
name|update_n_sets
argument_list|(
name|x
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|PARALLEL
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|code
operator|=
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|SET
operator|||
name|code
operator|==
name|CLOBBER
condition|)
name|update_n_sets
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|insn
operator|=
name|first
init|;
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|x
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|SET
operator|||
name|code
operator|==
name|CLOBBER
condition|)
name|update_n_sets
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|PARALLEL
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|code
operator|=
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|SET
operator|||
name|code
operator|==
name|CLOBBER
condition|)
name|update_n_sets
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|insn
operator|==
name|last
condition|)
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* The one entry point in this file.  DUMP_FILE is the dump file for    this pass.  */
end_comment

begin_function
name|void
name|schedule_insns
parameter_list|(
name|dump_file
parameter_list|)
name|FILE
modifier|*
name|dump_file
decl_stmt|;
block|{
name|int
name|max_uid
decl_stmt|;
name|int
name|b
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|int
name|rgn
decl_stmt|;
name|int
name|luid
decl_stmt|;
comment|/* disable speculative loads in their presence if cc0 defined */
ifdef|#
directive|ifdef
name|HAVE_cc0
name|flag_schedule_speculative_load
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* Taking care of this degenerate case makes the rest of      this code simpler.  */
if|if
condition|(
name|n_basic_blocks
operator|==
literal|0
condition|)
return|return;
comment|/* set dump and sched_verbose for the desired debugging output.  If no      dump-file was specified, but -fsched-verbose-N (any N), print to stderr.      For -fsched-verbose-N, N>=10, print everything to stderr.  */
name|sched_verbose
operator|=
name|sched_verbose_param
expr_stmt|;
if|if
condition|(
name|sched_verbose_param
operator|==
literal|0
operator|&&
name|dump_file
condition|)
name|sched_verbose
operator|=
literal|1
expr_stmt|;
name|dump
operator|=
operator|(
operator|(
name|sched_verbose_param
operator|>=
literal|10
operator|||
operator|!
name|dump_file
operator|)
condition|?
name|stderr
else|:
name|dump_file
operator|)
expr_stmt|;
name|nr_inter
operator|=
literal|0
expr_stmt|;
name|nr_spec
operator|=
literal|0
expr_stmt|;
comment|/* Initialize the unused_*_lists.  We can't use the ones left over from      the previous function, because gcc has freed that memory.  We can use      the ones left over from the first sched pass in the second pass however,      so only clear them on the first sched pass.  The first pass is before      reload if flag_schedule_insns is set, otherwise it is afterwards.  */
if|if
condition|(
name|reload_completed
operator|==
literal|0
operator|||
operator|!
name|flag_schedule_insns
condition|)
block|{
name|unused_insn_list
operator|=
literal|0
expr_stmt|;
name|unused_expr_list
operator|=
literal|0
expr_stmt|;
block|}
comment|/* initialize issue_rate */
name|issue_rate
operator|=
name|ISSUE_RATE
expr_stmt|;
comment|/* do the splitting first for all blocks */
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|n_basic_blocks
condition|;
name|b
operator|++
control|)
name|split_block_insns
argument_list|(
name|b
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|max_uid
operator|=
operator|(
name|get_max_uid
argument_list|()
operator|+
literal|1
operator|)
expr_stmt|;
name|cant_move
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|max_uid
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cant_move
argument_list|,
name|max_uid
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
name|fed_by_spec_load
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|max_uid
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|fed_by_spec_load
argument_list|,
name|max_uid
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
name|is_load_insn
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|max_uid
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|is_load_insn
argument_list|,
name|max_uid
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
name|insn_orig_block
operator|=
operator|(
name|int
operator|*
operator|)
name|xmalloc
argument_list|(
name|max_uid
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|insn_luid
operator|=
operator|(
name|int
operator|*
operator|)
name|xmalloc
argument_list|(
name|max_uid
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|luid
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|n_basic_blocks
condition|;
name|b
operator|++
control|)
for|for
control|(
name|insn
operator|=
name|BLOCK_HEAD
argument_list|(
name|b
argument_list|)
init|;
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|INSN_BLOCK
argument_list|(
name|insn
argument_list|)
operator|=
name|b
expr_stmt|;
name|INSN_LUID
argument_list|(
name|insn
argument_list|)
operator|=
name|luid
operator|++
expr_stmt|;
if|if
condition|(
name|insn
operator|==
name|BLOCK_END
argument_list|(
name|b
argument_list|)
condition|)
break|break;
block|}
comment|/* after reload, remove inter-blocks dependences computed before reload.  */
if|if
condition|(
name|reload_completed
condition|)
block|{
name|int
name|b
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|n_basic_blocks
condition|;
name|b
operator|++
control|)
for|for
control|(
name|insn
operator|=
name|BLOCK_HEAD
argument_list|(
name|b
argument_list|)
init|;
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|rtx
name|link
decl_stmt|,
name|prev
decl_stmt|;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
literal|'i'
condition|)
block|{
name|prev
operator|=
name|NULL_RTX
expr_stmt|;
name|link
operator|=
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
expr_stmt|;
while|while
condition|(
name|link
condition|)
block|{
name|rtx
name|x
init|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|INSN_BLOCK
argument_list|(
name|x
argument_list|)
operator|!=
name|b
condition|)
block|{
name|remove_dependence
argument_list|(
name|insn
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|link
operator|=
name|prev
condition|?
name|XEXP
argument_list|(
name|prev
argument_list|,
literal|1
argument_list|)
else|:
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
else|else
name|prev
operator|=
name|link
operator|,
name|link
operator|=
name|XEXP
argument_list|(
name|prev
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|insn
operator|==
name|BLOCK_END
argument_list|(
name|b
argument_list|)
condition|)
break|break;
block|}
block|}
name|nr_regions
operator|=
literal|0
expr_stmt|;
name|rgn_table
operator|=
operator|(
name|region
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|n_basic_blocks
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|region
argument_list|)
argument_list|)
expr_stmt|;
name|rgn_bb_table
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|n_basic_blocks
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|block_to_bb
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|n_basic_blocks
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|containing_rgn
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|n_basic_blocks
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
comment|/* compute regions for scheduling */
if|if
condition|(
name|reload_completed
operator|||
name|n_basic_blocks
operator|==
literal|1
operator|||
operator|!
name|flag_schedule_interblock
condition|)
block|{
name|find_single_block_region
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/* verify that a 'good' control flow graph can be built */
if|if
condition|(
name|is_cfg_nonregular
argument_list|()
condition|)
block|{
name|find_single_block_region
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|int_list_ptr
modifier|*
name|s_preds
decl_stmt|,
modifier|*
name|s_succs
decl_stmt|;
name|int
modifier|*
name|num_preds
decl_stmt|,
modifier|*
name|num_succs
decl_stmt|;
name|sbitmap
modifier|*
name|dom
decl_stmt|,
modifier|*
name|pdom
decl_stmt|;
name|s_preds
operator|=
operator|(
name|int_list_ptr
operator|*
operator|)
name|alloca
argument_list|(
name|n_basic_blocks
operator|*
sizeof|sizeof
argument_list|(
name|int_list_ptr
argument_list|)
argument_list|)
expr_stmt|;
name|s_succs
operator|=
operator|(
name|int_list_ptr
operator|*
operator|)
name|alloca
argument_list|(
name|n_basic_blocks
operator|*
sizeof|sizeof
argument_list|(
name|int_list_ptr
argument_list|)
argument_list|)
expr_stmt|;
name|num_preds
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|n_basic_blocks
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|num_succs
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|n_basic_blocks
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|dom
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|n_basic_blocks
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|pdom
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|n_basic_blocks
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
comment|/* The scheduler runs after flow; therefore, we can't blindly call 	     back into find_basic_blocks since doing so could invalidate the 	     info in global_live_at_start.  	     Consider a block consisting entirely of dead stores; after life 	     analysis it would be a block of NOTE_INSN_DELETED notes.  If 	     we call find_basic_blocks again, then the block would be removed 	     entirely and invalidate our the register live information.  	     We could (should?) recompute register live information.  Doing 	     so may even be beneficial.  */
name|compute_preds_succs
argument_list|(
name|s_preds
argument_list|,
name|s_succs
argument_list|,
name|num_preds
argument_list|,
name|num_succs
argument_list|)
expr_stmt|;
comment|/* Compute the dominators and post dominators.  We don't currently use 	     post dominators, but we should for speculative motion analysis.  */
name|compute_dominators
argument_list|(
name|dom
argument_list|,
name|pdom
argument_list|,
name|s_preds
argument_list|,
name|s_succs
argument_list|)
expr_stmt|;
comment|/* build_control_flow will return nonzero if it detects unreachable 	     blocks or any other irregularity with the cfg which prevents 	     cross block scheduling.  */
if|if
condition|(
name|build_control_flow
argument_list|(
name|s_preds
argument_list|,
name|s_succs
argument_list|,
name|num_preds
argument_list|,
name|num_succs
argument_list|)
operator|!=
literal|0
condition|)
name|find_single_block_region
argument_list|()
expr_stmt|;
else|else
name|find_rgns
argument_list|(
name|s_preds
argument_list|,
name|s_succs
argument_list|,
name|num_preds
argument_list|,
name|num_succs
argument_list|,
name|dom
argument_list|)
expr_stmt|;
if|if
condition|(
name|sched_verbose
operator|>=
literal|3
condition|)
name|debug_regions
argument_list|()
expr_stmt|;
comment|/* For now.  This will move as more and more of haifa is converted 	     to using the cfg code in flow.c  */
name|free_bb_mem
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|dom
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pdom
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Allocate data for this pass.  See comments, above,      for what these vectors do.       We use xmalloc instead of alloca, because max_uid can be very large      when there is a lot of function inlining.  If we used alloca, we could      exceed stack limits on some hosts for some inputs.  */
name|insn_priority
operator|=
operator|(
name|int
operator|*
operator|)
name|xmalloc
argument_list|(
name|max_uid
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|insn_reg_weight
operator|=
operator|(
name|int
operator|*
operator|)
name|xmalloc
argument_list|(
name|max_uid
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|insn_tick
operator|=
operator|(
name|int
operator|*
operator|)
name|xmalloc
argument_list|(
name|max_uid
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|insn_costs
operator|=
operator|(
name|short
operator|*
operator|)
name|xmalloc
argument_list|(
name|max_uid
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
name|insn_units
operator|=
operator|(
name|short
operator|*
operator|)
name|xmalloc
argument_list|(
name|max_uid
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
name|insn_blockage
operator|=
operator|(
name|unsigned
name|int
operator|*
operator|)
name|xmalloc
argument_list|(
name|max_uid
operator|*
expr|sizeof
operator|(
name|unsigned
name|int
operator|)
argument_list|)
expr_stmt|;
name|insn_ref_count
operator|=
operator|(
name|int
operator|*
operator|)
name|xmalloc
argument_list|(
name|max_uid
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Allocate for forward dependencies */
name|insn_dep_count
operator|=
operator|(
name|int
operator|*
operator|)
name|xmalloc
argument_list|(
name|max_uid
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|insn_depend
operator|=
operator|(
name|rtx
operator|*
operator|)
name|xmalloc
argument_list|(
name|max_uid
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|reload_completed
operator|==
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
name|sched_reg_n_calls_crossed
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|sched_reg_live_length
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|sched_reg_basic_block
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|bb_live_regs
operator|=
name|ALLOCA_REG_SET
argument_list|()
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sched_reg_n_calls_crossed
argument_list|,
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sched_reg_live_length
argument_list|,
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_regno
condition|;
name|i
operator|++
control|)
name|sched_reg_basic_block
index|[
name|i
index|]
operator|=
name|REG_BLOCK_UNKNOWN
expr_stmt|;
block|}
else|else
block|{
name|sched_reg_n_calls_crossed
operator|=
literal|0
expr_stmt|;
name|sched_reg_live_length
operator|=
literal|0
expr_stmt|;
name|bb_live_regs
operator|=
literal|0
expr_stmt|;
block|}
name|init_alias_analysis
argument_list|()
expr_stmt|;
if|if
condition|(
name|write_symbols
operator|!=
name|NO_DEBUG
condition|)
block|{
name|rtx
name|line
decl_stmt|;
name|line_note
operator|=
operator|(
name|rtx
operator|*
operator|)
name|xmalloc
argument_list|(
name|max_uid
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|line_note
argument_list|,
name|max_uid
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|line_note_head
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|n_basic_blocks
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|line_note_head
argument_list|,
name|n_basic_blocks
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Save-line-note-head:          Determine the line-number at the start of each basic block.          This must be computed and saved now, because after a basic block's          predecessor has been scheduled, it is impossible to accurately          determine the correct line number for the first insn of the block.  */
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|n_basic_blocks
condition|;
name|b
operator|++
control|)
for|for
control|(
name|line
operator|=
name|BLOCK_HEAD
argument_list|(
name|b
argument_list|)
init|;
name|line
condition|;
name|line
operator|=
name|PREV_INSN
argument_list|(
name|line
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|line
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|line
argument_list|)
operator|>
literal|0
condition|)
block|{
name|line_note_head
index|[
name|b
index|]
operator|=
name|line
expr_stmt|;
break|break;
block|}
block|}
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|insn_priority
argument_list|,
name|max_uid
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|insn_reg_weight
argument_list|,
name|max_uid
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|insn_tick
argument_list|,
name|max_uid
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|insn_costs
argument_list|,
name|max_uid
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|insn_units
argument_list|,
name|max_uid
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|insn_blockage
argument_list|,
name|max_uid
operator|*
expr|sizeof
operator|(
name|unsigned
name|int
operator|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|insn_ref_count
argument_list|,
name|max_uid
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Initialize for forward dependencies */
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|insn_depend
argument_list|,
name|max_uid
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|insn_dep_count
argument_list|,
name|max_uid
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Find units used in this fuction, for visualization */
if|if
condition|(
name|sched_verbose
condition|)
name|init_target_units
argument_list|()
expr_stmt|;
comment|/* ??? Add a NOTE after the last insn of the last basic block.  It is not      known why this is done.  */
name|insn
operator|=
name|BLOCK_END
argument_list|(
name|n_basic_blocks
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
operator|==
literal|0
operator|||
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|CODE_LABEL
comment|/* Don't emit a NOTE if it would end up between an unconditional 	     jump and a BARRIER.  */
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|GET_CODE
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|BARRIER
operator|)
operator|)
condition|)
name|emit_note_after
argument_list|(
name|NOTE_INSN_DELETED
argument_list|,
name|BLOCK_END
argument_list|(
name|n_basic_blocks
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Schedule every region in the subroutine */
for|for
control|(
name|rgn
operator|=
literal|0
init|;
name|rgn
operator|<
name|nr_regions
condition|;
name|rgn
operator|++
control|)
block|{
name|schedule_region
argument_list|(
name|rgn
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_C_ALLOCA
name|alloca
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Reposition the prologue and epilogue notes in case we moved the      prologue/epilogue insns.  */
if|if
condition|(
name|reload_completed
condition|)
name|reposition_prologue_and_epilogue_notes
argument_list|(
name|get_insns
argument_list|()
argument_list|)
expr_stmt|;
comment|/* delete redundant line notes.  */
if|if
condition|(
name|write_symbols
operator|!=
name|NO_DEBUG
condition|)
name|rm_redundant_line_notes
argument_list|()
expr_stmt|;
comment|/* Update information about uses of registers in the subroutine.  */
if|if
condition|(
name|reload_completed
operator|==
literal|0
condition|)
name|update_reg_usage
argument_list|()
expr_stmt|;
if|if
condition|(
name|sched_verbose
condition|)
block|{
if|if
condition|(
name|reload_completed
operator|==
literal|0
operator|&&
name|flag_schedule_interblock
condition|)
block|{
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|"\n;; Procedure interblock/speculative motions == %d/%d \n"
argument_list|,
name|nr_inter
argument_list|,
name|nr_spec
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|nr_inter
operator|>
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|"\n\n"
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|cant_move
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fed_by_spec_load
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|is_load_insn
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|insn_orig_block
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|insn_luid
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|insn_priority
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|insn_reg_weight
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|insn_tick
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|insn_costs
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|insn_units
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|insn_blockage
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|insn_ref_count
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|insn_dep_count
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|insn_depend
argument_list|)
expr_stmt|;
if|if
condition|(
name|write_symbols
operator|!=
name|NO_DEBUG
condition|)
name|free
argument_list|(
name|line_note
argument_list|)
expr_stmt|;
if|if
condition|(
name|bb_live_regs
condition|)
name|FREE_REG_SET
argument_list|(
name|bb_live_regs
argument_list|)
expr_stmt|;
if|if
condition|(
name|edge_table
condition|)
block|{
name|free
argument_list|(
name|edge_table
argument_list|)
expr_stmt|;
name|edge_table
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|in_edges
condition|)
block|{
name|free
argument_list|(
name|in_edges
argument_list|)
expr_stmt|;
name|in_edges
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|out_edges
condition|)
block|{
name|free
argument_list|(
name|out_edges
argument_list|)
expr_stmt|;
name|out_edges
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INSN_SCHEDULING */
end_comment

end_unit

