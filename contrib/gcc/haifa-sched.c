begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Instruction scheduling pass.    Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.    Contributed by Michael Tiemann (tiemann@cygnus.com) Enhanced by,    and currently maintained by, Jim Wilson (wilson@cygnus.com)  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* Instruction scheduling pass.  This file, along with sched-deps.c,    contains the generic parts.  The actual entry point is found for    the normal instruction scheduling pass is found in sched-rgn.c.     We compute insn priorities based on data dependencies.  Flow    analysis only creates a fraction of the data-dependencies we must    observe: namely, only those dependencies which the combiner can be    expected to use.  For this pass, we must therefore create the    remaining dependencies we need to observe: register dependencies,    memory dependencies, dependencies to keep function calls in order,    and the dependence between a conditional branch and the setting of    condition codes are all dealt with here.     The scheduler first traverses the data flow graph, starting with    the last instruction, and proceeding to the first, assigning values    to insn_priority as it goes.  This sorts the instructions    topologically by data dependence.     Once priorities have been established, we order the insns using    list scheduling.  This works as follows: starting with a list of    all the ready insns, and sorted according to priority number, we    schedule the insn from the end of the list by placing its    predecessors in the list according to their priority order.  We    consider this insn scheduled by setting the pointer to the "end" of    the list to point to the previous insn.  When an insn has no    predecessors, we either queue it until sufficient time has elapsed    or add it to the ready list.  As the instructions are scheduled or    when stalls are introduced, the queue advances and dumps insns into    the ready list.  When all insns down to the lowest priority have    been scheduled, the critical path of the basic block has been made    as short as possible.  The remaining insns are then scheduled in    remaining slots.     Function unit conflicts are resolved during forward list scheduling    by tracking the time when each insn is committed to the schedule    and from that, the time the function units it uses must be free.    As insns on the ready list are considered for scheduling, those    that would result in a blockage of the already committed insns are    queued until no blockage will result.     The following list shows the order in which we want to break ties    among insns in the ready list:     1.  choose insn with the longest path to end of bb, ties    broken by    2.  choose insn with least contribution to register pressure,    ties broken by    3.  prefer in-block upon interblock motion, ties broken by    4.  prefer useful upon speculative motion, ties broken by    5.  choose insn with largest control flow probability, ties    broken by    6.  choose insn with the least dependences upon the previously    scheduled insn, or finally    7   choose the insn which has the most insns dependent on it.    8.  choose insn with lowest UID.     Memory references complicate matters.  Only if we can be certain    that memory references are not part of the data dependency graph    (via true, anti, or output dependence), can we move operations past    memory references.  To first approximation, reads can be done    independently, while writes introduce dependencies.  Better    approximations will yield fewer dependencies.     Before reload, an extended analysis of interblock data dependences    is required for interblock scheduling.  This is performed in    compute_block_backward_dependences ().     Dependencies set up by memory references are treated in exactly the    same way as other dependencies, by using LOG_LINKS backward    dependences.  LOG_LINKS are translated into INSN_DEPEND forward    dependences for the purpose of forward list scheduling.     Having optimized the critical path, we may have also unduly    extended the lifetimes of some registers.  If an operation requires    that constants be loaded into registers, it is certainly desirable    to load those constants as early as necessary, but no earlier.    I.e., it will not do to load up a bunch of registers at the    beginning of a basic block only to use them at the end, if they    could be loaded later, since this may result in excessive register    utilization.     Note that since branches are never in basic blocks, but only end    basic blocks, this pass will not move branches.  But that is ok,    since we can use GNU's delayed branch scheduling pass to take care    of this case.     Also note that no further optimizations based on algebraic    identities are performed, so this pass would be a good one to    perform instruction splitting, such as breaking up a multiply    instruction into shifts and adds where that is profitable.     Given the memory aliasing analysis that this pass should perform,    it should be possible to remove redundant stores to memory, and to    load values from registers instead of hitting memory.     Before reload, speculative insns are moved only if a 'proof' exists    that no exception will be caused by this, and if no live registers    exist that inhibit the motion (live registers constraints are not    represented by data dependence edges).     This pass must update information that subsequent passes expect to    be correct.  Namely: reg_n_refs, reg_n_sets, reg_n_deaths,    reg_n_calls_crossed, and reg_live_length.  Also, BB_HEAD, BB_END.     The information in the line number notes is carefully retained by    this pass.  Notes that refer to the starting and ending of    exception regions are also carefully retained by this pass.  All    other NOTE insns are grouped in their same relative order at the    beginning of basic blocks and regions that have been scheduled.  */
end_comment

begin_escape
end_escape

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"insn-attr.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"sched-int.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INSN_SCHEDULING
end_ifdef

begin_comment
comment|/* issue_rate is the number of insns that can be scheduled in the same    machine cycle.  It can be defined in the config/mach/mach.h file,    otherwise we set it to 1.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|issue_rate
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If the following variable value is nonzero, the scheduler inserts    bubbles (nop insns).  The value of variable affects on scheduler    behavior only if automaton pipeline interface with multipass    scheduling is used and hook dfa_bubble is defined.  */
end_comment

begin_decl_stmt
name|int
name|insert_schedule_bubbles_p
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* sched-verbose controls the amount of debugging output the    scheduler prints.  It is controlled by -fsched-verbose=N:    N>0 and no -DSR : the output is directed to stderr.    N>=10 will direct the printouts to stderr (regardless of -dSR).    N=1: same as -dSR.    N=2: bb's probabilities, detailed ready list info, unit/insn info.    N=3: rtl at abort point, control-flow, regions info.    N=5: dependences info.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|sched_verbose_param
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|sched_verbose
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Debugging file.  All printouts are sent to dump, which is always set,    either to stderr, or to the dump listing file (-dRS).  */
end_comment

begin_decl_stmt
name|FILE
modifier|*
name|sched_dump
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Highest uid before scheduling.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|old_max_uid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* fix_sched_param() is called from toplev.c upon detection    of the -fsched-verbose=N option.  */
end_comment

begin_function
name|void
name|fix_sched_param
parameter_list|(
specifier|const
name|char
modifier|*
name|param
parameter_list|,
specifier|const
name|char
modifier|*
name|val
parameter_list|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|param
argument_list|,
literal|"verbose"
argument_list|)
condition|)
name|sched_verbose_param
operator|=
name|atoi
argument_list|(
name|val
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
literal|"fix_sched_param: unknown param: %s"
argument_list|,
name|param
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|struct
name|haifa_insn_data
modifier|*
name|h_i_d
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|LINE_NOTE
parameter_list|(
name|INSN
parameter_list|)
value|(h_i_d[INSN_UID (INSN)].line_note)
end_define

begin_define
define|#
directive|define
name|INSN_TICK
parameter_list|(
name|INSN
parameter_list|)
value|(h_i_d[INSN_UID (INSN)].tick)
end_define

begin_comment
comment|/* Vector indexed by basic block number giving the starting line-number    for each basic block.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
modifier|*
name|line_note_head
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List of important notes we must keep around.  This is a pointer to the    last element in the list.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|note_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Queues, etc.  */
end_comment

begin_comment
comment|/* An instruction is ready to be scheduled when all insns preceding it    have already been scheduled.  It is important to ensure that all    insns which use its result will not be executed until its result    has been computed.  An insn is maintained in one of four structures:     (P) the "Pending" set of insns which cannot be scheduled until    their dependencies have been satisfied.    (Q) the "Queued" set of insns that can be scheduled when sufficient    time has passed.    (R) the "Ready" list of unscheduled, uncommitted insns.    (S) the "Scheduled" list of insns.     Initially, all insns are either "Pending" or "Ready" depending on    whether their dependencies are satisfied.     Insns move from the "Ready" list to the "Scheduled" list as they    are committed to the schedule.  As this occurs, the insns in the    "Pending" list have their dependencies satisfied and move to either    the "Ready" list or the "Queued" set depending on whether    sufficient time has passed to make them ready.  As time passes,    insns move from the "Queued" set to the "Ready" list.  Insns may    move from the "Ready" list to the "Queued" set if they are blocked    due to a function unit conflict.     The "Pending" list (P) are the insns in the INSN_DEPEND of the unscheduled    insns, i.e., those that are ready, queued, and pending.    The "Queued" set (Q) is implemented by the variable `insn_queue'.    The "Ready" list (R) is implemented by the variables `ready' and    `n_ready'.    The "Scheduled" list (S) is the new insn chain built by this pass.     The transition (R->S) is implemented in the scheduling loop in    `schedule_block' when the best insn to schedule is chosen.    The transition (R->Q) is implemented in `queue_insn' when an    insn is found to have a function unit conflict with the already    committed insns.    The transitions (P->R and P->Q) are implemented in `schedule_insn' as    insns move from the ready list to the scheduled list.    The transition (Q->R) is implemented in 'queue_to_insn' as time    passes or stalls are introduced.  */
end_comment

begin_comment
comment|/* Implement a circular buffer to delay instructions until sufficient    time has passed.  For the old pipeline description interface,    INSN_QUEUE_SIZE is a power of two larger than MAX_BLOCKAGE and    MAX_READY_COST computed by genattr.c.  For the new pipeline    description interface, MAX_INSN_QUEUE_INDEX is a power of two minus    one which is larger than maximal time of instruction execution    computed by genattr.c on the base maximal time of functional unit    reservations and geting a result.  This is the longest time an    insn may be queued.  */
end_comment

begin_define
define|#
directive|define
name|MAX_INSN_QUEUE_INDEX
value|max_insn_queue_index_macro_value
end_define

begin_decl_stmt
specifier|static
name|rtx
modifier|*
name|insn_queue
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|q_ptr
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|q_size
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NEXT_Q
parameter_list|(
name|X
parameter_list|)
value|(((X)+1)& MAX_INSN_QUEUE_INDEX)
end_define

begin_define
define|#
directive|define
name|NEXT_Q_AFTER
parameter_list|(
name|X
parameter_list|,
name|C
parameter_list|)
value|(((X)+C)& MAX_INSN_QUEUE_INDEX)
end_define

begin_comment
comment|/* The following variable defines value for macro    MAX_INSN_QUEUE_INDEX.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|max_insn_queue_index_macro_value
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The following variable value refers for all current and future    reservations of the processor units.  */
end_comment

begin_decl_stmt
name|state_t
name|curr_state
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The following variable value is size of memory representing all    current and future reservations of the processor units.  It is used    only by DFA based scheduler.  */
end_comment

begin_decl_stmt
specifier|static
name|size_t
name|dfa_state_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The following array is used to find the best insn from ready when    the automaton pipeline interface is used.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|ready_try
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Describe the ready list of the scheduler.    VEC holds space enough for all insns in the current region.  VECLEN    says how many exactly.    FIRST is the index of the element with the highest priority; i.e. the    last one in the ready list, since elements are ordered by ascending    priority.    N_READY determines how many insns are on the ready list.  */
end_comment

begin_struct
struct|struct
name|ready_list
block|{
name|rtx
modifier|*
name|vec
decl_stmt|;
name|int
name|veclen
decl_stmt|;
name|int
name|first
decl_stmt|;
name|int
name|n_ready
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|int
name|may_trap_exp
parameter_list|(
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Nonzero iff the address is comprised from at most 1 register.  */
end_comment

begin_define
define|#
directive|define
name|CONST_BASED_ADDRESS_P
parameter_list|(
name|x
parameter_list|)
define|\
value|(GET_CODE (x) == REG					\    || ((GET_CODE (x) == PLUS || GET_CODE (x) == MINUS	\ 	|| (GET_CODE (x) == LO_SUM))			\&& (CONSTANT_P (XEXP (x, 0))			\ 	   || CONSTANT_P (XEXP (x, 1)))))
end_define

begin_comment
comment|/* Returns a class that insn with GET_DEST(insn)=x may belong to,    as found by analyzing insn's expression.  */
end_comment

begin_function
specifier|static
name|int
name|may_trap_exp
parameter_list|(
name|rtx
name|x
parameter_list|,
name|int
name|is_store
parameter_list|)
block|{
name|enum
name|rtx_code
name|code
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return
name|TRAP_FREE
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_store
condition|)
block|{
if|if
condition|(
name|code
operator|==
name|MEM
operator|&&
name|may_trap_p
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|TRAP_RISKY
return|;
else|else
return|return
name|TRAP_FREE
return|;
block|}
if|if
condition|(
name|code
operator|==
name|MEM
condition|)
block|{
comment|/* The insn uses memory:  a volatile load.  */
if|if
condition|(
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|IRISKY
return|;
comment|/* An exception-free load.  */
if|if
condition|(
operator|!
name|may_trap_p
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|IFREE
return|;
comment|/* A load with 1 base register, to be further checked.  */
if|if
condition|(
name|CONST_BASED_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|PFREE_CANDIDATE
return|;
comment|/* No info on the load, to be further checked.  */
return|return
name|PRISKY_CANDIDATE
return|;
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|i
decl_stmt|,
name|insn_class
init|=
name|TRAP_FREE
decl_stmt|;
comment|/* Neither store nor load, check if it may cause a trap.  */
if|if
condition|(
name|may_trap_p
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|TRAP_RISKY
return|;
comment|/* Recursive step: walk the insn...  */
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
name|int
name|tmp_class
init|=
name|may_trap_exp
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|is_store
argument_list|)
decl_stmt|;
name|insn_class
operator|=
name|WORST_CLASS
argument_list|(
name|insn_class
argument_list|,
name|tmp_class
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
name|int
name|tmp_class
init|=
name|may_trap_exp
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|is_store
argument_list|)
decl_stmt|;
name|insn_class
operator|=
name|WORST_CLASS
argument_list|(
name|insn_class
argument_list|,
name|tmp_class
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn_class
operator|==
name|TRAP_RISKY
operator|||
name|insn_class
operator|==
name|IRISKY
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|insn_class
operator|==
name|TRAP_RISKY
operator|||
name|insn_class
operator|==
name|IRISKY
condition|)
break|break;
block|}
return|return
name|insn_class
return|;
block|}
block|}
end_function

begin_comment
comment|/* Classifies insn for the purpose of verifying that it can be    moved speculatively, by examining it's patterns, returning:    TRAP_RISKY: store, or risky non-load insn (e.g. division by variable).    TRAP_FREE: non-load insn.    IFREE: load from a globally safe location.    IRISKY: volatile load.    PFREE_CANDIDATE, PRISKY_CANDIDATE: load that need to be checked for    being either PFREE or PRISKY.  */
end_comment

begin_function
name|int
name|haifa_classify_insn
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|int
name|tmp_class
init|=
name|TRAP_FREE
decl_stmt|;
name|int
name|insn_class
init|=
name|TRAP_FREE
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
name|int
name|i
decl_stmt|,
name|len
init|=
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
name|len
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|code
operator|=
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CLOBBER
case|:
comment|/* Test if it is a 'store'.  */
name|tmp_class
operator|=
name|may_trap_exp
argument_list|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|SET
case|:
comment|/* Test if it is a store.  */
name|tmp_class
operator|=
name|may_trap_exp
argument_list|(
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp_class
operator|==
name|TRAP_RISKY
condition|)
break|break;
comment|/* Test if it is a load.  */
name|tmp_class
operator|=
name|WORST_CLASS
argument_list|(
name|tmp_class
argument_list|,
name|may_trap_exp
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|COND_EXEC
case|:
case|case
name|TRAP_IF
case|:
name|tmp_class
operator|=
name|TRAP_RISKY
expr_stmt|;
break|break;
default|default:
empty_stmt|;
block|}
name|insn_class
operator|=
name|WORST_CLASS
argument_list|(
name|insn_class
argument_list|,
name|tmp_class
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn_class
operator|==
name|TRAP_RISKY
operator|||
name|insn_class
operator|==
name|IRISKY
condition|)
break|break;
block|}
block|}
else|else
block|{
name|code
operator|=
name|GET_CODE
argument_list|(
name|pat
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CLOBBER
case|:
comment|/* Test if it is a 'store'.  */
name|tmp_class
operator|=
name|may_trap_exp
argument_list|(
name|XEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|SET
case|:
comment|/* Test if it is a store.  */
name|tmp_class
operator|=
name|may_trap_exp
argument_list|(
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp_class
operator|==
name|TRAP_RISKY
condition|)
break|break;
comment|/* Test if it is a load.  */
name|tmp_class
operator|=
name|WORST_CLASS
argument_list|(
name|tmp_class
argument_list|,
name|may_trap_exp
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|COND_EXEC
case|:
case|case
name|TRAP_IF
case|:
name|tmp_class
operator|=
name|TRAP_RISKY
expr_stmt|;
break|break;
default|default:
empty_stmt|;
block|}
name|insn_class
operator|=
name|tmp_class
expr_stmt|;
block|}
return|return
name|insn_class
return|;
block|}
end_function

begin_comment
comment|/* Forward declarations.  */
end_comment

begin_comment
comment|/* The scheduler using only DFA description should never use the    following five functions:  */
end_comment

begin_function_decl
specifier|static
name|unsigned
name|int
name|blockage_range
parameter_list|(
name|int
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|clear_units
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|schedule_unit
parameter_list|(
name|int
parameter_list|,
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|actual_hazard
parameter_list|(
name|int
parameter_list|,
name|rtx
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|potential_hazard
parameter_list|(
name|int
parameter_list|,
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|priority
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rank_for_schedule
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|swap_sort
parameter_list|(
name|rtx
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|queue_insn
parameter_list|(
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|schedule_insn
parameter_list|(
name|rtx
parameter_list|,
name|struct
name|ready_list
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|find_set_reg_weight
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|find_insn_reg_weight
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|adjust_priority
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|advance_one_cycle
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Notes handling mechanism:    =========================    Generally, NOTES are saved before scheduling and restored after scheduling.    The scheduler distinguishes between three types of notes:     (1) LINE_NUMBER notes, generated and used for debugging.  Here,    before scheduling a region, a pointer to the LINE_NUMBER note is    added to the insn following it (in save_line_notes()), and the note    is removed (in rm_line_notes() and unlink_line_notes()).  After    scheduling the region, this pointer is used for regeneration of    the LINE_NUMBER note (in restore_line_notes()).     (2) LOOP_BEGIN, LOOP_END, SETJMP, EHREGION_BEG, EHREGION_END notes:    Before scheduling a region, a pointer to the note is added to the insn    that follows or precedes it.  (This happens as part of the data dependence    computation).  After scheduling an insn, the pointer contained in it is    used for regenerating the corresponding note (in reemit_notes).     (3) All other notes (e.g. INSN_DELETED):  Before scheduling a block,    these notes are put in a list (in rm_other_notes() and    unlink_other_notes ()).  After scheduling the block, these notes are    inserted at the beginning of the block (in schedule_block()).  */
end_comment

begin_function_decl
specifier|static
name|rtx
name|unlink_other_notes
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|unlink_line_notes
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|reemit_notes
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
modifier|*
name|ready_lastpos
parameter_list|(
name|struct
name|ready_list
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ready_sort
parameter_list|(
name|struct
name|ready_list
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|ready_remove_first
parameter_list|(
name|struct
name|ready_list
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|queue_to_ready
parameter_list|(
name|struct
name|ready_list
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|early_queue_to_ready
parameter_list|(
name|state_t
parameter_list|,
name|struct
name|ready_list
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|debug_ready_list
parameter_list|(
name|struct
name|ready_list
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|move_insn1
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|move_insn
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* The following functions are used to implement multi-pass scheduling    on the first cycle.  It is used only for DFA based scheduler.  */
end_comment

begin_function_decl
specifier|static
name|rtx
name|ready_element
parameter_list|(
name|struct
name|ready_list
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|ready_remove
parameter_list|(
name|struct
name|ready_list
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|max_issue
parameter_list|(
name|struct
name|ready_list
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|choose_ready
parameter_list|(
name|struct
name|ready_list
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INSN_SCHEDULING */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Point to state used for the current scheduling pass.  */
end_comment

begin_decl_stmt
name|struct
name|sched_info
modifier|*
name|current_sched_info
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_ifndef
ifndef|#
directive|ifndef
name|INSN_SCHEDULING
end_ifndef

begin_function
name|void
name|schedule_insns
parameter_list|(
name|FILE
modifier|*
name|dump_file
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{ }
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* Pointer to the last instruction scheduled.  Used by rank_for_schedule,    so that insns independent of the last scheduled insn will be preferred    over dependent instructions.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|last_scheduled_insn
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Compute the function units used by INSN.  This caches the value    returned by function_units_used.  A function unit is encoded as the    unit number if the value is non-negative and the complement of a    mask if the value is negative.  A function unit index is the    non-negative encoding.  The scheduler using only DFA description    should never use the following function.  */
end_comment

begin_function
name|HAIFA_INLINE
name|int
name|insn_unit
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|int
name|unit
init|=
name|INSN_UNIT
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|unit
operator|==
literal|0
condition|)
block|{
name|recog_memoized
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* A USE insn, or something else we don't need to understand.          We can't pass these directly to function_units_used because it will          trigger a fatal error for unrecognizable insns.  */
if|if
condition|(
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|<
literal|0
condition|)
name|unit
operator|=
operator|-
literal|1
expr_stmt|;
else|else
block|{
name|unit
operator|=
name|function_units_used
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Increment non-negative values so we can cache zero.  */
if|if
condition|(
name|unit
operator|>=
literal|0
condition|)
name|unit
operator|++
expr_stmt|;
block|}
comment|/* We only cache 16 bits of the result, so if the value is out of          range, don't cache it.  */
if|if
condition|(
name|FUNCTION_UNITS_SIZE
operator|<
name|HOST_BITS_PER_SHORT
operator|||
name|unit
operator|>=
literal|0
operator|||
operator|(
name|unit
operator|&
operator|~
operator|(
operator|(
literal|1
operator|<<
operator|(
name|HOST_BITS_PER_SHORT
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
condition|)
name|INSN_UNIT
argument_list|(
name|insn
argument_list|)
operator|=
name|unit
expr_stmt|;
block|}
return|return
operator|(
name|unit
operator|>
literal|0
condition|?
name|unit
operator|-
literal|1
else|:
name|unit
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Compute the blockage range for executing INSN on UNIT.  This caches    the value returned by the blockage_range_function for the unit.    These values are encoded in an int where the upper half gives the    minimum value and the lower half gives the maximum value.  The    scheduler using only DFA description should never use the following    function.  */
end_comment

begin_function
name|HAIFA_INLINE
specifier|static
name|unsigned
name|int
name|blockage_range
parameter_list|(
name|int
name|unit
parameter_list|,
name|rtx
name|insn
parameter_list|)
block|{
name|unsigned
name|int
name|blockage
init|=
name|INSN_BLOCKAGE
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|range
decl_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|UNIT_BLOCKED
argument_list|(
name|blockage
argument_list|)
operator|!=
name|unit
operator|+
literal|1
condition|)
block|{
name|range
operator|=
name|function_units
index|[
name|unit
index|]
operator|.
name|blockage_range_function
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* We only cache the blockage range for one unit and then only if          the values fit.  */
if|if
condition|(
name|HOST_BITS_PER_INT
operator|>=
name|UNIT_BITS
operator|+
literal|2
operator|*
name|BLOCKAGE_BITS
condition|)
name|INSN_BLOCKAGE
argument_list|(
name|insn
argument_list|)
operator|=
name|ENCODE_BLOCKAGE
argument_list|(
name|unit
operator|+
literal|1
argument_list|,
name|range
argument_list|)
expr_stmt|;
block|}
else|else
name|range
operator|=
name|BLOCKAGE_RANGE
argument_list|(
name|blockage
argument_list|)
expr_stmt|;
return|return
name|range
return|;
block|}
end_function

begin_comment
comment|/* A vector indexed by function unit instance giving the last insn to    use the unit.  The value of the function unit instance index for    unit U instance I is (U + I * FUNCTION_UNITS_SIZE).  The scheduler    using only DFA description should never use the following variable.  */
end_comment

begin_if
if|#
directive|if
name|FUNCTION_UNITS_SIZE
end_if

begin_decl_stmt
specifier|static
name|rtx
name|unit_last_insn
index|[
name|FUNCTION_UNITS_SIZE
operator|*
name|MAX_MULTIPLICITY
index|]
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|rtx
name|unit_last_insn
index|[
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* A vector indexed by function unit instance giving the minimum time    when the unit will unblock based on the maximum blockage cost.  The    scheduler using only DFA description should never use the following    variable.  */
end_comment

begin_if
if|#
directive|if
name|FUNCTION_UNITS_SIZE
end_if

begin_decl_stmt
specifier|static
name|int
name|unit_tick
index|[
name|FUNCTION_UNITS_SIZE
operator|*
name|MAX_MULTIPLICITY
index|]
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|int
name|unit_tick
index|[
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* A vector indexed by function unit number giving the number of insns    that remain to use the unit.  The scheduler using only DFA    description should never use the following variable.  */
end_comment

begin_if
if|#
directive|if
name|FUNCTION_UNITS_SIZE
end_if

begin_decl_stmt
specifier|static
name|int
name|unit_n_insns
index|[
name|FUNCTION_UNITS_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|int
name|unit_n_insns
index|[
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Access the unit_last_insn array.  Used by the visualization code.    The scheduler using only DFA description should never use the    following function.  */
end_comment

begin_function
name|rtx
name|get_unit_last_insn
parameter_list|(
name|int
name|instance
parameter_list|)
block|{
return|return
name|unit_last_insn
index|[
name|instance
index|]
return|;
block|}
end_function

begin_comment
comment|/* Reset the function unit state to the null state.  */
end_comment

begin_function
specifier|static
name|void
name|clear_units
parameter_list|(
name|void
parameter_list|)
block|{
name|memset
argument_list|(
name|unit_last_insn
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|unit_last_insn
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|unit_tick
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|unit_tick
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|unit_n_insns
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|unit_n_insns
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the issue-delay of an insn.  The scheduler using only DFA    description should never use the following function.  */
end_comment

begin_function
name|HAIFA_INLINE
name|int
name|insn_issue_delay
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|delay
init|=
literal|0
decl_stmt|;
name|int
name|unit
init|=
name|insn_unit
argument_list|(
name|insn
argument_list|)
decl_stmt|;
comment|/* Efficiency note: in fact, we are working 'hard' to compute a      value that was available in md file, and is not available in      function_units[] structure.  It would be nice to have this      value there, too.  */
if|if
condition|(
name|unit
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|function_units
index|[
name|unit
index|]
operator|.
name|blockage_range_function
operator|&&
name|function_units
index|[
name|unit
index|]
operator|.
name|blockage_function
condition|)
name|delay
operator|=
name|function_units
index|[
name|unit
index|]
operator|.
name|blockage_function
argument_list|(
name|insn
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
else|else
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|unit
operator|=
operator|~
name|unit
init|;
name|unit
condition|;
name|i
operator|++
operator|,
name|unit
operator|>>=
literal|1
control|)
if|if
condition|(
operator|(
name|unit
operator|&
literal|1
operator|)
operator|!=
literal|0
operator|&&
name|function_units
index|[
name|i
index|]
operator|.
name|blockage_range_function
operator|&&
name|function_units
index|[
name|i
index|]
operator|.
name|blockage_function
condition|)
name|delay
operator|=
name|MAX
argument_list|(
name|delay
argument_list|,
name|function_units
index|[
name|i
index|]
operator|.
name|blockage_function
argument_list|(
name|insn
argument_list|,
name|insn
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|delay
return|;
block|}
end_function

begin_comment
comment|/* Return the actual hazard cost of executing INSN on the unit UNIT,    instance INSTANCE at time CLOCK if the previous actual hazard cost    was COST.  The scheduler using only DFA description should never    use the following function.  */
end_comment

begin_function
name|HAIFA_INLINE
name|int
name|actual_hazard_this_instance
parameter_list|(
name|int
name|unit
parameter_list|,
name|int
name|instance
parameter_list|,
name|rtx
name|insn
parameter_list|,
name|int
name|clock
parameter_list|,
name|int
name|cost
parameter_list|)
block|{
name|int
name|tick
init|=
name|unit_tick
index|[
name|instance
index|]
decl_stmt|;
comment|/* Issue time of the last issued insn.  */
if|if
condition|(
name|tick
operator|-
name|clock
operator|>
name|cost
condition|)
block|{
comment|/* The scheduler is operating forward, so unit's last insn is the          executing insn and INSN is the candidate insn.  We want a          more exact measure of the blockage if we execute INSN at CLOCK          given when we committed the execution of the unit's last insn.           The blockage value is given by either the unit's max blockage          constant, blockage range function, or blockage function.  Use          the most exact form for the given unit.  */
if|if
condition|(
name|function_units
index|[
name|unit
index|]
operator|.
name|blockage_range_function
condition|)
block|{
if|if
condition|(
name|function_units
index|[
name|unit
index|]
operator|.
name|blockage_function
condition|)
name|tick
operator|+=
operator|(
name|function_units
index|[
name|unit
index|]
operator|.
name|blockage_function
argument_list|(
name|unit_last_insn
index|[
name|instance
index|]
argument_list|,
name|insn
argument_list|)
operator|-
name|function_units
index|[
name|unit
index|]
operator|.
name|max_blockage
operator|)
expr_stmt|;
else|else
name|tick
operator|+=
operator|(
operator|(
name|int
operator|)
name|MAX_BLOCKAGE_COST
argument_list|(
name|blockage_range
argument_list|(
name|unit
argument_list|,
name|insn
argument_list|)
argument_list|)
operator|-
name|function_units
index|[
name|unit
index|]
operator|.
name|max_blockage
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|tick
operator|-
name|clock
operator|>
name|cost
condition|)
name|cost
operator|=
name|tick
operator|-
name|clock
expr_stmt|;
block|}
return|return
name|cost
return|;
block|}
end_function

begin_comment
comment|/* Record INSN as having begun execution on the units encoded by UNIT    at time CLOCK.  The scheduler using only DFA description should    never use the following function.  */
end_comment

begin_function
specifier|static
name|void
name|schedule_unit
parameter_list|(
name|int
name|unit
parameter_list|,
name|rtx
name|insn
parameter_list|,
name|int
name|clock
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
literal|0
condition|)
block|{
name|int
name|instance
init|=
name|unit
decl_stmt|;
if|#
directive|if
name|MAX_MULTIPLICITY
operator|>
literal|1
comment|/* Find the first free instance of the function unit and use that          one.  We assume that one is free.  */
for|for
control|(
name|i
operator|=
name|function_units
index|[
name|unit
index|]
operator|.
name|multiplicity
operator|-
literal|1
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
operator|!
name|actual_hazard_this_instance
argument_list|(
name|unit
argument_list|,
name|instance
argument_list|,
name|insn
argument_list|,
name|clock
argument_list|,
literal|0
argument_list|)
condition|)
break|break;
name|instance
operator|+=
name|FUNCTION_UNITS_SIZE
expr_stmt|;
block|}
endif|#
directive|endif
name|unit_last_insn
index|[
name|instance
index|]
operator|=
name|insn
expr_stmt|;
name|unit_tick
index|[
name|instance
index|]
operator|=
operator|(
name|clock
operator|+
name|function_units
index|[
name|unit
index|]
operator|.
name|max_blockage
operator|)
expr_stmt|;
block|}
else|else
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|unit
operator|=
operator|~
name|unit
init|;
name|unit
condition|;
name|i
operator|++
operator|,
name|unit
operator|>>=
literal|1
control|)
if|if
condition|(
operator|(
name|unit
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
name|schedule_unit
argument_list|(
name|i
argument_list|,
name|insn
argument_list|,
name|clock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the actual hazard cost of executing INSN on the units    encoded by UNIT at time CLOCK if the previous actual hazard cost    was COST.  The scheduler using only DFA description should never    use the following function.  */
end_comment

begin_function
specifier|static
name|int
name|actual_hazard
parameter_list|(
name|int
name|unit
parameter_list|,
name|rtx
name|insn
parameter_list|,
name|int
name|clock
parameter_list|,
name|int
name|cost
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
literal|0
condition|)
block|{
comment|/* Find the instance of the function unit with the minimum hazard.  */
name|int
name|instance
init|=
name|unit
decl_stmt|;
name|int
name|best_cost
init|=
name|actual_hazard_this_instance
argument_list|(
name|unit
argument_list|,
name|instance
argument_list|,
name|insn
argument_list|,
name|clock
argument_list|,
name|cost
argument_list|)
decl_stmt|;
if|#
directive|if
name|MAX_MULTIPLICITY
operator|>
literal|1
name|int
name|this_cost
decl_stmt|;
if|if
condition|(
name|best_cost
operator|>
name|cost
condition|)
block|{
for|for
control|(
name|i
operator|=
name|function_units
index|[
name|unit
index|]
operator|.
name|multiplicity
operator|-
literal|1
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|instance
operator|+=
name|FUNCTION_UNITS_SIZE
expr_stmt|;
name|this_cost
operator|=
name|actual_hazard_this_instance
argument_list|(
name|unit
argument_list|,
name|instance
argument_list|,
name|insn
argument_list|,
name|clock
argument_list|,
name|cost
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_cost
operator|<
name|best_cost
condition|)
block|{
name|best_cost
operator|=
name|this_cost
expr_stmt|;
if|if
condition|(
name|this_cost
operator|<=
name|cost
condition|)
break|break;
block|}
block|}
block|}
endif|#
directive|endif
name|cost
operator|=
name|MAX
argument_list|(
name|cost
argument_list|,
name|best_cost
argument_list|)
expr_stmt|;
block|}
else|else
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|unit
operator|=
operator|~
name|unit
init|;
name|unit
condition|;
name|i
operator|++
operator|,
name|unit
operator|>>=
literal|1
control|)
if|if
condition|(
operator|(
name|unit
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
name|cost
operator|=
name|actual_hazard
argument_list|(
name|i
argument_list|,
name|insn
argument_list|,
name|clock
argument_list|,
name|cost
argument_list|)
expr_stmt|;
return|return
name|cost
return|;
block|}
end_function

begin_comment
comment|/* Return the potential hazard cost of executing an instruction on the    units encoded by UNIT if the previous potential hazard cost was    COST.  An insn with a large blockage time is chosen in preference    to one with a smaller time; an insn that uses a unit that is more    likely to be used is chosen in preference to one with a unit that    is less used.  We are trying to minimize a subsequent actual    hazard.  The scheduler using only DFA description should never use    the following function.  */
end_comment

begin_function
name|HAIFA_INLINE
specifier|static
name|int
name|potential_hazard
parameter_list|(
name|int
name|unit
parameter_list|,
name|rtx
name|insn
parameter_list|,
name|int
name|cost
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|ncost
decl_stmt|;
name|unsigned
name|int
name|minb
decl_stmt|,
name|maxb
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
literal|0
condition|)
block|{
name|minb
operator|=
name|maxb
operator|=
name|function_units
index|[
name|unit
index|]
operator|.
name|max_blockage
expr_stmt|;
if|if
condition|(
name|maxb
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|function_units
index|[
name|unit
index|]
operator|.
name|blockage_range_function
condition|)
block|{
name|maxb
operator|=
name|minb
operator|=
name|blockage_range
argument_list|(
name|unit
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|maxb
operator|=
name|MAX_BLOCKAGE_COST
argument_list|(
name|maxb
argument_list|)
expr_stmt|;
name|minb
operator|=
name|MIN_BLOCKAGE_COST
argument_list|(
name|minb
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|maxb
operator|>
literal|1
condition|)
block|{
comment|/* Make the number of instructions left dominate.  Make the 	         minimum delay dominate the maximum delay.  If all these 	         are the same, use the unit number to add an arbitrary 	         ordering.  Other terms can be added.  */
name|ncost
operator|=
name|minb
operator|*
literal|0x40
operator|+
name|maxb
expr_stmt|;
name|ncost
operator|*=
operator|(
name|unit_n_insns
index|[
name|unit
index|]
operator|-
literal|1
operator|)
operator|*
literal|0x1000
operator|+
name|unit
expr_stmt|;
if|if
condition|(
name|ncost
operator|>
name|cost
condition|)
name|cost
operator|=
name|ncost
expr_stmt|;
block|}
block|}
block|}
else|else
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|unit
operator|=
operator|~
name|unit
init|;
name|unit
condition|;
name|i
operator|++
operator|,
name|unit
operator|>>=
literal|1
control|)
if|if
condition|(
operator|(
name|unit
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
name|cost
operator|=
name|potential_hazard
argument_list|(
name|i
argument_list|,
name|insn
argument_list|,
name|cost
argument_list|)
expr_stmt|;
return|return
name|cost
return|;
block|}
end_function

begin_comment
comment|/* Compute cost of executing INSN given the dependence LINK on the insn USED.    This is the number of cycles between instruction issue and    instruction results.  */
end_comment

begin_function
name|HAIFA_INLINE
name|int
name|insn_cost
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|rtx
name|link
parameter_list|,
name|rtx
name|used
parameter_list|)
block|{
name|int
name|cost
init|=
name|INSN_COST
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|cost
operator|<
literal|0
condition|)
block|{
comment|/* A USE insn, or something else we don't need to 	 understand.  We can't pass these directly to 	 result_ready_cost or insn_default_latency because it will 	 trigger a fatal error for unrecognizable insns.  */
if|if
condition|(
name|recog_memoized
argument_list|(
name|insn
argument_list|)
operator|<
literal|0
condition|)
block|{
name|INSN_COST
argument_list|(
name|insn
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
if|if
condition|(
name|targetm
operator|.
name|sched
operator|.
name|use_dfa_pipeline_interface
operator|&&
call|(
modifier|*
name|targetm
operator|.
name|sched
operator|.
name|use_dfa_pipeline_interface
call|)
argument_list|()
condition|)
name|cost
operator|=
name|insn_default_latency
argument_list|(
name|insn
argument_list|)
expr_stmt|;
else|else
name|cost
operator|=
name|result_ready_cost
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|cost
operator|<
literal|0
condition|)
name|cost
operator|=
literal|0
expr_stmt|;
name|INSN_COST
argument_list|(
name|insn
argument_list|)
operator|=
name|cost
expr_stmt|;
block|}
block|}
comment|/* In this case estimate cost without caring how insn is used.  */
if|if
condition|(
name|link
operator|==
literal|0
operator|||
name|used
operator|==
literal|0
condition|)
return|return
name|cost
return|;
comment|/* A USE insn should never require the value used to be computed.      This allows the computation of a function's result and parameter      values to overlap the return and call.  */
if|if
condition|(
name|recog_memoized
argument_list|(
name|used
argument_list|)
operator|<
literal|0
condition|)
name|cost
operator|=
literal|0
expr_stmt|;
else|else
block|{
if|if
condition|(
name|targetm
operator|.
name|sched
operator|.
name|use_dfa_pipeline_interface
operator|&&
call|(
modifier|*
name|targetm
operator|.
name|sched
operator|.
name|use_dfa_pipeline_interface
call|)
argument_list|()
condition|)
block|{
if|if
condition|(
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
name|REG_DEP_ANTI
condition|)
name|cost
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
name|REG_DEP_OUTPUT
condition|)
block|{
name|cost
operator|=
operator|(
name|insn_default_latency
argument_list|(
name|insn
argument_list|)
operator|-
name|insn_default_latency
argument_list|(
name|used
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|cost
operator|<=
literal|0
condition|)
name|cost
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bypass_p
argument_list|(
name|insn
argument_list|)
condition|)
name|cost
operator|=
name|insn_latency
argument_list|(
name|insn
argument_list|,
name|used
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|targetm
operator|.
name|sched
operator|.
name|adjust_cost
condition|)
name|cost
operator|=
call|(
modifier|*
name|targetm
operator|.
name|sched
operator|.
name|adjust_cost
call|)
argument_list|(
name|used
argument_list|,
name|link
argument_list|,
name|insn
argument_list|,
name|cost
argument_list|)
expr_stmt|;
if|if
condition|(
name|cost
operator|<
literal|0
condition|)
name|cost
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|cost
return|;
block|}
end_function

begin_comment
comment|/* Compute the priority number for INSN.  */
end_comment

begin_function
specifier|static
name|int
name|priority
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|rtx
name|link
decl_stmt|;
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|INSN_PRIORITY_KNOWN
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|int
name|this_priority
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|INSN_DEPEND
argument_list|(
name|insn
argument_list|)
operator|==
literal|0
condition|)
name|this_priority
operator|=
name|insn_cost
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
for|for
control|(
name|link
operator|=
name|INSN_DEPEND
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|rtx
name|next
decl_stmt|;
name|int
name|next_priority
decl_stmt|;
if|if
condition|(
name|RTX_INTEGRATED_P
argument_list|(
name|link
argument_list|)
condition|)
continue|continue;
name|next
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Critical path is meaningful in block boundaries only.  */
if|if
condition|(
operator|!
call|(
modifier|*
name|current_sched_info
operator|->
name|contributes_to_priority
call|)
argument_list|(
name|next
argument_list|,
name|insn
argument_list|)
condition|)
continue|continue;
name|next_priority
operator|=
name|insn_cost
argument_list|(
name|insn
argument_list|,
name|link
argument_list|,
name|next
argument_list|)
operator|+
name|priority
argument_list|(
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_priority
operator|>
name|this_priority
condition|)
name|this_priority
operator|=
name|next_priority
expr_stmt|;
block|}
block|}
name|INSN_PRIORITY
argument_list|(
name|insn
argument_list|)
operator|=
name|this_priority
expr_stmt|;
name|INSN_PRIORITY_KNOWN
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|INSN_PRIORITY
argument_list|(
name|insn
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Macros and functions for keeping the priority queue sorted, and    dealing with queuing and dequeuing of instructions.  */
end_comment

begin_define
define|#
directive|define
name|SCHED_SORT
parameter_list|(
name|READY
parameter_list|,
name|N_READY
parameter_list|)
define|\
value|do { if ((N_READY) == 2)				             \        swap_sort (READY, N_READY);			             \      else if ((N_READY)> 2)                                         \          qsort (READY, N_READY, sizeof (rtx), rank_for_schedule); }  \ while (0)
end_define

begin_comment
comment|/* Returns a positive value if x is preferred; returns a negative value if    y is preferred.  Should never return 0, since that will make the sort    unstable.  */
end_comment

begin_function
specifier|static
name|int
name|rank_for_schedule
parameter_list|(
specifier|const
name|void
modifier|*
name|x
parameter_list|,
specifier|const
name|void
modifier|*
name|y
parameter_list|)
block|{
name|rtx
name|tmp
init|=
operator|*
operator|(
specifier|const
name|rtx
operator|*
operator|)
name|y
decl_stmt|;
name|rtx
name|tmp2
init|=
operator|*
operator|(
specifier|const
name|rtx
operator|*
operator|)
name|x
decl_stmt|;
name|rtx
name|link
decl_stmt|;
name|int
name|tmp_class
decl_stmt|,
name|tmp2_class
decl_stmt|,
name|depend_count1
decl_stmt|,
name|depend_count2
decl_stmt|;
name|int
name|val
decl_stmt|,
name|priority_val
decl_stmt|,
name|weight_val
decl_stmt|,
name|info_val
decl_stmt|;
comment|/* The insn in a schedule group should be issued the first.  */
if|if
condition|(
name|SCHED_GROUP_P
argument_list|(
name|tmp
argument_list|)
operator|!=
name|SCHED_GROUP_P
argument_list|(
name|tmp2
argument_list|)
condition|)
return|return
name|SCHED_GROUP_P
argument_list|(
name|tmp2
argument_list|)
condition|?
literal|1
else|:
operator|-
literal|1
return|;
comment|/* Prefer insn with higher priority.  */
name|priority_val
operator|=
name|INSN_PRIORITY
argument_list|(
name|tmp2
argument_list|)
operator|-
name|INSN_PRIORITY
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|priority_val
condition|)
return|return
name|priority_val
return|;
comment|/* Prefer an insn with smaller contribution to registers-pressure.  */
if|if
condition|(
operator|!
name|reload_completed
operator|&&
operator|(
name|weight_val
operator|=
name|INSN_REG_WEIGHT
argument_list|(
name|tmp
argument_list|)
operator|-
name|INSN_REG_WEIGHT
argument_list|(
name|tmp2
argument_list|)
operator|)
condition|)
return|return
name|weight_val
return|;
name|info_val
operator|=
call|(
modifier|*
name|current_sched_info
operator|->
name|rank
call|)
argument_list|(
name|tmp
argument_list|,
name|tmp2
argument_list|)
expr_stmt|;
if|if
condition|(
name|info_val
condition|)
return|return
name|info_val
return|;
comment|/* Compare insns based on their relation to the last-scheduled-insn.  */
if|if
condition|(
name|last_scheduled_insn
condition|)
block|{
comment|/* Classify the instructions into three classes:          1) Data dependent on last schedule insn.          2) Anti/Output dependent on last scheduled insn.          3) Independent of last scheduled insn, or has latency of one.          Choose the insn from the highest numbered class if different.  */
name|link
operator|=
name|find_insn_list
argument_list|(
name|tmp
argument_list|,
name|INSN_DEPEND
argument_list|(
name|last_scheduled_insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|link
operator|==
literal|0
operator|||
name|insn_cost
argument_list|(
name|last_scheduled_insn
argument_list|,
name|link
argument_list|,
name|tmp
argument_list|)
operator|==
literal|1
condition|)
name|tmp_class
operator|=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
literal|0
condition|)
comment|/* Data dependence.  */
name|tmp_class
operator|=
literal|1
expr_stmt|;
else|else
name|tmp_class
operator|=
literal|2
expr_stmt|;
name|link
operator|=
name|find_insn_list
argument_list|(
name|tmp2
argument_list|,
name|INSN_DEPEND
argument_list|(
name|last_scheduled_insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|link
operator|==
literal|0
operator|||
name|insn_cost
argument_list|(
name|last_scheduled_insn
argument_list|,
name|link
argument_list|,
name|tmp2
argument_list|)
operator|==
literal|1
condition|)
name|tmp2_class
operator|=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
literal|0
condition|)
comment|/* Data dependence.  */
name|tmp2_class
operator|=
literal|1
expr_stmt|;
else|else
name|tmp2_class
operator|=
literal|2
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|=
name|tmp2_class
operator|-
name|tmp_class
operator|)
condition|)
return|return
name|val
return|;
block|}
comment|/* Prefer the insn which has more later insns that depend on it.      This gives the scheduler more freedom when scheduling later      instructions at the expense of added register pressure.  */
name|depend_count1
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|link
operator|=
name|INSN_DEPEND
argument_list|(
name|tmp
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
name|depend_count1
operator|++
expr_stmt|;
name|depend_count2
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|link
operator|=
name|INSN_DEPEND
argument_list|(
name|tmp2
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
name|depend_count2
operator|++
expr_stmt|;
name|val
operator|=
name|depend_count2
operator|-
name|depend_count1
expr_stmt|;
if|if
condition|(
name|val
condition|)
return|return
name|val
return|;
comment|/* If insns are equally good, sort by INSN_LUID (original insn order),      so that we make the sort stable.  This minimizes instruction movement,      thus minimizing sched's effect on debugging and cross-jumping.  */
return|return
name|INSN_LUID
argument_list|(
name|tmp
argument_list|)
operator|-
name|INSN_LUID
argument_list|(
name|tmp2
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Resort the array A in which only element at index N may be out of order.  */
end_comment

begin_function
name|HAIFA_INLINE
specifier|static
name|void
name|swap_sort
parameter_list|(
name|rtx
modifier|*
name|a
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|rtx
name|insn
init|=
name|a
index|[
name|n
operator|-
literal|1
index|]
decl_stmt|;
name|int
name|i
init|=
name|n
operator|-
literal|2
decl_stmt|;
while|while
condition|(
name|i
operator|>=
literal|0
operator|&&
name|rank_for_schedule
argument_list|(
name|a
operator|+
name|i
argument_list|,
operator|&
name|insn
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|a
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|a
index|[
name|i
index|]
expr_stmt|;
name|i
operator|-=
literal|1
expr_stmt|;
block|}
name|a
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|insn
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add INSN to the insn queue so that it can be executed at least    N_CYCLES after the currently executing insn.  Preserve insns    chain for debugging purposes.  */
end_comment

begin_function
name|HAIFA_INLINE
specifier|static
name|void
name|queue_insn
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|int
name|n_cycles
parameter_list|)
block|{
name|int
name|next_q
init|=
name|NEXT_Q_AFTER
argument_list|(
name|q_ptr
argument_list|,
name|n_cycles
argument_list|)
decl_stmt|;
name|rtx
name|link
init|=
name|alloc_INSN_LIST
argument_list|(
name|insn
argument_list|,
name|insn_queue
index|[
name|next_q
index|]
argument_list|)
decl_stmt|;
name|insn_queue
index|[
name|next_q
index|]
operator|=
name|link
expr_stmt|;
name|q_size
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|sched_verbose
operator|>=
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|";;\t\tReady-->Q: insn %s: "
argument_list|,
call|(
modifier|*
name|current_sched_info
operator|->
name|print_insn
call|)
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|"queued for %d cycles.\n"
argument_list|,
name|n_cycles
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return a pointer to the bottom of the ready list, i.e. the insn    with the lowest priority.  */
end_comment

begin_function
name|HAIFA_INLINE
specifier|static
name|rtx
modifier|*
name|ready_lastpos
parameter_list|(
name|struct
name|ready_list
modifier|*
name|ready
parameter_list|)
block|{
if|if
condition|(
name|ready
operator|->
name|n_ready
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|ready
operator|->
name|vec
operator|+
name|ready
operator|->
name|first
operator|-
name|ready
operator|->
name|n_ready
operator|+
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Add an element INSN to the ready list so that it ends up with the lowest    priority.  */
end_comment

begin_function
name|HAIFA_INLINE
name|void
name|ready_add
parameter_list|(
name|struct
name|ready_list
modifier|*
name|ready
parameter_list|,
name|rtx
name|insn
parameter_list|)
block|{
if|if
condition|(
name|ready
operator|->
name|first
operator|==
name|ready
operator|->
name|n_ready
condition|)
block|{
name|memmove
argument_list|(
name|ready
operator|->
name|vec
operator|+
name|ready
operator|->
name|veclen
operator|-
name|ready
operator|->
name|n_ready
argument_list|,
name|ready_lastpos
argument_list|(
name|ready
argument_list|)
argument_list|,
name|ready
operator|->
name|n_ready
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|ready
operator|->
name|first
operator|=
name|ready
operator|->
name|veclen
operator|-
literal|1
expr_stmt|;
block|}
name|ready
operator|->
name|vec
index|[
name|ready
operator|->
name|first
operator|-
name|ready
operator|->
name|n_ready
index|]
operator|=
name|insn
expr_stmt|;
name|ready
operator|->
name|n_ready
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Remove the element with the highest priority from the ready list and    return it.  */
end_comment

begin_function
name|HAIFA_INLINE
specifier|static
name|rtx
name|ready_remove_first
parameter_list|(
name|struct
name|ready_list
modifier|*
name|ready
parameter_list|)
block|{
name|rtx
name|t
decl_stmt|;
if|if
condition|(
name|ready
operator|->
name|n_ready
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|t
operator|=
name|ready
operator|->
name|vec
index|[
name|ready
operator|->
name|first
operator|--
index|]
expr_stmt|;
name|ready
operator|->
name|n_ready
operator|--
expr_stmt|;
comment|/* If the queue becomes empty, reset it.  */
if|if
condition|(
name|ready
operator|->
name|n_ready
operator|==
literal|0
condition|)
name|ready
operator|->
name|first
operator|=
name|ready
operator|->
name|veclen
operator|-
literal|1
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* The following code implements multi-pass scheduling for the first    cycle.  In other words, we will try to choose ready insn which    permits to start maximum number of insns on the same cycle.  */
end_comment

begin_comment
comment|/* Return a pointer to the element INDEX from the ready.  INDEX for    insn with the highest priority is 0, and the lowest priority has    N_READY - 1.  */
end_comment

begin_function
name|HAIFA_INLINE
specifier|static
name|rtx
name|ready_element
parameter_list|(
name|struct
name|ready_list
modifier|*
name|ready
parameter_list|,
name|int
name|index
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
if|if
condition|(
name|ready
operator|->
name|n_ready
operator|==
literal|0
operator|||
name|index
operator|>=
name|ready
operator|->
name|n_ready
condition|)
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
return|return
name|ready
operator|->
name|vec
index|[
name|ready
operator|->
name|first
operator|-
name|index
index|]
return|;
block|}
end_function

begin_comment
comment|/* Remove the element INDEX from the ready list and return it.  INDEX    for insn with the highest priority is 0, and the lowest priority    has N_READY - 1.  */
end_comment

begin_function
name|HAIFA_INLINE
specifier|static
name|rtx
name|ready_remove
parameter_list|(
name|struct
name|ready_list
modifier|*
name|ready
parameter_list|,
name|int
name|index
parameter_list|)
block|{
name|rtx
name|t
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|index
operator|==
literal|0
condition|)
return|return
name|ready_remove_first
argument_list|(
name|ready
argument_list|)
return|;
if|if
condition|(
name|ready
operator|->
name|n_ready
operator|==
literal|0
operator|||
name|index
operator|>=
name|ready
operator|->
name|n_ready
condition|)
name|abort
argument_list|()
expr_stmt|;
name|t
operator|=
name|ready
operator|->
name|vec
index|[
name|ready
operator|->
name|first
operator|-
name|index
index|]
expr_stmt|;
name|ready
operator|->
name|n_ready
operator|--
expr_stmt|;
for|for
control|(
name|i
operator|=
name|index
init|;
name|i
operator|<
name|ready
operator|->
name|n_ready
condition|;
name|i
operator|++
control|)
name|ready
operator|->
name|vec
index|[
name|ready
operator|->
name|first
operator|-
name|i
index|]
operator|=
name|ready
operator|->
name|vec
index|[
name|ready
operator|->
name|first
operator|-
name|i
operator|-
literal|1
index|]
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Sort the ready list READY by ascending priority, using the SCHED_SORT    macro.  */
end_comment

begin_function
name|HAIFA_INLINE
specifier|static
name|void
name|ready_sort
parameter_list|(
name|struct
name|ready_list
modifier|*
name|ready
parameter_list|)
block|{
name|rtx
modifier|*
name|first
init|=
name|ready_lastpos
argument_list|(
name|ready
argument_list|)
decl_stmt|;
name|SCHED_SORT
argument_list|(
name|first
argument_list|,
name|ready
operator|->
name|n_ready
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* PREV is an insn that is ready to execute.  Adjust its priority if that    will help shorten or lengthen register lifetimes as appropriate.  Also    provide a hook for the target to tweek itself.  */
end_comment

begin_function
name|HAIFA_INLINE
specifier|static
name|void
name|adjust_priority
parameter_list|(
name|rtx
name|prev
parameter_list|)
block|{
comment|/* ??? There used to be code here to try and estimate how an insn      affected register lifetimes, but it did it by looking at REG_DEAD      notes, which we removed in schedule_region.  Nor did it try to      take into account register pressure or anything useful like that.       Revisit when we have a machine model to work with and not before.  */
if|if
condition|(
name|targetm
operator|.
name|sched
operator|.
name|adjust_priority
condition|)
name|INSN_PRIORITY
argument_list|(
name|prev
argument_list|)
operator|=
call|(
modifier|*
name|targetm
operator|.
name|sched
operator|.
name|adjust_priority
call|)
argument_list|(
name|prev
argument_list|,
name|INSN_PRIORITY
argument_list|(
name|prev
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Advance time on one cycle.  */
end_comment

begin_function
name|HAIFA_INLINE
specifier|static
name|void
name|advance_one_cycle
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|targetm
operator|.
name|sched
operator|.
name|use_dfa_pipeline_interface
operator|&&
call|(
modifier|*
name|targetm
operator|.
name|sched
operator|.
name|use_dfa_pipeline_interface
call|)
argument_list|()
condition|)
block|{
if|if
condition|(
name|targetm
operator|.
name|sched
operator|.
name|dfa_pre_cycle_insn
condition|)
name|state_transition
argument_list|(
name|curr_state
argument_list|,
call|(
modifier|*
name|targetm
operator|.
name|sched
operator|.
name|dfa_pre_cycle_insn
call|)
argument_list|()
argument_list|)
expr_stmt|;
name|state_transition
argument_list|(
name|curr_state
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|targetm
operator|.
name|sched
operator|.
name|dfa_post_cycle_insn
condition|)
name|state_transition
argument_list|(
name|curr_state
argument_list|,
call|(
modifier|*
name|targetm
operator|.
name|sched
operator|.
name|dfa_post_cycle_insn
call|)
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Clock at which the previous instruction was issued.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|last_clock_var
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* INSN is the "currently executing insn".  Launch each insn which was    waiting on INSN.  READY is the ready list which contains the insns    that are ready to fire.  CLOCK is the current cycle.  The function    returns necessary cycle advance after issuing the insn (it is not    zero for insns in a schedule group).  */
end_comment

begin_function
specifier|static
name|int
name|schedule_insn
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|struct
name|ready_list
modifier|*
name|ready
parameter_list|,
name|int
name|clock
parameter_list|)
block|{
name|rtx
name|link
decl_stmt|;
name|int
name|advance
init|=
literal|0
decl_stmt|;
name|int
name|unit
init|=
literal|0
decl_stmt|;
name|int
name|premature_issue
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|targetm
operator|.
name|sched
operator|.
name|use_dfa_pipeline_interface
operator|||
operator|!
call|(
modifier|*
name|targetm
operator|.
name|sched
operator|.
name|use_dfa_pipeline_interface
call|)
argument_list|()
condition|)
name|unit
operator|=
name|insn_unit
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|targetm
operator|.
name|sched
operator|.
name|use_dfa_pipeline_interface
operator|&&
call|(
modifier|*
name|targetm
operator|.
name|sched
operator|.
name|use_dfa_pipeline_interface
call|)
argument_list|()
operator|&&
name|sched_verbose
operator|>=
literal|1
condition|)
block|{
name|char
name|buf
index|[
literal|2048
index|]
decl_stmt|;
name|print_insn
argument_list|(
name|buf
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|buf
index|[
literal|40
index|]
operator|=
literal|0
expr_stmt|;
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|";;\t%3i--> %-40s:"
argument_list|,
name|clock
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|recog_memoized
argument_list|(
name|insn
argument_list|)
operator|<
literal|0
condition|)
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|"nothing"
argument_list|)
expr_stmt|;
else|else
name|print_reservation
argument_list|(
name|sched_dump
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|sched_dump
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sched_verbose
operator|>=
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|";;\t\t--> scheduling insn<<<%d>>> on unit "
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|insn_print_units
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|sched_dump
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|targetm
operator|.
name|sched
operator|.
name|use_dfa_pipeline_interface
operator|||
operator|!
call|(
modifier|*
name|targetm
operator|.
name|sched
operator|.
name|use_dfa_pipeline_interface
call|)
argument_list|()
condition|)
block|{
if|if
condition|(
name|sched_verbose
operator|&&
name|unit
operator|==
operator|-
literal|1
condition|)
name|visualize_no_unit
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|MAX_BLOCKAGE
operator|>
literal|1
operator|||
name|issue_rate
operator|>
literal|1
operator|||
name|sched_verbose
condition|)
name|schedule_unit
argument_list|(
name|unit
argument_list|,
name|insn
argument_list|,
name|clock
argument_list|)
expr_stmt|;
if|if
condition|(
name|INSN_DEPEND
argument_list|(
name|insn
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
name|INSN_TICK
argument_list|(
name|insn
argument_list|)
operator|>
name|clock
condition|)
block|{
comment|/* 'insn' has been prematurely moved from the queue to the 	 ready list.  */
name|premature_issue
operator|=
name|INSN_TICK
argument_list|(
name|insn
argument_list|)
operator|-
name|clock
expr_stmt|;
block|}
for|for
control|(
name|link
operator|=
name|INSN_DEPEND
argument_list|(
name|insn
argument_list|)
init|;
name|link
operator|!=
literal|0
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|rtx
name|next
init|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|cost
init|=
name|insn_cost
argument_list|(
name|insn
argument_list|,
name|link
argument_list|,
name|next
argument_list|)
decl_stmt|;
name|INSN_TICK
argument_list|(
name|next
argument_list|)
operator|=
name|MAX
argument_list|(
name|INSN_TICK
argument_list|(
name|next
argument_list|)
argument_list|,
name|clock
operator|+
name|cost
operator|+
name|premature_issue
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|INSN_DEP_COUNT
argument_list|(
name|next
argument_list|)
operator|-=
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
name|int
name|effective_cost
init|=
name|INSN_TICK
argument_list|(
name|next
argument_list|)
operator|-
name|clock
decl_stmt|;
if|if
condition|(
operator|!
call|(
modifier|*
name|current_sched_info
operator|->
name|new_ready
call|)
argument_list|(
name|next
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|sched_verbose
operator|>=
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|";;\t\tdependences resolved: insn %s "
argument_list|,
call|(
modifier|*
name|current_sched_info
operator|->
name|print_insn
call|)
argument_list|(
name|next
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|effective_cost
operator|<
literal|1
condition|)
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|"into ready\n"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|"into queue with cost=%d\n"
argument_list|,
name|effective_cost
argument_list|)
expr_stmt|;
block|}
comment|/* Adjust the priority of NEXT and either put it on the ready 	     list or queue it.  */
name|adjust_priority
argument_list|(
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|effective_cost
operator|<
literal|1
condition|)
name|ready_add
argument_list|(
name|ready
argument_list|,
name|next
argument_list|)
expr_stmt|;
else|else
block|{
name|queue_insn
argument_list|(
name|next
argument_list|,
name|effective_cost
argument_list|)
expr_stmt|;
if|if
condition|(
name|SCHED_GROUP_P
argument_list|(
name|next
argument_list|)
operator|&&
name|advance
operator|<
name|effective_cost
condition|)
name|advance
operator|=
name|effective_cost
expr_stmt|;
block|}
block|}
block|}
comment|/* Annotate the instruction with issue information -- TImode      indicates that the instruction is expected not to be able      to issue on the same cycle as the previous insn.  A machine      may use this information to decide how the instruction should      be aligned.  */
if|if
condition|(
name|issue_rate
operator|>
literal|1
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|USE
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|CLOBBER
condition|)
block|{
if|if
condition|(
name|reload_completed
condition|)
name|PUT_MODE
argument_list|(
name|insn
argument_list|,
name|clock
operator|>
name|last_clock_var
condition|?
name|TImode
else|:
name|VOIDmode
argument_list|)
expr_stmt|;
name|last_clock_var
operator|=
name|clock
expr_stmt|;
block|}
return|return
name|advance
return|;
block|}
end_function

begin_comment
comment|/* Functions for handling of notes.  */
end_comment

begin_comment
comment|/* Delete notes beginning with INSN and put them in the chain    of notes ended by NOTE_LIST.    Returns the insn following the notes.  */
end_comment

begin_function
specifier|static
name|rtx
name|unlink_other_notes
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|rtx
name|tail
parameter_list|)
block|{
name|rtx
name|prev
init|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
while|while
condition|(
name|insn
operator|!=
name|tail
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
block|{
name|rtx
name|next
init|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
comment|/* Delete the note from its current position.  */
if|if
condition|(
name|prev
condition|)
name|NEXT_INSN
argument_list|(
name|prev
argument_list|)
operator|=
name|next
expr_stmt|;
if|if
condition|(
name|next
condition|)
name|PREV_INSN
argument_list|(
name|next
argument_list|)
operator|=
name|prev
expr_stmt|;
comment|/* See sched_analyze to see how these are handled.  */
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE_INSN_LOOP_BEG
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE_INSN_LOOP_END
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE_INSN_BASIC_BLOCK
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE_INSN_EH_REGION_BEG
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE_INSN_EH_REGION_END
condition|)
block|{
comment|/* Insert the note at the end of the notes list.  */
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
operator|=
name|note_list
expr_stmt|;
if|if
condition|(
name|note_list
condition|)
name|NEXT_INSN
argument_list|(
name|note_list
argument_list|)
operator|=
name|insn
expr_stmt|;
name|note_list
operator|=
name|insn
expr_stmt|;
block|}
name|insn
operator|=
name|next
expr_stmt|;
block|}
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Delete line notes beginning with INSN. Record line-number notes so    they can be reused.  Returns the insn following the notes.  */
end_comment

begin_function
specifier|static
name|rtx
name|unlink_line_notes
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|rtx
name|tail
parameter_list|)
block|{
name|rtx
name|prev
init|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
while|while
condition|(
name|insn
operator|!=
name|tail
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
block|{
name|rtx
name|next
init|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|write_symbols
operator|!=
name|NO_DEBUG
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|>
literal|0
condition|)
block|{
comment|/* Delete the note from its current position.  */
if|if
condition|(
name|prev
condition|)
name|NEXT_INSN
argument_list|(
name|prev
argument_list|)
operator|=
name|next
expr_stmt|;
if|if
condition|(
name|next
condition|)
name|PREV_INSN
argument_list|(
name|next
argument_list|)
operator|=
name|prev
expr_stmt|;
comment|/* Record line-number notes so they can be reused.  */
name|LINE_NOTE
argument_list|(
name|insn
argument_list|)
operator|=
name|insn
expr_stmt|;
block|}
else|else
name|prev
operator|=
name|insn
expr_stmt|;
name|insn
operator|=
name|next
expr_stmt|;
block|}
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Return the head and tail pointers of BB.  */
end_comment

begin_function
name|void
name|get_block_head_tail
parameter_list|(
name|int
name|b
parameter_list|,
name|rtx
modifier|*
name|headp
parameter_list|,
name|rtx
modifier|*
name|tailp
parameter_list|)
block|{
comment|/* HEAD and TAIL delimit the basic block being scheduled.  */
name|rtx
name|head
init|=
name|BB_HEAD
argument_list|(
name|BASIC_BLOCK
argument_list|(
name|b
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|tail
init|=
name|BB_END
argument_list|(
name|BASIC_BLOCK
argument_list|(
name|b
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Don't include any notes or labels at the beginning of the      basic block, or notes at the ends of basic blocks.  */
while|while
condition|(
name|head
operator|!=
name|tail
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|head
argument_list|)
operator|==
name|NOTE
condition|)
name|head
operator|=
name|NEXT_INSN
argument_list|(
name|head
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|tail
argument_list|)
operator|==
name|NOTE
condition|)
name|tail
operator|=
name|PREV_INSN
argument_list|(
name|tail
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|head
argument_list|)
operator|==
name|CODE_LABEL
condition|)
name|head
operator|=
name|NEXT_INSN
argument_list|(
name|head
argument_list|)
expr_stmt|;
else|else
break|break;
block|}
operator|*
name|headp
operator|=
name|head
expr_stmt|;
operator|*
name|tailp
operator|=
name|tail
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return nonzero if there are no real insns in the range [ HEAD, TAIL ].  */
end_comment

begin_function
name|int
name|no_real_insns_p
parameter_list|(
name|rtx
name|head
parameter_list|,
name|rtx
name|tail
parameter_list|)
block|{
while|while
condition|(
name|head
operator|!=
name|NEXT_INSN
argument_list|(
name|tail
argument_list|)
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|head
argument_list|)
operator|!=
name|NOTE
operator|&&
name|GET_CODE
argument_list|(
name|head
argument_list|)
operator|!=
name|CODE_LABEL
condition|)
return|return
literal|0
return|;
name|head
operator|=
name|NEXT_INSN
argument_list|(
name|head
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Delete line notes from one block. Save them so they can be later restored    (in restore_line_notes).  HEAD and TAIL are the boundaries of the    block in which notes should be processed.  */
end_comment

begin_function
name|void
name|rm_line_notes
parameter_list|(
name|rtx
name|head
parameter_list|,
name|rtx
name|tail
parameter_list|)
block|{
name|rtx
name|next_tail
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|next_tail
operator|=
name|NEXT_INSN
argument_list|(
name|tail
argument_list|)
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|head
init|;
name|insn
operator|!=
name|next_tail
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|rtx
name|prev
decl_stmt|;
comment|/* Farm out notes, and maybe save them in NOTE_LIST.          This is needed to keep the debugger from          getting completely deranged.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
block|{
name|prev
operator|=
name|insn
expr_stmt|;
name|insn
operator|=
name|unlink_line_notes
argument_list|(
name|insn
argument_list|,
name|next_tail
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev
operator|==
name|tail
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|prev
operator|==
name|head
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|insn
operator|==
name|next_tail
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Save line number notes for each insn in block B.  HEAD and TAIL are    the boundaries of the block in which notes should be processed.  */
end_comment

begin_function
name|void
name|save_line_notes
parameter_list|(
name|int
name|b
parameter_list|,
name|rtx
name|head
parameter_list|,
name|rtx
name|tail
parameter_list|)
block|{
name|rtx
name|next_tail
decl_stmt|;
comment|/* We must use the true line number for the first insn in the block      that was computed and saved at the start of this pass.  We can't      use the current line number, because scheduling of the previous      block may have changed the current line number.  */
name|rtx
name|line
init|=
name|line_note_head
index|[
name|b
index|]
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|next_tail
operator|=
name|NEXT_INSN
argument_list|(
name|tail
argument_list|)
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|head
init|;
name|insn
operator|!=
name|next_tail
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|>
literal|0
condition|)
name|line
operator|=
name|insn
expr_stmt|;
else|else
name|LINE_NOTE
argument_list|(
name|insn
argument_list|)
operator|=
name|line
expr_stmt|;
block|}
end_function

begin_comment
comment|/* After a block was scheduled, insert line notes into the insns list.    HEAD and TAIL are the boundaries of the block in which notes should    be processed.  */
end_comment

begin_function
name|void
name|restore_line_notes
parameter_list|(
name|rtx
name|head
parameter_list|,
name|rtx
name|tail
parameter_list|)
block|{
name|rtx
name|line
decl_stmt|,
name|note
decl_stmt|,
name|prev
decl_stmt|,
name|new
decl_stmt|;
name|int
name|added_notes
init|=
literal|0
decl_stmt|;
name|rtx
name|next_tail
decl_stmt|,
name|insn
decl_stmt|;
name|head
operator|=
name|head
expr_stmt|;
name|next_tail
operator|=
name|NEXT_INSN
argument_list|(
name|tail
argument_list|)
expr_stmt|;
comment|/* Determine the current line-number.  We want to know the current      line number of the first insn of the block here, in case it is      different from the true line number that was saved earlier.  If      different, then we need a line number note before the first insn      of this block.  If it happens to be the same, then we don't want to      emit another line number note here.  */
for|for
control|(
name|line
operator|=
name|head
init|;
name|line
condition|;
name|line
operator|=
name|PREV_INSN
argument_list|(
name|line
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|line
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|line
argument_list|)
operator|>
literal|0
condition|)
break|break;
comment|/* Walk the insns keeping track of the current line-number and inserting      the line-number notes as needed.  */
for|for
control|(
name|insn
operator|=
name|head
init|;
name|insn
operator|!=
name|next_tail
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|>
literal|0
condition|)
name|line
operator|=
name|insn
expr_stmt|;
comment|/* This used to emit line number notes before every non-deleted note.      However, this confuses a debugger, because line notes not separated      by real instructions all end up at the same address.  I can find no      use for line number notes before other notes, so none are emitted.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE
operator|&&
name|INSN_UID
argument_list|(
name|insn
argument_list|)
operator|<
name|old_max_uid
operator|&&
operator|(
name|note
operator|=
name|LINE_NOTE
argument_list|(
name|insn
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|note
operator|!=
name|line
operator|&&
operator|(
name|line
operator|==
literal|0
operator|||
name|NOTE_LINE_NUMBER
argument_list|(
name|note
argument_list|)
operator|!=
name|NOTE_LINE_NUMBER
argument_list|(
name|line
argument_list|)
operator|||
name|NOTE_SOURCE_FILE
argument_list|(
name|note
argument_list|)
operator|!=
name|NOTE_SOURCE_FILE
argument_list|(
name|line
argument_list|)
operator|)
condition|)
block|{
name|line
operator|=
name|note
expr_stmt|;
name|prev
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|LINE_NOTE
argument_list|(
name|note
argument_list|)
condition|)
block|{
comment|/* Re-use the original line-number note.  */
name|LINE_NOTE
argument_list|(
name|note
argument_list|)
operator|=
literal|0
expr_stmt|;
name|PREV_INSN
argument_list|(
name|note
argument_list|)
operator|=
name|prev
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|prev
argument_list|)
operator|=
name|note
expr_stmt|;
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
operator|=
name|note
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|note
argument_list|)
operator|=
name|insn
expr_stmt|;
block|}
else|else
block|{
name|added_notes
operator|++
expr_stmt|;
name|new
operator|=
name|emit_note_after
argument_list|(
name|NOTE_LINE_NUMBER
argument_list|(
name|note
argument_list|)
argument_list|,
name|prev
argument_list|)
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|new
argument_list|)
operator|=
name|NOTE_SOURCE_FILE
argument_list|(
name|note
argument_list|)
expr_stmt|;
name|RTX_INTEGRATED_P
argument_list|(
name|new
argument_list|)
operator|=
name|RTX_INTEGRATED_P
argument_list|(
name|note
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sched_verbose
operator|&&
name|added_notes
condition|)
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|";; added %d line-number notes\n"
argument_list|,
name|added_notes
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* After scheduling the function, delete redundant line notes from the    insns list.  */
end_comment

begin_function
name|void
name|rm_redundant_line_notes
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|line
init|=
literal|0
decl_stmt|;
name|rtx
name|insn
init|=
name|get_insns
argument_list|()
decl_stmt|;
name|int
name|active_insn
init|=
literal|0
decl_stmt|;
name|int
name|notes
init|=
literal|0
decl_stmt|;
comment|/* Walk the insns deleting redundant line-number notes.  Many of these      are already present.  The remainder tend to occur at basic      block boundaries.  */
for|for
control|(
name|insn
operator|=
name|get_last_insn
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|>
literal|0
condition|)
block|{
comment|/* If there are no active insns following, INSN is redundant.  */
if|if
condition|(
name|active_insn
operator|==
literal|0
condition|)
block|{
name|notes
operator|++
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
operator|=
literal|0
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
block|}
comment|/* If the line number is unchanged, LINE is redundant.  */
elseif|else
if|if
condition|(
name|line
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|line
argument_list|)
operator|==
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|&&
name|NOTE_SOURCE_FILE
argument_list|(
name|line
argument_list|)
operator|==
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|notes
operator|++
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|line
argument_list|)
operator|=
literal|0
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|line
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
name|line
operator|=
name|insn
expr_stmt|;
block|}
else|else
name|line
operator|=
name|insn
expr_stmt|;
name|active_insn
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_DELETED
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|USE
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|CLOBBER
operator|)
operator|)
operator|)
condition|)
name|active_insn
operator|++
expr_stmt|;
if|if
condition|(
name|sched_verbose
operator|&&
name|notes
condition|)
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|";; deleted %d line-number notes\n"
argument_list|,
name|notes
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Delete notes between HEAD and TAIL and put them in the chain    of notes ended by NOTE_LIST.  */
end_comment

begin_function
name|void
name|rm_other_notes
parameter_list|(
name|rtx
name|head
parameter_list|,
name|rtx
name|tail
parameter_list|)
block|{
name|rtx
name|next_tail
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|note_list
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|head
operator|==
name|tail
operator|&&
operator|(
operator|!
name|INSN_P
argument_list|(
name|head
argument_list|)
operator|)
condition|)
return|return;
name|next_tail
operator|=
name|NEXT_INSN
argument_list|(
name|tail
argument_list|)
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|head
init|;
name|insn
operator|!=
name|next_tail
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|rtx
name|prev
decl_stmt|;
comment|/* Farm out notes, and maybe save them in NOTE_LIST.          This is needed to keep the debugger from          getting completely deranged.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
block|{
name|prev
operator|=
name|insn
expr_stmt|;
name|insn
operator|=
name|unlink_other_notes
argument_list|(
name|insn
argument_list|,
name|next_tail
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev
operator|==
name|tail
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|prev
operator|==
name|head
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|insn
operator|==
name|next_tail
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Functions for computation of registers live/usage info.  */
end_comment

begin_comment
comment|/* This function looks for a new register being defined.    If the destination register is already used by the source,    a new register is not needed.  */
end_comment

begin_function
specifier|static
name|int
name|find_set_reg_weight
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CLOBBER
operator|&&
name|register_operand
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
name|VOIDmode
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SET
operator|&&
name|register_operand
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
name|VOIDmode
argument_list|)
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
if|if
condition|(
operator|!
name|reg_mentioned_p
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Calculate INSN_REG_WEIGHT for all insns of a block.  */
end_comment

begin_function
specifier|static
name|void
name|find_insn_reg_weight
parameter_list|(
name|int
name|b
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|,
name|next_tail
decl_stmt|,
name|head
decl_stmt|,
name|tail
decl_stmt|;
name|get_block_head_tail
argument_list|(
name|b
argument_list|,
operator|&
name|head
argument_list|,
operator|&
name|tail
argument_list|)
expr_stmt|;
name|next_tail
operator|=
name|NEXT_INSN
argument_list|(
name|tail
argument_list|)
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|head
init|;
name|insn
operator|!=
name|next_tail
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|int
name|reg_weight
init|=
literal|0
decl_stmt|;
name|rtx
name|x
decl_stmt|;
comment|/* Handle register life information.  */
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
continue|continue;
comment|/* Increment weight for each register born here.  */
name|x
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|reg_weight
operator|+=
name|find_set_reg_weight
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
block|{
name|x
operator|=
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|reg_weight
operator|+=
name|find_set_reg_weight
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Decrement weight for each register that dies here.  */
for|for
control|(
name|x
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|x
condition|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
control|)
block|{
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|x
argument_list|)
operator|==
name|REG_DEAD
operator|||
name|REG_NOTE_KIND
argument_list|(
name|x
argument_list|)
operator|==
name|REG_UNUSED
condition|)
name|reg_weight
operator|--
expr_stmt|;
block|}
name|INSN_REG_WEIGHT
argument_list|(
name|insn
argument_list|)
operator|=
name|reg_weight
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Scheduling clock, modified in schedule_block() and queue_to_ready ().  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|clock_var
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Move insns that became ready to fire from queue to ready list.  */
end_comment

begin_function
specifier|static
name|void
name|queue_to_ready
parameter_list|(
name|struct
name|ready_list
modifier|*
name|ready
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
name|rtx
name|link
decl_stmt|;
name|q_ptr
operator|=
name|NEXT_Q
argument_list|(
name|q_ptr
argument_list|)
expr_stmt|;
comment|/* Add all pending insns that can be scheduled without stalls to the      ready list.  */
for|for
control|(
name|link
operator|=
name|insn_queue
index|[
name|q_ptr
index|]
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|insn
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|q_size
operator|-=
literal|1
expr_stmt|;
if|if
condition|(
name|sched_verbose
operator|>=
literal|2
condition|)
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|";;\t\tQ-->Ready: insn %s: "
argument_list|,
call|(
modifier|*
name|current_sched_info
operator|->
name|print_insn
call|)
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|ready_add
argument_list|(
name|ready
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|sched_verbose
operator|>=
literal|2
condition|)
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|"moving to ready without stalls\n"
argument_list|)
expr_stmt|;
block|}
name|insn_queue
index|[
name|q_ptr
index|]
operator|=
literal|0
expr_stmt|;
comment|/* If there are no ready insns, stall until one is ready and add all      of the pending insns at that point to the ready list.  */
if|if
condition|(
name|ready
operator|->
name|n_ready
operator|==
literal|0
condition|)
block|{
name|int
name|stalls
decl_stmt|;
for|for
control|(
name|stalls
operator|=
literal|1
init|;
name|stalls
operator|<=
name|MAX_INSN_QUEUE_INDEX
condition|;
name|stalls
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|link
operator|=
name|insn_queue
index|[
name|NEXT_Q_AFTER
argument_list|(
name|q_ptr
argument_list|,
name|stalls
argument_list|)
index|]
operator|)
condition|)
block|{
for|for
control|(
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|insn
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|q_size
operator|-=
literal|1
expr_stmt|;
if|if
condition|(
name|sched_verbose
operator|>=
literal|2
condition|)
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|";;\t\tQ-->Ready: insn %s: "
argument_list|,
call|(
modifier|*
name|current_sched_info
operator|->
name|print_insn
call|)
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|ready_add
argument_list|(
name|ready
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|sched_verbose
operator|>=
literal|2
condition|)
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|"moving to ready with %d stalls\n"
argument_list|,
name|stalls
argument_list|)
expr_stmt|;
block|}
name|insn_queue
index|[
name|NEXT_Q_AFTER
argument_list|(
name|q_ptr
argument_list|,
name|stalls
argument_list|)
index|]
operator|=
literal|0
expr_stmt|;
name|advance_one_cycle
argument_list|()
expr_stmt|;
break|break;
block|}
name|advance_one_cycle
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|!
name|targetm
operator|.
name|sched
operator|.
name|use_dfa_pipeline_interface
operator|||
operator|!
call|(
modifier|*
name|targetm
operator|.
name|sched
operator|.
name|use_dfa_pipeline_interface
call|)
argument_list|()
operator|)
operator|&&
name|sched_verbose
operator|&&
name|stalls
condition|)
name|visualize_stall_cycles
argument_list|(
name|stalls
argument_list|)
expr_stmt|;
name|q_ptr
operator|=
name|NEXT_Q_AFTER
argument_list|(
name|q_ptr
argument_list|,
name|stalls
argument_list|)
expr_stmt|;
name|clock_var
operator|+=
name|stalls
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Used by early_queue_to_ready.  Determines whether it is "ok" to    prematurely move INSN from the queue to the ready list.  Currently,     if a target defines the hook 'is_costly_dependence', this function     uses the hook to check whether there exist any dependences which are    considered costly by the target, between INSN and other insns that     have already been scheduled.  Dependences are checked up to Y cycles    back, with default Y=1; The flag -fsched-stalled-insns-dep=Y allows    controlling this value.     (Other considerations could be taken into account instead (or in     addition) depending on user flags and target hooks.  */
end_comment

begin_function
specifier|static
name|bool
name|ok_for_early_queue_removal
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|int
name|n_cycles
decl_stmt|;
name|rtx
name|prev_insn
init|=
name|last_scheduled_insn
decl_stmt|;
if|if
condition|(
name|targetm
operator|.
name|sched
operator|.
name|is_costly_dependence
condition|)
block|{
for|for
control|(
name|n_cycles
operator|=
name|flag_sched_stalled_insns_dep
init|;
name|n_cycles
condition|;
name|n_cycles
operator|--
control|)
block|{
for|for
control|(
init|;
name|prev_insn
condition|;
name|prev_insn
operator|=
name|PREV_INSN
argument_list|(
name|prev_insn
argument_list|)
control|)
block|{
name|rtx
name|dep_link
init|=
literal|0
decl_stmt|;
name|int
name|dep_cost
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|prev_insn
argument_list|)
operator|!=
name|NOTE
condition|)
block|{
name|dep_link
operator|=
name|find_insn_list
argument_list|(
name|insn
argument_list|,
name|INSN_DEPEND
argument_list|(
name|prev_insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dep_link
condition|)
block|{
name|dep_cost
operator|=
name|insn_cost
argument_list|(
name|prev_insn
argument_list|,
name|dep_link
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|targetm
operator|.
name|sched
operator|.
name|is_costly_dependence
argument_list|(
name|prev_insn
argument_list|,
name|insn
argument_list|,
name|dep_link
argument_list|,
name|dep_cost
argument_list|,
name|flag_sched_stalled_insns_dep
operator|-
name|n_cycles
argument_list|)
condition|)
return|return
name|false
return|;
block|}
block|}
if|if
condition|(
name|GET_MODE
argument_list|(
name|prev_insn
argument_list|)
operator|==
name|TImode
condition|)
comment|/* end of dispatch group */
break|break;
block|}
if|if
condition|(
operator|!
name|prev_insn
condition|)
break|break;
name|prev_insn
operator|=
name|PREV_INSN
argument_list|(
name|prev_insn
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Remove insns from the queue, before they become "ready" with respect    to FU latency considerations.  */
end_comment

begin_function
specifier|static
name|int
name|early_queue_to_ready
parameter_list|(
name|state_t
name|state
parameter_list|,
name|struct
name|ready_list
modifier|*
name|ready
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
name|rtx
name|link
decl_stmt|;
name|rtx
name|next_link
decl_stmt|;
name|rtx
name|prev_link
decl_stmt|;
name|bool
name|move_to_ready
decl_stmt|;
name|int
name|cost
decl_stmt|;
name|state_t
name|temp_state
init|=
name|alloca
argument_list|(
name|dfa_state_size
argument_list|)
decl_stmt|;
name|int
name|stalls
decl_stmt|;
name|int
name|insns_removed
init|=
literal|0
decl_stmt|;
comment|/*      Flag '-fsched-stalled-insns=X' determines the aggressiveness of this       function:        X == 0: There is no limit on how many queued insns can be removed                        prematurely.  (flag_sched_stalled_insns = -1).       X>= 1: Only X queued insns can be removed prematurely in each  	     invocation.  (flag_sched_stalled_insns = X).       Otherwise: Early queue removal is disabled.          (flag_sched_stalled_insns = 0)   */
if|if
condition|(
operator|!
name|flag_sched_stalled_insns
condition|)
return|return
literal|0
return|;
for|for
control|(
name|stalls
operator|=
literal|0
init|;
name|stalls
operator|<=
name|MAX_INSN_QUEUE_INDEX
condition|;
name|stalls
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|link
operator|=
name|insn_queue
index|[
name|NEXT_Q_AFTER
argument_list|(
name|q_ptr
argument_list|,
name|stalls
argument_list|)
index|]
operator|)
condition|)
block|{
if|if
condition|(
name|sched_verbose
operator|>
literal|6
condition|)
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|";; look at index %d + %d\n"
argument_list|,
name|q_ptr
argument_list|,
name|stalls
argument_list|)
expr_stmt|;
name|prev_link
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|link
condition|)
block|{
name|next_link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|insn
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|&&
name|sched_verbose
operator|>
literal|6
condition|)
name|print_rtl_single
argument_list|(
name|sched_dump
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|temp_state
argument_list|,
name|state
argument_list|,
name|dfa_state_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|recog_memoized
argument_list|(
name|insn
argument_list|)
operator|<
literal|0
condition|)
comment|/* non-negative to indicate that it's not ready 		   to avoid infinite Q->R->Q->R... */
name|cost
operator|=
literal|0
expr_stmt|;
else|else
name|cost
operator|=
name|state_transition
argument_list|(
name|temp_state
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|sched_verbose
operator|>=
literal|6
condition|)
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|"transition cost = %d\n"
argument_list|,
name|cost
argument_list|)
expr_stmt|;
name|move_to_ready
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|cost
operator|<
literal|0
condition|)
block|{
name|move_to_ready
operator|=
name|ok_for_early_queue_removal
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|move_to_ready
operator|==
name|true
condition|)
block|{
comment|/* move from Q to R */
name|q_size
operator|-=
literal|1
expr_stmt|;
name|ready_add
argument_list|(
name|ready
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev_link
condition|)
name|XEXP
argument_list|(
name|prev_link
argument_list|,
literal|1
argument_list|)
operator|=
name|next_link
expr_stmt|;
else|else
name|insn_queue
index|[
name|NEXT_Q_AFTER
argument_list|(
name|q_ptr
argument_list|,
name|stalls
argument_list|)
index|]
operator|=
name|next_link
expr_stmt|;
name|free_INSN_LIST_node
argument_list|(
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|sched_verbose
operator|>=
literal|2
condition|)
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|";;\t\tEarly Q-->Ready: insn %s\n"
argument_list|,
call|(
modifier|*
name|current_sched_info
operator|->
name|print_insn
call|)
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|insns_removed
operator|++
expr_stmt|;
if|if
condition|(
name|insns_removed
operator|==
name|flag_sched_stalled_insns
condition|)
comment|/* remove only one insn from Q at a time */
return|return
name|insns_removed
return|;
block|}
block|}
if|if
condition|(
name|move_to_ready
operator|==
name|false
condition|)
name|prev_link
operator|=
name|link
expr_stmt|;
name|link
operator|=
name|next_link
expr_stmt|;
block|}
comment|/* while link */
block|}
comment|/* if link */
block|}
comment|/* for stalls.. */
return|return
name|insns_removed
return|;
block|}
end_function

begin_comment
comment|/* Print the ready list for debugging purposes.  Callable from debugger.  */
end_comment

begin_function
specifier|static
name|void
name|debug_ready_list
parameter_list|(
name|struct
name|ready_list
modifier|*
name|ready
parameter_list|)
block|{
name|rtx
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|ready
operator|->
name|n_ready
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|p
operator|=
name|ready_lastpos
argument_list|(
name|ready
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ready
operator|->
name|n_ready
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|"  %s"
argument_list|,
call|(
modifier|*
name|current_sched_info
operator|->
name|print_insn
call|)
argument_list|(
name|p
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* move_insn1: Remove INSN from insn chain, and link it after LAST insn.  */
end_comment

begin_function
specifier|static
name|rtx
name|move_insn1
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|rtx
name|last
parameter_list|)
block|{
name|NEXT_INSN
argument_list|(
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|PREV_INSN
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
operator|=
name|NEXT_INSN
argument_list|(
name|last
argument_list|)
expr_stmt|;
name|PREV_INSN
argument_list|(
name|NEXT_INSN
argument_list|(
name|last
argument_list|)
argument_list|)
operator|=
name|insn
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|last
argument_list|)
operator|=
name|insn
expr_stmt|;
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
operator|=
name|last
expr_stmt|;
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Search INSN for REG_SAVE_NOTE note pairs for    NOTE_INSN_{LOOP,EHREGION}_{BEG,END}; and convert them back into    NOTEs.  The REG_SAVE_NOTE note following first one is contains the    saved value for NOTE_BLOCK_NUMBER which is useful for    NOTE_INSN_EH_REGION_{BEG,END} NOTEs.  LAST is the last instruction    output by the instruction scheduler.  Return the new value of LAST.  */
end_comment

begin_function
specifier|static
name|rtx
name|reemit_notes
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|rtx
name|last
parameter_list|)
block|{
name|rtx
name|note
decl_stmt|,
name|retval
decl_stmt|;
name|retval
operator|=
name|last
expr_stmt|;
for|for
control|(
name|note
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|note
condition|;
name|note
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
control|)
block|{
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
operator|==
name|REG_SAVE_NOTE
condition|)
block|{
name|enum
name|insn_note
name|note_type
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|last
operator|=
name|emit_note_before
argument_list|(
name|note_type
argument_list|,
name|last
argument_list|)
expr_stmt|;
name|remove_note
argument_list|(
name|insn
argument_list|,
name|note
argument_list|)
expr_stmt|;
name|note
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|note_type
operator|==
name|NOTE_INSN_EH_REGION_BEG
operator|||
name|note_type
operator|==
name|NOTE_INSN_EH_REGION_END
condition|)
name|NOTE_EH_HANDLER
argument_list|(
name|last
argument_list|)
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|remove_note
argument_list|(
name|insn
argument_list|,
name|note
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* Move INSN.  Reemit notes if needed.     Return the last insn emitted by the scheduler, which is the    return value from the first call to reemit_notes.  */
end_comment

begin_function
specifier|static
name|rtx
name|move_insn
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|rtx
name|last
parameter_list|)
block|{
name|rtx
name|retval
init|=
name|NULL
decl_stmt|;
name|move_insn1
argument_list|(
name|insn
argument_list|,
name|last
argument_list|)
expr_stmt|;
comment|/* If this is the first call to reemit_notes, then record      its return value.  */
if|if
condition|(
name|retval
operator|==
name|NULL_RTX
condition|)
name|retval
operator|=
name|reemit_notes
argument_list|(
name|insn
argument_list|,
name|insn
argument_list|)
expr_stmt|;
else|else
name|reemit_notes
argument_list|(
name|insn
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|SCHED_GROUP_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* The following structure describe an entry of the stack of choices.  */
end_comment

begin_struct
struct|struct
name|choice_entry
block|{
comment|/* Ordinal number of the issued insn in the ready queue.  */
name|int
name|index
decl_stmt|;
comment|/* The number of the rest insns whose issues we should try.  */
name|int
name|rest
decl_stmt|;
comment|/* The number of issued essential insns.  */
name|int
name|n
decl_stmt|;
comment|/* State after issuing the insn.  */
name|state_t
name|state
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The following array is used to implement a stack of choices used in    function max_issue.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|choice_entry
modifier|*
name|choice_stack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The following variable value is number of essential insns issued on    the current cycle.  An insn is essential one if it changes the    processors state.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cycle_issued_insns
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The following variable value is maximal number of tries of issuing    insns for the first cycle multipass insn scheduling.  We define    this value as constant*(DFA_LOOKAHEAD**ISSUE_RATE).  We would not    need this constraint if all real insns (with non-negative codes)    had reservations because in this case the algorithm complexity is    O(DFA_LOOKAHEAD**ISSUE_RATE).  Unfortunately, the dfa descriptions    might be incomplete and such insn might occur.  For such    descriptions, the complexity of algorithm (without the constraint)    could achieve DFA_LOOKAHEAD ** N , where N is the queue length.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|max_lookahead_tries
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The following value is value of hook    `first_cycle_multipass_dfa_lookahead' at the last call of    `max_issue'.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cached_first_cycle_multipass_dfa_lookahead
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The following value is value of `issue_rate' at the last call of    `sched_init'.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cached_issue_rate
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The following function returns maximal (or close to maximal) number    of insns which can be issued on the same cycle and one of which    insns is insns with the best rank (the first insn in READY).  To    make this function tries different samples of ready insns.  READY    is current queue `ready'.  Global array READY_TRY reflects what    insns are already issued in this try.  INDEX will contain index    of the best insn in READY.  The following function is used only for    first cycle multipass scheduling.  */
end_comment

begin_function
specifier|static
name|int
name|max_issue
parameter_list|(
name|struct
name|ready_list
modifier|*
name|ready
parameter_list|,
name|int
modifier|*
name|index
parameter_list|)
block|{
name|int
name|n
decl_stmt|,
name|i
decl_stmt|,
name|all
decl_stmt|,
name|n_ready
decl_stmt|,
name|best
decl_stmt|,
name|delay
decl_stmt|,
name|tries_num
decl_stmt|;
name|struct
name|choice_entry
modifier|*
name|top
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|best
operator|=
literal|0
expr_stmt|;
name|memcpy
argument_list|(
name|choice_stack
operator|->
name|state
argument_list|,
name|curr_state
argument_list|,
name|dfa_state_size
argument_list|)
expr_stmt|;
name|top
operator|=
name|choice_stack
expr_stmt|;
name|top
operator|->
name|rest
operator|=
name|cached_first_cycle_multipass_dfa_lookahead
expr_stmt|;
name|top
operator|->
name|n
operator|=
literal|0
expr_stmt|;
name|n_ready
operator|=
name|ready
operator|->
name|n_ready
expr_stmt|;
for|for
control|(
name|all
operator|=
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_ready
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|ready_try
index|[
name|i
index|]
condition|)
name|all
operator|++
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|tries_num
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|top
operator|->
name|rest
operator|==
literal|0
operator|||
name|i
operator|>=
name|n_ready
condition|)
block|{
if|if
condition|(
name|top
operator|==
name|choice_stack
condition|)
break|break;
if|if
condition|(
name|best
operator|<
name|top
operator|-
name|choice_stack
operator|&&
name|ready_try
index|[
literal|0
index|]
condition|)
block|{
name|best
operator|=
name|top
operator|-
name|choice_stack
expr_stmt|;
operator|*
name|index
operator|=
name|choice_stack
index|[
literal|1
index|]
operator|.
name|index
expr_stmt|;
if|if
condition|(
name|top
operator|->
name|n
operator|==
name|issue_rate
operator|-
name|cycle_issued_insns
operator|||
name|best
operator|==
name|all
condition|)
break|break;
block|}
name|i
operator|=
name|top
operator|->
name|index
expr_stmt|;
name|ready_try
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|top
operator|--
expr_stmt|;
name|memcpy
argument_list|(
name|curr_state
argument_list|,
name|top
operator|->
name|state
argument_list|,
name|dfa_state_size
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|ready_try
index|[
name|i
index|]
condition|)
block|{
name|tries_num
operator|++
expr_stmt|;
if|if
condition|(
name|tries_num
operator|>
name|max_lookahead_tries
condition|)
break|break;
name|insn
operator|=
name|ready_element
argument_list|(
name|ready
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|delay
operator|=
name|state_transition
argument_list|(
name|curr_state
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|delay
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|state_dead_lock_p
argument_list|(
name|curr_state
argument_list|)
condition|)
name|top
operator|->
name|rest
operator|=
literal|0
expr_stmt|;
else|else
name|top
operator|->
name|rest
operator|--
expr_stmt|;
name|n
operator|=
name|top
operator|->
name|n
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|top
operator|->
name|state
argument_list|,
name|curr_state
argument_list|,
name|dfa_state_size
argument_list|)
operator|!=
literal|0
condition|)
name|n
operator|++
expr_stmt|;
name|top
operator|++
expr_stmt|;
name|top
operator|->
name|rest
operator|=
name|cached_first_cycle_multipass_dfa_lookahead
expr_stmt|;
name|top
operator|->
name|index
operator|=
name|i
expr_stmt|;
name|top
operator|->
name|n
operator|=
name|n
expr_stmt|;
name|memcpy
argument_list|(
name|top
operator|->
name|state
argument_list|,
name|curr_state
argument_list|,
name|dfa_state_size
argument_list|)
expr_stmt|;
name|ready_try
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|i
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
name|i
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|top
operator|!=
name|choice_stack
condition|)
block|{
name|ready_try
index|[
name|top
operator|->
name|index
index|]
operator|=
literal|0
expr_stmt|;
name|top
operator|--
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|curr_state
argument_list|,
name|choice_stack
operator|->
name|state
argument_list|,
name|dfa_state_size
argument_list|)
expr_stmt|;
return|return
name|best
return|;
block|}
end_function

begin_comment
comment|/* The following function chooses insn from READY and modifies    *N_READY and READY.  The following function is used only for first    cycle multipass scheduling.  */
end_comment

begin_function
specifier|static
name|rtx
name|choose_ready
parameter_list|(
name|struct
name|ready_list
modifier|*
name|ready
parameter_list|)
block|{
name|int
name|lookahead
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|targetm
operator|.
name|sched
operator|.
name|first_cycle_multipass_dfa_lookahead
condition|)
name|lookahead
operator|=
call|(
modifier|*
name|targetm
operator|.
name|sched
operator|.
name|first_cycle_multipass_dfa_lookahead
call|)
argument_list|()
expr_stmt|;
if|if
condition|(
name|lookahead
operator|<=
literal|0
operator|||
name|SCHED_GROUP_P
argument_list|(
name|ready_element
argument_list|(
name|ready
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|ready_remove_first
argument_list|(
name|ready
argument_list|)
return|;
else|else
block|{
comment|/* Try to choose the better insn.  */
name|int
name|index
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
if|if
condition|(
name|cached_first_cycle_multipass_dfa_lookahead
operator|!=
name|lookahead
condition|)
block|{
name|cached_first_cycle_multipass_dfa_lookahead
operator|=
name|lookahead
expr_stmt|;
name|max_lookahead_tries
operator|=
literal|100
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|issue_rate
condition|;
name|i
operator|++
control|)
name|max_lookahead_tries
operator|*=
name|lookahead
expr_stmt|;
block|}
name|insn
operator|=
name|ready_element
argument_list|(
name|ready
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|<
literal|0
condition|)
return|return
name|ready_remove_first
argument_list|(
name|ready
argument_list|)
return|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|ready
operator|->
name|n_ready
condition|;
name|i
operator|++
control|)
block|{
name|insn
operator|=
name|ready_element
argument_list|(
name|ready
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|ready_try
index|[
name|i
index|]
operator|=
operator|(
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|<
literal|0
operator|||
operator|(
name|targetm
operator|.
name|sched
operator|.
name|first_cycle_multipass_dfa_lookahead_guard
operator|&&
operator|!
call|(
modifier|*
name|targetm
operator|.
name|sched
operator|.
name|first_cycle_multipass_dfa_lookahead_guard
call|)
argument_list|(
name|insn
argument_list|)
operator|)
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|max_issue
argument_list|(
name|ready
argument_list|,
operator|&
name|index
argument_list|)
operator|==
literal|0
condition|)
return|return
name|ready_remove_first
argument_list|(
name|ready
argument_list|)
return|;
else|else
return|return
name|ready_remove
argument_list|(
name|ready
argument_list|,
name|index
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Called from backends from targetm.sched.reorder to emit stuff into    the instruction stream.  */
end_comment

begin_function
name|rtx
name|sched_emit_insn
parameter_list|(
name|rtx
name|pat
parameter_list|)
block|{
name|rtx
name|insn
init|=
name|emit_insn_after
argument_list|(
name|pat
argument_list|,
name|last_scheduled_insn
argument_list|)
decl_stmt|;
name|last_scheduled_insn
operator|=
name|insn
expr_stmt|;
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Use forward list scheduling to rearrange insns of block B in region RGN,    possibly bringing insns from subsequent blocks in the same region.  */
end_comment

begin_function
name|void
name|schedule_block
parameter_list|(
name|int
name|b
parameter_list|,
name|int
name|rgn_n_insns
parameter_list|)
block|{
name|struct
name|ready_list
name|ready
decl_stmt|;
name|int
name|i
decl_stmt|,
name|first_cycle_insn_p
decl_stmt|;
name|int
name|can_issue_more
decl_stmt|;
name|state_t
name|temp_state
init|=
name|NULL
decl_stmt|;
comment|/* It is used for multipass scheduling.  */
name|int
name|sort_p
decl_stmt|,
name|advance
decl_stmt|,
name|start_clock_var
decl_stmt|;
comment|/* Head/tail info for this block.  */
name|rtx
name|prev_head
init|=
name|current_sched_info
operator|->
name|prev_head
decl_stmt|;
name|rtx
name|next_tail
init|=
name|current_sched_info
operator|->
name|next_tail
decl_stmt|;
name|rtx
name|head
init|=
name|NEXT_INSN
argument_list|(
name|prev_head
argument_list|)
decl_stmt|;
name|rtx
name|tail
init|=
name|PREV_INSN
argument_list|(
name|next_tail
argument_list|)
decl_stmt|;
comment|/* We used to have code to avoid getting parameters moved from hard      argument registers into pseudos.       However, it was removed when it proved to be of marginal benefit      and caused problems because schedule_block and compute_forward_dependences      had different notions of what the "head" insn was.  */
if|if
condition|(
name|head
operator|==
name|tail
operator|&&
operator|(
operator|!
name|INSN_P
argument_list|(
name|head
argument_list|)
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Debug info.  */
if|if
condition|(
name|sched_verbose
condition|)
block|{
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|";;   ======================================================\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|";;   -- basic block %d from %d to %d -- %s reload\n"
argument_list|,
name|b
argument_list|,
name|INSN_UID
argument_list|(
name|head
argument_list|)
argument_list|,
name|INSN_UID
argument_list|(
name|tail
argument_list|)
argument_list|,
operator|(
name|reload_completed
condition|?
literal|"after"
else|:
literal|"before"
operator|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|";;   ======================================================\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|visualize_alloc
argument_list|()
expr_stmt|;
name|init_block_visualization
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|targetm
operator|.
name|sched
operator|.
name|use_dfa_pipeline_interface
operator|&&
call|(
modifier|*
name|targetm
operator|.
name|sched
operator|.
name|use_dfa_pipeline_interface
call|)
argument_list|()
condition|)
name|state_reset
argument_list|(
name|curr_state
argument_list|)
expr_stmt|;
else|else
name|clear_units
argument_list|()
expr_stmt|;
comment|/* Allocate the ready list.  */
name|ready
operator|.
name|veclen
operator|=
name|rgn_n_insns
operator|+
literal|1
operator|+
name|issue_rate
expr_stmt|;
name|ready
operator|.
name|first
operator|=
name|ready
operator|.
name|veclen
operator|-
literal|1
expr_stmt|;
name|ready
operator|.
name|vec
operator|=
name|xmalloc
argument_list|(
name|ready
operator|.
name|veclen
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|ready
operator|.
name|n_ready
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|targetm
operator|.
name|sched
operator|.
name|use_dfa_pipeline_interface
operator|&&
call|(
modifier|*
name|targetm
operator|.
name|sched
operator|.
name|use_dfa_pipeline_interface
call|)
argument_list|()
condition|)
block|{
comment|/* It is used for first cycle multipass scheduling.  */
name|temp_state
operator|=
name|alloca
argument_list|(
name|dfa_state_size
argument_list|)
expr_stmt|;
name|ready_try
operator|=
name|xcalloc
argument_list|(
operator|(
name|rgn_n_insns
operator|+
literal|1
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
name|choice_stack
operator|=
name|xmalloc
argument_list|(
operator|(
name|rgn_n_insns
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|choice_entry
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|rgn_n_insns
condition|;
name|i
operator|++
control|)
name|choice_stack
index|[
name|i
index|]
operator|.
name|state
operator|=
name|xmalloc
argument_list|(
name|dfa_state_size
argument_list|)
expr_stmt|;
block|}
call|(
modifier|*
name|current_sched_info
operator|->
name|init_ready_list
call|)
argument_list|(
operator|&
name|ready
argument_list|)
expr_stmt|;
if|if
condition|(
name|targetm
operator|.
name|sched
operator|.
name|md_init
condition|)
call|(
modifier|*
name|targetm
operator|.
name|sched
operator|.
name|md_init
call|)
argument_list|(
name|sched_dump
argument_list|,
name|sched_verbose
argument_list|,
name|ready
operator|.
name|veclen
argument_list|)
expr_stmt|;
comment|/* We start inserting insns after PREV_HEAD.  */
name|last_scheduled_insn
operator|=
name|prev_head
expr_stmt|;
comment|/* Initialize INSN_QUEUE.  Q_SIZE is the total number of insns in the      queue.  */
name|q_ptr
operator|=
literal|0
expr_stmt|;
name|q_size
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|targetm
operator|.
name|sched
operator|.
name|use_dfa_pipeline_interface
operator|||
operator|!
call|(
modifier|*
name|targetm
operator|.
name|sched
operator|.
name|use_dfa_pipeline_interface
call|)
argument_list|()
condition|)
name|max_insn_queue_index_macro_value
operator|=
name|INSN_QUEUE_SIZE
operator|-
literal|1
expr_stmt|;
else|else
name|max_insn_queue_index_macro_value
operator|=
name|max_insn_queue_index
expr_stmt|;
name|insn_queue
operator|=
name|alloca
argument_list|(
operator|(
name|MAX_INSN_QUEUE_INDEX
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|insn_queue
argument_list|,
literal|0
argument_list|,
operator|(
name|MAX_INSN_QUEUE_INDEX
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|last_clock_var
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Start just before the beginning of time.  */
name|clock_var
operator|=
operator|-
literal|1
expr_stmt|;
name|advance
operator|=
literal|0
expr_stmt|;
name|sort_p
operator|=
name|TRUE
expr_stmt|;
comment|/* Loop until all the insns in BB are scheduled.  */
while|while
condition|(
call|(
modifier|*
name|current_sched_info
operator|->
name|schedule_more_p
call|)
argument_list|()
condition|)
block|{
do|do
block|{
name|start_clock_var
operator|=
name|clock_var
expr_stmt|;
name|clock_var
operator|++
expr_stmt|;
name|advance_one_cycle
argument_list|()
expr_stmt|;
comment|/* Add to the ready list all pending insns that can be issued now. 	     If there are no ready insns, increment clock until one 	     is ready and add all pending insns at that point to the ready 	     list.  */
name|queue_to_ready
argument_list|(
operator|&
name|ready
argument_list|)
expr_stmt|;
if|if
condition|(
name|ready
operator|.
name|n_ready
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|sched_verbose
operator|>=
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|";;\t\tReady list after queue_to_ready:  "
argument_list|)
expr_stmt|;
name|debug_ready_list
argument_list|(
operator|&
name|ready
argument_list|)
expr_stmt|;
block|}
name|advance
operator|-=
name|clock_var
operator|-
name|start_clock_var
expr_stmt|;
block|}
do|while
condition|(
name|advance
operator|>
literal|0
condition|)
do|;
if|if
condition|(
name|sort_p
condition|)
block|{
comment|/* Sort the ready list based on priority.  */
name|ready_sort
argument_list|(
operator|&
name|ready
argument_list|)
expr_stmt|;
if|if
condition|(
name|sched_verbose
operator|>=
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|";;\t\tReady list after ready_sort:  "
argument_list|)
expr_stmt|;
name|debug_ready_list
argument_list|(
operator|&
name|ready
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Allow the target to reorder the list, typically for 	 better instruction bundling.  */
if|if
condition|(
name|sort_p
operator|&&
name|targetm
operator|.
name|sched
operator|.
name|reorder
operator|&&
operator|(
name|ready
operator|.
name|n_ready
operator|==
literal|0
operator|||
operator|!
name|SCHED_GROUP_P
argument_list|(
name|ready_element
argument_list|(
operator|&
name|ready
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
condition|)
name|can_issue_more
operator|=
call|(
modifier|*
name|targetm
operator|.
name|sched
operator|.
name|reorder
call|)
argument_list|(
name|sched_dump
argument_list|,
name|sched_verbose
argument_list|,
name|ready_lastpos
argument_list|(
operator|&
name|ready
argument_list|)
argument_list|,
operator|&
name|ready
operator|.
name|n_ready
argument_list|,
name|clock_var
argument_list|)
expr_stmt|;
else|else
name|can_issue_more
operator|=
name|issue_rate
expr_stmt|;
name|first_cycle_insn_p
operator|=
literal|1
expr_stmt|;
name|cycle_issued_insns
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|rtx
name|insn
decl_stmt|;
name|int
name|cost
decl_stmt|;
name|bool
name|asm_p
init|=
name|false
decl_stmt|;
if|if
condition|(
name|sched_verbose
operator|>=
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|";;\tReady list (t =%3d):  "
argument_list|,
name|clock_var
argument_list|)
expr_stmt|;
name|debug_ready_list
argument_list|(
operator|&
name|ready
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|targetm
operator|.
name|sched
operator|.
name|use_dfa_pipeline_interface
operator|||
operator|!
call|(
modifier|*
name|targetm
operator|.
name|sched
operator|.
name|use_dfa_pipeline_interface
call|)
argument_list|()
condition|)
block|{
if|if
condition|(
name|ready
operator|.
name|n_ready
operator|==
literal|0
operator|||
operator|!
name|can_issue_more
operator|||
operator|!
call|(
modifier|*
name|current_sched_info
operator|->
name|schedule_more_p
call|)
argument_list|()
condition|)
break|break;
name|insn
operator|=
name|ready_remove_first
argument_list|(
operator|&
name|ready
argument_list|)
expr_stmt|;
name|cost
operator|=
name|actual_hazard
argument_list|(
name|insn_unit
argument_list|(
name|insn
argument_list|)
argument_list|,
name|insn
argument_list|,
name|clock_var
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ready
operator|.
name|n_ready
operator|==
literal|0
operator|&&
name|can_issue_more
operator|&&
name|reload_completed
condition|)
block|{
comment|/* Allow scheduling insns directly from the queue in case 		     there's nothing better to do (ready list is empty) but 		     there are still vacant dispatch slots in the current cycle.  */
if|if
condition|(
name|sched_verbose
operator|>=
literal|6
condition|)
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|";;\t\tSecond chance\n"
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|temp_state
argument_list|,
name|curr_state
argument_list|,
name|dfa_state_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|early_queue_to_ready
argument_list|(
name|temp_state
argument_list|,
operator|&
name|ready
argument_list|)
condition|)
name|ready_sort
argument_list|(
operator|&
name|ready
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ready
operator|.
name|n_ready
operator|==
literal|0
operator|||
operator|!
name|can_issue_more
operator|||
name|state_dead_lock_p
argument_list|(
name|curr_state
argument_list|)
operator|||
operator|!
call|(
modifier|*
name|current_sched_info
operator|->
name|schedule_more_p
call|)
argument_list|()
condition|)
break|break;
comment|/* Select and remove the insn from the ready list.  */
if|if
condition|(
name|sort_p
condition|)
name|insn
operator|=
name|choose_ready
argument_list|(
operator|&
name|ready
argument_list|)
expr_stmt|;
else|else
name|insn
operator|=
name|ready_remove_first
argument_list|(
operator|&
name|ready
argument_list|)
expr_stmt|;
if|if
condition|(
name|targetm
operator|.
name|sched
operator|.
name|dfa_new_cycle
operator|&&
call|(
modifier|*
name|targetm
operator|.
name|sched
operator|.
name|dfa_new_cycle
call|)
argument_list|(
name|sched_dump
argument_list|,
name|sched_verbose
argument_list|,
name|insn
argument_list|,
name|last_clock_var
argument_list|,
name|clock_var
argument_list|,
operator|&
name|sort_p
argument_list|)
condition|)
block|{
name|ready_add
argument_list|(
operator|&
name|ready
argument_list|,
name|insn
argument_list|)
expr_stmt|;
break|break;
block|}
name|sort_p
operator|=
name|TRUE
expr_stmt|;
name|memcpy
argument_list|(
name|temp_state
argument_list|,
name|curr_state
argument_list|,
name|dfa_state_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|recog_memoized
argument_list|(
name|insn
argument_list|)
operator|<
literal|0
condition|)
block|{
name|asm_p
operator|=
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|ASM_INPUT
operator|||
name|asm_noperands
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|>=
literal|0
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|first_cycle_insn_p
operator|&&
name|asm_p
condition|)
comment|/* This is asm insn which is tryed to be issued on the 		       cycle not first.  Issue it on the next cycle.  */
name|cost
operator|=
literal|1
expr_stmt|;
else|else
comment|/* A USE insn, or something else we don't need to 		       understand.  We can't pass these directly to 		       state_transition because it will trigger a 		       fatal error for unrecognizable insns.  */
name|cost
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|cost
operator|=
name|state_transition
argument_list|(
name|temp_state
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|targetm
operator|.
name|sched
operator|.
name|first_cycle_multipass_dfa_lookahead
operator|&&
name|targetm
operator|.
name|sched
operator|.
name|dfa_bubble
condition|)
block|{
if|if
condition|(
name|cost
operator|==
literal|0
condition|)
block|{
name|int
name|j
decl_stmt|;
name|rtx
name|bubble
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
operator|(
name|bubble
operator|=
call|(
modifier|*
name|targetm
operator|.
name|sched
operator|.
name|dfa_bubble
call|)
argument_list|(
name|j
argument_list|)
operator|)
operator|!=
name|NULL_RTX
condition|;
name|j
operator|++
control|)
block|{
name|memcpy
argument_list|(
name|temp_state
argument_list|,
name|curr_state
argument_list|,
name|dfa_state_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|state_transition
argument_list|(
name|temp_state
argument_list|,
name|bubble
argument_list|)
operator|<
literal|0
operator|&&
name|state_transition
argument_list|(
name|temp_state
argument_list|,
name|insn
argument_list|)
operator|<
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|bubble
operator|!=
name|NULL_RTX
condition|)
block|{
if|if
condition|(
name|insert_schedule_bubbles_p
condition|)
block|{
name|rtx
name|copy
decl_stmt|;
name|copy
operator|=
name|copy_rtx
argument_list|(
name|PATTERN
argument_list|(
name|bubble
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn_after
argument_list|(
name|copy
argument_list|,
name|last_scheduled_insn
argument_list|)
expr_stmt|;
name|last_scheduled_insn
operator|=
name|NEXT_INSN
argument_list|(
name|last_scheduled_insn
argument_list|)
expr_stmt|;
name|INSN_CODE
argument_list|(
name|last_scheduled_insn
argument_list|)
operator|=
name|INSN_CODE
argument_list|(
name|bubble
argument_list|)
expr_stmt|;
comment|/* Annotate the same for the first insns 				     scheduling by using mode.  */
name|PUT_MODE
argument_list|(
name|last_scheduled_insn
argument_list|,
operator|(
name|clock_var
operator|>
name|last_clock_var
condition|?
name|clock_var
operator|-
name|last_clock_var
else|:
name|VOIDmode
operator|)
argument_list|)
expr_stmt|;
name|last_clock_var
operator|=
name|clock_var
expr_stmt|;
if|if
condition|(
name|sched_verbose
operator|>=
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|";;\t\t--> scheduling bubble insn<<<%d>>>:reservation "
argument_list|,
name|INSN_UID
argument_list|(
name|last_scheduled_insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|recog_memoized
argument_list|(
name|last_scheduled_insn
argument_list|)
operator|<
literal|0
condition|)
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|"nothing"
argument_list|)
expr_stmt|;
else|else
name|print_reservation
argument_list|(
name|sched_dump
argument_list|,
name|last_scheduled_insn
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|cost
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|cost
operator|<
literal|0
condition|)
name|cost
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|cost
operator|==
literal|0
condition|)
name|cost
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cost
operator|>=
literal|1
condition|)
block|{
name|queue_insn
argument_list|(
name|insn
argument_list|,
name|cost
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
call|(
modifier|*
name|current_sched_info
operator|->
name|can_schedule_ready_p
call|)
argument_list|(
name|insn
argument_list|)
condition|)
goto|goto
name|next
goto|;
name|last_scheduled_insn
operator|=
name|move_insn
argument_list|(
name|insn
argument_list|,
name|last_scheduled_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|targetm
operator|.
name|sched
operator|.
name|use_dfa_pipeline_interface
operator|&&
call|(
modifier|*
name|targetm
operator|.
name|sched
operator|.
name|use_dfa_pipeline_interface
call|)
argument_list|()
condition|)
block|{
if|if
condition|(
name|memcmp
argument_list|(
name|curr_state
argument_list|,
name|temp_state
argument_list|,
name|dfa_state_size
argument_list|)
operator|!=
literal|0
condition|)
name|cycle_issued_insns
operator|++
expr_stmt|;
name|memcpy
argument_list|(
name|curr_state
argument_list|,
name|temp_state
argument_list|,
name|dfa_state_size
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|targetm
operator|.
name|sched
operator|.
name|variable_issue
condition|)
name|can_issue_more
operator|=
call|(
modifier|*
name|targetm
operator|.
name|sched
operator|.
name|variable_issue
call|)
argument_list|(
name|sched_dump
argument_list|,
name|sched_verbose
argument_list|,
name|insn
argument_list|,
name|can_issue_more
argument_list|)
expr_stmt|;
comment|/* A naked CLOBBER or USE generates no instruction, so do 	     not count them against the issue rate.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|USE
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|CLOBBER
condition|)
name|can_issue_more
operator|--
expr_stmt|;
name|advance
operator|=
name|schedule_insn
argument_list|(
name|insn
argument_list|,
operator|&
name|ready
argument_list|,
name|clock_var
argument_list|)
expr_stmt|;
comment|/* After issuing an asm insn we should start a new cycle.  */
if|if
condition|(
name|advance
operator|==
literal|0
operator|&&
name|asm_p
condition|)
name|advance
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|advance
operator|!=
literal|0
condition|)
break|break;
name|next
label|:
name|first_cycle_insn_p
operator|=
literal|0
expr_stmt|;
comment|/* Sort the ready list based on priority.  This must be 	     redone here, as schedule_insn may have readied additional 	     insns that will not be sorted correctly.  */
if|if
condition|(
name|ready
operator|.
name|n_ready
operator|>
literal|0
condition|)
name|ready_sort
argument_list|(
operator|&
name|ready
argument_list|)
expr_stmt|;
if|if
condition|(
name|targetm
operator|.
name|sched
operator|.
name|reorder2
operator|&&
operator|(
name|ready
operator|.
name|n_ready
operator|==
literal|0
operator|||
operator|!
name|SCHED_GROUP_P
argument_list|(
name|ready_element
argument_list|(
operator|&
name|ready
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|can_issue_more
operator|=
call|(
modifier|*
name|targetm
operator|.
name|sched
operator|.
name|reorder2
call|)
argument_list|(
name|sched_dump
argument_list|,
name|sched_verbose
argument_list|,
name|ready
operator|.
name|n_ready
condition|?
name|ready_lastpos
argument_list|(
operator|&
name|ready
argument_list|)
else|:
name|NULL
argument_list|,
operator|&
name|ready
operator|.
name|n_ready
argument_list|,
name|clock_var
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
operator|!
name|targetm
operator|.
name|sched
operator|.
name|use_dfa_pipeline_interface
operator|||
operator|!
call|(
modifier|*
name|targetm
operator|.
name|sched
operator|.
name|use_dfa_pipeline_interface
call|)
argument_list|()
operator|)
operator|&&
name|sched_verbose
condition|)
comment|/* Debug info.  */
name|visualize_scheduled_insns
argument_list|(
name|clock_var
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|targetm
operator|.
name|sched
operator|.
name|md_finish
condition|)
call|(
modifier|*
name|targetm
operator|.
name|sched
operator|.
name|md_finish
call|)
argument_list|(
name|sched_dump
argument_list|,
name|sched_verbose
argument_list|)
expr_stmt|;
comment|/* Debug info.  */
if|if
condition|(
name|sched_verbose
condition|)
block|{
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|";;\tReady list (final):  "
argument_list|)
expr_stmt|;
name|debug_ready_list
argument_list|(
operator|&
name|ready
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|targetm
operator|.
name|sched
operator|.
name|use_dfa_pipeline_interface
operator|||
operator|!
call|(
modifier|*
name|targetm
operator|.
name|sched
operator|.
name|use_dfa_pipeline_interface
call|)
argument_list|()
condition|)
name|print_block_visualization
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
comment|/* Sanity check -- queue must be empty now.  Meaningless if region has      multiple bbs.  */
if|if
condition|(
name|current_sched_info
operator|->
name|queue_must_finish_empty
operator|&&
name|q_size
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Update head/tail boundaries.  */
name|head
operator|=
name|NEXT_INSN
argument_list|(
name|prev_head
argument_list|)
expr_stmt|;
name|tail
operator|=
name|last_scheduled_insn
expr_stmt|;
if|if
condition|(
operator|!
name|reload_completed
condition|)
block|{
name|rtx
name|insn
decl_stmt|,
name|link
decl_stmt|,
name|next
decl_stmt|;
comment|/* INSN_TICK (minimum clock tick at which the insn becomes          ready) may be not correct for the insn in the subsequent          blocks of the region.  We should use a correct value of          `clock_var' or modify INSN_TICK.  It is better to keep          clock_var value equal to 0 at the start of a basic block.          Therefore we modify INSN_TICK here.  */
for|for
control|(
name|insn
operator|=
name|head
init|;
name|insn
operator|!=
name|tail
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
for|for
control|(
name|link
operator|=
name|INSN_DEPEND
argument_list|(
name|insn
argument_list|)
init|;
name|link
operator|!=
literal|0
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|next
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|INSN_TICK
argument_list|(
name|next
argument_list|)
operator|-=
name|clock_var
expr_stmt|;
block|}
block|}
block|}
comment|/* Restore-other-notes: NOTE_LIST is the end of a chain of notes      previously found among the insns.  Insert them at the beginning      of the insns.  */
if|if
condition|(
name|note_list
operator|!=
literal|0
condition|)
block|{
name|rtx
name|note_head
init|=
name|note_list
decl_stmt|;
while|while
condition|(
name|PREV_INSN
argument_list|(
name|note_head
argument_list|)
condition|)
block|{
name|note_head
operator|=
name|PREV_INSN
argument_list|(
name|note_head
argument_list|)
expr_stmt|;
block|}
name|PREV_INSN
argument_list|(
name|note_head
argument_list|)
operator|=
name|PREV_INSN
argument_list|(
name|head
argument_list|)
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|PREV_INSN
argument_list|(
name|head
argument_list|)
argument_list|)
operator|=
name|note_head
expr_stmt|;
name|PREV_INSN
argument_list|(
name|head
argument_list|)
operator|=
name|note_list
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|note_list
argument_list|)
operator|=
name|head
expr_stmt|;
name|head
operator|=
name|note_head
expr_stmt|;
block|}
comment|/* Debugging.  */
if|if
condition|(
name|sched_verbose
condition|)
block|{
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|";;   total time = %d\n;;   new head = %d\n"
argument_list|,
name|clock_var
argument_list|,
name|INSN_UID
argument_list|(
name|head
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|";;   new tail = %d\n\n"
argument_list|,
name|INSN_UID
argument_list|(
name|tail
argument_list|)
argument_list|)
expr_stmt|;
name|visualize_free
argument_list|()
expr_stmt|;
block|}
name|current_sched_info
operator|->
name|head
operator|=
name|head
expr_stmt|;
name|current_sched_info
operator|->
name|tail
operator|=
name|tail
expr_stmt|;
name|free
argument_list|(
name|ready
operator|.
name|vec
argument_list|)
expr_stmt|;
if|if
condition|(
name|targetm
operator|.
name|sched
operator|.
name|use_dfa_pipeline_interface
operator|&&
call|(
modifier|*
name|targetm
operator|.
name|sched
operator|.
name|use_dfa_pipeline_interface
call|)
argument_list|()
condition|)
block|{
name|free
argument_list|(
name|ready_try
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|rgn_n_insns
condition|;
name|i
operator|++
control|)
name|free
argument_list|(
name|choice_stack
index|[
name|i
index|]
operator|.
name|state
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|choice_stack
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Set_priorities: compute priority of each insn in the block.  */
end_comment

begin_function
name|int
name|set_priorities
parameter_list|(
name|rtx
name|head
parameter_list|,
name|rtx
name|tail
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
name|int
name|n_insn
decl_stmt|;
name|int
name|sched_max_insns_priority
init|=
name|current_sched_info
operator|->
name|sched_max_insns_priority
decl_stmt|;
name|rtx
name|prev_head
decl_stmt|;
name|prev_head
operator|=
name|PREV_INSN
argument_list|(
name|head
argument_list|)
expr_stmt|;
if|if
condition|(
name|head
operator|==
name|tail
operator|&&
operator|(
operator|!
name|INSN_P
argument_list|(
name|head
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
name|n_insn
operator|=
literal|0
expr_stmt|;
name|sched_max_insns_priority
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|tail
init|;
name|insn
operator|!=
name|prev_head
condition|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
continue|continue;
name|n_insn
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|priority
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|INSN_PRIORITY_KNOWN
argument_list|(
name|insn
argument_list|)
condition|)
name|sched_max_insns_priority
operator|=
name|MAX
argument_list|(
name|sched_max_insns_priority
argument_list|,
name|INSN_PRIORITY
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|sched_max_insns_priority
operator|+=
literal|1
expr_stmt|;
name|current_sched_info
operator|->
name|sched_max_insns_priority
operator|=
name|sched_max_insns_priority
expr_stmt|;
return|return
name|n_insn
return|;
block|}
end_function

begin_comment
comment|/* Initialize some global state for the scheduler.  DUMP_FILE is to be used    for debugging output.  */
end_comment

begin_function
name|void
name|sched_init
parameter_list|(
name|FILE
modifier|*
name|dump_file
parameter_list|)
block|{
name|int
name|luid
decl_stmt|;
name|basic_block
name|b
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Disable speculative loads in their presence if cc0 defined.  */
ifdef|#
directive|ifdef
name|HAVE_cc0
name|flag_schedule_speculative_load
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* Set dump and sched_verbose for the desired debugging output.  If no      dump-file was specified, but -fsched-verbose=N (any N), print to stderr.      For -fsched-verbose=N, N>=10, print everything to stderr.  */
name|sched_verbose
operator|=
name|sched_verbose_param
expr_stmt|;
if|if
condition|(
name|sched_verbose_param
operator|==
literal|0
operator|&&
name|dump_file
condition|)
name|sched_verbose
operator|=
literal|1
expr_stmt|;
name|sched_dump
operator|=
operator|(
operator|(
name|sched_verbose_param
operator|>=
literal|10
operator|||
operator|!
name|dump_file
operator|)
condition|?
name|stderr
else|:
name|dump_file
operator|)
expr_stmt|;
comment|/* Initialize issue_rate.  */
if|if
condition|(
name|targetm
operator|.
name|sched
operator|.
name|issue_rate
condition|)
name|issue_rate
operator|=
call|(
modifier|*
name|targetm
operator|.
name|sched
operator|.
name|issue_rate
call|)
argument_list|()
expr_stmt|;
else|else
name|issue_rate
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|cached_issue_rate
operator|!=
name|issue_rate
condition|)
block|{
name|cached_issue_rate
operator|=
name|issue_rate
expr_stmt|;
comment|/* To invalidate max_lookahead_tries:  */
name|cached_first_cycle_multipass_dfa_lookahead
operator|=
literal|0
expr_stmt|;
block|}
comment|/* We use LUID 0 for the fake insn (UID 0) which holds dependencies for      pseudos which do not cross calls.  */
name|old_max_uid
operator|=
name|get_max_uid
argument_list|()
operator|+
literal|1
expr_stmt|;
name|h_i_d
operator|=
name|xcalloc
argument_list|(
name|old_max_uid
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|h_i_d
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|old_max_uid
condition|;
name|i
operator|++
control|)
name|h_i_d
index|[
name|i
index|]
operator|.
name|cost
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|targetm
operator|.
name|sched
operator|.
name|use_dfa_pipeline_interface
operator|&&
call|(
modifier|*
name|targetm
operator|.
name|sched
operator|.
name|use_dfa_pipeline_interface
call|)
argument_list|()
condition|)
block|{
if|if
condition|(
name|targetm
operator|.
name|sched
operator|.
name|init_dfa_pre_cycle_insn
condition|)
call|(
modifier|*
name|targetm
operator|.
name|sched
operator|.
name|init_dfa_pre_cycle_insn
call|)
argument_list|()
expr_stmt|;
if|if
condition|(
name|targetm
operator|.
name|sched
operator|.
name|init_dfa_post_cycle_insn
condition|)
call|(
modifier|*
name|targetm
operator|.
name|sched
operator|.
name|init_dfa_post_cycle_insn
call|)
argument_list|()
expr_stmt|;
if|if
condition|(
name|targetm
operator|.
name|sched
operator|.
name|first_cycle_multipass_dfa_lookahead
operator|&&
name|targetm
operator|.
name|sched
operator|.
name|init_dfa_bubbles
condition|)
call|(
modifier|*
name|targetm
operator|.
name|sched
operator|.
name|init_dfa_bubbles
call|)
argument_list|()
expr_stmt|;
name|dfa_start
argument_list|()
expr_stmt|;
name|dfa_state_size
operator|=
name|state_size
argument_list|()
expr_stmt|;
name|curr_state
operator|=
name|xmalloc
argument_list|(
name|dfa_state_size
argument_list|)
expr_stmt|;
block|}
name|h_i_d
index|[
literal|0
index|]
operator|.
name|luid
operator|=
literal|0
expr_stmt|;
name|luid
operator|=
literal|1
expr_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|b
argument_list|)
for|for
control|(
name|insn
operator|=
name|BB_HEAD
argument_list|(
name|b
argument_list|)
init|;
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|INSN_LUID
argument_list|(
name|insn
argument_list|)
operator|=
name|luid
expr_stmt|;
comment|/* Increment the next luid, unless this is a note.  We don't 	   really need separate IDs for notes and we don't want to 	   schedule differently depending on whether or not there are 	   line-number notes, i.e., depending on whether or not we're 	   generating debugging information.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE
condition|)
operator|++
name|luid
expr_stmt|;
if|if
condition|(
name|insn
operator|==
name|BB_END
argument_list|(
name|b
argument_list|)
condition|)
break|break;
block|}
name|init_dependency_caches
argument_list|(
name|luid
argument_list|)
expr_stmt|;
name|init_alias_analysis
argument_list|()
expr_stmt|;
if|if
condition|(
name|write_symbols
operator|!=
name|NO_DEBUG
condition|)
block|{
name|rtx
name|line
decl_stmt|;
name|line_note_head
operator|=
name|xcalloc
argument_list|(
name|last_basic_block
argument_list|,
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Save-line-note-head:          Determine the line-number at the start of each basic block.          This must be computed and saved now, because after a basic block's          predecessor has been scheduled, it is impossible to accurately          determine the correct line number for the first insn of the block.  */
name|FOR_EACH_BB
argument_list|(
argument|b
argument_list|)
block|{
for|for
control|(
name|line
operator|=
name|BB_HEAD
argument_list|(
name|b
argument_list|)
init|;
name|line
condition|;
name|line
operator|=
name|PREV_INSN
argument_list|(
name|line
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|line
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|line
argument_list|)
operator|>
literal|0
condition|)
block|{
name|line_note_head
index|[
name|b
operator|->
name|index
index|]
operator|=
name|line
expr_stmt|;
break|break;
block|}
comment|/* Do a forward search as well, since we won't get to see the first 	     notes in a basic block.  */
for|for
control|(
name|line
operator|=
name|BB_HEAD
argument_list|(
name|b
argument_list|)
init|;
name|line
condition|;
name|line
operator|=
name|NEXT_INSN
argument_list|(
name|line
argument_list|)
control|)
block|{
if|if
condition|(
name|INSN_P
argument_list|(
name|line
argument_list|)
condition|)
break|break;
if|if
condition|(
name|GET_CODE
argument_list|(
name|line
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|line
argument_list|)
operator|>
literal|0
condition|)
name|line_note_head
index|[
name|b
operator|->
name|index
index|]
operator|=
name|line
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|(
operator|!
name|targetm
operator|.
name|sched
operator|.
name|use_dfa_pipeline_interface
operator|||
operator|!
call|(
modifier|*
name|targetm
operator|.
name|sched
operator|.
name|use_dfa_pipeline_interface
call|)
argument_list|()
operator|)
operator|&&
name|sched_verbose
condition|)
comment|/* Find units used in this function, for visualization.  */
name|init_target_units
argument_list|()
expr_stmt|;
comment|/* ??? Add a NOTE after the last insn of the last basic block.  It is not      known why this is done.  */
name|insn
operator|=
name|BB_END
argument_list|(
name|EXIT_BLOCK_PTR
operator|->
name|prev_bb
argument_list|)
expr_stmt|;
if|if
condition|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
operator|==
literal|0
operator|||
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|CODE_LABEL
comment|/* Don't emit a NOTE if it would end up before a BARRIER.  */
operator|&&
name|GET_CODE
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|BARRIER
operator|)
condition|)
block|{
name|emit_note_after
argument_list|(
name|NOTE_INSN_DELETED
argument_list|,
name|BB_END
argument_list|(
name|EXIT_BLOCK_PTR
operator|->
name|prev_bb
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make insn to appear outside BB.  */
name|BB_END
argument_list|(
name|EXIT_BLOCK_PTR
operator|->
name|prev_bb
argument_list|)
operator|=
name|PREV_INSN
argument_list|(
name|BB_END
argument_list|(
name|EXIT_BLOCK_PTR
operator|->
name|prev_bb
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Compute INSN_REG_WEIGHT for all blocks.  We must do this before      removing death notes.  */
name|FOR_EACH_BB_REVERSE
argument_list|(
argument|b
argument_list|)
name|find_insn_reg_weight
argument_list|(
name|b
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Free global data used during insn scheduling.  */
end_comment

begin_function
name|void
name|sched_finish
parameter_list|(
name|void
parameter_list|)
block|{
name|free
argument_list|(
name|h_i_d
argument_list|)
expr_stmt|;
if|if
condition|(
name|targetm
operator|.
name|sched
operator|.
name|use_dfa_pipeline_interface
operator|&&
call|(
modifier|*
name|targetm
operator|.
name|sched
operator|.
name|use_dfa_pipeline_interface
call|)
argument_list|()
condition|)
block|{
name|free
argument_list|(
name|curr_state
argument_list|)
expr_stmt|;
name|dfa_finish
argument_list|()
expr_stmt|;
block|}
name|free_dependency_caches
argument_list|()
expr_stmt|;
name|end_alias_analysis
argument_list|()
expr_stmt|;
if|if
condition|(
name|write_symbols
operator|!=
name|NO_DEBUG
condition|)
name|free
argument_list|(
name|line_note_head
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INSN_SCHEDULING */
end_comment

end_unit

