begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Instruction scheduling pass.    Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,    2000, 2001, 2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.    Contributed by Michael Tiemann (tiemann@cygnus.com) Enhanced by,    and currently maintained by, Jim Wilson (wilson@cygnus.com)  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* Instruction scheduling pass.  This file, along with sched-deps.c,    contains the generic parts.  The actual entry point is found for    the normal instruction scheduling pass is found in sched-rgn.c.     We compute insn priorities based on data dependencies.  Flow    analysis only creates a fraction of the data-dependencies we must    observe: namely, only those dependencies which the combiner can be    expected to use.  For this pass, we must therefore create the    remaining dependencies we need to observe: register dependencies,    memory dependencies, dependencies to keep function calls in order,    and the dependence between a conditional branch and the setting of    condition codes are all dealt with here.     The scheduler first traverses the data flow graph, starting with    the last instruction, and proceeding to the first, assigning values    to insn_priority as it goes.  This sorts the instructions    topologically by data dependence.     Once priorities have been established, we order the insns using    list scheduling.  This works as follows: starting with a list of    all the ready insns, and sorted according to priority number, we    schedule the insn from the end of the list by placing its    predecessors in the list according to their priority order.  We    consider this insn scheduled by setting the pointer to the "end" of    the list to point to the previous insn.  When an insn has no    predecessors, we either queue it until sufficient time has elapsed    or add it to the ready list.  As the instructions are scheduled or    when stalls are introduced, the queue advances and dumps insns into    the ready list.  When all insns down to the lowest priority have    been scheduled, the critical path of the basic block has been made    as short as possible.  The remaining insns are then scheduled in    remaining slots.     The following list shows the order in which we want to break ties    among insns in the ready list:     1.  choose insn with the longest path to end of bb, ties    broken by    2.  choose insn with least contribution to register pressure,    ties broken by    3.  prefer in-block upon interblock motion, ties broken by    4.  prefer useful upon speculative motion, ties broken by    5.  choose insn with largest control flow probability, ties    broken by    6.  choose insn with the least dependences upon the previously    scheduled insn, or finally    7   choose the insn which has the most insns dependent on it.    8.  choose insn with lowest UID.     Memory references complicate matters.  Only if we can be certain    that memory references are not part of the data dependency graph    (via true, anti, or output dependence), can we move operations past    memory references.  To first approximation, reads can be done    independently, while writes introduce dependencies.  Better    approximations will yield fewer dependencies.     Before reload, an extended analysis of interblock data dependences    is required for interblock scheduling.  This is performed in    compute_block_backward_dependences ().     Dependencies set up by memory references are treated in exactly the    same way as other dependencies, by using LOG_LINKS backward    dependences.  LOG_LINKS are translated into INSN_DEPEND forward    dependences for the purpose of forward list scheduling.     Having optimized the critical path, we may have also unduly    extended the lifetimes of some registers.  If an operation requires    that constants be loaded into registers, it is certainly desirable    to load those constants as early as necessary, but no earlier.    I.e., it will not do to load up a bunch of registers at the    beginning of a basic block only to use them at the end, if they    could be loaded later, since this may result in excessive register    utilization.     Note that since branches are never in basic blocks, but only end    basic blocks, this pass will not move branches.  But that is ok,    since we can use GNU's delayed branch scheduling pass to take care    of this case.     Also note that no further optimizations based on algebraic    identities are performed, so this pass would be a good one to    perform instruction splitting, such as breaking up a multiply    instruction into shifts and adds where that is profitable.     Given the memory aliasing analysis that this pass should perform,    it should be possible to remove redundant stores to memory, and to    load values from registers instead of hitting memory.     Before reload, speculative insns are moved only if a 'proof' exists    that no exception will be caused by this, and if no live registers    exist that inhibit the motion (live registers constraints are not    represented by data dependence edges).     This pass must update information that subsequent passes expect to    be correct.  Namely: reg_n_refs, reg_n_sets, reg_n_deaths,    reg_n_calls_crossed, and reg_live_length.  Also, BB_HEAD, BB_END.     The information in the line number notes is carefully retained by    this pass.  Notes that refer to the starting and ending of    exception regions are also carefully retained by this pass.  All    other NOTE insns are grouped in their same relative order at the    beginning of basic blocks and regions that have been scheduled.  */
end_comment

begin_escape
end_escape

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"insn-attr.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"sched-int.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"params.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INSN_SCHEDULING
end_ifdef

begin_comment
comment|/* issue_rate is the number of insns that can be scheduled in the same    machine cycle.  It can be defined in the config/mach/mach.h file,    otherwise we set it to 1.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|issue_rate
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* sched-verbose controls the amount of debugging output the    scheduler prints.  It is controlled by -fsched-verbose=N:    N>0 and no -DSR : the output is directed to stderr.    N>=10 will direct the printouts to stderr (regardless of -dSR).    N=1: same as -dSR.    N=2: bb's probabilities, detailed ready list info, unit/insn info.    N=3: rtl at abort point, control-flow, regions info.    N=5: dependences info.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|sched_verbose_param
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|sched_verbose
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Debugging file.  All printouts are sent to dump, which is always set,    either to stderr, or to the dump listing file (-dRS).  */
end_comment

begin_decl_stmt
name|FILE
modifier|*
name|sched_dump
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Highest uid before scheduling.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|old_max_uid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* fix_sched_param() is called from toplev.c upon detection    of the -fsched-verbose=N option.  */
end_comment

begin_function
name|void
name|fix_sched_param
parameter_list|(
specifier|const
name|char
modifier|*
name|param
parameter_list|,
specifier|const
name|char
modifier|*
name|val
parameter_list|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|param
argument_list|,
literal|"verbose"
argument_list|)
condition|)
name|sched_verbose_param
operator|=
name|atoi
argument_list|(
name|val
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
literal|0
argument_list|,
literal|"fix_sched_param: unknown param: %s"
argument_list|,
name|param
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|struct
name|haifa_insn_data
modifier|*
name|h_i_d
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|LINE_NOTE
parameter_list|(
name|INSN
parameter_list|)
value|(h_i_d[INSN_UID (INSN)].line_note)
end_define

begin_define
define|#
directive|define
name|INSN_TICK
parameter_list|(
name|INSN
parameter_list|)
value|(h_i_d[INSN_UID (INSN)].tick)
end_define

begin_define
define|#
directive|define
name|INTER_TICK
parameter_list|(
name|INSN
parameter_list|)
value|(h_i_d[INSN_UID (INSN)].inter_tick)
end_define

begin_comment
comment|/* If INSN_TICK of an instruction is equal to INVALID_TICK,    then it should be recalculated from scratch.  */
end_comment

begin_define
define|#
directive|define
name|INVALID_TICK
value|(-(max_insn_queue_index + 1))
end_define

begin_comment
comment|/* The minimal value of the INSN_TICK of an instruction.  */
end_comment

begin_define
define|#
directive|define
name|MIN_TICK
value|(-max_insn_queue_index)
end_define

begin_comment
comment|/* Issue points are used to distinguish between instructions in max_issue ().    For now, all instructions are equally good.  */
end_comment

begin_define
define|#
directive|define
name|ISSUE_POINTS
parameter_list|(
name|INSN
parameter_list|)
value|1
end_define

begin_comment
comment|/* Vector indexed by basic block number giving the starting line-number    for each basic block.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
modifier|*
name|line_note_head
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List of important notes we must keep around.  This is a pointer to the    last element in the list.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|note_list
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|spec_info_def
name|spec_info_var
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Description of the speculative part of the scheduling.    If NULL - no speculation.  */
end_comment

begin_decl_stmt
specifier|static
name|spec_info_t
name|spec_info
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* True, if recovery block was added during scheduling of current block.    Used to determine, if we need to fix INSN_TICKs.  */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|added_recovery_block_p
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Counters of different types of speculative instructions.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|nr_begin_data
decl_stmt|,
name|nr_be_in_data
decl_stmt|,
name|nr_begin_control
decl_stmt|,
name|nr_be_in_control
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointers to GLAT data.  See init_glat for more information.  */
end_comment

begin_decl_stmt
name|regset
modifier|*
name|glat_start
decl_stmt|,
modifier|*
name|glat_end
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Array used in {unlink, restore}_bb_notes.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
modifier|*
name|bb_header
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of basic_blocks.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|old_last_basic_block
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Basic block after which recovery blocks will be created.  */
end_comment

begin_decl_stmt
specifier|static
name|basic_block
name|before_recovery
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Queues, etc.  */
end_comment

begin_comment
comment|/* An instruction is ready to be scheduled when all insns preceding it    have already been scheduled.  It is important to ensure that all    insns which use its result will not be executed until its result    has been computed.  An insn is maintained in one of four structures:     (P) the "Pending" set of insns which cannot be scheduled until    their dependencies have been satisfied.    (Q) the "Queued" set of insns that can be scheduled when sufficient    time has passed.    (R) the "Ready" list of unscheduled, uncommitted insns.    (S) the "Scheduled" list of insns.     Initially, all insns are either "Pending" or "Ready" depending on    whether their dependencies are satisfied.     Insns move from the "Ready" list to the "Scheduled" list as they    are committed to the schedule.  As this occurs, the insns in the    "Pending" list have their dependencies satisfied and move to either    the "Ready" list or the "Queued" set depending on whether    sufficient time has passed to make them ready.  As time passes,    insns move from the "Queued" set to the "Ready" list.     The "Pending" list (P) are the insns in the INSN_DEPEND of the unscheduled    insns, i.e., those that are ready, queued, and pending.    The "Queued" set (Q) is implemented by the variable `insn_queue'.    The "Ready" list (R) is implemented by the variables `ready' and    `n_ready'.    The "Scheduled" list (S) is the new insn chain built by this pass.     The transition (R->S) is implemented in the scheduling loop in    `schedule_block' when the best insn to schedule is chosen.    The transitions (P->R and P->Q) are implemented in `schedule_insn' as    insns move from the ready list to the scheduled list.    The transition (Q->R) is implemented in 'queue_to_insn' as time    passes or stalls are introduced.  */
end_comment

begin_comment
comment|/* Implement a circular buffer to delay instructions until sufficient    time has passed.  For the new pipeline description interface,    MAX_INSN_QUEUE_INDEX is a power of two minus one which is not less    than maximal time of instruction execution computed by genattr.c on    the base maximal time of functional unit reservations and getting a    result.  This is the longest time an insn may be queued.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
modifier|*
name|insn_queue
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|q_ptr
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|q_size
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NEXT_Q
parameter_list|(
name|X
parameter_list|)
value|(((X)+1)& max_insn_queue_index)
end_define

begin_define
define|#
directive|define
name|NEXT_Q_AFTER
parameter_list|(
name|X
parameter_list|,
name|C
parameter_list|)
value|(((X)+C)& max_insn_queue_index)
end_define

begin_define
define|#
directive|define
name|QUEUE_SCHEDULED
value|(-3)
end_define

begin_define
define|#
directive|define
name|QUEUE_NOWHERE
value|(-2)
end_define

begin_define
define|#
directive|define
name|QUEUE_READY
value|(-1)
end_define

begin_comment
comment|/* QUEUE_SCHEDULED - INSN is scheduled.    QUEUE_NOWHERE   - INSN isn't scheduled yet and is neither in    queue or ready list.    QUEUE_READY     - INSN is in ready list.    N>= 0 - INSN queued for X [where NEXT_Q_AFTER (q_ptr, X) == N] cycles.  */
end_comment

begin_define
define|#
directive|define
name|QUEUE_INDEX
parameter_list|(
name|INSN
parameter_list|)
value|(h_i_d[INSN_UID (INSN)].queue_index)
end_define

begin_comment
comment|/* The following variable value refers for all current and future    reservations of the processor units.  */
end_comment

begin_decl_stmt
name|state_t
name|curr_state
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The following variable value is size of memory representing all    current and future reservations of the processor units.  */
end_comment

begin_decl_stmt
specifier|static
name|size_t
name|dfa_state_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The following array is used to find the best insn from ready when    the automaton pipeline interface is used.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|ready_try
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Describe the ready list of the scheduler.    VEC holds space enough for all insns in the current region.  VECLEN    says how many exactly.    FIRST is the index of the element with the highest priority; i.e. the    last one in the ready list, since elements are ordered by ascending    priority.    N_READY determines how many insns are on the ready list.  */
end_comment

begin_struct
struct|struct
name|ready_list
block|{
name|rtx
modifier|*
name|vec
decl_stmt|;
name|int
name|veclen
decl_stmt|;
name|int
name|first
decl_stmt|;
name|int
name|n_ready
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The pointer to the ready list.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|ready_list
modifier|*
name|readyp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Scheduling clock.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|clock_var
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of instructions in current scheduling region.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|rgn_n_insns
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|may_trap_exp
parameter_list|(
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Nonzero iff the address is comprised from at most 1 register.  */
end_comment

begin_define
define|#
directive|define
name|CONST_BASED_ADDRESS_P
parameter_list|(
name|x
parameter_list|)
define|\
value|(REG_P (x)					\    || ((GET_CODE (x) == PLUS || GET_CODE (x) == MINUS	\ 	|| (GET_CODE (x) == LO_SUM))			\&& (CONSTANT_P (XEXP (x, 0))			\ 	   || CONSTANT_P (XEXP (x, 1)))))
end_define

begin_comment
comment|/* Returns a class that insn with GET_DEST(insn)=x may belong to,    as found by analyzing insn's expression.  */
end_comment

begin_function
specifier|static
name|int
name|may_trap_exp
parameter_list|(
name|rtx
name|x
parameter_list|,
name|int
name|is_store
parameter_list|)
block|{
name|enum
name|rtx_code
name|code
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return
name|TRAP_FREE
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_store
condition|)
block|{
if|if
condition|(
name|code
operator|==
name|MEM
operator|&&
name|may_trap_p
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|TRAP_RISKY
return|;
else|else
return|return
name|TRAP_FREE
return|;
block|}
if|if
condition|(
name|code
operator|==
name|MEM
condition|)
block|{
comment|/* The insn uses memory:  a volatile load.  */
if|if
condition|(
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|IRISKY
return|;
comment|/* An exception-free load.  */
if|if
condition|(
operator|!
name|may_trap_p
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|IFREE
return|;
comment|/* A load with 1 base register, to be further checked.  */
if|if
condition|(
name|CONST_BASED_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|PFREE_CANDIDATE
return|;
comment|/* No info on the load, to be further checked.  */
return|return
name|PRISKY_CANDIDATE
return|;
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|i
decl_stmt|,
name|insn_class
init|=
name|TRAP_FREE
decl_stmt|;
comment|/* Neither store nor load, check if it may cause a trap.  */
if|if
condition|(
name|may_trap_p
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|TRAP_RISKY
return|;
comment|/* Recursive step: walk the insn...  */
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
name|int
name|tmp_class
init|=
name|may_trap_exp
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|is_store
argument_list|)
decl_stmt|;
name|insn_class
operator|=
name|WORST_CLASS
argument_list|(
name|insn_class
argument_list|,
name|tmp_class
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
name|int
name|tmp_class
init|=
name|may_trap_exp
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|is_store
argument_list|)
decl_stmt|;
name|insn_class
operator|=
name|WORST_CLASS
argument_list|(
name|insn_class
argument_list|,
name|tmp_class
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn_class
operator|==
name|TRAP_RISKY
operator|||
name|insn_class
operator|==
name|IRISKY
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|insn_class
operator|==
name|TRAP_RISKY
operator|||
name|insn_class
operator|==
name|IRISKY
condition|)
break|break;
block|}
return|return
name|insn_class
return|;
block|}
block|}
end_function

begin_comment
comment|/* Classifies insn for the purpose of verifying that it can be    moved speculatively, by examining it's patterns, returning:    TRAP_RISKY: store, or risky non-load insn (e.g. division by variable).    TRAP_FREE: non-load insn.    IFREE: load from a globally safe location.    IRISKY: volatile load.    PFREE_CANDIDATE, PRISKY_CANDIDATE: load that need to be checked for    being either PFREE or PRISKY.  */
end_comment

begin_function
name|int
name|haifa_classify_insn
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|int
name|tmp_class
init|=
name|TRAP_FREE
decl_stmt|;
name|int
name|insn_class
init|=
name|TRAP_FREE
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
name|int
name|i
decl_stmt|,
name|len
init|=
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
name|len
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|code
operator|=
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CLOBBER
case|:
comment|/* Test if it is a 'store'.  */
name|tmp_class
operator|=
name|may_trap_exp
argument_list|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|SET
case|:
comment|/* Test if it is a store.  */
name|tmp_class
operator|=
name|may_trap_exp
argument_list|(
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp_class
operator|==
name|TRAP_RISKY
condition|)
break|break;
comment|/* Test if it is a load.  */
name|tmp_class
operator|=
name|WORST_CLASS
argument_list|(
name|tmp_class
argument_list|,
name|may_trap_exp
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|COND_EXEC
case|:
case|case
name|TRAP_IF
case|:
name|tmp_class
operator|=
name|TRAP_RISKY
expr_stmt|;
break|break;
default|default:
empty_stmt|;
block|}
name|insn_class
operator|=
name|WORST_CLASS
argument_list|(
name|insn_class
argument_list|,
name|tmp_class
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn_class
operator|==
name|TRAP_RISKY
operator|||
name|insn_class
operator|==
name|IRISKY
condition|)
break|break;
block|}
block|}
else|else
block|{
name|code
operator|=
name|GET_CODE
argument_list|(
name|pat
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CLOBBER
case|:
comment|/* Test if it is a 'store'.  */
name|tmp_class
operator|=
name|may_trap_exp
argument_list|(
name|XEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|SET
case|:
comment|/* Test if it is a store.  */
name|tmp_class
operator|=
name|may_trap_exp
argument_list|(
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp_class
operator|==
name|TRAP_RISKY
condition|)
break|break;
comment|/* Test if it is a load.  */
name|tmp_class
operator|=
name|WORST_CLASS
argument_list|(
name|tmp_class
argument_list|,
name|may_trap_exp
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|COND_EXEC
case|:
case|case
name|TRAP_IF
case|:
name|tmp_class
operator|=
name|TRAP_RISKY
expr_stmt|;
break|break;
default|default:
empty_stmt|;
block|}
name|insn_class
operator|=
name|tmp_class
expr_stmt|;
block|}
return|return
name|insn_class
return|;
block|}
end_function

begin_comment
comment|/* Forward declarations.  */
end_comment

begin_function_decl
name|HAIFA_INLINE
specifier|static
name|int
name|insn_cost1
parameter_list|(
name|rtx
parameter_list|,
name|enum
name|reg_note
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|priority
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rank_for_schedule
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|swap_sort
parameter_list|(
name|rtx
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|queue_insn
parameter_list|(
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|schedule_insn
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|find_set_reg_weight
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|find_insn_reg_weight
parameter_list|(
name|basic_block
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|find_insn_reg_weight1
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|adjust_priority
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|advance_one_cycle
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Notes handling mechanism:    =========================    Generally, NOTES are saved before scheduling and restored after scheduling.    The scheduler distinguishes between three types of notes:     (1) LINE_NUMBER notes, generated and used for debugging.  Here,    before scheduling a region, a pointer to the LINE_NUMBER note is    added to the insn following it (in save_line_notes()), and the note    is removed (in rm_line_notes() and unlink_line_notes()).  After    scheduling the region, this pointer is used for regeneration of    the LINE_NUMBER note (in restore_line_notes()).     (2) LOOP_BEGIN, LOOP_END, SETJMP, EHREGION_BEG, EHREGION_END notes:    Before scheduling a region, a pointer to the note is added to the insn    that follows or precedes it.  (This happens as part of the data dependence    computation).  After scheduling an insn, the pointer contained in it is    used for regenerating the corresponding note (in reemit_notes).     (3) All other notes (e.g. INSN_DELETED):  Before scheduling a block,    these notes are put in a list (in rm_other_notes() and    unlink_other_notes ()).  After scheduling the block, these notes are    inserted at the beginning of the block (in schedule_block()).  */
end_comment

begin_function_decl
specifier|static
name|rtx
name|unlink_other_notes
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|unlink_line_notes
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|reemit_notes
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
modifier|*
name|ready_lastpos
parameter_list|(
name|struct
name|ready_list
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ready_add
parameter_list|(
name|struct
name|ready_list
modifier|*
parameter_list|,
name|rtx
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ready_sort
parameter_list|(
name|struct
name|ready_list
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|ready_remove_first
parameter_list|(
name|struct
name|ready_list
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|queue_to_ready
parameter_list|(
name|struct
name|ready_list
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|early_queue_to_ready
parameter_list|(
name|state_t
parameter_list|,
name|struct
name|ready_list
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|debug_ready_list
parameter_list|(
name|struct
name|ready_list
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|move_insn
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* The following functions are used to implement multi-pass scheduling    on the first cycle.  */
end_comment

begin_function_decl
specifier|static
name|rtx
name|ready_element
parameter_list|(
name|struct
name|ready_list
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|ready_remove
parameter_list|(
name|struct
name|ready_list
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ready_remove_insn
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|max_issue
parameter_list|(
name|struct
name|ready_list
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|choose_ready
parameter_list|(
name|struct
name|ready_list
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fix_inter_tick
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fix_tick_ready
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|change_queue_index
parameter_list|(
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|resolve_dep
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* The following functions are used to implement scheduling of data/control    speculative instructions.  */
end_comment

begin_function_decl
specifier|static
name|void
name|extend_h_i_d
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|extend_ready
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|extend_global
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|extend_all
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|init_h_i_d
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|generate_recovery_code
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|process_insn_depend_be_in_spec
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|ds_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|begin_speculative_block
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_to_speculative_block
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|dw_t
name|dep_weak
parameter_list|(
name|ds_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|edge
name|find_fallthru_edge
parameter_list|(
name|basic_block
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|init_before_recovery
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|basic_block
name|create_recovery_block
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|create_check_block_twin
parameter_list|(
name|rtx
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fix_recovery_deps
parameter_list|(
name|basic_block
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|associate_line_notes_with_blocks
parameter_list|(
name|basic_block
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|change_pattern
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|speculate_insn
parameter_list|(
name|rtx
parameter_list|,
name|ds_t
parameter_list|,
name|rtx
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_new_block_header
parameter_list|(
name|int
parameter_list|,
name|basic_block
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|restore_bb_notes
parameter_list|(
name|basic_block
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|extend_bb
parameter_list|(
name|basic_block
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fix_jump_move
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|move_block_after_check
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|void
name|move_succs
argument_list|(
name|VEC
argument_list|(
name|edge
argument_list|,
name|gc
argument_list|)
operator|*
operator|*
argument_list|,
name|basic_block
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|init_glat
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|init_glat1
parameter_list|(
name|basic_block
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|attach_life_info1
parameter_list|(
name|basic_block
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_glat
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sched_remove_insn
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|clear_priorities
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_jump_dependencies
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|calc_priorities
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|has_edge_p
argument_list|(
name|VEC
argument_list|(
name|edge
argument_list|,
name|gc
argument_list|)
operator|*
argument_list|,
name|int
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|check_cfg
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|check_sched_flags
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INSN_SCHEDULING */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Point to state used for the current scheduling pass.  */
end_comment

begin_decl_stmt
name|struct
name|sched_info
modifier|*
name|current_sched_info
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_ifndef
ifndef|#
directive|ifndef
name|INSN_SCHEDULING
end_ifndef

begin_function
name|void
name|schedule_insns
parameter_list|(
name|void
parameter_list|)
block|{ }
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* Working copy of frontend's sched_info variable.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|sched_info
name|current_sched_info_var
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer to the last instruction scheduled.  Used by rank_for_schedule,    so that insns independent of the last scheduled insn will be preferred    over dependent instructions.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|last_scheduled_insn
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Compute cost of executing INSN given the dependence LINK on the insn USED.    This is the number of cycles between instruction issue and    instruction results.  */
end_comment

begin_function
name|HAIFA_INLINE
name|int
name|insn_cost
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|rtx
name|link
parameter_list|,
name|rtx
name|used
parameter_list|)
block|{
return|return
name|insn_cost1
argument_list|(
name|insn
argument_list|,
name|used
condition|?
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
else|:
name|REG_NOTE_MAX
argument_list|,
name|link
argument_list|,
name|used
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Compute cost of executing INSN given the dependence on the insn USED.    If LINK is not NULL, then its REG_NOTE_KIND is used as a dependence type.    Otherwise, dependence between INSN and USED is assumed to be of type    DEP_TYPE.  This function was introduced as a workaround for    targetm.adjust_cost hook.    This is the number of cycles between instruction issue and    instruction results.  */
end_comment

begin_function
name|HAIFA_INLINE
specifier|static
name|int
name|insn_cost1
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|enum
name|reg_note
name|dep_type
parameter_list|,
name|rtx
name|link
parameter_list|,
name|rtx
name|used
parameter_list|)
block|{
name|int
name|cost
init|=
name|INSN_COST
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|cost
operator|<
literal|0
condition|)
block|{
comment|/* A USE insn, or something else we don't need to 	 understand.  We can't pass these directly to 	 result_ready_cost or insn_default_latency because it will 	 trigger a fatal error for unrecognizable insns.  */
if|if
condition|(
name|recog_memoized
argument_list|(
name|insn
argument_list|)
operator|<
literal|0
condition|)
block|{
name|INSN_COST
argument_list|(
name|insn
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
name|cost
operator|=
name|insn_default_latency
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|cost
operator|<
literal|0
condition|)
name|cost
operator|=
literal|0
expr_stmt|;
name|INSN_COST
argument_list|(
name|insn
argument_list|)
operator|=
name|cost
expr_stmt|;
block|}
block|}
comment|/* In this case estimate cost without caring how insn is used.  */
if|if
condition|(
name|used
operator|==
literal|0
condition|)
return|return
name|cost
return|;
comment|/* A USE insn should never require the value used to be computed.      This allows the computation of a function's result and parameter      values to overlap the return and call.  */
if|if
condition|(
name|recog_memoized
argument_list|(
name|used
argument_list|)
operator|<
literal|0
condition|)
name|cost
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|gcc_assert
argument_list|(
operator|!
name|link
operator|||
name|dep_type
operator|==
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|dep_type
operator|==
name|REG_DEP_ANTI
condition|)
name|cost
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|dep_type
operator|==
name|REG_DEP_OUTPUT
condition|)
block|{
name|cost
operator|=
operator|(
name|insn_default_latency
argument_list|(
name|insn
argument_list|)
operator|-
name|insn_default_latency
argument_list|(
name|used
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|cost
operator|<=
literal|0
condition|)
name|cost
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bypass_p
argument_list|(
name|insn
argument_list|)
condition|)
name|cost
operator|=
name|insn_latency
argument_list|(
name|insn
argument_list|,
name|used
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|targetm
operator|.
name|sched
operator|.
name|adjust_cost_2
condition|)
name|cost
operator|=
name|targetm
operator|.
name|sched
operator|.
name|adjust_cost_2
argument_list|(
name|used
argument_list|,
operator|(
name|int
operator|)
name|dep_type
argument_list|,
name|insn
argument_list|,
name|cost
argument_list|)
expr_stmt|;
else|else
block|{
name|gcc_assert
argument_list|(
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|targetm
operator|.
name|sched
operator|.
name|adjust_cost
condition|)
name|cost
operator|=
name|targetm
operator|.
name|sched
operator|.
name|adjust_cost
argument_list|(
name|used
argument_list|,
name|link
argument_list|,
name|insn
argument_list|,
name|cost
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cost
operator|<
literal|0
condition|)
name|cost
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|cost
return|;
block|}
end_function

begin_comment
comment|/* Compute the priority number for INSN.  */
end_comment

begin_function
specifier|static
name|int
name|priority
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|rtx
name|link
decl_stmt|;
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|INSN_PRIORITY_KNOWN
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|int
name|this_priority
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|INSN_DEPEND
argument_list|(
name|insn
argument_list|)
operator|==
literal|0
condition|)
name|this_priority
operator|=
name|insn_cost
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|rtx
name|prev_first
decl_stmt|,
name|twin
decl_stmt|;
name|basic_block
name|rec
decl_stmt|;
comment|/* For recovery check instructions we calculate priority slightly 	     different than that of normal instructions.  Instead of walking 	     through INSN_DEPEND (check) list, we walk through INSN_DEPEND list 	     of each instruction in the corresponding recovery block.  */
name|rec
operator|=
name|RECOVERY_BLOCK
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rec
operator|||
name|rec
operator|==
name|EXIT_BLOCK_PTR
condition|)
block|{
name|prev_first
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|twin
operator|=
name|insn
expr_stmt|;
block|}
else|else
block|{
name|prev_first
operator|=
name|NEXT_INSN
argument_list|(
name|BB_HEAD
argument_list|(
name|rec
argument_list|)
argument_list|)
expr_stmt|;
name|twin
operator|=
name|PREV_INSN
argument_list|(
name|BB_END
argument_list|(
name|rec
argument_list|)
argument_list|)
expr_stmt|;
block|}
do|do
block|{
for|for
control|(
name|link
operator|=
name|INSN_DEPEND
argument_list|(
name|twin
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|rtx
name|next
decl_stmt|;
name|int
name|next_priority
decl_stmt|;
name|next
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|BLOCK_FOR_INSN
argument_list|(
name|next
argument_list|)
operator|!=
name|rec
condition|)
block|{
comment|/* Critical path is meaningful in block boundaries 			 only.  */
if|if
condition|(
operator|!
call|(
modifier|*
name|current_sched_info
operator|->
name|contributes_to_priority
call|)
argument_list|(
name|next
argument_list|,
name|insn
argument_list|)
comment|/* If flag COUNT_SPEC_IN_CRITICAL_PATH is set, 			     then speculative instructions will less likely be 			     scheduled.  That is because the priority of 			     their producers will increase, and, thus, the 			     producers will more likely be scheduled, thus, 			     resolving the dependence.  */
operator|||
operator|(
operator|(
name|current_sched_info
operator|->
name|flags
operator|&
name|DO_SPECULATION
operator|)
operator|&&
operator|(
name|DEP_STATUS
argument_list|(
name|link
argument_list|)
operator|&
name|SPECULATIVE
operator|)
operator|&&
operator|!
operator|(
name|spec_info
operator|->
name|flags
operator|&
name|COUNT_SPEC_IN_CRITICAL_PATH
operator|)
operator|)
condition|)
continue|continue;
name|next_priority
operator|=
name|insn_cost1
argument_list|(
name|insn
argument_list|,
name|twin
operator|==
name|insn
condition|?
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
else|:
name|REG_DEP_ANTI
argument_list|,
name|twin
operator|==
name|insn
condition|?
name|link
else|:
literal|0
argument_list|,
name|next
argument_list|)
operator|+
name|priority
argument_list|(
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_priority
operator|>
name|this_priority
condition|)
name|this_priority
operator|=
name|next_priority
expr_stmt|;
block|}
block|}
name|twin
operator|=
name|PREV_INSN
argument_list|(
name|twin
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|twin
operator|!=
name|prev_first
condition|)
do|;
block|}
name|INSN_PRIORITY
argument_list|(
name|insn
argument_list|)
operator|=
name|this_priority
expr_stmt|;
name|INSN_PRIORITY_KNOWN
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|INSN_PRIORITY
argument_list|(
name|insn
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Macros and functions for keeping the priority queue sorted, and    dealing with queuing and dequeuing of instructions.  */
end_comment

begin_define
define|#
directive|define
name|SCHED_SORT
parameter_list|(
name|READY
parameter_list|,
name|N_READY
parameter_list|)
define|\
value|do { if ((N_READY) == 2)				             \        swap_sort (READY, N_READY);			             \      else if ((N_READY)> 2)                                         \          qsort (READY, N_READY, sizeof (rtx), rank_for_schedule); }  \ while (0)
end_define

begin_comment
comment|/* Returns a positive value if x is preferred; returns a negative value if    y is preferred.  Should never return 0, since that will make the sort    unstable.  */
end_comment

begin_function
specifier|static
name|int
name|rank_for_schedule
parameter_list|(
specifier|const
name|void
modifier|*
name|x
parameter_list|,
specifier|const
name|void
modifier|*
name|y
parameter_list|)
block|{
name|rtx
name|tmp
init|=
operator|*
operator|(
specifier|const
name|rtx
operator|*
operator|)
name|y
decl_stmt|;
name|rtx
name|tmp2
init|=
operator|*
operator|(
specifier|const
name|rtx
operator|*
operator|)
name|x
decl_stmt|;
name|rtx
name|link
decl_stmt|;
name|int
name|tmp_class
decl_stmt|,
name|tmp2_class
decl_stmt|,
name|depend_count1
decl_stmt|,
name|depend_count2
decl_stmt|;
name|int
name|val
decl_stmt|,
name|priority_val
decl_stmt|,
name|weight_val
decl_stmt|,
name|info_val
decl_stmt|;
comment|/* The insn in a schedule group should be issued the first.  */
if|if
condition|(
name|SCHED_GROUP_P
argument_list|(
name|tmp
argument_list|)
operator|!=
name|SCHED_GROUP_P
argument_list|(
name|tmp2
argument_list|)
condition|)
return|return
name|SCHED_GROUP_P
argument_list|(
name|tmp2
argument_list|)
condition|?
literal|1
else|:
operator|-
literal|1
return|;
comment|/* Prefer insn with higher priority.  */
name|priority_val
operator|=
name|INSN_PRIORITY
argument_list|(
name|tmp2
argument_list|)
operator|-
name|INSN_PRIORITY
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|priority_val
condition|)
return|return
name|priority_val
return|;
comment|/* Prefer speculative insn with greater dependencies weakness.  */
if|if
condition|(
name|spec_info
condition|)
block|{
name|ds_t
name|ds1
decl_stmt|,
name|ds2
decl_stmt|;
name|dw_t
name|dw1
decl_stmt|,
name|dw2
decl_stmt|;
name|int
name|dw
decl_stmt|;
name|ds1
operator|=
name|TODO_SPEC
argument_list|(
name|tmp
argument_list|)
operator|&
name|SPECULATIVE
expr_stmt|;
if|if
condition|(
name|ds1
condition|)
name|dw1
operator|=
name|dep_weak
argument_list|(
name|ds1
argument_list|)
expr_stmt|;
else|else
name|dw1
operator|=
name|NO_DEP_WEAK
expr_stmt|;
name|ds2
operator|=
name|TODO_SPEC
argument_list|(
name|tmp2
argument_list|)
operator|&
name|SPECULATIVE
expr_stmt|;
if|if
condition|(
name|ds2
condition|)
name|dw2
operator|=
name|dep_weak
argument_list|(
name|ds2
argument_list|)
expr_stmt|;
else|else
name|dw2
operator|=
name|NO_DEP_WEAK
expr_stmt|;
name|dw
operator|=
name|dw2
operator|-
name|dw1
expr_stmt|;
if|if
condition|(
name|dw
operator|>
operator|(
name|NO_DEP_WEAK
operator|/
literal|8
operator|)
operator|||
name|dw
operator|<
operator|-
operator|(
name|NO_DEP_WEAK
operator|/
literal|8
operator|)
condition|)
return|return
name|dw
return|;
block|}
comment|/* Prefer an insn with smaller contribution to registers-pressure.  */
if|if
condition|(
operator|!
name|reload_completed
operator|&&
operator|(
name|weight_val
operator|=
name|INSN_REG_WEIGHT
argument_list|(
name|tmp
argument_list|)
operator|-
name|INSN_REG_WEIGHT
argument_list|(
name|tmp2
argument_list|)
operator|)
condition|)
return|return
name|weight_val
return|;
name|info_val
operator|=
call|(
modifier|*
name|current_sched_info
operator|->
name|rank
call|)
argument_list|(
name|tmp
argument_list|,
name|tmp2
argument_list|)
expr_stmt|;
if|if
condition|(
name|info_val
condition|)
return|return
name|info_val
return|;
comment|/* Compare insns based on their relation to the last-scheduled-insn.  */
if|if
condition|(
name|INSN_P
argument_list|(
name|last_scheduled_insn
argument_list|)
condition|)
block|{
comment|/* Classify the instructions into three classes:          1) Data dependent on last schedule insn.          2) Anti/Output dependent on last scheduled insn.          3) Independent of last scheduled insn, or has latency of one.          Choose the insn from the highest numbered class if different.  */
name|link
operator|=
name|find_insn_list
argument_list|(
name|tmp
argument_list|,
name|INSN_DEPEND
argument_list|(
name|last_scheduled_insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|link
operator|==
literal|0
operator|||
name|insn_cost
argument_list|(
name|last_scheduled_insn
argument_list|,
name|link
argument_list|,
name|tmp
argument_list|)
operator|==
literal|1
condition|)
name|tmp_class
operator|=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
literal|0
condition|)
comment|/* Data dependence.  */
name|tmp_class
operator|=
literal|1
expr_stmt|;
else|else
name|tmp_class
operator|=
literal|2
expr_stmt|;
name|link
operator|=
name|find_insn_list
argument_list|(
name|tmp2
argument_list|,
name|INSN_DEPEND
argument_list|(
name|last_scheduled_insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|link
operator|==
literal|0
operator|||
name|insn_cost
argument_list|(
name|last_scheduled_insn
argument_list|,
name|link
argument_list|,
name|tmp2
argument_list|)
operator|==
literal|1
condition|)
name|tmp2_class
operator|=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
literal|0
condition|)
comment|/* Data dependence.  */
name|tmp2_class
operator|=
literal|1
expr_stmt|;
else|else
name|tmp2_class
operator|=
literal|2
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|=
name|tmp2_class
operator|-
name|tmp_class
operator|)
condition|)
return|return
name|val
return|;
block|}
comment|/* Prefer the insn which has more later insns that depend on it.      This gives the scheduler more freedom when scheduling later      instructions at the expense of added register pressure.  */
name|depend_count1
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|link
operator|=
name|INSN_DEPEND
argument_list|(
name|tmp
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
name|depend_count1
operator|++
expr_stmt|;
name|depend_count2
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|link
operator|=
name|INSN_DEPEND
argument_list|(
name|tmp2
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
name|depend_count2
operator|++
expr_stmt|;
name|val
operator|=
name|depend_count2
operator|-
name|depend_count1
expr_stmt|;
if|if
condition|(
name|val
condition|)
return|return
name|val
return|;
comment|/* If insns are equally good, sort by INSN_LUID (original insn order),      so that we make the sort stable.  This minimizes instruction movement,      thus minimizing sched's effect on debugging and cross-jumping.  */
return|return
name|INSN_LUID
argument_list|(
name|tmp
argument_list|)
operator|-
name|INSN_LUID
argument_list|(
name|tmp2
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Resort the array A in which only element at index N may be out of order.  */
end_comment

begin_function
name|HAIFA_INLINE
specifier|static
name|void
name|swap_sort
parameter_list|(
name|rtx
modifier|*
name|a
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|rtx
name|insn
init|=
name|a
index|[
name|n
operator|-
literal|1
index|]
decl_stmt|;
name|int
name|i
init|=
name|n
operator|-
literal|2
decl_stmt|;
while|while
condition|(
name|i
operator|>=
literal|0
operator|&&
name|rank_for_schedule
argument_list|(
name|a
operator|+
name|i
argument_list|,
operator|&
name|insn
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|a
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|a
index|[
name|i
index|]
expr_stmt|;
name|i
operator|-=
literal|1
expr_stmt|;
block|}
name|a
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|insn
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add INSN to the insn queue so that it can be executed at least    N_CYCLES after the currently executing insn.  Preserve insns    chain for debugging purposes.  */
end_comment

begin_function
name|HAIFA_INLINE
specifier|static
name|void
name|queue_insn
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|int
name|n_cycles
parameter_list|)
block|{
name|int
name|next_q
init|=
name|NEXT_Q_AFTER
argument_list|(
name|q_ptr
argument_list|,
name|n_cycles
argument_list|)
decl_stmt|;
name|rtx
name|link
init|=
name|alloc_INSN_LIST
argument_list|(
name|insn
argument_list|,
name|insn_queue
index|[
name|next_q
index|]
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
name|n_cycles
operator|<=
name|max_insn_queue_index
argument_list|)
expr_stmt|;
name|insn_queue
index|[
name|next_q
index|]
operator|=
name|link
expr_stmt|;
name|q_size
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|sched_verbose
operator|>=
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|";;\t\tReady-->Q: insn %s: "
argument_list|,
call|(
modifier|*
name|current_sched_info
operator|->
name|print_insn
call|)
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|"queued for %d cycles.\n"
argument_list|,
name|n_cycles
argument_list|)
expr_stmt|;
block|}
name|QUEUE_INDEX
argument_list|(
name|insn
argument_list|)
operator|=
name|next_q
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Remove INSN from queue.  */
end_comment

begin_function
specifier|static
name|void
name|queue_remove
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|QUEUE_INDEX
argument_list|(
name|insn
argument_list|)
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|remove_free_INSN_LIST_elem
argument_list|(
name|insn
argument_list|,
operator|&
name|insn_queue
index|[
name|QUEUE_INDEX
argument_list|(
name|insn
argument_list|)
index|]
argument_list|)
expr_stmt|;
name|q_size
operator|--
expr_stmt|;
name|QUEUE_INDEX
argument_list|(
name|insn
argument_list|)
operator|=
name|QUEUE_NOWHERE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return a pointer to the bottom of the ready list, i.e. the insn    with the lowest priority.  */
end_comment

begin_function
name|HAIFA_INLINE
specifier|static
name|rtx
modifier|*
name|ready_lastpos
parameter_list|(
name|struct
name|ready_list
modifier|*
name|ready
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|ready
operator|->
name|n_ready
operator|>=
literal|1
argument_list|)
expr_stmt|;
return|return
name|ready
operator|->
name|vec
operator|+
name|ready
operator|->
name|first
operator|-
name|ready
operator|->
name|n_ready
operator|+
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Add an element INSN to the ready list so that it ends up with the    lowest/highest priority depending on FIRST_P.  */
end_comment

begin_function
name|HAIFA_INLINE
specifier|static
name|void
name|ready_add
parameter_list|(
name|struct
name|ready_list
modifier|*
name|ready
parameter_list|,
name|rtx
name|insn
parameter_list|,
name|bool
name|first_p
parameter_list|)
block|{
if|if
condition|(
operator|!
name|first_p
condition|)
block|{
if|if
condition|(
name|ready
operator|->
name|first
operator|==
name|ready
operator|->
name|n_ready
condition|)
block|{
name|memmove
argument_list|(
name|ready
operator|->
name|vec
operator|+
name|ready
operator|->
name|veclen
operator|-
name|ready
operator|->
name|n_ready
argument_list|,
name|ready_lastpos
argument_list|(
name|ready
argument_list|)
argument_list|,
name|ready
operator|->
name|n_ready
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|ready
operator|->
name|first
operator|=
name|ready
operator|->
name|veclen
operator|-
literal|1
expr_stmt|;
block|}
name|ready
operator|->
name|vec
index|[
name|ready
operator|->
name|first
operator|-
name|ready
operator|->
name|n_ready
index|]
operator|=
name|insn
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ready
operator|->
name|first
operator|==
name|ready
operator|->
name|veclen
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|ready
operator|->
name|n_ready
condition|)
comment|/* ready_lastpos() fails when called with (ready->n_ready == 0).  */
name|memmove
argument_list|(
name|ready
operator|->
name|vec
operator|+
name|ready
operator|->
name|veclen
operator|-
name|ready
operator|->
name|n_ready
operator|-
literal|1
argument_list|,
name|ready_lastpos
argument_list|(
name|ready
argument_list|)
argument_list|,
name|ready
operator|->
name|n_ready
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|ready
operator|->
name|first
operator|=
name|ready
operator|->
name|veclen
operator|-
literal|2
expr_stmt|;
block|}
name|ready
operator|->
name|vec
index|[
operator|++
operator|(
name|ready
operator|->
name|first
operator|)
index|]
operator|=
name|insn
expr_stmt|;
block|}
name|ready
operator|->
name|n_ready
operator|++
expr_stmt|;
name|gcc_assert
argument_list|(
name|QUEUE_INDEX
argument_list|(
name|insn
argument_list|)
operator|!=
name|QUEUE_READY
argument_list|)
expr_stmt|;
name|QUEUE_INDEX
argument_list|(
name|insn
argument_list|)
operator|=
name|QUEUE_READY
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Remove the element with the highest priority from the ready list and    return it.  */
end_comment

begin_function
name|HAIFA_INLINE
specifier|static
name|rtx
name|ready_remove_first
parameter_list|(
name|struct
name|ready_list
modifier|*
name|ready
parameter_list|)
block|{
name|rtx
name|t
decl_stmt|;
name|gcc_assert
argument_list|(
name|ready
operator|->
name|n_ready
argument_list|)
expr_stmt|;
name|t
operator|=
name|ready
operator|->
name|vec
index|[
name|ready
operator|->
name|first
operator|--
index|]
expr_stmt|;
name|ready
operator|->
name|n_ready
operator|--
expr_stmt|;
comment|/* If the queue becomes empty, reset it.  */
if|if
condition|(
name|ready
operator|->
name|n_ready
operator|==
literal|0
condition|)
name|ready
operator|->
name|first
operator|=
name|ready
operator|->
name|veclen
operator|-
literal|1
expr_stmt|;
name|gcc_assert
argument_list|(
name|QUEUE_INDEX
argument_list|(
name|t
argument_list|)
operator|==
name|QUEUE_READY
argument_list|)
expr_stmt|;
name|QUEUE_INDEX
argument_list|(
name|t
argument_list|)
operator|=
name|QUEUE_NOWHERE
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* The following code implements multi-pass scheduling for the first    cycle.  In other words, we will try to choose ready insn which    permits to start maximum number of insns on the same cycle.  */
end_comment

begin_comment
comment|/* Return a pointer to the element INDEX from the ready.  INDEX for    insn with the highest priority is 0, and the lowest priority has    N_READY - 1.  */
end_comment

begin_function
name|HAIFA_INLINE
specifier|static
name|rtx
name|ready_element
parameter_list|(
name|struct
name|ready_list
modifier|*
name|ready
parameter_list|,
name|int
name|index
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|ready
operator|->
name|n_ready
operator|&&
name|index
operator|<
name|ready
operator|->
name|n_ready
argument_list|)
expr_stmt|;
return|return
name|ready
operator|->
name|vec
index|[
name|ready
operator|->
name|first
operator|-
name|index
index|]
return|;
block|}
end_function

begin_comment
comment|/* Remove the element INDEX from the ready list and return it.  INDEX    for insn with the highest priority is 0, and the lowest priority    has N_READY - 1.  */
end_comment

begin_function
name|HAIFA_INLINE
specifier|static
name|rtx
name|ready_remove
parameter_list|(
name|struct
name|ready_list
modifier|*
name|ready
parameter_list|,
name|int
name|index
parameter_list|)
block|{
name|rtx
name|t
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|index
operator|==
literal|0
condition|)
return|return
name|ready_remove_first
argument_list|(
name|ready
argument_list|)
return|;
name|gcc_assert
argument_list|(
name|ready
operator|->
name|n_ready
operator|&&
name|index
operator|<
name|ready
operator|->
name|n_ready
argument_list|)
expr_stmt|;
name|t
operator|=
name|ready
operator|->
name|vec
index|[
name|ready
operator|->
name|first
operator|-
name|index
index|]
expr_stmt|;
name|ready
operator|->
name|n_ready
operator|--
expr_stmt|;
for|for
control|(
name|i
operator|=
name|index
init|;
name|i
operator|<
name|ready
operator|->
name|n_ready
condition|;
name|i
operator|++
control|)
name|ready
operator|->
name|vec
index|[
name|ready
operator|->
name|first
operator|-
name|i
index|]
operator|=
name|ready
operator|->
name|vec
index|[
name|ready
operator|->
name|first
operator|-
name|i
operator|-
literal|1
index|]
expr_stmt|;
name|QUEUE_INDEX
argument_list|(
name|t
argument_list|)
operator|=
name|QUEUE_NOWHERE
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Remove INSN from the ready list.  */
end_comment

begin_function
specifier|static
name|void
name|ready_remove_insn
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|readyp
operator|->
name|n_ready
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|ready_element
argument_list|(
name|readyp
argument_list|,
name|i
argument_list|)
operator|==
name|insn
condition|)
block|{
name|ready_remove
argument_list|(
name|readyp
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return;
block|}
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Sort the ready list READY by ascending priority, using the SCHED_SORT    macro.  */
end_comment

begin_function
name|HAIFA_INLINE
specifier|static
name|void
name|ready_sort
parameter_list|(
name|struct
name|ready_list
modifier|*
name|ready
parameter_list|)
block|{
name|rtx
modifier|*
name|first
init|=
name|ready_lastpos
argument_list|(
name|ready
argument_list|)
decl_stmt|;
name|SCHED_SORT
argument_list|(
name|first
argument_list|,
name|ready
operator|->
name|n_ready
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* PREV is an insn that is ready to execute.  Adjust its priority if that    will help shorten or lengthen register lifetimes as appropriate.  Also    provide a hook for the target to tweek itself.  */
end_comment

begin_function
name|HAIFA_INLINE
specifier|static
name|void
name|adjust_priority
parameter_list|(
name|rtx
name|prev
parameter_list|)
block|{
comment|/* ??? There used to be code here to try and estimate how an insn      affected register lifetimes, but it did it by looking at REG_DEAD      notes, which we removed in schedule_region.  Nor did it try to      take into account register pressure or anything useful like that.       Revisit when we have a machine model to work with and not before.  */
if|if
condition|(
name|targetm
operator|.
name|sched
operator|.
name|adjust_priority
condition|)
name|INSN_PRIORITY
argument_list|(
name|prev
argument_list|)
operator|=
name|targetm
operator|.
name|sched
operator|.
name|adjust_priority
argument_list|(
name|prev
argument_list|,
name|INSN_PRIORITY
argument_list|(
name|prev
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Advance time on one cycle.  */
end_comment

begin_function
name|HAIFA_INLINE
specifier|static
name|void
name|advance_one_cycle
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|targetm
operator|.
name|sched
operator|.
name|dfa_pre_cycle_insn
condition|)
name|state_transition
argument_list|(
name|curr_state
argument_list|,
name|targetm
operator|.
name|sched
operator|.
name|dfa_pre_cycle_insn
argument_list|()
argument_list|)
expr_stmt|;
name|state_transition
argument_list|(
name|curr_state
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|targetm
operator|.
name|sched
operator|.
name|dfa_post_cycle_insn
condition|)
name|state_transition
argument_list|(
name|curr_state
argument_list|,
name|targetm
operator|.
name|sched
operator|.
name|dfa_post_cycle_insn
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Clock at which the previous instruction was issued.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|last_clock_var
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* INSN is the "currently executing insn".  Launch each insn which was    waiting on INSN.  READY is the ready list which contains the insns    that are ready to fire.  CLOCK is the current cycle.  The function    returns necessary cycle advance after issuing the insn (it is not    zero for insns in a schedule group).  */
end_comment

begin_function
specifier|static
name|int
name|schedule_insn
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|rtx
name|link
decl_stmt|;
name|int
name|advance
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|sched_verbose
operator|>=
literal|1
condition|)
block|{
name|char
name|buf
index|[
literal|2048
index|]
decl_stmt|;
name|print_insn
argument_list|(
name|buf
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|buf
index|[
literal|40
index|]
operator|=
literal|0
expr_stmt|;
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|";;\t%3i--> %-40s:"
argument_list|,
name|clock_var
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|recog_memoized
argument_list|(
name|insn
argument_list|)
operator|<
literal|0
condition|)
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|"nothing"
argument_list|)
expr_stmt|;
else|else
name|print_reservation
argument_list|(
name|sched_dump
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|sched_dump
argument_list|)
expr_stmt|;
block|}
comment|/* Scheduling instruction should have all its dependencies resolved and      should have been removed from the ready list.  */
name|gcc_assert
argument_list|(
name|INSN_DEP_COUNT
argument_list|(
name|insn
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|QUEUE_INDEX
argument_list|(
name|insn
argument_list|)
operator|==
name|QUEUE_NOWHERE
argument_list|)
expr_stmt|;
name|QUEUE_INDEX
argument_list|(
name|insn
argument_list|)
operator|=
name|QUEUE_SCHEDULED
expr_stmt|;
comment|/* Now we can free RESOLVED_DEPS list.  */
if|if
condition|(
name|current_sched_info
operator|->
name|flags
operator|&
name|USE_DEPS_LIST
condition|)
name|free_DEPS_LIST_list
argument_list|(
operator|&
name|RESOLVED_DEPS
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|free_INSN_LIST_list
argument_list|(
operator|&
name|RESOLVED_DEPS
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|INSN_TICK
argument_list|(
name|insn
argument_list|)
operator|>=
name|MIN_TICK
argument_list|)
expr_stmt|;
if|if
condition|(
name|INSN_TICK
argument_list|(
name|insn
argument_list|)
operator|>
name|clock_var
condition|)
comment|/* INSN has been prematurely moved from the queue to the ready list.        This is possible only if following flag is set.  */
name|gcc_assert
argument_list|(
name|flag_sched_stalled_insns
argument_list|)
expr_stmt|;
comment|/* ??? Probably, if INSN is scheduled prematurely, we should leave      INSN_TICK untouched.  This is a machine-dependent issue, actually.  */
name|INSN_TICK
argument_list|(
name|insn
argument_list|)
operator|=
name|clock_var
expr_stmt|;
comment|/* Update dependent instructions.  */
for|for
control|(
name|link
operator|=
name|INSN_DEPEND
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|rtx
name|next
init|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|resolve_dep
argument_list|(
name|next
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IS_SPECULATION_BRANCHY_CHECK_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|int
name|effective_cost
decl_stmt|;
name|effective_cost
operator|=
name|try_ready
argument_list|(
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|effective_cost
operator|>=
literal|0
operator|&&
name|SCHED_GROUP_P
argument_list|(
name|next
argument_list|)
operator|&&
name|advance
operator|<
name|effective_cost
condition|)
name|advance
operator|=
name|effective_cost
expr_stmt|;
block|}
else|else
comment|/* Check always has only one forward dependence (to the first insn in 	   the recovery block), therefore, this will be executed only once.  */
block|{
name|gcc_assert
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|fix_recovery_deps
argument_list|(
name|RECOVERY_BLOCK
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Annotate the instruction with issue information -- TImode      indicates that the instruction is expected not to be able      to issue on the same cycle as the previous insn.  A machine      may use this information to decide how the instruction should      be aligned.  */
if|if
condition|(
name|issue_rate
operator|>
literal|1
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|USE
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|CLOBBER
condition|)
block|{
if|if
condition|(
name|reload_completed
condition|)
name|PUT_MODE
argument_list|(
name|insn
argument_list|,
name|clock_var
operator|>
name|last_clock_var
condition|?
name|TImode
else|:
name|VOIDmode
argument_list|)
expr_stmt|;
name|last_clock_var
operator|=
name|clock_var
expr_stmt|;
block|}
return|return
name|advance
return|;
block|}
end_function

begin_comment
comment|/* Functions for handling of notes.  */
end_comment

begin_comment
comment|/* Delete notes beginning with INSN and put them in the chain    of notes ended by NOTE_LIST.    Returns the insn following the notes.  */
end_comment

begin_function
specifier|static
name|rtx
name|unlink_other_notes
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|rtx
name|tail
parameter_list|)
block|{
name|rtx
name|prev
init|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
while|while
condition|(
name|insn
operator|!=
name|tail
operator|&&
name|NOTE_NOT_BB_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|rtx
name|next
init|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|basic_block
name|bb
init|=
name|BLOCK_FOR_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
comment|/* Delete the note from its current position.  */
if|if
condition|(
name|prev
condition|)
name|NEXT_INSN
argument_list|(
name|prev
argument_list|)
operator|=
name|next
expr_stmt|;
if|if
condition|(
name|next
condition|)
name|PREV_INSN
argument_list|(
name|next
argument_list|)
operator|=
name|prev
expr_stmt|;
if|if
condition|(
name|bb
condition|)
block|{
comment|/* Basic block can begin with either LABEL or              NOTE_INSN_BASIC_BLOCK.  */
name|gcc_assert
argument_list|(
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
operator|!=
name|insn
argument_list|)
expr_stmt|;
comment|/* Check if we are removing last insn in the BB.  */
if|if
condition|(
name|BB_END
argument_list|(
name|bb
argument_list|)
operator|==
name|insn
condition|)
name|BB_END
argument_list|(
name|bb
argument_list|)
operator|=
name|prev
expr_stmt|;
block|}
comment|/* See sched_analyze to see how these are handled.  */
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE_INSN_EH_REGION_BEG
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE_INSN_EH_REGION_END
condition|)
block|{
comment|/* Insert the note at the end of the notes list.  */
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
operator|=
name|note_list
expr_stmt|;
if|if
condition|(
name|note_list
condition|)
name|NEXT_INSN
argument_list|(
name|note_list
argument_list|)
operator|=
name|insn
expr_stmt|;
name|note_list
operator|=
name|insn
expr_stmt|;
block|}
name|insn
operator|=
name|next
expr_stmt|;
block|}
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Delete line notes beginning with INSN. Record line-number notes so    they can be reused.  Returns the insn following the notes.  */
end_comment

begin_function
specifier|static
name|rtx
name|unlink_line_notes
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|rtx
name|tail
parameter_list|)
block|{
name|rtx
name|prev
init|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
while|while
condition|(
name|insn
operator|!=
name|tail
operator|&&
name|NOTE_NOT_BB_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|rtx
name|next
init|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|write_symbols
operator|!=
name|NO_DEBUG
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|>
literal|0
condition|)
block|{
name|basic_block
name|bb
init|=
name|BLOCK_FOR_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
comment|/* Delete the note from its current position.  */
if|if
condition|(
name|prev
condition|)
name|NEXT_INSN
argument_list|(
name|prev
argument_list|)
operator|=
name|next
expr_stmt|;
if|if
condition|(
name|next
condition|)
name|PREV_INSN
argument_list|(
name|next
argument_list|)
operator|=
name|prev
expr_stmt|;
if|if
condition|(
name|bb
condition|)
block|{
comment|/* Basic block can begin with either LABEL or                  NOTE_INSN_BASIC_BLOCK.  */
name|gcc_assert
argument_list|(
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
operator|!=
name|insn
argument_list|)
expr_stmt|;
comment|/* Check if we are removing last insn in the BB.  */
if|if
condition|(
name|BB_END
argument_list|(
name|bb
argument_list|)
operator|==
name|insn
condition|)
name|BB_END
argument_list|(
name|bb
argument_list|)
operator|=
name|prev
expr_stmt|;
block|}
comment|/* Record line-number notes so they can be reused.  */
name|LINE_NOTE
argument_list|(
name|insn
argument_list|)
operator|=
name|insn
expr_stmt|;
block|}
else|else
name|prev
operator|=
name|insn
expr_stmt|;
name|insn
operator|=
name|next
expr_stmt|;
block|}
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Return the head and tail pointers of ebb starting at BEG and ending    at END.  */
end_comment

begin_function
name|void
name|get_ebb_head_tail
parameter_list|(
name|basic_block
name|beg
parameter_list|,
name|basic_block
name|end
parameter_list|,
name|rtx
modifier|*
name|headp
parameter_list|,
name|rtx
modifier|*
name|tailp
parameter_list|)
block|{
name|rtx
name|beg_head
init|=
name|BB_HEAD
argument_list|(
name|beg
argument_list|)
decl_stmt|;
name|rtx
name|beg_tail
init|=
name|BB_END
argument_list|(
name|beg
argument_list|)
decl_stmt|;
name|rtx
name|end_head
init|=
name|BB_HEAD
argument_list|(
name|end
argument_list|)
decl_stmt|;
name|rtx
name|end_tail
init|=
name|BB_END
argument_list|(
name|end
argument_list|)
decl_stmt|;
comment|/* Don't include any notes or labels at the beginning of the BEG      basic block, or notes at the end of the END basic blocks.  */
if|if
condition|(
name|LABEL_P
argument_list|(
name|beg_head
argument_list|)
condition|)
name|beg_head
operator|=
name|NEXT_INSN
argument_list|(
name|beg_head
argument_list|)
expr_stmt|;
while|while
condition|(
name|beg_head
operator|!=
name|beg_tail
condition|)
if|if
condition|(
name|NOTE_P
argument_list|(
name|beg_head
argument_list|)
condition|)
name|beg_head
operator|=
name|NEXT_INSN
argument_list|(
name|beg_head
argument_list|)
expr_stmt|;
else|else
break|break;
operator|*
name|headp
operator|=
name|beg_head
expr_stmt|;
if|if
condition|(
name|beg
operator|==
name|end
condition|)
name|end_head
operator|=
name|beg_head
expr_stmt|;
elseif|else
if|if
condition|(
name|LABEL_P
argument_list|(
name|end_head
argument_list|)
condition|)
name|end_head
operator|=
name|NEXT_INSN
argument_list|(
name|end_head
argument_list|)
expr_stmt|;
while|while
condition|(
name|end_head
operator|!=
name|end_tail
condition|)
if|if
condition|(
name|NOTE_P
argument_list|(
name|end_tail
argument_list|)
condition|)
name|end_tail
operator|=
name|PREV_INSN
argument_list|(
name|end_tail
argument_list|)
expr_stmt|;
else|else
break|break;
operator|*
name|tailp
operator|=
name|end_tail
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return nonzero if there are no real insns in the range [ HEAD, TAIL ].  */
end_comment

begin_function
name|int
name|no_real_insns_p
parameter_list|(
name|rtx
name|head
parameter_list|,
name|rtx
name|tail
parameter_list|)
block|{
while|while
condition|(
name|head
operator|!=
name|NEXT_INSN
argument_list|(
name|tail
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|NOTE_P
argument_list|(
name|head
argument_list|)
operator|&&
operator|!
name|LABEL_P
argument_list|(
name|head
argument_list|)
condition|)
return|return
literal|0
return|;
name|head
operator|=
name|NEXT_INSN
argument_list|(
name|head
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Delete line notes from one block. Save them so they can be later restored    (in restore_line_notes).  HEAD and TAIL are the boundaries of the    block in which notes should be processed.  */
end_comment

begin_function
name|void
name|rm_line_notes
parameter_list|(
name|rtx
name|head
parameter_list|,
name|rtx
name|tail
parameter_list|)
block|{
name|rtx
name|next_tail
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|next_tail
operator|=
name|NEXT_INSN
argument_list|(
name|tail
argument_list|)
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|head
init|;
name|insn
operator|!=
name|next_tail
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|rtx
name|prev
decl_stmt|;
comment|/* Farm out notes, and maybe save them in NOTE_LIST.          This is needed to keep the debugger from          getting completely deranged.  */
if|if
condition|(
name|NOTE_NOT_BB_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|prev
operator|=
name|insn
expr_stmt|;
name|insn
operator|=
name|unlink_line_notes
argument_list|(
name|insn
argument_list|,
name|next_tail
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|prev
operator|!=
name|tail
operator|&&
name|prev
operator|!=
name|head
operator|&&
name|insn
operator|!=
name|next_tail
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Save line number notes for each insn in block B.  HEAD and TAIL are    the boundaries of the block in which notes should be processed.  */
end_comment

begin_function
name|void
name|save_line_notes
parameter_list|(
name|int
name|b
parameter_list|,
name|rtx
name|head
parameter_list|,
name|rtx
name|tail
parameter_list|)
block|{
name|rtx
name|next_tail
decl_stmt|;
comment|/* We must use the true line number for the first insn in the block      that was computed and saved at the start of this pass.  We can't      use the current line number, because scheduling of the previous      block may have changed the current line number.  */
name|rtx
name|line
init|=
name|line_note_head
index|[
name|b
index|]
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|next_tail
operator|=
name|NEXT_INSN
argument_list|(
name|tail
argument_list|)
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|head
init|;
name|insn
operator|!=
name|next_tail
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|NOTE_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|>
literal|0
condition|)
name|line
operator|=
name|insn
expr_stmt|;
else|else
name|LINE_NOTE
argument_list|(
name|insn
argument_list|)
operator|=
name|line
expr_stmt|;
block|}
end_function

begin_comment
comment|/* After a block was scheduled, insert line notes into the insns list.    HEAD and TAIL are the boundaries of the block in which notes should    be processed.  */
end_comment

begin_function
name|void
name|restore_line_notes
parameter_list|(
name|rtx
name|head
parameter_list|,
name|rtx
name|tail
parameter_list|)
block|{
name|rtx
name|line
decl_stmt|,
name|note
decl_stmt|,
name|prev
decl_stmt|,
name|new
decl_stmt|;
name|int
name|added_notes
init|=
literal|0
decl_stmt|;
name|rtx
name|next_tail
decl_stmt|,
name|insn
decl_stmt|;
name|head
operator|=
name|head
expr_stmt|;
name|next_tail
operator|=
name|NEXT_INSN
argument_list|(
name|tail
argument_list|)
expr_stmt|;
comment|/* Determine the current line-number.  We want to know the current      line number of the first insn of the block here, in case it is      different from the true line number that was saved earlier.  If      different, then we need a line number note before the first insn      of this block.  If it happens to be the same, then we don't want to      emit another line number note here.  */
for|for
control|(
name|line
operator|=
name|head
init|;
name|line
condition|;
name|line
operator|=
name|PREV_INSN
argument_list|(
name|line
argument_list|)
control|)
if|if
condition|(
name|NOTE_P
argument_list|(
name|line
argument_list|)
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|line
argument_list|)
operator|>
literal|0
condition|)
break|break;
comment|/* Walk the insns keeping track of the current line-number and inserting      the line-number notes as needed.  */
for|for
control|(
name|insn
operator|=
name|head
init|;
name|insn
operator|!=
name|next_tail
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|NOTE_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|>
literal|0
condition|)
name|line
operator|=
name|insn
expr_stmt|;
comment|/* This used to emit line number notes before every non-deleted note.      However, this confuses a debugger, because line notes not separated      by real instructions all end up at the same address.  I can find no      use for line number notes before other notes, so none are emitted.  */
elseif|else
if|if
condition|(
operator|!
name|NOTE_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|INSN_UID
argument_list|(
name|insn
argument_list|)
operator|<
name|old_max_uid
operator|&&
operator|(
name|note
operator|=
name|LINE_NOTE
argument_list|(
name|insn
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|note
operator|!=
name|line
operator|&&
operator|(
name|line
operator|==
literal|0
ifdef|#
directive|ifdef
name|USE_MAPPED_LOCATION
operator|||
name|NOTE_SOURCE_LOCATION
argument_list|(
name|note
argument_list|)
operator|!=
name|NOTE_SOURCE_LOCATION
argument_list|(
name|line
argument_list|)
else|#
directive|else
operator|||
name|NOTE_LINE_NUMBER
argument_list|(
name|note
argument_list|)
operator|!=
name|NOTE_LINE_NUMBER
argument_list|(
name|line
argument_list|)
operator|||
name|NOTE_SOURCE_FILE
argument_list|(
name|note
argument_list|)
operator|!=
name|NOTE_SOURCE_FILE
argument_list|(
name|line
argument_list|)
endif|#
directive|endif
operator|)
condition|)
block|{
name|line
operator|=
name|note
expr_stmt|;
name|prev
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|LINE_NOTE
argument_list|(
name|note
argument_list|)
condition|)
block|{
comment|/* Re-use the original line-number note.  */
name|LINE_NOTE
argument_list|(
name|note
argument_list|)
operator|=
literal|0
expr_stmt|;
name|PREV_INSN
argument_list|(
name|note
argument_list|)
operator|=
name|prev
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|prev
argument_list|)
operator|=
name|note
expr_stmt|;
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
operator|=
name|note
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|note
argument_list|)
operator|=
name|insn
expr_stmt|;
name|set_block_for_insn
argument_list|(
name|note
argument_list|,
name|BLOCK_FOR_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|added_notes
operator|++
expr_stmt|;
name|new
operator|=
name|emit_note_after
argument_list|(
name|NOTE_LINE_NUMBER
argument_list|(
name|note
argument_list|)
argument_list|,
name|prev
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|USE_MAPPED_LOCATION
name|NOTE_SOURCE_FILE
argument_list|(
name|new
argument_list|)
operator|=
name|NOTE_SOURCE_FILE
argument_list|(
name|note
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
if|if
condition|(
name|sched_verbose
operator|&&
name|added_notes
condition|)
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|";; added %d line-number notes\n"
argument_list|,
name|added_notes
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* After scheduling the function, delete redundant line notes from the    insns list.  */
end_comment

begin_function
name|void
name|rm_redundant_line_notes
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|line
init|=
literal|0
decl_stmt|;
name|rtx
name|insn
init|=
name|get_insns
argument_list|()
decl_stmt|;
name|int
name|active_insn
init|=
literal|0
decl_stmt|;
name|int
name|notes
init|=
literal|0
decl_stmt|;
comment|/* Walk the insns deleting redundant line-number notes.  Many of these      are already present.  The remainder tend to occur at basic      block boundaries.  */
for|for
control|(
name|insn
operator|=
name|get_last_insn
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|NOTE_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|>
literal|0
condition|)
block|{
comment|/* If there are no active insns following, INSN is redundant.  */
if|if
condition|(
name|active_insn
operator|==
literal|0
condition|)
block|{
name|notes
operator|++
expr_stmt|;
name|SET_INSN_DELETED
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
comment|/* If the line number is unchanged, LINE is redundant.  */
elseif|else
if|if
condition|(
name|line
ifdef|#
directive|ifdef
name|USE_MAPPED_LOCATION
operator|&&
name|NOTE_SOURCE_LOCATION
argument_list|(
name|line
argument_list|)
operator|==
name|NOTE_SOURCE_LOCATION
argument_list|(
name|insn
argument_list|)
else|#
directive|else
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|line
argument_list|)
operator|==
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|&&
name|NOTE_SOURCE_FILE
argument_list|(
name|line
argument_list|)
operator|==
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
endif|#
directive|endif
condition|)
block|{
name|notes
operator|++
expr_stmt|;
name|SET_INSN_DELETED
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|line
operator|=
name|insn
expr_stmt|;
block|}
else|else
name|line
operator|=
name|insn
expr_stmt|;
name|active_insn
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
operator|(
name|NOTE_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_DELETED
operator|)
operator|||
operator|(
name|NONJUMP_INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|USE
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|CLOBBER
operator|)
operator|)
operator|)
condition|)
name|active_insn
operator|++
expr_stmt|;
if|if
condition|(
name|sched_verbose
operator|&&
name|notes
condition|)
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|";; deleted %d line-number notes\n"
argument_list|,
name|notes
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Delete notes between HEAD and TAIL and put them in the chain    of notes ended by NOTE_LIST.  */
end_comment

begin_function
name|void
name|rm_other_notes
parameter_list|(
name|rtx
name|head
parameter_list|,
name|rtx
name|tail
parameter_list|)
block|{
name|rtx
name|next_tail
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|note_list
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|head
operator|==
name|tail
operator|&&
operator|(
operator|!
name|INSN_P
argument_list|(
name|head
argument_list|)
operator|)
condition|)
return|return;
name|next_tail
operator|=
name|NEXT_INSN
argument_list|(
name|tail
argument_list|)
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|head
init|;
name|insn
operator|!=
name|next_tail
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|rtx
name|prev
decl_stmt|;
comment|/* Farm out notes, and maybe save them in NOTE_LIST.          This is needed to keep the debugger from          getting completely deranged.  */
if|if
condition|(
name|NOTE_NOT_BB_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|prev
operator|=
name|insn
expr_stmt|;
name|insn
operator|=
name|unlink_other_notes
argument_list|(
name|insn
argument_list|,
name|next_tail
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|prev
operator|!=
name|tail
operator|&&
name|prev
operator|!=
name|head
operator|&&
name|insn
operator|!=
name|next_tail
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Functions for computation of registers live/usage info.  */
end_comment

begin_comment
comment|/* This function looks for a new register being defined.    If the destination register is already used by the source,    a new register is not needed.  */
end_comment

begin_function
specifier|static
name|int
name|find_set_reg_weight
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CLOBBER
operator|&&
name|register_operand
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
name|VOIDmode
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SET
operator|&&
name|register_operand
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
name|VOIDmode
argument_list|)
condition|)
block|{
if|if
condition|(
name|REG_P
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|reg_mentioned_p
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Calculate INSN_REG_WEIGHT for all insns of a block.  */
end_comment

begin_function
specifier|static
name|void
name|find_insn_reg_weight
parameter_list|(
name|basic_block
name|bb
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|,
name|next_tail
decl_stmt|,
name|head
decl_stmt|,
name|tail
decl_stmt|;
name|get_ebb_head_tail
argument_list|(
name|bb
argument_list|,
name|bb
argument_list|,
operator|&
name|head
argument_list|,
operator|&
name|tail
argument_list|)
expr_stmt|;
name|next_tail
operator|=
name|NEXT_INSN
argument_list|(
name|tail
argument_list|)
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|head
init|;
name|insn
operator|!=
name|next_tail
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
name|find_insn_reg_weight1
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Calculate INSN_REG_WEIGHT for single instruction.    Separated from find_insn_reg_weight because of need    to initialize new instruction in generate_recovery_code.  */
end_comment

begin_function
specifier|static
name|void
name|find_insn_reg_weight1
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|int
name|reg_weight
init|=
literal|0
decl_stmt|;
name|rtx
name|x
decl_stmt|;
comment|/* Handle register life information.  */
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
return|return;
comment|/* Increment weight for each register born here.  */
name|x
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|reg_weight
operator|+=
name|find_set_reg_weight
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
block|{
name|x
operator|=
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|reg_weight
operator|+=
name|find_set_reg_weight
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Decrement weight for each register that dies here.  */
for|for
control|(
name|x
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|x
condition|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
control|)
block|{
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|x
argument_list|)
operator|==
name|REG_DEAD
operator|||
name|REG_NOTE_KIND
argument_list|(
name|x
argument_list|)
operator|==
name|REG_UNUSED
condition|)
name|reg_weight
operator|--
expr_stmt|;
block|}
name|INSN_REG_WEIGHT
argument_list|(
name|insn
argument_list|)
operator|=
name|reg_weight
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Move insns that became ready to fire from queue to ready list.  */
end_comment

begin_function
specifier|static
name|void
name|queue_to_ready
parameter_list|(
name|struct
name|ready_list
modifier|*
name|ready
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
name|rtx
name|link
decl_stmt|;
name|q_ptr
operator|=
name|NEXT_Q
argument_list|(
name|q_ptr
argument_list|)
expr_stmt|;
comment|/* Add all pending insns that can be scheduled without stalls to the      ready list.  */
for|for
control|(
name|link
operator|=
name|insn_queue
index|[
name|q_ptr
index|]
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|insn
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|q_size
operator|-=
literal|1
expr_stmt|;
if|if
condition|(
name|sched_verbose
operator|>=
literal|2
condition|)
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|";;\t\tQ-->Ready: insn %s: "
argument_list|,
call|(
modifier|*
name|current_sched_info
operator|->
name|print_insn
call|)
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the ready list is full, delay the insn for 1 cycle. 	 See the comment in schedule_block for the rationale.  */
if|if
condition|(
operator|!
name|reload_completed
operator|&&
name|ready
operator|->
name|n_ready
operator|>
name|MAX_SCHED_READY_INSNS
operator|&&
operator|!
name|SCHED_GROUP_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
if|if
condition|(
name|sched_verbose
operator|>=
literal|2
condition|)
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|"requeued because ready full\n"
argument_list|)
expr_stmt|;
name|queue_insn
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ready_add
argument_list|(
name|ready
argument_list|,
name|insn
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|sched_verbose
operator|>=
literal|2
condition|)
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|"moving to ready without stalls\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|free_INSN_LIST_list
argument_list|(
operator|&
name|insn_queue
index|[
name|q_ptr
index|]
argument_list|)
expr_stmt|;
comment|/* If there are no ready insns, stall until one is ready and add all      of the pending insns at that point to the ready list.  */
if|if
condition|(
name|ready
operator|->
name|n_ready
operator|==
literal|0
condition|)
block|{
name|int
name|stalls
decl_stmt|;
for|for
control|(
name|stalls
operator|=
literal|1
init|;
name|stalls
operator|<=
name|max_insn_queue_index
condition|;
name|stalls
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|link
operator|=
name|insn_queue
index|[
name|NEXT_Q_AFTER
argument_list|(
name|q_ptr
argument_list|,
name|stalls
argument_list|)
index|]
operator|)
condition|)
block|{
for|for
control|(
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|insn
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|q_size
operator|-=
literal|1
expr_stmt|;
if|if
condition|(
name|sched_verbose
operator|>=
literal|2
condition|)
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|";;\t\tQ-->Ready: insn %s: "
argument_list|,
call|(
modifier|*
name|current_sched_info
operator|->
name|print_insn
call|)
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|ready_add
argument_list|(
name|ready
argument_list|,
name|insn
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|sched_verbose
operator|>=
literal|2
condition|)
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|"moving to ready with %d stalls\n"
argument_list|,
name|stalls
argument_list|)
expr_stmt|;
block|}
name|free_INSN_LIST_list
argument_list|(
operator|&
name|insn_queue
index|[
name|NEXT_Q_AFTER
argument_list|(
name|q_ptr
argument_list|,
name|stalls
argument_list|)
index|]
argument_list|)
expr_stmt|;
name|advance_one_cycle
argument_list|()
expr_stmt|;
break|break;
block|}
name|advance_one_cycle
argument_list|()
expr_stmt|;
block|}
name|q_ptr
operator|=
name|NEXT_Q_AFTER
argument_list|(
name|q_ptr
argument_list|,
name|stalls
argument_list|)
expr_stmt|;
name|clock_var
operator|+=
name|stalls
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Used by early_queue_to_ready.  Determines whether it is "ok" to    prematurely move INSN from the queue to the ready list.  Currently,     if a target defines the hook 'is_costly_dependence', this function     uses the hook to check whether there exist any dependences which are    considered costly by the target, between INSN and other insns that     have already been scheduled.  Dependences are checked up to Y cycles    back, with default Y=1; The flag -fsched-stalled-insns-dep=Y allows    controlling this value.     (Other considerations could be taken into account instead (or in     addition) depending on user flags and target hooks.  */
end_comment

begin_function
specifier|static
name|bool
name|ok_for_early_queue_removal
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|int
name|n_cycles
decl_stmt|;
name|rtx
name|prev_insn
init|=
name|last_scheduled_insn
decl_stmt|;
if|if
condition|(
name|targetm
operator|.
name|sched
operator|.
name|is_costly_dependence
condition|)
block|{
for|for
control|(
name|n_cycles
operator|=
name|flag_sched_stalled_insns_dep
init|;
name|n_cycles
condition|;
name|n_cycles
operator|--
control|)
block|{
for|for
control|(
init|;
name|prev_insn
condition|;
name|prev_insn
operator|=
name|PREV_INSN
argument_list|(
name|prev_insn
argument_list|)
control|)
block|{
name|rtx
name|dep_link
init|=
literal|0
decl_stmt|;
name|int
name|dep_cost
decl_stmt|;
if|if
condition|(
operator|!
name|NOTE_P
argument_list|(
name|prev_insn
argument_list|)
condition|)
block|{
name|dep_link
operator|=
name|find_insn_list
argument_list|(
name|insn
argument_list|,
name|INSN_DEPEND
argument_list|(
name|prev_insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dep_link
condition|)
block|{
name|dep_cost
operator|=
name|insn_cost
argument_list|(
name|prev_insn
argument_list|,
name|dep_link
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|targetm
operator|.
name|sched
operator|.
name|is_costly_dependence
argument_list|(
name|prev_insn
argument_list|,
name|insn
argument_list|,
name|dep_link
argument_list|,
name|dep_cost
argument_list|,
name|flag_sched_stalled_insns_dep
operator|-
name|n_cycles
argument_list|)
condition|)
return|return
name|false
return|;
block|}
block|}
if|if
condition|(
name|GET_MODE
argument_list|(
name|prev_insn
argument_list|)
operator|==
name|TImode
condition|)
comment|/* end of dispatch group */
break|break;
block|}
if|if
condition|(
operator|!
name|prev_insn
condition|)
break|break;
name|prev_insn
operator|=
name|PREV_INSN
argument_list|(
name|prev_insn
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Remove insns from the queue, before they become "ready" with respect    to FU latency considerations.  */
end_comment

begin_function
specifier|static
name|int
name|early_queue_to_ready
parameter_list|(
name|state_t
name|state
parameter_list|,
name|struct
name|ready_list
modifier|*
name|ready
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
name|rtx
name|link
decl_stmt|;
name|rtx
name|next_link
decl_stmt|;
name|rtx
name|prev_link
decl_stmt|;
name|bool
name|move_to_ready
decl_stmt|;
name|int
name|cost
decl_stmt|;
name|state_t
name|temp_state
init|=
name|alloca
argument_list|(
name|dfa_state_size
argument_list|)
decl_stmt|;
name|int
name|stalls
decl_stmt|;
name|int
name|insns_removed
init|=
literal|0
decl_stmt|;
comment|/*      Flag '-fsched-stalled-insns=X' determines the aggressiveness of this       function:        X == 0: There is no limit on how many queued insns can be removed                        prematurely.  (flag_sched_stalled_insns = -1).       X>= 1: Only X queued insns can be removed prematurely in each  	     invocation.  (flag_sched_stalled_insns = X).       Otherwise: Early queue removal is disabled.          (flag_sched_stalled_insns = 0)   */
if|if
condition|(
operator|!
name|flag_sched_stalled_insns
condition|)
return|return
literal|0
return|;
for|for
control|(
name|stalls
operator|=
literal|0
init|;
name|stalls
operator|<=
name|max_insn_queue_index
condition|;
name|stalls
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|link
operator|=
name|insn_queue
index|[
name|NEXT_Q_AFTER
argument_list|(
name|q_ptr
argument_list|,
name|stalls
argument_list|)
index|]
operator|)
condition|)
block|{
if|if
condition|(
name|sched_verbose
operator|>
literal|6
condition|)
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|";; look at index %d + %d\n"
argument_list|,
name|q_ptr
argument_list|,
name|stalls
argument_list|)
expr_stmt|;
name|prev_link
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|link
condition|)
block|{
name|next_link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|insn
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|&&
name|sched_verbose
operator|>
literal|6
condition|)
name|print_rtl_single
argument_list|(
name|sched_dump
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|temp_state
argument_list|,
name|state
argument_list|,
name|dfa_state_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|recog_memoized
argument_list|(
name|insn
argument_list|)
operator|<
literal|0
condition|)
comment|/* non-negative to indicate that it's not ready 		   to avoid infinite Q->R->Q->R... */
name|cost
operator|=
literal|0
expr_stmt|;
else|else
name|cost
operator|=
name|state_transition
argument_list|(
name|temp_state
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|sched_verbose
operator|>=
literal|6
condition|)
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|"transition cost = %d\n"
argument_list|,
name|cost
argument_list|)
expr_stmt|;
name|move_to_ready
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|cost
operator|<
literal|0
condition|)
block|{
name|move_to_ready
operator|=
name|ok_for_early_queue_removal
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|move_to_ready
operator|==
name|true
condition|)
block|{
comment|/* move from Q to R */
name|q_size
operator|-=
literal|1
expr_stmt|;
name|ready_add
argument_list|(
name|ready
argument_list|,
name|insn
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev_link
condition|)
name|XEXP
argument_list|(
name|prev_link
argument_list|,
literal|1
argument_list|)
operator|=
name|next_link
expr_stmt|;
else|else
name|insn_queue
index|[
name|NEXT_Q_AFTER
argument_list|(
name|q_ptr
argument_list|,
name|stalls
argument_list|)
index|]
operator|=
name|next_link
expr_stmt|;
name|free_INSN_LIST_node
argument_list|(
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|sched_verbose
operator|>=
literal|2
condition|)
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|";;\t\tEarly Q-->Ready: insn %s\n"
argument_list|,
call|(
modifier|*
name|current_sched_info
operator|->
name|print_insn
call|)
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|insns_removed
operator|++
expr_stmt|;
if|if
condition|(
name|insns_removed
operator|==
name|flag_sched_stalled_insns
condition|)
comment|/* Remove no more than flag_sched_stalled_insns insns 			   from Q at a time.  */
return|return
name|insns_removed
return|;
block|}
block|}
if|if
condition|(
name|move_to_ready
operator|==
name|false
condition|)
name|prev_link
operator|=
name|link
expr_stmt|;
name|link
operator|=
name|next_link
expr_stmt|;
block|}
comment|/* while link */
block|}
comment|/* if link */
block|}
comment|/* for stalls.. */
return|return
name|insns_removed
return|;
block|}
end_function

begin_comment
comment|/* Print the ready list for debugging purposes.  Callable from debugger.  */
end_comment

begin_function
specifier|static
name|void
name|debug_ready_list
parameter_list|(
name|struct
name|ready_list
modifier|*
name|ready
parameter_list|)
block|{
name|rtx
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|ready
operator|->
name|n_ready
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|p
operator|=
name|ready_lastpos
argument_list|(
name|ready
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ready
operator|->
name|n_ready
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|"  %s"
argument_list|,
call|(
modifier|*
name|current_sched_info
operator|->
name|print_insn
call|)
argument_list|(
name|p
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Search INSN for REG_SAVE_NOTE note pairs for    NOTE_INSN_EHREGION_{BEG,END}; and convert them back into    NOTEs.  The REG_SAVE_NOTE note following first one is contains the    saved value for NOTE_BLOCK_NUMBER which is useful for    NOTE_INSN_EH_REGION_{BEG,END} NOTEs.  */
end_comment

begin_function
specifier|static
name|void
name|reemit_notes
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|rtx
name|note
decl_stmt|,
name|last
init|=
name|insn
decl_stmt|;
for|for
control|(
name|note
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|note
condition|;
name|note
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
control|)
block|{
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
operator|==
name|REG_SAVE_NOTE
condition|)
block|{
name|enum
name|insn_note
name|note_type
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|last
operator|=
name|emit_note_before
argument_list|(
name|note_type
argument_list|,
name|last
argument_list|)
expr_stmt|;
name|remove_note
argument_list|(
name|insn
argument_list|,
name|note
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Move INSN.  Reemit notes if needed.  Update CFG, if needed.  */
end_comment

begin_function
specifier|static
name|void
name|move_insn
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|rtx
name|last
init|=
name|last_scheduled_insn
decl_stmt|;
if|if
condition|(
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
operator|!=
name|last
condition|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|rtx
name|note
decl_stmt|;
name|int
name|jump_p
init|=
literal|0
decl_stmt|;
name|bb
operator|=
name|BLOCK_FOR_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* BB_HEAD is either LABEL or NOTE.  */
name|gcc_assert
argument_list|(
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
operator|!=
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|BB_END
argument_list|(
name|bb
argument_list|)
operator|==
name|insn
condition|)
comment|/* If this is last instruction in BB, move end marker one 	   instruction up.  */
block|{
comment|/* Jumps are always placed at the end of basic block.  */
name|jump_p
operator|=
name|control_flow_insn_p
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|jump_p
operator|||
operator|(
operator|(
name|current_sched_info
operator|->
name|flags
operator|&
name|SCHED_RGN
operator|)
operator|&&
name|IS_SPECULATION_BRANCHY_CHECK_P
argument_list|(
name|insn
argument_list|)
operator|)
operator|||
operator|(
name|current_sched_info
operator|->
name|flags
operator|&
name|SCHED_EBB
operator|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|BLOCK_FOR_INSN
argument_list|(
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|bb
argument_list|)
expr_stmt|;
name|BB_END
argument_list|(
name|bb
argument_list|)
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
name|gcc_assert
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
operator|!=
name|last
argument_list|)
expr_stmt|;
if|if
condition|(
name|jump_p
condition|)
comment|/* We move the block note along with jump.  */
block|{
comment|/* NT is needed for assertion below.  */
name|rtx
name|nt
init|=
name|current_sched_info
operator|->
name|next_tail
decl_stmt|;
name|note
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
while|while
condition|(
name|NOTE_NOT_BB_P
argument_list|(
name|note
argument_list|)
operator|&&
name|note
operator|!=
name|nt
condition|)
name|note
operator|=
name|NEXT_INSN
argument_list|(
name|note
argument_list|)
expr_stmt|;
if|if
condition|(
name|note
operator|!=
name|nt
operator|&&
operator|(
name|LABEL_P
argument_list|(
name|note
argument_list|)
operator|||
name|BARRIER_P
argument_list|(
name|note
argument_list|)
operator|)
condition|)
name|note
operator|=
name|NEXT_INSN
argument_list|(
name|note
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|NOTE_INSN_BASIC_BLOCK_P
argument_list|(
name|note
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|note
operator|=
name|insn
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|=
name|NEXT_INSN
argument_list|(
name|note
argument_list|)
expr_stmt|;
name|PREV_INSN
argument_list|(
name|NEXT_INSN
argument_list|(
name|note
argument_list|)
argument_list|)
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|note
argument_list|)
operator|=
name|NEXT_INSN
argument_list|(
name|last
argument_list|)
expr_stmt|;
name|PREV_INSN
argument_list|(
name|NEXT_INSN
argument_list|(
name|last
argument_list|)
argument_list|)
operator|=
name|note
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|last
argument_list|)
operator|=
name|insn
expr_stmt|;
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
operator|=
name|last
expr_stmt|;
name|bb
operator|=
name|BLOCK_FOR_INSN
argument_list|(
name|last
argument_list|)
expr_stmt|;
if|if
condition|(
name|jump_p
condition|)
block|{
name|fix_jump_move
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|BLOCK_FOR_INSN
argument_list|(
name|insn
argument_list|)
operator|!=
name|bb
condition|)
name|move_block_after_check
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
operator|==
name|last
argument_list|)
expr_stmt|;
block|}
name|set_block_for_insn
argument_list|(
name|insn
argument_list|,
name|bb
argument_list|)
expr_stmt|;
comment|/* Update BB_END, if needed.  */
if|if
condition|(
name|BB_END
argument_list|(
name|bb
argument_list|)
operator|==
name|last
condition|)
name|BB_END
argument_list|(
name|bb
argument_list|)
operator|=
name|insn
expr_stmt|;
block|}
name|reemit_notes
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|SCHED_GROUP_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The following structure describe an entry of the stack of choices.  */
end_comment

begin_struct
struct|struct
name|choice_entry
block|{
comment|/* Ordinal number of the issued insn in the ready queue.  */
name|int
name|index
decl_stmt|;
comment|/* The number of the rest insns whose issues we should try.  */
name|int
name|rest
decl_stmt|;
comment|/* The number of issued essential insns.  */
name|int
name|n
decl_stmt|;
comment|/* State after issuing the insn.  */
name|state_t
name|state
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The following array is used to implement a stack of choices used in    function max_issue.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|choice_entry
modifier|*
name|choice_stack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The following variable value is number of essential insns issued on    the current cycle.  An insn is essential one if it changes the    processors state.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cycle_issued_insns
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The following variable value is maximal number of tries of issuing    insns for the first cycle multipass insn scheduling.  We define    this value as constant*(DFA_LOOKAHEAD**ISSUE_RATE).  We would not    need this constraint if all real insns (with non-negative codes)    had reservations because in this case the algorithm complexity is    O(DFA_LOOKAHEAD**ISSUE_RATE).  Unfortunately, the dfa descriptions    might be incomplete and such insn might occur.  For such    descriptions, the complexity of algorithm (without the constraint)    could achieve DFA_LOOKAHEAD ** N , where N is the queue length.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|max_lookahead_tries
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The following value is value of hook    `first_cycle_multipass_dfa_lookahead' at the last call of    `max_issue'.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cached_first_cycle_multipass_dfa_lookahead
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The following value is value of `issue_rate' at the last call of    `sched_init'.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cached_issue_rate
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The following function returns maximal (or close to maximal) number    of insns which can be issued on the same cycle and one of which    insns is insns with the best rank (the first insn in READY).  To    make this function tries different samples of ready insns.  READY    is current queue `ready'.  Global array READY_TRY reflects what    insns are already issued in this try.  MAX_POINTS is the sum of points    of all instructions in READY.  The function stops immediately,    if it reached the such a solution, that all instruction can be issued.    INDEX will contain index of the best insn in READY.  The following    function is used only for first cycle multipass scheduling.  */
end_comment

begin_function
specifier|static
name|int
name|max_issue
parameter_list|(
name|struct
name|ready_list
modifier|*
name|ready
parameter_list|,
name|int
modifier|*
name|index
parameter_list|,
name|int
name|max_points
parameter_list|)
block|{
name|int
name|n
decl_stmt|,
name|i
decl_stmt|,
name|all
decl_stmt|,
name|n_ready
decl_stmt|,
name|best
decl_stmt|,
name|delay
decl_stmt|,
name|tries_num
decl_stmt|,
name|points
init|=
operator|-
literal|1
decl_stmt|;
name|struct
name|choice_entry
modifier|*
name|top
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|best
operator|=
literal|0
expr_stmt|;
name|memcpy
argument_list|(
name|choice_stack
operator|->
name|state
argument_list|,
name|curr_state
argument_list|,
name|dfa_state_size
argument_list|)
expr_stmt|;
name|top
operator|=
name|choice_stack
expr_stmt|;
name|top
operator|->
name|rest
operator|=
name|cached_first_cycle_multipass_dfa_lookahead
expr_stmt|;
name|top
operator|->
name|n
operator|=
literal|0
expr_stmt|;
name|n_ready
operator|=
name|ready
operator|->
name|n_ready
expr_stmt|;
for|for
control|(
name|all
operator|=
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_ready
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|ready_try
index|[
name|i
index|]
condition|)
name|all
operator|++
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|tries_num
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|top
operator|->
name|rest
operator|==
literal|0
operator|||
name|i
operator|>=
name|n_ready
condition|)
block|{
if|if
condition|(
name|top
operator|==
name|choice_stack
condition|)
break|break;
if|if
condition|(
name|best
operator|<
name|top
operator|-
name|choice_stack
operator|&&
name|ready_try
index|[
literal|0
index|]
condition|)
block|{
name|best
operator|=
name|top
operator|-
name|choice_stack
expr_stmt|;
operator|*
name|index
operator|=
name|choice_stack
index|[
literal|1
index|]
operator|.
name|index
expr_stmt|;
name|points
operator|=
name|top
operator|->
name|n
expr_stmt|;
if|if
condition|(
name|top
operator|->
name|n
operator|==
name|max_points
operator|||
name|best
operator|==
name|all
condition|)
break|break;
block|}
name|i
operator|=
name|top
operator|->
name|index
expr_stmt|;
name|ready_try
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|top
operator|--
expr_stmt|;
name|memcpy
argument_list|(
name|curr_state
argument_list|,
name|top
operator|->
name|state
argument_list|,
name|dfa_state_size
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|ready_try
index|[
name|i
index|]
condition|)
block|{
name|tries_num
operator|++
expr_stmt|;
if|if
condition|(
name|tries_num
operator|>
name|max_lookahead_tries
condition|)
break|break;
name|insn
operator|=
name|ready_element
argument_list|(
name|ready
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|delay
operator|=
name|state_transition
argument_list|(
name|curr_state
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|delay
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|state_dead_lock_p
argument_list|(
name|curr_state
argument_list|)
condition|)
name|top
operator|->
name|rest
operator|=
literal|0
expr_stmt|;
else|else
name|top
operator|->
name|rest
operator|--
expr_stmt|;
name|n
operator|=
name|top
operator|->
name|n
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|top
operator|->
name|state
argument_list|,
name|curr_state
argument_list|,
name|dfa_state_size
argument_list|)
operator|!=
literal|0
condition|)
name|n
operator|+=
name|ISSUE_POINTS
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|top
operator|++
expr_stmt|;
name|top
operator|->
name|rest
operator|=
name|cached_first_cycle_multipass_dfa_lookahead
expr_stmt|;
name|top
operator|->
name|index
operator|=
name|i
expr_stmt|;
name|top
operator|->
name|n
operator|=
name|n
expr_stmt|;
name|memcpy
argument_list|(
name|top
operator|->
name|state
argument_list|,
name|curr_state
argument_list|,
name|dfa_state_size
argument_list|)
expr_stmt|;
name|ready_try
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|i
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
name|i
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|top
operator|!=
name|choice_stack
condition|)
block|{
name|ready_try
index|[
name|top
operator|->
name|index
index|]
operator|=
literal|0
expr_stmt|;
name|top
operator|--
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|curr_state
argument_list|,
name|choice_stack
operator|->
name|state
argument_list|,
name|dfa_state_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|sched_verbose
operator|>=
literal|4
condition|)
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|";;\t\tChoosed insn : %s; points: %d/%d\n"
argument_list|,
call|(
modifier|*
name|current_sched_info
operator|->
name|print_insn
call|)
argument_list|(
name|ready_element
argument_list|(
name|ready
argument_list|,
operator|*
name|index
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|points
argument_list|,
name|max_points
argument_list|)
expr_stmt|;
return|return
name|best
return|;
block|}
end_function

begin_comment
comment|/* The following function chooses insn from READY and modifies    *N_READY and READY.  The following function is used only for first    cycle multipass scheduling.  */
end_comment

begin_function
specifier|static
name|rtx
name|choose_ready
parameter_list|(
name|struct
name|ready_list
modifier|*
name|ready
parameter_list|)
block|{
name|int
name|lookahead
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|targetm
operator|.
name|sched
operator|.
name|first_cycle_multipass_dfa_lookahead
condition|)
name|lookahead
operator|=
name|targetm
operator|.
name|sched
operator|.
name|first_cycle_multipass_dfa_lookahead
argument_list|()
expr_stmt|;
if|if
condition|(
name|lookahead
operator|<=
literal|0
operator|||
name|SCHED_GROUP_P
argument_list|(
name|ready_element
argument_list|(
name|ready
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|ready_remove_first
argument_list|(
name|ready
argument_list|)
return|;
else|else
block|{
comment|/* Try to choose the better insn.  */
name|int
name|index
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|,
name|n
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|int
name|more_issue
decl_stmt|,
name|max_points
decl_stmt|,
name|try_data
init|=
literal|1
decl_stmt|,
name|try_control
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|cached_first_cycle_multipass_dfa_lookahead
operator|!=
name|lookahead
condition|)
block|{
name|cached_first_cycle_multipass_dfa_lookahead
operator|=
name|lookahead
expr_stmt|;
name|max_lookahead_tries
operator|=
literal|100
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|issue_rate
condition|;
name|i
operator|++
control|)
name|max_lookahead_tries
operator|*=
name|lookahead
expr_stmt|;
block|}
name|insn
operator|=
name|ready_element
argument_list|(
name|ready
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|<
literal|0
condition|)
return|return
name|ready_remove_first
argument_list|(
name|ready
argument_list|)
return|;
if|if
condition|(
name|spec_info
operator|&&
name|spec_info
operator|->
name|flags
operator|&
operator|(
name|PREFER_NON_DATA_SPEC
operator||
name|PREFER_NON_CONTROL_SPEC
operator|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|n
operator|=
name|ready
operator|->
name|n_ready
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|x
decl_stmt|;
name|ds_t
name|s
decl_stmt|;
name|x
operator|=
name|ready_element
argument_list|(
name|ready
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|s
operator|=
name|TODO_SPEC
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|spec_info
operator|->
name|flags
operator|&
name|PREFER_NON_DATA_SPEC
operator|&&
operator|!
operator|(
name|s
operator|&
name|DATA_SPEC
operator|)
condition|)
block|{
name|try_data
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|spec_info
operator|->
name|flags
operator|&
name|PREFER_NON_CONTROL_SPEC
operator|)
operator|||
operator|!
name|try_control
condition|)
break|break;
block|}
if|if
condition|(
name|spec_info
operator|->
name|flags
operator|&
name|PREFER_NON_CONTROL_SPEC
operator|&&
operator|!
operator|(
name|s
operator|&
name|CONTROL_SPEC
operator|)
condition|)
block|{
name|try_control
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|spec_info
operator|->
name|flags
operator|&
name|PREFER_NON_DATA_SPEC
operator|)
operator|||
operator|!
name|try_data
condition|)
break|break;
block|}
block|}
block|}
if|if
condition|(
operator|(
operator|!
name|try_data
operator|&&
operator|(
name|TODO_SPEC
argument_list|(
name|insn
argument_list|)
operator|&
name|DATA_SPEC
operator|)
operator|)
operator|||
operator|(
operator|!
name|try_control
operator|&&
operator|(
name|TODO_SPEC
argument_list|(
name|insn
argument_list|)
operator|&
name|CONTROL_SPEC
operator|)
operator|)
operator|||
operator|(
name|targetm
operator|.
name|sched
operator|.
name|first_cycle_multipass_dfa_lookahead_guard_spec
operator|&&
operator|!
name|targetm
operator|.
name|sched
operator|.
name|first_cycle_multipass_dfa_lookahead_guard_spec
argument_list|(
name|insn
argument_list|)
operator|)
condition|)
comment|/* Discard speculative instruction that stands first in the ready 	   list.  */
block|{
name|change_queue_index
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|max_points
operator|=
name|ISSUE_POINTS
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|more_issue
operator|=
name|issue_rate
operator|-
name|cycle_issued_insns
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|ready
operator|->
name|n_ready
condition|;
name|i
operator|++
control|)
block|{
name|insn
operator|=
name|ready_element
argument_list|(
name|ready
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|ready_try
index|[
name|i
index|]
operator|=
operator|(
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|<
literal|0
operator|||
operator|(
operator|!
name|try_data
operator|&&
operator|(
name|TODO_SPEC
argument_list|(
name|insn
argument_list|)
operator|&
name|DATA_SPEC
operator|)
operator|)
operator|||
operator|(
operator|!
name|try_control
operator|&&
operator|(
name|TODO_SPEC
argument_list|(
name|insn
argument_list|)
operator|&
name|CONTROL_SPEC
operator|)
operator|)
operator|||
operator|(
name|targetm
operator|.
name|sched
operator|.
name|first_cycle_multipass_dfa_lookahead_guard
operator|&&
operator|!
name|targetm
operator|.
name|sched
operator|.
name|first_cycle_multipass_dfa_lookahead_guard
argument_list|(
name|insn
argument_list|)
operator|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|ready_try
index|[
name|i
index|]
operator|&&
name|more_issue
operator|--
operator|>
literal|0
condition|)
name|max_points
operator|+=
name|ISSUE_POINTS
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|max_issue
argument_list|(
name|ready
argument_list|,
operator|&
name|index
argument_list|,
name|max_points
argument_list|)
operator|==
literal|0
condition|)
return|return
name|ready_remove_first
argument_list|(
name|ready
argument_list|)
return|;
else|else
return|return
name|ready_remove
argument_list|(
name|ready
argument_list|,
name|index
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Use forward list scheduling to rearrange insns of block pointed to by    TARGET_BB, possibly bringing insns from subsequent blocks in the same    region.  */
end_comment

begin_function
name|void
name|schedule_block
parameter_list|(
name|basic_block
modifier|*
name|target_bb
parameter_list|,
name|int
name|rgn_n_insns1
parameter_list|)
block|{
name|struct
name|ready_list
name|ready
decl_stmt|;
name|int
name|i
decl_stmt|,
name|first_cycle_insn_p
decl_stmt|;
name|int
name|can_issue_more
decl_stmt|;
name|state_t
name|temp_state
init|=
name|NULL
decl_stmt|;
comment|/* It is used for multipass scheduling.  */
name|int
name|sort_p
decl_stmt|,
name|advance
decl_stmt|,
name|start_clock_var
decl_stmt|;
comment|/* Head/tail info for this block.  */
name|rtx
name|prev_head
init|=
name|current_sched_info
operator|->
name|prev_head
decl_stmt|;
name|rtx
name|next_tail
init|=
name|current_sched_info
operator|->
name|next_tail
decl_stmt|;
name|rtx
name|head
init|=
name|NEXT_INSN
argument_list|(
name|prev_head
argument_list|)
decl_stmt|;
name|rtx
name|tail
init|=
name|PREV_INSN
argument_list|(
name|next_tail
argument_list|)
decl_stmt|;
comment|/* We used to have code to avoid getting parameters moved from hard      argument registers into pseudos.       However, it was removed when it proved to be of marginal benefit      and caused problems because schedule_block and compute_forward_dependences      had different notions of what the "head" insn was.  */
name|gcc_assert
argument_list|(
name|head
operator|!=
name|tail
operator|||
name|INSN_P
argument_list|(
name|head
argument_list|)
argument_list|)
expr_stmt|;
name|added_recovery_block_p
operator|=
name|false
expr_stmt|;
comment|/* Debug info.  */
if|if
condition|(
name|sched_verbose
condition|)
name|dump_new_block_header
argument_list|(
literal|0
argument_list|,
operator|*
name|target_bb
argument_list|,
name|head
argument_list|,
name|tail
argument_list|)
expr_stmt|;
name|state_reset
argument_list|(
name|curr_state
argument_list|)
expr_stmt|;
comment|/* Allocate the ready list.  */
name|readyp
operator|=
operator|&
name|ready
expr_stmt|;
name|ready
operator|.
name|vec
operator|=
name|NULL
expr_stmt|;
name|ready_try
operator|=
name|NULL
expr_stmt|;
name|choice_stack
operator|=
name|NULL
expr_stmt|;
name|rgn_n_insns
operator|=
operator|-
literal|1
expr_stmt|;
name|extend_ready
argument_list|(
name|rgn_n_insns1
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ready
operator|.
name|first
operator|=
name|ready
operator|.
name|veclen
operator|-
literal|1
expr_stmt|;
name|ready
operator|.
name|n_ready
operator|=
literal|0
expr_stmt|;
comment|/* It is used for first cycle multipass scheduling.  */
name|temp_state
operator|=
name|alloca
argument_list|(
name|dfa_state_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|targetm
operator|.
name|sched
operator|.
name|md_init
condition|)
name|targetm
operator|.
name|sched
operator|.
name|md_init
argument_list|(
name|sched_dump
argument_list|,
name|sched_verbose
argument_list|,
name|ready
operator|.
name|veclen
argument_list|)
expr_stmt|;
comment|/* We start inserting insns after PREV_HEAD.  */
name|last_scheduled_insn
operator|=
name|prev_head
expr_stmt|;
name|gcc_assert
argument_list|(
name|NOTE_P
argument_list|(
name|last_scheduled_insn
argument_list|)
operator|&&
name|BLOCK_FOR_INSN
argument_list|(
name|last_scheduled_insn
argument_list|)
operator|==
operator|*
name|target_bb
argument_list|)
expr_stmt|;
comment|/* Initialize INSN_QUEUE.  Q_SIZE is the total number of insns in the      queue.  */
name|q_ptr
operator|=
literal|0
expr_stmt|;
name|q_size
operator|=
literal|0
expr_stmt|;
name|insn_queue
operator|=
name|alloca
argument_list|(
operator|(
name|max_insn_queue_index
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|insn_queue
argument_list|,
literal|0
argument_list|,
operator|(
name|max_insn_queue_index
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Start just before the beginning of time.  */
name|clock_var
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* We need queue and ready lists and clock_var be initialized       in try_ready () (which is called through init_ready_list ()).  */
call|(
modifier|*
name|current_sched_info
operator|->
name|init_ready_list
call|)
argument_list|()
expr_stmt|;
comment|/* The algorithm is O(n^2) in the number of ready insns at any given      time in the worst case.  Before reload we are more likely to have      big lists so truncate them to a reasonable size.  */
if|if
condition|(
operator|!
name|reload_completed
operator|&&
name|ready
operator|.
name|n_ready
operator|>
name|MAX_SCHED_READY_INSNS
condition|)
block|{
name|ready_sort
argument_list|(
operator|&
name|ready
argument_list|)
expr_stmt|;
comment|/* Find first free-standing insn past MAX_SCHED_READY_INSNS.  */
for|for
control|(
name|i
operator|=
name|MAX_SCHED_READY_INSNS
init|;
name|i
operator|<
name|ready
operator|.
name|n_ready
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|SCHED_GROUP_P
argument_list|(
name|ready_element
argument_list|(
operator|&
name|ready
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
break|break;
if|if
condition|(
name|sched_verbose
operator|>=
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|";;\t\tReady list on entry: %d insns\n"
argument_list|,
name|ready
operator|.
name|n_ready
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|";;\t\t before reload => truncated to %d insns\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
comment|/* Delay all insns past it for 1 cycle.  */
while|while
condition|(
name|i
operator|<
name|ready
operator|.
name|n_ready
condition|)
name|queue_insn
argument_list|(
name|ready_remove
argument_list|(
operator|&
name|ready
argument_list|,
name|i
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Now we can restore basic block notes and maintain precise cfg.  */
name|restore_bb_notes
argument_list|(
operator|*
name|target_bb
argument_list|)
expr_stmt|;
name|last_clock_var
operator|=
operator|-
literal|1
expr_stmt|;
name|advance
operator|=
literal|0
expr_stmt|;
name|sort_p
operator|=
name|TRUE
expr_stmt|;
comment|/* Loop until all the insns in BB are scheduled.  */
while|while
condition|(
call|(
modifier|*
name|current_sched_info
operator|->
name|schedule_more_p
call|)
argument_list|()
condition|)
block|{
do|do
block|{
name|start_clock_var
operator|=
name|clock_var
expr_stmt|;
name|clock_var
operator|++
expr_stmt|;
name|advance_one_cycle
argument_list|()
expr_stmt|;
comment|/* Add to the ready list all pending insns that can be issued now. 	     If there are no ready insns, increment clock until one 	     is ready and add all pending insns at that point to the ready 	     list.  */
name|queue_to_ready
argument_list|(
operator|&
name|ready
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|ready
operator|.
name|n_ready
argument_list|)
expr_stmt|;
if|if
condition|(
name|sched_verbose
operator|>=
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|";;\t\tReady list after queue_to_ready:  "
argument_list|)
expr_stmt|;
name|debug_ready_list
argument_list|(
operator|&
name|ready
argument_list|)
expr_stmt|;
block|}
name|advance
operator|-=
name|clock_var
operator|-
name|start_clock_var
expr_stmt|;
block|}
do|while
condition|(
name|advance
operator|>
literal|0
condition|)
do|;
if|if
condition|(
name|sort_p
condition|)
block|{
comment|/* Sort the ready list based on priority.  */
name|ready_sort
argument_list|(
operator|&
name|ready
argument_list|)
expr_stmt|;
if|if
condition|(
name|sched_verbose
operator|>=
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|";;\t\tReady list after ready_sort:  "
argument_list|)
expr_stmt|;
name|debug_ready_list
argument_list|(
operator|&
name|ready
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Allow the target to reorder the list, typically for 	 better instruction bundling.  */
if|if
condition|(
name|sort_p
operator|&&
name|targetm
operator|.
name|sched
operator|.
name|reorder
operator|&&
operator|(
name|ready
operator|.
name|n_ready
operator|==
literal|0
operator|||
operator|!
name|SCHED_GROUP_P
argument_list|(
name|ready_element
argument_list|(
operator|&
name|ready
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
condition|)
name|can_issue_more
operator|=
name|targetm
operator|.
name|sched
operator|.
name|reorder
argument_list|(
name|sched_dump
argument_list|,
name|sched_verbose
argument_list|,
name|ready_lastpos
argument_list|(
operator|&
name|ready
argument_list|)
argument_list|,
operator|&
name|ready
operator|.
name|n_ready
argument_list|,
name|clock_var
argument_list|)
expr_stmt|;
else|else
name|can_issue_more
operator|=
name|issue_rate
expr_stmt|;
name|first_cycle_insn_p
operator|=
literal|1
expr_stmt|;
name|cycle_issued_insns
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|rtx
name|insn
decl_stmt|;
name|int
name|cost
decl_stmt|;
name|bool
name|asm_p
init|=
name|false
decl_stmt|;
if|if
condition|(
name|sched_verbose
operator|>=
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|";;\tReady list (t = %3d):  "
argument_list|,
name|clock_var
argument_list|)
expr_stmt|;
name|debug_ready_list
argument_list|(
operator|&
name|ready
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ready
operator|.
name|n_ready
operator|==
literal|0
operator|&&
name|can_issue_more
operator|&&
name|reload_completed
condition|)
block|{
comment|/* Allow scheduling insns directly from the queue in case 		 there's nothing better to do (ready list is empty) but 		 there are still vacant dispatch slots in the current cycle.  */
if|if
condition|(
name|sched_verbose
operator|>=
literal|6
condition|)
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|";;\t\tSecond chance\n"
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|temp_state
argument_list|,
name|curr_state
argument_list|,
name|dfa_state_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|early_queue_to_ready
argument_list|(
name|temp_state
argument_list|,
operator|&
name|ready
argument_list|)
condition|)
name|ready_sort
argument_list|(
operator|&
name|ready
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ready
operator|.
name|n_ready
operator|==
literal|0
operator|||
operator|!
name|can_issue_more
operator|||
name|state_dead_lock_p
argument_list|(
name|curr_state
argument_list|)
operator|||
operator|!
call|(
modifier|*
name|current_sched_info
operator|->
name|schedule_more_p
call|)
argument_list|()
condition|)
break|break;
comment|/* Select and remove the insn from the ready list.  */
if|if
condition|(
name|sort_p
condition|)
block|{
name|insn
operator|=
name|choose_ready
argument_list|(
operator|&
name|ready
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|insn
condition|)
continue|continue;
block|}
else|else
name|insn
operator|=
name|ready_remove_first
argument_list|(
operator|&
name|ready
argument_list|)
expr_stmt|;
if|if
condition|(
name|targetm
operator|.
name|sched
operator|.
name|dfa_new_cycle
operator|&&
name|targetm
operator|.
name|sched
operator|.
name|dfa_new_cycle
argument_list|(
name|sched_dump
argument_list|,
name|sched_verbose
argument_list|,
name|insn
argument_list|,
name|last_clock_var
argument_list|,
name|clock_var
argument_list|,
operator|&
name|sort_p
argument_list|)
condition|)
comment|/* SORT_P is used by the target to override sorting 	       of the ready list.  This is needed when the target 	       has modified its internal structures expecting that 	       the insn will be issued next.  As we need the insn 	       to have the highest priority (so it will be returned by 	       the ready_remove_first call above), we invoke 	       ready_add (&ready, insn, true). 	       But, still, there is one issue: INSN can be later  	       discarded by scheduler's front end through  	       current_sched_info->can_schedule_ready_p, hence, won't 	       be issued next.  */
block|{
name|ready_add
argument_list|(
operator|&
name|ready
argument_list|,
name|insn
argument_list|,
name|true
argument_list|)
expr_stmt|;
break|break;
block|}
name|sort_p
operator|=
name|TRUE
expr_stmt|;
name|memcpy
argument_list|(
name|temp_state
argument_list|,
name|curr_state
argument_list|,
name|dfa_state_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|recog_memoized
argument_list|(
name|insn
argument_list|)
operator|<
literal|0
condition|)
block|{
name|asm_p
operator|=
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|ASM_INPUT
operator|||
name|asm_noperands
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|>=
literal|0
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|first_cycle_insn_p
operator|&&
name|asm_p
condition|)
comment|/* This is asm insn which is tryed to be issued on the 		   cycle not first.  Issue it on the next cycle.  */
name|cost
operator|=
literal|1
expr_stmt|;
else|else
comment|/* A USE insn, or something else we don't need to 		   understand.  We can't pass these directly to 		   state_transition because it will trigger a 		   fatal error for unrecognizable insns.  */
name|cost
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|cost
operator|=
name|state_transition
argument_list|(
name|temp_state
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|cost
operator|<
literal|0
condition|)
name|cost
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|cost
operator|==
literal|0
condition|)
name|cost
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|cost
operator|>=
literal|1
condition|)
block|{
name|queue_insn
argument_list|(
name|insn
argument_list|,
name|cost
argument_list|)
expr_stmt|;
if|if
condition|(
name|SCHED_GROUP_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|advance
operator|=
name|cost
expr_stmt|;
break|break;
block|}
continue|continue;
block|}
if|if
condition|(
name|current_sched_info
operator|->
name|can_schedule_ready_p
operator|&&
operator|!
call|(
modifier|*
name|current_sched_info
operator|->
name|can_schedule_ready_p
call|)
argument_list|(
name|insn
argument_list|)
condition|)
comment|/* We normally get here only if we don't want to move 	       insn from the split block.  */
block|{
name|TODO_SPEC
argument_list|(
name|insn
argument_list|)
operator|=
operator|(
name|TODO_SPEC
argument_list|(
name|insn
argument_list|)
operator|&
operator|~
name|SPECULATIVE
operator|)
operator||
name|HARD_DEP
expr_stmt|;
continue|continue;
block|}
comment|/* DECISION is made.  */
if|if
condition|(
name|TODO_SPEC
argument_list|(
name|insn
argument_list|)
operator|&
name|SPECULATIVE
condition|)
name|generate_recovery_code
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|control_flow_insn_p
argument_list|(
name|last_scheduled_insn
argument_list|)
comment|/* This is used to to switch basic blocks by request 		 from scheduler front-end (actually, sched-ebb.c only). 		 This is used to process blocks with single fallthru 		 edge.  If succeeding block has jump, it [jump] will try 		 move at the end of current bb, thus corrupting CFG.  */
operator|||
name|current_sched_info
operator|->
name|advance_target_bb
argument_list|(
operator|*
name|target_bb
argument_list|,
name|insn
argument_list|)
condition|)
block|{
operator|*
name|target_bb
operator|=
name|current_sched_info
operator|->
name|advance_target_bb
argument_list|(
operator|*
name|target_bb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sched_verbose
condition|)
block|{
name|rtx
name|x
decl_stmt|;
name|x
operator|=
name|next_real_insn
argument_list|(
name|last_scheduled_insn
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|dump_new_block_header
argument_list|(
literal|1
argument_list|,
operator|*
name|target_bb
argument_list|,
name|x
argument_list|,
name|tail
argument_list|)
expr_stmt|;
block|}
name|last_scheduled_insn
operator|=
name|bb_note
argument_list|(
operator|*
name|target_bb
argument_list|)
expr_stmt|;
block|}
comment|/* Update counters, etc in the scheduler's front end.  */
call|(
modifier|*
name|current_sched_info
operator|->
name|begin_schedule_ready
call|)
argument_list|(
name|insn
argument_list|,
name|last_scheduled_insn
argument_list|)
expr_stmt|;
name|move_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|last_scheduled_insn
operator|=
name|insn
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|curr_state
argument_list|,
name|temp_state
argument_list|,
name|dfa_state_size
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|cycle_issued_insns
operator|++
expr_stmt|;
name|memcpy
argument_list|(
name|curr_state
argument_list|,
name|temp_state
argument_list|,
name|dfa_state_size
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|targetm
operator|.
name|sched
operator|.
name|variable_issue
condition|)
name|can_issue_more
operator|=
name|targetm
operator|.
name|sched
operator|.
name|variable_issue
argument_list|(
name|sched_dump
argument_list|,
name|sched_verbose
argument_list|,
name|insn
argument_list|,
name|can_issue_more
argument_list|)
expr_stmt|;
comment|/* A naked CLOBBER or USE generates no instruction, so do 	     not count them against the issue rate.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|USE
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|CLOBBER
condition|)
name|can_issue_more
operator|--
expr_stmt|;
name|advance
operator|=
name|schedule_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* After issuing an asm insn we should start a new cycle.  */
if|if
condition|(
name|advance
operator|==
literal|0
operator|&&
name|asm_p
condition|)
name|advance
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|advance
operator|!=
literal|0
condition|)
break|break;
name|first_cycle_insn_p
operator|=
literal|0
expr_stmt|;
comment|/* Sort the ready list based on priority.  This must be 	     redone here, as schedule_insn may have readied additional 	     insns that will not be sorted correctly.  */
if|if
condition|(
name|ready
operator|.
name|n_ready
operator|>
literal|0
condition|)
name|ready_sort
argument_list|(
operator|&
name|ready
argument_list|)
expr_stmt|;
if|if
condition|(
name|targetm
operator|.
name|sched
operator|.
name|reorder2
operator|&&
operator|(
name|ready
operator|.
name|n_ready
operator|==
literal|0
operator|||
operator|!
name|SCHED_GROUP_P
argument_list|(
name|ready_element
argument_list|(
operator|&
name|ready
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|can_issue_more
operator|=
name|targetm
operator|.
name|sched
operator|.
name|reorder2
argument_list|(
name|sched_dump
argument_list|,
name|sched_verbose
argument_list|,
name|ready
operator|.
name|n_ready
condition|?
name|ready_lastpos
argument_list|(
operator|&
name|ready
argument_list|)
else|:
name|NULL
argument_list|,
operator|&
name|ready
operator|.
name|n_ready
argument_list|,
name|clock_var
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Debug info.  */
if|if
condition|(
name|sched_verbose
condition|)
block|{
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|";;\tReady list (final):  "
argument_list|)
expr_stmt|;
name|debug_ready_list
argument_list|(
operator|&
name|ready
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|current_sched_info
operator|->
name|queue_must_finish_empty
condition|)
comment|/* Sanity check -- queue must be empty now.  Meaningless if region has        multiple bbs.  */
name|gcc_assert
argument_list|(
operator|!
name|q_size
operator|&&
operator|!
name|ready
operator|.
name|n_ready
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* We must maintain QUEUE_INDEX between blocks in region.  */
for|for
control|(
name|i
operator|=
name|ready
operator|.
name|n_ready
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|rtx
name|x
decl_stmt|;
name|x
operator|=
name|ready_element
argument_list|(
operator|&
name|ready
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|QUEUE_INDEX
argument_list|(
name|x
argument_list|)
operator|=
name|QUEUE_NOWHERE
expr_stmt|;
name|TODO_SPEC
argument_list|(
name|x
argument_list|)
operator|=
operator|(
name|TODO_SPEC
argument_list|(
name|x
argument_list|)
operator|&
operator|~
name|SPECULATIVE
operator|)
operator||
name|HARD_DEP
expr_stmt|;
block|}
if|if
condition|(
name|q_size
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|max_insn_queue_index
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|link
decl_stmt|;
for|for
control|(
name|link
operator|=
name|insn_queue
index|[
name|i
index|]
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|rtx
name|x
decl_stmt|;
name|x
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|QUEUE_INDEX
argument_list|(
name|x
argument_list|)
operator|=
name|QUEUE_NOWHERE
expr_stmt|;
name|TODO_SPEC
argument_list|(
name|x
argument_list|)
operator|=
operator|(
name|TODO_SPEC
argument_list|(
name|x
argument_list|)
operator|&
operator|~
name|SPECULATIVE
operator|)
operator||
name|HARD_DEP
expr_stmt|;
block|}
name|free_INSN_LIST_list
argument_list|(
operator|&
name|insn_queue
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|current_sched_info
operator|->
name|queue_must_finish_empty
operator|||
name|added_recovery_block_p
condition|)
block|{
comment|/* INSN_TICK (minimum clock tick at which the insn becomes          ready) may be not correct for the insn in the subsequent          blocks of the region.  We should use a correct value of          `clock_var' or modify INSN_TICK.  It is better to keep          clock_var value equal to 0 at the start of a basic block.          Therefore we modify INSN_TICK here.  */
name|fix_inter_tick
argument_list|(
name|NEXT_INSN
argument_list|(
name|prev_head
argument_list|)
argument_list|,
name|last_scheduled_insn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|targetm
operator|.
name|sched
operator|.
name|md_finish
condition|)
name|targetm
operator|.
name|sched
operator|.
name|md_finish
argument_list|(
name|sched_dump
argument_list|,
name|sched_verbose
argument_list|)
expr_stmt|;
comment|/* Update head/tail boundaries.  */
name|head
operator|=
name|NEXT_INSN
argument_list|(
name|prev_head
argument_list|)
expr_stmt|;
name|tail
operator|=
name|last_scheduled_insn
expr_stmt|;
comment|/* Restore-other-notes: NOTE_LIST is the end of a chain of notes      previously found among the insns.  Insert them at the beginning      of the insns.  */
if|if
condition|(
name|note_list
operator|!=
literal|0
condition|)
block|{
name|basic_block
name|head_bb
init|=
name|BLOCK_FOR_INSN
argument_list|(
name|head
argument_list|)
decl_stmt|;
name|rtx
name|note_head
init|=
name|note_list
decl_stmt|;
while|while
condition|(
name|PREV_INSN
argument_list|(
name|note_head
argument_list|)
condition|)
block|{
name|set_block_for_insn
argument_list|(
name|note_head
argument_list|,
name|head_bb
argument_list|)
expr_stmt|;
name|note_head
operator|=
name|PREV_INSN
argument_list|(
name|note_head
argument_list|)
expr_stmt|;
block|}
comment|/* In the above cycle we've missed this note:  */
name|set_block_for_insn
argument_list|(
name|note_head
argument_list|,
name|head_bb
argument_list|)
expr_stmt|;
name|PREV_INSN
argument_list|(
name|note_head
argument_list|)
operator|=
name|PREV_INSN
argument_list|(
name|head
argument_list|)
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|PREV_INSN
argument_list|(
name|head
argument_list|)
argument_list|)
operator|=
name|note_head
expr_stmt|;
name|PREV_INSN
argument_list|(
name|head
argument_list|)
operator|=
name|note_list
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|note_list
argument_list|)
operator|=
name|head
expr_stmt|;
name|head
operator|=
name|note_head
expr_stmt|;
block|}
comment|/* Debugging.  */
if|if
condition|(
name|sched_verbose
condition|)
block|{
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|";;   total time = %d\n;;   new head = %d\n"
argument_list|,
name|clock_var
argument_list|,
name|INSN_UID
argument_list|(
name|head
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|";;   new tail = %d\n\n"
argument_list|,
name|INSN_UID
argument_list|(
name|tail
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|current_sched_info
operator|->
name|head
operator|=
name|head
expr_stmt|;
name|current_sched_info
operator|->
name|tail
operator|=
name|tail
expr_stmt|;
name|free
argument_list|(
name|ready
operator|.
name|vec
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ready_try
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|rgn_n_insns
condition|;
name|i
operator|++
control|)
name|free
argument_list|(
name|choice_stack
index|[
name|i
index|]
operator|.
name|state
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|choice_stack
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Set_priorities: compute priority of each insn in the block.  */
end_comment

begin_function
name|int
name|set_priorities
parameter_list|(
name|rtx
name|head
parameter_list|,
name|rtx
name|tail
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
name|int
name|n_insn
decl_stmt|;
name|int
name|sched_max_insns_priority
init|=
name|current_sched_info
operator|->
name|sched_max_insns_priority
decl_stmt|;
name|rtx
name|prev_head
decl_stmt|;
if|if
condition|(
name|head
operator|==
name|tail
operator|&&
operator|(
operator|!
name|INSN_P
argument_list|(
name|head
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
name|n_insn
operator|=
literal|0
expr_stmt|;
name|prev_head
operator|=
name|PREV_INSN
argument_list|(
name|head
argument_list|)
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|tail
init|;
name|insn
operator|!=
name|prev_head
condition|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
continue|continue;
name|n_insn
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|priority
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|INSN_PRIORITY_KNOWN
argument_list|(
name|insn
argument_list|)
condition|)
name|sched_max_insns_priority
operator|=
name|MAX
argument_list|(
name|sched_max_insns_priority
argument_list|,
name|INSN_PRIORITY
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|current_sched_info
operator|->
name|sched_max_insns_priority
operator|=
name|sched_max_insns_priority
expr_stmt|;
return|return
name|n_insn
return|;
block|}
end_function

begin_comment
comment|/* Next LUID to assign to an instruction.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|luid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initialize some global state for the scheduler.  */
end_comment

begin_function
name|void
name|sched_init
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|b
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Switch to working copy of sched_info.  */
name|memcpy
argument_list|(
operator|&
name|current_sched_info_var
argument_list|,
name|current_sched_info
argument_list|,
sizeof|sizeof
argument_list|(
name|current_sched_info_var
argument_list|)
argument_list|)
expr_stmt|;
name|current_sched_info
operator|=
operator|&
name|current_sched_info_var
expr_stmt|;
comment|/* Disable speculative loads in their presence if cc0 defined.  */
ifdef|#
directive|ifdef
name|HAVE_cc0
name|flag_schedule_speculative_load
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* Set dump and sched_verbose for the desired debugging output.  If no      dump-file was specified, but -fsched-verbose=N (any N), print to stderr.      For -fsched-verbose=N, N>=10, print everything to stderr.  */
name|sched_verbose
operator|=
name|sched_verbose_param
expr_stmt|;
if|if
condition|(
name|sched_verbose_param
operator|==
literal|0
operator|&&
name|dump_file
condition|)
name|sched_verbose
operator|=
literal|1
expr_stmt|;
name|sched_dump
operator|=
operator|(
operator|(
name|sched_verbose_param
operator|>=
literal|10
operator|||
operator|!
name|dump_file
operator|)
condition|?
name|stderr
else|:
name|dump_file
operator|)
expr_stmt|;
comment|/* Initialize SPEC_INFO.  */
if|if
condition|(
name|targetm
operator|.
name|sched
operator|.
name|set_sched_flags
condition|)
block|{
name|spec_info
operator|=
operator|&
name|spec_info_var
expr_stmt|;
name|targetm
operator|.
name|sched
operator|.
name|set_sched_flags
argument_list|(
name|spec_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_sched_info
operator|->
name|flags
operator|&
name|DO_SPECULATION
condition|)
name|spec_info
operator|->
name|weakness_cutoff
operator|=
operator|(
name|PARAM_VALUE
argument_list|(
name|PARAM_SCHED_SPEC_PROB_CUTOFF
argument_list|)
operator|*
name|MAX_DEP_WEAK
operator|)
operator|/
literal|100
expr_stmt|;
else|else
comment|/* So we won't read anything accidentally.  */
name|spec_info
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
name|check_sched_flags
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
else|else
comment|/* So we won't read anything accidentally.  */
name|spec_info
operator|=
literal|0
expr_stmt|;
comment|/* Initialize issue_rate.  */
if|if
condition|(
name|targetm
operator|.
name|sched
operator|.
name|issue_rate
condition|)
name|issue_rate
operator|=
name|targetm
operator|.
name|sched
operator|.
name|issue_rate
argument_list|()
expr_stmt|;
else|else
name|issue_rate
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|cached_issue_rate
operator|!=
name|issue_rate
condition|)
block|{
name|cached_issue_rate
operator|=
name|issue_rate
expr_stmt|;
comment|/* To invalidate max_lookahead_tries:  */
name|cached_first_cycle_multipass_dfa_lookahead
operator|=
literal|0
expr_stmt|;
block|}
name|old_max_uid
operator|=
literal|0
expr_stmt|;
name|h_i_d
operator|=
literal|0
expr_stmt|;
name|extend_h_i_d
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|old_max_uid
condition|;
name|i
operator|++
control|)
block|{
name|h_i_d
index|[
name|i
index|]
operator|.
name|cost
operator|=
operator|-
literal|1
expr_stmt|;
name|h_i_d
index|[
name|i
index|]
operator|.
name|todo_spec
operator|=
name|HARD_DEP
expr_stmt|;
name|h_i_d
index|[
name|i
index|]
operator|.
name|queue_index
operator|=
name|QUEUE_NOWHERE
expr_stmt|;
name|h_i_d
index|[
name|i
index|]
operator|.
name|tick
operator|=
name|INVALID_TICK
expr_stmt|;
name|h_i_d
index|[
name|i
index|]
operator|.
name|inter_tick
operator|=
name|INVALID_TICK
expr_stmt|;
block|}
if|if
condition|(
name|targetm
operator|.
name|sched
operator|.
name|init_dfa_pre_cycle_insn
condition|)
name|targetm
operator|.
name|sched
operator|.
name|init_dfa_pre_cycle_insn
argument_list|()
expr_stmt|;
if|if
condition|(
name|targetm
operator|.
name|sched
operator|.
name|init_dfa_post_cycle_insn
condition|)
name|targetm
operator|.
name|sched
operator|.
name|init_dfa_post_cycle_insn
argument_list|()
expr_stmt|;
name|dfa_start
argument_list|()
expr_stmt|;
name|dfa_state_size
operator|=
name|state_size
argument_list|()
expr_stmt|;
name|curr_state
operator|=
name|xmalloc
argument_list|(
name|dfa_state_size
argument_list|)
expr_stmt|;
name|h_i_d
index|[
literal|0
index|]
operator|.
name|luid
operator|=
literal|0
expr_stmt|;
name|luid
operator|=
literal|1
expr_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|b
argument_list|)
for|for
control|(
name|insn
operator|=
name|BB_HEAD
argument_list|(
name|b
argument_list|)
init|;
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|INSN_LUID
argument_list|(
name|insn
argument_list|)
operator|=
name|luid
expr_stmt|;
comment|/* Increment the next luid, unless this is a note.  We don't 	   really need separate IDs for notes and we don't want to 	   schedule differently depending on whether or not there are 	   line-number notes, i.e., depending on whether or not we're 	   generating debugging information.  */
if|if
condition|(
operator|!
name|NOTE_P
argument_list|(
name|insn
argument_list|)
condition|)
operator|++
name|luid
expr_stmt|;
if|if
condition|(
name|insn
operator|==
name|BB_END
argument_list|(
name|b
argument_list|)
condition|)
break|break;
block|}
name|init_dependency_caches
argument_list|(
name|luid
argument_list|)
expr_stmt|;
name|init_alias_analysis
argument_list|()
expr_stmt|;
name|line_note_head
operator|=
literal|0
expr_stmt|;
name|old_last_basic_block
operator|=
literal|0
expr_stmt|;
name|glat_start
operator|=
literal|0
expr_stmt|;
name|glat_end
operator|=
literal|0
expr_stmt|;
name|extend_bb
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_sched_info
operator|->
name|flags
operator|&
name|USE_GLAT
condition|)
name|init_glat
argument_list|()
expr_stmt|;
comment|/* Compute INSN_REG_WEIGHT for all blocks.  We must do this before      removing death notes.  */
name|FOR_EACH_BB_REVERSE
argument_list|(
argument|b
argument_list|)
name|find_insn_reg_weight
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|targetm
operator|.
name|sched
operator|.
name|md_init_global
condition|)
name|targetm
operator|.
name|sched
operator|.
name|md_init_global
argument_list|(
name|sched_dump
argument_list|,
name|sched_verbose
argument_list|,
name|old_max_uid
argument_list|)
expr_stmt|;
name|nr_begin_data
operator|=
name|nr_begin_control
operator|=
name|nr_be_in_data
operator|=
name|nr_be_in_control
operator|=
literal|0
expr_stmt|;
name|before_recovery
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
comment|/* This is used preferably for finding bugs in check_cfg () itself.  */
name|check_cfg
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Free global data used during insn scheduling.  */
end_comment

begin_function
name|void
name|sched_finish
parameter_list|(
name|void
parameter_list|)
block|{
name|free
argument_list|(
name|h_i_d
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|curr_state
argument_list|)
expr_stmt|;
name|dfa_finish
argument_list|()
expr_stmt|;
name|free_dependency_caches
argument_list|()
expr_stmt|;
name|end_alias_analysis
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|line_note_head
argument_list|)
expr_stmt|;
name|free_glat
argument_list|()
expr_stmt|;
if|if
condition|(
name|targetm
operator|.
name|sched
operator|.
name|md_finish_global
condition|)
name|targetm
operator|.
name|sched
operator|.
name|md_finish_global
argument_list|(
name|sched_dump
argument_list|,
name|sched_verbose
argument_list|)
expr_stmt|;
if|if
condition|(
name|spec_info
operator|&&
name|spec_info
operator|->
name|dump
condition|)
block|{
name|char
name|c
init|=
name|reload_completed
condition|?
literal|'a'
else|:
literal|'b'
decl_stmt|;
name|fprintf
argument_list|(
name|spec_info
operator|->
name|dump
argument_list|,
literal|";; %s:\n"
argument_list|,
name|current_function_name
argument_list|()
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|spec_info
operator|->
name|dump
argument_list|,
literal|";; Procedure %cr-begin-data-spec motions == %d\n"
argument_list|,
name|c
argument_list|,
name|nr_begin_data
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|spec_info
operator|->
name|dump
argument_list|,
literal|";; Procedure %cr-be-in-data-spec motions == %d\n"
argument_list|,
name|c
argument_list|,
name|nr_be_in_data
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|spec_info
operator|->
name|dump
argument_list|,
literal|";; Procedure %cr-begin-control-spec motions == %d\n"
argument_list|,
name|c
argument_list|,
name|nr_begin_control
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|spec_info
operator|->
name|dump
argument_list|,
literal|";; Procedure %cr-be-in-control-spec motions == %d\n"
argument_list|,
name|c
argument_list|,
name|nr_be_in_control
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
comment|/* After reload ia64 backend clobbers CFG, so can't check anything.  */
if|if
condition|(
operator|!
name|reload_completed
condition|)
name|check_cfg
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|current_sched_info
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Fix INSN_TICKs of the instructions in the current block as well as    INSN_TICKs of their dependents.    HEAD and TAIL are the begin and the end of the current scheduled block.  */
end_comment

begin_function
specifier|static
name|void
name|fix_inter_tick
parameter_list|(
name|rtx
name|head
parameter_list|,
name|rtx
name|tail
parameter_list|)
block|{
comment|/* Set of instructions with corrected INSN_TICK.  */
name|bitmap_head
name|processed
decl_stmt|;
name|int
name|next_clock
init|=
name|clock_var
operator|+
literal|1
decl_stmt|;
name|bitmap_initialize
argument_list|(
operator|&
name|processed
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Iterates over scheduled instructions and fix their INSN_TICKs and      INSN_TICKs of dependent instructions, so that INSN_TICKs are consistent      across different blocks.  */
for|for
control|(
name|tail
operator|=
name|NEXT_INSN
argument_list|(
name|tail
argument_list|)
init|;
name|head
operator|!=
name|tail
condition|;
name|head
operator|=
name|NEXT_INSN
argument_list|(
name|head
argument_list|)
control|)
block|{
if|if
condition|(
name|INSN_P
argument_list|(
name|head
argument_list|)
condition|)
block|{
name|int
name|tick
decl_stmt|;
name|rtx
name|link
decl_stmt|;
name|tick
operator|=
name|INSN_TICK
argument_list|(
name|head
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|tick
operator|>=
name|MIN_TICK
argument_list|)
expr_stmt|;
comment|/* Fix INSN_TICK of instruction from just scheduled block.  */
if|if
condition|(
operator|!
name|bitmap_bit_p
argument_list|(
operator|&
name|processed
argument_list|,
name|INSN_LUID
argument_list|(
name|head
argument_list|)
argument_list|)
condition|)
block|{
name|bitmap_set_bit
argument_list|(
operator|&
name|processed
argument_list|,
name|INSN_LUID
argument_list|(
name|head
argument_list|)
argument_list|)
expr_stmt|;
name|tick
operator|-=
name|next_clock
expr_stmt|;
if|if
condition|(
name|tick
operator|<
name|MIN_TICK
condition|)
name|tick
operator|=
name|MIN_TICK
expr_stmt|;
name|INSN_TICK
argument_list|(
name|head
argument_list|)
operator|=
name|tick
expr_stmt|;
block|}
for|for
control|(
name|link
operator|=
name|INSN_DEPEND
argument_list|(
name|head
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|rtx
name|next
decl_stmt|;
name|next
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tick
operator|=
name|INSN_TICK
argument_list|(
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|tick
operator|!=
name|INVALID_TICK
comment|/* If NEXT has its INSN_TICK calculated, fix it. 		     If not - it will be properly calculated from 		     scratch later in fix_tick_ready.  */
operator|&&
operator|!
name|bitmap_bit_p
argument_list|(
operator|&
name|processed
argument_list|,
name|INSN_LUID
argument_list|(
name|next
argument_list|)
argument_list|)
condition|)
block|{
name|bitmap_set_bit
argument_list|(
operator|&
name|processed
argument_list|,
name|INSN_LUID
argument_list|(
name|next
argument_list|)
argument_list|)
expr_stmt|;
name|tick
operator|-=
name|next_clock
expr_stmt|;
if|if
condition|(
name|tick
operator|<
name|MIN_TICK
condition|)
name|tick
operator|=
name|MIN_TICK
expr_stmt|;
if|if
condition|(
name|tick
operator|>
name|INTER_TICK
argument_list|(
name|next
argument_list|)
condition|)
name|INTER_TICK
argument_list|(
name|next
argument_list|)
operator|=
name|tick
expr_stmt|;
else|else
name|tick
operator|=
name|INTER_TICK
argument_list|(
name|next
argument_list|)
expr_stmt|;
name|INSN_TICK
argument_list|(
name|next
argument_list|)
operator|=
name|tick
expr_stmt|;
block|}
block|}
block|}
block|}
name|bitmap_clear
argument_list|(
operator|&
name|processed
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Check if NEXT is ready to be added to the ready or queue list.    If "yes", add it to the proper list.    Returns:       -1 - is not ready yet,        0 - added to the ready list,    0< N - queued for N cycles.  */
end_comment

begin_function
name|int
name|try_ready
parameter_list|(
name|rtx
name|next
parameter_list|)
block|{
name|ds_t
name|old_ts
decl_stmt|,
modifier|*
name|ts
decl_stmt|;
name|rtx
name|link
decl_stmt|;
name|ts
operator|=
operator|&
name|TODO_SPEC
argument_list|(
name|next
argument_list|)
expr_stmt|;
name|old_ts
operator|=
operator|*
name|ts
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
operator|(
name|old_ts
operator|&
operator|~
operator|(
name|SPECULATIVE
operator||
name|HARD_DEP
operator|)
operator|)
operator|&&
operator|(
operator|(
name|old_ts
operator|&
name|HARD_DEP
operator|)
operator|||
operator|(
name|old_ts
operator|&
name|SPECULATIVE
operator|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|current_sched_info
operator|->
name|flags
operator|&
name|DO_SPECULATION
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|LOG_LINKS
argument_list|(
name|next
argument_list|)
condition|)
operator|*
name|ts
operator|&=
operator|~
name|HARD_DEP
expr_stmt|;
block|}
else|else
block|{
operator|*
name|ts
operator|&=
operator|~
name|SPECULATIVE
operator|&
operator|~
name|HARD_DEP
expr_stmt|;
name|link
operator|=
name|LOG_LINKS
argument_list|(
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|link
condition|)
block|{
comment|/* LOG_LINKS are maintained sorted.               So if DEP_STATUS of the first dep is SPECULATIVE,              than all other deps are speculative too.  */
if|if
condition|(
name|DEP_STATUS
argument_list|(
name|link
argument_list|)
operator|&
name|SPECULATIVE
condition|)
block|{
comment|/* Now we've got NEXT with speculative deps only.                  1. Look at the deps to see what we have to do.                  2. Check if we can do 'todo'.  */
operator|*
name|ts
operator|=
name|DEP_STATUS
argument_list|(
name|link
argument_list|)
operator|&
name|SPECULATIVE
expr_stmt|;
while|while
condition|(
operator|(
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
operator|*
name|ts
operator|=
name|ds_merge
argument_list|(
operator|*
name|ts
argument_list|,
name|DEP_STATUS
argument_list|(
name|link
argument_list|)
operator|&
name|SPECULATIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|dep_weak
argument_list|(
operator|*
name|ts
argument_list|)
operator|<
name|spec_info
operator|->
name|weakness_cutoff
condition|)
comment|/* Too few points.  */
operator|*
name|ts
operator|=
operator|(
operator|*
name|ts
operator|&
operator|~
name|SPECULATIVE
operator|)
operator||
name|HARD_DEP
expr_stmt|;
block|}
else|else
operator|*
name|ts
operator||=
name|HARD_DEP
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|*
name|ts
operator|&
name|HARD_DEP
condition|)
name|gcc_assert
argument_list|(
operator|*
name|ts
operator|==
name|old_ts
operator|&&
name|QUEUE_INDEX
argument_list|(
name|next
argument_list|)
operator|==
name|QUEUE_NOWHERE
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|current_sched_info
operator|->
name|new_ready
condition|)
operator|*
name|ts
operator|=
name|current_sched_info
operator|->
name|new_ready
argument_list|(
name|next
argument_list|,
operator|*
name|ts
argument_list|)
expr_stmt|;
comment|/* * if !(old_ts& SPECULATIVE) (e.g. HARD_DEP or 0), then insn might       have its original pattern or changed (speculative) one.  This is due      to changing ebb in region scheduling.      * But if (old_ts& SPECULATIVE), then we are pretty sure that insn      has speculative pattern.            We can't assert (!(*ts& HARD_DEP) || *ts == old_ts) here because      control-speculative NEXT could have been discarded by sched-rgn.c      (the same case as when discarded by can_schedule_ready_p ()).  */
if|if
condition|(
operator|(
operator|*
name|ts
operator|&
name|SPECULATIVE
operator|)
comment|/* If (old_ts == *ts), then (old_ts& SPECULATIVE) and we don't  	 need to change anything.  */
operator|&&
operator|*
name|ts
operator|!=
name|old_ts
condition|)
block|{
name|int
name|res
decl_stmt|;
name|rtx
name|new_pat
decl_stmt|;
name|gcc_assert
argument_list|(
operator|(
operator|*
name|ts
operator|&
name|SPECULATIVE
operator|)
operator|&&
operator|!
operator|(
operator|*
name|ts
operator|&
operator|~
name|SPECULATIVE
operator|)
argument_list|)
expr_stmt|;
name|res
operator|=
name|speculate_insn
argument_list|(
name|next
argument_list|,
operator|*
name|ts
argument_list|,
operator|&
name|new_pat
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|res
condition|)
block|{
case|case
operator|-
literal|1
case|:
comment|/* It would be nice to change DEP_STATUS of all dependences, 	     which have ((DEP_STATUS& SPECULATIVE) == *ts) to HARD_DEP, 	     so we won't reanalyze anything.  */
operator|*
name|ts
operator|=
operator|(
operator|*
name|ts
operator|&
operator|~
name|SPECULATIVE
operator|)
operator||
name|HARD_DEP
expr_stmt|;
break|break;
case|case
literal|0
case|:
comment|/* We follow the rule, that every speculative insn 	     has non-null ORIG_PAT.  */
if|if
condition|(
operator|!
name|ORIG_PAT
argument_list|(
name|next
argument_list|)
condition|)
name|ORIG_PAT
argument_list|(
name|next
argument_list|)
operator|=
name|PATTERN
argument_list|(
name|next
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
if|if
condition|(
operator|!
name|ORIG_PAT
argument_list|(
name|next
argument_list|)
condition|)
comment|/* If we gonna to overwrite the original pattern of insn, 	       save it.  */
name|ORIG_PAT
argument_list|(
name|next
argument_list|)
operator|=
name|PATTERN
argument_list|(
name|next
argument_list|)
expr_stmt|;
name|change_pattern
argument_list|(
name|next
argument_list|,
name|new_pat
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* We need to restore pattern only if (*ts == 0), because otherwise it is      either correct (*ts& SPECULATIVE),      or we simply don't care (*ts& HARD_DEP).  */
name|gcc_assert
argument_list|(
operator|!
name|ORIG_PAT
argument_list|(
name|next
argument_list|)
operator|||
operator|!
name|IS_SPECULATION_BRANCHY_CHECK_P
argument_list|(
name|next
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ts
operator|&
name|HARD_DEP
condition|)
block|{
comment|/* We can't assert (QUEUE_INDEX (next) == QUEUE_NOWHERE) here because 	 control-speculative NEXT could have been discarded by sched-rgn.c 	 (the same case as when discarded by can_schedule_ready_p ()).  */
comment|/*gcc_assert (QUEUE_INDEX (next) == QUEUE_NOWHERE);*/
name|change_queue_index
argument_list|(
name|next
argument_list|,
name|QUEUE_NOWHERE
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
operator|*
name|ts
operator|&
name|BEGIN_SPEC
operator|)
operator|&&
name|ORIG_PAT
argument_list|(
name|next
argument_list|)
operator|&&
operator|!
name|IS_SPECULATION_CHECK_P
argument_list|(
name|next
argument_list|)
condition|)
comment|/* We should change pattern of every previously speculative         instruction - and we determine if NEXT was speculative by using        ORIG_PAT field.  Except one case - speculation checks have ORIG_PAT        pat too, so skip them.  */
block|{
name|change_pattern
argument_list|(
name|next
argument_list|,
name|ORIG_PAT
argument_list|(
name|next
argument_list|)
argument_list|)
expr_stmt|;
name|ORIG_PAT
argument_list|(
name|next
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|sched_verbose
operator|>=
literal|2
condition|)
block|{
name|int
name|s
init|=
name|TODO_SPEC
argument_list|(
name|next
argument_list|)
decl_stmt|;
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|";;\t\tdependencies resolved: insn %s"
argument_list|,
call|(
modifier|*
name|current_sched_info
operator|->
name|print_insn
call|)
argument_list|(
name|next
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|spec_info
operator|&&
name|spec_info
operator|->
name|dump
condition|)
block|{
if|if
condition|(
name|s
operator|&
name|BEGIN_DATA
condition|)
name|fprintf
argument_list|(
name|spec_info
operator|->
name|dump
argument_list|,
literal|"; data-spec;"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|&
name|BEGIN_CONTROL
condition|)
name|fprintf
argument_list|(
name|spec_info
operator|->
name|dump
argument_list|,
literal|"; control-spec;"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|&
name|BE_IN_CONTROL
condition|)
name|fprintf
argument_list|(
name|spec_info
operator|->
name|dump
argument_list|,
literal|"; in-control-spec;"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|adjust_priority
argument_list|(
name|next
argument_list|)
expr_stmt|;
return|return
name|fix_tick_ready
argument_list|(
name|next
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Calculate INSN_TICK of NEXT and add it to either ready or queue list.  */
end_comment

begin_function
specifier|static
name|int
name|fix_tick_ready
parameter_list|(
name|rtx
name|next
parameter_list|)
block|{
name|rtx
name|link
decl_stmt|;
name|int
name|tick
decl_stmt|,
name|delay
decl_stmt|;
name|link
operator|=
name|RESOLVED_DEPS
argument_list|(
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|link
condition|)
block|{
name|int
name|full_p
decl_stmt|;
name|tick
operator|=
name|INSN_TICK
argument_list|(
name|next
argument_list|)
expr_stmt|;
comment|/* if tick is not equal to INVALID_TICK, then update 	 INSN_TICK of NEXT with the most recent resolved dependence 	 cost.  Otherwise, recalculate from scratch.  */
name|full_p
operator|=
name|tick
operator|==
name|INVALID_TICK
expr_stmt|;
do|do
block|{
name|rtx
name|pro
decl_stmt|;
name|int
name|tick1
decl_stmt|;
name|pro
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|INSN_TICK
argument_list|(
name|pro
argument_list|)
operator|>=
name|MIN_TICK
argument_list|)
expr_stmt|;
name|tick1
operator|=
name|INSN_TICK
argument_list|(
name|pro
argument_list|)
operator|+
name|insn_cost
argument_list|(
name|pro
argument_list|,
name|link
argument_list|,
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|tick1
operator|>
name|tick
condition|)
name|tick
operator|=
name|tick1
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
operator|)
operator|&&
name|full_p
condition|)
do|;
block|}
else|else
name|tick
operator|=
operator|-
literal|1
expr_stmt|;
name|INSN_TICK
argument_list|(
name|next
argument_list|)
operator|=
name|tick
expr_stmt|;
name|delay
operator|=
name|tick
operator|-
name|clock_var
expr_stmt|;
if|if
condition|(
name|delay
operator|<=
literal|0
condition|)
name|delay
operator|=
name|QUEUE_READY
expr_stmt|;
name|change_queue_index
argument_list|(
name|next
argument_list|,
name|delay
argument_list|)
expr_stmt|;
return|return
name|delay
return|;
block|}
end_function

begin_comment
comment|/* Move NEXT to the proper queue list with (DELAY>= 1),    or add it to the ready list (DELAY == QUEUE_READY),    or remove it from ready and queue lists at all (DELAY == QUEUE_NOWHERE).  */
end_comment

begin_function
specifier|static
name|void
name|change_queue_index
parameter_list|(
name|rtx
name|next
parameter_list|,
name|int
name|delay
parameter_list|)
block|{
name|int
name|i
init|=
name|QUEUE_INDEX
argument_list|(
name|next
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
name|QUEUE_NOWHERE
operator|<=
name|delay
operator|&&
name|delay
operator|<=
name|max_insn_queue_index
operator|&&
name|delay
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|i
operator|!=
name|QUEUE_SCHEDULED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|delay
operator|>
literal|0
operator|&&
name|NEXT_Q_AFTER
argument_list|(
name|q_ptr
argument_list|,
name|delay
argument_list|)
operator|==
name|i
operator|)
operator|||
operator|(
name|delay
operator|<
literal|0
operator|&&
name|delay
operator|==
name|i
operator|)
condition|)
comment|/* We have nothing to do.  */
return|return;
comment|/* Remove NEXT from wherever it is now.  */
if|if
condition|(
name|i
operator|==
name|QUEUE_READY
condition|)
name|ready_remove_insn
argument_list|(
name|next
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
name|queue_remove
argument_list|(
name|next
argument_list|)
expr_stmt|;
comment|/* Add it to the proper place.  */
if|if
condition|(
name|delay
operator|==
name|QUEUE_READY
condition|)
name|ready_add
argument_list|(
name|readyp
argument_list|,
name|next
argument_list|,
name|false
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|delay
operator|>=
literal|1
condition|)
name|queue_insn
argument_list|(
name|next
argument_list|,
name|delay
argument_list|)
expr_stmt|;
if|if
condition|(
name|sched_verbose
operator|>=
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|";;\t\ttick updated: insn %s"
argument_list|,
call|(
modifier|*
name|current_sched_info
operator|->
name|print_insn
call|)
argument_list|(
name|next
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|delay
operator|==
name|QUEUE_READY
condition|)
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|" into ready\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|delay
operator|>=
literal|1
condition|)
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|" into queue with cost=%d\n"
argument_list|,
name|delay
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|" removed from ready or queue lists\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* INSN is being scheduled.  Resolve the dependence between INSN and NEXT.  */
end_comment

begin_function
specifier|static
name|void
name|resolve_dep
parameter_list|(
name|rtx
name|next
parameter_list|,
name|rtx
name|insn
parameter_list|)
block|{
name|rtx
name|dep
decl_stmt|;
name|INSN_DEP_COUNT
argument_list|(
name|next
argument_list|)
operator|--
expr_stmt|;
name|dep
operator|=
name|remove_list_elem
argument_list|(
name|insn
argument_list|,
operator|&
name|LOG_LINKS
argument_list|(
name|next
argument_list|)
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|dep
argument_list|,
literal|1
argument_list|)
operator|=
name|RESOLVED_DEPS
argument_list|(
name|next
argument_list|)
expr_stmt|;
name|RESOLVED_DEPS
argument_list|(
name|next
argument_list|)
operator|=
name|dep
expr_stmt|;
name|gcc_assert
argument_list|(
operator|(
name|INSN_DEP_COUNT
argument_list|(
name|next
argument_list|)
operator|!=
literal|0
operator|||
operator|!
name|LOG_LINKS
argument_list|(
name|next
argument_list|)
operator|)
operator|&&
operator|(
name|LOG_LINKS
argument_list|(
name|next
argument_list|)
operator|||
name|INSN_DEP_COUNT
argument_list|(
name|next
argument_list|)
operator|==
literal|0
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Extend H_I_D data.  */
end_comment

begin_function
specifier|static
name|void
name|extend_h_i_d
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* We use LUID 0 for the fake insn (UID 0) which holds dependencies for      pseudos which do not cross calls.  */
name|int
name|new_max_uid
init|=
name|get_max_uid
argument_list|()
operator|+
literal|1
decl_stmt|;
name|h_i_d
operator|=
name|xrecalloc
argument_list|(
name|h_i_d
argument_list|,
name|new_max_uid
argument_list|,
name|old_max_uid
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|h_i_d
argument_list|)
argument_list|)
expr_stmt|;
name|old_max_uid
operator|=
name|new_max_uid
expr_stmt|;
if|if
condition|(
name|targetm
operator|.
name|sched
operator|.
name|h_i_d_extended
condition|)
name|targetm
operator|.
name|sched
operator|.
name|h_i_d_extended
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Extend READY, READY_TRY and CHOICE_STACK arrays.    N_NEW_INSNS is the number of additional elements to allocate.  */
end_comment

begin_function
specifier|static
name|void
name|extend_ready
parameter_list|(
name|int
name|n_new_insns
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|readyp
operator|->
name|veclen
operator|=
name|rgn_n_insns
operator|+
name|n_new_insns
operator|+
literal|1
operator|+
name|issue_rate
expr_stmt|;
name|readyp
operator|->
name|vec
operator|=
name|XRESIZEVEC
argument_list|(
name|rtx
argument_list|,
name|readyp
operator|->
name|vec
argument_list|,
name|readyp
operator|->
name|veclen
argument_list|)
expr_stmt|;
name|ready_try
operator|=
name|xrecalloc
argument_list|(
name|ready_try
argument_list|,
name|rgn_n_insns
operator|+
name|n_new_insns
operator|+
literal|1
argument_list|,
name|rgn_n_insns
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
name|rgn_n_insns
operator|+=
name|n_new_insns
expr_stmt|;
name|choice_stack
operator|=
name|XRESIZEVEC
argument_list|(
expr|struct
name|choice_entry
argument_list|,
name|choice_stack
argument_list|,
name|rgn_n_insns
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|rgn_n_insns
init|;
name|n_new_insns
operator|--
condition|;
name|i
operator|--
control|)
name|choice_stack
index|[
name|i
index|]
operator|.
name|state
operator|=
name|xmalloc
argument_list|(
name|dfa_state_size
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Extend global scheduler structures (those, that live across calls to    schedule_block) to include information about just emitted INSN.  */
end_comment

begin_function
specifier|static
name|void
name|extend_global
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* These structures have scheduler scope.  */
name|extend_h_i_d
argument_list|()
expr_stmt|;
name|init_h_i_d
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|extend_dependency_caches
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Extends global and local scheduler structures to include information    about just emitted INSN.  */
end_comment

begin_function
specifier|static
name|void
name|extend_all
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|extend_global
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* These structures have block scope.  */
name|extend_ready
argument_list|(
literal|1
argument_list|)
expr_stmt|;
call|(
modifier|*
name|current_sched_info
operator|->
name|add_remove_insn
call|)
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize h_i_d entry of the new INSN with default values.    Values, that are not explicitly initialized here, hold zero.  */
end_comment

begin_function
specifier|static
name|void
name|init_h_i_d
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|INSN_LUID
argument_list|(
name|insn
argument_list|)
operator|=
name|luid
operator|++
expr_stmt|;
name|INSN_COST
argument_list|(
name|insn
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
name|TODO_SPEC
argument_list|(
name|insn
argument_list|)
operator|=
name|HARD_DEP
expr_stmt|;
name|QUEUE_INDEX
argument_list|(
name|insn
argument_list|)
operator|=
name|QUEUE_NOWHERE
expr_stmt|;
name|INSN_TICK
argument_list|(
name|insn
argument_list|)
operator|=
name|INVALID_TICK
expr_stmt|;
name|INTER_TICK
argument_list|(
name|insn
argument_list|)
operator|=
name|INVALID_TICK
expr_stmt|;
name|find_insn_reg_weight1
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generates recovery code for INSN.  */
end_comment

begin_function
specifier|static
name|void
name|generate_recovery_code
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
if|if
condition|(
name|TODO_SPEC
argument_list|(
name|insn
argument_list|)
operator|&
name|BEGIN_SPEC
condition|)
name|begin_speculative_block
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Here we have insn with no dependencies to      instructions other then CHECK_SPEC ones.  */
if|if
condition|(
name|TODO_SPEC
argument_list|(
name|insn
argument_list|)
operator|&
name|BE_IN_SPEC
condition|)
name|add_to_speculative_block
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Helper function.    Tries to add speculative dependencies of type FS between instructions    in LINK list and TWIN.  */
end_comment

begin_function
specifier|static
name|void
name|process_insn_depend_be_in_spec
parameter_list|(
name|rtx
name|link
parameter_list|,
name|rtx
name|twin
parameter_list|,
name|ds_t
name|fs
parameter_list|)
block|{
for|for
control|(
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|ds_t
name|ds
decl_stmt|;
name|rtx
name|consumer
decl_stmt|;
name|consumer
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ds
operator|=
name|DEP_STATUS
argument_list|(
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
comment|/* If we want to create speculative dep.  */
name|fs
comment|/* And we can do that because this is a true dep.  */
operator|&&
operator|(
name|ds
operator|&
name|DEP_TYPES
operator|)
operator|==
name|DEP_TRUE
condition|)
block|{
name|gcc_assert
argument_list|(
operator|!
operator|(
name|ds
operator|&
name|BE_IN_SPEC
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
comment|/* If this dep can be overcome with 'begin speculation'.  */
name|ds
operator|&
name|BEGIN_SPEC
condition|)
comment|/* Then we have a choice: keep the dep 'begin speculative' 	       or transform it into 'be in speculative'.  */
block|{
if|if
condition|(
comment|/* In try_ready we assert that if insn once became ready 		     it can be removed from the ready (or queue) list only 		     due to backend decision.  Hence we can't let the 		     probability of the speculative dep to decrease.  */
name|dep_weak
argument_list|(
name|ds
argument_list|)
operator|<=
name|dep_weak
argument_list|(
name|fs
argument_list|)
condition|)
comment|/* Transform it to be in speculative.  */
name|ds
operator|=
operator|(
name|ds
operator|&
operator|~
name|BEGIN_SPEC
operator|)
operator||
name|fs
expr_stmt|;
block|}
else|else
comment|/* Mark the dep as 'be in speculative'.  */
name|ds
operator||=
name|fs
expr_stmt|;
block|}
name|add_back_forw_dep
argument_list|(
name|consumer
argument_list|,
name|twin
argument_list|,
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
argument_list|,
name|ds
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Generates recovery code for BEGIN speculative INSN.  */
end_comment

begin_function
specifier|static
name|void
name|begin_speculative_block
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
if|if
condition|(
name|TODO_SPEC
argument_list|(
name|insn
argument_list|)
operator|&
name|BEGIN_DATA
condition|)
name|nr_begin_data
operator|++
expr_stmt|;
if|if
condition|(
name|TODO_SPEC
argument_list|(
name|insn
argument_list|)
operator|&
name|BEGIN_CONTROL
condition|)
name|nr_begin_control
operator|++
expr_stmt|;
name|create_check_block_twin
argument_list|(
name|insn
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|TODO_SPEC
argument_list|(
name|insn
argument_list|)
operator|&=
operator|~
name|BEGIN_SPEC
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generates recovery code for BE_IN speculative INSN.  */
end_comment

begin_function
specifier|static
name|void
name|add_to_speculative_block
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|ds_t
name|ts
decl_stmt|;
name|rtx
name|link
decl_stmt|,
name|twins
init|=
name|NULL
decl_stmt|;
name|ts
operator|=
name|TODO_SPEC
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
operator|(
name|ts
operator|&
operator|~
name|BE_IN_SPEC
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ts
operator|&
name|BE_IN_DATA
condition|)
name|nr_be_in_data
operator|++
expr_stmt|;
if|if
condition|(
name|ts
operator|&
name|BE_IN_CONTROL
condition|)
name|nr_be_in_control
operator|++
expr_stmt|;
name|TODO_SPEC
argument_list|(
name|insn
argument_list|)
operator|&=
operator|~
name|BE_IN_SPEC
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|TODO_SPEC
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|DONE_SPEC
argument_list|(
name|insn
argument_list|)
operator||=
name|ts
expr_stmt|;
comment|/* First we convert all simple checks to branchy.  */
for|for
control|(
name|link
operator|=
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
control|)
block|{
name|rtx
name|check
decl_stmt|;
name|check
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_SPECULATION_SIMPLE_CHECK_P
argument_list|(
name|check
argument_list|)
condition|)
block|{
name|create_check_block_twin
argument_list|(
name|check
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|link
operator|=
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
else|else
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|clear_priorities
argument_list|(
name|insn
argument_list|)
expr_stmt|;
do|do
block|{
name|rtx
name|link
decl_stmt|,
name|check
decl_stmt|,
name|twin
decl_stmt|;
name|basic_block
name|rec
decl_stmt|;
name|link
operator|=
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
operator|(
name|DEP_STATUS
argument_list|(
name|link
argument_list|)
operator|&
name|BEGIN_SPEC
operator|)
operator|&&
operator|(
name|DEP_STATUS
argument_list|(
name|link
argument_list|)
operator|&
name|BE_IN_SPEC
operator|)
operator|&&
operator|(
name|DEP_STATUS
argument_list|(
name|link
argument_list|)
operator|&
name|DEP_TYPES
operator|)
operator|==
name|DEP_TRUE
argument_list|)
expr_stmt|;
name|check
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|IS_SPECULATION_CHECK_P
argument_list|(
name|check
argument_list|)
operator|&&
operator|!
name|ORIG_PAT
argument_list|(
name|check
argument_list|)
operator|&&
name|QUEUE_INDEX
argument_list|(
name|check
argument_list|)
operator|==
name|QUEUE_NOWHERE
argument_list|)
expr_stmt|;
name|rec
operator|=
name|BLOCK_FOR_INSN
argument_list|(
name|check
argument_list|)
expr_stmt|;
name|twin
operator|=
name|emit_insn_before
argument_list|(
name|copy_rtx
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|,
name|BB_END
argument_list|(
name|rec
argument_list|)
argument_list|)
expr_stmt|;
name|extend_global
argument_list|(
name|twin
argument_list|)
expr_stmt|;
name|RESOLVED_DEPS
argument_list|(
name|twin
argument_list|)
operator|=
name|copy_DEPS_LIST_list
argument_list|(
name|RESOLVED_DEPS
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sched_verbose
operator|&&
name|spec_info
operator|->
name|dump
condition|)
comment|/* INSN_BB (insn) isn't determined for twin insns yet.            So we can't use current_sched_info->print_insn.  */
name|fprintf
argument_list|(
name|spec_info
operator|->
name|dump
argument_list|,
literal|";;\t\tGenerated twin insn : %d/rec%d\n"
argument_list|,
name|INSN_UID
argument_list|(
name|twin
argument_list|)
argument_list|,
name|rec
operator|->
name|index
argument_list|)
expr_stmt|;
name|twins
operator|=
name|alloc_INSN_LIST
argument_list|(
name|twin
argument_list|,
name|twins
argument_list|)
expr_stmt|;
comment|/* Add dependences between TWIN and all appropriate 	 instructions from REC.  */
do|do
block|{
name|add_back_forw_dep
argument_list|(
name|twin
argument_list|,
name|check
argument_list|,
name|REG_DEP_TRUE
argument_list|,
name|DEP_TRUE
argument_list|)
expr_stmt|;
do|do
block|{
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|link
condition|)
block|{
name|check
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|BLOCK_FOR_INSN
argument_list|(
name|check
argument_list|)
operator|==
name|rec
condition|)
break|break;
block|}
else|else
break|break;
block|}
do|while
condition|(
literal|1
condition|)
do|;
block|}
do|while
condition|(
name|link
condition|)
do|;
name|process_insn_depend_be_in_spec
argument_list|(
name|INSN_DEPEND
argument_list|(
name|insn
argument_list|)
argument_list|,
name|twin
argument_list|,
name|ts
argument_list|)
expr_stmt|;
for|for
control|(
name|link
operator|=
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
control|)
block|{
name|check
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|BLOCK_FOR_INSN
argument_list|(
name|check
argument_list|)
operator|==
name|rec
condition|)
block|{
name|delete_back_forw_dep
argument_list|(
name|insn
argument_list|,
name|check
argument_list|)
expr_stmt|;
name|link
operator|=
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
else|else
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
condition|)
do|;
comment|/* We can't add the dependence between insn and twin earlier because      that would make twin appear in the INSN_DEPEND (insn).  */
while|while
condition|(
name|twins
condition|)
block|{
name|rtx
name|twin
decl_stmt|;
name|twin
operator|=
name|XEXP
argument_list|(
name|twins
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|calc_priorities
argument_list|(
name|twin
argument_list|)
expr_stmt|;
name|add_back_forw_dep
argument_list|(
name|twin
argument_list|,
name|insn
argument_list|,
name|REG_DEP_OUTPUT
argument_list|,
name|DEP_OUTPUT
argument_list|)
expr_stmt|;
name|twin
operator|=
name|XEXP
argument_list|(
name|twins
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|free_INSN_LIST_node
argument_list|(
name|twins
argument_list|)
expr_stmt|;
name|twins
operator|=
name|twin
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Extends and fills with zeros (only the new part) array pointed to by P.  */
end_comment

begin_function
name|void
modifier|*
name|xrecalloc
parameter_list|(
name|void
modifier|*
name|p
parameter_list|,
name|size_t
name|new_nmemb
parameter_list|,
name|size_t
name|old_nmemb
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|new_nmemb
operator|>=
name|old_nmemb
argument_list|)
expr_stmt|;
name|p
operator|=
name|XRESIZEVAR
argument_list|(
name|void
argument_list|,
name|p
argument_list|,
name|new_nmemb
operator|*
name|size
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
operator|(
name|char
operator|*
operator|)
name|p
operator|)
operator|+
name|old_nmemb
operator|*
name|size
argument_list|,
literal|0
argument_list|,
operator|(
name|new_nmemb
operator|-
name|old_nmemb
operator|)
operator|*
name|size
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* Return the probability of speculation success for the speculation    status DS.  */
end_comment

begin_function
specifier|static
name|dw_t
name|dep_weak
parameter_list|(
name|ds_t
name|ds
parameter_list|)
block|{
name|ds_t
name|res
init|=
literal|1
decl_stmt|,
name|dt
decl_stmt|;
name|int
name|n
init|=
literal|0
decl_stmt|;
name|dt
operator|=
name|FIRST_SPEC_TYPE
expr_stmt|;
do|do
block|{
if|if
condition|(
name|ds
operator|&
name|dt
condition|)
block|{
name|res
operator|*=
operator|(
name|ds_t
operator|)
name|get_dep_weak
argument_list|(
name|ds
argument_list|,
name|dt
argument_list|)
expr_stmt|;
name|n
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|dt
operator|==
name|LAST_SPEC_TYPE
condition|)
break|break;
name|dt
operator|<<=
name|SPEC_TYPE_SHIFT
expr_stmt|;
block|}
do|while
condition|(
literal|1
condition|)
do|;
name|gcc_assert
argument_list|(
name|n
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|n
condition|)
name|res
operator|/=
name|MAX_DEP_WEAK
expr_stmt|;
if|if
condition|(
name|res
operator|<
name|MIN_DEP_WEAK
condition|)
name|res
operator|=
name|MIN_DEP_WEAK
expr_stmt|;
name|gcc_assert
argument_list|(
name|res
operator|<=
name|MAX_DEP_WEAK
argument_list|)
expr_stmt|;
return|return
operator|(
name|dw_t
operator|)
name|res
return|;
block|}
end_function

begin_comment
comment|/* Helper function.    Find fallthru edge from PRED.  */
end_comment

begin_function
specifier|static
name|edge
name|find_fallthru_edge
parameter_list|(
name|basic_block
name|pred
parameter_list|)
block|{
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|basic_block
name|succ
decl_stmt|;
name|succ
operator|=
name|pred
operator|->
name|next_bb
expr_stmt|;
name|gcc_assert
argument_list|(
name|succ
operator|->
name|prev_bb
operator|==
name|pred
argument_list|)
expr_stmt|;
if|if
condition|(
name|EDGE_COUNT
argument_list|(
name|pred
operator|->
name|succs
argument_list|)
operator|<=
name|EDGE_COUNT
argument_list|(
name|succ
operator|->
name|preds
argument_list|)
condition|)
block|{
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|pred->succs
argument_list|)
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
condition|)
block|{
name|gcc_assert
argument_list|(
name|e
operator|->
name|dest
operator|==
name|succ
argument_list|)
expr_stmt|;
return|return
name|e
return|;
block|}
block|}
else|else
block|{
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|succ->preds
argument_list|)
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
condition|)
block|{
name|gcc_assert
argument_list|(
name|e
operator|->
name|src
operator|==
name|pred
argument_list|)
expr_stmt|;
return|return
name|e
return|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Initialize BEFORE_RECOVERY variable.  */
end_comment

begin_function
specifier|static
name|void
name|init_before_recovery
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|last
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|last
operator|=
name|EXIT_BLOCK_PTR
operator|->
name|prev_bb
expr_stmt|;
name|e
operator|=
name|find_fallthru_edge
argument_list|(
name|last
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
condition|)
block|{
comment|/* We create two basic blocks:           1. Single instruction block is inserted right after E->SRC          and has jump to           2. Empty block right before EXIT_BLOCK.          Between these two blocks recovery blocks will be emitted.  */
name|basic_block
name|single
decl_stmt|,
name|empty
decl_stmt|;
name|rtx
name|x
decl_stmt|,
name|label
decl_stmt|;
name|single
operator|=
name|create_empty_bb
argument_list|(
name|last
argument_list|)
expr_stmt|;
name|empty
operator|=
name|create_empty_bb
argument_list|(
name|single
argument_list|)
expr_stmt|;
name|single
operator|->
name|count
operator|=
name|last
operator|->
name|count
expr_stmt|;
name|empty
operator|->
name|count
operator|=
name|last
operator|->
name|count
expr_stmt|;
name|single
operator|->
name|frequency
operator|=
name|last
operator|->
name|frequency
expr_stmt|;
name|empty
operator|->
name|frequency
operator|=
name|last
operator|->
name|frequency
expr_stmt|;
name|BB_COPY_PARTITION
argument_list|(
name|single
argument_list|,
name|last
argument_list|)
expr_stmt|;
name|BB_COPY_PARTITION
argument_list|(
name|empty
argument_list|,
name|last
argument_list|)
expr_stmt|;
name|redirect_edge_succ
argument_list|(
name|e
argument_list|,
name|single
argument_list|)
expr_stmt|;
name|make_single_succ_edge
argument_list|(
name|single
argument_list|,
name|empty
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|make_single_succ_edge
argument_list|(
name|empty
argument_list|,
name|EXIT_BLOCK_PTR
argument_list|,
name|EDGE_FALLTHRU
operator||
name|EDGE_CAN_FALLTHRU
argument_list|)
expr_stmt|;
name|label
operator|=
name|block_label
argument_list|(
name|empty
argument_list|)
expr_stmt|;
name|x
operator|=
name|emit_jump_insn_after
argument_list|(
name|gen_jump
argument_list|(
name|label
argument_list|)
argument_list|,
name|BB_END
argument_list|(
name|single
argument_list|)
argument_list|)
expr_stmt|;
name|JUMP_LABEL
argument_list|(
name|x
argument_list|)
operator|=
name|label
expr_stmt|;
name|LABEL_NUSES
argument_list|(
name|label
argument_list|)
operator|++
expr_stmt|;
name|extend_global
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|emit_barrier_after
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|add_block
argument_list|(
name|empty
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_block
argument_list|(
name|single
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|before_recovery
operator|=
name|single
expr_stmt|;
if|if
condition|(
name|sched_verbose
operator|>=
literal|2
operator|&&
name|spec_info
operator|->
name|dump
condition|)
name|fprintf
argument_list|(
name|spec_info
operator|->
name|dump
argument_list|,
literal|";;\t\tFixed fallthru to EXIT : %d->>%d->%d->>EXIT\n"
argument_list|,
name|last
operator|->
name|index
argument_list|,
name|single
operator|->
name|index
argument_list|,
name|empty
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
else|else
name|before_recovery
operator|=
name|last
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns new recovery block.  */
end_comment

begin_function
specifier|static
name|basic_block
name|create_recovery_block
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|label
decl_stmt|;
name|rtx
name|barrier
decl_stmt|;
name|basic_block
name|rec
decl_stmt|;
name|added_recovery_block_p
operator|=
name|true
expr_stmt|;
if|if
condition|(
operator|!
name|before_recovery
condition|)
name|init_before_recovery
argument_list|()
expr_stmt|;
name|barrier
operator|=
name|get_last_bb_insn
argument_list|(
name|before_recovery
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|BARRIER_P
argument_list|(
name|barrier
argument_list|)
argument_list|)
expr_stmt|;
name|label
operator|=
name|emit_label_after
argument_list|(
name|gen_label_rtx
argument_list|()
argument_list|,
name|barrier
argument_list|)
expr_stmt|;
name|rec
operator|=
name|create_basic_block
argument_list|(
name|label
argument_list|,
name|label
argument_list|,
name|before_recovery
argument_list|)
expr_stmt|;
comment|/* Recovery block always end with an unconditional jump.  */
name|emit_barrier_after
argument_list|(
name|BB_END
argument_list|(
name|rec
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|BB_PARTITION
argument_list|(
name|before_recovery
argument_list|)
operator|!=
name|BB_UNPARTITIONED
condition|)
name|BB_SET_PARTITION
argument_list|(
name|rec
argument_list|,
name|BB_COLD_PARTITION
argument_list|)
expr_stmt|;
if|if
condition|(
name|sched_verbose
operator|&&
name|spec_info
operator|->
name|dump
condition|)
name|fprintf
argument_list|(
name|spec_info
operator|->
name|dump
argument_list|,
literal|";;\t\tGenerated recovery block rec%d\n"
argument_list|,
name|rec
operator|->
name|index
argument_list|)
expr_stmt|;
name|before_recovery
operator|=
name|rec
expr_stmt|;
return|return
name|rec
return|;
block|}
end_function

begin_comment
comment|/* This function creates recovery code for INSN.  If MUTATE_P is nonzero,    INSN is a simple check, that should be converted to branchy one.  */
end_comment

begin_function
specifier|static
name|void
name|create_check_block_twin
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|bool
name|mutate_p
parameter_list|)
block|{
name|basic_block
name|rec
decl_stmt|;
name|rtx
name|label
decl_stmt|,
name|check
decl_stmt|,
name|twin
decl_stmt|,
name|link
decl_stmt|;
name|ds_t
name|fs
decl_stmt|;
name|gcc_assert
argument_list|(
name|ORIG_PAT
argument_list|(
name|insn
argument_list|)
operator|&&
operator|(
operator|!
name|mutate_p
operator|||
operator|(
name|IS_SPECULATION_SIMPLE_CHECK_P
argument_list|(
name|insn
argument_list|)
operator|&&
operator|!
operator|(
name|TODO_SPEC
argument_list|(
name|insn
argument_list|)
operator|&
name|SPECULATIVE
operator|)
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* Create recovery block.  */
if|if
condition|(
name|mutate_p
operator|||
name|targetm
operator|.
name|sched
operator|.
name|needs_block_p
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|rec
operator|=
name|create_recovery_block
argument_list|()
expr_stmt|;
name|label
operator|=
name|BB_HEAD
argument_list|(
name|rec
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rec
operator|=
name|EXIT_BLOCK_PTR
expr_stmt|;
name|label
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Emit CHECK.  */
name|check
operator|=
name|targetm
operator|.
name|sched
operator|.
name|gen_check
argument_list|(
name|insn
argument_list|,
name|label
argument_list|,
name|mutate_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|rec
operator|!=
name|EXIT_BLOCK_PTR
condition|)
block|{
comment|/* To have mem_reg alive at the beginning of second_bb, 	 we emit check BEFORE insn, so insn after splitting  	 insn will be at the beginning of second_bb, which will 	 provide us with the correct life information.  */
name|check
operator|=
name|emit_jump_insn_before
argument_list|(
name|check
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|JUMP_LABEL
argument_list|(
name|check
argument_list|)
operator|=
name|label
expr_stmt|;
name|LABEL_NUSES
argument_list|(
name|label
argument_list|)
operator|++
expr_stmt|;
block|}
else|else
name|check
operator|=
name|emit_insn_before
argument_list|(
name|check
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* Extend data structures.  */
name|extend_all
argument_list|(
name|check
argument_list|)
expr_stmt|;
name|RECOVERY_BLOCK
argument_list|(
name|check
argument_list|)
operator|=
name|rec
expr_stmt|;
if|if
condition|(
name|sched_verbose
operator|&&
name|spec_info
operator|->
name|dump
condition|)
name|fprintf
argument_list|(
name|spec_info
operator|->
name|dump
argument_list|,
literal|";;\t\tGenerated check insn : %s\n"
argument_list|,
call|(
modifier|*
name|current_sched_info
operator|->
name|print_insn
call|)
argument_list|(
name|check
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|ORIG_PAT
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Initialize TWIN (twin is a duplicate of original instruction      in the recovery block).  */
if|if
condition|(
name|rec
operator|!=
name|EXIT_BLOCK_PTR
condition|)
block|{
name|rtx
name|link
decl_stmt|;
for|for
control|(
name|link
operator|=
name|RESOLVED_DEPS
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|DEP_STATUS
argument_list|(
name|link
argument_list|)
operator|&
name|DEP_OUTPUT
condition|)
block|{
name|RESOLVED_DEPS
argument_list|(
name|check
argument_list|)
operator|=
name|alloc_DEPS_LIST
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|,
name|RESOLVED_DEPS
argument_list|(
name|check
argument_list|)
argument_list|,
name|DEP_TRUE
argument_list|)
expr_stmt|;
name|PUT_REG_NOTE_KIND
argument_list|(
name|RESOLVED_DEPS
argument_list|(
name|check
argument_list|)
argument_list|,
name|REG_DEP_TRUE
argument_list|)
expr_stmt|;
block|}
name|twin
operator|=
name|emit_insn_after
argument_list|(
name|ORIG_PAT
argument_list|(
name|insn
argument_list|)
argument_list|,
name|BB_END
argument_list|(
name|rec
argument_list|)
argument_list|)
expr_stmt|;
name|extend_global
argument_list|(
name|twin
argument_list|)
expr_stmt|;
if|if
condition|(
name|sched_verbose
operator|&&
name|spec_info
operator|->
name|dump
condition|)
comment|/* INSN_BB (insn) isn't determined for twin insns yet. 	   So we can't use current_sched_info->print_insn.  */
name|fprintf
argument_list|(
name|spec_info
operator|->
name|dump
argument_list|,
literal|";;\t\tGenerated twin insn : %d/rec%d\n"
argument_list|,
name|INSN_UID
argument_list|(
name|twin
argument_list|)
argument_list|,
name|rec
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ORIG_PAT
argument_list|(
name|check
argument_list|)
operator|=
name|ORIG_PAT
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|HAS_INTERNAL_DEP
argument_list|(
name|check
argument_list|)
operator|=
literal|1
expr_stmt|;
name|twin
operator|=
name|check
expr_stmt|;
comment|/* ??? We probably should change all OUTPUT dependencies to 	 (TRUE | OUTPUT).  */
block|}
name|RESOLVED_DEPS
argument_list|(
name|twin
argument_list|)
operator|=
name|copy_DEPS_LIST_list
argument_list|(
name|RESOLVED_DEPS
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rec
operator|!=
name|EXIT_BLOCK_PTR
condition|)
comment|/* In case of branchy check, fix CFG.  */
block|{
name|basic_block
name|first_bb
decl_stmt|,
name|second_bb
decl_stmt|;
name|rtx
name|jump
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|int
name|edge_flags
decl_stmt|;
name|first_bb
operator|=
name|BLOCK_FOR_INSN
argument_list|(
name|check
argument_list|)
expr_stmt|;
name|e
operator|=
name|split_block
argument_list|(
name|first_bb
argument_list|,
name|check
argument_list|)
expr_stmt|;
comment|/* split_block emits note if *check == BB_END.  Probably it  	 is better to rip that note off.  */
name|gcc_assert
argument_list|(
name|e
operator|->
name|src
operator|==
name|first_bb
argument_list|)
expr_stmt|;
name|second_bb
operator|=
name|e
operator|->
name|dest
expr_stmt|;
comment|/* This is fixing of incoming edge.  */
comment|/* ??? Which other flags should be specified?  */
if|if
condition|(
name|BB_PARTITION
argument_list|(
name|first_bb
argument_list|)
operator|!=
name|BB_PARTITION
argument_list|(
name|rec
argument_list|)
condition|)
comment|/* Partition type is the same, if it is "unpartitioned".  */
name|edge_flags
operator|=
name|EDGE_CROSSING
expr_stmt|;
else|else
name|edge_flags
operator|=
literal|0
expr_stmt|;
name|e
operator|=
name|make_edge
argument_list|(
name|first_bb
argument_list|,
name|rec
argument_list|,
name|edge_flags
argument_list|)
expr_stmt|;
name|add_block
argument_list|(
name|second_bb
argument_list|,
name|first_bb
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|NOTE_INSN_BASIC_BLOCK_P
argument_list|(
name|BB_HEAD
argument_list|(
name|second_bb
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|label
operator|=
name|block_label
argument_list|(
name|second_bb
argument_list|)
expr_stmt|;
name|jump
operator|=
name|emit_jump_insn_after
argument_list|(
name|gen_jump
argument_list|(
name|label
argument_list|)
argument_list|,
name|BB_END
argument_list|(
name|rec
argument_list|)
argument_list|)
expr_stmt|;
name|JUMP_LABEL
argument_list|(
name|jump
argument_list|)
operator|=
name|label
expr_stmt|;
name|LABEL_NUSES
argument_list|(
name|label
argument_list|)
operator|++
expr_stmt|;
name|extend_global
argument_list|(
name|jump
argument_list|)
expr_stmt|;
if|if
condition|(
name|BB_PARTITION
argument_list|(
name|second_bb
argument_list|)
operator|!=
name|BB_PARTITION
argument_list|(
name|rec
argument_list|)
condition|)
comment|/* Partition type is the same, if it is "unpartitioned".  */
block|{
comment|/* Rewritten from cfgrtl.c.  */
if|if
condition|(
name|flag_reorder_blocks_and_partition
operator|&&
name|targetm
operator|.
name|have_named_sections
comment|/*&& !any_condjump_p (jump)*/
condition|)
comment|/* any_condjump_p (jump) == false. 	       We don't need the same note for the check because 	       any_condjump_p (check) == true.  */
block|{
name|REG_NOTES
argument_list|(
name|jump
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_CROSSING_JUMP
argument_list|,
name|NULL_RTX
argument_list|,
name|REG_NOTES
argument_list|(
name|jump
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|edge_flags
operator|=
name|EDGE_CROSSING
expr_stmt|;
block|}
else|else
name|edge_flags
operator|=
literal|0
expr_stmt|;
name|make_single_succ_edge
argument_list|(
name|rec
argument_list|,
name|second_bb
argument_list|,
name|edge_flags
argument_list|)
expr_stmt|;
name|add_block
argument_list|(
name|rec
argument_list|,
name|EXIT_BLOCK_PTR
argument_list|)
expr_stmt|;
block|}
comment|/* Move backward dependences from INSN to CHECK and       move forward dependences from INSN to TWIN.  */
for|for
control|(
name|link
operator|=
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|ds_t
name|ds
decl_stmt|;
comment|/* If BEGIN_DATA: [insn ~~TRUE~~> producer]: 	 check --TRUE--> producer  ??? or ANTI ??? 	 twin  --TRUE--> producer 	 twin  --ANTI--> check 	  	 If BEGIN_CONTROL: [insn ~~ANTI~~> producer]: 	 check --ANTI--> producer 	 twin  --ANTI--> producer 	 twin  --ANTI--> check  	 If BE_IN_SPEC: [insn ~~TRUE~~> producer]: 	 check ~~TRUE~~> producer 	 twin  ~~TRUE~~> producer 	 twin  --ANTI--> check  */
name|ds
operator|=
name|DEP_STATUS
argument_list|(
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|&
name|BEGIN_SPEC
condition|)
block|{
name|gcc_assert
argument_list|(
operator|!
name|mutate_p
argument_list|)
expr_stmt|;
name|ds
operator|&=
operator|~
name|BEGIN_SPEC
expr_stmt|;
block|}
if|if
condition|(
name|rec
operator|!=
name|EXIT_BLOCK_PTR
condition|)
block|{
name|add_back_forw_dep
argument_list|(
name|check
argument_list|,
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|,
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
argument_list|,
name|ds
argument_list|)
expr_stmt|;
name|add_back_forw_dep
argument_list|(
name|twin
argument_list|,
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|,
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
argument_list|,
name|ds
argument_list|)
expr_stmt|;
block|}
else|else
name|add_back_forw_dep
argument_list|(
name|check
argument_list|,
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|,
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
argument_list|,
name|ds
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|link
operator|=
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
control|)
if|if
condition|(
operator|(
name|DEP_STATUS
argument_list|(
name|link
argument_list|)
operator|&
name|BEGIN_SPEC
operator|)
operator|||
name|mutate_p
condition|)
comment|/* We can delete this dep only if we totally overcome it with 	 BEGIN_SPECULATION.  */
block|{
name|delete_back_forw_dep
argument_list|(
name|insn
argument_list|,
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|link
operator|=
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
else|else
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fs
operator|=
literal|0
expr_stmt|;
comment|/* Fields (DONE_SPEC (x)& BEGIN_SPEC) and CHECK_SPEC (x) are set only      here.  */
name|gcc_assert
argument_list|(
operator|!
name|DONE_SPEC
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mutate_p
condition|)
block|{
name|ds_t
name|ts
init|=
name|TODO_SPEC
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|DONE_SPEC
argument_list|(
name|insn
argument_list|)
operator|=
name|ts
operator|&
name|BEGIN_SPEC
expr_stmt|;
name|CHECK_SPEC
argument_list|(
name|check
argument_list|)
operator|=
name|ts
operator|&
name|BEGIN_SPEC
expr_stmt|;
if|if
condition|(
name|ts
operator|&
name|BEGIN_DATA
condition|)
name|fs
operator|=
name|set_dep_weak
argument_list|(
name|fs
argument_list|,
name|BE_IN_DATA
argument_list|,
name|get_dep_weak
argument_list|(
name|ts
argument_list|,
name|BEGIN_DATA
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ts
operator|&
name|BEGIN_CONTROL
condition|)
name|fs
operator|=
name|set_dep_weak
argument_list|(
name|fs
argument_list|,
name|BE_IN_CONTROL
argument_list|,
name|get_dep_weak
argument_list|(
name|ts
argument_list|,
name|BEGIN_CONTROL
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|CHECK_SPEC
argument_list|(
name|check
argument_list|)
operator|=
name|CHECK_SPEC
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Future speculations: call the helper.  */
name|process_insn_depend_be_in_spec
argument_list|(
name|INSN_DEPEND
argument_list|(
name|insn
argument_list|)
argument_list|,
name|twin
argument_list|,
name|fs
argument_list|)
expr_stmt|;
if|if
condition|(
name|rec
operator|!=
name|EXIT_BLOCK_PTR
condition|)
block|{
comment|/* Which types of dependencies should we use here is, 	 generally, machine-dependent question...  But, for now, 	 it is not.  */
if|if
condition|(
operator|!
name|mutate_p
condition|)
block|{
name|add_back_forw_dep
argument_list|(
name|check
argument_list|,
name|insn
argument_list|,
name|REG_DEP_TRUE
argument_list|,
name|DEP_TRUE
argument_list|)
expr_stmt|;
name|add_back_forw_dep
argument_list|(
name|twin
argument_list|,
name|insn
argument_list|,
name|REG_DEP_OUTPUT
argument_list|,
name|DEP_OUTPUT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|spec_info
operator|->
name|dump
condition|)
name|fprintf
argument_list|(
name|spec_info
operator|->
name|dump
argument_list|,
literal|";;\t\tRemoved simple check : %s\n"
argument_list|,
call|(
modifier|*
name|current_sched_info
operator|->
name|print_insn
call|)
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|link
operator|=
name|INSN_DEPEND
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|INSN_DEPEND
argument_list|(
name|insn
argument_list|)
control|)
name|delete_back_forw_dep
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|QUEUE_INDEX
argument_list|(
name|insn
argument_list|)
operator|!=
name|QUEUE_NOWHERE
condition|)
name|try_ready
argument_list|(
name|check
argument_list|)
expr_stmt|;
name|sched_remove_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
name|add_back_forw_dep
argument_list|(
name|twin
argument_list|,
name|check
argument_list|,
name|REG_DEP_ANTI
argument_list|,
name|DEP_ANTI
argument_list|)
expr_stmt|;
block|}
else|else
name|add_back_forw_dep
argument_list|(
name|check
argument_list|,
name|insn
argument_list|,
name|REG_DEP_TRUE
argument_list|,
name|DEP_TRUE
operator||
name|DEP_OUTPUT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mutate_p
condition|)
comment|/* Fix priorities.  If MUTATE_P is nonzero, this is not necessary,        because it'll be done later in add_to_speculative_block.  */
block|{
name|clear_priorities
argument_list|(
name|twin
argument_list|)
expr_stmt|;
name|calc_priorities
argument_list|(
name|twin
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Removes dependency between instructions in the recovery block REC    and usual region instructions.  It keeps inner dependences so it    won't be necessary to recompute them.  */
end_comment

begin_function
specifier|static
name|void
name|fix_recovery_deps
parameter_list|(
name|basic_block
name|rec
parameter_list|)
block|{
name|rtx
name|note
decl_stmt|,
name|insn
decl_stmt|,
name|link
decl_stmt|,
name|jump
decl_stmt|,
name|ready_list
init|=
literal|0
decl_stmt|;
name|bitmap_head
name|in_ready
decl_stmt|;
name|bitmap_initialize
argument_list|(
operator|&
name|in_ready
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* NOTE - a basic block note.  */
name|note
operator|=
name|NEXT_INSN
argument_list|(
name|BB_HEAD
argument_list|(
name|rec
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|NOTE_INSN_BASIC_BLOCK_P
argument_list|(
name|note
argument_list|)
argument_list|)
expr_stmt|;
name|insn
operator|=
name|BB_END
argument_list|(
name|rec
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|JUMP_P
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
do|do
block|{
for|for
control|(
name|link
operator|=
name|INSN_DEPEND
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
control|)
block|{
name|rtx
name|consumer
decl_stmt|;
name|consumer
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|BLOCK_FOR_INSN
argument_list|(
name|consumer
argument_list|)
operator|!=
name|rec
condition|)
block|{
name|delete_back_forw_dep
argument_list|(
name|consumer
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bitmap_bit_p
argument_list|(
operator|&
name|in_ready
argument_list|,
name|INSN_LUID
argument_list|(
name|consumer
argument_list|)
argument_list|)
condition|)
block|{
name|ready_list
operator|=
name|alloc_INSN_LIST
argument_list|(
name|consumer
argument_list|,
name|ready_list
argument_list|)
expr_stmt|;
name|bitmap_set_bit
argument_list|(
operator|&
name|in_ready
argument_list|,
name|INSN_LUID
argument_list|(
name|consumer
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|link
operator|=
name|INSN_DEPEND
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gcc_assert
argument_list|(
operator|(
name|DEP_STATUS
argument_list|(
name|link
argument_list|)
operator|&
name|DEP_TYPES
operator|)
operator|==
name|DEP_TRUE
argument_list|)
expr_stmt|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|insn
operator|!=
name|note
condition|)
do|;
name|bitmap_clear
argument_list|(
operator|&
name|in_ready
argument_list|)
expr_stmt|;
comment|/* Try to add instructions to the ready or queue list.  */
for|for
control|(
name|link
operator|=
name|ready_list
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
name|try_ready
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|free_INSN_LIST_list
argument_list|(
operator|&
name|ready_list
argument_list|)
expr_stmt|;
comment|/* Fixing jump's dependences.  */
name|insn
operator|=
name|BB_HEAD
argument_list|(
name|rec
argument_list|)
expr_stmt|;
name|jump
operator|=
name|BB_END
argument_list|(
name|rec
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|LABEL_P
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|NOTE_INSN_BASIC_BLOCK_P
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|add_jump_dependencies
argument_list|(
name|insn
argument_list|,
name|jump
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The function saves line notes at the beginning of block B.  */
end_comment

begin_function
specifier|static
name|void
name|associate_line_notes_with_blocks
parameter_list|(
name|basic_block
name|b
parameter_list|)
block|{
name|rtx
name|line
decl_stmt|;
for|for
control|(
name|line
operator|=
name|BB_HEAD
argument_list|(
name|b
argument_list|)
init|;
name|line
condition|;
name|line
operator|=
name|PREV_INSN
argument_list|(
name|line
argument_list|)
control|)
if|if
condition|(
name|NOTE_P
argument_list|(
name|line
argument_list|)
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|line
argument_list|)
operator|>
literal|0
condition|)
block|{
name|line_note_head
index|[
name|b
operator|->
name|index
index|]
operator|=
name|line
expr_stmt|;
break|break;
block|}
comment|/* Do a forward search as well, since we won't get to see the first      notes in a basic block.  */
for|for
control|(
name|line
operator|=
name|BB_HEAD
argument_list|(
name|b
argument_list|)
init|;
name|line
condition|;
name|line
operator|=
name|NEXT_INSN
argument_list|(
name|line
argument_list|)
control|)
block|{
if|if
condition|(
name|INSN_P
argument_list|(
name|line
argument_list|)
condition|)
break|break;
if|if
condition|(
name|NOTE_P
argument_list|(
name|line
argument_list|)
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|line
argument_list|)
operator|>
literal|0
condition|)
name|line_note_head
index|[
name|b
operator|->
name|index
index|]
operator|=
name|line
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Changes pattern of the INSN to NEW_PAT.  */
end_comment

begin_function
specifier|static
name|void
name|change_pattern
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|rtx
name|new_pat
parameter_list|)
block|{
name|int
name|t
decl_stmt|;
name|t
operator|=
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|new_pat
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Invalidate INSN_COST, so it'll be recalculated.  */
name|INSN_COST
argument_list|(
name|insn
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Invalidate INSN_TICK, so it'll be recalculated.  */
name|INSN_TICK
argument_list|(
name|insn
argument_list|)
operator|=
name|INVALID_TICK
expr_stmt|;
name|dfa_clear_single_insn_cache
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* -1 - can't speculate,    0 - for speculation with REQUEST mode it is OK to use    current instruction pattern,    1 - need to change pattern for *NEW_PAT to be speculative.  */
end_comment

begin_function
specifier|static
name|int
name|speculate_insn
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|ds_t
name|request
parameter_list|,
name|rtx
modifier|*
name|new_pat
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|current_sched_info
operator|->
name|flags
operator|&
name|DO_SPECULATION
operator|&&
operator|(
name|request
operator|&
name|SPECULATIVE
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NONJUMP_INSN_P
argument_list|(
name|insn
argument_list|)
operator|||
name|HAS_INTERNAL_DEP
argument_list|(
name|insn
argument_list|)
operator|||
name|SCHED_GROUP_P
argument_list|(
name|insn
argument_list|)
operator|||
name|side_effects_p
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|||
operator|(
name|request
operator|&
name|spec_info
operator|->
name|mask
operator|)
operator|!=
name|request
condition|)
return|return
operator|-
literal|1
return|;
name|gcc_assert
argument_list|(
operator|!
name|IS_SPECULATION_CHECK_P
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|request
operator|&
name|BE_IN_SPEC
condition|)
block|{
if|if
condition|(
name|may_trap_p
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|!
operator|(
name|request
operator|&
name|BEGIN_SPEC
operator|)
condition|)
return|return
literal|0
return|;
block|}
return|return
name|targetm
operator|.
name|sched
operator|.
name|speculate_insn
argument_list|(
name|insn
argument_list|,
name|request
operator|&
name|BEGIN_SPEC
argument_list|,
name|new_pat
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Print some information about block BB, which starts with HEAD and    ends with TAIL, before scheduling it.    I is zero, if scheduler is about to start with the fresh ebb.  */
end_comment

begin_function
specifier|static
name|void
name|dump_new_block_header
parameter_list|(
name|int
name|i
parameter_list|,
name|basic_block
name|bb
parameter_list|,
name|rtx
name|head
parameter_list|,
name|rtx
name|tail
parameter_list|)
block|{
if|if
condition|(
operator|!
name|i
condition|)
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|";;   ======================================================\n"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|";;   =====================ADVANCING TO=====================\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|";;   -- basic block %d from %d to %d -- %s reload\n"
argument_list|,
name|bb
operator|->
name|index
argument_list|,
name|INSN_UID
argument_list|(
name|head
argument_list|)
argument_list|,
name|INSN_UID
argument_list|(
name|tail
argument_list|)
argument_list|,
operator|(
name|reload_completed
condition|?
literal|"after"
else|:
literal|"before"
operator|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|";;   ======================================================\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|sched_dump
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Unlink basic block notes and labels and saves them, so they    can be easily restored.  We unlink basic block notes in EBB to    provide back-compatibility with the previous code, as target backends    assume, that there'll be only instructions between    current_sched_info->{head and tail}.  We restore these notes as soon    as we can.    FIRST (LAST) is the first (last) basic block in the ebb.    NB: In usual case (FIRST == LAST) nothing is really done.  */
end_comment

begin_function
name|void
name|unlink_bb_notes
parameter_list|(
name|basic_block
name|first
parameter_list|,
name|basic_block
name|last
parameter_list|)
block|{
comment|/* We DON'T unlink basic block notes of the first block in the ebb.  */
if|if
condition|(
name|first
operator|==
name|last
condition|)
return|return;
name|bb_header
operator|=
name|xmalloc
argument_list|(
name|last_basic_block
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|bb_header
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make a sentinel.  */
if|if
condition|(
name|last
operator|->
name|next_bb
operator|!=
name|EXIT_BLOCK_PTR
condition|)
name|bb_header
index|[
name|last
operator|->
name|next_bb
operator|->
name|index
index|]
operator|=
literal|0
expr_stmt|;
name|first
operator|=
name|first
operator|->
name|next_bb
expr_stmt|;
do|do
block|{
name|rtx
name|prev
decl_stmt|,
name|label
decl_stmt|,
name|note
decl_stmt|,
name|next
decl_stmt|;
name|label
operator|=
name|BB_HEAD
argument_list|(
name|last
argument_list|)
expr_stmt|;
if|if
condition|(
name|LABEL_P
argument_list|(
name|label
argument_list|)
condition|)
name|note
operator|=
name|NEXT_INSN
argument_list|(
name|label
argument_list|)
expr_stmt|;
else|else
name|note
operator|=
name|label
expr_stmt|;
name|gcc_assert
argument_list|(
name|NOTE_INSN_BASIC_BLOCK_P
argument_list|(
name|note
argument_list|)
argument_list|)
expr_stmt|;
name|prev
operator|=
name|PREV_INSN
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|note
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|prev
operator|&&
name|next
argument_list|)
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|prev
argument_list|)
operator|=
name|next
expr_stmt|;
name|PREV_INSN
argument_list|(
name|next
argument_list|)
operator|=
name|prev
expr_stmt|;
name|bb_header
index|[
name|last
operator|->
name|index
index|]
operator|=
name|label
expr_stmt|;
if|if
condition|(
name|last
operator|==
name|first
condition|)
break|break;
name|last
operator|=
name|last
operator|->
name|prev_bb
expr_stmt|;
block|}
do|while
condition|(
literal|1
condition|)
do|;
block|}
end_function

begin_comment
comment|/* Restore basic block notes.    FIRST is the first basic block in the ebb.  */
end_comment

begin_function
specifier|static
name|void
name|restore_bb_notes
parameter_list|(
name|basic_block
name|first
parameter_list|)
block|{
if|if
condition|(
operator|!
name|bb_header
condition|)
return|return;
comment|/* We DON'T unlink basic block notes of the first block in the ebb.  */
name|first
operator|=
name|first
operator|->
name|next_bb
expr_stmt|;
comment|/* Remember: FIRST is actually a second basic block in the ebb.  */
while|while
condition|(
name|first
operator|!=
name|EXIT_BLOCK_PTR
operator|&&
name|bb_header
index|[
name|first
operator|->
name|index
index|]
condition|)
block|{
name|rtx
name|prev
decl_stmt|,
name|label
decl_stmt|,
name|note
decl_stmt|,
name|next
decl_stmt|;
name|label
operator|=
name|bb_header
index|[
name|first
operator|->
name|index
index|]
expr_stmt|;
name|prev
operator|=
name|PREV_INSN
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|prev
argument_list|)
expr_stmt|;
if|if
condition|(
name|LABEL_P
argument_list|(
name|label
argument_list|)
condition|)
name|note
operator|=
name|NEXT_INSN
argument_list|(
name|label
argument_list|)
expr_stmt|;
else|else
name|note
operator|=
name|label
expr_stmt|;
name|gcc_assert
argument_list|(
name|NOTE_INSN_BASIC_BLOCK_P
argument_list|(
name|note
argument_list|)
argument_list|)
expr_stmt|;
name|bb_header
index|[
name|first
operator|->
name|index
index|]
operator|=
literal|0
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|prev
argument_list|)
operator|=
name|label
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|note
argument_list|)
operator|=
name|next
expr_stmt|;
name|PREV_INSN
argument_list|(
name|next
argument_list|)
operator|=
name|note
expr_stmt|;
name|first
operator|=
name|first
operator|->
name|next_bb
expr_stmt|;
block|}
name|free
argument_list|(
name|bb_header
argument_list|)
expr_stmt|;
name|bb_header
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Extend per basic block data structures of the scheduler.    If BB is NULL, initialize structures for the whole CFG.    Otherwise, initialize them for the just created BB.  */
end_comment

begin_function
specifier|static
name|void
name|extend_bb
parameter_list|(
name|basic_block
name|bb
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
if|if
condition|(
name|write_symbols
operator|!=
name|NO_DEBUG
condition|)
block|{
comment|/* Save-line-note-head:          Determine the line-number at the start of each basic block.          This must be computed and saved now, because after a basic block's          predecessor has been scheduled, it is impossible to accurately          determine the correct line number for the first insn of the block.  */
name|line_note_head
operator|=
name|xrecalloc
argument_list|(
name|line_note_head
argument_list|,
name|last_basic_block
argument_list|,
name|old_last_basic_block
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|line_note_head
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bb
condition|)
name|associate_line_notes_with_blocks
argument_list|(
name|bb
argument_list|)
expr_stmt|;
else|else
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
name|associate_line_notes_with_blocks
argument_list|(
name|bb
argument_list|)
expr_stmt|;
block|}
name|old_last_basic_block
operator|=
name|last_basic_block
expr_stmt|;
if|if
condition|(
name|current_sched_info
operator|->
name|flags
operator|&
name|USE_GLAT
condition|)
block|{
name|glat_start
operator|=
name|xrealloc
argument_list|(
name|glat_start
argument_list|,
name|last_basic_block
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|glat_start
argument_list|)
argument_list|)
expr_stmt|;
name|glat_end
operator|=
name|xrealloc
argument_list|(
name|glat_end
argument_list|,
name|last_basic_block
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|glat_end
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* The following is done to keep current_sched_info->next_tail non null.  */
name|insn
operator|=
name|BB_END
argument_list|(
name|EXIT_BLOCK_PTR
operator|->
name|prev_bb
argument_list|)
expr_stmt|;
if|if
condition|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
operator|==
literal|0
operator|||
operator|(
operator|!
name|NOTE_P
argument_list|(
name|insn
argument_list|)
operator|&&
operator|!
name|LABEL_P
argument_list|(
name|insn
argument_list|)
comment|/* Don't emit a NOTE if it would end up before a BARRIER.  */
operator|&&
operator|!
name|BARRIER_P
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|emit_note_after
argument_list|(
name|NOTE_INSN_DELETED
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* Make insn to appear outside BB.  */
name|BB_END
argument_list|(
name|EXIT_BLOCK_PTR
operator|->
name|prev_bb
argument_list|)
operator|=
name|insn
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Add a basic block BB to extended basic block EBB.    If EBB is EXIT_BLOCK_PTR, then BB is recovery block.    If EBB is NULL, then BB should be a new region.  */
end_comment

begin_function
name|void
name|add_block
parameter_list|(
name|basic_block
name|bb
parameter_list|,
name|basic_block
name|ebb
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|current_sched_info
operator|->
name|flags
operator|&
name|DETACH_LIFE_INFO
operator|&&
name|bb
operator|->
name|il
operator|.
name|rtl
operator|->
name|global_live_at_start
operator|==
literal|0
operator|&&
name|bb
operator|->
name|il
operator|.
name|rtl
operator|->
name|global_live_at_end
operator|==
literal|0
argument_list|)
expr_stmt|;
name|extend_bb
argument_list|(
name|bb
argument_list|)
expr_stmt|;
name|glat_start
index|[
name|bb
operator|->
name|index
index|]
operator|=
literal|0
expr_stmt|;
name|glat_end
index|[
name|bb
operator|->
name|index
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|current_sched_info
operator|->
name|add_block
condition|)
comment|/* This changes only data structures of the front-end.  */
name|current_sched_info
operator|->
name|add_block
argument_list|(
name|bb
argument_list|,
name|ebb
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Helper function.    Fix CFG after both in- and inter-block movement of    control_flow_insn_p JUMP.  */
end_comment

begin_function
specifier|static
name|void
name|fix_jump_move
parameter_list|(
name|rtx
name|jump
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|,
name|jump_bb
decl_stmt|,
name|jump_bb_next
decl_stmt|;
name|bb
operator|=
name|BLOCK_FOR_INSN
argument_list|(
name|PREV_INSN
argument_list|(
name|jump
argument_list|)
argument_list|)
expr_stmt|;
name|jump_bb
operator|=
name|BLOCK_FOR_INSN
argument_list|(
name|jump
argument_list|)
expr_stmt|;
name|jump_bb_next
operator|=
name|jump_bb
operator|->
name|next_bb
expr_stmt|;
name|gcc_assert
argument_list|(
name|current_sched_info
operator|->
name|flags
operator|&
name|SCHED_EBB
operator|||
name|IS_SPECULATION_BRANCHY_CHECK_P
argument_list|(
name|jump
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NOTE_INSN_BASIC_BLOCK_P
argument_list|(
name|BB_END
argument_list|(
name|jump_bb_next
argument_list|)
argument_list|)
condition|)
comment|/* if jump_bb_next is not empty.  */
name|BB_END
argument_list|(
name|jump_bb
argument_list|)
operator|=
name|BB_END
argument_list|(
name|jump_bb_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|BB_END
argument_list|(
name|bb
argument_list|)
operator|!=
name|PREV_INSN
argument_list|(
name|jump
argument_list|)
condition|)
comment|/* Then there are instruction after jump that should be placed        to jump_bb_next.  */
name|BB_END
argument_list|(
name|jump_bb_next
argument_list|)
operator|=
name|BB_END
argument_list|(
name|bb
argument_list|)
expr_stmt|;
else|else
comment|/* Otherwise jump_bb_next is empty.  */
name|BB_END
argument_list|(
name|jump_bb_next
argument_list|)
operator|=
name|NEXT_INSN
argument_list|(
name|BB_HEAD
argument_list|(
name|jump_bb_next
argument_list|)
argument_list|)
expr_stmt|;
comment|/* To make assertion in move_insn happy.  */
name|BB_END
argument_list|(
name|bb
argument_list|)
operator|=
name|PREV_INSN
argument_list|(
name|jump
argument_list|)
expr_stmt|;
name|update_bb_for_insn
argument_list|(
name|jump_bb_next
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Fix CFG after interblock movement of control_flow_insn_p JUMP.  */
end_comment

begin_function
specifier|static
name|void
name|move_block_after_check
parameter_list|(
name|rtx
name|jump
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|,
name|jump_bb
decl_stmt|,
name|jump_bb_next
decl_stmt|;
name|VEC
argument_list|(
name|edge
argument_list|,
name|gc
argument_list|)
operator|*
name|t
expr_stmt|;
name|bb
operator|=
name|BLOCK_FOR_INSN
argument_list|(
name|PREV_INSN
argument_list|(
name|jump
argument_list|)
argument_list|)
expr_stmt|;
name|jump_bb
operator|=
name|BLOCK_FOR_INSN
argument_list|(
name|jump
argument_list|)
expr_stmt|;
name|jump_bb_next
operator|=
name|jump_bb
operator|->
name|next_bb
expr_stmt|;
name|update_bb_for_insn
argument_list|(
name|jump_bb
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|IS_SPECULATION_CHECK_P
argument_list|(
name|jump
argument_list|)
operator|||
name|IS_SPECULATION_CHECK_P
argument_list|(
name|BB_END
argument_list|(
name|jump_bb_next
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|unlink_block
argument_list|(
name|jump_bb_next
argument_list|)
expr_stmt|;
name|link_block
argument_list|(
name|jump_bb_next
argument_list|,
name|bb
argument_list|)
expr_stmt|;
name|t
operator|=
name|bb
operator|->
name|succs
expr_stmt|;
name|bb
operator|->
name|succs
operator|=
literal|0
expr_stmt|;
name|move_succs
argument_list|(
operator|&
operator|(
name|jump_bb
operator|->
name|succs
operator|)
argument_list|,
name|bb
argument_list|)
expr_stmt|;
name|move_succs
argument_list|(
operator|&
operator|(
name|jump_bb_next
operator|->
name|succs
operator|)
argument_list|,
name|jump_bb
argument_list|)
expr_stmt|;
name|move_succs
argument_list|(
operator|&
name|t
argument_list|,
name|jump_bb_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_sched_info
operator|->
name|fix_recovery_cfg
condition|)
name|current_sched_info
operator|->
name|fix_recovery_cfg
argument_list|(
name|bb
operator|->
name|index
argument_list|,
name|jump_bb
operator|->
name|index
argument_list|,
name|jump_bb_next
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Helper function for move_block_after_check.    This functions attaches edge vector pointed to by SUCCSP to    block TO.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|move_succs
argument_list|(
name|VEC
argument_list|(
name|edge
argument_list|,
name|gc
argument_list|)
operator|*
operator|*
name|succsp
argument_list|,
name|basic_block
name|to
argument_list|)
block|{
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|gcc_assert
argument_list|(
name|to
operator|->
name|succs
operator|==
literal|0
argument_list|)
expr_stmt|;
name|to
operator|->
name|succs
operator|=
operator|*
name|succsp
expr_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|to->succs
argument_list|)
name|e
operator|->
name|src
operator|=
name|to
expr_stmt|;
operator|*
name|succsp
operator|=
literal|0
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* Initialize GLAT (global_live_at_{start, end}) structures.    GLAT structures are used to substitute global_live_{start, end}    regsets during scheduling.  This is necessary to use such functions as    split_block (), as they assume consistency of register live information.  */
end_comment

begin_function
specifier|static
name|void
name|init_glat
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|FOR_ALL_BB
argument_list|(
argument|bb
argument_list|)
name|init_glat1
argument_list|(
name|bb
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Helper function for init_glat.  */
end_comment

begin_function
specifier|static
name|void
name|init_glat1
parameter_list|(
name|basic_block
name|bb
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|bb
operator|->
name|il
operator|.
name|rtl
operator|->
name|global_live_at_start
operator|!=
literal|0
operator|&&
name|bb
operator|->
name|il
operator|.
name|rtl
operator|->
name|global_live_at_end
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|glat_start
index|[
name|bb
operator|->
name|index
index|]
operator|=
name|bb
operator|->
name|il
operator|.
name|rtl
operator|->
name|global_live_at_start
expr_stmt|;
name|glat_end
index|[
name|bb
operator|->
name|index
index|]
operator|=
name|bb
operator|->
name|il
operator|.
name|rtl
operator|->
name|global_live_at_end
expr_stmt|;
if|if
condition|(
name|current_sched_info
operator|->
name|flags
operator|&
name|DETACH_LIFE_INFO
condition|)
block|{
name|bb
operator|->
name|il
operator|.
name|rtl
operator|->
name|global_live_at_start
operator|=
literal|0
expr_stmt|;
name|bb
operator|->
name|il
operator|.
name|rtl
operator|->
name|global_live_at_end
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Attach reg_live_info back to basic blocks.    Also save regsets, that should not have been changed during scheduling,    for checking purposes (see check_reg_live).  */
end_comment

begin_function
name|void
name|attach_life_info
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|FOR_ALL_BB
argument_list|(
argument|bb
argument_list|)
name|attach_life_info1
argument_list|(
name|bb
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Helper function for attach_life_info.  */
end_comment

begin_function
specifier|static
name|void
name|attach_life_info1
parameter_list|(
name|basic_block
name|bb
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|bb
operator|->
name|il
operator|.
name|rtl
operator|->
name|global_live_at_start
operator|==
literal|0
operator|&&
name|bb
operator|->
name|il
operator|.
name|rtl
operator|->
name|global_live_at_end
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|glat_start
index|[
name|bb
operator|->
name|index
index|]
condition|)
block|{
name|gcc_assert
argument_list|(
name|glat_end
index|[
name|bb
operator|->
name|index
index|]
argument_list|)
expr_stmt|;
name|bb
operator|->
name|il
operator|.
name|rtl
operator|->
name|global_live_at_start
operator|=
name|glat_start
index|[
name|bb
operator|->
name|index
index|]
expr_stmt|;
name|bb
operator|->
name|il
operator|.
name|rtl
operator|->
name|global_live_at_end
operator|=
name|glat_end
index|[
name|bb
operator|->
name|index
index|]
expr_stmt|;
comment|/* Make them NULL, so they won't be freed in free_glat.  */
name|glat_start
index|[
name|bb
operator|->
name|index
index|]
operator|=
literal|0
expr_stmt|;
name|glat_end
index|[
name|bb
operator|->
name|index
index|]
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
if|if
condition|(
name|bb
operator|->
name|index
operator|<
name|NUM_FIXED_BLOCKS
operator|||
name|current_sched_info
operator|->
name|region_head_or_leaf_p
argument_list|(
name|bb
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|glat_start
index|[
name|bb
operator|->
name|index
index|]
operator|=
name|ALLOC_REG_SET
argument_list|(
operator|&
name|reg_obstack
argument_list|)
expr_stmt|;
name|COPY_REG_SET
argument_list|(
name|glat_start
index|[
name|bb
operator|->
name|index
index|]
argument_list|,
name|bb
operator|->
name|il
operator|.
name|rtl
operator|->
name|global_live_at_start
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bb
operator|->
name|index
operator|<
name|NUM_FIXED_BLOCKS
operator|||
name|current_sched_info
operator|->
name|region_head_or_leaf_p
argument_list|(
name|bb
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|glat_end
index|[
name|bb
operator|->
name|index
index|]
operator|=
name|ALLOC_REG_SET
argument_list|(
operator|&
name|reg_obstack
argument_list|)
expr_stmt|;
name|COPY_REG_SET
argument_list|(
name|glat_end
index|[
name|bb
operator|->
name|index
index|]
argument_list|,
name|bb
operator|->
name|il
operator|.
name|rtl
operator|->
name|global_live_at_end
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
else|else
block|{
name|gcc_assert
argument_list|(
operator|!
name|glat_end
index|[
name|bb
operator|->
name|index
index|]
argument_list|)
expr_stmt|;
name|bb
operator|->
name|il
operator|.
name|rtl
operator|->
name|global_live_at_start
operator|=
name|ALLOC_REG_SET
argument_list|(
operator|&
name|reg_obstack
argument_list|)
expr_stmt|;
name|bb
operator|->
name|il
operator|.
name|rtl
operator|->
name|global_live_at_end
operator|=
name|ALLOC_REG_SET
argument_list|(
operator|&
name|reg_obstack
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Free GLAT information.  */
end_comment

begin_function
specifier|static
name|void
name|free_glat
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
if|if
condition|(
name|current_sched_info
operator|->
name|flags
operator|&
name|DETACH_LIFE_INFO
condition|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|FOR_ALL_BB
argument_list|(
argument|bb
argument_list|)
block|{
if|if
condition|(
name|glat_start
index|[
name|bb
operator|->
name|index
index|]
condition|)
name|FREE_REG_SET
argument_list|(
name|glat_start
index|[
name|bb
operator|->
name|index
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|glat_end
index|[
name|bb
operator|->
name|index
index|]
condition|)
name|FREE_REG_SET
argument_list|(
name|glat_end
index|[
name|bb
operator|->
name|index
index|]
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|free
argument_list|(
name|glat_start
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|glat_end
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Remove INSN from the instruction stream.    INSN should have any dependencies.  */
end_comment

begin_function
specifier|static
name|void
name|sched_remove_insn
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|change_queue_index
argument_list|(
name|insn
argument_list|,
name|QUEUE_NOWHERE
argument_list|)
expr_stmt|;
name|current_sched_info
operator|->
name|add_remove_insn
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|remove_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Clear priorities of all instructions, that are    forward dependent on INSN.  */
end_comment

begin_function
specifier|static
name|void
name|clear_priorities
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|rtx
name|link
decl_stmt|;
for|for
control|(
name|link
operator|=
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|rtx
name|pro
decl_stmt|;
name|pro
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|INSN_PRIORITY_KNOWN
argument_list|(
name|pro
argument_list|)
condition|)
block|{
name|INSN_PRIORITY_KNOWN
argument_list|(
name|pro
argument_list|)
operator|=
literal|0
expr_stmt|;
name|clear_priorities
argument_list|(
name|pro
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Recompute priorities of instructions, whose priorities might have been    changed due to changes in INSN.  */
end_comment

begin_function
specifier|static
name|void
name|calc_priorities
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|rtx
name|link
decl_stmt|;
for|for
control|(
name|link
operator|=
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|rtx
name|pro
decl_stmt|;
name|pro
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|INSN_PRIORITY_KNOWN
argument_list|(
name|pro
argument_list|)
condition|)
block|{
name|priority
argument_list|(
name|pro
argument_list|)
expr_stmt|;
name|calc_priorities
argument_list|(
name|pro
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Add dependences between JUMP and other instructions in the recovery    block.  INSN is the first insn the recovery block.  */
end_comment

begin_function
specifier|static
name|void
name|add_jump_dependencies
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|rtx
name|jump
parameter_list|)
block|{
do|do
block|{
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|==
name|jump
condition|)
break|break;
if|if
condition|(
operator|!
name|INSN_DEPEND
argument_list|(
name|insn
argument_list|)
condition|)
name|add_back_forw_dep
argument_list|(
name|jump
argument_list|,
name|insn
argument_list|,
name|REG_DEP_ANTI
argument_list|,
name|DEP_ANTI
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
literal|1
condition|)
do|;
name|gcc_assert
argument_list|(
name|LOG_LINKS
argument_list|(
name|jump
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the NOTE_INSN_BASIC_BLOCK of BB.  */
end_comment

begin_function
name|rtx
name|bb_note
parameter_list|(
name|basic_block
name|bb
parameter_list|)
block|{
name|rtx
name|note
decl_stmt|;
name|note
operator|=
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
expr_stmt|;
if|if
condition|(
name|LABEL_P
argument_list|(
name|note
argument_list|)
condition|)
name|note
operator|=
name|NEXT_INSN
argument_list|(
name|note
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|NOTE_INSN_BASIC_BLOCK_P
argument_list|(
name|note
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|note
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
end_ifdef

begin_function_decl
specifier|extern
name|void
name|debug_spec_status
parameter_list|(
name|ds_t
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Dump information about the dependence status S.  */
end_comment

begin_function
name|void
name|debug_spec_status
parameter_list|(
name|ds_t
name|s
parameter_list|)
block|{
name|FILE
modifier|*
name|f
init|=
name|stderr
decl_stmt|;
if|if
condition|(
name|s
operator|&
name|BEGIN_DATA
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"BEGIN_DATA: %d; "
argument_list|,
name|get_dep_weak
argument_list|(
name|s
argument_list|,
name|BEGIN_DATA
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|&
name|BE_IN_DATA
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"BE_IN_DATA: %d; "
argument_list|,
name|get_dep_weak
argument_list|(
name|s
argument_list|,
name|BE_IN_DATA
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|&
name|BEGIN_CONTROL
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"BEGIN_CONTROL: %d; "
argument_list|,
name|get_dep_weak
argument_list|(
name|s
argument_list|,
name|BEGIN_CONTROL
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|&
name|BE_IN_CONTROL
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"BE_IN_CONTROL: %d; "
argument_list|,
name|get_dep_weak
argument_list|(
name|s
argument_list|,
name|BE_IN_CONTROL
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|&
name|HARD_DEP
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"HARD_DEP; "
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|&
name|DEP_TRUE
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"DEP_TRUE; "
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|&
name|DEP_ANTI
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"DEP_ANTI; "
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|&
name|DEP_OUTPUT
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"DEP_OUTPUT; "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Helper function for check_cfg.    Return nonzero, if edge vector pointed to by EL has edge with TYPE in    its flags.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|has_edge_p
argument_list|(
name|VEC
argument_list|(
name|edge
argument_list|,
name|gc
argument_list|)
operator|*
name|el
argument_list|,
name|int
name|type
argument_list|)
block|{
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|el
argument_list|)
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|type
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_decl_stmt

begin_comment
comment|/* Check few properties of CFG between HEAD and TAIL.    If HEAD (TAIL) is NULL check from the beginning (till the end) of the    instruction stream.  */
end_comment

begin_function
specifier|static
name|void
name|check_cfg
parameter_list|(
name|rtx
name|head
parameter_list|,
name|rtx
name|tail
parameter_list|)
block|{
name|rtx
name|next_tail
decl_stmt|;
name|basic_block
name|bb
init|=
literal|0
decl_stmt|;
name|int
name|not_first
init|=
literal|0
decl_stmt|,
name|not_last
decl_stmt|;
if|if
condition|(
name|head
operator|==
name|NULL
condition|)
name|head
operator|=
name|get_insns
argument_list|()
expr_stmt|;
if|if
condition|(
name|tail
operator|==
name|NULL
condition|)
name|tail
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
name|next_tail
operator|=
name|NEXT_INSN
argument_list|(
name|tail
argument_list|)
expr_stmt|;
do|do
block|{
name|not_last
operator|=
name|head
operator|!=
name|tail
expr_stmt|;
if|if
condition|(
name|not_first
condition|)
name|gcc_assert
argument_list|(
name|NEXT_INSN
argument_list|(
name|PREV_INSN
argument_list|(
name|head
argument_list|)
argument_list|)
operator|==
name|head
argument_list|)
expr_stmt|;
if|if
condition|(
name|not_last
condition|)
name|gcc_assert
argument_list|(
name|PREV_INSN
argument_list|(
name|NEXT_INSN
argument_list|(
name|head
argument_list|)
argument_list|)
operator|==
name|head
argument_list|)
expr_stmt|;
if|if
condition|(
name|LABEL_P
argument_list|(
name|head
argument_list|)
operator|||
operator|(
name|NOTE_INSN_BASIC_BLOCK_P
argument_list|(
name|head
argument_list|)
operator|&&
operator|(
operator|!
name|not_first
operator|||
operator|(
name|not_first
operator|&&
operator|!
name|LABEL_P
argument_list|(
name|PREV_INSN
argument_list|(
name|head
argument_list|)
argument_list|)
operator|)
operator|)
operator|)
condition|)
block|{
name|gcc_assert
argument_list|(
name|bb
operator|==
literal|0
argument_list|)
expr_stmt|;
name|bb
operator|=
name|BLOCK_FOR_INSN
argument_list|(
name|head
argument_list|)
expr_stmt|;
if|if
condition|(
name|bb
operator|!=
literal|0
condition|)
name|gcc_assert
argument_list|(
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
operator|==
name|head
argument_list|)
expr_stmt|;
else|else
comment|/* This is the case of jump table.  See inside_basic_block_p ().  */
name|gcc_assert
argument_list|(
name|LABEL_P
argument_list|(
name|head
argument_list|)
operator|&&
operator|!
name|inside_basic_block_p
argument_list|(
name|head
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bb
operator|==
literal|0
condition|)
block|{
name|gcc_assert
argument_list|(
operator|!
name|inside_basic_block_p
argument_list|(
name|head
argument_list|)
argument_list|)
expr_stmt|;
name|head
operator|=
name|NEXT_INSN
argument_list|(
name|head
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gcc_assert
argument_list|(
name|inside_basic_block_p
argument_list|(
name|head
argument_list|)
operator|||
name|NOTE_P
argument_list|(
name|head
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|BLOCK_FOR_INSN
argument_list|(
name|head
argument_list|)
operator|==
name|bb
argument_list|)
expr_stmt|;
if|if
condition|(
name|LABEL_P
argument_list|(
name|head
argument_list|)
condition|)
block|{
name|head
operator|=
name|NEXT_INSN
argument_list|(
name|head
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|NOTE_INSN_BASIC_BLOCK_P
argument_list|(
name|head
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|control_flow_insn_p
argument_list|(
name|head
argument_list|)
condition|)
block|{
name|gcc_assert
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
operator|==
name|head
argument_list|)
expr_stmt|;
if|if
condition|(
name|any_uncondjump_p
argument_list|(
name|head
argument_list|)
condition|)
name|gcc_assert
argument_list|(
name|EDGE_COUNT
argument_list|(
name|bb
operator|->
name|succs
argument_list|)
operator|==
literal|1
operator|&&
name|BARRIER_P
argument_list|(
name|NEXT_INSN
argument_list|(
name|head
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|any_condjump_p
argument_list|(
name|head
argument_list|)
condition|)
name|gcc_assert
argument_list|(
comment|/* Usual case.  */
operator|(
name|EDGE_COUNT
argument_list|(
name|bb
operator|->
name|succs
argument_list|)
operator|>
literal|1
operator|&&
operator|!
name|BARRIER_P
argument_list|(
name|NEXT_INSN
argument_list|(
name|head
argument_list|)
argument_list|)
operator|)
comment|/* Or jump to the next instruction.  */
operator|||
operator|(
name|EDGE_COUNT
argument_list|(
name|bb
operator|->
name|succs
argument_list|)
operator|==
literal|1
operator|&&
operator|(
name|BB_HEAD
argument_list|(
name|EDGE_I
argument_list|(
name|bb
operator|->
name|succs
argument_list|,
literal|0
argument_list|)
operator|->
name|dest
argument_list|)
operator|==
name|JUMP_LABEL
argument_list|(
name|head
argument_list|)
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|BB_END
argument_list|(
name|bb
argument_list|)
operator|==
name|head
condition|)
block|{
if|if
condition|(
name|EDGE_COUNT
argument_list|(
name|bb
operator|->
name|succs
argument_list|)
operator|>
literal|1
condition|)
name|gcc_assert
argument_list|(
name|control_flow_insn_p
argument_list|(
name|head
argument_list|)
operator|||
name|has_edge_p
argument_list|(
name|bb
operator|->
name|succs
argument_list|,
name|EDGE_COMPLEX
argument_list|)
argument_list|)
expr_stmt|;
name|bb
operator|=
literal|0
expr_stmt|;
block|}
name|head
operator|=
name|NEXT_INSN
argument_list|(
name|head
argument_list|)
expr_stmt|;
block|}
block|}
name|not_first
operator|=
literal|1
expr_stmt|;
block|}
do|while
condition|(
name|head
operator|!=
name|next_tail
condition|)
do|;
name|gcc_assert
argument_list|(
name|bb
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Perform a few consistency checks of flags in different data structures.  */
end_comment

begin_function
specifier|static
name|void
name|check_sched_flags
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|int
name|f
init|=
name|current_sched_info
operator|->
name|flags
decl_stmt|;
if|if
condition|(
name|flag_sched_stalled_insns
condition|)
name|gcc_assert
argument_list|(
operator|!
operator|(
name|f
operator|&
name|DO_SPECULATION
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|&
name|DO_SPECULATION
condition|)
name|gcc_assert
argument_list|(
operator|!
name|flag_sched_stalled_insns
operator|&&
operator|(
name|f
operator|&
name|DETACH_LIFE_INFO
operator|)
operator|&&
name|spec_info
operator|&&
name|spec_info
operator|->
name|mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|&
name|DETACH_LIFE_INFO
condition|)
name|gcc_assert
argument_list|(
name|f
operator|&
name|USE_GLAT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Check global_live_at_{start, end} regsets.    If FATAL_P is TRUE, then abort execution at the first failure.    Otherwise, print diagnostics to STDERR (this mode is for calling    from debugger).  */
end_comment

begin_function
name|void
name|check_reg_live
parameter_list|(
name|bool
name|fatal_p
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|FOR_ALL_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|int
name|i
decl_stmt|;
name|i
operator|=
name|bb
operator|->
name|index
expr_stmt|;
if|if
condition|(
name|glat_start
index|[
name|i
index|]
condition|)
block|{
name|bool
name|b
init|=
name|bitmap_equal_p
argument_list|(
name|bb
operator|->
name|il
operator|.
name|rtl
operator|->
name|global_live_at_start
argument_list|,
name|glat_start
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|b
condition|)
block|{
name|gcc_assert
argument_list|(
operator|!
name|fatal_p
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|";; check_reg_live_at_start (%d) failed.\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|glat_end
index|[
name|i
index|]
condition|)
block|{
name|bool
name|b
init|=
name|bitmap_equal_p
argument_list|(
name|bb
operator|->
name|il
operator|.
name|rtl
operator|->
name|global_live_at_end
argument_list|,
name|glat_end
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|b
condition|)
block|{
name|gcc_assert
argument_list|(
operator|!
name|fatal_p
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|";; check_reg_live_at_end (%d) failed.\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ENABLE_CHECKING */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INSN_SCHEDULING */
end_comment

end_unit

