begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Miscellaneous SSA utility functions.    Copyright (C) 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_include
include|#
directive|include
file|"bitmap.h"
end_include

begin_include
include|#
directive|include
file|"pointer-set.h"
end_include

begin_include
include|#
directive|include
file|"tree-flow.h"
end_include

begin_include
include|#
directive|include
file|"tree-gimple.h"
end_include

begin_include
include|#
directive|include
file|"tree-inline.h"
end_include

begin_include
include|#
directive|include
file|"varray.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"hashtab.h"
end_include

begin_include
include|#
directive|include
file|"tree-dump.h"
end_include

begin_include
include|#
directive|include
file|"tree-pass.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_comment
comment|/* Remove the corresponding arguments from the PHI nodes in E's    destination block and redirect it to DEST.  Return redirected edge.    The list of removed arguments is stored in PENDING_STMT (e).  */
end_comment

begin_function
name|edge
name|ssa_redirect_edge
parameter_list|(
name|edge
name|e
parameter_list|,
name|basic_block
name|dest
parameter_list|)
block|{
name|tree
name|phi
decl_stmt|;
name|tree
name|list
init|=
name|NULL
decl_stmt|,
modifier|*
name|last
init|=
operator|&
name|list
decl_stmt|;
name|tree
name|src
decl_stmt|,
name|dst
decl_stmt|,
name|node
decl_stmt|;
comment|/* Remove the appropriate PHI arguments in E's destination block.  */
for|for
control|(
name|phi
operator|=
name|phi_nodes
argument_list|(
name|e
operator|->
name|dest
argument_list|)
init|;
name|phi
condition|;
name|phi
operator|=
name|PHI_CHAIN
argument_list|(
name|phi
argument_list|)
control|)
block|{
if|if
condition|(
name|PHI_ARG_DEF
argument_list|(
name|phi
argument_list|,
name|e
operator|->
name|dest_idx
argument_list|)
operator|==
name|NULL_TREE
condition|)
continue|continue;
name|src
operator|=
name|PHI_ARG_DEF
argument_list|(
name|phi
argument_list|,
name|e
operator|->
name|dest_idx
argument_list|)
expr_stmt|;
name|dst
operator|=
name|PHI_RESULT
argument_list|(
name|phi
argument_list|)
expr_stmt|;
name|node
operator|=
name|build_tree_list
argument_list|(
name|dst
argument_list|,
name|src
argument_list|)
expr_stmt|;
operator|*
name|last
operator|=
name|node
expr_stmt|;
name|last
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
name|e
operator|=
name|redirect_edge_succ_nodup
argument_list|(
name|e
argument_list|,
name|dest
argument_list|)
expr_stmt|;
name|PENDING_STMT
argument_list|(
name|e
argument_list|)
operator|=
name|list
expr_stmt|;
return|return
name|e
return|;
block|}
end_function

begin_comment
comment|/* Add PHI arguments queued in PENDINT_STMT list on edge E to edge    E->dest.  */
end_comment

begin_function
name|void
name|flush_pending_stmts
parameter_list|(
name|edge
name|e
parameter_list|)
block|{
name|tree
name|phi
decl_stmt|,
name|arg
decl_stmt|;
if|if
condition|(
operator|!
name|PENDING_STMT
argument_list|(
name|e
argument_list|)
condition|)
return|return;
for|for
control|(
name|phi
operator|=
name|phi_nodes
argument_list|(
name|e
operator|->
name|dest
argument_list|)
operator|,
name|arg
operator|=
name|PENDING_STMT
argument_list|(
name|e
argument_list|)
init|;
name|phi
condition|;
name|phi
operator|=
name|PHI_CHAIN
argument_list|(
name|phi
argument_list|)
operator|,
name|arg
operator|=
name|TREE_CHAIN
argument_list|(
name|arg
argument_list|)
control|)
block|{
name|tree
name|def
init|=
name|TREE_VALUE
argument_list|(
name|arg
argument_list|)
decl_stmt|;
name|add_phi_arg
argument_list|(
name|phi
argument_list|,
name|def
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|PENDING_STMT
argument_list|(
name|e
argument_list|)
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return true if SSA_NAME is malformed and mark it visited.     IS_VIRTUAL is true if this SSA_NAME was found inside a virtual       operand.  */
end_comment

begin_function
specifier|static
name|bool
name|verify_ssa_name
parameter_list|(
name|tree
name|ssa_name
parameter_list|,
name|bool
name|is_virtual
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ssa_name
argument_list|)
operator|!=
name|SSA_NAME
condition|)
block|{
name|error
argument_list|(
literal|"expected an SSA_NAME object"
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|ssa_name
argument_list|)
operator|!=
name|TREE_TYPE
argument_list|(
name|SSA_NAME_VAR
argument_list|(
name|ssa_name
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"type mismatch between an SSA_NAME and its symbol"
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
if|if
condition|(
name|SSA_NAME_IN_FREE_LIST
argument_list|(
name|ssa_name
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"found an SSA_NAME that had been released into the free pool"
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
if|if
condition|(
name|is_virtual
operator|&&
name|is_gimple_reg
argument_list|(
name|ssa_name
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"found a virtual definition for a GIMPLE register"
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
if|if
condition|(
operator|!
name|is_virtual
operator|&&
operator|!
name|is_gimple_reg
argument_list|(
name|ssa_name
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"found a real definition for a non-register"
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
if|if
condition|(
name|is_virtual
operator|&&
name|var_ann
argument_list|(
name|SSA_NAME_VAR
argument_list|(
name|ssa_name
argument_list|)
argument_list|)
operator|&&
name|get_subvars_for_var
argument_list|(
name|SSA_NAME_VAR
argument_list|(
name|ssa_name
argument_list|)
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"found real variable when subvariables should have appeared"
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Return true if the definition of SSA_NAME at block BB is malformed.     STMT is the statement where SSA_NAME is created.     DEFINITION_BLOCK is an array of basic blocks indexed by SSA_NAME       version numbers.  If DEFINITION_BLOCK[SSA_NAME_VERSION] is set,       it means that the block in that array slot contains the       definition of SSA_NAME.     IS_VIRTUAL is true if SSA_NAME is created by a V_MAY_DEF or a       V_MUST_DEF.  */
end_comment

begin_function
specifier|static
name|bool
name|verify_def
parameter_list|(
name|basic_block
name|bb
parameter_list|,
name|basic_block
modifier|*
name|definition_block
parameter_list|,
name|tree
name|ssa_name
parameter_list|,
name|tree
name|stmt
parameter_list|,
name|bool
name|is_virtual
parameter_list|)
block|{
if|if
condition|(
name|verify_ssa_name
argument_list|(
name|ssa_name
argument_list|,
name|is_virtual
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|definition_block
index|[
name|SSA_NAME_VERSION
argument_list|(
name|ssa_name
argument_list|)
index|]
condition|)
block|{
name|error
argument_list|(
literal|"SSA_NAME created in two different blocks %i and %i"
argument_list|,
name|definition_block
index|[
name|SSA_NAME_VERSION
argument_list|(
name|ssa_name
argument_list|)
index|]
operator|->
name|index
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|definition_block
index|[
name|SSA_NAME_VERSION
argument_list|(
name|ssa_name
argument_list|)
index|]
operator|=
name|bb
expr_stmt|;
if|if
condition|(
name|SSA_NAME_DEF_STMT
argument_list|(
name|ssa_name
argument_list|)
operator|!=
name|stmt
condition|)
block|{
name|error
argument_list|(
literal|"SSA_NAME_DEF_STMT is wrong"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Expected definition statement:\n"
argument_list|)
expr_stmt|;
name|print_generic_stmt
argument_list|(
name|stderr
argument_list|,
name|SSA_NAME_DEF_STMT
argument_list|(
name|ssa_name
argument_list|)
argument_list|,
name|TDF_VOPS
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nActual definition statement:\n"
argument_list|)
expr_stmt|;
name|print_generic_stmt
argument_list|(
name|stderr
argument_list|,
name|stmt
argument_list|,
name|TDF_VOPS
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
return|return
name|false
return|;
name|err
label|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"while verifying SSA_NAME "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|stderr
argument_list|,
name|ssa_name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" in statement\n"
argument_list|)
expr_stmt|;
name|print_generic_stmt
argument_list|(
name|stderr
argument_list|,
name|stmt
argument_list|,
name|TDF_VOPS
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Return true if the use of SSA_NAME at statement STMT in block BB is    malformed.     DEF_BB is the block where SSA_NAME was found to be created.     IDOM contains immediate dominator information for the flowgraph.     CHECK_ABNORMAL is true if the caller wants to check whether this use       is flowing through an abnormal edge (only used when checking PHI       arguments).     IS_VIRTUAL is true if SSA_NAME is created by a V_MAY_DEF or a       V_MUST_DEF.        If NAMES_DEFINED_IN_BB is not NULL, it contains a bitmap of ssa names      that are defined before STMT in basic block BB.  */
end_comment

begin_function
specifier|static
name|bool
name|verify_use
parameter_list|(
name|basic_block
name|bb
parameter_list|,
name|basic_block
name|def_bb
parameter_list|,
name|use_operand_p
name|use_p
parameter_list|,
name|tree
name|stmt
parameter_list|,
name|bool
name|check_abnormal
parameter_list|,
name|bool
name|is_virtual
parameter_list|,
name|bitmap
name|names_defined_in_bb
parameter_list|)
block|{
name|bool
name|err
init|=
name|false
decl_stmt|;
name|tree
name|ssa_name
init|=
name|USE_FROM_PTR
argument_list|(
name|use_p
argument_list|)
decl_stmt|;
name|err
operator|=
name|verify_ssa_name
argument_list|(
name|ssa_name
argument_list|,
name|is_virtual
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TREE_VISITED
argument_list|(
name|ssa_name
argument_list|)
condition|)
if|if
condition|(
name|verify_imm_links
argument_list|(
name|stderr
argument_list|,
name|ssa_name
argument_list|)
condition|)
name|err
operator|=
name|true
expr_stmt|;
name|TREE_VISITED
argument_list|(
name|ssa_name
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|IS_EMPTY_STMT
argument_list|(
name|SSA_NAME_DEF_STMT
argument_list|(
name|ssa_name
argument_list|)
argument_list|)
operator|&&
name|default_def
argument_list|(
name|SSA_NAME_VAR
argument_list|(
name|ssa_name
argument_list|)
argument_list|)
operator|==
name|ssa_name
condition|)
empty_stmt|;
comment|/* Default definitions have empty statements.  Nothing to do.  */
elseif|else
if|if
condition|(
operator|!
name|def_bb
condition|)
block|{
name|error
argument_list|(
literal|"missing definition"
argument_list|)
expr_stmt|;
name|err
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bb
operator|!=
name|def_bb
operator|&&
operator|!
name|dominated_by_p
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|bb
argument_list|,
name|def_bb
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"definition in block %i does not dominate use in block %i"
argument_list|,
name|def_bb
operator|->
name|index
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|err
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bb
operator|==
name|def_bb
operator|&&
name|names_defined_in_bb
operator|!=
name|NULL
operator|&&
operator|!
name|bitmap_bit_p
argument_list|(
name|names_defined_in_bb
argument_list|,
name|SSA_NAME_VERSION
argument_list|(
name|ssa_name
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"definition in block %i follows the use"
argument_list|,
name|def_bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|err
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|check_abnormal
operator|&&
operator|!
name|SSA_NAME_OCCURS_IN_ABNORMAL_PHI
argument_list|(
name|ssa_name
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"SSA_NAME_OCCURS_IN_ABNORMAL_PHI should be set"
argument_list|)
expr_stmt|;
name|err
operator|=
name|true
expr_stmt|;
block|}
comment|/* Make sure the use is in an appropriate list by checking the previous       element to make sure it's the same.  */
if|if
condition|(
name|use_p
operator|->
name|prev
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"no immediate_use list"
argument_list|)
expr_stmt|;
name|err
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
name|tree
name|listvar
decl_stmt|;
if|if
condition|(
name|use_p
operator|->
name|prev
operator|->
name|use
operator|==
name|NULL
condition|)
name|listvar
operator|=
name|use_p
operator|->
name|prev
operator|->
name|stmt
expr_stmt|;
else|else
name|listvar
operator|=
name|USE_FROM_PTR
argument_list|(
name|use_p
operator|->
name|prev
argument_list|)
expr_stmt|;
if|if
condition|(
name|listvar
operator|!=
name|ssa_name
condition|)
block|{
name|error
argument_list|(
literal|"wrong immediate use list"
argument_list|)
expr_stmt|;
name|err
operator|=
name|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|err
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"for SSA_NAME: "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|stderr
argument_list|,
name|ssa_name
argument_list|,
name|TDF_VOPS
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" in statement:\n"
argument_list|)
expr_stmt|;
name|print_generic_stmt
argument_list|(
name|stderr
argument_list|,
name|stmt
argument_list|,
name|TDF_VOPS
argument_list|)
expr_stmt|;
block|}
return|return
name|err
return|;
block|}
end_function

begin_comment
comment|/* Return true if any of the arguments for PHI node PHI at block BB is    malformed.     DEFINITION_BLOCK is an array of basic blocks indexed by SSA_NAME version       numbers.  If DEFINITION_BLOCK[SSA_NAME_VERSION] is set, it means that the       block in that array slot contains the definition of SSA_NAME.  */
end_comment

begin_function
specifier|static
name|bool
name|verify_phi_args
parameter_list|(
name|tree
name|phi
parameter_list|,
name|basic_block
name|bb
parameter_list|,
name|basic_block
modifier|*
name|definition_block
parameter_list|)
block|{
name|edge
name|e
decl_stmt|;
name|bool
name|err
init|=
name|false
decl_stmt|;
name|unsigned
name|i
decl_stmt|,
name|phi_num_args
init|=
name|PHI_NUM_ARGS
argument_list|(
name|phi
argument_list|)
decl_stmt|;
if|if
condition|(
name|EDGE_COUNT
argument_list|(
name|bb
operator|->
name|preds
argument_list|)
operator|!=
name|phi_num_args
condition|)
block|{
name|error
argument_list|(
literal|"incoming edge count does not match number of PHI arguments"
argument_list|)
expr_stmt|;
name|err
operator|=
name|true
expr_stmt|;
goto|goto
name|error
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|phi_num_args
condition|;
name|i
operator|++
control|)
block|{
name|use_operand_p
name|op_p
init|=
name|PHI_ARG_DEF_PTR
argument_list|(
name|phi
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|tree
name|op
init|=
name|USE_FROM_PTR
argument_list|(
name|op_p
argument_list|)
decl_stmt|;
name|e
operator|=
name|EDGE_PRED
argument_list|(
name|bb
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|NULL_TREE
condition|)
block|{
name|error
argument_list|(
literal|"PHI argument is missing for edge %d->%d"
argument_list|,
name|e
operator|->
name|src
operator|->
name|index
argument_list|,
name|e
operator|->
name|dest
operator|->
name|index
argument_list|)
expr_stmt|;
name|err
operator|=
name|true
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|SSA_NAME
operator|&&
operator|!
name|is_gimple_min_invariant
argument_list|(
name|op
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"PHI argument is not SSA_NAME, or invariant"
argument_list|)
expr_stmt|;
name|err
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SSA_NAME
condition|)
name|err
operator|=
name|verify_use
argument_list|(
name|e
operator|->
name|src
argument_list|,
name|definition_block
index|[
name|SSA_NAME_VERSION
argument_list|(
name|op
argument_list|)
index|]
argument_list|,
name|op_p
argument_list|,
name|phi
argument_list|,
name|e
operator|->
name|flags
operator|&
name|EDGE_ABNORMAL
argument_list|,
operator|!
name|is_gimple_reg
argument_list|(
name|PHI_RESULT
argument_list|(
name|phi
argument_list|)
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|dest
operator|!=
name|bb
condition|)
block|{
name|error
argument_list|(
literal|"wrong edge %d->%d for PHI argument"
argument_list|,
name|e
operator|->
name|src
operator|->
name|index
argument_list|,
name|e
operator|->
name|dest
operator|->
name|index
argument_list|)
expr_stmt|;
name|err
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|err
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"PHI argument\n"
argument_list|)
expr_stmt|;
name|print_generic_stmt
argument_list|(
name|stderr
argument_list|,
name|op
argument_list|,
name|TDF_VOPS
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
block|}
name|error
label|:
if|if
condition|(
name|err
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"for PHI node\n"
argument_list|)
expr_stmt|;
name|print_generic_stmt
argument_list|(
name|stderr
argument_list|,
name|phi
argument_list|,
name|TDF_VOPS
argument_list|)
expr_stmt|;
block|}
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|verify_flow_insensitive_alias_info
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|var
decl_stmt|;
name|bitmap
name|visited
init|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
name|referenced_var_iterator
name|rvi
decl_stmt|;
name|FOR_EACH_REFERENCED_VAR
argument_list|(
argument|var
argument_list|,
argument|rvi
argument_list|)
block|{
name|size_t
name|j
decl_stmt|;
name|var_ann_t
name|ann
decl_stmt|;
name|VEC
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|)
operator|*
name|may_aliases
expr_stmt|;
name|tree
name|alias
decl_stmt|;
name|ann
operator|=
name|var_ann
argument_list|(
name|var
argument_list|)
expr_stmt|;
name|may_aliases
operator|=
name|ann
operator|->
name|may_aliases
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|tree
argument_list|,
name|may_aliases
argument_list|,
name|j
argument_list|,
name|alias
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
name|bitmap_set_bit
argument_list|(
name|visited
argument_list|,
name|DECL_UID
argument_list|(
name|alias
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|may_be_aliased
argument_list|(
name|alias
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"non-addressable variable inside an alias set"
argument_list|)
expr_stmt|;
name|debug_variable
argument_list|(
name|alias
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
block|}
block|}
name|FOR_EACH_REFERENCED_VAR
argument_list|(
argument|var
argument_list|,
argument|rvi
argument_list|)
block|{
name|var_ann_t
name|ann
decl_stmt|;
name|ann
operator|=
name|var_ann
argument_list|(
name|var
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|MTAG_P
argument_list|(
name|var
argument_list|)
operator|&&
name|ann
operator|->
name|is_aliased
operator|&&
operator|!
name|bitmap_bit_p
argument_list|(
name|visited
argument_list|,
name|DECL_UID
argument_list|(
name|var
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"addressable variable that is aliased but is not in any alias set"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
block|}
name|BITMAP_FREE
argument_list|(
name|visited
argument_list|)
expr_stmt|;
return|return;
name|err
label|:
name|debug_variable
argument_list|(
name|var
argument_list|)
expr_stmt|;
name|internal_error
argument_list|(
literal|"verify_flow_insensitive_alias_info failed"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|verify_flow_sensitive_alias_info
parameter_list|(
name|void
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
name|tree
name|ptr
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|num_ssa_names
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|var
decl_stmt|;
name|var_ann_t
name|ann
decl_stmt|;
name|struct
name|ptr_info_def
modifier|*
name|pi
decl_stmt|;
name|ptr
operator|=
name|ssa_name
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ptr
condition|)
continue|continue;
comment|/* We only care for pointers that are actually referenced in the 	 program.  */
if|if
condition|(
operator|!
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|ptr
argument_list|)
argument_list|)
operator|||
operator|!
name|TREE_VISITED
argument_list|(
name|ptr
argument_list|)
condition|)
continue|continue;
comment|/* RESULT_DECL is special.  If it's a GIMPLE register, then it 	 is only written-to only once in the return statement. 	 Otherwise, aggregate RESULT_DECLs may be written-to more than 	 once in virtual operands.  */
name|var
operator|=
name|SSA_NAME_VAR
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|var
argument_list|)
operator|==
name|RESULT_DECL
operator|&&
name|is_gimple_reg
argument_list|(
name|ptr
argument_list|)
condition|)
continue|continue;
name|pi
operator|=
name|SSA_NAME_PTR_INFO
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|pi
operator|==
name|NULL
condition|)
continue|continue;
name|ann
operator|=
name|var_ann
argument_list|(
name|var
argument_list|)
expr_stmt|;
if|if
condition|(
name|pi
operator|->
name|is_dereferenced
operator|&&
operator|!
name|pi
operator|->
name|name_mem_tag
operator|&&
operator|!
name|ann
operator|->
name|symbol_mem_tag
condition|)
block|{
name|error
argument_list|(
literal|"dereferenced pointers should have a name or a symbol tag"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|pi
operator|->
name|name_mem_tag
operator|&&
operator|(
name|pi
operator|->
name|pt_vars
operator|==
name|NULL
operator|||
name|bitmap_empty_p
argument_list|(
name|pi
operator|->
name|pt_vars
argument_list|)
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"pointers with a memory tag, should have points-to sets"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|pi
operator|->
name|value_escapes_p
operator|&&
name|pi
operator|->
name|name_mem_tag
operator|&&
operator|!
name|is_call_clobbered
argument_list|(
name|pi
operator|->
name|name_mem_tag
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"pointer escapes but its name tag is not call-clobbered"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
block|}
return|return;
name|err
label|:
name|debug_variable
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|internal_error
argument_list|(
literal|"verify_flow_sensitive_alias_info failed"
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|DEF_VEC_P
argument_list|(
name|bitmap
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DEF_VEC_ALLOC_P
argument_list|(
name|bitmap
argument_list|,
name|heap
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Verify that all name tags have different points to sets.    This algorithm takes advantage of the fact that every variable with the    same name tag must have the same points-to set.     So we check a single variable for each name tag, and verify that its    points-to set is different from every other points-to set for other name    tags.     Additionally, given a pointer P_i with name tag NMT and symbol tag    SMT, this function verified the alias set of SMT is a superset of    the alias set of NMT.  */
end_comment

begin_function
specifier|static
name|void
name|verify_name_tags
parameter_list|(
name|void
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
name|size_t
name|j
decl_stmt|;
name|bitmap
name|first
decl_stmt|,
name|second
decl_stmt|;
name|VEC
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|)
operator|*
name|name_tag_reps
operator|=
name|NULL
expr_stmt|;
name|VEC
argument_list|(
name|bitmap
argument_list|,
name|heap
argument_list|)
operator|*
name|pt_vars_for_reps
operator|=
name|NULL
expr_stmt|;
name|bitmap
name|type_aliases
init|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
comment|/* First we compute the name tag representatives and their points-to sets.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_ssa_names
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ptr_info_def
modifier|*
name|pi
decl_stmt|;
name|tree
name|smt
decl_stmt|,
name|ptr
init|=
name|ssa_name
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|ptr
operator|==
name|NULL_TREE
condition|)
continue|continue;
name|pi
operator|=
name|SSA_NAME_PTR_INFO
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TREE_VISITED
argument_list|(
name|ptr
argument_list|)
operator|||
operator|!
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|ptr
argument_list|)
argument_list|)
operator|||
operator|!
name|pi
operator|||
operator|!
name|pi
operator|->
name|name_mem_tag
operator|||
name|TREE_VISITED
argument_list|(
name|pi
operator|->
name|name_mem_tag
argument_list|)
condition|)
continue|continue;
name|TREE_VISITED
argument_list|(
name|pi
operator|->
name|name_mem_tag
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|pi
operator|->
name|pt_vars
operator|==
name|NULL
condition|)
continue|continue;
name|VEC_safe_push
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
name|name_tag_reps
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|bitmap
argument_list|,
name|heap
argument_list|,
name|pt_vars_for_reps
argument_list|,
name|pi
operator|->
name|pt_vars
argument_list|)
expr_stmt|;
comment|/* Verify that alias set of PTR's symbol tag is a superset of the 	 alias set of PTR's name tag.  */
name|smt
operator|=
name|var_ann
argument_list|(
name|SSA_NAME_VAR
argument_list|(
name|ptr
argument_list|)
argument_list|)
operator|->
name|symbol_mem_tag
expr_stmt|;
if|if
condition|(
name|smt
condition|)
block|{
name|size_t
name|i
decl_stmt|;
name|VEC
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|)
operator|*
name|aliases
operator|=
name|var_ann
argument_list|(
name|smt
argument_list|)
operator|->
name|may_aliases
expr_stmt|;
name|tree
name|alias
decl_stmt|;
name|bitmap_clear
argument_list|(
name|type_aliases
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|tree
argument_list|,
name|aliases
argument_list|,
name|i
argument_list|,
name|alias
argument_list|)
condition|;
name|i
operator|++
control|)
name|bitmap_set_bit
argument_list|(
name|type_aliases
argument_list|,
name|DECL_UID
argument_list|(
name|alias
argument_list|)
argument_list|)
expr_stmt|;
comment|/* When grouping, we may have added PTR's symbol tag into the 	     alias set of PTR's name tag.  To prevent a false 	     positive, pretend that SMT is in its own alias set.  */
name|bitmap_set_bit
argument_list|(
name|type_aliases
argument_list|,
name|DECL_UID
argument_list|(
name|smt
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitmap_equal_p
argument_list|(
name|type_aliases
argument_list|,
name|pi
operator|->
name|pt_vars
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|bitmap_intersect_compl_p
argument_list|(
name|type_aliases
argument_list|,
name|pi
operator|->
name|pt_vars
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"alias set of a pointer's symbol tag should be a superset of the corresponding name tag"
argument_list|)
expr_stmt|;
name|debug_variable
argument_list|(
name|smt
argument_list|)
expr_stmt|;
name|debug_variable
argument_list|(
name|pi
operator|->
name|name_mem_tag
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
block|}
block|}
comment|/* Now compare all the representative bitmaps with all other representative      bitmaps, to verify that they are all different.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|bitmap
argument_list|,
name|pt_vars_for_reps
argument_list|,
name|i
argument_list|,
name|first
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|VEC_iterate
argument_list|(
name|bitmap
argument_list|,
name|pt_vars_for_reps
argument_list|,
name|j
argument_list|,
name|second
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|bitmap_equal_p
argument_list|(
name|first
argument_list|,
name|second
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"two different pointers with identical points-to sets but different name tags"
argument_list|)
expr_stmt|;
name|debug_variable
argument_list|(
name|VEC_index
argument_list|(
name|tree
argument_list|,
name|name_tag_reps
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
block|}
block|}
comment|/* Lastly, clear out the visited flags.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_ssa_names
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ssa_name
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|tree
name|ptr
init|=
name|ssa_name
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|struct
name|ptr_info_def
modifier|*
name|pi
init|=
name|SSA_NAME_PTR_INFO
argument_list|(
name|ptr
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|TREE_VISITED
argument_list|(
name|ptr
argument_list|)
operator|||
operator|!
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|ptr
argument_list|)
argument_list|)
operator|||
operator|!
name|pi
operator|||
operator|!
name|pi
operator|->
name|name_mem_tag
condition|)
continue|continue;
name|TREE_VISITED
argument_list|(
name|pi
operator|->
name|name_mem_tag
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* We do not have to free the bitmaps or trees in the vectors, as      they are not owned by us.  */
name|VEC_free
argument_list|(
name|bitmap
argument_list|,
name|heap
argument_list|,
name|pt_vars_for_reps
argument_list|)
expr_stmt|;
name|VEC_free
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
name|name_tag_reps
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|type_aliases
argument_list|)
expr_stmt|;
return|return;
name|err
label|:
name|debug_variable
argument_list|(
name|VEC_index
argument_list|(
name|tree
argument_list|,
name|name_tag_reps
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|internal_error
argument_list|(
literal|"verify_name_tags failed"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Verify the consistency of call clobbering information.  */
end_comment

begin_function
specifier|static
name|void
name|verify_call_clobbering
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
name|tree
name|var
decl_stmt|;
name|referenced_var_iterator
name|rvi
decl_stmt|;
comment|/* At all times, the result of the DECL_CALL_CLOBBERED flag should      match the result of the call_clobbered_vars bitmap.  Verify both      that everything in call_clobbered_vars is marked      DECL_CALL_CLOBBERED, and that everything marked      DECL_CALL_CLOBBERED is in call_clobbered_vars.  */
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|call_clobbered_vars
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|bi
argument_list|)
block|{
name|var
operator|=
name|referenced_var
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|MTAG_P
argument_list|(
name|var
argument_list|)
operator|&&
operator|!
name|DECL_CALL_CLOBBERED
argument_list|(
name|var
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"variable in call_clobbered_vars but not marked DECL_CALL_CLOBBERED"
argument_list|)
expr_stmt|;
name|debug_variable
argument_list|(
name|var
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
block|}
name|FOR_EACH_REFERENCED_VAR
argument_list|(
argument|var
argument_list|,
argument|rvi
argument_list|)
block|{
if|if
condition|(
operator|!
name|MTAG_P
argument_list|(
name|var
argument_list|)
operator|&&
name|DECL_CALL_CLOBBERED
argument_list|(
name|var
argument_list|)
operator|&&
operator|!
name|bitmap_bit_p
argument_list|(
name|call_clobbered_vars
argument_list|,
name|DECL_UID
argument_list|(
name|var
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"variable marked DECL_CALL_CLOBBERED but not in call_clobbered_vars bitmap."
argument_list|)
expr_stmt|;
name|debug_variable
argument_list|(
name|var
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
block|}
return|return;
name|err
label|:
name|internal_error
argument_list|(
literal|"verify_call_clobbering failed"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Verify the consistency of aliasing information.  */
end_comment

begin_function
specifier|static
name|void
name|verify_alias_info
parameter_list|(
name|void
parameter_list|)
block|{
name|verify_flow_sensitive_alias_info
argument_list|()
expr_stmt|;
name|verify_name_tags
argument_list|()
expr_stmt|;
name|verify_call_clobbering
argument_list|()
expr_stmt|;
name|verify_flow_insensitive_alias_info
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Verify common invariants in the SSA web.    TODO: verify the variable annotations.  */
end_comment

begin_function
name|void
name|verify_ssa
parameter_list|(
name|bool
name|check_modified_stmt
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|basic_block
modifier|*
name|definition_block
init|=
name|XCNEWVEC
argument_list|(
name|basic_block
argument_list|,
name|num_ssa_names
argument_list|)
decl_stmt|;
name|ssa_op_iter
name|iter
decl_stmt|;
name|tree
name|op
decl_stmt|;
name|enum
name|dom_state
name|orig_dom_state
init|=
name|dom_computed
index|[
name|CDI_DOMINATORS
index|]
decl_stmt|;
name|bitmap
name|names_defined_in_bb
init|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|need_ssa_update_p
argument_list|()
argument_list|)
expr_stmt|;
name|verify_stmts
argument_list|()
expr_stmt|;
name|timevar_push
argument_list|(
name|TV_TREE_SSA_VERIFY
argument_list|)
expr_stmt|;
comment|/* Keep track of SSA names present in the IL.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|num_ssa_names
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|name
init|=
name|ssa_name
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|name
condition|)
block|{
name|tree
name|stmt
decl_stmt|;
name|TREE_VISITED
argument_list|(
name|name
argument_list|)
operator|=
literal|0
expr_stmt|;
name|stmt
operator|=
name|SSA_NAME_DEF_STMT
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IS_EMPTY_STMT
argument_list|(
name|stmt
argument_list|)
condition|)
block|{
name|basic_block
name|bb
init|=
name|bb_for_stmt
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
name|verify_def
argument_list|(
name|bb
argument_list|,
name|definition_block
argument_list|,
name|name
argument_list|,
name|stmt
argument_list|,
operator|!
name|is_gimple_reg
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|calculate_dominance_info
argument_list|(
name|CDI_DOMINATORS
argument_list|)
expr_stmt|;
comment|/* Now verify all the uses and make sure they agree with the definitions      found in the previous pass.  */
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|edge
name|e
decl_stmt|;
name|tree
name|phi
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|block_stmt_iterator
name|bsi
decl_stmt|;
comment|/* Make sure that all edges have a clear 'aux' field.  */
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->preds
argument_list|)
block|{
if|if
condition|(
name|e
operator|->
name|aux
condition|)
block|{
name|error
argument_list|(
literal|"AUX pointer initialized for edge %d->%d"
argument_list|,
name|e
operator|->
name|src
operator|->
name|index
argument_list|,
name|e
operator|->
name|dest
operator|->
name|index
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
block|}
comment|/* Verify the arguments for every PHI node in the block.  */
for|for
control|(
name|phi
operator|=
name|phi_nodes
argument_list|(
name|bb
argument_list|)
init|;
name|phi
condition|;
name|phi
operator|=
name|PHI_CHAIN
argument_list|(
name|phi
argument_list|)
control|)
block|{
if|if
condition|(
name|verify_phi_args
argument_list|(
name|phi
argument_list|,
name|bb
argument_list|,
name|definition_block
argument_list|)
condition|)
goto|goto
name|err
goto|;
name|bitmap_set_bit
argument_list|(
name|names_defined_in_bb
argument_list|,
name|SSA_NAME_VERSION
argument_list|(
name|PHI_RESULT
argument_list|(
name|phi
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Now verify all the uses and vuses in every statement of the block.  */
for|for
control|(
name|bsi
operator|=
name|bsi_start
argument_list|(
name|bb
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|;
name|bsi_next
argument_list|(
operator|&
name|bsi
argument_list|)
control|)
block|{
name|tree
name|stmt
init|=
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
decl_stmt|;
name|use_operand_p
name|use_p
decl_stmt|;
if|if
condition|(
name|check_modified_stmt
operator|&&
name|stmt_modified_p
argument_list|(
name|stmt
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"stmt (%p) marked modified after optimization pass : "
argument_list|,
operator|(
name|void
operator|*
operator|)
name|stmt
argument_list|)
expr_stmt|;
name|print_generic_stmt
argument_list|(
name|stderr
argument_list|,
name|stmt
argument_list|,
name|TDF_VOPS
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|MODIFY_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|SSA_NAME
condition|)
block|{
name|tree
name|lhs
decl_stmt|,
name|base_address
decl_stmt|;
name|lhs
operator|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|base_address
operator|=
name|get_base_address
argument_list|(
name|lhs
argument_list|)
expr_stmt|;
if|if
condition|(
name|base_address
operator|&&
name|SSA_VAR_P
argument_list|(
name|base_address
argument_list|)
operator|&&
name|ZERO_SSA_OPERANDS
argument_list|(
name|stmt
argument_list|,
name|SSA_OP_VMAYDEF
operator||
name|SSA_OP_VMUSTDEF
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"statement makes a memory store, but has no "
literal|"V_MAY_DEFS nor V_MUST_DEFS"
argument_list|)
expr_stmt|;
name|print_generic_stmt
argument_list|(
name|stderr
argument_list|,
name|stmt
argument_list|,
name|TDF_VOPS
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
block|}
name|FOR_EACH_SSA_USE_OPERAND
argument_list|(
argument|use_p
argument_list|,
argument|stmt
argument_list|,
argument|iter
argument_list|,
argument|SSA_OP_ALL_USES | SSA_OP_ALL_KILLS
argument_list|)
block|{
name|op
operator|=
name|USE_FROM_PTR
argument_list|(
name|use_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|verify_use
argument_list|(
name|bb
argument_list|,
name|definition_block
index|[
name|SSA_NAME_VERSION
argument_list|(
name|op
argument_list|)
index|]
argument_list|,
name|use_p
argument_list|,
name|stmt
argument_list|,
name|false
argument_list|,
operator|!
name|is_gimple_reg
argument_list|(
name|op
argument_list|)
argument_list|,
name|names_defined_in_bb
argument_list|)
condition|)
goto|goto
name|err
goto|;
block|}
name|FOR_EACH_SSA_TREE_OPERAND
argument_list|(
argument|op
argument_list|,
argument|stmt
argument_list|,
argument|iter
argument_list|,
argument|SSA_OP_ALL_DEFS
argument_list|)
name|bitmap_set_bit
argument_list|(
name|names_defined_in_bb
argument_list|,
name|SSA_NAME_VERSION
argument_list|(
name|op
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|bitmap_clear
argument_list|(
name|names_defined_in_bb
argument_list|)
expr_stmt|;
block|}
comment|/* Finally, verify alias information.  */
name|verify_alias_info
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|definition_block
argument_list|)
expr_stmt|;
comment|/* Restore the dominance information to its prior known state, so      that we do not perturb the compiler's subsequent behavior.  */
if|if
condition|(
name|orig_dom_state
operator|==
name|DOM_NONE
condition|)
name|free_dominance_info
argument_list|(
name|CDI_DOMINATORS
argument_list|)
expr_stmt|;
else|else
name|dom_computed
index|[
name|CDI_DOMINATORS
index|]
operator|=
name|orig_dom_state
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|names_defined_in_bb
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_TREE_SSA_VERIFY
argument_list|)
expr_stmt|;
return|return;
name|err
label|:
name|internal_error
argument_list|(
literal|"verify_ssa failed"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return true if the uid in both int tree maps are equal.  */
end_comment

begin_function
name|int
name|int_tree_map_eq
parameter_list|(
specifier|const
name|void
modifier|*
name|va
parameter_list|,
specifier|const
name|void
modifier|*
name|vb
parameter_list|)
block|{
specifier|const
name|struct
name|int_tree_map
modifier|*
name|a
init|=
operator|(
specifier|const
expr|struct
name|int_tree_map
operator|*
operator|)
name|va
decl_stmt|;
specifier|const
name|struct
name|int_tree_map
modifier|*
name|b
init|=
operator|(
specifier|const
expr|struct
name|int_tree_map
operator|*
operator|)
name|vb
decl_stmt|;
return|return
operator|(
name|a
operator|->
name|uid
operator|==
name|b
operator|->
name|uid
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Hash a UID in a int_tree_map.  */
end_comment

begin_function
name|unsigned
name|int
name|int_tree_map_hash
parameter_list|(
specifier|const
name|void
modifier|*
name|item
parameter_list|)
block|{
return|return
operator|(
operator|(
specifier|const
expr|struct
name|int_tree_map
operator|*
operator|)
name|item
operator|)
operator|->
name|uid
return|;
block|}
end_function

begin_comment
comment|/* Initialize global DFA and SSA structures.  */
end_comment

begin_function
name|void
name|init_tree_ssa
parameter_list|(
name|void
parameter_list|)
block|{
name|referenced_vars
operator|=
name|htab_create_ggc
argument_list|(
literal|20
argument_list|,
name|int_tree_map_hash
argument_list|,
name|int_tree_map_eq
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|default_defs
operator|=
name|htab_create_ggc
argument_list|(
literal|20
argument_list|,
name|int_tree_map_hash
argument_list|,
name|int_tree_map_eq
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|call_clobbered_vars
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|addressable_vars
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|init_alias_heapvars
argument_list|()
expr_stmt|;
name|init_ssanames
argument_list|()
expr_stmt|;
name|init_phinodes
argument_list|()
expr_stmt|;
name|global_var
operator|=
name|NULL_TREE
expr_stmt|;
name|aliases_computed_p
operator|=
name|false
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Deallocate memory associated with SSA data structures for FNDECL.  */
end_comment

begin_function
name|void
name|delete_tree_ssa
parameter_list|(
name|void
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|block_stmt_iterator
name|bsi
decl_stmt|;
name|referenced_var_iterator
name|rvi
decl_stmt|;
name|tree
name|var
decl_stmt|;
comment|/* Release any ssa_names still in use.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_ssa_names
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|var
init|=
name|ssa_name
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|var
operator|&&
name|TREE_CODE
argument_list|(
name|var
argument_list|)
operator|==
name|SSA_NAME
condition|)
block|{
name|SSA_NAME_IMM_USE_NODE
argument_list|(
name|var
argument_list|)
operator|.
name|prev
operator|=
operator|&
operator|(
name|SSA_NAME_IMM_USE_NODE
argument_list|(
name|var
argument_list|)
operator|)
expr_stmt|;
name|SSA_NAME_IMM_USE_NODE
argument_list|(
name|var
argument_list|)
operator|.
name|next
operator|=
operator|&
operator|(
name|SSA_NAME_IMM_USE_NODE
argument_list|(
name|var
argument_list|)
operator|)
expr_stmt|;
block|}
name|release_ssa_name
argument_list|(
name|var
argument_list|)
expr_stmt|;
block|}
comment|/* Remove annotations from every tree in the function.  */
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
for|for
control|(
name|bsi
operator|=
name|bsi_start
argument_list|(
name|bb
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|;
name|bsi_next
argument_list|(
operator|&
name|bsi
argument_list|)
control|)
block|{
name|tree
name|stmt
init|=
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
decl_stmt|;
name|stmt_ann_t
name|ann
init|=
name|get_stmt_ann
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
name|free_ssa_operands
argument_list|(
operator|&
name|ann
operator|->
name|operands
argument_list|)
expr_stmt|;
name|ann
operator|->
name|addresses_taken
operator|=
literal|0
expr_stmt|;
name|mark_stmt_modified
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
block|}
name|set_phi_nodes
argument_list|(
name|bb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* Remove annotations from every referenced variable.  */
name|FOR_EACH_REFERENCED_VAR
argument_list|(
argument|var
argument_list|,
argument|rvi
argument_list|)
block|{
name|ggc_free
argument_list|(
name|var
operator|->
name|common
operator|.
name|ann
argument_list|)
expr_stmt|;
name|var
operator|->
name|common
operator|.
name|ann
operator|=
name|NULL
expr_stmt|;
block|}
name|htab_delete
argument_list|(
name|referenced_vars
argument_list|)
expr_stmt|;
name|referenced_vars
operator|=
name|NULL
expr_stmt|;
name|fini_ssanames
argument_list|()
expr_stmt|;
name|fini_phinodes
argument_list|()
expr_stmt|;
name|global_var
operator|=
name|NULL_TREE
expr_stmt|;
name|htab_delete
argument_list|(
name|default_defs
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|call_clobbered_vars
argument_list|)
expr_stmt|;
name|call_clobbered_vars
operator|=
name|NULL
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|addressable_vars
argument_list|)
expr_stmt|;
name|addressable_vars
operator|=
name|NULL
expr_stmt|;
name|modified_noreturn_calls
operator|=
name|NULL
expr_stmt|;
name|aliases_computed_p
operator|=
name|false
expr_stmt|;
name|delete_alias_heapvars
argument_list|()
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|need_ssa_update_p
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return true if the conversion from INNER_TYPE to OUTER_TYPE is a    useless type conversion, otherwise return false.  */
end_comment

begin_function
name|bool
name|tree_ssa_useless_type_conversion_1
parameter_list|(
name|tree
name|outer_type
parameter_list|,
name|tree
name|inner_type
parameter_list|)
block|{
if|if
condition|(
name|inner_type
operator|==
name|outer_type
condition|)
return|return
name|true
return|;
comment|/* Changes in machine mode are never useless conversions.  */
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|inner_type
argument_list|)
operator|!=
name|TYPE_MODE
argument_list|(
name|outer_type
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* If the inner and outer types are effectively the same, then      strip the type conversion and enter the equivalence into      the table.  */
if|if
condition|(
name|lang_hooks
operator|.
name|types_compatible_p
argument_list|(
name|inner_type
argument_list|,
name|outer_type
argument_list|)
condition|)
return|return
name|true
return|;
comment|/* If both types are pointers and the outer type is a (void *), then      the conversion is not necessary.  The opposite is not true since      that conversion would result in a loss of information if the      equivalence was used.  Consider an indirect function call where      we need to know the exact type of the function to correctly      implement the ABI.  */
elseif|else
if|if
condition|(
name|POINTER_TYPE_P
argument_list|(
name|inner_type
argument_list|)
operator|&&
name|POINTER_TYPE_P
argument_list|(
name|outer_type
argument_list|)
operator|&&
name|TYPE_REF_CAN_ALIAS_ALL
argument_list|(
name|inner_type
argument_list|)
operator|==
name|TYPE_REF_CAN_ALIAS_ALL
argument_list|(
name|outer_type
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|outer_type
argument_list|)
argument_list|)
operator|==
name|VOID_TYPE
condition|)
return|return
name|true
return|;
comment|/* Don't lose casts between pointers to volatile and non-volatile      qualified types.  Doing so would result in changing the semantics      of later accesses.  */
elseif|else
if|if
condition|(
name|POINTER_TYPE_P
argument_list|(
name|inner_type
argument_list|)
operator|&&
name|POINTER_TYPE_P
argument_list|(
name|outer_type
argument_list|)
operator|&&
name|TYPE_VOLATILE
argument_list|(
name|TREE_TYPE
argument_list|(
name|outer_type
argument_list|)
argument_list|)
operator|!=
name|TYPE_VOLATILE
argument_list|(
name|TREE_TYPE
argument_list|(
name|inner_type
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Pointers/references are equivalent if their pointed to types      are effectively the same.  This allows to strip conversions between      pointer types with different type qualifiers.  */
elseif|else
if|if
condition|(
name|POINTER_TYPE_P
argument_list|(
name|inner_type
argument_list|)
operator|&&
name|POINTER_TYPE_P
argument_list|(
name|outer_type
argument_list|)
operator|&&
name|TYPE_REF_CAN_ALIAS_ALL
argument_list|(
name|inner_type
argument_list|)
operator|==
name|TYPE_REF_CAN_ALIAS_ALL
argument_list|(
name|outer_type
argument_list|)
operator|&&
name|lang_hooks
operator|.
name|types_compatible_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|inner_type
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|outer_type
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
comment|/* If both the inner and outer types are integral types, then the      conversion is not necessary if they have the same mode and      signedness and precision, and both or neither are boolean.  Some      code assumes an invariant that boolean types stay boolean and do      not become 1-bit bit-field types.  Note that types with precision      not using all bits of the mode (such as bit-field types in C)      mean that testing of precision is necessary.  */
elseif|else
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|inner_type
argument_list|)
operator|&&
name|INTEGRAL_TYPE_P
argument_list|(
name|outer_type
argument_list|)
operator|&&
name|TYPE_UNSIGNED
argument_list|(
name|inner_type
argument_list|)
operator|==
name|TYPE_UNSIGNED
argument_list|(
name|outer_type
argument_list|)
operator|&&
name|TYPE_PRECISION
argument_list|(
name|inner_type
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|outer_type
argument_list|)
operator|&&
name|simple_cst_equal
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|inner_type
argument_list|)
argument_list|,
name|TYPE_MAX_VALUE
argument_list|(
name|outer_type
argument_list|)
argument_list|)
operator|&&
name|simple_cst_equal
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|inner_type
argument_list|)
argument_list|,
name|TYPE_MIN_VALUE
argument_list|(
name|outer_type
argument_list|)
argument_list|)
condition|)
block|{
name|bool
name|first_boolean
init|=
operator|(
name|TREE_CODE
argument_list|(
name|inner_type
argument_list|)
operator|==
name|BOOLEAN_TYPE
operator|)
decl_stmt|;
name|bool
name|second_boolean
init|=
operator|(
name|TREE_CODE
argument_list|(
name|outer_type
argument_list|)
operator|==
name|BOOLEAN_TYPE
operator|)
decl_stmt|;
if|if
condition|(
name|first_boolean
operator|==
name|second_boolean
condition|)
return|return
name|true
return|;
block|}
comment|/* Recurse for complex types.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|inner_type
argument_list|)
operator|==
name|COMPLEX_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|outer_type
argument_list|)
operator|==
name|COMPLEX_TYPE
operator|&&
name|tree_ssa_useless_type_conversion_1
argument_list|(
name|TREE_TYPE
argument_list|(
name|outer_type
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|inner_type
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Return true if EXPR is a useless type conversion, otherwise return    false.  */
end_comment

begin_function
name|bool
name|tree_ssa_useless_type_conversion
parameter_list|(
name|tree
name|expr
parameter_list|)
block|{
comment|/* If we have an assignment that merely uses a NOP_EXPR to change      the top of the RHS to the type of the LHS and the type conversion      is "safe", then strip away the type conversion so that we can      enter LHS = RHS into the const_and_copies table.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|CONVERT_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|VIEW_CONVERT_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|NON_LVALUE_EXPR
condition|)
return|return
name|tree_ssa_useless_type_conversion_1
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Returns true if statement STMT may read memory.  */
end_comment

begin_function
name|bool
name|stmt_references_memory_p
parameter_list|(
name|tree
name|stmt
parameter_list|)
block|{
name|stmt_ann_t
name|ann
init|=
name|stmt_ann
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
if|if
condition|(
name|ann
operator|->
name|has_volatile_ops
condition|)
return|return
name|true
return|;
return|return
operator|(
operator|!
name|ZERO_SSA_OPERANDS
argument_list|(
name|stmt
argument_list|,
name|SSA_OP_ALL_VIRTUALS
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Internal helper for walk_use_def_chains.  VAR, FN and DATA are as    described in walk_use_def_chains.        VISITED is a pointer set used to mark visited SSA_NAMEs to avoid       infinite loops.  We used to have a bitmap for this to just mark       SSA versions we had visited.  But non-sparse bitmaps are way too       expensive, while sparse bitmaps may cause quadratic behavior.     IS_DFS is true if the caller wants to perform a depth-first search       when visiting PHI nodes.  A DFS will visit each PHI argument and       call FN after each one.  Otherwise, all the arguments are       visited first and then FN is called with each of the visited       arguments in a separate pass.  */
end_comment

begin_function
specifier|static
name|bool
name|walk_use_def_chains_1
parameter_list|(
name|tree
name|var
parameter_list|,
name|walk_use_def_chains_fn
name|fn
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|pointer_set_t
modifier|*
name|visited
parameter_list|,
name|bool
name|is_dfs
parameter_list|)
block|{
name|tree
name|def_stmt
decl_stmt|;
if|if
condition|(
name|pointer_set_insert
argument_list|(
name|visited
argument_list|,
name|var
argument_list|)
condition|)
return|return
name|false
return|;
name|def_stmt
operator|=
name|SSA_NAME_DEF_STMT
argument_list|(
name|var
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|def_stmt
argument_list|)
operator|!=
name|PHI_NODE
condition|)
block|{
comment|/* If we reached the end of the use-def chain, call FN.  */
return|return
name|fn
argument_list|(
name|var
argument_list|,
name|def_stmt
argument_list|,
name|data
argument_list|)
return|;
block|}
else|else
block|{
name|int
name|i
decl_stmt|;
comment|/* When doing a breadth-first search, call FN before following the 	 use-def links for each argument.  */
if|if
condition|(
operator|!
name|is_dfs
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PHI_NUM_ARGS
argument_list|(
name|def_stmt
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|fn
argument_list|(
name|PHI_ARG_DEF
argument_list|(
name|def_stmt
argument_list|,
name|i
argument_list|)
argument_list|,
name|def_stmt
argument_list|,
name|data
argument_list|)
condition|)
return|return
name|true
return|;
comment|/* Follow use-def links out of each PHI argument.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PHI_NUM_ARGS
argument_list|(
name|def_stmt
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|arg
init|=
name|PHI_ARG_DEF
argument_list|(
name|def_stmt
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|SSA_NAME
operator|&&
name|walk_use_def_chains_1
argument_list|(
name|arg
argument_list|,
name|fn
argument_list|,
name|data
argument_list|,
name|visited
argument_list|,
name|is_dfs
argument_list|)
condition|)
return|return
name|true
return|;
block|}
comment|/* When doing a depth-first search, call FN after following the 	 use-def links for each argument.  */
if|if
condition|(
name|is_dfs
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PHI_NUM_ARGS
argument_list|(
name|def_stmt
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|fn
argument_list|(
name|PHI_ARG_DEF
argument_list|(
name|def_stmt
argument_list|,
name|i
argument_list|)
argument_list|,
name|def_stmt
argument_list|,
name|data
argument_list|)
condition|)
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Walk use-def chains starting at the SSA variable VAR.  Call    function FN at each reaching definition found.  FN takes three    arguments: VAR, its defining statement (DEF_STMT) and a generic    pointer to whatever state information that FN may want to maintain    (DATA).  FN is able to stop the walk by returning true, otherwise    in order to continue the walk, FN should return false.       Note, that if DEF_STMT is a PHI node, the semantics are slightly    different.  The first argument to FN is no longer the original    variable VAR, but the PHI argument currently being examined.  If FN    wants to get at VAR, it should call PHI_RESULT (PHI).     If IS_DFS is true, this function will:  	1- walk the use-def chains for all the PHI arguments, and, 	2- call (*FN) (ARG, PHI, DATA) on all the PHI arguments.     If IS_DFS is false, the two steps above are done in reverse order    (i.e., a breadth-first search).  */
end_comment

begin_function
name|void
name|walk_use_def_chains
parameter_list|(
name|tree
name|var
parameter_list|,
name|walk_use_def_chains_fn
name|fn
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|bool
name|is_dfs
parameter_list|)
block|{
name|tree
name|def_stmt
decl_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|var
argument_list|)
operator|==
name|SSA_NAME
argument_list|)
expr_stmt|;
name|def_stmt
operator|=
name|SSA_NAME_DEF_STMT
argument_list|(
name|var
argument_list|)
expr_stmt|;
comment|/* We only need to recurse if the reaching definition comes from a PHI      node.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|def_stmt
argument_list|)
operator|!=
name|PHI_NODE
condition|)
call|(
modifier|*
name|fn
call|)
argument_list|(
name|var
argument_list|,
name|def_stmt
argument_list|,
name|data
argument_list|)
expr_stmt|;
else|else
block|{
name|struct
name|pointer_set_t
modifier|*
name|visited
init|=
name|pointer_set_create
argument_list|()
decl_stmt|;
name|walk_use_def_chains_1
argument_list|(
name|var
argument_list|,
name|fn
argument_list|,
name|data
argument_list|,
name|visited
argument_list|,
name|is_dfs
argument_list|)
expr_stmt|;
name|pointer_set_destroy
argument_list|(
name|visited
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Emit warnings for uninitialized variables.  This is done in two passes.     The first pass notices real uses of SSA names with default definitions.    Such uses are unconditionally uninitialized, and we can be certain that    such a use is a mistake.  This pass is run before most optimizations,    so that we catch as many as we can.     The second pass follows PHI nodes to find uses that are potentially    uninitialized.  In this case we can't necessarily prove that the use    is really uninitialized.  This pass is run after most optimizations,    so that we thread as many jumps and possible, and delete as much dead    code as possible, in order to reduce false positives.  We also look    again for plain uninitialized variables, since optimization may have    changed conditionally uninitialized to unconditionally uninitialized.  */
end_comment

begin_comment
comment|/* Emit a warning for T, an SSA_NAME, being uninitialized.  The exact    warning text is in MSGID and LOCUS may contain a location or be null.  */
end_comment

begin_function
specifier|static
name|void
name|warn_uninit
parameter_list|(
name|tree
name|t
parameter_list|,
specifier|const
name|char
modifier|*
name|gmsgid
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|tree
name|var
init|=
name|SSA_NAME_VAR
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|tree
name|def
init|=
name|SSA_NAME_DEF_STMT
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|tree
name|context
init|=
operator|(
name|tree
operator|)
name|data
decl_stmt|;
name|location_t
modifier|*
name|locus
decl_stmt|,
modifier|*
name|fun_locus
decl_stmt|;
comment|/* Default uses (indicated by an empty definition statement),      are uninitialized.  */
if|if
condition|(
operator|!
name|IS_EMPTY_STMT
argument_list|(
name|def
argument_list|)
condition|)
return|return;
comment|/* Except for PARMs of course, which are always initialized.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|var
argument_list|)
operator|==
name|PARM_DECL
condition|)
return|return;
comment|/* Hard register variables get their initial value from the ether.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|var
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_HARD_REGISTER
argument_list|(
name|var
argument_list|)
condition|)
return|return;
comment|/* TREE_NO_WARNING either means we already warned, or the front end      wishes to suppress the warning.  */
if|if
condition|(
name|TREE_NO_WARNING
argument_list|(
name|var
argument_list|)
condition|)
return|return;
name|locus
operator|=
operator|(
name|context
operator|!=
name|NULL
operator|&&
name|EXPR_HAS_LOCATION
argument_list|(
name|context
argument_list|)
condition|?
name|EXPR_LOCUS
argument_list|(
name|context
argument_list|)
else|:
operator|&
name|DECL_SOURCE_LOCATION
argument_list|(
name|var
argument_list|)
operator|)
expr_stmt|;
name|warning
argument_list|(
literal|0
argument_list|,
name|gmsgid
argument_list|,
name|locus
argument_list|,
name|var
argument_list|)
expr_stmt|;
name|fun_locus
operator|=
operator|&
name|DECL_SOURCE_LOCATION
argument_list|(
name|cfun
operator|->
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|locus
operator|->
name|file
operator|!=
name|fun_locus
operator|->
name|file
operator|||
name|locus
operator|->
name|line
operator|<
name|fun_locus
operator|->
name|line
operator|||
name|locus
operator|->
name|line
operator|>
name|cfun
operator|->
name|function_end_locus
operator|.
name|line
condition|)
name|inform
argument_list|(
literal|"%J%qD was declared here"
argument_list|,
name|var
argument_list|,
name|var
argument_list|)
expr_stmt|;
name|TREE_NO_WARNING
argument_list|(
name|var
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called via walk_tree, look for SSA_NAMEs that have empty definitions    and warn about them.  */
end_comment

begin_function
specifier|static
name|tree
name|warn_uninitialized_var
parameter_list|(
name|tree
modifier|*
name|tp
parameter_list|,
name|int
modifier|*
name|walk_subtrees
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|tree
name|t
init|=
operator|*
name|tp
decl_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|SSA_NAME
case|:
comment|/* We only do data flow with SSA_NAMEs, so that's all we 	 can warn about.  */
name|warn_uninit
argument_list|(
name|t
argument_list|,
literal|"%H%qD is used uninitialized in this function"
argument_list|,
name|data
argument_list|)
expr_stmt|;
operator|*
name|walk_subtrees
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|REALPART_EXPR
case|:
case|case
name|IMAGPART_EXPR
case|:
comment|/* The total store transformation performed during gimplification 	 creates uninitialized variable uses.  If all is well, these will 	 be optimized away, so don't warn now.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SSA_NAME
condition|)
operator|*
name|walk_subtrees
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|IS_TYPE_OR_DECL_P
argument_list|(
name|t
argument_list|)
condition|)
operator|*
name|walk_subtrees
operator|=
literal|0
expr_stmt|;
break|break;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Look for inputs to PHI that are SSA_NAMEs that have empty definitions    and warn about them.  */
end_comment

begin_function
specifier|static
name|void
name|warn_uninitialized_phi
parameter_list|(
name|tree
name|phi
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|n
init|=
name|PHI_NUM_ARGS
argument_list|(
name|phi
argument_list|)
decl_stmt|;
comment|/* Don't look at memory tags.  */
if|if
condition|(
operator|!
name|is_gimple_reg
argument_list|(
name|PHI_RESULT
argument_list|(
name|phi
argument_list|)
argument_list|)
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|op
init|=
name|PHI_ARG_DEF
argument_list|(
name|phi
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SSA_NAME
condition|)
name|warn_uninit
argument_list|(
name|op
argument_list|,
literal|"%H%qD may be used uninitialized in this function"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|execute_early_warn_uninitialized
parameter_list|(
name|void
parameter_list|)
block|{
name|block_stmt_iterator
name|bsi
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
for|for
control|(
name|bsi
operator|=
name|bsi_start
argument_list|(
name|bb
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|;
name|bsi_next
argument_list|(
operator|&
name|bsi
argument_list|)
control|)
block|{
name|tree
name|context
init|=
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
decl_stmt|;
name|walk_tree
argument_list|(
name|bsi_stmt_ptr
argument_list|(
name|bsi
argument_list|)
argument_list|,
name|warn_uninitialized_var
argument_list|,
name|context
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|execute_late_warn_uninitialized
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|tree
name|phi
decl_stmt|;
comment|/* Re-do the plain uninitialized variable check, as optimization may have      straightened control flow.  Do this first so that we don't accidentally      get a "may be" warning when we'd have seen an "is" warning later.  */
name|execute_early_warn_uninitialized
argument_list|()
expr_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
for|for
control|(
name|phi
operator|=
name|phi_nodes
argument_list|(
name|bb
argument_list|)
init|;
name|phi
condition|;
name|phi
operator|=
name|PHI_CHAIN
argument_list|(
name|phi
argument_list|)
control|)
name|warn_uninitialized_phi
argument_list|(
name|phi
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|gate_warn_uninitialized
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|warn_uninitialized
operator|!=
literal|0
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|tree_opt_pass
name|pass_early_warn_uninitialized
init|=
block|{
name|NULL
block|,
comment|/* name */
name|gate_warn_uninitialized
block|,
comment|/* gate */
name|execute_early_warn_uninitialized
block|,
comment|/* execute */
name|NULL
block|,
comment|/* sub */
name|NULL
block|,
comment|/* next */
literal|0
block|,
comment|/* static_pass_number */
literal|0
block|,
comment|/* tv_id */
name|PROP_ssa
block|,
comment|/* properties_required */
literal|0
block|,
comment|/* properties_provided */
literal|0
block|,
comment|/* properties_destroyed */
literal|0
block|,
comment|/* todo_flags_start */
literal|0
block|,
comment|/* todo_flags_finish */
literal|0
comment|/* letter */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|tree_opt_pass
name|pass_late_warn_uninitialized
init|=
block|{
name|NULL
block|,
comment|/* name */
name|gate_warn_uninitialized
block|,
comment|/* gate */
name|execute_late_warn_uninitialized
block|,
comment|/* execute */
name|NULL
block|,
comment|/* sub */
name|NULL
block|,
comment|/* next */
literal|0
block|,
comment|/* static_pass_number */
literal|0
block|,
comment|/* tv_id */
name|PROP_ssa
block|,
comment|/* properties_required */
literal|0
block|,
comment|/* properties_provided */
literal|0
block|,
comment|/* properties_destroyed */
literal|0
block|,
comment|/* todo_flags_start */
literal|0
block|,
comment|/* todo_flags_finish */
literal|0
comment|/* letter */
block|}
decl_stmt|;
end_decl_stmt

end_unit

