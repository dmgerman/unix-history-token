begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Optimize jump instructions, for GNU compiler.    Copyright (C) 1987, 1988, 1989, 1991, 1992, 1993, 1994, 1995, 1996, 1997    1998, 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* This is the pathetic reminder of old fame of the jump-optimization pass    of the compiler.  Now it contains basically set of utility function to    operate with jumps.     Each CODE_LABEL has a count of the times it is used    stored in the LABEL_NUSES internal field, and each JUMP_INSN    has one label that it refers to stored in the    JUMP_LABEL internal field.  With this we can detect labels that    become unused because of the deletion of all the jumps that    formerly used them.  The JUMP_LABEL info is sometimes looked    at by later passes.     The subroutines delete_insn, redirect_jump, and invert_jump are used    from other passes as well.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"insn-attr.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"reload.h"
end_include

begin_include
include|#
directive|include
file|"predict.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_comment
comment|/* Optimize jump y; x: ... y: jumpif... x?    Don't know if it is worth bothering with.  */
end_comment

begin_comment
comment|/* Optimize two cases of conditional jump to conditional jump?    This can never delete any instruction or make anything dead,    or even change what is live at any point.    So perhaps let combiner do it.  */
end_comment

begin_function_decl
specifier|static
name|rtx
name|next_nonnote_insn_in_loop
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|init_label_info
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mark_all_labels
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|duplicate_loop_exit_test
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|delete_computation
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|redirect_exp_1
parameter_list|(
name|rtx
modifier|*
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|redirect_exp
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|invert_exp_1
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|invert_exp
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|returnjump_p_1
parameter_list|(
name|rtx
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|delete_prior_computation
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* Alternate entry into the jump optimizer.  This entry point only rebuilds    the JUMP_LABEL field in jumping insns and REG_LABEL notes in non-jumping    instructions.  */
end_comment

begin_function
name|void
name|rebuild_jump_labels
parameter_list|(
name|rtx
name|f
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
name|timevar_push
argument_list|(
name|TV_REBUILD_JUMP
argument_list|)
expr_stmt|;
name|init_label_info
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|mark_all_labels
argument_list|(
name|f
argument_list|)
expr_stmt|;
comment|/* Keep track of labels used from static data; we don't track them      closely enough to delete them here, so make sure their reference      count doesn't drop to zero.  */
for|for
control|(
name|insn
operator|=
name|forced_labels
init|;
name|insn
condition|;
name|insn
operator|=
name|XEXP
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CODE_LABEL
condition|)
name|LABEL_NUSES
argument_list|(
name|XEXP
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|++
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_REBUILD_JUMP
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Some old code expects exactly one BARRIER as the NEXT_INSN of a    non-fallthru insn.  This is not generally true, as multiple barriers    may have crept in, or the BARRIER may be separated from the last    real insn by one or more NOTEs.     This simple pass moves barriers and removes duplicates so that the    old code is happy.  */
end_comment

begin_function
name|void
name|cleanup_barriers
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|,
name|next
decl_stmt|,
name|prev
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|next
control|)
block|{
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|BARRIER
condition|)
block|{
name|prev
operator|=
name|prev_nonnote_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|prev
argument_list|)
operator|==
name|BARRIER
condition|)
name|delete_barrier
argument_list|(
name|insn
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|prev
operator|!=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
condition|)
name|reorder_insns
argument_list|(
name|insn
argument_list|,
name|insn
argument_list|,
name|prev
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the next insn after INSN that is not a NOTE and is in the loop,    i.e. when there is no such INSN before NOTE_INSN_LOOP_END return NULL_RTX.    This routine does not look inside SEQUENCEs.  */
end_comment

begin_function
specifier|static
name|rtx
name|next_nonnote_insn_in_loop
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
while|while
condition|(
name|insn
condition|)
block|{
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE
condition|)
break|break;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_LOOP_END
condition|)
return|return
name|NULL_RTX
return|;
block|}
return|return
name|insn
return|;
block|}
end_function

begin_function
name|void
name|copy_loop_headers
parameter_list|(
name|rtx
name|f
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|,
name|next
decl_stmt|;
comment|/* Now iterate optimizing jumps until nothing changes over one pass.  */
for|for
control|(
name|insn
operator|=
name|f
init|;
name|insn
condition|;
name|insn
operator|=
name|next
control|)
block|{
name|rtx
name|temp
decl_stmt|,
name|temp1
decl_stmt|;
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* See if this is a NOTE_INSN_LOOP_BEG followed by an unconditional 	 jump.  Try to optimize by duplicating the loop exit test if so. 	 This is only safe immediately after regscan, because it uses 	 the values of regno_first_uid and regno_last_uid.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_LOOP_BEG
operator|&&
operator|(
name|temp1
operator|=
name|next_nonnote_insn_in_loop
argument_list|(
name|insn
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|any_uncondjump_p
argument_list|(
name|temp1
argument_list|)
operator|&&
name|onlyjump_p
argument_list|(
name|temp1
argument_list|)
condition|)
block|{
name|temp
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|duplicate_loop_exit_test
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
name|void
name|purge_line_number_notes
parameter_list|(
name|rtx
name|f
parameter_list|)
block|{
name|rtx
name|last_note
init|=
literal|0
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
comment|/* Delete extraneous line number notes.      Note that two consecutive notes for different lines are not really      extraneous.  There should be some indication where that line belonged,      even if it became empty.  */
for|for
control|(
name|insn
operator|=
name|f
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
block|{
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_FUNCTION_BEG
condition|)
comment|/* Any previous line note was for the prologue; gdb wants a new 	     note after the prologue even if it is for the same line.  */
name|last_note
operator|=
name|NULL_RTX
expr_stmt|;
elseif|else
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|>=
literal|0
condition|)
block|{
comment|/* Delete this note if it is identical to previous note.  */
if|if
condition|(
name|last_note
operator|&&
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_SOURCE_FILE
argument_list|(
name|last_note
argument_list|)
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_LINE_NUMBER
argument_list|(
name|last_note
argument_list|)
condition|)
block|{
name|delete_related_insns
argument_list|(
name|insn
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|last_note
operator|=
name|insn
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Initialize LABEL_NUSES and JUMP_LABEL fields.  Delete any REG_LABEL    notes whose labels don't occur in the insn any more.  Returns the    largest INSN_UID found.  */
end_comment

begin_function
specifier|static
name|void
name|init_label_info
parameter_list|(
name|rtx
name|f
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|f
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
condition|)
name|LABEL_NUSES
argument_list|(
name|insn
argument_list|)
operator|=
operator|(
name|LABEL_PRESERVE_P
argument_list|(
name|insn
argument_list|)
operator|!=
literal|0
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
name|rtx
name|note
decl_stmt|,
name|next
decl_stmt|;
for|for
control|(
name|note
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|note
condition|;
name|note
operator|=
name|next
control|)
block|{
name|next
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
operator|==
name|REG_LABEL
operator|&&
operator|!
name|reg_mentioned_p
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
name|remove_note
argument_list|(
name|insn
argument_list|,
name|note
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Mark the label each jump jumps to.    Combine consecutive labels, and count uses of labels.  */
end_comment

begin_function
specifier|static
name|void
name|mark_all_labels
parameter_list|(
name|rtx
name|f
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|f
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|CALL_PLACEHOLDER
condition|)
block|{
name|mark_all_labels
argument_list|(
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|mark_all_labels
argument_list|(
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|mark_all_labels
argument_list|(
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Canonicalize the tail recursion label attached to the 	       CALL_PLACEHOLDER insn.  */
if|if
condition|(
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|rtx
name|label_ref
init|=
name|gen_rtx_LABEL_REF
argument_list|(
name|VOIDmode
argument_list|,
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|3
argument_list|)
argument_list|)
decl_stmt|;
name|mark_jump_label
argument_list|(
name|label_ref
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|3
argument_list|)
operator|=
name|XEXP
argument_list|(
name|label_ref
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
name|mark_jump_label
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|INSN_DELETED_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
block|{
comment|/* When we know the LABEL_REF contained in a REG used in 	       an indirect jump, we'll have a REG_LABEL note so that 	       flow can tell where it's going.  */
if|if
condition|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
operator|==
literal|0
condition|)
block|{
name|rtx
name|label_note
init|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_LABEL
argument_list|,
name|NULL_RTX
argument_list|)
decl_stmt|;
if|if
condition|(
name|label_note
condition|)
block|{
comment|/* But a LABEL_REF around the REG_LABEL note, so 		       that we can canonicalize it.  */
name|rtx
name|label_ref
init|=
name|gen_rtx_LABEL_REF
argument_list|(
name|VOIDmode
argument_list|,
name|XEXP
argument_list|(
name|label_note
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|mark_jump_label
argument_list|(
name|label_ref
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|label_note
argument_list|,
literal|0
argument_list|)
operator|=
name|XEXP
argument_list|(
name|label_ref
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
operator|=
name|XEXP
argument_list|(
name|label_note
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* LOOP_START is a NOTE_INSN_LOOP_BEG note that is followed by an unconditional    jump.  Assume that this unconditional jump is to the exit test code.  If    the code is sufficiently simple, make a copy of it before INSN,    followed by a jump to the exit of the loop.  Then delete the unconditional    jump after INSN.     Return 1 if we made the change, else 0.     This is only safe immediately after a regscan pass because it uses the    values of regno_first_uid and regno_last_uid.  */
end_comment

begin_function
specifier|static
name|int
name|duplicate_loop_exit_test
parameter_list|(
name|rtx
name|loop_start
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|,
name|set
decl_stmt|,
name|reg
decl_stmt|,
name|p
decl_stmt|,
name|link
decl_stmt|;
name|rtx
name|copy
init|=
literal|0
decl_stmt|,
name|first_copy
init|=
literal|0
decl_stmt|;
name|int
name|num_insns
init|=
literal|0
decl_stmt|;
name|rtx
name|exitcode
init|=
name|NEXT_INSN
argument_list|(
name|JUMP_LABEL
argument_list|(
name|next_nonnote_insn_in_loop
argument_list|(
name|loop_start
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|lastexit
decl_stmt|;
name|int
name|max_reg
init|=
name|max_reg_num
argument_list|()
decl_stmt|;
name|rtx
modifier|*
name|reg_map
init|=
literal|0
decl_stmt|;
name|rtx
name|loop_pre_header_label
decl_stmt|;
comment|/* Scan the exit code.  We do not perform this optimization if any insn:           is a CALL_INSN 	 is a CODE_LABEL 	 has a REG_RETVAL or REG_LIBCALL note (hard to adjust) 	 is a NOTE_INSN_LOOP_BEG because this means we have a nested loop       We also do not do this if we find an insn with ASM_OPERANDS.  While      this restriction should not be necessary, copying an insn with      ASM_OPERANDS can confuse asm_noperands in some cases.       Also, don't do this if the exit code is more than 20 insns.  */
for|for
control|(
name|insn
operator|=
name|exitcode
init|;
name|insn
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_LOOP_END
operator|)
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
condition|)
block|{
case|case
name|CODE_LABEL
case|:
case|case
name|CALL_INSN
case|:
return|return
literal|0
return|;
case|case
name|NOTE
case|:
if|if
condition|(
name|optimize
operator|<
literal|2
operator|&&
operator|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_BLOCK_BEG
operator|||
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_BLOCK_END
operator|)
condition|)
comment|/* If we were to duplicate this code, we would not move 	       the BLOCK notes, and so debugging the moved code would 	       be difficult.  Thus, we only move the code with -O2 or 	       higher.  */
return|return
literal|0
return|;
break|break;
case|case
name|JUMP_INSN
case|:
case|case
name|INSN
case|:
if|if
condition|(
operator|++
name|num_insns
operator|>
literal|20
operator|||
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_RETVAL
argument_list|,
name|NULL_RTX
argument_list|)
operator|||
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_LIBCALL
argument_list|,
name|NULL_RTX
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
default|default:
break|break;
block|}
block|}
comment|/* Unless INSN is zero, we can do the optimization.  */
if|if
condition|(
name|insn
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|lastexit
operator|=
name|insn
expr_stmt|;
comment|/* See if any insn sets a register only used in the loop exit code and      not a user variable.  If so, replace it with a new register.  */
for|for
control|(
name|insn
operator|=
name|exitcode
init|;
name|insn
operator|!=
name|lastexit
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
operator|(
name|set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|reg
operator|=
name|SET_DEST
argument_list|(
name|set
argument_list|)
operator|,
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|REG
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SUBREG
operator|&&
operator|(
name|reg
operator|=
name|SUBREG_REG
argument_list|(
name|reg
argument_list|)
operator|,
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|REG
operator|)
operator|)
operator|)
operator|&&
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|REGNO_FIRST_UID
argument_list|(
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|)
operator|==
name|INSN_UID
argument_list|(
name|insn
argument_list|)
condition|)
block|{
for|for
control|(
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
init|;
name|p
operator|!=
name|lastexit
condition|;
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
control|)
if|if
condition|(
name|REGNO_LAST_UID
argument_list|(
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|)
operator|==
name|INSN_UID
argument_list|(
name|p
argument_list|)
condition|)
break|break;
if|if
condition|(
name|p
operator|!=
name|lastexit
condition|)
block|{
comment|/* We can do the replacement.  Allocate reg_map if this is the 	       first replacement we found.  */
if|if
condition|(
name|reg_map
operator|==
literal|0
condition|)
name|reg_map
operator|=
name|xcalloc
argument_list|(
name|max_reg
argument_list|,
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|REG_LOOP_TEST_P
argument_list|(
name|reg
argument_list|)
operator|=
literal|1
expr_stmt|;
name|reg_map
index|[
name|REGNO
argument_list|(
name|reg
argument_list|)
index|]
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|loop_pre_header_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
comment|/* Now copy each insn.  */
for|for
control|(
name|insn
operator|=
name|exitcode
init|;
name|insn
operator|!=
name|lastexit
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
condition|)
block|{
case|case
name|BARRIER
case|:
name|copy
operator|=
name|emit_barrier_before
argument_list|(
name|loop_start
argument_list|)
expr_stmt|;
break|break;
case|case
name|NOTE
case|:
comment|/* Only copy line-number notes.  */
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|copy
operator|=
name|emit_note_before
argument_list|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
argument_list|,
name|loop_start
argument_list|)
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|copy
argument_list|)
operator|=
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|INSN
case|:
name|copy
operator|=
name|emit_insn_before
argument_list|(
name|copy_insn
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|,
name|loop_start
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_map
condition|)
name|replace_regs
argument_list|(
name|PATTERN
argument_list|(
name|copy
argument_list|)
argument_list|,
name|reg_map
argument_list|,
name|max_reg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|mark_jump_label
argument_list|(
name|PATTERN
argument_list|(
name|copy
argument_list|)
argument_list|,
name|copy
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|INSN_LOCATOR
argument_list|(
name|copy
argument_list|)
operator|=
name|INSN_LOCATOR
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Copy all REG_NOTES except REG_LABEL since mark_jump_label will 	     make them.  */
for|for
control|(
name|link
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|!=
name|REG_LABEL
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|link
argument_list|)
operator|==
name|EXPR_LIST
condition|)
name|REG_NOTES
argument_list|(
name|copy
argument_list|)
operator|=
name|copy_insn_1
argument_list|(
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|copy
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|REG_NOTES
argument_list|(
name|copy
argument_list|)
operator|=
name|copy_insn_1
argument_list|(
name|gen_rtx_INSN_LIST
argument_list|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|copy
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|reg_map
operator|&&
name|REG_NOTES
argument_list|(
name|copy
argument_list|)
condition|)
name|replace_regs
argument_list|(
name|REG_NOTES
argument_list|(
name|copy
argument_list|)
argument_list|,
name|reg_map
argument_list|,
name|max_reg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|JUMP_INSN
case|:
name|copy
operator|=
name|emit_jump_insn_before
argument_list|(
name|copy_insn
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|,
name|loop_start
argument_list|)
expr_stmt|;
name|INSN_LOCATOR
argument_list|(
name|copy
argument_list|)
operator|=
name|INSN_LOCATOR
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_map
condition|)
name|replace_regs
argument_list|(
name|PATTERN
argument_list|(
name|copy
argument_list|)
argument_list|,
name|reg_map
argument_list|,
name|max_reg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|mark_jump_label
argument_list|(
name|PATTERN
argument_list|(
name|copy
argument_list|)
argument_list|,
name|copy
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|REG_NOTES
argument_list|(
name|copy
argument_list|)
operator|=
name|copy_insn_1
argument_list|(
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_map
condition|)
name|replace_regs
argument_list|(
name|REG_NOTES
argument_list|(
name|copy
argument_list|)
argument_list|,
name|reg_map
argument_list|,
name|max_reg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Predict conditional jump that do make loop looping as taken. 	     Other jumps are probably exit conditions, so predict 	     them as untaken.  */
if|if
condition|(
name|any_condjump_p
argument_list|(
name|copy
argument_list|)
condition|)
block|{
name|rtx
name|label
init|=
name|JUMP_LABEL
argument_list|(
name|copy
argument_list|)
decl_stmt|;
if|if
condition|(
name|label
condition|)
block|{
comment|/* The jump_insn after loop_start should be followed 		     by barrier and loopback label.  */
if|if
condition|(
name|prev_nonnote_insn
argument_list|(
name|label
argument_list|)
operator|&&
operator|(
name|prev_nonnote_insn
argument_list|(
name|prev_nonnote_insn
argument_list|(
name|label
argument_list|)
argument_list|)
operator|==
name|next_nonnote_insn
argument_list|(
name|loop_start
argument_list|)
operator|)
condition|)
block|{
name|predict_insn_def
argument_list|(
name|copy
argument_list|,
name|PRED_LOOP_HEADER
argument_list|,
name|TAKEN
argument_list|)
expr_stmt|;
comment|/* To keep pre-header, we need to redirect all loop 		         entrances before the LOOP_BEG note.  */
name|redirect_jump
argument_list|(
name|copy
argument_list|,
name|loop_pre_header_label
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|predict_insn_def
argument_list|(
name|copy
argument_list|,
name|PRED_LOOP_HEADER
argument_list|,
name|NOT_TAKEN
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Record the first insn we copied.  We need it so that we can 	 scan the copied insns for new pseudo registers.  */
if|if
condition|(
operator|!
name|first_copy
condition|)
name|first_copy
operator|=
name|copy
expr_stmt|;
block|}
comment|/* Now clean up by emitting a jump to the end label and deleting the jump      at the start of the loop.  */
if|if
condition|(
operator|!
name|copy
operator|||
name|GET_CODE
argument_list|(
name|copy
argument_list|)
operator|!=
name|BARRIER
condition|)
block|{
name|copy
operator|=
name|emit_jump_insn_before
argument_list|(
name|gen_jump
argument_list|(
name|get_label_after
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|,
name|loop_start
argument_list|)
expr_stmt|;
comment|/* Record the first insn we copied.  We need it so that we can 	 scan the copied insns for new pseudo registers.   This may not 	 be strictly necessary since we should have copied at least one 	 insn above.  But I am going to be safe.  */
if|if
condition|(
operator|!
name|first_copy
condition|)
name|first_copy
operator|=
name|copy
expr_stmt|;
name|mark_jump_label
argument_list|(
name|PATTERN
argument_list|(
name|copy
argument_list|)
argument_list|,
name|copy
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_barrier_before
argument_list|(
name|loop_start
argument_list|)
expr_stmt|;
block|}
name|emit_label_before
argument_list|(
name|loop_pre_header_label
argument_list|,
name|loop_start
argument_list|)
expr_stmt|;
comment|/* Now scan from the first insn we copied to the last insn we copied      (copy) for new pseudo registers.  Do this after the code to jump to      the end label since that might create a new pseudo too.  */
name|reg_scan_update
argument_list|(
name|first_copy
argument_list|,
name|copy
argument_list|,
name|max_reg
argument_list|)
expr_stmt|;
comment|/* Mark the exit code as the virtual top of the converted loop.  */
name|emit_note_before
argument_list|(
name|NOTE_INSN_LOOP_VTOP
argument_list|,
name|exitcode
argument_list|)
expr_stmt|;
name|delete_related_insns
argument_list|(
name|next_nonnote_insn
argument_list|(
name|loop_start
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Clean up.  */
if|if
condition|(
name|reg_map
condition|)
name|free
argument_list|(
name|reg_map
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Move all block-beg, block-end, loop-beg, loop-cont, loop-vtop, loop-end,    notes between START and END out before START.  START and END may be such    notes.  Returns the values of the new starting and ending insns, which    may be different if the original ones were such notes.    Return true if there were only such notes and no real instructions.  */
end_comment

begin_function
name|bool
name|squeeze_notes
parameter_list|(
name|rtx
modifier|*
name|startp
parameter_list|,
name|rtx
modifier|*
name|endp
parameter_list|)
block|{
name|rtx
name|start
init|=
operator|*
name|startp
decl_stmt|;
name|rtx
name|end
init|=
operator|*
name|endp
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|rtx
name|next
decl_stmt|;
name|rtx
name|last
init|=
name|NULL
decl_stmt|;
name|rtx
name|past_end
init|=
name|NEXT_INSN
argument_list|(
name|end
argument_list|)
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|start
init|;
name|insn
operator|!=
name|past_end
condition|;
name|insn
operator|=
name|next
control|)
block|{
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
operator|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_BLOCK_END
operator|||
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_BLOCK_BEG
operator|||
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_LOOP_BEG
operator|||
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_LOOP_END
operator|||
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_LOOP_CONT
operator|||
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_LOOP_VTOP
operator|)
condition|)
block|{
if|if
condition|(
name|insn
operator|==
name|start
condition|)
name|start
operator|=
name|next
expr_stmt|;
else|else
block|{
name|rtx
name|prev
init|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
operator|=
name|PREV_INSN
argument_list|(
name|start
argument_list|)
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
operator|=
name|start
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|=
name|insn
expr_stmt|;
name|PREV_INSN
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|=
name|insn
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|prev
argument_list|)
operator|=
name|next
expr_stmt|;
name|PREV_INSN
argument_list|(
name|next
argument_list|)
operator|=
name|prev
expr_stmt|;
block|}
block|}
else|else
name|last
operator|=
name|insn
expr_stmt|;
block|}
comment|/* There were no real instructions.  */
if|if
condition|(
name|start
operator|==
name|past_end
condition|)
return|return
name|true
return|;
name|end
operator|=
name|last
expr_stmt|;
operator|*
name|startp
operator|=
name|start
expr_stmt|;
operator|*
name|endp
operator|=
name|end
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the label before INSN, or put a new label there.  */
end_comment

begin_function
name|rtx
name|get_label_before
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|rtx
name|label
decl_stmt|;
comment|/* Find an existing label at this point      or make a new one if there is none.  */
name|label
operator|=
name|prev_nonnote_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|label
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|label
argument_list|)
operator|!=
name|CODE_LABEL
condition|)
block|{
name|rtx
name|prev
init|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|emit_label_after
argument_list|(
name|label
argument_list|,
name|prev
argument_list|)
expr_stmt|;
name|LABEL_NUSES
argument_list|(
name|label
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|label
return|;
block|}
end_function

begin_comment
comment|/* Return the label after INSN, or put a new label there.  */
end_comment

begin_function
name|rtx
name|get_label_after
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|rtx
name|label
decl_stmt|;
comment|/* Find an existing label at this point      or make a new one if there is none.  */
name|label
operator|=
name|next_nonnote_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|label
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|label
argument_list|)
operator|!=
name|CODE_LABEL
condition|)
block|{
name|label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|emit_label_after
argument_list|(
name|label
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|LABEL_NUSES
argument_list|(
name|label
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|label
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a comparison (CODE ARG0 ARG1), inside an insn, INSN, return a code    of reversed comparison if it is possible to do so.  Otherwise return UNKNOWN.    UNKNOWN may be returned in case we are having CC_MODE compare and we don't    know whether it's source is floating point or integer comparison.  Machine    description should define REVERSIBLE_CC_MODE and REVERSE_CONDITION macros    to help this function avoid overhead in these cases.  */
end_comment

begin_function
name|enum
name|rtx_code
name|reversed_comparison_code_parts
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|,
name|rtx
name|arg0
parameter_list|,
name|rtx
name|arg1
parameter_list|,
name|rtx
name|insn
parameter_list|)
block|{
name|enum
name|machine_mode
name|mode
decl_stmt|;
comment|/* If this is not actually a comparison, we can't reverse it.  */
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|!=
literal|'<'
condition|)
return|return
name|UNKNOWN
return|;
name|mode
operator|=
name|GET_MODE
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
name|mode
operator|=
name|GET_MODE
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
comment|/* First see if machine description supply us way to reverse the comparison.      Give it priority over everything else to allow machine description to do      tricks.  */
ifdef|#
directive|ifdef
name|REVERSIBLE_CC_MODE
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_CC
operator|&&
name|REVERSIBLE_CC_MODE
argument_list|(
name|mode
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|REVERSE_CONDITION
return|return
name|REVERSE_CONDITION
argument_list|(
name|code
argument_list|,
name|mode
argument_list|)
return|;
endif|#
directive|endif
return|return
name|reverse_condition
argument_list|(
name|code
argument_list|)
return|;
block|}
endif|#
directive|endif
comment|/* Try a few special cases based on the comparison code.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|GEU
case|:
case|case
name|GTU
case|:
case|case
name|LEU
case|:
case|case
name|LTU
case|:
case|case
name|NE
case|:
case|case
name|EQ
case|:
comment|/* It is always safe to reverse EQ and NE, even for the floating 	 point.  Similarly the unsigned comparisons are never used for 	 floating point so we can reverse them in the default way.  */
return|return
name|reverse_condition
argument_list|(
name|code
argument_list|)
return|;
case|case
name|ORDERED
case|:
case|case
name|UNORDERED
case|:
case|case
name|LTGT
case|:
case|case
name|UNEQ
case|:
comment|/* In case we already see unordered comparison, we can be sure to 	 be dealing with floating point so we don't need any more tests.  */
return|return
name|reverse_condition_maybe_unordered
argument_list|(
name|code
argument_list|)
return|;
case|case
name|UNLT
case|:
case|case
name|UNLE
case|:
case|case
name|UNGT
case|:
case|case
name|UNGE
case|:
comment|/* We don't have safe way to reverse these yet.  */
return|return
name|UNKNOWN
return|;
default|default:
break|break;
block|}
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_CC
operator|||
name|CC0_P
argument_list|(
name|arg0
argument_list|)
condition|)
block|{
name|rtx
name|prev
decl_stmt|;
comment|/* Try to search for the comparison to determine the real mode.          This code is expensive, but with sane machine description it          will be never used, since REVERSIBLE_CC_MODE will return true          in all cases.  */
if|if
condition|(
operator|!
name|insn
condition|)
return|return
name|UNKNOWN
return|;
for|for
control|(
name|prev
operator|=
name|prev_nonnote_insn
argument_list|(
name|insn
argument_list|)
init|;
name|prev
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|prev
argument_list|)
operator|!=
name|CODE_LABEL
condition|;
name|prev
operator|=
name|prev_nonnote_insn
argument_list|(
name|prev
argument_list|)
control|)
block|{
name|rtx
name|set
init|=
name|set_of
argument_list|(
name|arg0
argument_list|,
name|prev
argument_list|)
decl_stmt|;
if|if
condition|(
name|set
operator|&&
name|GET_CODE
argument_list|(
name|set
argument_list|)
operator|==
name|SET
operator|&&
name|rtx_equal_p
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|,
name|arg0
argument_list|)
condition|)
block|{
name|rtx
name|src
init|=
name|SET_SRC
argument_list|(
name|set
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|COMPARE
condition|)
block|{
name|rtx
name|comparison
init|=
name|src
decl_stmt|;
name|arg0
operator|=
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mode
operator|=
name|GET_MODE
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
name|mode
operator|=
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|comparison
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* We can get past reg-reg moves.  This may be useful for model 	         of i387 comparisons that first move flag registers around.  */
if|if
condition|(
name|REG_P
argument_list|(
name|src
argument_list|)
condition|)
block|{
name|arg0
operator|=
name|src
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* If register is clobbered in some ununderstandable way, 	     give up.  */
if|if
condition|(
name|set
condition|)
return|return
name|UNKNOWN
return|;
block|}
block|}
comment|/* Test for an integer condition, or a floating-point comparison      in which NaNs can be ignored.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|CONST_INT
operator|||
operator|(
name|GET_MODE
argument_list|(
name|arg0
argument_list|)
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|!=
name|MODE_CC
operator|&&
operator|!
name|HONOR_NANS
argument_list|(
name|mode
argument_list|)
operator|)
condition|)
return|return
name|reverse_condition
argument_list|(
name|code
argument_list|)
return|;
return|return
name|UNKNOWN
return|;
block|}
end_function

begin_comment
comment|/* A wrapper around the previous function to take COMPARISON as rtx    expression.  This simplifies many callers.  */
end_comment

begin_function
name|enum
name|rtx_code
name|reversed_comparison_code
parameter_list|(
name|rtx
name|comparison
parameter_list|,
name|rtx
name|insn
parameter_list|)
block|{
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|comparison
argument_list|)
argument_list|)
operator|!=
literal|'<'
condition|)
return|return
name|UNKNOWN
return|;
return|return
name|reversed_comparison_code_parts
argument_list|(
name|GET_CODE
argument_list|(
name|comparison
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|comparison
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|comparison
argument_list|,
literal|1
argument_list|)
argument_list|,
name|insn
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given an rtx-code for a comparison, return the code for the negated    comparison.  If no such code exists, return UNKNOWN.     WATCH OUT!  reverse_condition is not safe to use on a jump that might    be acting on the results of an IEEE floating point comparison, because    of the special treatment of non-signaling nans in comparisons.    Use reversed_comparison_code instead.  */
end_comment

begin_function
name|enum
name|rtx_code
name|reverse_condition
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|)
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|EQ
case|:
return|return
name|NE
return|;
case|case
name|NE
case|:
return|return
name|EQ
return|;
case|case
name|GT
case|:
return|return
name|LE
return|;
case|case
name|GE
case|:
return|return
name|LT
return|;
case|case
name|LT
case|:
return|return
name|GE
return|;
case|case
name|LE
case|:
return|return
name|GT
return|;
case|case
name|GTU
case|:
return|return
name|LEU
return|;
case|case
name|GEU
case|:
return|return
name|LTU
return|;
case|case
name|LTU
case|:
return|return
name|GEU
return|;
case|case
name|LEU
case|:
return|return
name|GTU
return|;
case|case
name|UNORDERED
case|:
return|return
name|ORDERED
return|;
case|case
name|ORDERED
case|:
return|return
name|UNORDERED
return|;
case|case
name|UNLT
case|:
case|case
name|UNLE
case|:
case|case
name|UNGT
case|:
case|case
name|UNGE
case|:
case|case
name|UNEQ
case|:
case|case
name|LTGT
case|:
return|return
name|UNKNOWN
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Similar, but we're allowed to generate unordered comparisons, which    makes it safe for IEEE floating-point.  Of course, we have to recognize    that the target will support them too...  */
end_comment

begin_function
name|enum
name|rtx_code
name|reverse_condition_maybe_unordered
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|)
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|EQ
case|:
return|return
name|NE
return|;
case|case
name|NE
case|:
return|return
name|EQ
return|;
case|case
name|GT
case|:
return|return
name|UNLE
return|;
case|case
name|GE
case|:
return|return
name|UNLT
return|;
case|case
name|LT
case|:
return|return
name|UNGE
return|;
case|case
name|LE
case|:
return|return
name|UNGT
return|;
case|case
name|LTGT
case|:
return|return
name|UNEQ
return|;
case|case
name|UNORDERED
case|:
return|return
name|ORDERED
return|;
case|case
name|ORDERED
case|:
return|return
name|UNORDERED
return|;
case|case
name|UNLT
case|:
return|return
name|GE
return|;
case|case
name|UNLE
case|:
return|return
name|GT
return|;
case|case
name|UNGT
case|:
return|return
name|LE
return|;
case|case
name|UNGE
case|:
return|return
name|LT
return|;
case|case
name|UNEQ
case|:
return|return
name|LTGT
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Similar, but return the code when two operands of a comparison are swapped.    This IS safe for IEEE floating-point.  */
end_comment

begin_function
name|enum
name|rtx_code
name|swap_condition
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|)
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|EQ
case|:
case|case
name|NE
case|:
case|case
name|UNORDERED
case|:
case|case
name|ORDERED
case|:
case|case
name|UNEQ
case|:
case|case
name|LTGT
case|:
return|return
name|code
return|;
case|case
name|GT
case|:
return|return
name|LT
return|;
case|case
name|GE
case|:
return|return
name|LE
return|;
case|case
name|LT
case|:
return|return
name|GT
return|;
case|case
name|LE
case|:
return|return
name|GE
return|;
case|case
name|GTU
case|:
return|return
name|LTU
return|;
case|case
name|GEU
case|:
return|return
name|LEU
return|;
case|case
name|LTU
case|:
return|return
name|GTU
return|;
case|case
name|LEU
case|:
return|return
name|GEU
return|;
case|case
name|UNLT
case|:
return|return
name|UNGT
return|;
case|case
name|UNLE
case|:
return|return
name|UNGE
return|;
case|case
name|UNGT
case|:
return|return
name|UNLT
return|;
case|case
name|UNGE
case|:
return|return
name|UNLE
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Given a comparison CODE, return the corresponding unsigned comparison.    If CODE is an equality comparison or already an unsigned comparison,    CODE is returned.  */
end_comment

begin_function
name|enum
name|rtx_code
name|unsigned_condition
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|)
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|EQ
case|:
case|case
name|NE
case|:
case|case
name|GTU
case|:
case|case
name|GEU
case|:
case|case
name|LTU
case|:
case|case
name|LEU
case|:
return|return
name|code
return|;
case|case
name|GT
case|:
return|return
name|GTU
return|;
case|case
name|GE
case|:
return|return
name|GEU
return|;
case|case
name|LT
case|:
return|return
name|LTU
return|;
case|case
name|LE
case|:
return|return
name|LEU
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Similarly, return the signed version of a comparison.  */
end_comment

begin_function
name|enum
name|rtx_code
name|signed_condition
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|)
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|EQ
case|:
case|case
name|NE
case|:
case|case
name|GT
case|:
case|case
name|GE
case|:
case|case
name|LT
case|:
case|case
name|LE
case|:
return|return
name|code
return|;
case|case
name|GTU
case|:
return|return
name|GT
return|;
case|case
name|GEU
case|:
return|return
name|GE
return|;
case|case
name|LTU
case|:
return|return
name|LT
return|;
case|case
name|LEU
case|:
return|return
name|LE
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return nonzero if CODE1 is more strict than CODE2, i.e., if the    truth of CODE1 implies the truth of CODE2.  */
end_comment

begin_function
name|int
name|comparison_dominates_p
parameter_list|(
name|enum
name|rtx_code
name|code1
parameter_list|,
name|enum
name|rtx_code
name|code2
parameter_list|)
block|{
comment|/* UNKNOWN comparison codes can happen as a result of trying to revert      comparison codes.      They can't match anything, so we have to reject them here.  */
if|if
condition|(
name|code1
operator|==
name|UNKNOWN
operator|||
name|code2
operator|==
name|UNKNOWN
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|code1
operator|==
name|code2
condition|)
return|return
literal|1
return|;
switch|switch
condition|(
name|code1
condition|)
block|{
case|case
name|UNEQ
case|:
if|if
condition|(
name|code2
operator|==
name|UNLE
operator|||
name|code2
operator|==
name|UNGE
condition|)
return|return
literal|1
return|;
break|break;
case|case
name|EQ
case|:
if|if
condition|(
name|code2
operator|==
name|LE
operator|||
name|code2
operator|==
name|LEU
operator|||
name|code2
operator|==
name|GE
operator|||
name|code2
operator|==
name|GEU
operator|||
name|code2
operator|==
name|ORDERED
condition|)
return|return
literal|1
return|;
break|break;
case|case
name|UNLT
case|:
if|if
condition|(
name|code2
operator|==
name|UNLE
operator|||
name|code2
operator|==
name|NE
condition|)
return|return
literal|1
return|;
break|break;
case|case
name|LT
case|:
if|if
condition|(
name|code2
operator|==
name|LE
operator|||
name|code2
operator|==
name|NE
operator|||
name|code2
operator|==
name|ORDERED
operator|||
name|code2
operator|==
name|LTGT
condition|)
return|return
literal|1
return|;
break|break;
case|case
name|UNGT
case|:
if|if
condition|(
name|code2
operator|==
name|UNGE
operator|||
name|code2
operator|==
name|NE
condition|)
return|return
literal|1
return|;
break|break;
case|case
name|GT
case|:
if|if
condition|(
name|code2
operator|==
name|GE
operator|||
name|code2
operator|==
name|NE
operator|||
name|code2
operator|==
name|ORDERED
operator|||
name|code2
operator|==
name|LTGT
condition|)
return|return
literal|1
return|;
break|break;
case|case
name|GE
case|:
case|case
name|LE
case|:
if|if
condition|(
name|code2
operator|==
name|ORDERED
condition|)
return|return
literal|1
return|;
break|break;
case|case
name|LTGT
case|:
if|if
condition|(
name|code2
operator|==
name|NE
operator|||
name|code2
operator|==
name|ORDERED
condition|)
return|return
literal|1
return|;
break|break;
case|case
name|LTU
case|:
if|if
condition|(
name|code2
operator|==
name|LEU
operator|||
name|code2
operator|==
name|NE
condition|)
return|return
literal|1
return|;
break|break;
case|case
name|GTU
case|:
if|if
condition|(
name|code2
operator|==
name|GEU
operator|||
name|code2
operator|==
name|NE
condition|)
return|return
literal|1
return|;
break|break;
case|case
name|UNORDERED
case|:
if|if
condition|(
name|code2
operator|==
name|NE
operator|||
name|code2
operator|==
name|UNEQ
operator|||
name|code2
operator|==
name|UNLE
operator|||
name|code2
operator|==
name|UNLT
operator|||
name|code2
operator|==
name|UNGE
operator|||
name|code2
operator|==
name|UNGT
condition|)
return|return
literal|1
return|;
break|break;
default|default:
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if INSN is an unconditional jump and nothing else.  */
end_comment

begin_function
name|int
name|simplejump_p
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
return|return
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|PC
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if INSN is a (possibly) conditional jump    and nothing more.     Use this function is deprecated, since we need to support combined    branch and compare insns.  Use any_condjump_p instead whenever possible.  */
end_comment

begin_function
name|int
name|condjump_p
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|rtx
name|x
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|SET
operator|||
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|PC
condition|)
return|return
literal|0
return|;
name|x
operator|=
name|SET_SRC
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|LABEL_REF
condition|)
return|return
literal|1
return|;
else|else
return|return
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|IF_THEN_ELSE
operator|&&
operator|(
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|==
name|PC
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|RETURN
operator|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|PC
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|==
name|RETURN
operator|)
operator|)
operator|)
operator|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if INSN is a (possibly) conditional jump inside a    PARALLEL.     Use this function is deprecated, since we need to support combined    branch and compare insns.  Use any_condjump_p instead whenever possible.  */
end_comment

begin_function
name|int
name|condjump_in_parallel_p
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|rtx
name|x
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|PARALLEL
condition|)
return|return
literal|0
return|;
else|else
name|x
operator|=
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|SET
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|PC
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|IF_THEN_ELSE
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|2
argument_list|)
operator|==
name|pc_rtx
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|RETURN
operator|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
name|pc_rtx
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|==
name|RETURN
operator|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return set of PC, otherwise NULL.  */
end_comment

begin_function
name|rtx
name|pc_set
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|rtx
name|pat
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|JUMP_INSN
condition|)
return|return
name|NULL_RTX
return|;
name|pat
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* The set is allowed to appear either as the insn pattern or      the first set in a PARALLEL.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|PARALLEL
condition|)
name|pat
operator|=
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|==
name|PC
condition|)
return|return
name|pat
return|;
return|return
name|NULL_RTX
return|;
block|}
end_function

begin_comment
comment|/* Return true when insn is an unconditional direct jump,    possibly bundled inside a PARALLEL.  */
end_comment

begin_function
name|int
name|any_uncondjump_p
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|rtx
name|x
init|=
name|pc_set
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|x
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|LABEL_REF
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return true when insn is a conditional jump.  This function works for    instructions containing PC sets in PARALLELs.  The instruction may have    various other effects so before removing the jump you must verify    onlyjump_p.     Note that unlike condjump_p it returns false for unconditional jumps.  */
end_comment

begin_function
name|int
name|any_condjump_p
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|rtx
name|x
init|=
name|pc_set
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|enum
name|rtx_code
name|a
decl_stmt|,
name|b
decl_stmt|;
if|if
condition|(
operator|!
name|x
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|IF_THEN_ELSE
condition|)
return|return
literal|0
return|;
name|a
operator|=
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|b
operator|=
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|b
operator|==
name|PC
operator|&&
operator|(
name|a
operator|==
name|LABEL_REF
operator|||
name|a
operator|==
name|RETURN
operator|)
operator|)
operator|||
operator|(
name|a
operator|==
name|PC
operator|&&
operator|(
name|b
operator|==
name|LABEL_REF
operator|||
name|b
operator|==
name|RETURN
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the label of a conditional jump.  */
end_comment

begin_function
name|rtx
name|condjump_label
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|rtx
name|x
init|=
name|pc_set
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|x
condition|)
return|return
name|NULL_RTX
return|;
name|x
operator|=
name|SET_SRC
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|LABEL_REF
condition|)
return|return
name|x
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|IF_THEN_ELSE
condition|)
return|return
name|NULL_RTX
return|;
if|if
condition|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
operator|==
name|pc_rtx
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
condition|)
return|return
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
return|;
if|if
condition|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|==
name|pc_rtx
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
condition|)
return|return
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
return|;
return|return
name|NULL_RTX
return|;
block|}
end_function

begin_comment
comment|/* Return true if INSN is a (possibly conditional) return insn.  */
end_comment

begin_function
specifier|static
name|int
name|returnjump_p_1
parameter_list|(
name|rtx
modifier|*
name|loc
parameter_list|,
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|rtx
name|x
init|=
operator|*
name|loc
decl_stmt|;
return|return
name|x
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|RETURN
operator|||
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SET
operator|&&
name|SET_IS_RETURN_P
argument_list|(
name|x
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|returnjump_p
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|JUMP_INSN
condition|)
return|return
literal|0
return|;
return|return
name|for_each_rtx
argument_list|(
operator|&
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|returnjump_p_1
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if INSN is a jump that only transfers control and    nothing more.  */
end_comment

begin_function
name|int
name|onlyjump_p
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|rtx
name|set
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|JUMP_INSN
condition|)
return|return
literal|0
return|;
name|set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|set
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|!=
name|PC
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|side_effects_p
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_cc0
end_ifdef

begin_comment
comment|/* Return nonzero if X is an RTX that only sets the condition codes    and has no side effects.  */
end_comment

begin_function
name|int
name|only_sets_cc0_p
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
if|if
condition|(
operator|!
name|x
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|INSN_P
argument_list|(
name|x
argument_list|)
condition|)
name|x
operator|=
name|PATTERN
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
name|sets_cc0_p
argument_list|(
name|x
argument_list|)
operator|==
literal|1
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|x
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if X is an RTX that does nothing but set the condition codes    and CLOBBER or USE registers.    Return -1 if X does explicitly set the condition codes,    but also does other things.  */
end_comment

begin_function
name|int
name|sets_cc0_p
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
if|if
condition|(
operator|!
name|x
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|INSN_P
argument_list|(
name|x
argument_list|)
condition|)
name|x
operator|=
name|PATTERN
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SET
operator|&&
name|SET_DEST
argument_list|(
name|x
argument_list|)
operator|==
name|cc0_rtx
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|sets_cc0
init|=
literal|0
decl_stmt|;
name|int
name|other_things
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|cc0_rtx
condition|)
name|sets_cc0
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|SET
condition|)
name|other_things
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|!
name|sets_cc0
condition|?
literal|0
else|:
name|other_things
condition|?
operator|-
literal|1
else|:
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Follow any unconditional jump at LABEL;    return the ultimate label reached by any such chain of jumps.    If LABEL is not followed by a jump, return LABEL.    If the chain loops or we can't find end, return LABEL,    since that tells caller to avoid changing the insn.     If RELOAD_COMPLETED is 0, we do not chain across a NOTE_INSN_LOOP_BEG or    a USE or CLOBBER.  */
end_comment

begin_function
name|rtx
name|follow_jumps
parameter_list|(
name|rtx
name|label
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
name|rtx
name|next
decl_stmt|;
name|rtx
name|value
init|=
name|label
decl_stmt|;
name|int
name|depth
decl_stmt|;
for|for
control|(
name|depth
operator|=
literal|0
init|;
operator|(
name|depth
operator|<
literal|10
operator|&&
operator|(
name|insn
operator|=
name|next_active_insn
argument_list|(
name|value
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
operator|(
operator|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
operator|!=
literal|0
operator|&&
name|any_uncondjump_p
argument_list|(
name|insn
argument_list|)
operator|&&
name|onlyjump_p
argument_list|(
name|insn
argument_list|)
operator|)
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|RETURN
operator|)
operator|&&
operator|(
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|BARRIER
operator|)
condition|;
name|depth
operator|++
control|)
block|{
comment|/* Don't chain through the insn that jumps into a loop 	 from outside the loop, 	 since that would create multiple loop entry jumps 	 and prevent loop optimization.  */
name|rtx
name|tem
decl_stmt|;
if|if
condition|(
operator|!
name|reload_completed
condition|)
for|for
control|(
name|tem
operator|=
name|value
init|;
name|tem
operator|!=
name|insn
condition|;
name|tem
operator|=
name|NEXT_INSN
argument_list|(
name|tem
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|NOTE
operator|&&
operator|(
name|NOTE_LINE_NUMBER
argument_list|(
name|tem
argument_list|)
operator|==
name|NOTE_INSN_LOOP_BEG
comment|/* ??? Optional.  Disables some optimizations, but makes 		     gcov output more accurate with -O.  */
operator|||
operator|(
name|flag_test_coverage
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|tem
argument_list|)
operator|>
literal|0
operator|)
operator|)
condition|)
return|return
name|value
return|;
comment|/* If we have found a cycle, make the insn jump to itself.  */
if|if
condition|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
operator|==
name|label
condition|)
return|return
name|label
return|;
name|tem
operator|=
name|next_active_insn
argument_list|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|tem
argument_list|)
argument_list|)
operator|==
name|ADDR_VEC
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|tem
argument_list|)
argument_list|)
operator|==
name|ADDR_DIFF_VEC
operator|)
condition|)
break|break;
name|value
operator|=
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|depth
operator|==
literal|10
condition|)
return|return
name|label
return|;
return|return
name|value
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Find all CODE_LABELs referred to in X, and increment their use counts.    If INSN is a JUMP_INSN and there is at least one CODE_LABEL referenced    in INSN, then store one of them in JUMP_LABEL (INSN).    If INSN is an INSN or a CALL_INSN and there is at least one CODE_LABEL    referenced in INSN, add a REG_LABEL note containing that label to INSN.    Also, when there are consecutive labels, canonicalize on the last of them.     Note that two labels separated by a loop-beginning note    must be kept distinct if we have not yet done loop-optimization,    because the gap between them is where loop-optimize    will want to move invariant code to.  CROSS_JUMP tells us    that loop-optimization is done with.  */
end_comment

begin_function
name|void
name|mark_jump_label
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
name|insn
parameter_list|,
name|int
name|in_mem
parameter_list|)
block|{
name|RTX_CODE
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PC
case|:
case|case
name|CC0
case|:
case|case
name|REG
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CLOBBER
case|:
case|case
name|CALL
case|:
return|return;
case|case
name|MEM
case|:
name|in_mem
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|SYMBOL_REF
case|:
if|if
condition|(
operator|!
name|in_mem
condition|)
return|return;
comment|/* If this is a constant-pool reference, see if it is a label.  */
if|if
condition|(
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|x
argument_list|)
condition|)
name|mark_jump_label
argument_list|(
name|get_pool_constant
argument_list|(
name|x
argument_list|)
argument_list|,
name|insn
argument_list|,
name|in_mem
argument_list|)
expr_stmt|;
break|break;
case|case
name|LABEL_REF
case|:
block|{
name|rtx
name|label
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* Ignore remaining references to unreachable labels that 	   have been deleted.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|label
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|label
argument_list|)
operator|==
name|NOTE_INSN_DELETED_LABEL
condition|)
break|break;
if|if
condition|(
name|GET_CODE
argument_list|(
name|label
argument_list|)
operator|!=
name|CODE_LABEL
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Ignore references to labels of containing functions.  */
if|if
condition|(
name|LABEL_REF_NONLOCAL_P
argument_list|(
name|x
argument_list|)
condition|)
break|break;
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|=
name|label
expr_stmt|;
if|if
condition|(
operator|!
name|insn
operator|||
operator|!
name|INSN_DELETED_P
argument_list|(
name|insn
argument_list|)
condition|)
operator|++
name|LABEL_NUSES
argument_list|(
name|label
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
operator|=
name|label
expr_stmt|;
else|else
block|{
comment|/* Add a REG_LABEL note for LABEL unless there already 		   is one.  All uses of a label, except for labels 		   that are the targets of jumps, must have a 		   REG_LABEL note.  */
if|if
condition|(
operator|!
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_LABEL
argument_list|,
name|label
argument_list|)
condition|)
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_INSN_LIST
argument_list|(
name|REG_LABEL
argument_list|,
name|label
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
comment|/* Do walk the labels in a vector, but not the first operand of an      ADDR_DIFF_VEC.  Don't set the JUMP_LABEL of a vector.  */
case|case
name|ADDR_VEC
case|:
case|case
name|ADDR_DIFF_VEC
case|:
if|if
condition|(
operator|!
name|INSN_DELETED_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|int
name|eltnum
init|=
name|code
operator|==
name|ADDR_DIFF_VEC
condition|?
literal|1
else|:
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|eltnum
argument_list|)
condition|;
name|i
operator|++
control|)
name|mark_jump_label
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|eltnum
argument_list|,
name|i
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|in_mem
argument_list|)
expr_stmt|;
block|}
return|return;
default|default:
break|break;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|mark_jump_label
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|insn
argument_list|,
name|in_mem
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|mark_jump_label
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|insn
argument_list|,
name|in_mem
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* If all INSN does is set the pc, delete it,    and delete the insn that set the condition codes for it    if that's what the previous thing was.  */
end_comment

begin_function
name|void
name|delete_jump
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|rtx
name|set
init|=
name|single_set
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|set
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|PC
condition|)
name|delete_computation
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Verify INSN is a BARRIER and delete it.  */
end_comment

begin_function
name|void
name|delete_barrier
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|BARRIER
condition|)
name|abort
argument_list|()
expr_stmt|;
name|delete_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Recursively delete prior insns that compute the value (used only by INSN    which the caller is deleting) stored in the register mentioned by NOTE    which is a REG_DEAD note associated with INSN.  */
end_comment

begin_function
specifier|static
name|void
name|delete_prior_computation
parameter_list|(
name|rtx
name|note
parameter_list|,
name|rtx
name|insn
parameter_list|)
block|{
name|rtx
name|our_prev
decl_stmt|;
name|rtx
name|reg
init|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
decl_stmt|;
for|for
control|(
name|our_prev
operator|=
name|prev_nonnote_insn
argument_list|(
name|insn
argument_list|)
init|;
name|our_prev
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|our_prev
argument_list|)
operator|==
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|our_prev
argument_list|)
operator|==
name|CALL_INSN
operator|)
condition|;
name|our_prev
operator|=
name|prev_nonnote_insn
argument_list|(
name|our_prev
argument_list|)
control|)
block|{
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|our_prev
argument_list|)
decl_stmt|;
comment|/* If we reach a CALL which is not calling a const function 	 or the callee pops the arguments, then give up.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|our_prev
argument_list|)
operator|==
name|CALL_INSN
operator|&&
operator|(
operator|!
name|CONST_OR_PURE_CALL_P
argument_list|(
name|our_prev
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|!=
name|SET
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|!=
name|CALL
operator|)
condition|)
break|break;
comment|/* If we reach a SEQUENCE, it is too complex to try to 	 do anything with it, so give up.  We can be run during 	 and after reorg, so SEQUENCE rtl can legitimately show 	 up here.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|SEQUENCE
condition|)
break|break;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|USE
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|INSN
condition|)
comment|/* reorg creates USEs that look like this.  We leave them 	   alone because reorg needs them for its own purposes.  */
break|break;
if|if
condition|(
name|reg_set_p
argument_list|(
name|reg
argument_list|,
name|pat
argument_list|)
condition|)
block|{
if|if
condition|(
name|side_effects_p
argument_list|(
name|pat
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|our_prev
argument_list|)
operator|!=
name|CALL_INSN
condition|)
break|break;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
comment|/* If we find a SET of something else, we can't 		 delete the insn.  */
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|part
init|=
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|part
argument_list|)
operator|==
name|SET
operator|&&
name|SET_DEST
argument_list|(
name|part
argument_list|)
operator|!=
name|reg
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
condition|)
name|delete_computation
argument_list|(
name|our_prev
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|int
name|dest_regno
init|=
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|dest_endregno
init|=
operator|(
name|dest_regno
operator|+
operator|(
name|dest_regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|?
name|HARD_REGNO_NREGS
argument_list|(
name|dest_regno
argument_list|,
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|)
argument_list|)
else|:
literal|1
operator|)
operator|)
decl_stmt|;
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|reg
argument_list|)
decl_stmt|;
name|int
name|endregno
init|=
operator|(
name|regno
operator|+
operator|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|?
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
else|:
literal|1
operator|)
operator|)
decl_stmt|;
if|if
condition|(
name|dest_regno
operator|>=
name|regno
operator|&&
name|dest_endregno
operator|<=
name|endregno
condition|)
name|delete_computation
argument_list|(
name|our_prev
argument_list|)
expr_stmt|;
comment|/* We may have a multi-word hard register and some, but not 		 all, of the words of the register are needed in subsequent 		 insns.  Write REG_UNUSED notes for those parts that were not 		 needed.  */
elseif|else
if|if
condition|(
name|dest_regno
operator|<=
name|regno
operator|&&
name|dest_endregno
operator|>=
name|endregno
condition|)
block|{
name|int
name|i
decl_stmt|;
name|REG_NOTES
argument_list|(
name|our_prev
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_UNUSED
argument_list|,
name|reg
argument_list|,
name|REG_NOTES
argument_list|(
name|our_prev
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|dest_regno
init|;
name|i
operator|<
name|dest_endregno
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|find_regno_note
argument_list|(
name|our_prev
argument_list|,
name|REG_UNUSED
argument_list|,
name|i
argument_list|)
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|dest_endregno
condition|)
name|delete_computation
argument_list|(
name|our_prev
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
comment|/* If PAT references the register that dies here, it is an 	 additional use.  Hence any prior SET isn't dead.  However, this 	 insn becomes the new place for the REG_DEAD note.  */
if|if
condition|(
name|reg_overlap_mentioned_p
argument_list|(
name|reg
argument_list|,
name|pat
argument_list|)
condition|)
block|{
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
operator|=
name|REG_NOTES
argument_list|(
name|our_prev
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|our_prev
argument_list|)
operator|=
name|note
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Delete INSN and recursively delete insns that compute values used only    by INSN.  This uses the REG_DEAD notes computed during flow analysis.    If we are running before flow.c, we need do nothing since flow.c will    delete dead code.  We also can't know if the registers being used are    dead or not at this point.     Otherwise, look at all our REG_DEAD notes.  If a previous insn does    nothing other than set a register that dies in this insn, we can delete    that insn as well.     On machines with CC0, if CC0 is used in this insn, we may be able to    delete the insn that set it.  */
end_comment

begin_function
specifier|static
name|void
name|delete_computation
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|rtx
name|note
decl_stmt|,
name|next
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_cc0
if|if
condition|(
name|reg_referenced_p
argument_list|(
name|cc0_rtx
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|prev
init|=
name|prev_nonnote_insn
argument_list|(
name|insn
argument_list|)
decl_stmt|;
comment|/* We assume that at this stage 	 CC's are always set explicitly 	 and always immediately before the jump that 	 will use them.  So if the previous insn 	 exists to set the CC's, delete it 	 (unless it performs auto-increments, etc.).  */
if|if
condition|(
name|prev
operator|&&
name|GET_CODE
argument_list|(
name|prev
argument_list|)
operator|==
name|INSN
operator|&&
name|sets_cc0_p
argument_list|(
name|PATTERN
argument_list|(
name|prev
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|sets_cc0_p
argument_list|(
name|PATTERN
argument_list|(
name|prev
argument_list|)
argument_list|)
operator|>
literal|0
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|PATTERN
argument_list|(
name|prev
argument_list|)
argument_list|)
condition|)
name|delete_computation
argument_list|(
name|prev
argument_list|)
expr_stmt|;
else|else
comment|/* Otherwise, show that cc0 won't be used.  */
name|REG_NOTES
argument_list|(
name|prev
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_UNUSED
argument_list|,
name|cc0_rtx
argument_list|,
name|REG_NOTES
argument_list|(
name|prev
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
for|for
control|(
name|note
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|note
condition|;
name|note
operator|=
name|next
control|)
block|{
name|next
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
operator|!=
name|REG_DEAD
comment|/* Verify that the REG_NOTE is legitimate.  */
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|REG
condition|)
continue|continue;
name|delete_prior_computation
argument_list|(
name|note
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
name|delete_related_insns
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Delete insn INSN from the chain of insns and update label ref counts    and delete insns now unreachable.     Returns the first insn after INSN that was not deleted.     Usage of this instruction is deprecated.  Use delete_insn instead and    subsequent cfg_cleanup pass to delete unreachable code if needed.  */
end_comment

begin_function
name|rtx
name|delete_related_insns
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|int
name|was_code_label
init|=
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
operator|)
decl_stmt|;
name|rtx
name|note
decl_stmt|;
name|rtx
name|next
init|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|,
name|prev
init|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
while|while
condition|(
name|next
operator|&&
name|INSN_DELETED_P
argument_list|(
name|next
argument_list|)
condition|)
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|next
argument_list|)
expr_stmt|;
comment|/* This insn is already deleted => return first following nondeleted.  */
if|if
condition|(
name|INSN_DELETED_P
argument_list|(
name|insn
argument_list|)
condition|)
return|return
name|next
return|;
name|delete_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* If instruction is followed by a barrier,      delete the barrier too.  */
if|if
condition|(
name|next
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|BARRIER
condition|)
name|delete_insn
argument_list|(
name|next
argument_list|)
expr_stmt|;
comment|/* If deleting a jump, decrement the count of the label,      and delete the label if it is now unused.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|rtx
name|lab
init|=
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
decl_stmt|,
name|lab_next
decl_stmt|;
if|if
condition|(
name|LABEL_NUSES
argument_list|(
name|lab
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* This can delete NEXT or PREV, 	     either directly if NEXT is JUMP_LABEL (INSN), 	     or indirectly through more levels of jumps.  */
name|delete_related_insns
argument_list|(
name|lab
argument_list|)
expr_stmt|;
comment|/* I feel a little doubtful about this loop, 	     but I see no clean and sure alternative way 	     to find the first insn after INSN that is not now deleted. 	     I hope this works.  */
while|while
condition|(
name|next
operator|&&
name|INSN_DELETED_P
argument_list|(
name|next
argument_list|)
condition|)
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|next
argument_list|)
expr_stmt|;
return|return
name|next
return|;
block|}
elseif|else
if|if
condition|(
name|tablejump_p
argument_list|(
name|insn
argument_list|,
name|NULL
argument_list|,
operator|&
name|lab_next
argument_list|)
condition|)
block|{
comment|/* If we're deleting the tablejump, delete the dispatch table. 	     We may not be able to kill the label immediately preceding 	     just yet, as it might be referenced in code leading up to 	     the tablejump.  */
name|delete_related_insns
argument_list|(
name|lab_next
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Likewise if we're deleting a dispatch table.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|ADDR_VEC
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|ADDR_DIFF_VEC
operator|)
condition|)
block|{
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|diff_vec_p
init|=
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|ADDR_DIFF_VEC
decl_stmt|;
name|int
name|len
init|=
name|XVECLEN
argument_list|(
name|pat
argument_list|,
name|diff_vec_p
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|LABEL_NUSES
argument_list|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
name|diff_vec_p
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|delete_related_insns
argument_list|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
name|diff_vec_p
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|next
operator|&&
name|INSN_DELETED_P
argument_list|(
name|next
argument_list|)
condition|)
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|next
argument_list|)
expr_stmt|;
return|return
name|next
return|;
block|}
comment|/* Likewise for an ordinary INSN / CALL_INSN with a REG_LABEL note.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
for|for
control|(
name|note
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|note
condition|;
name|note
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
operator|==
name|REG_LABEL
comment|/* This could also be a NOTE_INSN_DELETED_LABEL note.  */
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CODE_LABEL
condition|)
if|if
condition|(
name|LABEL_NUSES
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|delete_related_insns
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|prev
operator|&&
operator|(
name|INSN_DELETED_P
argument_list|(
name|prev
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|prev
argument_list|)
operator|==
name|NOTE
operator|)
condition|)
name|prev
operator|=
name|PREV_INSN
argument_list|(
name|prev
argument_list|)
expr_stmt|;
comment|/* If INSN was a label and a dispatch table follows it,      delete the dispatch table.  The tablejump must have gone already.      It isn't useful to fall through into a table.  */
if|if
condition|(
name|was_code_label
operator|&&
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|ADDR_VEC
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|ADDR_DIFF_VEC
operator|)
condition|)
name|next
operator|=
name|delete_related_insns
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If INSN was a label, delete insns following it if now unreachable.  */
if|if
condition|(
name|was_code_label
operator|&&
name|prev
operator|&&
name|GET_CODE
argument_list|(
name|prev
argument_list|)
operator|==
name|BARRIER
condition|)
block|{
name|RTX_CODE
name|code
decl_stmt|;
while|while
condition|(
name|next
operator|!=
literal|0
operator|&&
operator|(
name|GET_RTX_CLASS
argument_list|(
name|code
operator|=
name|GET_CODE
argument_list|(
name|next
argument_list|)
argument_list|)
operator|==
literal|'i'
operator|||
name|code
operator|==
name|NOTE
operator|||
name|code
operator|==
name|BARRIER
operator|||
operator|(
name|code
operator|==
name|CODE_LABEL
operator|&&
name|INSN_DELETED_P
argument_list|(
name|next
argument_list|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|code
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|next
argument_list|)
operator|!=
name|NOTE_INSN_FUNCTION_END
condition|)
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|next
argument_list|)
expr_stmt|;
comment|/* Keep going past other deleted labels to delete what follows.  */
elseif|else
if|if
condition|(
name|code
operator|==
name|CODE_LABEL
operator|&&
name|INSN_DELETED_P
argument_list|(
name|next
argument_list|)
condition|)
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|next
argument_list|)
expr_stmt|;
else|else
comment|/* Note: if this deletes a jump, it can cause more 	       deletion of unreachable code, after a different label. 	       As long as the value from this recursive call is correct, 	       this invocation functions correctly.  */
name|next
operator|=
name|delete_related_insns
argument_list|(
name|next
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|next
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Delete a range of insns from FROM to TO, inclusive.    This is for the sake of peephole optimization, so assume    that whatever these insns do will still be done by a new    peephole insn that will replace them.  */
end_comment

begin_function
name|void
name|delete_for_peephole
parameter_list|(
name|rtx
name|from
parameter_list|,
name|rtx
name|to
parameter_list|)
block|{
name|rtx
name|insn
init|=
name|from
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|rtx
name|next
init|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|prev
init|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE
condition|)
block|{
name|INSN_DELETED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Patch this insn out of the chain.  */
comment|/* We don't do this all at once, because we 	     must preserve all NOTEs.  */
if|if
condition|(
name|prev
condition|)
name|NEXT_INSN
argument_list|(
name|prev
argument_list|)
operator|=
name|next
expr_stmt|;
if|if
condition|(
name|next
condition|)
name|PREV_INSN
argument_list|(
name|next
argument_list|)
operator|=
name|prev
expr_stmt|;
block|}
if|if
condition|(
name|insn
operator|==
name|to
condition|)
break|break;
name|insn
operator|=
name|next
expr_stmt|;
block|}
comment|/* Note that if TO is an unconditional jump      we *do not* delete the BARRIER that follows,      since the peephole that replaces this sequence      is also an unconditional jump in that case.  */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* We have determined that AVOIDED_INSN is never reached, and are    about to delete it.  If the insn chain between AVOIDED_INSN and    FINISH contains more than one line from the current function, and    contains at least one operation, print a warning if the user asked    for it.  If FINISH is NULL, look between AVOIDED_INSN and a LABEL.     CSE and inlining can duplicate insns, so it's possible to get    spurious warnings from this.  */
end_comment

begin_function
name|void
name|never_reached_warning
parameter_list|(
name|rtx
name|avoided_insn
parameter_list|,
name|rtx
name|finish
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
name|rtx
name|a_line_note
init|=
name|NULL
decl_stmt|;
name|int
name|two_avoided_lines
init|=
literal|0
decl_stmt|,
name|contains_insn
init|=
literal|0
decl_stmt|,
name|reached_end
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|warn_notreached
condition|)
return|return;
comment|/* Back up to the first of any NOTEs preceding avoided_insn; flow passes      us the head of a block, a NOTE_INSN_BASIC_BLOCK, which often follows      the line note.  */
name|insn
operator|=
name|avoided_insn
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|rtx
name|prev
init|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|prev
operator|==
name|NULL_RTX
operator|||
name|GET_CODE
argument_list|(
name|prev
argument_list|)
operator|!=
name|NOTE
condition|)
break|break;
name|insn
operator|=
name|prev
expr_stmt|;
block|}
comment|/* Scan forwards, looking at LINE_NUMBER notes, until we hit a LABEL      in case FINISH is NULL, otherwise until we run out of insns.  */
for|for
control|(
init|;
name|insn
operator|!=
name|NULL
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
operator|(
name|finish
operator|==
name|NULL
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
operator|)
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|BARRIER
condition|)
break|break;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
comment|/* A line number note?  */
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|a_line_note
operator|==
name|NULL
condition|)
name|a_line_note
operator|=
name|insn
expr_stmt|;
else|else
name|two_avoided_lines
operator||=
operator|(
name|NOTE_LINE_NUMBER
argument_list|(
name|a_line_note
argument_list|)
operator|!=
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
if|if
condition|(
name|reached_end
condition|)
break|break;
name|contains_insn
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|insn
operator|==
name|finish
condition|)
name|reached_end
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|two_avoided_lines
operator|&&
name|contains_insn
condition|)
block|{
name|location_t
name|locus
decl_stmt|;
name|locus
operator|.
name|file
operator|=
name|NOTE_SOURCE_FILE
argument_list|(
name|a_line_note
argument_list|)
expr_stmt|;
name|locus
operator|.
name|line
operator|=
name|NOTE_LINE_NUMBER
argument_list|(
name|a_line_note
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"%Hwill never be executed"
argument_list|,
operator|&
name|locus
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Throughout LOC, redirect OLABEL to NLABEL.  Treat null OLABEL or    NLABEL as a return.  Accrue modifications into the change group.  */
end_comment

begin_function
specifier|static
name|void
name|redirect_exp_1
parameter_list|(
name|rtx
modifier|*
name|loc
parameter_list|,
name|rtx
name|olabel
parameter_list|,
name|rtx
name|nlabel
parameter_list|,
name|rtx
name|insn
parameter_list|)
block|{
name|rtx
name|x
init|=
operator|*
name|loc
decl_stmt|;
name|RTX_CODE
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|LABEL_REF
condition|)
block|{
if|if
condition|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|olabel
condition|)
block|{
name|rtx
name|n
decl_stmt|;
if|if
condition|(
name|nlabel
condition|)
name|n
operator|=
name|gen_rtx_LABEL_REF
argument_list|(
name|VOIDmode
argument_list|,
name|nlabel
argument_list|)
expr_stmt|;
else|else
name|n
operator|=
name|gen_rtx_RETURN
argument_list|(
name|VOIDmode
argument_list|)
expr_stmt|;
name|validate_change
argument_list|(
name|insn
argument_list|,
name|loc
argument_list|,
name|n
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|RETURN
operator|&&
name|olabel
operator|==
literal|0
condition|)
block|{
name|x
operator|=
name|gen_rtx_LABEL_REF
argument_list|(
name|VOIDmode
argument_list|,
name|nlabel
argument_list|)
expr_stmt|;
if|if
condition|(
name|loc
operator|==
operator|&
name|PATTERN
argument_list|(
name|insn
argument_list|)
condition|)
name|x
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|pc_rtx
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|validate_change
argument_list|(
name|insn
argument_list|,
name|loc
argument_list|,
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|code
operator|==
name|SET
operator|&&
name|nlabel
operator|==
literal|0
operator|&&
name|SET_DEST
argument_list|(
name|x
argument_list|)
operator|==
name|pc_rtx
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|&&
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|olabel
condition|)
block|{
name|validate_change
argument_list|(
name|insn
argument_list|,
name|loc
argument_list|,
name|gen_rtx_RETURN
argument_list|(
name|VOIDmode
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|redirect_exp_1
argument_list|(
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|olabel
argument_list|,
name|nlabel
argument_list|,
name|insn
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|redirect_exp_1
argument_list|(
operator|&
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|olabel
argument_list|,
name|nlabel
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Similar, but apply the change group and report success or failure.  */
end_comment

begin_function
specifier|static
name|int
name|redirect_exp
parameter_list|(
name|rtx
name|olabel
parameter_list|,
name|rtx
name|nlabel
parameter_list|,
name|rtx
name|insn
parameter_list|)
block|{
name|rtx
modifier|*
name|loc
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|PARALLEL
condition|)
name|loc
operator|=
operator|&
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|loc
operator|=
operator|&
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|redirect_exp_1
argument_list|(
name|loc
argument_list|,
name|olabel
argument_list|,
name|nlabel
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_validated_changes
argument_list|()
operator|==
literal|0
condition|)
return|return
literal|0
return|;
return|return
name|apply_change_group
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/* Make JUMP go to NLABEL instead of where it jumps now.  Accrue    the modifications into the change group.  Return false if we did    not see how to do that.  */
end_comment

begin_function
name|int
name|redirect_jump_1
parameter_list|(
name|rtx
name|jump
parameter_list|,
name|rtx
name|nlabel
parameter_list|)
block|{
name|int
name|ochanges
init|=
name|num_validated_changes
argument_list|()
decl_stmt|;
name|rtx
modifier|*
name|loc
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|jump
argument_list|)
argument_list|)
operator|==
name|PARALLEL
condition|)
name|loc
operator|=
operator|&
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|jump
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|loc
operator|=
operator|&
name|PATTERN
argument_list|(
name|jump
argument_list|)
expr_stmt|;
name|redirect_exp_1
argument_list|(
name|loc
argument_list|,
name|JUMP_LABEL
argument_list|(
name|jump
argument_list|)
argument_list|,
name|nlabel
argument_list|,
name|jump
argument_list|)
expr_stmt|;
return|return
name|num_validated_changes
argument_list|()
operator|>
name|ochanges
return|;
block|}
end_function

begin_comment
comment|/* Make JUMP go to NLABEL instead of where it jumps now.  If the old    jump target label is unused as a result, it and the code following    it may be deleted.     If NLABEL is zero, we are to turn the jump into a (possibly conditional)    RETURN insn.     The return value will be 1 if the change was made, 0 if it wasn't    (this can only occur for NLABEL == 0).  */
end_comment

begin_function
name|int
name|redirect_jump
parameter_list|(
name|rtx
name|jump
parameter_list|,
name|rtx
name|nlabel
parameter_list|,
name|int
name|delete_unused
parameter_list|)
block|{
name|rtx
name|olabel
init|=
name|JUMP_LABEL
argument_list|(
name|jump
argument_list|)
decl_stmt|;
name|rtx
name|note
decl_stmt|;
if|if
condition|(
name|nlabel
operator|==
name|olabel
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
name|redirect_exp
argument_list|(
name|olabel
argument_list|,
name|nlabel
argument_list|,
name|jump
argument_list|)
condition|)
return|return
literal|0
return|;
name|JUMP_LABEL
argument_list|(
name|jump
argument_list|)
operator|=
name|nlabel
expr_stmt|;
if|if
condition|(
name|nlabel
condition|)
operator|++
name|LABEL_NUSES
argument_list|(
name|nlabel
argument_list|)
expr_stmt|;
comment|/* Update labels in any REG_EQUAL note.  */
if|if
condition|(
operator|(
name|note
operator|=
name|find_reg_note
argument_list|(
name|jump
argument_list|,
name|REG_EQUAL
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
operator|!=
name|NULL_RTX
condition|)
block|{
if|if
condition|(
name|nlabel
operator|&&
name|olabel
condition|)
block|{
name|rtx
name|dest
init|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|IF_THEN_ELSE
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|&&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|olabel
condition|)
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|=
name|nlabel
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|&&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|2
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|olabel
condition|)
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|2
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|=
name|nlabel
expr_stmt|;
block|}
else|else
name|remove_note
argument_list|(
name|jump
argument_list|,
name|note
argument_list|)
expr_stmt|;
block|}
else|else
name|remove_note
argument_list|(
name|jump
argument_list|,
name|note
argument_list|)
expr_stmt|;
block|}
comment|/* If we're eliding the jump over exception cleanups at the end of a      function, move the function end note so that -Wreturn-type works.  */
if|if
condition|(
name|olabel
operator|&&
name|nlabel
operator|&&
name|NEXT_INSN
argument_list|(
name|olabel
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|NEXT_INSN
argument_list|(
name|olabel
argument_list|)
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|NEXT_INSN
argument_list|(
name|olabel
argument_list|)
argument_list|)
operator|==
name|NOTE_INSN_FUNCTION_END
condition|)
name|emit_note_after
argument_list|(
name|NOTE_INSN_FUNCTION_END
argument_list|,
name|nlabel
argument_list|)
expr_stmt|;
if|if
condition|(
name|olabel
operator|&&
operator|--
name|LABEL_NUSES
argument_list|(
name|olabel
argument_list|)
operator|==
literal|0
operator|&&
name|delete_unused
comment|/* Undefined labels will remain outside the insn stream.  */
operator|&&
name|INSN_UID
argument_list|(
name|olabel
argument_list|)
condition|)
name|delete_related_insns
argument_list|(
name|olabel
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Invert the jump condition of rtx X contained in jump insn, INSN.    Accrue the modifications into the change group.  */
end_comment

begin_function
specifier|static
name|void
name|invert_exp_1
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|RTX_CODE
name|code
decl_stmt|;
name|rtx
name|x
init|=
name|pc_set
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|x
condition|)
name|abort
argument_list|()
expr_stmt|;
name|x
operator|=
name|SET_SRC
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|IF_THEN_ELSE
condition|)
block|{
name|rtx
name|comp
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|tem
decl_stmt|;
name|enum
name|rtx_code
name|reversed_code
decl_stmt|;
comment|/* We can do this in two ways:  The preferable way, which can only 	 be done if this is not an integer comparison, is to reverse 	 the comparison code.  Otherwise, swap the THEN-part and ELSE-part 	 of the IF_THEN_ELSE.  If we can't do either, fail.  */
name|reversed_code
operator|=
name|reversed_comparison_code
argument_list|(
name|comp
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|reversed_code
operator|!=
name|UNKNOWN
condition|)
block|{
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|gen_rtx_fmt_ee
argument_list|(
name|reversed_code
argument_list|,
name|GET_MODE
argument_list|(
name|comp
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|comp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|comp
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
name|tem
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
argument_list|,
name|tem
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Invert the jump condition of conditional jump insn, INSN.     Return 1 if we can do so, 0 if we cannot find a way to do so that    matches a pattern.  */
end_comment

begin_function
specifier|static
name|int
name|invert_exp
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|invert_exp_1
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_validated_changes
argument_list|()
operator|==
literal|0
condition|)
return|return
literal|0
return|;
return|return
name|apply_change_group
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/* Invert the condition of the jump JUMP, and make it jump to label    NLABEL instead of where it jumps now.  Accrue changes into the    change group.  Return false if we didn't see how to perform the    inversion and redirection.  */
end_comment

begin_function
name|int
name|invert_jump_1
parameter_list|(
name|rtx
name|jump
parameter_list|,
name|rtx
name|nlabel
parameter_list|)
block|{
name|int
name|ochanges
decl_stmt|;
name|ochanges
operator|=
name|num_validated_changes
argument_list|()
expr_stmt|;
name|invert_exp_1
argument_list|(
name|jump
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_validated_changes
argument_list|()
operator|==
name|ochanges
condition|)
return|return
literal|0
return|;
return|return
name|redirect_jump_1
argument_list|(
name|jump
argument_list|,
name|nlabel
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Invert the condition of the jump JUMP, and make it jump to label    NLABEL instead of where it jumps now.  Return true if successful.  */
end_comment

begin_function
name|int
name|invert_jump
parameter_list|(
name|rtx
name|jump
parameter_list|,
name|rtx
name|nlabel
parameter_list|,
name|int
name|delete_unused
parameter_list|)
block|{
comment|/* We have to either invert the condition and change the label or      do neither.  Either operation could fail.  We first try to invert      the jump. If that succeeds, we try changing the label.  If that fails,      we invert the jump back to what it was.  */
if|if
condition|(
operator|!
name|invert_exp
argument_list|(
name|jump
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|redirect_jump
argument_list|(
name|jump
argument_list|,
name|nlabel
argument_list|,
name|delete_unused
argument_list|)
condition|)
block|{
comment|/* Remove REG_EQUAL note if we have one.  */
name|rtx
name|note
init|=
name|find_reg_note
argument_list|(
name|jump
argument_list|,
name|REG_EQUAL
argument_list|,
name|NULL_RTX
argument_list|)
decl_stmt|;
if|if
condition|(
name|note
condition|)
name|remove_note
argument_list|(
name|jump
argument_list|,
name|note
argument_list|)
expr_stmt|;
name|invert_br_probabilities
argument_list|(
name|jump
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|invert_exp
argument_list|(
name|jump
argument_list|)
condition|)
comment|/* This should just be putting it back the way it was.  */
name|abort
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Like rtx_equal_p except that it considers two REGs as equal    if they renumber to the same value and considers two commutative    operations to be the same if the order of the operands has been    reversed.     ??? Addition is not commutative on the PA due to the weird implicit    space register selection rules for memory addresses.  Therefore, we    don't consider a + b == b + a.     We could/should make this test a little tighter.  Possibly only    disabling it on the PA via some backend macro or only disabling this    case when the PLUS is inside a MEM.  */
end_comment

begin_function
name|int
name|rtx_renumbered_equal_p
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
name|y
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|RTX_CODE
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|x
operator|==
name|y
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|(
name|code
operator|==
name|REG
operator|||
operator|(
name|code
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|REG
operator|)
operator|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|REG
operator|||
operator|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|y
argument_list|)
argument_list|)
operator|==
name|REG
operator|)
operator|)
condition|)
block|{
name|int
name|reg_x
init|=
operator|-
literal|1
decl_stmt|,
name|reg_y
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|byte_x
init|=
literal|0
decl_stmt|,
name|byte_y
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|y
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* If we haven't done any renumbering, don't 	 make any assumptions.  */
if|if
condition|(
name|reg_renumber
operator|==
literal|0
condition|)
return|return
name|rtx_equal_p
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|SUBREG
condition|)
block|{
name|reg_x
operator|=
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|byte_x
operator|=
name|SUBREG_BYTE
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_renumber
index|[
name|reg_x
index|]
operator|>=
literal|0
condition|)
block|{
name|reg_x
operator|=
name|subreg_regno_offset
argument_list|(
name|reg_renumber
index|[
name|reg_x
index|]
argument_list|,
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|byte_x
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|byte_x
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|reg_x
operator|=
name|REGNO
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_renumber
index|[
name|reg_x
index|]
operator|>=
literal|0
condition|)
name|reg_x
operator|=
name|reg_renumber
index|[
name|reg_x
index|]
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
name|reg_y
operator|=
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|y
argument_list|)
argument_list|)
expr_stmt|;
name|byte_y
operator|=
name|SUBREG_BYTE
argument_list|(
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_renumber
index|[
name|reg_y
index|]
operator|>=
literal|0
condition|)
block|{
name|reg_y
operator|=
name|subreg_regno_offset
argument_list|(
name|reg_renumber
index|[
name|reg_y
index|]
argument_list|,
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|y
argument_list|)
argument_list|)
argument_list|,
name|byte_y
argument_list|,
name|GET_MODE
argument_list|(
name|y
argument_list|)
argument_list|)
expr_stmt|;
name|byte_y
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|reg_y
operator|=
name|REGNO
argument_list|(
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_renumber
index|[
name|reg_y
index|]
operator|>=
literal|0
condition|)
name|reg_y
operator|=
name|reg_renumber
index|[
name|reg_y
index|]
expr_stmt|;
block|}
return|return
name|reg_x
operator|>=
literal|0
operator|&&
name|reg_x
operator|==
name|reg_y
operator|&&
name|byte_x
operator|==
name|byte_y
return|;
block|}
comment|/* Now we have disposed of all the cases      in which different rtx codes can match.  */
if|if
condition|(
name|code
operator|!=
name|GET_CODE
argument_list|(
name|y
argument_list|)
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PC
case|:
case|case
name|CC0
case|:
case|case
name|ADDR_VEC
case|:
case|case
name|ADDR_DIFF_VEC
case|:
case|case
name|CONST_INT
case|:
return|return
literal|0
return|;
case|case
name|LABEL_REF
case|:
comment|/* We can't assume nonlocal labels have their following insns yet.  */
if|if
condition|(
name|LABEL_REF_NONLOCAL_P
argument_list|(
name|x
argument_list|)
operator|||
name|LABEL_REF_NONLOCAL_P
argument_list|(
name|y
argument_list|)
condition|)
return|return
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
return|;
comment|/* Two label-refs are equivalent if they point at labels 	 in the same position in the instruction stream.  */
return|return
operator|(
name|next_real_insn
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|next_real_insn
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|SYMBOL_REF
case|:
return|return
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|XSTR
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|CODE_LABEL
case|:
comment|/* If we didn't match EQ equality above, they aren't the same.  */
return|return
literal|0
return|;
default|default:
break|break;
block|}
comment|/* (MULT:SI x y) and (MULT:HI x y) are NOT equivalent.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|y
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* For commutative operations, the RTX match if the operand match in any      order.  Also handle the simple binary and unary cases without a loop.       ??? Don't consider PLUS a commutative operator; see comments above.  */
if|if
condition|(
operator|(
name|code
operator|==
name|EQ
operator|||
name|code
operator|==
name|NE
operator|||
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'c'
operator|)
operator|&&
name|code
operator|!=
name|PLUS
condition|)
return|return
operator|(
operator|(
name|rtx_renumbered_equal_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|rtx_renumbered_equal_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|rtx_renumbered_equal_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|rtx_renumbered_equal_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|)
return|;
elseif|else
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'<'
operator|||
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'2'
condition|)
return|return
operator|(
name|rtx_renumbered_equal_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|rtx_renumbered_equal_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'1'
condition|)
return|return
name|rtx_renumbered_equal_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
comment|/* Compare the elements.  If any pair of corresponding elements      fail to match, return 0 for the whole things.  */
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|int
name|j
decl_stmt|;
switch|switch
condition|(
name|fmt
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'w'
case|:
if|if
condition|(
name|XWINT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
name|XWINT
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'i'
case|:
if|if
condition|(
name|XINT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
name|XINT
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'t'
case|:
if|if
condition|(
name|XTREE
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
name|XTREE
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'s'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|XSTR
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|XSTR
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'e'
case|:
if|if
condition|(
operator|!
name|rtx_renumbered_equal_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'u'
case|:
if|if
condition|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
name|XEXP
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Fall through.  */
case|case
literal|'0'
case|:
break|break;
case|case
literal|'E'
case|:
if|if
condition|(
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
name|XVECLEN
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
operator|!
name|rtx_renumbered_equal_p
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|XVECEXP
argument_list|(
name|y
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If X is a hard register or equivalent to one or a subregister of one,    return the hard register number.  If X is a pseudo register that was not    assigned a hard register, return the pseudo register number.  Otherwise,    return -1.  Any rtx is valid for X.  */
end_comment

begin_function
name|int
name|true_regnum
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
block|{
if|if
condition|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|reg_renumber
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
operator|>=
literal|0
condition|)
return|return
name|reg_renumber
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
return|;
return|return
name|REGNO
argument_list|(
name|x
argument_list|)
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
name|int
name|base
init|=
name|true_regnum
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|base
operator|>=
literal|0
operator|&&
name|base
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
return|return
name|base
operator|+
name|subreg_regno_offset
argument_list|(
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|SUBREG_BYTE
argument_list|(
name|x
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return regno of the register REG and handle subregs too.  */
end_comment

begin_function
name|unsigned
name|int
name|reg_or_subregno
parameter_list|(
name|rtx
name|reg
parameter_list|)
block|{
if|if
condition|(
name|REG_P
argument_list|(
name|reg
argument_list|)
condition|)
return|return
name|REGNO
argument_list|(
name|reg
argument_list|)
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SUBREG
condition|)
return|return
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|reg
argument_list|)
argument_list|)
return|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

end_unit

