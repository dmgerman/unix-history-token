begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Optimize jump instructions, for GNU compiler.    Copyright (C) 1987, 1988, 1989, 1991, 1992, 1993, 1994, 1995, 1996, 1997    1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005    Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* This is the pathetic reminder of old fame of the jump-optimization pass    of the compiler.  Now it contains basically a set of utility functions to    operate with jumps.     Each CODE_LABEL has a count of the times it is used    stored in the LABEL_NUSES internal field, and each JUMP_INSN    has one label that it refers to stored in the    JUMP_LABEL internal field.  With this we can detect labels that    become unused because of the deletion of all the jumps that    formerly used them.  The JUMP_LABEL info is sometimes looked    at by later passes.     The subroutines redirect_jump and invert_jump are used    from other passes as well.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"insn-attr.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"reload.h"
end_include

begin_include
include|#
directive|include
file|"predict.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"tree-pass.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_comment
comment|/* Optimize jump y; x: ... y: jumpif... x?    Don't know if it is worth bothering with.  */
end_comment

begin_comment
comment|/* Optimize two cases of conditional jump to conditional jump?    This can never delete any instruction or make anything dead,    or even change what is live at any point.    So perhaps let combiner do it.  */
end_comment

begin_function_decl
specifier|static
name|void
name|init_label_info
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mark_all_labels
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|delete_computation
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|redirect_exp_1
parameter_list|(
name|rtx
modifier|*
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|invert_exp_1
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|returnjump_p_1
parameter_list|(
name|rtx
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|delete_prior_computation
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* Alternate entry into the jump optimizer.  This entry point only rebuilds    the JUMP_LABEL field in jumping insns and REG_LABEL notes in non-jumping    instructions.  */
end_comment

begin_function
name|void
name|rebuild_jump_labels
parameter_list|(
name|rtx
name|f
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
name|timevar_push
argument_list|(
name|TV_REBUILD_JUMP
argument_list|)
expr_stmt|;
name|init_label_info
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|mark_all_labels
argument_list|(
name|f
argument_list|)
expr_stmt|;
comment|/* Keep track of labels used from static data; we don't track them      closely enough to delete them here, so make sure their reference      count doesn't drop to zero.  */
for|for
control|(
name|insn
operator|=
name|forced_labels
init|;
name|insn
condition|;
name|insn
operator|=
name|XEXP
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|LABEL_P
argument_list|(
name|XEXP
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|LABEL_NUSES
argument_list|(
name|XEXP
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|++
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_REBUILD_JUMP
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Some old code expects exactly one BARRIER as the NEXT_INSN of a    non-fallthru insn.  This is not generally true, as multiple barriers    may have crept in, or the BARRIER may be separated from the last    real insn by one or more NOTEs.     This simple pass moves barriers and removes duplicates so that the    old code is happy.  */
end_comment

begin_function
name|unsigned
name|int
name|cleanup_barriers
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|,
name|next
decl_stmt|,
name|prev
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|next
control|)
block|{
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|BARRIER_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|prev
operator|=
name|prev_nonnote_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|BARRIER_P
argument_list|(
name|prev
argument_list|)
condition|)
name|delete_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|prev
operator|!=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
condition|)
name|reorder_insns
argument_list|(
name|insn
argument_list|,
name|insn
argument_list|,
name|prev
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|tree_opt_pass
name|pass_cleanup_barriers
init|=
block|{
literal|"barriers"
block|,
comment|/* name */
name|NULL
block|,
comment|/* gate */
name|cleanup_barriers
block|,
comment|/* execute */
name|NULL
block|,
comment|/* sub */
name|NULL
block|,
comment|/* next */
literal|0
block|,
comment|/* static_pass_number */
literal|0
block|,
comment|/* tv_id */
literal|0
block|,
comment|/* properties_required */
literal|0
block|,
comment|/* properties_provided */
literal|0
block|,
comment|/* properties_destroyed */
literal|0
block|,
comment|/* todo_flags_start */
name|TODO_dump_func
block|,
comment|/* todo_flags_finish */
literal|0
comment|/* letter */
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|unsigned
name|int
name|purge_line_number_notes
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|last_note
init|=
literal|0
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
comment|/* Delete extraneous line number notes.      Note that two consecutive notes for different lines are not really      extraneous.  There should be some indication where that line belonged,      even if it became empty.  */
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|NOTE_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_FUNCTION_BEG
condition|)
comment|/* Any previous line note was for the prologue; gdb wants a new 	     note after the prologue even if it is for the same line.  */
name|last_note
operator|=
name|NULL_RTX
expr_stmt|;
elseif|else
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|>=
literal|0
condition|)
block|{
comment|/* Delete this note if it is identical to previous note.  */
if|if
condition|(
name|last_note
ifdef|#
directive|ifdef
name|USE_MAPPED_LOCATION
operator|&&
name|NOTE_SOURCE_LOCATION
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_SOURCE_LOCATION
argument_list|(
name|last_note
argument_list|)
else|#
directive|else
operator|&&
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_SOURCE_FILE
argument_list|(
name|last_note
argument_list|)
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_LINE_NUMBER
argument_list|(
name|last_note
argument_list|)
endif|#
directive|endif
condition|)
block|{
name|delete_related_insns
argument_list|(
name|insn
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|last_note
operator|=
name|insn
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|tree_opt_pass
name|pass_purge_lineno_notes
init|=
block|{
literal|"elnotes"
block|,
comment|/* name */
name|NULL
block|,
comment|/* gate */
name|purge_line_number_notes
block|,
comment|/* execute */
name|NULL
block|,
comment|/* sub */
name|NULL
block|,
comment|/* next */
literal|0
block|,
comment|/* static_pass_number */
literal|0
block|,
comment|/* tv_id */
literal|0
block|,
comment|/* properties_required */
literal|0
block|,
comment|/* properties_provided */
literal|0
block|,
comment|/* properties_destroyed */
literal|0
block|,
comment|/* todo_flags_start */
name|TODO_dump_func
block|,
comment|/* todo_flags_finish */
literal|0
comment|/* letter */
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Initialize LABEL_NUSES and JUMP_LABEL fields.  Delete any REG_LABEL    notes whose labels don't occur in the insn any more.  Returns the    largest INSN_UID found.  */
end_comment

begin_function
specifier|static
name|void
name|init_label_info
parameter_list|(
name|rtx
name|f
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|f
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|LABEL_P
argument_list|(
name|insn
argument_list|)
condition|)
name|LABEL_NUSES
argument_list|(
name|insn
argument_list|)
operator|=
operator|(
name|LABEL_PRESERVE_P
argument_list|(
name|insn
argument_list|)
operator|!=
literal|0
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|JUMP_P
argument_list|(
name|insn
argument_list|)
condition|)
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|NONJUMP_INSN_P
argument_list|(
name|insn
argument_list|)
operator|||
name|CALL_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|rtx
name|note
decl_stmt|,
name|next
decl_stmt|;
for|for
control|(
name|note
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|note
condition|;
name|note
operator|=
name|next
control|)
block|{
name|next
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
operator|==
name|REG_LABEL
operator|&&
operator|!
name|reg_mentioned_p
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
name|remove_note
argument_list|(
name|insn
argument_list|,
name|note
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Mark the label each jump jumps to.    Combine consecutive labels, and count uses of labels.  */
end_comment

begin_function
specifier|static
name|void
name|mark_all_labels
parameter_list|(
name|rtx
name|f
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|f
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|mark_jump_label
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|INSN_DELETED_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|JUMP_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
comment|/* When we know the LABEL_REF contained in a REG used in 	       an indirect jump, we'll have a REG_LABEL note so that 	       flow can tell where it's going.  */
if|if
condition|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
operator|==
literal|0
condition|)
block|{
name|rtx
name|label_note
init|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_LABEL
argument_list|,
name|NULL_RTX
argument_list|)
decl_stmt|;
if|if
condition|(
name|label_note
condition|)
block|{
comment|/* But a LABEL_REF around the REG_LABEL note, so 		       that we can canonicalize it.  */
name|rtx
name|label_ref
init|=
name|gen_rtx_LABEL_REF
argument_list|(
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|label_note
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|mark_jump_label
argument_list|(
name|label_ref
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|label_note
argument_list|,
literal|0
argument_list|)
operator|=
name|XEXP
argument_list|(
name|label_ref
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
operator|=
name|XEXP
argument_list|(
name|label_note
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Move all block-beg, block-end and loop-beg notes between START and END out    before START.  START and END may be such notes.  Returns the values of the    new starting and ending insns, which may be different if the original ones    were such notes.  Return true if there were only such notes and no real    instructions.  */
end_comment

begin_function
name|bool
name|squeeze_notes
parameter_list|(
name|rtx
modifier|*
name|startp
parameter_list|,
name|rtx
modifier|*
name|endp
parameter_list|)
block|{
name|rtx
name|start
init|=
operator|*
name|startp
decl_stmt|;
name|rtx
name|end
init|=
operator|*
name|endp
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|rtx
name|next
decl_stmt|;
name|rtx
name|last
init|=
name|NULL
decl_stmt|;
name|rtx
name|past_end
init|=
name|NEXT_INSN
argument_list|(
name|end
argument_list|)
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|start
init|;
name|insn
operator|!=
name|past_end
condition|;
name|insn
operator|=
name|next
control|)
block|{
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|NOTE_P
argument_list|(
name|insn
argument_list|)
operator|&&
operator|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_BLOCK_END
operator|||
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_BLOCK_BEG
operator|)
condition|)
block|{
comment|/* BLOCK_BEG or BLOCK_END notes only exist in the `final' pass.  */
name|gcc_assert
argument_list|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE_INSN_BLOCK_BEG
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE_INSN_BLOCK_END
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|==
name|start
condition|)
name|start
operator|=
name|next
expr_stmt|;
else|else
block|{
name|rtx
name|prev
init|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
operator|=
name|PREV_INSN
argument_list|(
name|start
argument_list|)
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
operator|=
name|start
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|=
name|insn
expr_stmt|;
name|PREV_INSN
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|=
name|insn
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|prev
argument_list|)
operator|=
name|next
expr_stmt|;
name|PREV_INSN
argument_list|(
name|next
argument_list|)
operator|=
name|prev
expr_stmt|;
block|}
block|}
else|else
name|last
operator|=
name|insn
expr_stmt|;
block|}
comment|/* There were no real instructions.  */
if|if
condition|(
name|start
operator|==
name|past_end
condition|)
return|return
name|true
return|;
name|end
operator|=
name|last
expr_stmt|;
operator|*
name|startp
operator|=
name|start
expr_stmt|;
operator|*
name|endp
operator|=
name|end
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the label before INSN, or put a new label there.  */
end_comment

begin_function
name|rtx
name|get_label_before
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|rtx
name|label
decl_stmt|;
comment|/* Find an existing label at this point      or make a new one if there is none.  */
name|label
operator|=
name|prev_nonnote_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|label
operator|==
literal|0
operator|||
operator|!
name|LABEL_P
argument_list|(
name|label
argument_list|)
condition|)
block|{
name|rtx
name|prev
init|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|emit_label_after
argument_list|(
name|label
argument_list|,
name|prev
argument_list|)
expr_stmt|;
name|LABEL_NUSES
argument_list|(
name|label
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|label
return|;
block|}
end_function

begin_comment
comment|/* Return the label after INSN, or put a new label there.  */
end_comment

begin_function
name|rtx
name|get_label_after
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|rtx
name|label
decl_stmt|;
comment|/* Find an existing label at this point      or make a new one if there is none.  */
name|label
operator|=
name|next_nonnote_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|label
operator|==
literal|0
operator|||
operator|!
name|LABEL_P
argument_list|(
name|label
argument_list|)
condition|)
block|{
name|label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|emit_label_after
argument_list|(
name|label
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|LABEL_NUSES
argument_list|(
name|label
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|label
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a comparison (CODE ARG0 ARG1), inside an insn, INSN, return a code    of reversed comparison if it is possible to do so.  Otherwise return UNKNOWN.    UNKNOWN may be returned in case we are having CC_MODE compare and we don't    know whether it's source is floating point or integer comparison.  Machine    description should define REVERSIBLE_CC_MODE and REVERSE_CONDITION macros    to help this function avoid overhead in these cases.  */
end_comment

begin_function
name|enum
name|rtx_code
name|reversed_comparison_code_parts
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|,
name|rtx
name|arg0
parameter_list|,
name|rtx
name|arg1
parameter_list|,
name|rtx
name|insn
parameter_list|)
block|{
name|enum
name|machine_mode
name|mode
decl_stmt|;
comment|/* If this is not actually a comparison, we can't reverse it.  */
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|!=
name|RTX_COMPARE
operator|&&
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|!=
name|RTX_COMM_COMPARE
condition|)
return|return
name|UNKNOWN
return|;
name|mode
operator|=
name|GET_MODE
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
name|mode
operator|=
name|GET_MODE
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
comment|/* First see if machine description supplies us way to reverse the      comparison.  Give it priority over everything else to allow      machine description to do tricks.  */
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_CC
operator|&&
name|REVERSIBLE_CC_MODE
argument_list|(
name|mode
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|REVERSE_CONDITION
return|return
name|REVERSE_CONDITION
argument_list|(
name|code
argument_list|,
name|mode
argument_list|)
return|;
endif|#
directive|endif
return|return
name|reverse_condition
argument_list|(
name|code
argument_list|)
return|;
block|}
comment|/* Try a few special cases based on the comparison code.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|GEU
case|:
case|case
name|GTU
case|:
case|case
name|LEU
case|:
case|case
name|LTU
case|:
case|case
name|NE
case|:
case|case
name|EQ
case|:
comment|/* It is always safe to reverse EQ and NE, even for the floating 	 point.  Similarly the unsigned comparisons are never used for 	 floating point so we can reverse them in the default way.  */
return|return
name|reverse_condition
argument_list|(
name|code
argument_list|)
return|;
case|case
name|ORDERED
case|:
case|case
name|UNORDERED
case|:
case|case
name|LTGT
case|:
case|case
name|UNEQ
case|:
comment|/* In case we already see unordered comparison, we can be sure to 	 be dealing with floating point so we don't need any more tests.  */
return|return
name|reverse_condition_maybe_unordered
argument_list|(
name|code
argument_list|)
return|;
case|case
name|UNLT
case|:
case|case
name|UNLE
case|:
case|case
name|UNGT
case|:
case|case
name|UNGE
case|:
comment|/* We don't have safe way to reverse these yet.  */
return|return
name|UNKNOWN
return|;
default|default:
break|break;
block|}
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_CC
operator|||
name|CC0_P
argument_list|(
name|arg0
argument_list|)
condition|)
block|{
name|rtx
name|prev
decl_stmt|;
comment|/* Try to search for the comparison to determine the real mode.          This code is expensive, but with sane machine description it          will be never used, since REVERSIBLE_CC_MODE will return true          in all cases.  */
if|if
condition|(
operator|!
name|insn
condition|)
return|return
name|UNKNOWN
return|;
for|for
control|(
name|prev
operator|=
name|prev_nonnote_insn
argument_list|(
name|insn
argument_list|)
init|;
name|prev
operator|!=
literal|0
operator|&&
operator|!
name|LABEL_P
argument_list|(
name|prev
argument_list|)
condition|;
name|prev
operator|=
name|prev_nonnote_insn
argument_list|(
name|prev
argument_list|)
control|)
block|{
name|rtx
name|set
init|=
name|set_of
argument_list|(
name|arg0
argument_list|,
name|prev
argument_list|)
decl_stmt|;
if|if
condition|(
name|set
operator|&&
name|GET_CODE
argument_list|(
name|set
argument_list|)
operator|==
name|SET
operator|&&
name|rtx_equal_p
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|,
name|arg0
argument_list|)
condition|)
block|{
name|rtx
name|src
init|=
name|SET_SRC
argument_list|(
name|set
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|COMPARE
condition|)
block|{
name|rtx
name|comparison
init|=
name|src
decl_stmt|;
name|arg0
operator|=
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mode
operator|=
name|GET_MODE
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
name|mode
operator|=
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|comparison
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* We can get past reg-reg moves.  This may be useful for model 	         of i387 comparisons that first move flag registers around.  */
if|if
condition|(
name|REG_P
argument_list|(
name|src
argument_list|)
condition|)
block|{
name|arg0
operator|=
name|src
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* If register is clobbered in some ununderstandable way, 	     give up.  */
if|if
condition|(
name|set
condition|)
return|return
name|UNKNOWN
return|;
block|}
block|}
comment|/* Test for an integer condition, or a floating-point comparison      in which NaNs can be ignored.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|CONST_INT
operator|||
operator|(
name|GET_MODE
argument_list|(
name|arg0
argument_list|)
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|!=
name|MODE_CC
operator|&&
operator|!
name|HONOR_NANS
argument_list|(
name|mode
argument_list|)
operator|)
condition|)
return|return
name|reverse_condition
argument_list|(
name|code
argument_list|)
return|;
return|return
name|UNKNOWN
return|;
block|}
end_function

begin_comment
comment|/* A wrapper around the previous function to take COMPARISON as rtx    expression.  This simplifies many callers.  */
end_comment

begin_function
name|enum
name|rtx_code
name|reversed_comparison_code
parameter_list|(
name|rtx
name|comparison
parameter_list|,
name|rtx
name|insn
parameter_list|)
block|{
if|if
condition|(
operator|!
name|COMPARISON_P
argument_list|(
name|comparison
argument_list|)
condition|)
return|return
name|UNKNOWN
return|;
return|return
name|reversed_comparison_code_parts
argument_list|(
name|GET_CODE
argument_list|(
name|comparison
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|comparison
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|comparison
argument_list|,
literal|1
argument_list|)
argument_list|,
name|insn
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return comparison with reversed code of EXP.    Return NULL_RTX in case we fail to do the reversal.  */
end_comment

begin_function
name|rtx
name|reversed_comparison
parameter_list|(
name|rtx
name|exp
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|enum
name|rtx_code
name|reversed_code
init|=
name|reversed_comparison_code
argument_list|(
name|exp
argument_list|,
name|NULL_RTX
argument_list|)
decl_stmt|;
if|if
condition|(
name|reversed_code
operator|==
name|UNKNOWN
condition|)
return|return
name|NULL_RTX
return|;
else|else
return|return
name|simplify_gen_relational
argument_list|(
name|reversed_code
argument_list|,
name|mode
argument_list|,
name|VOIDmode
argument_list|,
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given an rtx-code for a comparison, return the code for the negated    comparison.  If no such code exists, return UNKNOWN.     WATCH OUT!  reverse_condition is not safe to use on a jump that might    be acting on the results of an IEEE floating point comparison, because    of the special treatment of non-signaling nans in comparisons.    Use reversed_comparison_code instead.  */
end_comment

begin_function
name|enum
name|rtx_code
name|reverse_condition
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|)
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|EQ
case|:
return|return
name|NE
return|;
case|case
name|NE
case|:
return|return
name|EQ
return|;
case|case
name|GT
case|:
return|return
name|LE
return|;
case|case
name|GE
case|:
return|return
name|LT
return|;
case|case
name|LT
case|:
return|return
name|GE
return|;
case|case
name|LE
case|:
return|return
name|GT
return|;
case|case
name|GTU
case|:
return|return
name|LEU
return|;
case|case
name|GEU
case|:
return|return
name|LTU
return|;
case|case
name|LTU
case|:
return|return
name|GEU
return|;
case|case
name|LEU
case|:
return|return
name|GTU
return|;
case|case
name|UNORDERED
case|:
return|return
name|ORDERED
return|;
case|case
name|ORDERED
case|:
return|return
name|UNORDERED
return|;
case|case
name|UNLT
case|:
case|case
name|UNLE
case|:
case|case
name|UNGT
case|:
case|case
name|UNGE
case|:
case|case
name|UNEQ
case|:
case|case
name|LTGT
case|:
return|return
name|UNKNOWN
return|;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Similar, but we're allowed to generate unordered comparisons, which    makes it safe for IEEE floating-point.  Of course, we have to recognize    that the target will support them too...  */
end_comment

begin_function
name|enum
name|rtx_code
name|reverse_condition_maybe_unordered
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|)
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|EQ
case|:
return|return
name|NE
return|;
case|case
name|NE
case|:
return|return
name|EQ
return|;
case|case
name|GT
case|:
return|return
name|UNLE
return|;
case|case
name|GE
case|:
return|return
name|UNLT
return|;
case|case
name|LT
case|:
return|return
name|UNGE
return|;
case|case
name|LE
case|:
return|return
name|UNGT
return|;
case|case
name|LTGT
case|:
return|return
name|UNEQ
return|;
case|case
name|UNORDERED
case|:
return|return
name|ORDERED
return|;
case|case
name|ORDERED
case|:
return|return
name|UNORDERED
return|;
case|case
name|UNLT
case|:
return|return
name|GE
return|;
case|case
name|UNLE
case|:
return|return
name|GT
return|;
case|case
name|UNGT
case|:
return|return
name|LE
return|;
case|case
name|UNGE
case|:
return|return
name|LT
return|;
case|case
name|UNEQ
case|:
return|return
name|LTGT
return|;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Similar, but return the code when two operands of a comparison are swapped.    This IS safe for IEEE floating-point.  */
end_comment

begin_function
name|enum
name|rtx_code
name|swap_condition
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|)
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|EQ
case|:
case|case
name|NE
case|:
case|case
name|UNORDERED
case|:
case|case
name|ORDERED
case|:
case|case
name|UNEQ
case|:
case|case
name|LTGT
case|:
return|return
name|code
return|;
case|case
name|GT
case|:
return|return
name|LT
return|;
case|case
name|GE
case|:
return|return
name|LE
return|;
case|case
name|LT
case|:
return|return
name|GT
return|;
case|case
name|LE
case|:
return|return
name|GE
return|;
case|case
name|GTU
case|:
return|return
name|LTU
return|;
case|case
name|GEU
case|:
return|return
name|LEU
return|;
case|case
name|LTU
case|:
return|return
name|GTU
return|;
case|case
name|LEU
case|:
return|return
name|GEU
return|;
case|case
name|UNLT
case|:
return|return
name|UNGT
return|;
case|case
name|UNLE
case|:
return|return
name|UNGE
return|;
case|case
name|UNGT
case|:
return|return
name|UNLT
return|;
case|case
name|UNGE
case|:
return|return
name|UNLE
return|;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Given a comparison CODE, return the corresponding unsigned comparison.    If CODE is an equality comparison or already an unsigned comparison,    CODE is returned.  */
end_comment

begin_function
name|enum
name|rtx_code
name|unsigned_condition
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|)
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|EQ
case|:
case|case
name|NE
case|:
case|case
name|GTU
case|:
case|case
name|GEU
case|:
case|case
name|LTU
case|:
case|case
name|LEU
case|:
return|return
name|code
return|;
case|case
name|GT
case|:
return|return
name|GTU
return|;
case|case
name|GE
case|:
return|return
name|GEU
return|;
case|case
name|LT
case|:
return|return
name|LTU
return|;
case|case
name|LE
case|:
return|return
name|LEU
return|;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Similarly, return the signed version of a comparison.  */
end_comment

begin_function
name|enum
name|rtx_code
name|signed_condition
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|)
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|EQ
case|:
case|case
name|NE
case|:
case|case
name|GT
case|:
case|case
name|GE
case|:
case|case
name|LT
case|:
case|case
name|LE
case|:
return|return
name|code
return|;
case|case
name|GTU
case|:
return|return
name|GT
return|;
case|case
name|GEU
case|:
return|return
name|GE
return|;
case|case
name|LTU
case|:
return|return
name|LT
return|;
case|case
name|LEU
case|:
return|return
name|LE
return|;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return nonzero if CODE1 is more strict than CODE2, i.e., if the    truth of CODE1 implies the truth of CODE2.  */
end_comment

begin_function
name|int
name|comparison_dominates_p
parameter_list|(
name|enum
name|rtx_code
name|code1
parameter_list|,
name|enum
name|rtx_code
name|code2
parameter_list|)
block|{
comment|/* UNKNOWN comparison codes can happen as a result of trying to revert      comparison codes.      They can't match anything, so we have to reject them here.  */
if|if
condition|(
name|code1
operator|==
name|UNKNOWN
operator|||
name|code2
operator|==
name|UNKNOWN
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|code1
operator|==
name|code2
condition|)
return|return
literal|1
return|;
switch|switch
condition|(
name|code1
condition|)
block|{
case|case
name|UNEQ
case|:
if|if
condition|(
name|code2
operator|==
name|UNLE
operator|||
name|code2
operator|==
name|UNGE
condition|)
return|return
literal|1
return|;
break|break;
case|case
name|EQ
case|:
if|if
condition|(
name|code2
operator|==
name|LE
operator|||
name|code2
operator|==
name|LEU
operator|||
name|code2
operator|==
name|GE
operator|||
name|code2
operator|==
name|GEU
operator|||
name|code2
operator|==
name|ORDERED
condition|)
return|return
literal|1
return|;
break|break;
case|case
name|UNLT
case|:
if|if
condition|(
name|code2
operator|==
name|UNLE
operator|||
name|code2
operator|==
name|NE
condition|)
return|return
literal|1
return|;
break|break;
case|case
name|LT
case|:
if|if
condition|(
name|code2
operator|==
name|LE
operator|||
name|code2
operator|==
name|NE
operator|||
name|code2
operator|==
name|ORDERED
operator|||
name|code2
operator|==
name|LTGT
condition|)
return|return
literal|1
return|;
break|break;
case|case
name|UNGT
case|:
if|if
condition|(
name|code2
operator|==
name|UNGE
operator|||
name|code2
operator|==
name|NE
condition|)
return|return
literal|1
return|;
break|break;
case|case
name|GT
case|:
if|if
condition|(
name|code2
operator|==
name|GE
operator|||
name|code2
operator|==
name|NE
operator|||
name|code2
operator|==
name|ORDERED
operator|||
name|code2
operator|==
name|LTGT
condition|)
return|return
literal|1
return|;
break|break;
case|case
name|GE
case|:
case|case
name|LE
case|:
if|if
condition|(
name|code2
operator|==
name|ORDERED
condition|)
return|return
literal|1
return|;
break|break;
case|case
name|LTGT
case|:
if|if
condition|(
name|code2
operator|==
name|NE
operator|||
name|code2
operator|==
name|ORDERED
condition|)
return|return
literal|1
return|;
break|break;
case|case
name|LTU
case|:
if|if
condition|(
name|code2
operator|==
name|LEU
operator|||
name|code2
operator|==
name|NE
condition|)
return|return
literal|1
return|;
break|break;
case|case
name|GTU
case|:
if|if
condition|(
name|code2
operator|==
name|GEU
operator|||
name|code2
operator|==
name|NE
condition|)
return|return
literal|1
return|;
break|break;
case|case
name|UNORDERED
case|:
if|if
condition|(
name|code2
operator|==
name|NE
operator|||
name|code2
operator|==
name|UNEQ
operator|||
name|code2
operator|==
name|UNLE
operator|||
name|code2
operator|==
name|UNLT
operator|||
name|code2
operator|==
name|UNGE
operator|||
name|code2
operator|==
name|UNGT
condition|)
return|return
literal|1
return|;
break|break;
default|default:
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if INSN is an unconditional jump and nothing else.  */
end_comment

begin_function
name|int
name|simplejump_p
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
return|return
operator|(
name|JUMP_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|PC
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if INSN is a (possibly) conditional jump    and nothing more.     Use of this function is deprecated, since we need to support combined    branch and compare insns.  Use any_condjump_p instead whenever possible.  */
end_comment

begin_function
name|int
name|condjump_p
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|rtx
name|x
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|SET
operator|||
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|PC
condition|)
return|return
literal|0
return|;
name|x
operator|=
name|SET_SRC
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|LABEL_REF
condition|)
return|return
literal|1
return|;
else|else
return|return
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|IF_THEN_ELSE
operator|&&
operator|(
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|==
name|PC
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|RETURN
operator|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|PC
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|==
name|RETURN
operator|)
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if INSN is a (possibly) conditional jump inside a    PARALLEL.     Use this function is deprecated, since we need to support combined    branch and compare insns.  Use any_condjump_p instead whenever possible.  */
end_comment

begin_function
name|int
name|condjump_in_parallel_p
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|rtx
name|x
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|PARALLEL
condition|)
return|return
literal|0
return|;
else|else
name|x
operator|=
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|SET
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|PC
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|IF_THEN_ELSE
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|2
argument_list|)
operator|==
name|pc_rtx
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|RETURN
operator|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
name|pc_rtx
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|==
name|RETURN
operator|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return set of PC, otherwise NULL.  */
end_comment

begin_function
name|rtx
name|pc_set
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|rtx
name|pat
decl_stmt|;
if|if
condition|(
operator|!
name|JUMP_P
argument_list|(
name|insn
argument_list|)
condition|)
return|return
name|NULL_RTX
return|;
name|pat
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* The set is allowed to appear either as the insn pattern or      the first set in a PARALLEL.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|PARALLEL
condition|)
name|pat
operator|=
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|==
name|PC
condition|)
return|return
name|pat
return|;
return|return
name|NULL_RTX
return|;
block|}
end_function

begin_comment
comment|/* Return true when insn is an unconditional direct jump,    possibly bundled inside a PARALLEL.  */
end_comment

begin_function
name|int
name|any_uncondjump_p
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|rtx
name|x
init|=
name|pc_set
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|x
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|LABEL_REF
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_NON_LOCAL_GOTO
argument_list|,
name|NULL_RTX
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return true when insn is a conditional jump.  This function works for    instructions containing PC sets in PARALLELs.  The instruction may have    various other effects so before removing the jump you must verify    onlyjump_p.     Note that unlike condjump_p it returns false for unconditional jumps.  */
end_comment

begin_function
name|int
name|any_condjump_p
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|rtx
name|x
init|=
name|pc_set
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|enum
name|rtx_code
name|a
decl_stmt|,
name|b
decl_stmt|;
if|if
condition|(
operator|!
name|x
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|IF_THEN_ELSE
condition|)
return|return
literal|0
return|;
name|a
operator|=
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|b
operator|=
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|b
operator|==
name|PC
operator|&&
operator|(
name|a
operator|==
name|LABEL_REF
operator|||
name|a
operator|==
name|RETURN
operator|)
operator|)
operator|||
operator|(
name|a
operator|==
name|PC
operator|&&
operator|(
name|b
operator|==
name|LABEL_REF
operator|||
name|b
operator|==
name|RETURN
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the label of a conditional jump.  */
end_comment

begin_function
name|rtx
name|condjump_label
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|rtx
name|x
init|=
name|pc_set
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|x
condition|)
return|return
name|NULL_RTX
return|;
name|x
operator|=
name|SET_SRC
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|LABEL_REF
condition|)
return|return
name|x
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|IF_THEN_ELSE
condition|)
return|return
name|NULL_RTX
return|;
if|if
condition|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
operator|==
name|pc_rtx
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
condition|)
return|return
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
return|;
if|if
condition|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|==
name|pc_rtx
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
condition|)
return|return
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
return|;
return|return
name|NULL_RTX
return|;
block|}
end_function

begin_comment
comment|/* Return true if INSN is a (possibly conditional) return insn.  */
end_comment

begin_function
specifier|static
name|int
name|returnjump_p_1
parameter_list|(
name|rtx
modifier|*
name|loc
parameter_list|,
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|rtx
name|x
init|=
operator|*
name|loc
decl_stmt|;
return|return
name|x
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|RETURN
operator|||
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SET
operator|&&
name|SET_IS_RETURN_P
argument_list|(
name|x
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|returnjump_p
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
if|if
condition|(
operator|!
name|JUMP_P
argument_list|(
name|insn
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|for_each_rtx
argument_list|(
operator|&
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|returnjump_p_1
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if INSN is a jump that only transfers control and    nothing more.  */
end_comment

begin_function
name|int
name|onlyjump_p
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|rtx
name|set
decl_stmt|;
if|if
condition|(
operator|!
name|JUMP_P
argument_list|(
name|insn
argument_list|)
condition|)
return|return
literal|0
return|;
name|set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|set
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|!=
name|PC
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|side_effects_p
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_cc0
end_ifdef

begin_comment
comment|/* Return nonzero if X is an RTX that only sets the condition codes    and has no side effects.  */
end_comment

begin_function
name|int
name|only_sets_cc0_p
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
if|if
condition|(
operator|!
name|x
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|INSN_P
argument_list|(
name|x
argument_list|)
condition|)
name|x
operator|=
name|PATTERN
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
name|sets_cc0_p
argument_list|(
name|x
argument_list|)
operator|==
literal|1
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|x
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if X is an RTX that does nothing but set the condition codes    and CLOBBER or USE registers.    Return -1 if X does explicitly set the condition codes,    but also does other things.  */
end_comment

begin_function
name|int
name|sets_cc0_p
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
if|if
condition|(
operator|!
name|x
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|INSN_P
argument_list|(
name|x
argument_list|)
condition|)
name|x
operator|=
name|PATTERN
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SET
operator|&&
name|SET_DEST
argument_list|(
name|x
argument_list|)
operator|==
name|cc0_rtx
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|sets_cc0
init|=
literal|0
decl_stmt|;
name|int
name|other_things
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|cc0_rtx
condition|)
name|sets_cc0
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|SET
condition|)
name|other_things
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|!
name|sets_cc0
condition|?
literal|0
else|:
name|other_things
condition|?
operator|-
literal|1
else|:
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Follow any unconditional jump at LABEL;    return the ultimate label reached by any such chain of jumps.    Return null if the chain ultimately leads to a return instruction.    If LABEL is not followed by a jump, return LABEL.    If the chain loops or we can't find end, return LABEL,    since that tells caller to avoid changing the insn.     If RELOAD_COMPLETED is 0, we do not chain across a USE or CLOBBER.  */
end_comment

begin_function
name|rtx
name|follow_jumps
parameter_list|(
name|rtx
name|label
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
name|rtx
name|next
decl_stmt|;
name|rtx
name|value
init|=
name|label
decl_stmt|;
name|int
name|depth
decl_stmt|;
for|for
control|(
name|depth
operator|=
literal|0
init|;
operator|(
name|depth
operator|<
literal|10
operator|&&
operator|(
name|insn
operator|=
name|next_active_insn
argument_list|(
name|value
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|JUMP_P
argument_list|(
name|insn
argument_list|)
operator|&&
operator|(
operator|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
operator|!=
literal|0
operator|&&
name|any_uncondjump_p
argument_list|(
name|insn
argument_list|)
operator|&&
name|onlyjump_p
argument_list|(
name|insn
argument_list|)
operator|)
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|RETURN
operator|)
operator|&&
operator|(
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
operator|)
operator|&&
name|BARRIER_P
argument_list|(
name|next
argument_list|)
operator|)
condition|;
name|depth
operator|++
control|)
block|{
name|rtx
name|tem
decl_stmt|;
if|if
condition|(
operator|!
name|reload_completed
operator|&&
name|flag_test_coverage
condition|)
block|{
comment|/* ??? Optional.  Disables some optimizations, but makes 	     gcov output more accurate with -O.  */
for|for
control|(
name|tem
operator|=
name|value
init|;
name|tem
operator|!=
name|insn
condition|;
name|tem
operator|=
name|NEXT_INSN
argument_list|(
name|tem
argument_list|)
control|)
if|if
condition|(
name|NOTE_P
argument_list|(
name|tem
argument_list|)
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|tem
argument_list|)
operator|>
literal|0
condition|)
return|return
name|value
return|;
block|}
comment|/* If we have found a cycle, make the insn jump to itself.  */
if|if
condition|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
operator|==
name|label
condition|)
return|return
name|label
return|;
name|tem
operator|=
name|next_active_insn
argument_list|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|tem
argument_list|)
argument_list|)
operator|==
name|ADDR_VEC
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|tem
argument_list|)
argument_list|)
operator|==
name|ADDR_DIFF_VEC
operator|)
condition|)
break|break;
name|value
operator|=
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|depth
operator|==
literal|10
condition|)
return|return
name|label
return|;
return|return
name|value
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Find all CODE_LABELs referred to in X, and increment their use counts.    If INSN is a JUMP_INSN and there is at least one CODE_LABEL referenced    in INSN, then store one of them in JUMP_LABEL (INSN).    If INSN is an INSN or a CALL_INSN and there is at least one CODE_LABEL    referenced in INSN, add a REG_LABEL note containing that label to INSN.    Also, when there are consecutive labels, canonicalize on the last of them.     Note that two labels separated by a loop-beginning note    must be kept distinct if we have not yet done loop-optimization,    because the gap between them is where loop-optimize    will want to move invariant code to.  CROSS_JUMP tells us    that loop-optimization is done with.  */
end_comment

begin_function
name|void
name|mark_jump_label
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
name|insn
parameter_list|,
name|int
name|in_mem
parameter_list|)
block|{
name|RTX_CODE
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PC
case|:
case|case
name|CC0
case|:
case|case
name|REG
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CLOBBER
case|:
case|case
name|CALL
case|:
return|return;
case|case
name|MEM
case|:
name|in_mem
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|SYMBOL_REF
case|:
if|if
condition|(
operator|!
name|in_mem
condition|)
return|return;
comment|/* If this is a constant-pool reference, see if it is a label.  */
if|if
condition|(
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|x
argument_list|)
condition|)
name|mark_jump_label
argument_list|(
name|get_pool_constant
argument_list|(
name|x
argument_list|)
argument_list|,
name|insn
argument_list|,
name|in_mem
argument_list|)
expr_stmt|;
break|break;
case|case
name|LABEL_REF
case|:
block|{
name|rtx
name|label
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* Ignore remaining references to unreachable labels that 	   have been deleted.  */
if|if
condition|(
name|NOTE_P
argument_list|(
name|label
argument_list|)
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|label
argument_list|)
operator|==
name|NOTE_INSN_DELETED_LABEL
condition|)
break|break;
name|gcc_assert
argument_list|(
name|LABEL_P
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Ignore references to labels of containing functions.  */
if|if
condition|(
name|LABEL_REF_NONLOCAL_P
argument_list|(
name|x
argument_list|)
condition|)
break|break;
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|=
name|label
expr_stmt|;
if|if
condition|(
operator|!
name|insn
operator|||
operator|!
name|INSN_DELETED_P
argument_list|(
name|insn
argument_list|)
condition|)
operator|++
name|LABEL_NUSES
argument_list|(
name|label
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
condition|)
block|{
if|if
condition|(
name|JUMP_P
argument_list|(
name|insn
argument_list|)
condition|)
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
operator|=
name|label
expr_stmt|;
else|else
block|{
comment|/* Add a REG_LABEL note for LABEL unless there already 		   is one.  All uses of a label, except for labels 		   that are the targets of jumps, must have a 		   REG_LABEL note.  */
if|if
condition|(
operator|!
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_LABEL
argument_list|,
name|label
argument_list|)
condition|)
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_INSN_LIST
argument_list|(
name|REG_LABEL
argument_list|,
name|label
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
comment|/* Do walk the labels in a vector, but not the first operand of an      ADDR_DIFF_VEC.  Don't set the JUMP_LABEL of a vector.  */
case|case
name|ADDR_VEC
case|:
case|case
name|ADDR_DIFF_VEC
case|:
if|if
condition|(
operator|!
name|INSN_DELETED_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|int
name|eltnum
init|=
name|code
operator|==
name|ADDR_DIFF_VEC
condition|?
literal|1
else|:
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|eltnum
argument_list|)
condition|;
name|i
operator|++
control|)
name|mark_jump_label
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|eltnum
argument_list|,
name|i
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|in_mem
argument_list|)
expr_stmt|;
block|}
return|return;
default|default:
break|break;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|mark_jump_label
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|insn
argument_list|,
name|in_mem
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|mark_jump_label
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|insn
argument_list|,
name|in_mem
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* If all INSN does is set the pc, delete it,    and delete the insn that set the condition codes for it    if that's what the previous thing was.  */
end_comment

begin_function
name|void
name|delete_jump
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|rtx
name|set
init|=
name|single_set
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|set
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|PC
condition|)
name|delete_computation
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Recursively delete prior insns that compute the value (used only by INSN    which the caller is deleting) stored in the register mentioned by NOTE    which is a REG_DEAD note associated with INSN.  */
end_comment

begin_function
specifier|static
name|void
name|delete_prior_computation
parameter_list|(
name|rtx
name|note
parameter_list|,
name|rtx
name|insn
parameter_list|)
block|{
name|rtx
name|our_prev
decl_stmt|;
name|rtx
name|reg
init|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
decl_stmt|;
for|for
control|(
name|our_prev
operator|=
name|prev_nonnote_insn
argument_list|(
name|insn
argument_list|)
init|;
name|our_prev
operator|&&
operator|(
name|NONJUMP_INSN_P
argument_list|(
name|our_prev
argument_list|)
operator|||
name|CALL_P
argument_list|(
name|our_prev
argument_list|)
operator|)
condition|;
name|our_prev
operator|=
name|prev_nonnote_insn
argument_list|(
name|our_prev
argument_list|)
control|)
block|{
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|our_prev
argument_list|)
decl_stmt|;
comment|/* If we reach a CALL which is not calling a const function 	 or the callee pops the arguments, then give up.  */
if|if
condition|(
name|CALL_P
argument_list|(
name|our_prev
argument_list|)
operator|&&
operator|(
operator|!
name|CONST_OR_PURE_CALL_P
argument_list|(
name|our_prev
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|!=
name|SET
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|!=
name|CALL
operator|)
condition|)
break|break;
comment|/* If we reach a SEQUENCE, it is too complex to try to 	 do anything with it, so give up.  We can be run during 	 and after reorg, so SEQUENCE rtl can legitimately show 	 up here.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|SEQUENCE
condition|)
break|break;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|USE
operator|&&
name|NONJUMP_INSN_P
argument_list|(
name|XEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
comment|/* reorg creates USEs that look like this.  We leave them 	   alone because reorg needs them for its own purposes.  */
break|break;
if|if
condition|(
name|reg_set_p
argument_list|(
name|reg
argument_list|,
name|pat
argument_list|)
condition|)
block|{
if|if
condition|(
name|side_effects_p
argument_list|(
name|pat
argument_list|)
operator|&&
operator|!
name|CALL_P
argument_list|(
name|our_prev
argument_list|)
condition|)
break|break;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
comment|/* If we find a SET of something else, we can't 		 delete the insn.  */
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|part
init|=
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|part
argument_list|)
operator|==
name|SET
operator|&&
name|SET_DEST
argument_list|(
name|part
argument_list|)
operator|!=
name|reg
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
condition|)
name|delete_computation
argument_list|(
name|our_prev
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|SET
operator|&&
name|REG_P
argument_list|(
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|)
condition|)
block|{
name|int
name|dest_regno
init|=
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|dest_endregno
init|=
operator|(
name|dest_regno
operator|+
operator|(
name|dest_regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|?
name|hard_regno_nregs
index|[
name|dest_regno
index|]
index|[
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|)
index|]
else|:
literal|1
operator|)
operator|)
decl_stmt|;
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|reg
argument_list|)
decl_stmt|;
name|int
name|endregno
init|=
operator|(
name|regno
operator|+
operator|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|?
name|hard_regno_nregs
index|[
name|regno
index|]
index|[
name|GET_MODE
argument_list|(
name|reg
argument_list|)
index|]
else|:
literal|1
operator|)
operator|)
decl_stmt|;
if|if
condition|(
name|dest_regno
operator|>=
name|regno
operator|&&
name|dest_endregno
operator|<=
name|endregno
condition|)
name|delete_computation
argument_list|(
name|our_prev
argument_list|)
expr_stmt|;
comment|/* We may have a multi-word hard register and some, but not 		 all, of the words of the register are needed in subsequent 		 insns.  Write REG_UNUSED notes for those parts that were not 		 needed.  */
elseif|else
if|if
condition|(
name|dest_regno
operator|<=
name|regno
operator|&&
name|dest_endregno
operator|>=
name|endregno
condition|)
block|{
name|int
name|i
decl_stmt|;
name|REG_NOTES
argument_list|(
name|our_prev
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_UNUSED
argument_list|,
name|reg
argument_list|,
name|REG_NOTES
argument_list|(
name|our_prev
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|dest_regno
init|;
name|i
operator|<
name|dest_endregno
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|find_regno_note
argument_list|(
name|our_prev
argument_list|,
name|REG_UNUSED
argument_list|,
name|i
argument_list|)
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|dest_endregno
condition|)
name|delete_computation
argument_list|(
name|our_prev
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
comment|/* If PAT references the register that dies here, it is an 	 additional use.  Hence any prior SET isn't dead.  However, this 	 insn becomes the new place for the REG_DEAD note.  */
if|if
condition|(
name|reg_overlap_mentioned_p
argument_list|(
name|reg
argument_list|,
name|pat
argument_list|)
condition|)
block|{
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
operator|=
name|REG_NOTES
argument_list|(
name|our_prev
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|our_prev
argument_list|)
operator|=
name|note
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Delete INSN and recursively delete insns that compute values used only    by INSN.  This uses the REG_DEAD notes computed during flow analysis.    If we are running before flow.c, we need do nothing since flow.c will    delete dead code.  We also can't know if the registers being used are    dead or not at this point.     Otherwise, look at all our REG_DEAD notes.  If a previous insn does    nothing other than set a register that dies in this insn, we can delete    that insn as well.     On machines with CC0, if CC0 is used in this insn, we may be able to    delete the insn that set it.  */
end_comment

begin_function
specifier|static
name|void
name|delete_computation
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|rtx
name|note
decl_stmt|,
name|next
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_cc0
if|if
condition|(
name|reg_referenced_p
argument_list|(
name|cc0_rtx
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|prev
init|=
name|prev_nonnote_insn
argument_list|(
name|insn
argument_list|)
decl_stmt|;
comment|/* We assume that at this stage 	 CC's are always set explicitly 	 and always immediately before the jump that 	 will use them.  So if the previous insn 	 exists to set the CC's, delete it 	 (unless it performs auto-increments, etc.).  */
if|if
condition|(
name|prev
operator|&&
name|NONJUMP_INSN_P
argument_list|(
name|prev
argument_list|)
operator|&&
name|sets_cc0_p
argument_list|(
name|PATTERN
argument_list|(
name|prev
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|sets_cc0_p
argument_list|(
name|PATTERN
argument_list|(
name|prev
argument_list|)
argument_list|)
operator|>
literal|0
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|PATTERN
argument_list|(
name|prev
argument_list|)
argument_list|)
condition|)
name|delete_computation
argument_list|(
name|prev
argument_list|)
expr_stmt|;
else|else
comment|/* Otherwise, show that cc0 won't be used.  */
name|REG_NOTES
argument_list|(
name|prev
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_UNUSED
argument_list|,
name|cc0_rtx
argument_list|,
name|REG_NOTES
argument_list|(
name|prev
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
for|for
control|(
name|note
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|note
condition|;
name|note
operator|=
name|next
control|)
block|{
name|next
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
operator|!=
name|REG_DEAD
comment|/* Verify that the REG_NOTE is legitimate.  */
operator|||
operator|!
name|REG_P
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
continue|continue;
name|delete_prior_computation
argument_list|(
name|note
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
name|delete_related_insns
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Delete insn INSN from the chain of insns and update label ref counts    and delete insns now unreachable.     Returns the first insn after INSN that was not deleted.     Usage of this instruction is deprecated.  Use delete_insn instead and    subsequent cfg_cleanup pass to delete unreachable code if needed.  */
end_comment

begin_function
name|rtx
name|delete_related_insns
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|int
name|was_code_label
init|=
operator|(
name|LABEL_P
argument_list|(
name|insn
argument_list|)
operator|)
decl_stmt|;
name|rtx
name|note
decl_stmt|;
name|rtx
name|next
init|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|,
name|prev
init|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
while|while
condition|(
name|next
operator|&&
name|INSN_DELETED_P
argument_list|(
name|next
argument_list|)
condition|)
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|next
argument_list|)
expr_stmt|;
comment|/* This insn is already deleted => return first following nondeleted.  */
if|if
condition|(
name|INSN_DELETED_P
argument_list|(
name|insn
argument_list|)
condition|)
return|return
name|next
return|;
name|delete_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* If instruction is followed by a barrier,      delete the barrier too.  */
if|if
condition|(
name|next
operator|!=
literal|0
operator|&&
name|BARRIER_P
argument_list|(
name|next
argument_list|)
condition|)
name|delete_insn
argument_list|(
name|next
argument_list|)
expr_stmt|;
comment|/* If deleting a jump, decrement the count of the label,      and delete the label if it is now unused.  */
if|if
condition|(
name|JUMP_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|rtx
name|lab
init|=
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
decl_stmt|,
name|lab_next
decl_stmt|;
if|if
condition|(
name|LABEL_NUSES
argument_list|(
name|lab
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* This can delete NEXT or PREV, 	     either directly if NEXT is JUMP_LABEL (INSN), 	     or indirectly through more levels of jumps.  */
name|delete_related_insns
argument_list|(
name|lab
argument_list|)
expr_stmt|;
comment|/* I feel a little doubtful about this loop, 	     but I see no clean and sure alternative way 	     to find the first insn after INSN that is not now deleted. 	     I hope this works.  */
while|while
condition|(
name|next
operator|&&
name|INSN_DELETED_P
argument_list|(
name|next
argument_list|)
condition|)
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|next
argument_list|)
expr_stmt|;
return|return
name|next
return|;
block|}
elseif|else
if|if
condition|(
name|tablejump_p
argument_list|(
name|insn
argument_list|,
name|NULL
argument_list|,
operator|&
name|lab_next
argument_list|)
condition|)
block|{
comment|/* If we're deleting the tablejump, delete the dispatch table. 	     We may not be able to kill the label immediately preceding 	     just yet, as it might be referenced in code leading up to 	     the tablejump.  */
name|delete_related_insns
argument_list|(
name|lab_next
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Likewise if we're deleting a dispatch table.  */
if|if
condition|(
name|JUMP_P
argument_list|(
name|insn
argument_list|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|ADDR_VEC
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|ADDR_DIFF_VEC
operator|)
condition|)
block|{
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|diff_vec_p
init|=
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|ADDR_DIFF_VEC
decl_stmt|;
name|int
name|len
init|=
name|XVECLEN
argument_list|(
name|pat
argument_list|,
name|diff_vec_p
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|LABEL_NUSES
argument_list|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
name|diff_vec_p
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|delete_related_insns
argument_list|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
name|diff_vec_p
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|next
operator|&&
name|INSN_DELETED_P
argument_list|(
name|next
argument_list|)
condition|)
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|next
argument_list|)
expr_stmt|;
return|return
name|next
return|;
block|}
comment|/* Likewise for an ordinary INSN / CALL_INSN with a REG_LABEL note.  */
if|if
condition|(
name|NONJUMP_INSN_P
argument_list|(
name|insn
argument_list|)
operator|||
name|CALL_P
argument_list|(
name|insn
argument_list|)
condition|)
for|for
control|(
name|note
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|note
condition|;
name|note
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
operator|==
name|REG_LABEL
comment|/* This could also be a NOTE_INSN_DELETED_LABEL note.  */
operator|&&
name|LABEL_P
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
if|if
condition|(
name|LABEL_NUSES
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|delete_related_insns
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|prev
operator|&&
operator|(
name|INSN_DELETED_P
argument_list|(
name|prev
argument_list|)
operator|||
name|NOTE_P
argument_list|(
name|prev
argument_list|)
operator|)
condition|)
name|prev
operator|=
name|PREV_INSN
argument_list|(
name|prev
argument_list|)
expr_stmt|;
comment|/* If INSN was a label and a dispatch table follows it,      delete the dispatch table.  The tablejump must have gone already.      It isn't useful to fall through into a table.  */
if|if
condition|(
name|was_code_label
operator|&&
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
operator|!=
literal|0
operator|&&
name|JUMP_P
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|ADDR_VEC
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|ADDR_DIFF_VEC
operator|)
condition|)
name|next
operator|=
name|delete_related_insns
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If INSN was a label, delete insns following it if now unreachable.  */
if|if
condition|(
name|was_code_label
operator|&&
name|prev
operator|&&
name|BARRIER_P
argument_list|(
name|prev
argument_list|)
condition|)
block|{
name|enum
name|rtx_code
name|code
decl_stmt|;
while|while
condition|(
name|next
condition|)
block|{
name|code
operator|=
name|GET_CODE
argument_list|(
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|next
argument_list|)
operator|!=
name|NOTE_INSN_FUNCTION_END
condition|)
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|next
argument_list|)
expr_stmt|;
comment|/* Keep going past other deleted labels to delete what follows.  */
elseif|else
if|if
condition|(
name|code
operator|==
name|CODE_LABEL
operator|&&
name|INSN_DELETED_P
argument_list|(
name|next
argument_list|)
condition|)
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|next
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|BARRIER
operator|||
name|INSN_P
argument_list|(
name|next
argument_list|)
condition|)
comment|/* Note: if this deletes a jump, it can cause more 	       deletion of unreachable code, after a different label. 	       As long as the value from this recursive call is correct, 	       this invocation functions correctly.  */
name|next
operator|=
name|delete_related_insns
argument_list|(
name|next
argument_list|)
expr_stmt|;
else|else
break|break;
block|}
block|}
return|return
name|next
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Delete a range of insns from FROM to TO, inclusive.    This is for the sake of peephole optimization, so assume    that whatever these insns do will still be done by a new    peephole insn that will replace them.  */
end_comment

begin_function
name|void
name|delete_for_peephole
parameter_list|(
name|rtx
name|from
parameter_list|,
name|rtx
name|to
parameter_list|)
block|{
name|rtx
name|insn
init|=
name|from
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|rtx
name|next
init|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|prev
init|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|NOTE_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|INSN_DELETED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Patch this insn out of the chain.  */
comment|/* We don't do this all at once, because we 	     must preserve all NOTEs.  */
if|if
condition|(
name|prev
condition|)
name|NEXT_INSN
argument_list|(
name|prev
argument_list|)
operator|=
name|next
expr_stmt|;
if|if
condition|(
name|next
condition|)
name|PREV_INSN
argument_list|(
name|next
argument_list|)
operator|=
name|prev
expr_stmt|;
block|}
if|if
condition|(
name|insn
operator|==
name|to
condition|)
break|break;
name|insn
operator|=
name|next
expr_stmt|;
block|}
comment|/* Note that if TO is an unconditional jump      we *do not* delete the BARRIER that follows,      since the peephole that replaces this sequence      is also an unconditional jump in that case.  */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Throughout LOC, redirect OLABEL to NLABEL.  Treat null OLABEL or    NLABEL as a return.  Accrue modifications into the change group.  */
end_comment

begin_function
specifier|static
name|void
name|redirect_exp_1
parameter_list|(
name|rtx
modifier|*
name|loc
parameter_list|,
name|rtx
name|olabel
parameter_list|,
name|rtx
name|nlabel
parameter_list|,
name|rtx
name|insn
parameter_list|)
block|{
name|rtx
name|x
init|=
operator|*
name|loc
decl_stmt|;
name|RTX_CODE
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|LABEL_REF
condition|)
block|{
if|if
condition|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|olabel
condition|)
block|{
name|rtx
name|n
decl_stmt|;
if|if
condition|(
name|nlabel
condition|)
name|n
operator|=
name|gen_rtx_LABEL_REF
argument_list|(
name|Pmode
argument_list|,
name|nlabel
argument_list|)
expr_stmt|;
else|else
name|n
operator|=
name|gen_rtx_RETURN
argument_list|(
name|VOIDmode
argument_list|)
expr_stmt|;
name|validate_change
argument_list|(
name|insn
argument_list|,
name|loc
argument_list|,
name|n
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|RETURN
operator|&&
name|olabel
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|nlabel
condition|)
name|x
operator|=
name|gen_rtx_LABEL_REF
argument_list|(
name|Pmode
argument_list|,
name|nlabel
argument_list|)
expr_stmt|;
else|else
name|x
operator|=
name|gen_rtx_RETURN
argument_list|(
name|VOIDmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|loc
operator|==
operator|&
name|PATTERN
argument_list|(
name|insn
argument_list|)
condition|)
name|x
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|pc_rtx
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|validate_change
argument_list|(
name|insn
argument_list|,
name|loc
argument_list|,
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|code
operator|==
name|SET
operator|&&
name|nlabel
operator|==
literal|0
operator|&&
name|SET_DEST
argument_list|(
name|x
argument_list|)
operator|==
name|pc_rtx
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|&&
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|olabel
condition|)
block|{
name|validate_change
argument_list|(
name|insn
argument_list|,
name|loc
argument_list|,
name|gen_rtx_RETURN
argument_list|(
name|VOIDmode
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|redirect_exp_1
argument_list|(
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|olabel
argument_list|,
name|nlabel
argument_list|,
name|insn
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|redirect_exp_1
argument_list|(
operator|&
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|olabel
argument_list|,
name|nlabel
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Make JUMP go to NLABEL instead of where it jumps now.  Accrue    the modifications into the change group.  Return false if we did    not see how to do that.  */
end_comment

begin_function
name|int
name|redirect_jump_1
parameter_list|(
name|rtx
name|jump
parameter_list|,
name|rtx
name|nlabel
parameter_list|)
block|{
name|int
name|ochanges
init|=
name|num_validated_changes
argument_list|()
decl_stmt|;
name|rtx
modifier|*
name|loc
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|jump
argument_list|)
argument_list|)
operator|==
name|PARALLEL
condition|)
name|loc
operator|=
operator|&
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|jump
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|loc
operator|=
operator|&
name|PATTERN
argument_list|(
name|jump
argument_list|)
expr_stmt|;
name|redirect_exp_1
argument_list|(
name|loc
argument_list|,
name|JUMP_LABEL
argument_list|(
name|jump
argument_list|)
argument_list|,
name|nlabel
argument_list|,
name|jump
argument_list|)
expr_stmt|;
return|return
name|num_validated_changes
argument_list|()
operator|>
name|ochanges
return|;
block|}
end_function

begin_comment
comment|/* Make JUMP go to NLABEL instead of where it jumps now.  If the old    jump target label is unused as a result, it and the code following    it may be deleted.     If NLABEL is zero, we are to turn the jump into a (possibly conditional)    RETURN insn.     The return value will be 1 if the change was made, 0 if it wasn't    (this can only occur for NLABEL == 0).  */
end_comment

begin_function
name|int
name|redirect_jump
parameter_list|(
name|rtx
name|jump
parameter_list|,
name|rtx
name|nlabel
parameter_list|,
name|int
name|delete_unused
parameter_list|)
block|{
name|rtx
name|olabel
init|=
name|JUMP_LABEL
argument_list|(
name|jump
argument_list|)
decl_stmt|;
if|if
condition|(
name|nlabel
operator|==
name|olabel
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
name|redirect_jump_1
argument_list|(
name|jump
argument_list|,
name|nlabel
argument_list|)
operator|||
operator|!
name|apply_change_group
argument_list|()
condition|)
return|return
literal|0
return|;
name|redirect_jump_2
argument_list|(
name|jump
argument_list|,
name|olabel
argument_list|,
name|nlabel
argument_list|,
name|delete_unused
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Fix up JUMP_LABEL and label ref counts after OLABEL has been replaced with    NLABEL in JUMP.  If DELETE_UNUSED is non-negative, copy a    NOTE_INSN_FUNCTION_END found after OLABEL to the place after NLABEL.    If DELETE_UNUSED is positive, delete related insn to OLABEL if its ref    count has dropped to zero.  */
end_comment

begin_function
name|void
name|redirect_jump_2
parameter_list|(
name|rtx
name|jump
parameter_list|,
name|rtx
name|olabel
parameter_list|,
name|rtx
name|nlabel
parameter_list|,
name|int
name|delete_unused
parameter_list|,
name|int
name|invert
parameter_list|)
block|{
name|rtx
name|note
decl_stmt|;
name|JUMP_LABEL
argument_list|(
name|jump
argument_list|)
operator|=
name|nlabel
expr_stmt|;
if|if
condition|(
name|nlabel
condition|)
operator|++
name|LABEL_NUSES
argument_list|(
name|nlabel
argument_list|)
expr_stmt|;
comment|/* Update labels in any REG_EQUAL note.  */
if|if
condition|(
operator|(
name|note
operator|=
name|find_reg_note
argument_list|(
name|jump
argument_list|,
name|REG_EQUAL
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
operator|!=
name|NULL_RTX
condition|)
block|{
if|if
condition|(
operator|!
name|nlabel
operator|||
operator|(
name|invert
operator|&&
operator|!
name|invert_exp_1
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|jump
argument_list|)
operator|)
condition|)
name|remove_note
argument_list|(
name|jump
argument_list|,
name|note
argument_list|)
expr_stmt|;
else|else
block|{
name|redirect_exp_1
argument_list|(
operator|&
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|olabel
argument_list|,
name|nlabel
argument_list|,
name|jump
argument_list|)
expr_stmt|;
name|confirm_change_group
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* If we're eliding the jump over exception cleanups at the end of a      function, move the function end note so that -Wreturn-type works.  */
if|if
condition|(
name|olabel
operator|&&
name|nlabel
operator|&&
name|NEXT_INSN
argument_list|(
name|olabel
argument_list|)
operator|&&
name|NOTE_P
argument_list|(
name|NEXT_INSN
argument_list|(
name|olabel
argument_list|)
argument_list|)
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|NEXT_INSN
argument_list|(
name|olabel
argument_list|)
argument_list|)
operator|==
name|NOTE_INSN_FUNCTION_END
operator|&&
name|delete_unused
operator|>=
literal|0
condition|)
name|emit_note_after
argument_list|(
name|NOTE_INSN_FUNCTION_END
argument_list|,
name|nlabel
argument_list|)
expr_stmt|;
if|if
condition|(
name|olabel
operator|&&
operator|--
name|LABEL_NUSES
argument_list|(
name|olabel
argument_list|)
operator|==
literal|0
operator|&&
name|delete_unused
operator|>
literal|0
comment|/* Undefined labels will remain outside the insn stream.  */
operator|&&
name|INSN_UID
argument_list|(
name|olabel
argument_list|)
condition|)
name|delete_related_insns
argument_list|(
name|olabel
argument_list|)
expr_stmt|;
if|if
condition|(
name|invert
condition|)
name|invert_br_probabilities
argument_list|(
name|jump
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Invert the jump condition X contained in jump insn INSN.  Accrue the    modifications into the change group.  Return nonzero for success.  */
end_comment

begin_function
specifier|static
name|int
name|invert_exp_1
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
name|insn
parameter_list|)
block|{
name|RTX_CODE
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|IF_THEN_ELSE
condition|)
block|{
name|rtx
name|comp
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|tem
decl_stmt|;
name|enum
name|rtx_code
name|reversed_code
decl_stmt|;
comment|/* We can do this in two ways:  The preferable way, which can only 	 be done if this is not an integer comparison, is to reverse 	 the comparison code.  Otherwise, swap the THEN-part and ELSE-part 	 of the IF_THEN_ELSE.  If we can't do either, fail.  */
name|reversed_code
operator|=
name|reversed_comparison_code
argument_list|(
name|comp
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|reversed_code
operator|!=
name|UNKNOWN
condition|)
block|{
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|gen_rtx_fmt_ee
argument_list|(
name|reversed_code
argument_list|,
name|GET_MODE
argument_list|(
name|comp
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|comp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|comp
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|tem
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
argument_list|,
name|tem
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Invert the condition of the jump JUMP, and make it jump to label    NLABEL instead of where it jumps now.  Accrue changes into the    change group.  Return false if we didn't see how to perform the    inversion and redirection.  */
end_comment

begin_function
name|int
name|invert_jump_1
parameter_list|(
name|rtx
name|jump
parameter_list|,
name|rtx
name|nlabel
parameter_list|)
block|{
name|rtx
name|x
init|=
name|pc_set
argument_list|(
name|jump
argument_list|)
decl_stmt|;
name|int
name|ochanges
decl_stmt|;
name|int
name|ok
decl_stmt|;
name|ochanges
operator|=
name|num_validated_changes
argument_list|()
expr_stmt|;
name|gcc_assert
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|ok
operator|=
name|invert_exp_1
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|jump
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|ok
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_validated_changes
argument_list|()
operator|==
name|ochanges
condition|)
return|return
literal|0
return|;
comment|/* redirect_jump_1 will fail of nlabel == olabel, and the current use is      in Pmode, so checking this is not merely an optimization.  */
return|return
name|nlabel
operator|==
name|JUMP_LABEL
argument_list|(
name|jump
argument_list|)
operator|||
name|redirect_jump_1
argument_list|(
name|jump
argument_list|,
name|nlabel
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Invert the condition of the jump JUMP, and make it jump to label    NLABEL instead of where it jumps now.  Return true if successful.  */
end_comment

begin_function
name|int
name|invert_jump
parameter_list|(
name|rtx
name|jump
parameter_list|,
name|rtx
name|nlabel
parameter_list|,
name|int
name|delete_unused
parameter_list|)
block|{
name|rtx
name|olabel
init|=
name|JUMP_LABEL
argument_list|(
name|jump
argument_list|)
decl_stmt|;
if|if
condition|(
name|invert_jump_1
argument_list|(
name|jump
argument_list|,
name|nlabel
argument_list|)
operator|&&
name|apply_change_group
argument_list|()
condition|)
block|{
name|redirect_jump_2
argument_list|(
name|jump
argument_list|,
name|olabel
argument_list|,
name|nlabel
argument_list|,
name|delete_unused
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|cancel_changes
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Like rtx_equal_p except that it considers two REGs as equal    if they renumber to the same value and considers two commutative    operations to be the same if the order of the operands has been    reversed.  */
end_comment

begin_function
name|int
name|rtx_renumbered_equal_p
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
name|y
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|x
operator|==
name|y
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|(
name|code
operator|==
name|REG
operator|||
operator|(
name|code
operator|==
name|SUBREG
operator|&&
name|REG_P
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|)
operator|)
operator|&&
operator|(
name|REG_P
argument_list|(
name|y
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|SUBREG
operator|&&
name|REG_P
argument_list|(
name|SUBREG_REG
argument_list|(
name|y
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
block|{
name|int
name|reg_x
init|=
operator|-
literal|1
decl_stmt|,
name|reg_y
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|byte_x
init|=
literal|0
decl_stmt|,
name|byte_y
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|y
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* If we haven't done any renumbering, don't 	 make any assumptions.  */
if|if
condition|(
name|reg_renumber
operator|==
literal|0
condition|)
return|return
name|rtx_equal_p
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|SUBREG
condition|)
block|{
name|reg_x
operator|=
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|byte_x
operator|=
name|SUBREG_BYTE
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_renumber
index|[
name|reg_x
index|]
operator|>=
literal|0
condition|)
block|{
name|reg_x
operator|=
name|subreg_regno_offset
argument_list|(
name|reg_renumber
index|[
name|reg_x
index|]
argument_list|,
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|byte_x
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|byte_x
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|reg_x
operator|=
name|REGNO
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_renumber
index|[
name|reg_x
index|]
operator|>=
literal|0
condition|)
name|reg_x
operator|=
name|reg_renumber
index|[
name|reg_x
index|]
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
name|reg_y
operator|=
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|y
argument_list|)
argument_list|)
expr_stmt|;
name|byte_y
operator|=
name|SUBREG_BYTE
argument_list|(
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_renumber
index|[
name|reg_y
index|]
operator|>=
literal|0
condition|)
block|{
name|reg_y
operator|=
name|subreg_regno_offset
argument_list|(
name|reg_renumber
index|[
name|reg_y
index|]
argument_list|,
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|y
argument_list|)
argument_list|)
argument_list|,
name|byte_y
argument_list|,
name|GET_MODE
argument_list|(
name|y
argument_list|)
argument_list|)
expr_stmt|;
name|byte_y
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|reg_y
operator|=
name|REGNO
argument_list|(
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_renumber
index|[
name|reg_y
index|]
operator|>=
literal|0
condition|)
name|reg_y
operator|=
name|reg_renumber
index|[
name|reg_y
index|]
expr_stmt|;
block|}
return|return
name|reg_x
operator|>=
literal|0
operator|&&
name|reg_x
operator|==
name|reg_y
operator|&&
name|byte_x
operator|==
name|byte_y
return|;
block|}
comment|/* Now we have disposed of all the cases      in which different rtx codes can match.  */
if|if
condition|(
name|code
operator|!=
name|GET_CODE
argument_list|(
name|y
argument_list|)
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PC
case|:
case|case
name|CC0
case|:
case|case
name|ADDR_VEC
case|:
case|case
name|ADDR_DIFF_VEC
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
return|return
literal|0
return|;
case|case
name|LABEL_REF
case|:
comment|/* We can't assume nonlocal labels have their following insns yet.  */
if|if
condition|(
name|LABEL_REF_NONLOCAL_P
argument_list|(
name|x
argument_list|)
operator|||
name|LABEL_REF_NONLOCAL_P
argument_list|(
name|y
argument_list|)
condition|)
return|return
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
return|;
comment|/* Two label-refs are equivalent if they point at labels 	 in the same position in the instruction stream.  */
return|return
operator|(
name|next_real_insn
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|next_real_insn
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|SYMBOL_REF
case|:
return|return
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|XSTR
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|CODE_LABEL
case|:
comment|/* If we didn't match EQ equality above, they aren't the same.  */
return|return
literal|0
return|;
default|default:
break|break;
block|}
comment|/* (MULT:SI x y) and (MULT:HI x y) are NOT equivalent.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|y
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* For commutative operations, the RTX match if the operand match in any      order.  Also handle the simple binary and unary cases without a loop.  */
if|if
condition|(
name|targetm
operator|.
name|commutative_p
argument_list|(
name|x
argument_list|,
name|UNKNOWN
argument_list|)
condition|)
return|return
operator|(
operator|(
name|rtx_renumbered_equal_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|rtx_renumbered_equal_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|rtx_renumbered_equal_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|rtx_renumbered_equal_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|)
return|;
elseif|else
if|if
condition|(
name|NON_COMMUTATIVE_P
argument_list|(
name|x
argument_list|)
condition|)
return|return
operator|(
name|rtx_renumbered_equal_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|rtx_renumbered_equal_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
name|UNARY_P
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|rtx_renumbered_equal_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
comment|/* Compare the elements.  If any pair of corresponding elements      fail to match, return 0 for the whole things.  */
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|int
name|j
decl_stmt|;
switch|switch
condition|(
name|fmt
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'w'
case|:
if|if
condition|(
name|XWINT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
name|XWINT
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'i'
case|:
if|if
condition|(
name|XINT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
name|XINT
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'t'
case|:
if|if
condition|(
name|XTREE
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
name|XTREE
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'s'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|XSTR
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|XSTR
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'e'
case|:
if|if
condition|(
operator|!
name|rtx_renumbered_equal_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'u'
case|:
if|if
condition|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
name|XEXP
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Fall through.  */
case|case
literal|'0'
case|:
break|break;
case|case
literal|'E'
case|:
if|if
condition|(
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
name|XVECLEN
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
operator|!
name|rtx_renumbered_equal_p
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|XVECEXP
argument_list|(
name|y
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If X is a hard register or equivalent to one or a subregister of one,    return the hard register number.  If X is a pseudo register that was not    assigned a hard register, return the pseudo register number.  Otherwise,    return -1.  Any rtx is valid for X.  */
end_comment

begin_function
name|int
name|true_regnum
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
if|if
condition|(
name|REG_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
if|if
condition|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|reg_renumber
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
operator|>=
literal|0
condition|)
return|return
name|reg_renumber
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
return|;
return|return
name|REGNO
argument_list|(
name|x
argument_list|)
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
name|int
name|base
init|=
name|true_regnum
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|base
operator|>=
literal|0
operator|&&
name|base
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|subreg_offset_representable_p
argument_list|(
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|SUBREG_BYTE
argument_list|(
name|x
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
return|return
name|base
operator|+
name|subreg_regno_offset
argument_list|(
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|SUBREG_BYTE
argument_list|(
name|x
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return regno of the register REG and handle subregs too.  */
end_comment

begin_function
name|unsigned
name|int
name|reg_or_subregno
parameter_list|(
name|rtx
name|reg
parameter_list|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SUBREG
condition|)
name|reg
operator|=
name|SUBREG_REG
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|REG_P
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|REGNO
argument_list|(
name|reg
argument_list|)
return|;
block|}
end_function

end_unit

