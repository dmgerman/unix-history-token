begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Optimize jump instructions, for GNU compiler.    Copyright (C) 1987, 88, 89, 91-97, 1998 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* This is the jump-optimization pass of the compiler.    It is run two or three times: once before cse, sometimes once after cse,    and once after reload (before final).     jump_optimize deletes unreachable code and labels that are not used.    It also deletes jumps that jump to the following insn,    and simplifies jumps around unconditional jumps and jumps    to unconditional jumps.     Each CODE_LABEL has a count of the times it is used    stored in the LABEL_NUSES internal field, and each JUMP_INSN    has one label that it refers to stored in the    JUMP_LABEL internal field.  With this we can detect labels that    become unused because of the deletion of all the jumps that    formerly used them.  The JUMP_LABEL info is sometimes looked    at by later passes.     Optionally, cross-jumping can be done.  Currently it is done    only the last time (when after reload and before final).    In fact, the code for cross-jumping now assumes that register    allocation has been done, since it uses `rtx_renumbered_equal_p'.     Jump optimization is done after cse when cse's constant-propagation    causes jumps to become unconditional or to be deleted.     Unreachable loops are not detected here, because the labels    have references and the insns appear reachable from the labels.    find_basic_blocks in flow.c finds and deletes such loops.     The subroutines delete_insn, redirect_jump, and invert_jump are used    from other passes as well.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"insn-flags.h"
end_include

begin_include
include|#
directive|include
file|"insn-attr.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_comment
comment|/* ??? Eventually must record somehow the labels used by jumps    from nested functions.  */
end_comment

begin_comment
comment|/* Pre-record the next or previous real insn for each label?    No, this pass is very fast anyway.  */
end_comment

begin_comment
comment|/* Condense consecutive labels?    This would make life analysis faster, maybe.  */
end_comment

begin_comment
comment|/* Optimize jump y; x: ... y: jumpif... x?    Don't know if it is worth bothering with.  */
end_comment

begin_comment
comment|/* Optimize two cases of conditional jump to conditional jump?    This can never delete any instruction or make anything dead,    or even change what is live at any point.    So perhaps let combiner do it.  */
end_comment

begin_comment
comment|/* Vector indexed by uid.    For each CODE_LABEL, index by its uid to get first unconditional jump    that jumps to the label.    For each JUMP_INSN, index by its uid to get the next unconditional jump    that jumps to the same label.    Element 0 is the start of a chain of all return insns.    (It is safe to use element 0 because insn uid 0 is not used.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
modifier|*
name|jump_chain
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List of labels referred to from initializers.    These can never be deleted.  */
end_comment

begin_decl_stmt
name|rtx
name|forced_labels
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Maximum index in jump_chain.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|max_jump_chain
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set nonzero by jump_optimize if control can fall through    to the end of the function.  */
end_comment

begin_decl_stmt
name|int
name|can_reach_end
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indicates whether death notes are significant in cross jump analysis.    Normally they are not significant, because of A and B jump to C,    and R dies in A, it must die in B.  But this might not be true after    stack register conversion, and we must compare death notes in that    case.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cross_jump_death_matters
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|duplicate_loop_exit_test
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|find_cross_jump
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|int
operator|,
name|rtx
operator|*
operator|,
name|rtx
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_cross_jump
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|jump_back_p
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|tension_vector_labels
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mark_jump_label
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|delete_computation
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|delete_from_jump_chain
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|delete_labelref_insn
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mark_modified_reg
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|redirect_tablejump
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_cc0
end_ifndef

begin_decl_stmt
specifier|static
name|rtx
name|find_insert_position
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Delete no-op jumps and optimize jumps to jumps    and jumps around jumps.    Delete unused labels and unreachable code.     If CROSS_JUMP is 1, detect matching code    before a jump and its destination and unify them.    If CROSS_JUMP is 2, do cross-jumping, but pay attention to death notes.     If NOOP_MOVES is nonzero, delete no-op move insns.     If AFTER_REGSCAN is nonzero, then this jump pass is being run immediately    after regscan, and it is safe to use regno_first_uid and regno_last_uid.     If `optimize' is zero, don't change any code,    just determine whether control drops off the end of the function.    This case occurs when we have -W and not -O.    It works because `delete_insn' checks the value of `optimize'    and refrains from actually deleting when that is 0.  */
end_comment

begin_function
name|void
name|jump_optimize
parameter_list|(
name|f
parameter_list|,
name|cross_jump
parameter_list|,
name|noop_moves
parameter_list|,
name|after_regscan
parameter_list|)
name|rtx
name|f
decl_stmt|;
name|int
name|cross_jump
decl_stmt|;
name|int
name|noop_moves
decl_stmt|;
name|int
name|after_regscan
decl_stmt|;
block|{
specifier|register
name|rtx
name|insn
decl_stmt|,
name|next
decl_stmt|,
name|note
decl_stmt|;
name|int
name|changed
decl_stmt|;
name|int
name|old_max_reg
decl_stmt|;
name|int
name|first
init|=
literal|1
decl_stmt|;
name|int
name|max_uid
init|=
literal|0
decl_stmt|;
name|rtx
name|last_insn
decl_stmt|;
name|cross_jump_death_matters
operator|=
operator|(
name|cross_jump
operator|==
literal|2
operator|)
expr_stmt|;
comment|/* Initialize LABEL_NUSES and JUMP_LABEL fields.  Delete any REG_LABEL      notes whose labels don't occur in the insn any more.  */
for|for
control|(
name|insn
operator|=
name|f
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
condition|)
name|LABEL_NUSES
argument_list|(
name|insn
argument_list|)
operator|=
operator|(
name|LABEL_PRESERVE_P
argument_list|(
name|insn
argument_list|)
operator|!=
literal|0
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
for|for
control|(
name|note
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|note
condition|;
name|note
operator|=
name|next
control|)
block|{
name|next
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
operator|==
name|REG_LABEL
operator|&&
operator|!
name|reg_mentioned_p
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
name|remove_note
argument_list|(
name|insn
argument_list|,
name|note
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|INSN_UID
argument_list|(
name|insn
argument_list|)
operator|>
name|max_uid
condition|)
name|max_uid
operator|=
name|INSN_UID
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
name|max_uid
operator|++
expr_stmt|;
comment|/* If we are performing cross jump optimizations, then initialize      tables mapping UIDs to EH regions to avoid incorrect movement      of insns from one EH region to another.  */
if|if
condition|(
name|flag_exceptions
operator|&&
name|cross_jump
condition|)
name|init_insn_eh_region
argument_list|(
name|f
argument_list|,
name|max_uid
argument_list|)
expr_stmt|;
comment|/* Delete insns following barriers, up to next label.  */
for|for
control|(
name|insn
operator|=
name|f
init|;
name|insn
condition|;
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|BARRIER
condition|)
block|{
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
while|while
condition|(
name|insn
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|CODE_LABEL
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE_INSN_FUNCTION_END
condition|)
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
else|else
name|insn
operator|=
name|delete_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
comment|/* INSN is now the code_label.  */
block|}
else|else
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
comment|/* Leave some extra room for labels and duplicate exit test insns      we make.  */
name|max_jump_chain
operator|=
name|max_uid
operator|*
literal|14
operator|/
literal|10
expr_stmt|;
name|jump_chain
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|max_jump_chain
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|jump_chain
argument_list|,
name|max_jump_chain
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Mark the label each jump jumps to.      Combine consecutive labels, and count uses of labels.       For each label, make a chain (using `jump_chain')      of all the *unconditional* jumps that jump to it;      also make a chain of all returns.  */
for|for
control|(
name|insn
operator|=
name|f
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
literal|'i'
condition|)
block|{
name|mark_jump_label
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|insn
argument_list|,
name|cross_jump
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|INSN_DELETED_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
block|{
if|if
condition|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
operator|!=
literal|0
operator|&&
name|simplejump_p
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|jump_chain
index|[
name|INSN_UID
argument_list|(
name|insn
argument_list|)
index|]
operator|=
name|jump_chain
index|[
name|INSN_UID
argument_list|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
argument_list|)
index|]
expr_stmt|;
name|jump_chain
index|[
name|INSN_UID
argument_list|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
argument_list|)
index|]
operator|=
name|insn
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|RETURN
condition|)
block|{
name|jump_chain
index|[
name|INSN_UID
argument_list|(
name|insn
argument_list|)
index|]
operator|=
name|jump_chain
index|[
literal|0
index|]
expr_stmt|;
name|jump_chain
index|[
literal|0
index|]
operator|=
name|insn
expr_stmt|;
block|}
block|}
block|}
comment|/* Keep track of labels used from static data;      they cannot ever be deleted.  */
for|for
control|(
name|insn
operator|=
name|forced_labels
init|;
name|insn
condition|;
name|insn
operator|=
name|XEXP
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|)
control|)
name|LABEL_NUSES
argument_list|(
name|XEXP
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|++
expr_stmt|;
name|check_exception_handler_labels
argument_list|()
expr_stmt|;
comment|/* Keep track of labels used for marking handlers for exception      regions; they cannot usually be deleted.  */
for|for
control|(
name|insn
operator|=
name|exception_handler_labels
init|;
name|insn
condition|;
name|insn
operator|=
name|XEXP
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|)
control|)
name|LABEL_NUSES
argument_list|(
name|XEXP
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|++
expr_stmt|;
name|exception_optimize
argument_list|()
expr_stmt|;
comment|/* Delete all labels already not referenced.      Also find the last insn.  */
name|last_insn
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|f
init|;
name|insn
condition|;
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
operator|&&
name|LABEL_NUSES
argument_list|(
name|insn
argument_list|)
operator|==
literal|0
condition|)
name|insn
operator|=
name|delete_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
else|else
block|{
name|last_insn
operator|=
name|insn
expr_stmt|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|optimize
condition|)
block|{
comment|/* See if there is still a NOTE_INSN_FUNCTION_END in this function. 	 If so record that this function can drop off the end.  */
name|insn
operator|=
name|last_insn
expr_stmt|;
block|{
name|int
name|n_labels
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|insn
comment|/* One label can follow the end-note: the return label.  */
operator|&&
operator|(
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
operator|&&
name|n_labels
operator|--
operator|>
literal|0
operator|)
comment|/* Ordinary insns can follow it if returning a structure.  */
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
comment|/* If machine uses explicit RETURN insns, no epilogue, 		      then one of them follows the note.  */
operator|||
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|RETURN
operator|)
comment|/* A barrier can follow the return insn.  */
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|BARRIER
comment|/* Other kinds of notes can follow also.  */
operator|||
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE_INSN_FUNCTION_END
operator|)
operator|)
condition|)
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
comment|/* Report if control can fall through at the end of the function.  */
if|if
condition|(
name|insn
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_FUNCTION_END
operator|&&
operator|!
name|INSN_DELETED_P
argument_list|(
name|insn
argument_list|)
condition|)
name|can_reach_end
operator|=
literal|1
expr_stmt|;
comment|/* Zero the "deleted" flag of all the "deleted" insns.  */
for|for
control|(
name|insn
operator|=
name|f
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
name|INSN_DELETED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Show that the jump chain is not valid.  */
name|jump_chain
operator|=
literal|0
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|HAVE_return
if|if
condition|(
name|HAVE_return
condition|)
block|{
comment|/* If we fall through to the epilogue, see if we can insert a RETURN insn 	 in front of it.  If the machine allows it at this point (we might be 	 after reload for a leaf routine), it will improve optimization for it 	 to be there.  */
name|insn
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
while|while
condition|(
name|insn
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|BARRIER
condition|)
block|{
name|emit_jump_insn
argument_list|(
name|gen_return
argument_list|()
argument_list|)
expr_stmt|;
name|emit_barrier
argument_list|()
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|noop_moves
condition|)
for|for
control|(
name|insn
operator|=
name|f
init|;
name|insn
condition|;
control|)
block|{
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
condition|)
block|{
specifier|register
name|rtx
name|body
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
comment|/* Combine stack_adjusts with following push_insns.  */
ifdef|#
directive|ifdef
name|PUSH_ROUNDING
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|SET
operator|&&
name|SET_DEST
argument_list|(
name|body
argument_list|)
operator|==
name|stack_pointer_rtx
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|stack_pointer_rtx
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|>
literal|0
condition|)
block|{
name|rtx
name|p
decl_stmt|;
name|rtx
name|stack_adjust_insn
init|=
name|insn
decl_stmt|;
name|int
name|stack_adjust_amount
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|total_pushed
init|=
literal|0
decl_stmt|;
name|int
name|pushes
init|=
literal|0
decl_stmt|;
comment|/* Find all successive push insns.  */
name|p
operator|=
name|insn
expr_stmt|;
comment|/* Don't convert more than three pushes; 		   that starts adding too many displaced addresses 		   and the whole thing starts becoming a losing 		   proposition.  */
while|while
condition|(
name|pushes
operator|<
literal|3
condition|)
block|{
name|rtx
name|pbody
decl_stmt|,
name|dest
decl_stmt|;
name|p
operator|=
name|next_nonnote_insn
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|!=
name|INSN
condition|)
break|break;
name|pbody
operator|=
name|PATTERN
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pbody
argument_list|)
operator|!=
name|SET
condition|)
break|break;
name|dest
operator|=
name|SET_DEST
argument_list|(
name|pbody
argument_list|)
expr_stmt|;
comment|/* Allow a no-op move between the adjust and the push.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|pbody
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|dest
argument_list|)
operator|==
name|REGNO
argument_list|(
name|SET_SRC
argument_list|(
name|pbody
argument_list|)
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
operator|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|POST_INC
operator|&&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|stack_pointer_rtx
operator|)
condition|)
break|break;
name|pushes
operator|++
expr_stmt|;
if|if
condition|(
name|total_pushed
operator|+
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|pbody
argument_list|)
argument_list|)
argument_list|)
operator|>
name|stack_adjust_amount
condition|)
break|break;
name|total_pushed
operator|+=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|pbody
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Discard the amount pushed from the stack adjust; 		   maybe eliminate it entirely.  */
if|if
condition|(
name|total_pushed
operator|>=
name|stack_adjust_amount
condition|)
block|{
name|delete_computation
argument_list|(
name|stack_adjust_insn
argument_list|)
expr_stmt|;
name|total_pushed
operator|=
name|stack_adjust_amount
expr_stmt|;
block|}
else|else
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|stack_adjust_insn
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|=
name|GEN_INT
argument_list|(
name|stack_adjust_amount
operator|-
name|total_pushed
argument_list|)
expr_stmt|;
comment|/* Change the appropriate push insns to ordinary stores.  */
name|p
operator|=
name|insn
expr_stmt|;
while|while
condition|(
name|total_pushed
operator|>
literal|0
condition|)
block|{
name|rtx
name|pbody
decl_stmt|,
name|dest
decl_stmt|;
name|p
operator|=
name|next_nonnote_insn
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|!=
name|INSN
condition|)
break|break;
name|pbody
operator|=
name|PATTERN
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pbody
argument_list|)
operator|!=
name|SET
condition|)
break|break;
name|dest
operator|=
name|SET_DEST
argument_list|(
name|pbody
argument_list|)
expr_stmt|;
comment|/* Allow a no-op move between the adjust and the push.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|pbody
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|dest
argument_list|)
operator|==
name|REGNO
argument_list|(
name|SET_SRC
argument_list|(
name|pbody
argument_list|)
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
operator|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|POST_INC
operator|&&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|stack_pointer_rtx
operator|)
condition|)
break|break;
name|total_pushed
operator|-=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|pbody
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If this push doesn't fully fit in the space 		       of the stack adjust that we deleted, 		       make another stack adjust here for what we 		       didn't use up.  There should be peepholes 		       to recognize the resulting sequence of insns.  */
if|if
condition|(
name|total_pushed
operator|<
literal|0
condition|)
block|{
name|emit_insn_before
argument_list|(
name|gen_add2_insn
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|GEN_INT
argument_list|(
operator|-
name|total_pushed
argument_list|)
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
break|break;
block|}
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
operator|=
name|plus_constant
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|total_pushed
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* Detect and delete no-op move instructions 	       resulting from not allocating a parameter in a register.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|SET
operator|&&
operator|(
name|SET_DEST
argument_list|(
name|body
argument_list|)
operator|==
name|SET_SRC
argument_list|(
name|body
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|body
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
name|rtx_equal_p
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|,
name|SET_DEST
argument_list|(
name|body
argument_list|)
argument_list|)
operator|)
operator|)
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|body
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
name|MEM_VOLATILE_P
argument_list|(
name|SET_DEST
argument_list|(
name|body
argument_list|)
argument_list|)
operator|)
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
name|MEM_VOLATILE_P
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|)
operator|)
condition|)
name|delete_computation
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Detect and ignore no-op move instructions 	       resulting from smart or fortuitous register allocation.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|SET
condition|)
block|{
name|int
name|sreg
init|=
name|true_regnum
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|dreg
init|=
name|true_regnum
argument_list|(
name|SET_DEST
argument_list|(
name|body
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|sreg
operator|==
name|dreg
operator|&&
name|sreg
operator|>=
literal|0
condition|)
name|delete_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sreg
operator|>=
literal|0
operator|&&
name|dreg
operator|>=
literal|0
condition|)
block|{
name|rtx
name|trial
decl_stmt|;
name|rtx
name|tem
init|=
name|find_equiv_reg
argument_list|(
name|NULL_RTX
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|,
name|sreg
argument_list|,
name|NULL_PTR
argument_list|,
name|dreg
argument_list|,
name|GET_MODE
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|tem
operator|!=
literal|0
operator|&&
name|GET_MODE
argument_list|(
name|tem
argument_list|)
operator|==
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|body
argument_list|)
argument_list|)
condition|)
block|{
comment|/* DREG may have been the target of a REG_DEAD note in 			   the insn which makes INSN redundant.  If so, reorg 			   would still think it is dead.  So search for such a 			   note and delete it if we find it.  */
if|if
condition|(
operator|!
name|find_regno_note
argument_list|(
name|insn
argument_list|,
name|REG_UNUSED
argument_list|,
name|dreg
argument_list|)
condition|)
for|for
control|(
name|trial
operator|=
name|prev_nonnote_insn
argument_list|(
name|insn
argument_list|)
init|;
name|trial
operator|&&
name|GET_CODE
argument_list|(
name|trial
argument_list|)
operator|!=
name|CODE_LABEL
condition|;
name|trial
operator|=
name|prev_nonnote_insn
argument_list|(
name|trial
argument_list|)
control|)
if|if
condition|(
name|find_regno_note
argument_list|(
name|trial
argument_list|,
name|REG_DEAD
argument_list|,
name|dreg
argument_list|)
condition|)
block|{
name|remove_death
argument_list|(
name|dreg
argument_list|,
name|trial
argument_list|)
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|PRESERVE_DEATH_INFO_REGNO_P
comment|/* Deleting insn could lose a death-note for SREG 			   so don't do it if final needs accurate 			   death-notes.  */
if|if
condition|(
name|PRESERVE_DEATH_INFO_REGNO_P
argument_list|(
name|sreg
argument_list|)
operator|&&
operator|(
name|trial
operator|=
name|find_regno_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|sreg
argument_list|)
operator|)
condition|)
block|{
comment|/* Change this into a USE so that we won't emit 			       code for it, but still can keep the note.  */
name|PATTERN
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|XEXP
argument_list|(
name|trial
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Remove all reg notes but the REG_DEAD one.  */
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|trial
expr_stmt|;
name|XEXP
argument_list|(
name|trial
argument_list|,
literal|1
argument_list|)
operator|=
name|NULL_RTX
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|delete_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|dreg
operator|>=
literal|0
operator|&&
name|CONSTANT_P
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|)
operator|&&
name|find_equiv_reg
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|,
name|dreg
argument_list|,
name|NULL_PTR
argument_list|,
literal|0
argument_list|,
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|body
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
comment|/* This handles the case where we have two consecutive 		       assignments of the same constant to pseudos that didn't 		       get a hard reg.  Each SET from the constant will be 		       converted into a SET of the spill register and an 		       output reload will be made following it.  This produces 		       two loads of the same constant into the same spill 		       register.  */
name|rtx
name|in_insn
init|=
name|insn
decl_stmt|;
comment|/* Look back for a death note for the first reg. 		       If there is one, it is no longer accurate.  */
while|while
condition|(
name|in_insn
operator|&&
name|GET_CODE
argument_list|(
name|in_insn
argument_list|)
operator|!=
name|CODE_LABEL
condition|)
block|{
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|in_insn
argument_list|)
operator|==
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|in_insn
argument_list|)
operator|==
name|JUMP_INSN
operator|)
operator|&&
name|find_regno_note
argument_list|(
name|in_insn
argument_list|,
name|REG_DEAD
argument_list|,
name|dreg
argument_list|)
condition|)
block|{
name|remove_death
argument_list|(
name|dreg
argument_list|,
name|in_insn
argument_list|)
expr_stmt|;
break|break;
block|}
name|in_insn
operator|=
name|PREV_INSN
argument_list|(
name|in_insn
argument_list|)
expr_stmt|;
block|}
comment|/* Delete the second load of the value.  */
name|delete_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
comment|/* If each part is a set between two identical registers or 		   a USE or CLOBBER, delete the insn.  */
name|int
name|i
decl_stmt|,
name|sreg
decl_stmt|,
name|dreg
decl_stmt|;
name|rtx
name|tem
decl_stmt|;
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|tem
operator|=
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|USE
operator|||
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|CLOBBER
condition|)
continue|continue;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|!=
name|SET
operator|||
operator|(
name|sreg
operator|=
name|true_regnum
argument_list|(
name|SET_SRC
argument_list|(
name|tem
argument_list|)
argument_list|)
operator|)
operator|<
literal|0
operator|||
operator|(
name|dreg
operator|=
name|true_regnum
argument_list|(
name|SET_DEST
argument_list|(
name|tem
argument_list|)
argument_list|)
operator|)
operator|<
literal|0
operator|||
name|dreg
operator|!=
name|sreg
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|delete_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
comment|/* Also delete insns to store bit fields if they are no-ops.  */
comment|/* Not worth the hair to detect this in the big-endian case.  */
elseif|else
if|if
condition|(
operator|!
name|BYTES_BIG_ENDIAN
operator|&&
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|body
argument_list|)
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|&&
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|body
argument_list|)
argument_list|,
literal|2
argument_list|)
operator|==
name|const0_rtx
operator|&&
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|body
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|SET_SRC
argument_list|(
name|body
argument_list|)
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
name|MEM_VOLATILE_P
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|)
operator|)
condition|)
name|delete_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
name|insn
operator|=
name|next
expr_stmt|;
block|}
comment|/* If we haven't yet gotten to reload and we have just run regscan,      delete any insn that sets a register that isn't used elsewhere.      This helps some of the optimizations below by having less insns      being jumped around.  */
if|if
condition|(
operator|!
name|reload_completed
operator|&&
name|after_regscan
condition|)
for|for
control|(
name|insn
operator|=
name|f
init|;
name|insn
condition|;
name|insn
operator|=
name|next
control|)
block|{
name|rtx
name|set
init|=
name|single_set
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|set
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|REGNO_FIRST_UID
argument_list|(
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
argument_list|)
operator|==
name|INSN_UID
argument_list|(
name|insn
argument_list|)
comment|/* We use regno_last_note_uid so as not to delete the setting 	       of a reg that's used in notes.  A subsequent optimization 	       might arrange to use that reg for real.  */
operator|&&
name|REGNO_LAST_NOTE_UID
argument_list|(
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
argument_list|)
operator|==
name|INSN_UID
argument_list|(
name|insn
argument_list|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|&&
operator|!
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_RETVAL
argument_list|,
literal|0
argument_list|)
condition|)
name|delete_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
comment|/* Now iterate optimizing jumps until nothing changes over one pass.  */
name|changed
operator|=
literal|1
expr_stmt|;
name|old_max_reg
operator|=
name|max_reg_num
argument_list|()
expr_stmt|;
while|while
condition|(
name|changed
condition|)
block|{
name|changed
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|f
init|;
name|insn
condition|;
name|insn
operator|=
name|next
control|)
block|{
name|rtx
name|reallabelprev
decl_stmt|;
name|rtx
name|temp
decl_stmt|,
name|temp1
decl_stmt|,
name|temp2
decl_stmt|,
name|temp3
decl_stmt|,
name|temp4
decl_stmt|,
name|temp5
decl_stmt|,
name|temp6
decl_stmt|;
name|rtx
name|nlabel
decl_stmt|;
name|int
name|this_is_simplejump
decl_stmt|,
name|this_is_condjump
decl_stmt|,
name|reversep
init|=
literal|0
decl_stmt|;
name|int
name|this_is_condjump_in_parallel
decl_stmt|;
if|#
directive|if
literal|0
comment|/* If NOT the first iteration, if this is the last jump pass 	     (just before final), do the special peephole optimizations. 	     Avoiding the first iteration gives ordinary jump opts 	     a chance to work before peephole opts.  */
block|if (reload_completed&& !first&& !flag_no_peephole) 	    if (GET_CODE (insn) == INSN || GET_CODE (insn) == JUMP_INSN) 	      peephole (insn);
endif|#
directive|endif
comment|/* That could have deleted some insns after INSN, so check now 	     what the following insn is.  */
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* See if this is a NOTE_INSN_LOOP_BEG followed by an unconditional 	     jump.  Try to optimize by duplicating the loop exit test if so. 	     This is only safe immediately after regscan, because it uses 	     the values of regno_first_uid and regno_last_uid.  */
if|if
condition|(
name|after_regscan
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_LOOP_BEG
operator|&&
operator|(
name|temp1
operator|=
name|next_nonnote_insn
argument_list|(
name|insn
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|simplejump_p
argument_list|(
name|temp1
argument_list|)
condition|)
block|{
name|temp
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|duplicate_loop_exit_test
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|changed
operator|=
literal|1
expr_stmt|;
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|temp
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|JUMP_INSN
condition|)
continue|continue;
name|this_is_simplejump
operator|=
name|simplejump_p
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|this_is_condjump
operator|=
name|condjump_p
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|this_is_condjump_in_parallel
operator|=
name|condjump_in_parallel_p
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Tension the labels in dispatch tables.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|ADDR_VEC
condition|)
name|changed
operator||=
name|tension_vector_labels
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|ADDR_DIFF_VEC
condition|)
name|changed
operator||=
name|tension_vector_labels
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* If a dispatch table always goes to the same place, 	     get rid of it and replace the insn that uses it.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|ADDR_VEC
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|ADDR_DIFF_VEC
condition|)
block|{
name|int
name|i
decl_stmt|;
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|int
name|diff_vec_p
init|=
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|ADDR_DIFF_VEC
decl_stmt|;
name|int
name|len
init|=
name|XVECLEN
argument_list|(
name|pat
argument_list|,
name|diff_vec_p
argument_list|)
decl_stmt|;
name|rtx
name|dispatch
init|=
name|prev_real_insn
argument_list|(
name|insn
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
name|diff_vec_p
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|!=
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
name|diff_vec_p
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|len
operator|&&
name|dispatch
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|dispatch
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|JUMP_LABEL
argument_list|(
name|dispatch
argument_list|)
operator|!=
literal|0
comment|/* Don't mess with a casesi insn.  */
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|dispatch
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|dispatch
argument_list|)
argument_list|)
argument_list|)
operator|==
name|IF_THEN_ELSE
operator|)
operator|)
operator|&&
name|next_real_insn
argument_list|(
name|JUMP_LABEL
argument_list|(
name|dispatch
argument_list|)
argument_list|)
operator|==
name|insn
condition|)
block|{
name|redirect_tablejump
argument_list|(
name|dispatch
argument_list|,
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
name|diff_vec_p
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|reallabelprev
operator|=
name|prev_active_insn
argument_list|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If a jump references the end of the function, try to turn 	     it into a RETURN insn, possibly a conditional one.  */
if|if
condition|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
operator|&&
operator|(
name|next_active_insn
argument_list|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|next_active_insn
argument_list|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|==
name|RETURN
operator|)
condition|)
name|changed
operator||=
name|redirect_jump
argument_list|(
name|insn
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
comment|/* Detect jump to following insn.  */
if|if
condition|(
name|reallabelprev
operator|==
name|insn
operator|&&
name|condjump_p
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|next
operator|=
name|next_real_insn
argument_list|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|delete_jump
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
comment|/* If we have an unconditional jump preceded by a USE, try to put 	     the USE before the target and jump there.  This simplifies many 	     of the optimizations below since we don't have to worry about 	     dealing with these USE insns.  We only do this if the label 	     being branch to already has the identical USE or if code 	     never falls through to that label.  */
if|if
condition|(
name|this_is_simplejump
operator|&&
operator|(
name|temp
operator|=
name|prev_nonnote_insn
argument_list|(
name|insn
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|temp
argument_list|)
argument_list|)
operator|==
name|USE
operator|&&
operator|(
name|temp1
operator|=
name|prev_nonnote_insn
argument_list|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|temp1
argument_list|)
operator|==
name|BARRIER
operator|||
operator|(
name|GET_CODE
argument_list|(
name|temp1
argument_list|)
operator|==
name|INSN
operator|&&
name|rtx_equal_p
argument_list|(
name|PATTERN
argument_list|(
name|temp
argument_list|)
argument_list|,
name|PATTERN
argument_list|(
name|temp1
argument_list|)
argument_list|)
operator|)
operator|)
comment|/* Don't do this optimization if we have a loop containing only 		 the USE instruction, and the loop start label has a usage 		 count of 1.  This is because we will redo this optimization 		 everytime through the outer loop, and jump opt will never 		 exit.  */
operator|&&
operator|!
operator|(
operator|(
name|temp2
operator|=
name|prev_nonnote_insn
argument_list|(
name|temp
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|temp2
operator|==
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
operator|&&
name|LABEL_NUSES
argument_list|(
name|temp2
argument_list|)
operator|==
literal|1
operator|)
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|temp1
argument_list|)
operator|==
name|BARRIER
condition|)
block|{
name|emit_insn_after
argument_list|(
name|PATTERN
argument_list|(
name|temp
argument_list|)
argument_list|,
name|temp1
argument_list|)
expr_stmt|;
name|temp1
operator|=
name|NEXT_INSN
argument_list|(
name|temp1
argument_list|)
expr_stmt|;
block|}
name|delete_insn
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|redirect_jump
argument_list|(
name|insn
argument_list|,
name|get_label_before
argument_list|(
name|temp1
argument_list|)
argument_list|)
expr_stmt|;
name|reallabelprev
operator|=
name|prev_real_insn
argument_list|(
name|temp1
argument_list|)
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Simplify   if (...) x = a; else x = b; by converting it 	     to         x = b; if (...) x = a; 	     if B is sufficiently simple, the test doesn't involve X, 	     and nothing in the test modifies B or X.  	     If we have small register classes, we also can't do this if X 	     is a hard register.  	     If the "x = b;" insn has any REG_NOTES, we don't do this because 	     of the possibility that we are running after CSE and there is a 	     REG_EQUAL note that is only valid if the branch has already been 	     taken.  If we move the insn with the REG_EQUAL note, we may 	     fold the comparison to always be false in a later CSE pass. 	     (We could also delete the REG_NOTES when moving the insn, but it 	     seems simpler to not move it.)  An exception is that we can move 	     the insn if the only note is a REG_EQUAL or REG_EQUIV whose 	     value is the same as "b".  	     INSN is the branch over the `else' part.   	     We set:  	     TEMP to the jump insn preceding "x = a;" 	     TEMP1 to X 	     TEMP2 to the insn that sets "x = b;" 	     TEMP3 to the insn that sets "x = a;" 	     TEMP4 to the set of "x = b";  */
if|if
condition|(
name|this_is_simplejump
operator|&&
operator|(
name|temp3
operator|=
name|prev_active_insn
argument_list|(
name|insn
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|temp3
argument_list|)
operator|==
name|INSN
operator|&&
operator|(
name|temp4
operator|=
name|single_set
argument_list|(
name|temp3
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|temp1
operator|=
name|SET_DEST
argument_list|(
name|temp4
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
operator|(
operator|!
name|SMALL_REGISTER_CLASSES
operator|||
name|REGNO
argument_list|(
name|temp1
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
operator|&&
operator|(
name|temp2
operator|=
name|next_active_insn
argument_list|(
name|insn
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|temp2
argument_list|)
operator|==
name|INSN
operator|&&
operator|(
name|temp4
operator|=
name|single_set
argument_list|(
name|temp2
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|rtx_equal_p
argument_list|(
name|SET_DEST
argument_list|(
name|temp4
argument_list|)
argument_list|,
name|temp1
argument_list|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|SET_SRC
argument_list|(
name|temp4
argument_list|)
argument_list|)
operator|&&
operator|!
name|may_trap_p
argument_list|(
name|SET_SRC
argument_list|(
name|temp4
argument_list|)
argument_list|)
operator|&&
operator|(
name|REG_NOTES
argument_list|(
name|temp2
argument_list|)
operator|==
literal|0
operator|||
operator|(
operator|(
name|REG_NOTE_KIND
argument_list|(
name|REG_NOTES
argument_list|(
name|temp2
argument_list|)
argument_list|)
operator|==
name|REG_EQUAL
operator|||
name|REG_NOTE_KIND
argument_list|(
name|REG_NOTES
argument_list|(
name|temp2
argument_list|)
argument_list|)
operator|==
name|REG_EQUIV
operator|)
operator|&&
name|XEXP
argument_list|(
name|REG_NOTES
argument_list|(
name|temp2
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|REG_NOTES
argument_list|(
name|temp2
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|SET_SRC
argument_list|(
name|temp4
argument_list|)
argument_list|)
operator|)
operator|)
operator|&&
operator|(
name|temp
operator|=
name|prev_active_insn
argument_list|(
name|temp3
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|condjump_p
argument_list|(
name|temp
argument_list|)
operator|&&
operator|!
name|simplejump_p
argument_list|(
name|temp
argument_list|)
comment|/* TEMP must skip over the "x = a;" insn */
operator|&&
name|prev_real_insn
argument_list|(
name|JUMP_LABEL
argument_list|(
name|temp
argument_list|)
argument_list|)
operator|==
name|insn
operator|&&
name|no_labels_between_p
argument_list|(
name|insn
argument_list|,
name|JUMP_LABEL
argument_list|(
name|temp
argument_list|)
argument_list|)
comment|/* There must be no other entries to the "x = b;" insn.  */
operator|&&
name|no_labels_between_p
argument_list|(
name|JUMP_LABEL
argument_list|(
name|temp
argument_list|)
argument_list|,
name|temp2
argument_list|)
comment|/* INSN must either branch to the insn after TEMP2 or the insn 		 after TEMP2 must branch to the same place as INSN.  */
operator|&&
operator|(
name|reallabelprev
operator|==
name|temp2
operator|||
operator|(
operator|(
name|temp5
operator|=
name|next_active_insn
argument_list|(
name|temp2
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|simplejump_p
argument_list|(
name|temp5
argument_list|)
operator|&&
name|JUMP_LABEL
argument_list|(
name|temp5
argument_list|)
operator|==
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
operator|)
operator|)
condition|)
block|{
comment|/* The test expression, X, may be a complicated test with 		 multiple branches.  See if we can find all the uses of 		 the label that TEMP branches to without hitting a CALL_INSN 		 or a jump to somewhere else.  */
name|rtx
name|target
init|=
name|JUMP_LABEL
argument_list|(
name|temp
argument_list|)
decl_stmt|;
name|int
name|nuses
init|=
name|LABEL_NUSES
argument_list|(
name|target
argument_list|)
decl_stmt|;
name|rtx
name|p
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_cc0
name|rtx
name|q
decl_stmt|;
endif|#
directive|endif
comment|/* Set P to the first jump insn that goes around "x = a;".  */
for|for
control|(
name|p
operator|=
name|temp
init|;
name|nuses
operator|&&
name|p
condition|;
name|p
operator|=
name|prev_nonnote_insn
argument_list|(
name|p
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|JUMP_INSN
condition|)
block|{
if|if
condition|(
name|condjump_p
argument_list|(
name|p
argument_list|)
operator|&&
operator|!
name|simplejump_p
argument_list|(
name|p
argument_list|)
operator|&&
name|JUMP_LABEL
argument_list|(
name|p
argument_list|)
operator|==
name|target
condition|)
block|{
name|nuses
operator|--
expr_stmt|;
if|if
condition|(
name|nuses
operator|==
literal|0
condition|)
break|break;
block|}
else|else
break|break;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|CALL_INSN
condition|)
break|break;
block|}
ifdef|#
directive|ifdef
name|HAVE_cc0
comment|/* We cannot insert anything between a set of cc and its use 		 so if P uses cc0, we must back up to the previous insn.  */
name|q
operator|=
name|prev_nonnote_insn
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|&&
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|q
argument_list|)
argument_list|)
operator|==
literal|'i'
operator|&&
name|sets_cc0_p
argument_list|(
name|PATTERN
argument_list|(
name|q
argument_list|)
argument_list|)
condition|)
name|p
operator|=
name|q
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|p
condition|)
name|p
operator|=
name|PREV_INSN
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* If we found all the uses and there was no data conflict, we 		 can move the assignment unless we can branch into the middle 		 from somewhere.  */
if|if
condition|(
name|nuses
operator|==
literal|0
operator|&&
name|p
operator|&&
name|no_labels_between_p
argument_list|(
name|p
argument_list|,
name|insn
argument_list|)
operator|&&
operator|!
name|reg_referenced_between_p
argument_list|(
name|temp1
argument_list|,
name|p
argument_list|,
name|NEXT_INSN
argument_list|(
name|temp3
argument_list|)
argument_list|)
operator|&&
operator|!
name|reg_set_between_p
argument_list|(
name|temp1
argument_list|,
name|p
argument_list|,
name|temp3
argument_list|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|temp4
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|||
operator|!
name|modified_between_p
argument_list|(
name|SET_SRC
argument_list|(
name|temp4
argument_list|)
argument_list|,
name|p
argument_list|,
name|temp2
argument_list|)
operator|)
condition|)
block|{
name|emit_insn_after_with_line_notes
argument_list|(
name|PATTERN
argument_list|(
name|temp2
argument_list|)
argument_list|,
name|p
argument_list|,
name|temp2
argument_list|)
expr_stmt|;
name|delete_insn
argument_list|(
name|temp2
argument_list|)
expr_stmt|;
comment|/* Set NEXT to an insn that we know won't go away.  */
name|next
operator|=
name|next_active_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Delete the jump around the set.  Note that we must do 		     this before we redirect the test jumps so that it won't 		     delete the code immediately following the assignment 		     we moved (which might be a jump).  */
name|delete_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* We either have two consecutive labels or a jump to 		     a jump, so adjust all the JUMP_INSNs to branch to where 		     INSN branches to.  */
for|for
control|(
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
init|;
name|p
operator|!=
name|next
condition|;
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|JUMP_INSN
condition|)
name|redirect_jump
argument_list|(
name|p
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* Simplify   if (...) { x = a; goto l; } x = b; by converting it 	     to         x = a; if (...) goto l; x = b; 	     if A is sufficiently simple, the test doesn't involve X, 	     and nothing in the test modifies A or X.  	     If we have small register classes, we also can't do this if X 	     is a hard register.  	     If the "x = a;" insn has any REG_NOTES, we don't do this because 	     of the possibility that we are running after CSE and there is a 	     REG_EQUAL note that is only valid if the branch has already been 	     taken.  If we move the insn with the REG_EQUAL note, we may 	     fold the comparison to always be false in a later CSE pass. 	     (We could also delete the REG_NOTES when moving the insn, but it 	     seems simpler to not move it.)  An exception is that we can move 	     the insn if the only note is a REG_EQUAL or REG_EQUIV whose 	     value is the same as "a".  	     INSN is the goto.  	     We set:  	     TEMP to the jump insn preceding "x = a;" 	     TEMP1 to X 	     TEMP2 to the insn that sets "x = b;" 	     TEMP3 to the insn that sets "x = a;" 	     TEMP4 to the set of "x = a";  */
if|if
condition|(
name|this_is_simplejump
operator|&&
operator|(
name|temp2
operator|=
name|next_active_insn
argument_list|(
name|insn
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|temp2
argument_list|)
operator|==
name|INSN
operator|&&
operator|(
name|temp4
operator|=
name|single_set
argument_list|(
name|temp2
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|temp1
operator|=
name|SET_DEST
argument_list|(
name|temp4
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
operator|(
operator|!
name|SMALL_REGISTER_CLASSES
operator|||
name|REGNO
argument_list|(
name|temp1
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
operator|&&
operator|(
name|temp3
operator|=
name|prev_active_insn
argument_list|(
name|insn
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|temp3
argument_list|)
operator|==
name|INSN
operator|&&
operator|(
name|temp4
operator|=
name|single_set
argument_list|(
name|temp3
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|rtx_equal_p
argument_list|(
name|SET_DEST
argument_list|(
name|temp4
argument_list|)
argument_list|,
name|temp1
argument_list|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|SET_SRC
argument_list|(
name|temp4
argument_list|)
argument_list|)
operator|&&
operator|!
name|may_trap_p
argument_list|(
name|SET_SRC
argument_list|(
name|temp4
argument_list|)
argument_list|)
operator|&&
operator|(
name|REG_NOTES
argument_list|(
name|temp3
argument_list|)
operator|==
literal|0
operator|||
operator|(
operator|(
name|REG_NOTE_KIND
argument_list|(
name|REG_NOTES
argument_list|(
name|temp3
argument_list|)
argument_list|)
operator|==
name|REG_EQUAL
operator|||
name|REG_NOTE_KIND
argument_list|(
name|REG_NOTES
argument_list|(
name|temp3
argument_list|)
argument_list|)
operator|==
name|REG_EQUIV
operator|)
operator|&&
name|XEXP
argument_list|(
name|REG_NOTES
argument_list|(
name|temp3
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|REG_NOTES
argument_list|(
name|temp3
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|SET_SRC
argument_list|(
name|temp4
argument_list|)
argument_list|)
operator|)
operator|)
operator|&&
operator|(
name|temp
operator|=
name|prev_active_insn
argument_list|(
name|temp3
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|condjump_p
argument_list|(
name|temp
argument_list|)
operator|&&
operator|!
name|simplejump_p
argument_list|(
name|temp
argument_list|)
comment|/* TEMP must skip over the "x = a;" insn */
operator|&&
name|prev_real_insn
argument_list|(
name|JUMP_LABEL
argument_list|(
name|temp
argument_list|)
argument_list|)
operator|==
name|insn
operator|&&
name|no_labels_between_p
argument_list|(
name|temp
argument_list|,
name|insn
argument_list|)
condition|)
block|{
name|rtx
name|prev_label
init|=
name|JUMP_LABEL
argument_list|(
name|temp
argument_list|)
decl_stmt|;
name|rtx
name|insert_after
init|=
name|prev_nonnote_insn
argument_list|(
name|temp
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_cc0
comment|/* We cannot insert anything between a set of cc and its use.  */
if|if
condition|(
name|insert_after
operator|&&
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insert_after
argument_list|)
argument_list|)
operator|==
literal|'i'
operator|&&
name|sets_cc0_p
argument_list|(
name|PATTERN
argument_list|(
name|insert_after
argument_list|)
argument_list|)
condition|)
name|insert_after
operator|=
name|prev_nonnote_insn
argument_list|(
name|insert_after
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|++
name|LABEL_NUSES
argument_list|(
name|prev_label
argument_list|)
expr_stmt|;
if|if
condition|(
name|insert_after
operator|&&
name|no_labels_between_p
argument_list|(
name|insert_after
argument_list|,
name|temp
argument_list|)
operator|&&
operator|!
name|reg_referenced_between_p
argument_list|(
name|temp1
argument_list|,
name|insert_after
argument_list|,
name|temp3
argument_list|)
operator|&&
operator|!
name|reg_referenced_between_p
argument_list|(
name|temp1
argument_list|,
name|temp3
argument_list|,
name|NEXT_INSN
argument_list|(
name|temp2
argument_list|)
argument_list|)
operator|&&
operator|!
name|reg_set_between_p
argument_list|(
name|temp1
argument_list|,
name|insert_after
argument_list|,
name|temp
argument_list|)
operator|&&
operator|!
name|modified_between_p
argument_list|(
name|SET_SRC
argument_list|(
name|temp4
argument_list|)
argument_list|,
name|insert_after
argument_list|,
name|temp
argument_list|)
operator|&&
name|invert_jump
argument_list|(
name|temp
argument_list|,
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
block|{
name|emit_insn_after_with_line_notes
argument_list|(
name|PATTERN
argument_list|(
name|temp3
argument_list|)
argument_list|,
name|insert_after
argument_list|,
name|temp3
argument_list|)
expr_stmt|;
name|delete_insn
argument_list|(
name|temp3
argument_list|)
expr_stmt|;
name|delete_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Set NEXT to an insn that we know won't go away.  */
name|next
operator|=
name|temp2
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|prev_label
operator|&&
operator|--
name|LABEL_NUSES
argument_list|(
name|prev_label
argument_list|)
operator|==
literal|0
condition|)
name|delete_insn
argument_list|(
name|prev_label
argument_list|)
expr_stmt|;
if|if
condition|(
name|changed
condition|)
continue|continue;
block|}
ifndef|#
directive|ifndef
name|HAVE_cc0
comment|/* If we have if (...) x = exp;  and branches are expensive, 	     EXP is a single insn, does not have any side effects, cannot 	     trap, and is not too costly, convert this to 	     t = exp; if (...) x = t;  	     Don't do this when we have CC0 because it is unlikely to help 	     and we'd need to worry about where to place the new insn and 	     the potential for conflicts.  We also can't do this when we have 	     notes on the insn for the same reason as above.  	     We set:  	     TEMP to the "x = exp;" insn. 	     TEMP1 to the single set in the "x = exp;" insn. 	     TEMP2 to "x".  */
if|if
condition|(
operator|!
name|reload_completed
operator|&&
name|this_is_condjump
operator|&&
operator|!
name|this_is_simplejump
operator|&&
name|BRANCH_COST
operator|>=
literal|3
operator|&&
operator|(
name|temp
operator|=
name|next_nonnote_insn
argument_list|(
name|insn
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|==
name|INSN
operator|&&
name|REG_NOTES
argument_list|(
name|temp
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|reallabelprev
operator|==
name|temp
operator|||
operator|(
operator|(
name|temp2
operator|=
name|next_active_insn
argument_list|(
name|temp
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|simplejump_p
argument_list|(
name|temp2
argument_list|)
operator|&&
name|JUMP_LABEL
argument_list|(
name|temp2
argument_list|)
operator|==
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
operator|)
operator|)
operator|&&
operator|(
name|temp1
operator|=
name|single_set
argument_list|(
name|temp
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|temp2
operator|=
name|SET_DEST
argument_list|(
name|temp1
argument_list|)
operator|,
name|GET_CODE
argument_list|(
name|temp2
argument_list|)
operator|==
name|REG
operator|)
operator|&&
operator|(
operator|!
name|SMALL_REGISTER_CLASSES
operator|||
name|REGNO
argument_list|(
name|temp2
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|temp1
argument_list|)
argument_list|)
operator|!=
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|temp1
argument_list|)
argument_list|)
operator|!=
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|temp1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|SET_SRC
argument_list|(
name|temp1
argument_list|)
argument_list|)
operator|&&
operator|!
name|may_trap_p
argument_list|(
name|SET_SRC
argument_list|(
name|temp1
argument_list|)
argument_list|)
operator|&&
name|rtx_cost
argument_list|(
name|SET_SRC
argument_list|(
name|temp1
argument_list|)
argument_list|,
name|SET
argument_list|)
operator|<
literal|10
condition|)
block|{
name|rtx
name|new
init|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|temp2
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|temp3
operator|=
name|find_insert_position
argument_list|(
name|insn
argument_list|,
name|temp
argument_list|)
operator|)
operator|&&
name|validate_change
argument_list|(
name|temp
argument_list|,
operator|&
name|SET_DEST
argument_list|(
name|temp1
argument_list|)
argument_list|,
name|new
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|next
operator|=
name|emit_insn_after
argument_list|(
name|gen_move_insn
argument_list|(
name|temp2
argument_list|,
name|new
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|emit_insn_after_with_line_notes
argument_list|(
name|PATTERN
argument_list|(
name|temp
argument_list|)
argument_list|,
name|PREV_INSN
argument_list|(
name|temp3
argument_list|)
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|delete_insn
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|reallabelprev
operator|=
name|prev_active_insn
argument_list|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|after_regscan
condition|)
block|{
name|reg_scan_update
argument_list|(
name|temp3
argument_list|,
name|NEXT_INSN
argument_list|(
name|next
argument_list|)
argument_list|,
name|old_max_reg
argument_list|)
expr_stmt|;
name|old_max_reg
operator|=
name|max_reg_num
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/* Similarly, if it takes two insns to compute EXP but they 	     have the same destination.  Here TEMP3 will be the second 	     insn and TEMP4 the SET from that insn.  */
if|if
condition|(
operator|!
name|reload_completed
operator|&&
name|this_is_condjump
operator|&&
operator|!
name|this_is_simplejump
operator|&&
name|BRANCH_COST
operator|>=
literal|4
operator|&&
operator|(
name|temp
operator|=
name|next_nonnote_insn
argument_list|(
name|insn
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|==
name|INSN
operator|&&
name|REG_NOTES
argument_list|(
name|temp
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|temp3
operator|=
name|next_nonnote_insn
argument_list|(
name|temp
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|temp3
argument_list|)
operator|==
name|INSN
operator|&&
name|REG_NOTES
argument_list|(
name|temp3
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|reallabelprev
operator|==
name|temp3
operator|||
operator|(
operator|(
name|temp2
operator|=
name|next_active_insn
argument_list|(
name|temp3
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|simplejump_p
argument_list|(
name|temp2
argument_list|)
operator|&&
name|JUMP_LABEL
argument_list|(
name|temp2
argument_list|)
operator|==
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
operator|)
operator|)
operator|&&
operator|(
name|temp1
operator|=
name|single_set
argument_list|(
name|temp
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|temp2
operator|=
name|SET_DEST
argument_list|(
name|temp1
argument_list|)
operator|,
name|GET_CODE
argument_list|(
name|temp2
argument_list|)
operator|==
name|REG
operator|)
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|temp2
argument_list|)
argument_list|)
operator|==
name|MODE_INT
operator|&&
operator|(
operator|!
name|SMALL_REGISTER_CLASSES
operator|||
name|REGNO
argument_list|(
name|temp2
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|SET_SRC
argument_list|(
name|temp1
argument_list|)
argument_list|)
operator|&&
operator|!
name|may_trap_p
argument_list|(
name|SET_SRC
argument_list|(
name|temp1
argument_list|)
argument_list|)
operator|&&
name|rtx_cost
argument_list|(
name|SET_SRC
argument_list|(
name|temp1
argument_list|)
argument_list|,
name|SET
argument_list|)
operator|<
literal|10
operator|&&
operator|(
name|temp4
operator|=
name|single_set
argument_list|(
name|temp3
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|rtx_equal_p
argument_list|(
name|SET_DEST
argument_list|(
name|temp4
argument_list|)
argument_list|,
name|temp2
argument_list|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|SET_SRC
argument_list|(
name|temp4
argument_list|)
argument_list|)
operator|&&
operator|!
name|may_trap_p
argument_list|(
name|SET_SRC
argument_list|(
name|temp4
argument_list|)
argument_list|)
operator|&&
name|rtx_cost
argument_list|(
name|SET_SRC
argument_list|(
name|temp4
argument_list|)
argument_list|,
name|SET
argument_list|)
operator|<
literal|10
condition|)
block|{
name|rtx
name|new
init|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|temp2
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|temp5
operator|=
name|find_insert_position
argument_list|(
name|insn
argument_list|,
name|temp
argument_list|)
operator|)
operator|&&
operator|(
name|temp6
operator|=
name|find_insert_position
argument_list|(
name|insn
argument_list|,
name|temp3
argument_list|)
operator|)
operator|&&
name|validate_change
argument_list|(
name|temp
argument_list|,
operator|&
name|SET_DEST
argument_list|(
name|temp1
argument_list|)
argument_list|,
name|new
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|/* Use the earliest of temp5 and temp6. */
if|if
condition|(
name|temp5
operator|!=
name|insn
condition|)
name|temp6
operator|=
name|temp5
expr_stmt|;
name|next
operator|=
name|emit_insn_after
argument_list|(
name|gen_move_insn
argument_list|(
name|temp2
argument_list|,
name|new
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|emit_insn_after_with_line_notes
argument_list|(
name|PATTERN
argument_list|(
name|temp
argument_list|)
argument_list|,
name|PREV_INSN
argument_list|(
name|temp6
argument_list|)
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|emit_insn_after_with_line_notes
argument_list|(
name|replace_rtx
argument_list|(
name|PATTERN
argument_list|(
name|temp3
argument_list|)
argument_list|,
name|temp2
argument_list|,
name|new
argument_list|)
argument_list|,
name|PREV_INSN
argument_list|(
name|temp6
argument_list|)
argument_list|,
name|temp3
argument_list|)
expr_stmt|;
name|delete_insn
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|delete_insn
argument_list|(
name|temp3
argument_list|)
expr_stmt|;
name|reallabelprev
operator|=
name|prev_active_insn
argument_list|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|after_regscan
condition|)
block|{
name|reg_scan_update
argument_list|(
name|temp6
argument_list|,
name|NEXT_INSN
argument_list|(
name|next
argument_list|)
argument_list|,
name|old_max_reg
argument_list|)
expr_stmt|;
name|old_max_reg
operator|=
name|max_reg_num
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/* Finally, handle the case where two insns are used to  	     compute EXP but a temporary register is used.  Here we must 	     ensure that the temporary register is not used anywhere else.  */
if|if
condition|(
operator|!
name|reload_completed
operator|&&
name|after_regscan
operator|&&
name|this_is_condjump
operator|&&
operator|!
name|this_is_simplejump
operator|&&
name|BRANCH_COST
operator|>=
literal|4
operator|&&
operator|(
name|temp
operator|=
name|next_nonnote_insn
argument_list|(
name|insn
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|==
name|INSN
operator|&&
name|REG_NOTES
argument_list|(
name|temp
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|temp3
operator|=
name|next_nonnote_insn
argument_list|(
name|temp
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|temp3
argument_list|)
operator|==
name|INSN
operator|&&
name|REG_NOTES
argument_list|(
name|temp3
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|reallabelprev
operator|==
name|temp3
operator|||
operator|(
operator|(
name|temp2
operator|=
name|next_active_insn
argument_list|(
name|temp3
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|simplejump_p
argument_list|(
name|temp2
argument_list|)
operator|&&
name|JUMP_LABEL
argument_list|(
name|temp2
argument_list|)
operator|==
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
operator|)
operator|)
operator|&&
operator|(
name|temp1
operator|=
name|single_set
argument_list|(
name|temp
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|temp5
operator|=
name|SET_DEST
argument_list|(
name|temp1
argument_list|)
operator|,
operator|(
name|GET_CODE
argument_list|(
name|temp5
argument_list|)
operator|==
name|REG
operator|||
operator|(
name|GET_CODE
argument_list|(
name|temp5
argument_list|)
operator|==
name|SUBREG
operator|&&
operator|(
name|temp5
operator|=
name|SUBREG_REG
argument_list|(
name|temp5
argument_list|)
operator|,
name|GET_CODE
argument_list|(
name|temp5
argument_list|)
operator|==
name|REG
operator|)
operator|)
operator|)
operator|)
operator|&&
name|REGNO
argument_list|(
name|temp5
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|REGNO_FIRST_UID
argument_list|(
name|REGNO
argument_list|(
name|temp5
argument_list|)
argument_list|)
operator|==
name|INSN_UID
argument_list|(
name|temp
argument_list|)
operator|&&
name|REGNO_LAST_UID
argument_list|(
name|REGNO
argument_list|(
name|temp5
argument_list|)
argument_list|)
operator|==
name|INSN_UID
argument_list|(
name|temp3
argument_list|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|SET_SRC
argument_list|(
name|temp1
argument_list|)
argument_list|)
operator|&&
operator|!
name|may_trap_p
argument_list|(
name|SET_SRC
argument_list|(
name|temp1
argument_list|)
argument_list|)
operator|&&
name|rtx_cost
argument_list|(
name|SET_SRC
argument_list|(
name|temp1
argument_list|)
argument_list|,
name|SET
argument_list|)
operator|<
literal|10
operator|&&
operator|(
name|temp4
operator|=
name|single_set
argument_list|(
name|temp3
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|temp2
operator|=
name|SET_DEST
argument_list|(
name|temp4
argument_list|)
operator|,
name|GET_CODE
argument_list|(
name|temp2
argument_list|)
operator|==
name|REG
operator|)
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|temp2
argument_list|)
argument_list|)
operator|==
name|MODE_INT
operator|&&
operator|(
operator|!
name|SMALL_REGISTER_CLASSES
operator|||
name|REGNO
argument_list|(
name|temp2
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
operator|&&
name|rtx_equal_p
argument_list|(
name|SET_DEST
argument_list|(
name|temp4
argument_list|)
argument_list|,
name|temp2
argument_list|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|SET_SRC
argument_list|(
name|temp4
argument_list|)
argument_list|)
operator|&&
operator|!
name|may_trap_p
argument_list|(
name|SET_SRC
argument_list|(
name|temp4
argument_list|)
argument_list|)
operator|&&
name|rtx_cost
argument_list|(
name|SET_SRC
argument_list|(
name|temp4
argument_list|)
argument_list|,
name|SET
argument_list|)
operator|<
literal|10
condition|)
block|{
name|rtx
name|new
init|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|temp2
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|temp5
operator|=
name|find_insert_position
argument_list|(
name|insn
argument_list|,
name|temp
argument_list|)
operator|)
operator|&&
operator|(
name|temp6
operator|=
name|find_insert_position
argument_list|(
name|insn
argument_list|,
name|temp3
argument_list|)
operator|)
operator|&&
name|validate_change
argument_list|(
name|temp3
argument_list|,
operator|&
name|SET_DEST
argument_list|(
name|temp4
argument_list|)
argument_list|,
name|new
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|/* Use the earliest of temp5 and temp6. */
if|if
condition|(
name|temp5
operator|!=
name|insn
condition|)
name|temp6
operator|=
name|temp5
expr_stmt|;
name|next
operator|=
name|emit_insn_after
argument_list|(
name|gen_move_insn
argument_list|(
name|temp2
argument_list|,
name|new
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|emit_insn_after_with_line_notes
argument_list|(
name|PATTERN
argument_list|(
name|temp
argument_list|)
argument_list|,
name|PREV_INSN
argument_list|(
name|temp6
argument_list|)
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|emit_insn_after_with_line_notes
argument_list|(
name|PATTERN
argument_list|(
name|temp3
argument_list|)
argument_list|,
name|PREV_INSN
argument_list|(
name|temp6
argument_list|)
argument_list|,
name|temp3
argument_list|)
expr_stmt|;
name|delete_insn
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|delete_insn
argument_list|(
name|temp3
argument_list|)
expr_stmt|;
name|reallabelprev
operator|=
name|prev_active_insn
argument_list|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|after_regscan
condition|)
block|{
name|reg_scan_update
argument_list|(
name|temp6
argument_list|,
name|NEXT_INSN
argument_list|(
name|next
argument_list|)
argument_list|,
name|old_max_reg
argument_list|)
expr_stmt|;
name|old_max_reg
operator|=
name|max_reg_num
argument_list|()
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* HAVE_cc0 */
comment|/* Try to use a conditional move (if the target has them), or a 	     store-flag insn.  The general case is:  	     1) x = a; if (...) x = b; and 	     2) if (...) x = b;  	     If the jump would be faster, the machine should not have defined 	     the movcc or scc insns!.  These cases are often made by the 	     previous optimization.  	     The second case is treated as  x = x; if (...) x = b;.  	     INSN here is the jump around the store.  We set:  	     TEMP to the "x = b;" insn. 	     TEMP1 to X. 	     TEMP2 to B. 	     TEMP3 to A (X in the second case). 	     TEMP4 to the condition being tested. 	     TEMP5 to the earliest insn used to find the condition.  */
if|if
condition|(
comment|/* We can't do this after reload has completed.  */
operator|!
name|reload_completed
operator|&&
name|this_is_condjump
operator|&&
operator|!
name|this_is_simplejump
comment|/* Set TEMP to the "x = b;" insn.  */
operator|&&
operator|(
name|temp
operator|=
name|next_nonnote_insn
argument_list|(
name|insn
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|temp
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|temp1
operator|=
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|temp
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
operator|(
operator|!
name|SMALL_REGISTER_CLASSES
operator|||
name|REGNO
argument_list|(
name|temp1
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|temp2
operator|=
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|temp
argument_list|)
argument_list|)
argument_list|)
operator|&&
operator|!
name|may_trap_p
argument_list|(
name|temp2
argument_list|)
comment|/* Allow either form, but prefer the former if both apply.  		 There is no point in using the old value of TEMP1 if 		 it is a register, since cse will alias them.  It can 		 lose if the old value were a hard register since CSE 		 won't replace hard registers.  Avoid using TEMP3 if 		 small register classes and it is a hard register.  */
operator|&&
operator|(
operator|(
operator|(
name|temp3
operator|=
name|reg_set_last
argument_list|(
name|temp1
argument_list|,
name|insn
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
operator|!
operator|(
name|SMALL_REGISTER_CLASSES
operator|&&
name|GET_CODE
argument_list|(
name|temp3
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|temp3
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|)
operator|)
comment|/* Make the latter case look like  x = x; if (...) x = b;  */
operator|||
operator|(
name|temp3
operator|=
name|temp1
operator|,
literal|1
operator|)
operator|)
comment|/* INSN must either branch to the insn after TEMP or the insn 		 after TEMP must branch to the same place as INSN.  */
operator|&&
operator|(
name|reallabelprev
operator|==
name|temp
operator|||
operator|(
operator|(
name|temp4
operator|=
name|next_active_insn
argument_list|(
name|temp
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|simplejump_p
argument_list|(
name|temp4
argument_list|)
operator|&&
name|JUMP_LABEL
argument_list|(
name|temp4
argument_list|)
operator|==
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
operator|)
operator|)
operator|&&
operator|(
name|temp4
operator|=
name|get_condition
argument_list|(
name|insn
argument_list|,
operator|&
name|temp5
argument_list|)
operator|)
operator|!=
literal|0
comment|/* We must be comparing objects whose modes imply the size. 		 We could handle BLKmode if (1) emit_store_flag could 		 and (2) we could find the size reliably.  */
operator|&&
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|temp4
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|BLKmode
comment|/* Even if branches are cheap, the store_flag optimization 		 can win when the operation to be performed can be 		 expressed directly.  */
ifdef|#
directive|ifdef
name|HAVE_cc0
comment|/* If the previous insn sets CC0 and something else, we can't 		 do this since we are going to delete that insn.  */
operator|&&
operator|!
operator|(
operator|(
name|temp6
operator|=
name|prev_nonnote_insn
argument_list|(
name|insn
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|temp6
argument_list|)
operator|==
name|INSN
operator|&&
operator|(
name|sets_cc0_p
argument_list|(
name|PATTERN
argument_list|(
name|temp6
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
operator|||
operator|(
name|sets_cc0_p
argument_list|(
name|PATTERN
argument_list|(
name|temp6
argument_list|)
argument_list|)
operator|==
literal|1
operator|&&
name|FIND_REG_INC_NOTE
argument_list|(
name|temp6
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
operator|)
operator|)
endif|#
directive|endif
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_conditional_move
comment|/* First try a conditional move.  */
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|temp4
argument_list|)
decl_stmt|;
name|rtx
name|var
init|=
name|temp1
decl_stmt|;
name|rtx
name|cond0
decl_stmt|,
name|cond1
decl_stmt|,
name|aval
decl_stmt|,
name|bval
decl_stmt|;
name|rtx
name|target
decl_stmt|;
comment|/* Copy the compared variables into cond0 and cond1, so that 		   any side effects performed in or after the old comparison, 		   will not affect our compare which will come later.  */
comment|/* ??? Is it possible to just use the comparison in the jump 		   insn?  After all, we're going to delete it.  We'd have 		   to modify emit_conditional_move to take a comparison rtx 		   instead or write a new function.  */
name|cond0
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|temp4
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We want the target to be able to simplify comparisons with 		   zero (and maybe other constants as well), so don't create 		   pseudos for them.  There's no need to either.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|temp4
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|temp4
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
name|cond1
operator|=
name|XEXP
argument_list|(
name|temp4
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|cond1
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|temp4
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|aval
operator|=
name|temp3
expr_stmt|;
name|bval
operator|=
name|temp2
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|target
operator|=
name|emit_conditional_move
argument_list|(
name|var
argument_list|,
name|code
argument_list|,
name|cond0
argument_list|,
name|cond1
argument_list|,
name|VOIDmode
argument_list|,
name|aval
argument_list|,
name|bval
argument_list|,
name|GET_MODE
argument_list|(
name|var
argument_list|)
argument_list|,
operator|(
name|code
operator|==
name|LTU
operator|||
name|code
operator|==
name|GEU
operator|||
name|code
operator|==
name|LEU
operator|||
name|code
operator|==
name|GTU
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
block|{
name|rtx
name|seq1
decl_stmt|,
name|seq2
decl_stmt|,
name|last
decl_stmt|;
comment|/* Save the conditional move sequence but don't emit it 		       yet.  On some machines, like the alpha, it is possible 		       that temp5 == insn, so next generate the sequence that 		       saves the compared values and then emit both 		       sequences ensuring seq1 occurs before seq2.  */
name|seq2
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
comment|/* Now that we can't fail, generate the copy insns that 		       preserve the compared values.  */
name|start_sequence
argument_list|()
expr_stmt|;
name|emit_move_insn
argument_list|(
name|cond0
argument_list|,
name|XEXP
argument_list|(
name|temp4
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cond1
operator|!=
name|XEXP
argument_list|(
name|temp4
argument_list|,
literal|1
argument_list|)
condition|)
name|emit_move_insn
argument_list|(
name|cond1
argument_list|,
name|XEXP
argument_list|(
name|temp4
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|seq1
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_insns_before
argument_list|(
name|seq1
argument_list|,
name|temp5
argument_list|)
expr_stmt|;
comment|/* Insert conditional move after insn, to be sure that 		       the jump and a possible compare won't be separated */
name|last
operator|=
name|emit_insns_after
argument_list|(
name|seq2
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* ??? We can also delete the insn that sets X to A. 		       Flow will do it too though.  */
name|delete_insn
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|delete_jump
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|after_regscan
condition|)
block|{
name|reg_scan_update
argument_list|(
name|seq1
argument_list|,
name|NEXT_INSN
argument_list|(
name|last
argument_list|)
argument_list|,
name|old_max_reg
argument_list|)
expr_stmt|;
name|old_max_reg
operator|=
name|max_reg_num
argument_list|()
expr_stmt|;
block|}
name|changed
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
else|else
name|end_sequence
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* That didn't work, try a store-flag insn.  		 We further divide the cases into:  		 1) x = a; if (...) x = b; and either A or B is zero, 		 2) if (...) x = 0; and jumps are expensive, 		 3) x = a; if (...) x = b; and A and B are constants where all 		 the set bits in A are also set in B and jumps are expensive, 		 4) x = a; if (...) x = b; and A and B non-zero, and jumps are 		 more expensive, and 		 5) if (...) x = b; if jumps are even more expensive.  */
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|temp1
argument_list|)
argument_list|)
operator|==
name|MODE_INT
operator|&&
operator|(
operator|(
name|GET_CODE
argument_list|(
name|temp3
argument_list|)
operator|==
name|CONST_INT
operator|)
comment|/* Make the latter case look like 			 x = x; if (...) x = 0;  */
operator|||
operator|(
name|temp3
operator|=
name|temp1
operator|,
operator|(
operator|(
name|BRANCH_COST
operator|>=
literal|2
operator|&&
name|temp2
operator|==
name|const0_rtx
operator|)
operator|||
name|BRANCH_COST
operator|>=
literal|3
operator|)
operator|)
operator|)
comment|/* If B is zero, OK; if A is zero, can only do (1) if we 		     can reverse the condition.  See if (3) applies possibly 		     by reversing the condition.  Prefer reversing to (4) when 		     branches are very expensive.  */
operator|&&
operator|(
operator|(
operator|(
name|BRANCH_COST
operator|>=
literal|2
operator|||
name|STORE_FLAG_VALUE
operator|==
operator|-
literal|1
operator|||
operator|(
name|STORE_FLAG_VALUE
operator|==
literal|1
comment|/* Check that the mask is a power of two, 			    so that it can probably be generated 			    with a shift.  */
operator|&&
name|GET_CODE
argument_list|(
name|temp3
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|exact_log2
argument_list|(
name|INTVAL
argument_list|(
name|temp3
argument_list|)
argument_list|)
operator|>=
literal|0
operator|)
operator|)
operator|&&
operator|(
name|reversep
operator|=
literal|0
operator|,
name|temp2
operator|==
name|const0_rtx
operator|)
operator|)
operator|||
operator|(
operator|(
name|BRANCH_COST
operator|>=
literal|2
operator|||
name|STORE_FLAG_VALUE
operator|==
operator|-
literal|1
operator|||
operator|(
name|STORE_FLAG_VALUE
operator|==
literal|1
operator|&&
name|GET_CODE
argument_list|(
name|temp2
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|exact_log2
argument_list|(
name|INTVAL
argument_list|(
name|temp2
argument_list|)
argument_list|)
operator|>=
literal|0
operator|)
operator|)
operator|&&
name|temp3
operator|==
name|const0_rtx
operator|&&
operator|(
name|reversep
operator|=
name|can_reverse_comparison_p
argument_list|(
name|temp4
argument_list|,
name|insn
argument_list|)
operator|)
operator|)
operator|||
operator|(
name|BRANCH_COST
operator|>=
literal|2
operator|&&
name|GET_CODE
argument_list|(
name|temp2
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|temp3
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
operator|(
name|INTVAL
argument_list|(
name|temp2
argument_list|)
operator|&
name|INTVAL
argument_list|(
name|temp3
argument_list|)
operator|)
operator|==
name|INTVAL
argument_list|(
name|temp2
argument_list|)
operator|||
operator|(
operator|(
name|INTVAL
argument_list|(
name|temp2
argument_list|)
operator|&
name|INTVAL
argument_list|(
name|temp3
argument_list|)
operator|)
operator|==
name|INTVAL
argument_list|(
name|temp3
argument_list|)
operator|&&
operator|(
name|reversep
operator|=
name|can_reverse_comparison_p
argument_list|(
name|temp4
argument_list|,
name|insn
argument_list|)
operator|)
operator|)
operator|)
operator|)
operator|||
name|BRANCH_COST
operator|>=
literal|3
operator|)
condition|)
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|temp4
argument_list|)
decl_stmt|;
name|rtx
name|uval
decl_stmt|,
name|cval
decl_stmt|,
name|var
init|=
name|temp1
decl_stmt|;
name|int
name|normalizep
decl_stmt|;
name|rtx
name|target
decl_stmt|;
comment|/* If necessary, reverse the condition.  */
if|if
condition|(
name|reversep
condition|)
name|code
operator|=
name|reverse_condition
argument_list|(
name|code
argument_list|)
operator|,
name|uval
operator|=
name|temp2
operator|,
name|cval
operator|=
name|temp3
expr_stmt|;
else|else
name|uval
operator|=
name|temp3
operator|,
name|cval
operator|=
name|temp2
expr_stmt|;
comment|/* If CVAL is non-zero, normalize to -1.  Otherwise, if UVAL 		     is the constant 1, it is best to just compute the result 		     directly.  If UVAL is constant and STORE_FLAG_VALUE 		     includes all of its bits, it is best to compute the flag 		     value unnormalized and `and' it with UVAL.  Otherwise, 		     normalize to -1 and `and' with UVAL.  */
name|normalizep
operator|=
operator|(
name|cval
operator|!=
name|const0_rtx
condition|?
operator|-
literal|1
else|:
operator|(
name|uval
operator|==
name|const1_rtx
condition|?
literal|1
else|:
operator|(
name|GET_CODE
argument_list|(
name|uval
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|INTVAL
argument_list|(
name|uval
argument_list|)
operator|&
operator|~
name|STORE_FLAG_VALUE
operator|)
operator|==
literal|0
operator|)
condition|?
literal|0
else|:
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
comment|/* We will be putting the store-flag insn immediately in 		     front of the comparison that was originally being done, 		     so we know all the variables in TEMP4 will be valid. 		     However, this might be in front of the assignment of 		     A to VAR.  If it is, it would clobber the store-flag 		     we will be emitting.  		     Therefore, emit into a temporary which will be copied to 		     VAR immediately after TEMP.  */
name|start_sequence
argument_list|()
expr_stmt|;
name|target
operator|=
name|emit_store_flag
argument_list|(
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|var
argument_list|)
argument_list|)
argument_list|,
name|code
argument_list|,
name|XEXP
argument_list|(
name|temp4
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|temp4
argument_list|,
literal|1
argument_list|)
argument_list|,
name|VOIDmode
argument_list|,
operator|(
name|code
operator|==
name|LTU
operator|||
name|code
operator|==
name|LEU
operator|||
name|code
operator|==
name|GEU
operator|||
name|code
operator|==
name|GTU
operator|)
argument_list|,
name|normalizep
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
block|{
name|rtx
name|seq
decl_stmt|;
name|rtx
name|before
init|=
name|insn
decl_stmt|;
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
comment|/* Put the store-flag insns in front of the first insn 			 used to compute the condition to ensure that we 			 use the same values of them as the current  			 comparison.  However, the remainder of the insns we 			 generate will be placed directly in front of the 			 jump insn, in case any of the pseudos we use 			 are modified earlier.  */
name|emit_insns_before
argument_list|(
name|seq
argument_list|,
name|temp5
argument_list|)
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
comment|/* Both CVAL and UVAL are non-zero.  */
if|if
condition|(
name|cval
operator|!=
name|const0_rtx
operator|&&
name|uval
operator|!=
name|const0_rtx
condition|)
block|{
name|rtx
name|tem1
decl_stmt|,
name|tem2
decl_stmt|;
name|tem1
operator|=
name|expand_and
argument_list|(
name|uval
argument_list|,
name|target
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|cval
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|uval
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|INTVAL
argument_list|(
name|cval
argument_list|)
operator|&
name|INTVAL
argument_list|(
name|uval
argument_list|)
operator|)
operator|==
name|INTVAL
argument_list|(
name|cval
argument_list|)
condition|)
name|tem2
operator|=
name|cval
expr_stmt|;
else|else
block|{
name|tem2
operator|=
name|expand_unop
argument_list|(
name|GET_MODE
argument_list|(
name|var
argument_list|)
argument_list|,
name|one_cmpl_optab
argument_list|,
name|target
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tem2
operator|=
name|expand_and
argument_list|(
name|cval
argument_list|,
name|tem2
argument_list|,
operator|(
name|GET_CODE
argument_list|(
name|tem2
argument_list|)
operator|==
name|REG
condition|?
name|tem2
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* If we usually make new pseudos, do so here.  This 			     turns out to help machines that have conditional 			     move insns.  */
comment|/* ??? Conditional moves have already been handled. 			     This may be obsolete.  */
if|if
condition|(
name|flag_expensive_optimizations
condition|)
name|target
operator|=
literal|0
expr_stmt|;
name|target
operator|=
name|expand_binop
argument_list|(
name|GET_MODE
argument_list|(
name|var
argument_list|)
argument_list|,
name|ior_optab
argument_list|,
name|tem1
argument_list|,
name|tem2
argument_list|,
name|target
argument_list|,
literal|1
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|normalizep
operator|!=
literal|1
condition|)
block|{
comment|/* We know that either CVAL or UVAL is zero.  If 			     UVAL is zero, negate TARGET and `and' with CVAL. 			     Otherwise, `and' with UVAL.  */
if|if
condition|(
name|uval
operator|==
name|const0_rtx
condition|)
block|{
name|target
operator|=
name|expand_unop
argument_list|(
name|GET_MODE
argument_list|(
name|var
argument_list|)
argument_list|,
name|one_cmpl_optab
argument_list|,
name|target
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|uval
operator|=
name|cval
expr_stmt|;
block|}
name|target
operator|=
name|expand_and
argument_list|(
name|uval
argument_list|,
name|target
argument_list|,
operator|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|REG
operator|&&
operator|!
name|preserve_subexpressions_p
argument_list|()
condition|?
name|target
else|:
name|NULL_RTX
operator|)
argument_list|)
expr_stmt|;
block|}
name|emit_move_insn
argument_list|(
name|var
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_cc0
comment|/* If INSN uses CC0, we must not separate it from the 			 insn that sets cc0.  */
if|if
condition|(
name|reg_mentioned_p
argument_list|(
name|cc0_rtx
argument_list|,
name|PATTERN
argument_list|(
name|before
argument_list|)
argument_list|)
condition|)
name|before
operator|=
name|prev_nonnote_insn
argument_list|(
name|before
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|emit_insns_before
argument_list|(
name|seq
argument_list|,
name|before
argument_list|)
expr_stmt|;
name|delete_insn
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|delete_jump
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|after_regscan
condition|)
block|{
name|reg_scan_update
argument_list|(
name|seq
argument_list|,
name|NEXT_INSN
argument_list|(
name|next
argument_list|)
argument_list|,
name|old_max_reg
argument_list|)
expr_stmt|;
name|old_max_reg
operator|=
name|max_reg_num
argument_list|()
expr_stmt|;
block|}
name|changed
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
else|else
name|end_sequence
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* If branches are expensive, convert 	        if (foo) bar++;    to    bar += (foo != 0); 	     and similarly for "bar--;"   	     INSN is the conditional branch around the arithmetic.  We set:  	     TEMP is the arithmetic insn. 	     TEMP1 is the SET doing the arithmetic. 	     TEMP2 is the operand being incremented or decremented. 	     TEMP3 to the condition being tested. 	     TEMP4 to the earliest insn used to find the condition.  */
if|if
condition|(
operator|(
name|BRANCH_COST
operator|>=
literal|2
ifdef|#
directive|ifdef
name|HAVE_incscc
operator|||
name|HAVE_incscc
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_decscc
operator|||
name|HAVE_decscc
endif|#
directive|endif
operator|)
operator|&&
operator|!
name|reload_completed
operator|&&
name|this_is_condjump
operator|&&
operator|!
name|this_is_simplejump
operator|&&
operator|(
name|temp
operator|=
name|next_nonnote_insn
argument_list|(
name|insn
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|temp1
operator|=
name|single_set
argument_list|(
name|temp
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|temp2
operator|=
name|SET_DEST
argument_list|(
name|temp1
argument_list|)
operator|,
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|temp2
argument_list|)
argument_list|)
operator|==
name|MODE_INT
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|temp1
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
operator|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|temp1
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
name|const1_rtx
operator|||
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|temp1
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
name|constm1_rtx
operator|)
operator|&&
name|rtx_equal_p
argument_list|(
name|temp2
argument_list|,
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|temp1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|temp2
argument_list|)
operator|&&
operator|!
name|may_trap_p
argument_list|(
name|temp2
argument_list|)
comment|/* INSN must either branch to the insn after TEMP or the insn 		 after TEMP must branch to the same place as INSN.  */
operator|&&
operator|(
name|reallabelprev
operator|==
name|temp
operator|||
operator|(
operator|(
name|temp3
operator|=
name|next_active_insn
argument_list|(
name|temp
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|simplejump_p
argument_list|(
name|temp3
argument_list|)
operator|&&
name|JUMP_LABEL
argument_list|(
name|temp3
argument_list|)
operator|==
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
operator|)
operator|)
operator|&&
operator|(
name|temp3
operator|=
name|get_condition
argument_list|(
name|insn
argument_list|,
operator|&
name|temp4
argument_list|)
operator|)
operator|!=
literal|0
comment|/* We must be comparing objects whose modes imply the size. 		 We could handle BLKmode if (1) emit_store_flag could 		 and (2) we could find the size reliably.  */
operator|&&
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|temp3
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|BLKmode
operator|&&
name|can_reverse_comparison_p
argument_list|(
name|temp3
argument_list|,
name|insn
argument_list|)
condition|)
block|{
name|rtx
name|temp6
decl_stmt|,
name|target
init|=
literal|0
decl_stmt|,
name|seq
decl_stmt|,
name|init_insn
init|=
literal|0
decl_stmt|,
name|init
init|=
name|temp2
decl_stmt|;
name|enum
name|rtx_code
name|code
init|=
name|reverse_condition
argument_list|(
name|GET_CODE
argument_list|(
name|temp3
argument_list|)
argument_list|)
decl_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
comment|/* It must be the case that TEMP2 is not modified in the range 		 [TEMP4, INSN).  The one exception we make is if the insn 		 before INSN sets TEMP2 to something which is also unchanged 		 in that range.  In that case, we can move the initialization 		 into our sequence.  */
if|if
condition|(
operator|(
name|temp5
operator|=
name|prev_active_insn
argument_list|(
name|insn
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|no_labels_between_p
argument_list|(
name|temp5
argument_list|,
name|insn
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|temp5
argument_list|)
operator|==
name|INSN
operator|&&
operator|(
name|temp6
operator|=
name|single_set
argument_list|(
name|temp5
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|rtx_equal_p
argument_list|(
name|temp2
argument_list|,
name|SET_DEST
argument_list|(
name|temp6
argument_list|)
argument_list|)
operator|&&
operator|(
name|CONSTANT_P
argument_list|(
name|SET_SRC
argument_list|(
name|temp6
argument_list|)
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|temp6
argument_list|)
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|temp6
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|)
condition|)
block|{
name|emit_insn
argument_list|(
name|PATTERN
argument_list|(
name|temp5
argument_list|)
argument_list|)
expr_stmt|;
name|init_insn
operator|=
name|temp5
expr_stmt|;
name|init
operator|=
name|SET_SRC
argument_list|(
name|temp6
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|init
argument_list|)
operator|||
operator|!
name|reg_set_between_p
argument_list|(
name|init
argument_list|,
name|PREV_INSN
argument_list|(
name|temp4
argument_list|)
argument_list|,
name|insn
argument_list|)
condition|)
name|target
operator|=
name|emit_store_flag
argument_list|(
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|temp2
argument_list|)
argument_list|)
argument_list|,
name|code
argument_list|,
name|XEXP
argument_list|(
name|temp3
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|temp3
argument_list|,
literal|1
argument_list|)
argument_list|,
name|VOIDmode
argument_list|,
operator|(
name|code
operator|==
name|LTU
operator|||
name|code
operator|==
name|LEU
operator|||
name|code
operator|==
name|GTU
operator|||
name|code
operator|==
name|GEU
operator|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* If we can do the store-flag, do the addition or 		 subtraction.  */
if|if
condition|(
name|target
condition|)
name|target
operator|=
name|expand_binop
argument_list|(
name|GET_MODE
argument_list|(
name|temp2
argument_list|)
argument_list|,
operator|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|temp1
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
name|const1_rtx
condition|?
name|add_optab
else|:
name|sub_optab
operator|)
argument_list|,
name|temp2
argument_list|,
name|target
argument_list|,
name|temp2
argument_list|,
literal|0
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|!=
literal|0
condition|)
block|{
comment|/* Put the result back in temp2 in case it isn't already. 		     Then replace the jump, possible a CC0-setting insn in 		     front of the jump, and TEMP, with the sequence we have 		     made.  */
if|if
condition|(
name|target
operator|!=
name|temp2
condition|)
name|emit_move_insn
argument_list|(
name|temp2
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_insns_before
argument_list|(
name|seq
argument_list|,
name|temp4
argument_list|)
expr_stmt|;
name|delete_insn
argument_list|(
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|init_insn
condition|)
name|delete_insn
argument_list|(
name|init_insn
argument_list|)
expr_stmt|;
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_cc0
name|delete_insn
argument_list|(
name|prev_nonnote_insn
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|delete_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|after_regscan
condition|)
block|{
name|reg_scan_update
argument_list|(
name|seq
argument_list|,
name|NEXT_INSN
argument_list|(
name|next
argument_list|)
argument_list|,
name|old_max_reg
argument_list|)
expr_stmt|;
name|old_max_reg
operator|=
name|max_reg_num
argument_list|()
expr_stmt|;
block|}
name|changed
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
else|else
name|end_sequence
argument_list|()
expr_stmt|;
block|}
comment|/* Simplify   if (...) x = 1; else {...}  if (x) ... 	     We recognize this case scanning backwards as well.  	     TEMP is the assignment to x; 	     TEMP1 is the label at the head of the second if.  */
comment|/* ?? This should call get_condition to find the values being 	     compared, instead of looking for a COMPARE insn when HAVE_cc0 	     is not defined.  This would allow it to work on the m88k.  */
comment|/* ?? This optimization is only safe before cse is run if HAVE_cc0 	     is not defined and the condition is tested by a separate compare 	     insn.  This is because the code below assumes that the result 	     of the compare dies in the following branch.  	     Not only that, but there might be other insns between the 	     compare and branch whose results are live.  Those insns need 	     to be executed.  	     A way to fix this is to move the insns at JUMP_LABEL (insn) 	     to before INSN.  If we are running before flow, they will 	     be deleted if they aren't needed.   But this doesn't work 	     well after flow.  	     This is really a special-case of jump threading, anyway.  The 	     right thing to do is to replace this and jump threading with 	     much simpler code in cse.  	     This code has been turned off in the non-cc0 case in the 	     meantime.  */
ifdef|#
directive|ifdef
name|HAVE_cc0
elseif|else
if|if
condition|(
name|this_is_simplejump
comment|/* Safe to skip USE and CLOBBER insns here 		      since they will not be deleted.  */
operator|&&
operator|(
name|temp
operator|=
name|prev_active_insn
argument_list|(
name|insn
argument_list|)
operator|)
operator|&&
name|no_labels_between_p
argument_list|(
name|temp
argument_list|,
name|insn
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|temp
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|temp
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|CONSTANT_P
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|temp
argument_list|)
argument_list|)
argument_list|)
operator|&&
operator|(
name|temp1
operator|=
name|next_active_insn
argument_list|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|)
comment|/* If we find that the next value tested is `x' 		      (TEMP1 is the insn where this happens), win.  */
operator|&&
name|GET_CODE
argument_list|(
name|temp1
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|temp1
argument_list|)
argument_list|)
operator|==
name|SET
ifdef|#
directive|ifdef
name|HAVE_cc0
comment|/* Does temp1 `tst' the value of x?  */
operator|&&
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|temp1
argument_list|)
argument_list|)
operator|==
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|temp
argument_list|)
argument_list|)
operator|&&
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|temp1
argument_list|)
argument_list|)
operator|==
name|cc0_rtx
operator|&&
operator|(
name|temp1
operator|=
name|next_nonnote_insn
argument_list|(
name|temp1
argument_list|)
operator|)
else|#
directive|else
comment|/* Does temp1 compare the value of x against zero?  */
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|temp1
argument_list|)
argument_list|)
argument_list|)
operator|==
name|COMPARE
operator|&&
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|temp1
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
name|const0_rtx
operator|&&
operator|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|temp1
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|temp
argument_list|)
argument_list|)
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|temp1
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|temp1
operator|=
name|find_next_ref
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|temp1
argument_list|)
argument_list|)
argument_list|,
name|temp1
argument_list|)
operator|)
endif|#
directive|endif
operator|&&
name|condjump_p
argument_list|(
name|temp1
argument_list|)
condition|)
block|{
comment|/* Get the if_then_else from the condjump.  */
name|rtx
name|choice
init|=
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|temp1
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|choice
argument_list|)
operator|==
name|IF_THEN_ELSE
condition|)
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|choice
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|val
init|=
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|temp
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|cond
init|=
name|simplify_relational_operation
argument_list|(
name|code
argument_list|,
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|temp
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|val
argument_list|,
name|const0_rtx
argument_list|)
decl_stmt|;
name|rtx
name|ultimate
decl_stmt|;
if|if
condition|(
name|cond
operator|==
name|const_true_rtx
condition|)
name|ultimate
operator|=
name|XEXP
argument_list|(
name|choice
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cond
operator|==
name|const0_rtx
condition|)
name|ultimate
operator|=
name|XEXP
argument_list|(
name|choice
argument_list|,
literal|2
argument_list|)
expr_stmt|;
else|else
name|ultimate
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ultimate
operator|==
name|pc_rtx
condition|)
name|ultimate
operator|=
name|get_label_after
argument_list|(
name|temp1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ultimate
operator|&&
name|GET_CODE
argument_list|(
name|ultimate
argument_list|)
operator|!=
name|RETURN
condition|)
name|ultimate
operator|=
name|XEXP
argument_list|(
name|ultimate
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ultimate
operator|&&
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
operator|!=
name|ultimate
condition|)
name|changed
operator||=
name|redirect_jump
argument_list|(
name|insn
argument_list|,
name|ultimate
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|#
directive|if
literal|0
comment|/* @@ This needs a bit of work before it will be right.  	     Any type of comparison can be accepted for the first and 	     second compare.  When rewriting the first jump, we must 	     compute the what conditions can reach label3, and use the 	     appropriate code.  We can not simply reverse/swap the code 	     of the first jump.  In some cases, the second jump must be 	     rewritten also.  	     For example,<  == converts to>  ==<  != converts to ==> 	     etc.  	     If the code is written to only accept an '==' test for the second 	     compare, then all that needs to be done is to swap the condition 	     of the first branch.  	     It is questionable whether we want this optimization anyways, 	     since if the user wrote code like this because he/she knew that 	     the jump to label1 is taken most of the time, then rewriting 	     this gives slower code.  */
comment|/* @@ This should call get_condition to find the values being 	     compared, instead of looking for a COMPARE insn when HAVE_cc0 	     is not defined.  This would allow it to work on the m88k.  */
comment|/* @@ This optimization is only safe before cse is run if HAVE_cc0 	     is not defined and the condition is tested by a separate compare 	     insn.  This is because the code below assumes that the result 	     of the compare dies in the following branch.  */
comment|/* Simplify  test a ~= b 		       condjump label1; 		       test a == b 		       condjump label2; 		       jump label3; 		       label1:  	     rewriting as 		       test a ~~= b 		       condjump label3 		       test a == b 		       condjump label2 		       label1:  	     where ~= is an inequality, e.g.>, and ~~= is the swapped 	     inequality, e.g.<.  	     We recognize this case scanning backwards.  	     TEMP is the conditional jump to `label2'; 	     TEMP1 is the test for `a == b'; 	     TEMP2 is the conditional jump to `label1'; 	     TEMP3 is the test for `a ~= b'.  */
if|else if (this_is_simplejump&& (temp = prev_active_insn (insn))&& no_labels_between_p (temp, insn)&& condjump_p (temp)&& (temp1 = prev_active_insn (temp))&& no_labels_between_p (temp1, temp)&& GET_CODE (temp1) == INSN&& GET_CODE (PATTERN (temp1)) == SET
ifdef|#
directive|ifdef
name|HAVE_cc0
if|&& sets_cc0_p (PATTERN (temp1)) == 1
else|#
directive|else
if|&& GET_CODE (SET_SRC (PATTERN (temp1))) == COMPARE&& GET_CODE (SET_DEST (PATTERN (temp1))) == REG&& (temp == find_next_ref (SET_DEST (PATTERN (temp1)), temp1))
endif|#
directive|endif
if|&& (temp2 = prev_active_insn (temp1))&& no_labels_between_p (temp2, temp1)&& condjump_p (temp2)&& JUMP_LABEL (temp2) == next_nonnote_insn (NEXT_INSN (insn))&& (temp3 = prev_active_insn (temp2))&& no_labels_between_p (temp3, temp2)&& GET_CODE (PATTERN (temp3)) == SET&& rtx_equal_p (SET_DEST (PATTERN (temp3)), 				   SET_DEST (PATTERN (temp1)))&& rtx_equal_p (SET_SRC (PATTERN (temp1)), 				   SET_SRC (PATTERN (temp3)))&& ! inequality_comparisons_p (PATTERN (temp))&& inequality_comparisons_p (PATTERN (temp2))) 	    { 	      rtx fallthrough_label = JUMP_LABEL (temp2);  	      ++LABEL_NUSES (fallthrough_label); 	      if (swap_jump (temp2, JUMP_LABEL (insn))) 		{ 		  delete_insn (insn); 		  changed = 1; 		}  	      if (--LABEL_NUSES (fallthrough_label) == 0) 		delete_insn (fallthrough_label); 	    }
endif|#
directive|endif
comment|/* Simplify  if (...) {... x = 1;} if (x) ...  	     We recognize this case backwards.  	     TEMP is the test of `x'; 	     TEMP1 is the assignment to `x' at the end of the 	     previous statement.  */
comment|/* @@ This should call get_condition to find the values being 	     compared, instead of looking for a COMPARE insn when HAVE_cc0 	     is not defined.  This would allow it to work on the m88k.  */
comment|/* @@ This optimization is only safe before cse is run if HAVE_cc0 	     is not defined and the condition is tested by a separate compare 	     insn.  This is because the code below assumes that the result 	     of the compare dies in the following branch.  */
comment|/* ??? This has to be turned off.  The problem is that the 	     unconditional jump might indirectly end up branching to the 	     label between TEMP1 and TEMP.  We can't detect this, in general, 	     since it may become a jump to there after further optimizations. 	     If that jump is done, it will be deleted, so we will retry 	     this optimization in the next pass, thus an infinite loop.  	     The present code prevents this by putting the jump after the 	     label, but this is not logically correct.  */
if|#
directive|if
literal|0
if|else if (this_is_condjump
comment|/* Safe to skip USE and CLOBBER insns here 		      since they will not be deleted.  */
if|&& (temp = prev_active_insn (insn))&& no_labels_between_p (temp, insn)&& GET_CODE (temp) == INSN&& GET_CODE (PATTERN (temp)) == SET
ifdef|#
directive|ifdef
name|HAVE_cc0
if|&& sets_cc0_p (PATTERN (temp)) == 1&& GET_CODE (SET_SRC (PATTERN (temp))) == REG
else|#
directive|else
comment|/* Temp must be a compare insn, we can not accept a register 		      to register move here, since it may not be simply a 		      tst insn.  */
if|&& GET_CODE (SET_SRC (PATTERN (temp))) == COMPARE&& XEXP (SET_SRC (PATTERN (temp)), 1) == const0_rtx&& GET_CODE (XEXP (SET_SRC (PATTERN (temp)), 0)) == REG&& GET_CODE (SET_DEST (PATTERN (temp))) == REG&& insn == find_next_ref (SET_DEST (PATTERN (temp)), temp)
endif|#
directive|endif
comment|/* May skip USE or CLOBBER insns here 		      for checking for opportunity, since we 		      take care of them later.  */
if|&& (temp1 = prev_active_insn (temp))&& GET_CODE (temp1) == INSN&& GET_CODE (PATTERN (temp1)) == SET
ifdef|#
directive|ifdef
name|HAVE_cc0
if|&& SET_SRC (PATTERN (temp)) == SET_DEST (PATTERN (temp1))
else|#
directive|else
if|&& (XEXP (SET_SRC (PATTERN (temp)), 0) 		       == SET_DEST (PATTERN (temp1)))
endif|#
directive|endif
if|&& CONSTANT_P (SET_SRC (PATTERN (temp1)))
comment|/* If this isn't true, cse will do the job.  */
if|&& ! no_labels_between_p (temp1, temp)) 	    {
comment|/* Get the if_then_else from the condjump.  */
if|rtx choice = SET_SRC (PATTERN (insn)); 	      if (GET_CODE (choice) == IF_THEN_ELSE&& (GET_CODE (XEXP (choice, 0)) == EQ 		      || GET_CODE (XEXP (choice, 0)) == NE)) 		{ 		  int want_nonzero = (GET_CODE (XEXP (choice, 0)) == NE); 		  rtx last_insn; 		  rtx ultimate; 		  rtx p;
comment|/* Get the place that condjump will jump to 		     if it is reached from here.  */
if|if ((SET_SRC (PATTERN (temp1)) != const0_rtx) 		      == want_nonzero) 		    ultimate = XEXP (choice, 1); 		  else 		    ultimate = XEXP (choice, 2);
comment|/* Get it as a CODE_LABEL.  */
if|if (ultimate == pc_rtx) 		    ultimate = get_label_after (insn); 		  else
comment|/* Get the label out of the LABEL_REF.  */
if|ultimate = XEXP (ultimate, 0);
comment|/* Insert the jump immediately before TEMP, specifically 		     after the label that is between TEMP1 and TEMP.  */
if|last_insn = PREV_INSN (temp);
comment|/* If we would be branching to the next insn, the jump 		     would immediately be deleted and the re-inserted in 		     a subsequent pass over the code.  So don't do anything 		     in that case.  */
if|if (next_active_insn (last_insn) 		      != next_active_insn (ultimate)) 		    { 		      emit_barrier_after (last_insn); 		      p = emit_jump_insn_after (gen_jump (ultimate), 						last_insn); 		      JUMP_LABEL (p) = ultimate; 		      ++LABEL_NUSES (ultimate); 		      if (INSN_UID (ultimate)< max_jump_chain&& INSN_CODE (p)< max_jump_chain) 			{ 			  jump_chain[INSN_UID (p)] 			    = jump_chain[INSN_UID (ultimate)]; 			  jump_chain[INSN_UID (ultimate)] = p; 			} 		      changed = 1; 		      continue; 		    } 		} 	    }
endif|#
directive|endif
comment|/* Detect a conditional jump going to the same place 	     as an immediately following unconditional jump.  */
elseif|else
if|if
condition|(
name|this_is_condjump
operator|&&
operator|(
name|temp
operator|=
name|next_active_insn
argument_list|(
name|insn
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|simplejump_p
argument_list|(
name|temp
argument_list|)
operator|&&
operator|(
name|next_active_insn
argument_list|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|next_active_insn
argument_list|(
name|JUMP_LABEL
argument_list|(
name|temp
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|rtx
name|tem
init|=
name|temp
decl_stmt|;
comment|/* ??? Optional.  Disables some optimizations, but makes 		 gcov output more accurate with -O.  */
if|if
condition|(
name|flag_test_coverage
operator|&&
operator|!
name|reload_completed
condition|)
for|for
control|(
name|tem
operator|=
name|insn
init|;
name|tem
operator|!=
name|temp
condition|;
name|tem
operator|=
name|NEXT_INSN
argument_list|(
name|tem
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|tem
argument_list|)
operator|>
literal|0
condition|)
break|break;
if|if
condition|(
name|tem
operator|==
name|temp
condition|)
block|{
name|delete_jump
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
block|}
ifdef|#
directive|ifdef
name|HAVE_trap
comment|/* Detect a conditional jump jumping over an unconditional trap.  */
elseif|else
if|if
condition|(
name|HAVE_trap
operator|&&
name|this_is_condjump
operator|&&
operator|!
name|this_is_simplejump
operator|&&
name|reallabelprev
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|reallabelprev
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|reallabelprev
argument_list|)
argument_list|)
operator|==
name|TRAP_IF
operator|&&
name|TRAP_CONDITION
argument_list|(
name|PATTERN
argument_list|(
name|reallabelprev
argument_list|)
argument_list|)
operator|==
name|const_true_rtx
operator|&&
name|prev_active_insn
argument_list|(
name|reallabelprev
argument_list|)
operator|==
name|insn
operator|&&
name|no_labels_between_p
argument_list|(
name|insn
argument_list|,
name|reallabelprev
argument_list|)
operator|&&
operator|(
name|temp2
operator|=
name|get_condition
argument_list|(
name|insn
argument_list|,
operator|&
name|temp4
argument_list|)
operator|)
operator|&&
name|can_reverse_comparison_p
argument_list|(
name|temp2
argument_list|,
name|insn
argument_list|)
condition|)
block|{
name|rtx
name|new
init|=
name|gen_cond_trap
argument_list|(
name|reverse_condition
argument_list|(
name|GET_CODE
argument_list|(
name|temp2
argument_list|)
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|temp2
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|temp2
argument_list|,
literal|1
argument_list|)
argument_list|,
name|TRAP_CODE
argument_list|(
name|PATTERN
argument_list|(
name|reallabelprev
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|new
condition|)
block|{
name|emit_insn_before
argument_list|(
name|new
argument_list|,
name|temp4
argument_list|)
expr_stmt|;
name|delete_insn
argument_list|(
name|reallabelprev
argument_list|)
expr_stmt|;
name|delete_jump
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* Detect a jump jumping to an unconditional trap.  */
elseif|else
if|if
condition|(
name|HAVE_trap
operator|&&
name|this_is_condjump
operator|&&
operator|(
name|temp
operator|=
name|next_active_insn
argument_list|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|temp
argument_list|)
argument_list|)
operator|==
name|TRAP_IF
operator|&&
operator|(
name|this_is_simplejump
operator|||
operator|(
name|temp2
operator|=
name|get_condition
argument_list|(
name|insn
argument_list|,
operator|&
name|temp4
argument_list|)
operator|)
operator|)
condition|)
block|{
name|rtx
name|tc
init|=
name|TRAP_CONDITION
argument_list|(
name|PATTERN
argument_list|(
name|temp
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|tc
operator|==
name|const_true_rtx
operator|||
operator|(
operator|!
name|this_is_simplejump
operator|&&
name|rtx_equal_p
argument_list|(
name|temp2
argument_list|,
name|tc
argument_list|)
operator|)
condition|)
block|{
name|rtx
name|new
decl_stmt|;
comment|/* Replace an unconditional jump to a trap with a trap.  */
if|if
condition|(
name|this_is_simplejump
condition|)
block|{
name|emit_barrier_after
argument_list|(
name|emit_insn_before
argument_list|(
name|gen_trap
argument_list|()
argument_list|,
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|delete_jump
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
name|new
operator|=
name|gen_cond_trap
argument_list|(
name|GET_CODE
argument_list|(
name|temp2
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|temp2
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|temp2
argument_list|,
literal|1
argument_list|)
argument_list|,
name|TRAP_CODE
argument_list|(
name|PATTERN
argument_list|(
name|temp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
condition|)
block|{
name|emit_insn_before
argument_list|(
name|new
argument_list|,
name|temp4
argument_list|)
expr_stmt|;
name|delete_jump
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* If the trap condition and jump condition are mutually 		 exclusive, redirect the jump to the following insn.  */
elseif|else
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|tc
argument_list|)
argument_list|)
operator|==
literal|'<'
operator|&&
operator|!
name|this_is_simplejump
operator|&&
name|swap_condition
argument_list|(
name|GET_CODE
argument_list|(
name|temp2
argument_list|)
argument_list|)
operator|==
name|GET_CODE
argument_list|(
name|tc
argument_list|)
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|tc
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|temp2
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|tc
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|temp2
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|redirect_jump
argument_list|(
name|insn
argument_list|,
name|get_label_after
argument_list|(
name|temp
argument_list|)
argument_list|)
condition|)
block|{
name|changed
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
block|}
endif|#
directive|endif
comment|/* Detect a conditional jump jumping over an unconditional jump.  */
elseif|else
if|if
condition|(
operator|(
name|this_is_condjump
operator|||
name|this_is_condjump_in_parallel
operator|)
operator|&&
operator|!
name|this_is_simplejump
operator|&&
name|reallabelprev
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|reallabelprev
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|prev_active_insn
argument_list|(
name|reallabelprev
argument_list|)
operator|==
name|insn
operator|&&
name|no_labels_between_p
argument_list|(
name|insn
argument_list|,
name|reallabelprev
argument_list|)
operator|&&
name|simplejump_p
argument_list|(
name|reallabelprev
argument_list|)
condition|)
block|{
comment|/* When we invert the unconditional jump, we will be 		 decrementing the usage count of its old label. 		 Make sure that we don't delete it now because that 		 might cause the following code to be deleted.  */
name|rtx
name|prev_uses
init|=
name|prev_nonnote_insn
argument_list|(
name|reallabelprev
argument_list|)
decl_stmt|;
name|rtx
name|prev_label
init|=
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|prev_label
condition|)
operator|++
name|LABEL_NUSES
argument_list|(
name|prev_label
argument_list|)
expr_stmt|;
if|if
condition|(
name|invert_jump
argument_list|(
name|insn
argument_list|,
name|JUMP_LABEL
argument_list|(
name|reallabelprev
argument_list|)
argument_list|)
condition|)
block|{
comment|/* It is very likely that if there are USE insns before 		     this jump, they hold REG_DEAD notes.  These REG_DEAD 		     notes are no longer valid due to this optimization, 		     and will cause the life-analysis that following passes 		     (notably delayed-branch scheduling) to think that 		     these registers are dead when they are not.  		     To prevent this trouble, we just remove the USE insns 		     from the insn chain.  */
while|while
condition|(
name|prev_uses
operator|&&
name|GET_CODE
argument_list|(
name|prev_uses
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|prev_uses
argument_list|)
argument_list|)
operator|==
name|USE
condition|)
block|{
name|rtx
name|useless
init|=
name|prev_uses
decl_stmt|;
name|prev_uses
operator|=
name|prev_nonnote_insn
argument_list|(
name|prev_uses
argument_list|)
expr_stmt|;
name|delete_insn
argument_list|(
name|useless
argument_list|)
expr_stmt|;
block|}
name|delete_insn
argument_list|(
name|reallabelprev
argument_list|)
expr_stmt|;
name|next
operator|=
name|insn
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
block|}
comment|/* We can now safely delete the label if it is unreferenced 		 since the delete_insn above has deleted the BARRIER.  */
if|if
condition|(
name|prev_label
operator|&&
operator|--
name|LABEL_NUSES
argument_list|(
name|prev_label
argument_list|)
operator|==
literal|0
condition|)
name|delete_insn
argument_list|(
name|prev_label
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
block|{
comment|/* Detect a jump to a jump.  */
name|nlabel
operator|=
name|follow_jumps
argument_list|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nlabel
operator|!=
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
operator|&&
name|redirect_jump
argument_list|(
name|insn
argument_list|,
name|nlabel
argument_list|)
condition|)
block|{
name|changed
operator|=
literal|1
expr_stmt|;
name|next
operator|=
name|insn
expr_stmt|;
block|}
comment|/* Look for   if (foo) bar; else break;  */
comment|/* The insns look like this: 		 insn = condjump label1; 		 ...range1 (some insns)... 		 jump label2; 		 label1: 		 ...range2 (some insns)... 		 jump somewhere unconditionally 		 label2:  */
block|{
name|rtx
name|label1
init|=
name|next_label
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|range1end
init|=
name|label1
condition|?
name|prev_active_insn
argument_list|(
name|label1
argument_list|)
else|:
literal|0
decl_stmt|;
comment|/* Don't do this optimization on the first round, so that 		   jump-around-a-jump gets simplified before we ask here 		   whether a jump is unconditional.  		   Also don't do it when we are called after reload since 		   it will confuse reorg.  */
if|if
condition|(
operator|!
name|first
operator|&&
operator|(
name|reload_completed
condition|?
operator|!
name|flag_delayed_branch
else|:
literal|1
operator|)
comment|/* Make sure INSN is something we can invert.  */
operator|&&
name|condjump_p
argument_list|(
name|insn
argument_list|)
operator|&&
name|label1
operator|!=
literal|0
operator|&&
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
operator|==
name|label1
operator|&&
name|LABEL_NUSES
argument_list|(
name|label1
argument_list|)
operator|==
literal|1
operator|&&
name|GET_CODE
argument_list|(
name|range1end
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|simplejump_p
argument_list|(
name|range1end
argument_list|)
condition|)
block|{
name|rtx
name|label2
init|=
name|next_label
argument_list|(
name|label1
argument_list|)
decl_stmt|;
name|rtx
name|range2end
init|=
name|label2
condition|?
name|prev_active_insn
argument_list|(
name|label2
argument_list|)
else|:
literal|0
decl_stmt|;
if|if
condition|(
name|range1end
operator|!=
name|range2end
operator|&&
name|JUMP_LABEL
argument_list|(
name|range1end
argument_list|)
operator|==
name|label2
operator|&&
name|GET_CODE
argument_list|(
name|range2end
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|GET_CODE
argument_list|(
name|NEXT_INSN
argument_list|(
name|range2end
argument_list|)
argument_list|)
operator|==
name|BARRIER
comment|/* Invert the jump condition, so we 			   still execute the same insns in each case.  */
operator|&&
name|invert_jump
argument_list|(
name|insn
argument_list|,
name|label1
argument_list|)
condition|)
block|{
name|rtx
name|range1beg
init|=
name|next_active_insn
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|range2beg
init|=
name|next_active_insn
argument_list|(
name|label1
argument_list|)
decl_stmt|;
name|rtx
name|range1after
decl_stmt|,
name|range2after
decl_stmt|;
name|rtx
name|range1before
decl_stmt|,
name|range2before
decl_stmt|;
name|rtx
name|rangenext
decl_stmt|;
comment|/* Include in each range any notes before it, to be 			   sure that we get the line number note if any, even 			   if there are other notes here.  */
while|while
condition|(
name|PREV_INSN
argument_list|(
name|range1beg
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|PREV_INSN
argument_list|(
name|range1beg
argument_list|)
argument_list|)
operator|==
name|NOTE
condition|)
name|range1beg
operator|=
name|PREV_INSN
argument_list|(
name|range1beg
argument_list|)
expr_stmt|;
while|while
condition|(
name|PREV_INSN
argument_list|(
name|range2beg
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|PREV_INSN
argument_list|(
name|range2beg
argument_list|)
argument_list|)
operator|==
name|NOTE
condition|)
name|range2beg
operator|=
name|PREV_INSN
argument_list|(
name|range2beg
argument_list|)
expr_stmt|;
comment|/* Don't move NOTEs for blocks or loops; shift them 			   outside the ranges, where they'll stay put.  */
name|range1beg
operator|=
name|squeeze_notes
argument_list|(
name|range1beg
argument_list|,
name|range1end
argument_list|)
expr_stmt|;
name|range2beg
operator|=
name|squeeze_notes
argument_list|(
name|range2beg
argument_list|,
name|range2end
argument_list|)
expr_stmt|;
comment|/* Get current surrounds of the 2 ranges.  */
name|range1before
operator|=
name|PREV_INSN
argument_list|(
name|range1beg
argument_list|)
expr_stmt|;
name|range2before
operator|=
name|PREV_INSN
argument_list|(
name|range2beg
argument_list|)
expr_stmt|;
name|range1after
operator|=
name|NEXT_INSN
argument_list|(
name|range1end
argument_list|)
expr_stmt|;
name|range2after
operator|=
name|NEXT_INSN
argument_list|(
name|range2end
argument_list|)
expr_stmt|;
comment|/* Splice range2 where range1 was.  */
name|NEXT_INSN
argument_list|(
name|range1before
argument_list|)
operator|=
name|range2beg
expr_stmt|;
name|PREV_INSN
argument_list|(
name|range2beg
argument_list|)
operator|=
name|range1before
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|range2end
argument_list|)
operator|=
name|range1after
expr_stmt|;
name|PREV_INSN
argument_list|(
name|range1after
argument_list|)
operator|=
name|range2end
expr_stmt|;
comment|/* Splice range1 where range2 was.  */
name|NEXT_INSN
argument_list|(
name|range2before
argument_list|)
operator|=
name|range1beg
expr_stmt|;
name|PREV_INSN
argument_list|(
name|range1beg
argument_list|)
operator|=
name|range2before
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|range1end
argument_list|)
operator|=
name|range2after
expr_stmt|;
name|PREV_INSN
argument_list|(
name|range2after
argument_list|)
operator|=
name|range1end
expr_stmt|;
comment|/* Check for a loop end note between the end of 			   range2, and the next code label.  If there is one, 			   then what we have really seen is 			   if (foo) break; end_of_loop; 			   and moved the break sequence outside the loop. 			   We must move the LOOP_END note to where the 			   loop really ends now, or we will confuse loop 			   optimization.  Stop if we find a LOOP_BEG note 			   first, since we don't want to move the LOOP_END 			   note in that case.  */
for|for
control|(
init|;
name|range2after
operator|!=
name|label2
condition|;
name|range2after
operator|=
name|rangenext
control|)
block|{
name|rangenext
operator|=
name|NEXT_INSN
argument_list|(
name|range2after
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|range2after
argument_list|)
operator|==
name|NOTE
condition|)
block|{
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|range2after
argument_list|)
operator|==
name|NOTE_INSN_LOOP_END
condition|)
block|{
name|NEXT_INSN
argument_list|(
name|PREV_INSN
argument_list|(
name|range2after
argument_list|)
argument_list|)
operator|=
name|rangenext
expr_stmt|;
name|PREV_INSN
argument_list|(
name|rangenext
argument_list|)
operator|=
name|PREV_INSN
argument_list|(
name|range2after
argument_list|)
expr_stmt|;
name|PREV_INSN
argument_list|(
name|range2after
argument_list|)
operator|=
name|PREV_INSN
argument_list|(
name|range1beg
argument_list|)
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|range2after
argument_list|)
operator|=
name|range1beg
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|PREV_INSN
argument_list|(
name|range1beg
argument_list|)
argument_list|)
operator|=
name|range2after
expr_stmt|;
name|PREV_INSN
argument_list|(
name|range1beg
argument_list|)
operator|=
name|range2after
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|range2after
argument_list|)
operator|==
name|NOTE_INSN_LOOP_BEG
condition|)
break|break;
block|}
block|}
name|changed
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
block|}
block|}
comment|/* Now that the jump has been tensioned, 		 try cross jumping: check for identical code 		 before the jump and before its target label.  */
comment|/* First, cross jumping of conditional jumps:  */
if|if
condition|(
name|cross_jump
operator|&&
name|condjump_p
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|rtx
name|newjpos
decl_stmt|,
name|newlpos
decl_stmt|;
name|rtx
name|x
init|=
name|prev_real_insn
argument_list|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
argument_list|)
decl_stmt|;
comment|/* A conditional jump may be crossjumped 		     only if the place it jumps to follows 		     an opposing jump that comes back here.  */
if|if
condition|(
name|x
operator|!=
literal|0
operator|&&
operator|!
name|jump_back_p
argument_list|(
name|x
argument_list|,
name|insn
argument_list|)
condition|)
comment|/* We have no opposing jump; 		       cannot cross jump this insn.  */
name|x
operator|=
literal|0
expr_stmt|;
name|newjpos
operator|=
literal|0
expr_stmt|;
comment|/* TARGET is nonzero if it is ok to cross jump 		     to code before TARGET.  If so, see if matches.  */
if|if
condition|(
name|x
operator|!=
literal|0
condition|)
name|find_cross_jump
argument_list|(
name|insn
argument_list|,
name|x
argument_list|,
literal|2
argument_list|,
operator|&
name|newjpos
argument_list|,
operator|&
name|newlpos
argument_list|)
expr_stmt|;
if|if
condition|(
name|newjpos
operator|!=
literal|0
condition|)
block|{
name|do_cross_jump
argument_list|(
name|insn
argument_list|,
name|newjpos
argument_list|,
name|newlpos
argument_list|)
expr_stmt|;
comment|/* Make the old conditional jump 			 into an unconditional one.  */
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|=
name|gen_rtx_LABEL_REF
argument_list|(
name|VOIDmode
argument_list|,
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
name|emit_barrier_after
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Add to jump_chain unless this is a new label 			 whose UID is too large.  */
if|if
condition|(
name|INSN_UID
argument_list|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|<
name|max_jump_chain
condition|)
block|{
name|jump_chain
index|[
name|INSN_UID
argument_list|(
name|insn
argument_list|)
index|]
operator|=
name|jump_chain
index|[
name|INSN_UID
argument_list|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
argument_list|)
index|]
expr_stmt|;
name|jump_chain
index|[
name|INSN_UID
argument_list|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
argument_list|)
index|]
operator|=
name|insn
expr_stmt|;
block|}
name|changed
operator|=
literal|1
expr_stmt|;
name|next
operator|=
name|insn
expr_stmt|;
block|}
block|}
comment|/* Cross jumping of unconditional jumps: 		 a few differences.  */
if|if
condition|(
name|cross_jump
operator|&&
name|simplejump_p
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|rtx
name|newjpos
decl_stmt|,
name|newlpos
decl_stmt|;
name|rtx
name|target
decl_stmt|;
name|newjpos
operator|=
literal|0
expr_stmt|;
comment|/* TARGET is nonzero if it is ok to cross jump 		     to code before TARGET.  If so, see if matches.  */
name|find_cross_jump
argument_list|(
name|insn
argument_list|,
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|newjpos
argument_list|,
operator|&
name|newlpos
argument_list|)
expr_stmt|;
comment|/* If cannot cross jump to code before the label, 		     see if we can cross jump to another jump to 		     the same label.  */
comment|/* Try each other jump to this label.  */
if|if
condition|(
name|INSN_UID
argument_list|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|<
name|max_uid
condition|)
for|for
control|(
name|target
operator|=
name|jump_chain
index|[
name|INSN_UID
argument_list|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
argument_list|)
index|]
init|;
name|target
operator|!=
literal|0
operator|&&
name|newjpos
operator|==
literal|0
condition|;
name|target
operator|=
name|jump_chain
index|[
name|INSN_UID
argument_list|(
name|target
argument_list|)
index|]
control|)
if|if
condition|(
name|target
operator|!=
name|insn
operator|&&
name|JUMP_LABEL
argument_list|(
name|target
argument_list|)
operator|==
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
comment|/* Ignore TARGET if it's deleted.  */
operator|&&
operator|!
name|INSN_DELETED_P
argument_list|(
name|target
argument_list|)
condition|)
name|find_cross_jump
argument_list|(
name|insn
argument_list|,
name|target
argument_list|,
literal|2
argument_list|,
operator|&
name|newjpos
argument_list|,
operator|&
name|newlpos
argument_list|)
expr_stmt|;
if|if
condition|(
name|newjpos
operator|!=
literal|0
condition|)
block|{
name|do_cross_jump
argument_list|(
name|insn
argument_list|,
name|newjpos
argument_list|,
name|newlpos
argument_list|)
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
name|next
operator|=
name|insn
expr_stmt|;
block|}
block|}
comment|/* This code was dead in the previous jump.c!  */
if|if
condition|(
name|cross_jump
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|RETURN
condition|)
block|{
comment|/* Return insns all "jump to the same place" 		     so we can cross-jump between any two of them.  */
name|rtx
name|newjpos
decl_stmt|,
name|newlpos
decl_stmt|,
name|target
decl_stmt|;
name|newjpos
operator|=
literal|0
expr_stmt|;
comment|/* If cannot cross jump to code before the label, 		     see if we can cross jump to another jump to 		     the same label.  */
comment|/* Try each other jump to this label.  */
for|for
control|(
name|target
operator|=
name|jump_chain
index|[
literal|0
index|]
init|;
name|target
operator|!=
literal|0
operator|&&
name|newjpos
operator|==
literal|0
condition|;
name|target
operator|=
name|jump_chain
index|[
name|INSN_UID
argument_list|(
name|target
argument_list|)
index|]
control|)
if|if
condition|(
name|target
operator|!=
name|insn
operator|&&
operator|!
name|INSN_DELETED_P
argument_list|(
name|target
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|target
argument_list|)
argument_list|)
operator|==
name|RETURN
condition|)
name|find_cross_jump
argument_list|(
name|insn
argument_list|,
name|target
argument_list|,
literal|2
argument_list|,
operator|&
name|newjpos
argument_list|,
operator|&
name|newlpos
argument_list|)
expr_stmt|;
if|if
condition|(
name|newjpos
operator|!=
literal|0
condition|)
block|{
name|do_cross_jump
argument_list|(
name|insn
argument_list|,
name|newjpos
argument_list|,
name|newlpos
argument_list|)
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
name|next
operator|=
name|insn
expr_stmt|;
block|}
block|}
block|}
block|}
name|first
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Delete extraneous line number notes.      Note that two consecutive notes for different lines are not really      extraneous.  There should be some indication where that line belonged,      even if it became empty.  */
block|{
name|rtx
name|last_note
init|=
literal|0
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|f
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|>=
literal|0
condition|)
block|{
comment|/* Delete this note if it is identical to previous note.  */
if|if
condition|(
name|last_note
operator|&&
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_SOURCE_FILE
argument_list|(
name|last_note
argument_list|)
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_LINE_NUMBER
argument_list|(
name|last_note
argument_list|)
condition|)
block|{
name|delete_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|last_note
operator|=
name|insn
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|HAVE_return
if|if
condition|(
name|HAVE_return
condition|)
block|{
comment|/* If we fall through to the epilogue, see if we can insert a RETURN insn 	 in front of it.  If the machine allows it at this point (we might be 	 after reload for a leaf routine), it will improve optimization for it 	 to be there.  We do this both here and at the start of this pass since 	 the RETURN might have been deleted by some of our optimizations.  */
name|insn
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
while|while
condition|(
name|insn
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|BARRIER
condition|)
block|{
name|emit_jump_insn
argument_list|(
name|gen_return
argument_list|()
argument_list|)
expr_stmt|;
name|emit_barrier
argument_list|()
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* See if there is still a NOTE_INSN_FUNCTION_END in this function.      If so, delete it, and record that this function can drop off the end.  */
name|insn
operator|=
name|last_insn
expr_stmt|;
block|{
name|int
name|n_labels
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|insn
comment|/* One label can follow the end-note: the return label.  */
operator|&&
operator|(
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
operator|&&
name|n_labels
operator|--
operator|>
literal|0
operator|)
comment|/* Ordinary insns can follow it if returning a structure.  */
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
comment|/* If machine uses explicit RETURN insns, no epilogue, 		  then one of them follows the note.  */
operator|||
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|RETURN
operator|)
comment|/* A barrier can follow the return insn.  */
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|BARRIER
comment|/* Other kinds of notes can follow also.  */
operator|||
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE_INSN_FUNCTION_END
operator|)
operator|)
condition|)
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
comment|/* Report if control can fall through at the end of the function.  */
if|if
condition|(
name|insn
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_FUNCTION_END
condition|)
block|{
name|can_reach_end
operator|=
literal|1
expr_stmt|;
name|delete_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
comment|/* Show JUMP_CHAIN no longer valid.  */
name|jump_chain
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* LOOP_START is a NOTE_INSN_LOOP_BEG note that is followed by an unconditional    jump.  Assume that this unconditional jump is to the exit test code.  If    the code is sufficiently simple, make a copy of it before INSN,    followed by a jump to the exit of the loop.  Then delete the unconditional    jump after INSN.     Return 1 if we made the change, else 0.     This is only safe immediately after a regscan pass because it uses the    values of regno_first_uid and regno_last_uid.  */
end_comment

begin_function
specifier|static
name|int
name|duplicate_loop_exit_test
parameter_list|(
name|loop_start
parameter_list|)
name|rtx
name|loop_start
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|,
name|set
decl_stmt|,
name|reg
decl_stmt|,
name|p
decl_stmt|,
name|link
decl_stmt|;
name|rtx
name|copy
init|=
literal|0
decl_stmt|;
name|int
name|num_insns
init|=
literal|0
decl_stmt|;
name|rtx
name|exitcode
init|=
name|NEXT_INSN
argument_list|(
name|JUMP_LABEL
argument_list|(
name|next_nonnote_insn
argument_list|(
name|loop_start
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|lastexit
decl_stmt|;
name|int
name|max_reg
init|=
name|max_reg_num
argument_list|()
decl_stmt|;
name|rtx
modifier|*
name|reg_map
init|=
literal|0
decl_stmt|;
comment|/* Scan the exit code.  We do not perform this optimization if any insn:           is a CALL_INSN 	 is a CODE_LABEL 	 has a REG_RETVAL or REG_LIBCALL note (hard to adjust) 	 is a NOTE_INSN_LOOP_BEG because this means we have a nested loop 	 is a NOTE_INSN_BLOCK_{BEG,END} because duplicating these notes 	      are not valid 	           We also do not do this if we find an insn with ASM_OPERANDS.  While      this restriction should not be necessary, copying an insn with      ASM_OPERANDS can confuse asm_noperands in some cases.       Also, don't do this if the exit code is more than 20 insns.  */
for|for
control|(
name|insn
operator|=
name|exitcode
init|;
name|insn
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_LOOP_END
operator|)
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
condition|)
block|{
case|case
name|CODE_LABEL
case|:
case|case
name|CALL_INSN
case|:
return|return
literal|0
return|;
case|case
name|NOTE
case|:
comment|/* We could be in front of the wrong NOTE_INSN_LOOP_END if there is 	     a jump immediately after the loop start that branches outside 	     the loop but within an outer loop, near the exit test. 	     If we copied this exit test and created a phony 	     NOTE_INSN_LOOP_VTOP, this could make instructions immediately 	     before the exit test look like these could be safely moved 	     out of the loop even if they actually may be never executed. 	     This can be avoided by checking here for NOTE_INSN_LOOP_CONT.  */
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_LOOP_BEG
operator|||
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_LOOP_CONT
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|optimize
operator|<
literal|2
operator|&&
operator|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_BLOCK_BEG
operator|||
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_BLOCK_END
operator|)
condition|)
comment|/* If we were to duplicate this code, we would not move 	       the BLOCK notes, and so debugging the moved code would 	       be difficult.  Thus, we only move the code with -O2 or 	       higher.  */
return|return
literal|0
return|;
break|break;
case|case
name|JUMP_INSN
case|:
case|case
name|INSN
case|:
if|if
condition|(
operator|++
name|num_insns
operator|>
literal|20
operator|||
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_RETVAL
argument_list|,
name|NULL_RTX
argument_list|)
operator|||
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_LIBCALL
argument_list|,
name|NULL_RTX
argument_list|)
operator|||
name|asm_noperands
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|>
literal|0
condition|)
return|return
literal|0
return|;
break|break;
default|default:
break|break;
block|}
block|}
comment|/* Unless INSN is zero, we can do the optimization.  */
if|if
condition|(
name|insn
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|lastexit
operator|=
name|insn
expr_stmt|;
comment|/* See if any insn sets a register only used in the loop exit code and      not a user variable.  If so, replace it with a new register.  */
for|for
control|(
name|insn
operator|=
name|exitcode
init|;
name|insn
operator|!=
name|lastexit
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
operator|(
name|set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|reg
operator|=
name|SET_DEST
argument_list|(
name|set
argument_list|)
operator|,
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|REG
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SUBREG
operator|&&
operator|(
name|reg
operator|=
name|SUBREG_REG
argument_list|(
name|reg
argument_list|)
operator|,
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|REG
operator|)
operator|)
operator|)
operator|&&
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|REGNO_FIRST_UID
argument_list|(
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|)
operator|==
name|INSN_UID
argument_list|(
name|insn
argument_list|)
condition|)
block|{
for|for
control|(
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
init|;
name|p
operator|!=
name|lastexit
condition|;
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
control|)
if|if
condition|(
name|REGNO_LAST_UID
argument_list|(
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|)
operator|==
name|INSN_UID
argument_list|(
name|p
argument_list|)
condition|)
break|break;
if|if
condition|(
name|p
operator|!=
name|lastexit
condition|)
block|{
comment|/* We can do the replacement.  Allocate reg_map if this is the 	       first replacement we found.  */
if|if
condition|(
name|reg_map
operator|==
literal|0
condition|)
block|{
name|reg_map
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|max_reg
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|reg_map
argument_list|,
name|max_reg
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|REG_LOOP_TEST_P
argument_list|(
name|reg
argument_list|)
operator|=
literal|1
expr_stmt|;
name|reg_map
index|[
name|REGNO
argument_list|(
name|reg
argument_list|)
index|]
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Now copy each insn.  */
for|for
control|(
name|insn
operator|=
name|exitcode
init|;
name|insn
operator|!=
name|lastexit
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
condition|)
block|{
case|case
name|BARRIER
case|:
name|copy
operator|=
name|emit_barrier_before
argument_list|(
name|loop_start
argument_list|)
expr_stmt|;
break|break;
case|case
name|NOTE
case|:
comment|/* Only copy line-number notes.  */
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|copy
operator|=
name|emit_note_before
argument_list|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
argument_list|,
name|loop_start
argument_list|)
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|copy
argument_list|)
operator|=
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|INSN
case|:
name|copy
operator|=
name|emit_insn_before
argument_list|(
name|copy_rtx
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|,
name|loop_start
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_map
condition|)
name|replace_regs
argument_list|(
name|PATTERN
argument_list|(
name|copy
argument_list|)
argument_list|,
name|reg_map
argument_list|,
name|max_reg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|mark_jump_label
argument_list|(
name|PATTERN
argument_list|(
name|copy
argument_list|)
argument_list|,
name|copy
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Copy all REG_NOTES except REG_LABEL since mark_jump_label will 	   make them.  */
for|for
control|(
name|link
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|!=
name|REG_LABEL
condition|)
name|REG_NOTES
argument_list|(
name|copy
argument_list|)
operator|=
name|copy_rtx
argument_list|(
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|copy
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_map
operator|&&
name|REG_NOTES
argument_list|(
name|copy
argument_list|)
condition|)
name|replace_regs
argument_list|(
name|REG_NOTES
argument_list|(
name|copy
argument_list|)
argument_list|,
name|reg_map
argument_list|,
name|max_reg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|JUMP_INSN
case|:
name|copy
operator|=
name|emit_jump_insn_before
argument_list|(
name|copy_rtx
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|,
name|loop_start
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_map
condition|)
name|replace_regs
argument_list|(
name|PATTERN
argument_list|(
name|copy
argument_list|)
argument_list|,
name|reg_map
argument_list|,
name|max_reg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|mark_jump_label
argument_list|(
name|PATTERN
argument_list|(
name|copy
argument_list|)
argument_list|,
name|copy
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|REG_NOTES
argument_list|(
name|copy
argument_list|)
operator|=
name|copy_rtx
argument_list|(
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_map
condition|)
name|replace_regs
argument_list|(
name|REG_NOTES
argument_list|(
name|copy
argument_list|)
argument_list|,
name|reg_map
argument_list|,
name|max_reg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* If this is a simple jump, add it to the jump chain.  */
if|if
condition|(
name|INSN_UID
argument_list|(
name|copy
argument_list|)
operator|<
name|max_jump_chain
operator|&&
name|JUMP_LABEL
argument_list|(
name|copy
argument_list|)
operator|&&
name|simplejump_p
argument_list|(
name|copy
argument_list|)
condition|)
block|{
name|jump_chain
index|[
name|INSN_UID
argument_list|(
name|copy
argument_list|)
index|]
operator|=
name|jump_chain
index|[
name|INSN_UID
argument_list|(
name|JUMP_LABEL
argument_list|(
name|copy
argument_list|)
argument_list|)
index|]
expr_stmt|;
name|jump_chain
index|[
name|INSN_UID
argument_list|(
name|JUMP_LABEL
argument_list|(
name|copy
argument_list|)
argument_list|)
index|]
operator|=
name|copy
expr_stmt|;
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Now clean up by emitting a jump to the end label and deleting the jump      at the start of the loop.  */
if|if
condition|(
operator|!
name|copy
operator|||
name|GET_CODE
argument_list|(
name|copy
argument_list|)
operator|!=
name|BARRIER
condition|)
block|{
name|copy
operator|=
name|emit_jump_insn_before
argument_list|(
name|gen_jump
argument_list|(
name|get_label_after
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|,
name|loop_start
argument_list|)
expr_stmt|;
name|mark_jump_label
argument_list|(
name|PATTERN
argument_list|(
name|copy
argument_list|)
argument_list|,
name|copy
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|INSN_UID
argument_list|(
name|copy
argument_list|)
operator|<
name|max_jump_chain
operator|&&
name|INSN_UID
argument_list|(
name|JUMP_LABEL
argument_list|(
name|copy
argument_list|)
argument_list|)
operator|<
name|max_jump_chain
condition|)
block|{
name|jump_chain
index|[
name|INSN_UID
argument_list|(
name|copy
argument_list|)
index|]
operator|=
name|jump_chain
index|[
name|INSN_UID
argument_list|(
name|JUMP_LABEL
argument_list|(
name|copy
argument_list|)
argument_list|)
index|]
expr_stmt|;
name|jump_chain
index|[
name|INSN_UID
argument_list|(
name|JUMP_LABEL
argument_list|(
name|copy
argument_list|)
argument_list|)
index|]
operator|=
name|copy
expr_stmt|;
block|}
name|emit_barrier_before
argument_list|(
name|loop_start
argument_list|)
expr_stmt|;
block|}
comment|/* Mark the exit code as the virtual top of the converted loop.  */
name|emit_note_before
argument_list|(
name|NOTE_INSN_LOOP_VTOP
argument_list|,
name|exitcode
argument_list|)
expr_stmt|;
name|delete_insn
argument_list|(
name|next_nonnote_insn
argument_list|(
name|loop_start
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Move all block-beg, block-end, loop-beg, loop-cont, loop-vtop, and    loop-end notes between START and END out before START.  Assume that    END is not such a note.  START may be such a note.  Returns the value    of the new starting insn, which may be different if the original start    was such a note.  */
end_comment

begin_function
name|rtx
name|squeeze_notes
parameter_list|(
name|start
parameter_list|,
name|end
parameter_list|)
name|rtx
name|start
decl_stmt|,
name|end
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|;
name|rtx
name|next
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|start
init|;
name|insn
operator|!=
name|end
condition|;
name|insn
operator|=
name|next
control|)
block|{
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
operator|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_BLOCK_END
operator|||
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_BLOCK_BEG
operator|||
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_LOOP_BEG
operator|||
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_LOOP_END
operator|||
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_LOOP_CONT
operator|||
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_LOOP_VTOP
operator|)
condition|)
block|{
if|if
condition|(
name|insn
operator|==
name|start
condition|)
name|start
operator|=
name|next
expr_stmt|;
else|else
block|{
name|rtx
name|prev
init|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
operator|=
name|PREV_INSN
argument_list|(
name|start
argument_list|)
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
operator|=
name|start
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|=
name|insn
expr_stmt|;
name|PREV_INSN
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|=
name|insn
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|prev
argument_list|)
operator|=
name|next
expr_stmt|;
name|PREV_INSN
argument_list|(
name|next
argument_list|)
operator|=
name|prev
expr_stmt|;
block|}
block|}
block|}
return|return
name|start
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Compare the instructions before insn E1 with those before E2    to find an opportunity for cross jumping.    (This means detecting identical sequences of insns followed by    jumps to the same place, or followed by a label and a jump    to that label, and replacing one with a jump to the other.)     Assume E1 is a jump that jumps to label E2    (that is not always true but it might as well be).    Find the longest possible equivalent sequences    and store the first insns of those sequences into *F1 and *F2.    Store zero there if no equivalent preceding instructions are found.     We give up if we find a label in stream 1.    Actually we could transfer that label into stream 2.  */
end_comment

begin_function
specifier|static
name|void
name|find_cross_jump
parameter_list|(
name|e1
parameter_list|,
name|e2
parameter_list|,
name|minimum
parameter_list|,
name|f1
parameter_list|,
name|f2
parameter_list|)
name|rtx
name|e1
decl_stmt|,
name|e2
decl_stmt|;
name|int
name|minimum
decl_stmt|;
name|rtx
modifier|*
name|f1
decl_stmt|,
decl|*
name|f2
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|rtx
name|i1
init|=
name|e1
decl_stmt|,
name|i2
init|=
name|e2
decl_stmt|;
specifier|register
name|rtx
name|p1
decl_stmt|,
name|p2
decl_stmt|;
name|int
name|lose
init|=
literal|0
decl_stmt|;
name|rtx
name|last1
init|=
literal|0
decl_stmt|,
name|last2
init|=
literal|0
decl_stmt|;
name|rtx
name|afterlast1
init|=
literal|0
decl_stmt|,
name|afterlast2
init|=
literal|0
decl_stmt|;
operator|*
name|f1
operator|=
literal|0
expr_stmt|;
operator|*
name|f2
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|i1
operator|=
name|prev_nonnote_insn
argument_list|(
name|i1
argument_list|)
expr_stmt|;
name|i2
operator|=
name|PREV_INSN
argument_list|(
name|i2
argument_list|)
expr_stmt|;
while|while
condition|(
name|i2
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|i2
argument_list|)
operator|==
name|NOTE
operator|||
name|GET_CODE
argument_list|(
name|i2
argument_list|)
operator|==
name|CODE_LABEL
operator|)
condition|)
name|i2
operator|=
name|PREV_INSN
argument_list|(
name|i2
argument_list|)
expr_stmt|;
if|if
condition|(
name|i1
operator|==
literal|0
condition|)
break|break;
comment|/* Don't allow the range of insns preceding E1 or E2 	 to include the other (E2 or E1).  */
if|if
condition|(
name|i2
operator|==
name|e1
operator|||
name|i1
operator|==
name|e2
condition|)
break|break;
comment|/* If we will get to this code by jumping, those jumps will be 	 tensioned to go directly to the new label (before I2), 	 so this cross-jumping won't cost extra.  So reduce the minimum.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|i1
argument_list|)
operator|==
name|CODE_LABEL
condition|)
block|{
operator|--
name|minimum
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|i2
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|i1
argument_list|)
operator|!=
name|GET_CODE
argument_list|(
name|i2
argument_list|)
condition|)
break|break;
comment|/* Avoid moving insns across EH regions.   	 ??? This is only necessary if i1 or i2 can throw an exception.  */
if|if
condition|(
name|flag_exceptions
operator|&&
operator|!
name|in_same_eh_region
argument_list|(
name|i1
argument_list|,
name|i2
argument_list|)
condition|)
break|break;
name|p1
operator|=
name|PATTERN
argument_list|(
name|i1
argument_list|)
expr_stmt|;
name|p2
operator|=
name|PATTERN
argument_list|(
name|i2
argument_list|)
expr_stmt|;
comment|/* If this is a CALL_INSN, compare register usage information. 	 If we don't check this on stack register machines, the two 	 CALL_INSNs might be merged leaving reg-stack.c with mismatching 	 numbers of stack registers in the same basic block. 	 If we don't check this on machines with delay slots, a delay slot may 	 be filled that clobbers a parameter expected by the subroutine.  	 ??? We take the simple route for now and assume that if they're 	 equal, they were constructed identically.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|i1
argument_list|)
operator|==
name|CALL_INSN
operator|&&
operator|!
name|rtx_equal_p
argument_list|(
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|i1
argument_list|)
argument_list|,
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|i2
argument_list|)
argument_list|)
condition|)
name|lose
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|STACK_REGS
comment|/* If cross_jump_death_matters is not 0, the insn's mode 	 indicates whether or not the insn contains any stack-like 	 regs.  */
if|if
condition|(
operator|!
name|lose
operator|&&
name|cross_jump_death_matters
operator|&&
name|GET_MODE
argument_list|(
name|i1
argument_list|)
operator|==
name|QImode
condition|)
block|{
comment|/* If register stack conversion has already been done, then 	     death notes must also be compared before it is certain that 	     the two instruction streams match.  */
name|rtx
name|note
decl_stmt|;
name|HARD_REG_SET
name|i1_regset
decl_stmt|,
name|i2_regset
decl_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|i1_regset
argument_list|)
expr_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|i2_regset
argument_list|)
expr_stmt|;
for|for
control|(
name|note
operator|=
name|REG_NOTES
argument_list|(
name|i1
argument_list|)
init|;
name|note
condition|;
name|note
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
operator|==
name|REG_DEAD
operator|&&
name|STACK_REG_P
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|SET_HARD_REG_BIT
argument_list|(
name|i1_regset
argument_list|,
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|note
operator|=
name|REG_NOTES
argument_list|(
name|i2
argument_list|)
init|;
name|note
condition|;
name|note
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
operator|==
name|REG_DEAD
operator|&&
name|STACK_REG_P
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|SET_HARD_REG_BIT
argument_list|(
name|i2_regset
argument_list|,
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|GO_IF_HARD_REG_EQUAL
argument_list|(
name|i1_regset
argument_list|,
name|i2_regset
argument_list|,
name|done
argument_list|)
expr_stmt|;
name|lose
operator|=
literal|1
expr_stmt|;
name|done
label|:
empty_stmt|;
block|}
endif|#
directive|endif
comment|/* Don't allow old-style asm or volatile extended asms to be accepted 	 for cross jumping purposes.  It is conceptually correct to allow 	 them, since cross-jumping preserves the dynamic instruction order 	 even though it is changing the static instruction order.  However, 	 if an asm is being used to emit an assembler pseudo-op, such as 	 the MIPS `.set reorder' pseudo-op, then the static instruction order 	 matters and it must be preserved.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|p1
argument_list|)
operator|==
name|ASM_INPUT
operator|||
name|GET_CODE
argument_list|(
name|p2
argument_list|)
operator|==
name|ASM_INPUT
operator|||
operator|(
name|GET_CODE
argument_list|(
name|p1
argument_list|)
operator|==
name|ASM_OPERANDS
operator|&&
name|MEM_VOLATILE_P
argument_list|(
name|p1
argument_list|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|p2
argument_list|)
operator|==
name|ASM_OPERANDS
operator|&&
name|MEM_VOLATILE_P
argument_list|(
name|p2
argument_list|)
operator|)
condition|)
name|lose
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|lose
operator|||
name|GET_CODE
argument_list|(
name|p1
argument_list|)
operator|!=
name|GET_CODE
argument_list|(
name|p2
argument_list|)
operator|||
operator|!
name|rtx_renumbered_equal_p
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
condition|)
block|{
comment|/* The following code helps take care of G++ cleanups.  */
name|rtx
name|equiv1
decl_stmt|;
name|rtx
name|equiv2
decl_stmt|;
if|if
condition|(
operator|!
name|lose
operator|&&
name|GET_CODE
argument_list|(
name|p1
argument_list|)
operator|==
name|GET_CODE
argument_list|(
name|p2
argument_list|)
operator|&&
operator|(
operator|(
name|equiv1
operator|=
name|find_reg_note
argument_list|(
name|i1
argument_list|,
name|REG_EQUAL
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|equiv1
operator|=
name|find_reg_note
argument_list|(
name|i1
argument_list|,
name|REG_EQUIV
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|(
name|equiv2
operator|=
name|find_reg_note
argument_list|(
name|i2
argument_list|,
name|REG_EQUAL
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|equiv2
operator|=
name|find_reg_note
argument_list|(
name|i2
argument_list|,
name|REG_EQUIV
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
operator|!=
literal|0
operator|)
comment|/* If the equivalences are not to a constant, they may 		 reference pseudos that no longer exist, so we can't 		 use them.  */
operator|&&
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|equiv1
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|equiv1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|equiv2
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|s1
init|=
name|single_set
argument_list|(
name|i1
argument_list|)
decl_stmt|;
name|rtx
name|s2
init|=
name|single_set
argument_list|(
name|i2
argument_list|)
decl_stmt|;
if|if
condition|(
name|s1
operator|!=
literal|0
operator|&&
name|s2
operator|!=
literal|0
operator|&&
name|rtx_renumbered_equal_p
argument_list|(
name|SET_DEST
argument_list|(
name|s1
argument_list|)
argument_list|,
name|SET_DEST
argument_list|(
name|s2
argument_list|)
argument_list|)
condition|)
block|{
name|validate_change
argument_list|(
name|i1
argument_list|,
operator|&
name|SET_SRC
argument_list|(
name|s1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|equiv1
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|validate_change
argument_list|(
name|i2
argument_list|,
operator|&
name|SET_SRC
argument_list|(
name|s2
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|equiv2
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rtx_renumbered_equal_p
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
condition|)
name|cancel_changes
argument_list|(
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|apply_change_group
argument_list|()
condition|)
goto|goto
name|win
goto|;
block|}
block|}
comment|/* Insns fail to match; cross jumping is limited to the following 	     insns.  */
ifdef|#
directive|ifdef
name|HAVE_cc0
comment|/* Don't allow the insn after a compare to be shared by 	     cross-jumping unless the compare is also shared. 	     Here, if either of these non-matching insns is a compare, 	     exclude the following insn from possible cross-jumping.  */
if|if
condition|(
name|sets_cc0_p
argument_list|(
name|p1
argument_list|)
operator|||
name|sets_cc0_p
argument_list|(
name|p2
argument_list|)
condition|)
name|last1
operator|=
name|afterlast1
operator|,
name|last2
operator|=
name|afterlast2
operator|,
operator|++
name|minimum
expr_stmt|;
endif|#
directive|endif
comment|/* If cross-jumping here will feed a jump-around-jump 	     optimization, this jump won't cost extra, so reduce 	     the minimum.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|i1
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|JUMP_LABEL
argument_list|(
name|i1
argument_list|)
operator|&&
name|prev_real_insn
argument_list|(
name|JUMP_LABEL
argument_list|(
name|i1
argument_list|)
argument_list|)
operator|==
name|e1
condition|)
operator|--
name|minimum
expr_stmt|;
break|break;
block|}
name|win
label|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|p1
argument_list|)
operator|!=
name|USE
operator|&&
name|GET_CODE
argument_list|(
name|p1
argument_list|)
operator|!=
name|CLOBBER
condition|)
block|{
comment|/* Ok, this insn is potentially includable in a cross-jump here.  */
name|afterlast1
operator|=
name|last1
operator|,
name|afterlast2
operator|=
name|last2
expr_stmt|;
name|last1
operator|=
name|i1
operator|,
name|last2
operator|=
name|i2
operator|,
operator|--
name|minimum
expr_stmt|;
block|}
block|}
if|if
condition|(
name|minimum
operator|<=
literal|0
operator|&&
name|last1
operator|!=
literal|0
operator|&&
name|last1
operator|!=
name|e1
condition|)
operator|*
name|f1
operator|=
name|last1
operator|,
operator|*
name|f2
operator|=
name|last2
expr_stmt|;
block|}
end_block

begin_function
specifier|static
name|void
name|do_cross_jump
parameter_list|(
name|insn
parameter_list|,
name|newjpos
parameter_list|,
name|newlpos
parameter_list|)
name|rtx
name|insn
decl_stmt|,
name|newjpos
decl_stmt|,
name|newlpos
decl_stmt|;
block|{
comment|/* Find an existing label at this point      or make a new one if there is none.  */
specifier|register
name|rtx
name|label
init|=
name|get_label_before
argument_list|(
name|newlpos
argument_list|)
decl_stmt|;
comment|/* Make the same jump insn jump to the new point.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|RETURN
condition|)
block|{
comment|/* Remove from jump chain of returns.  */
name|delete_from_jump_chain
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Change the insn.  */
name|PATTERN
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_jump
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
operator|=
name|label
expr_stmt|;
name|LABEL_NUSES
argument_list|(
name|label
argument_list|)
operator|++
expr_stmt|;
comment|/* Add to new the jump chain.  */
if|if
condition|(
name|INSN_UID
argument_list|(
name|label
argument_list|)
operator|<
name|max_jump_chain
operator|&&
name|INSN_UID
argument_list|(
name|insn
argument_list|)
operator|<
name|max_jump_chain
condition|)
block|{
name|jump_chain
index|[
name|INSN_UID
argument_list|(
name|insn
argument_list|)
index|]
operator|=
name|jump_chain
index|[
name|INSN_UID
argument_list|(
name|label
argument_list|)
index|]
expr_stmt|;
name|jump_chain
index|[
name|INSN_UID
argument_list|(
name|label
argument_list|)
index|]
operator|=
name|insn
expr_stmt|;
block|}
block|}
else|else
name|redirect_jump
argument_list|(
name|insn
argument_list|,
name|label
argument_list|)
expr_stmt|;
comment|/* Delete the matching insns before the jump.  Also, remove any REG_EQUAL      or REG_EQUIV note in the NEWLPOS stream that isn't also present in      the NEWJPOS stream.  */
while|while
condition|(
name|newjpos
operator|!=
name|insn
condition|)
block|{
name|rtx
name|lnote
decl_stmt|;
for|for
control|(
name|lnote
operator|=
name|REG_NOTES
argument_list|(
name|newlpos
argument_list|)
init|;
name|lnote
condition|;
name|lnote
operator|=
name|XEXP
argument_list|(
name|lnote
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
operator|(
name|REG_NOTE_KIND
argument_list|(
name|lnote
argument_list|)
operator|==
name|REG_EQUAL
operator|||
name|REG_NOTE_KIND
argument_list|(
name|lnote
argument_list|)
operator|==
name|REG_EQUIV
operator|)
operator|&&
operator|!
name|find_reg_note
argument_list|(
name|newjpos
argument_list|,
name|REG_EQUAL
argument_list|,
name|XEXP
argument_list|(
name|lnote
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
operator|!
name|find_reg_note
argument_list|(
name|newjpos
argument_list|,
name|REG_EQUIV
argument_list|,
name|XEXP
argument_list|(
name|lnote
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|remove_note
argument_list|(
name|newlpos
argument_list|,
name|lnote
argument_list|)
expr_stmt|;
name|delete_insn
argument_list|(
name|newjpos
argument_list|)
expr_stmt|;
name|newjpos
operator|=
name|next_real_insn
argument_list|(
name|newjpos
argument_list|)
expr_stmt|;
name|newlpos
operator|=
name|next_real_insn
argument_list|(
name|newlpos
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the label before INSN, or put a new label there.  */
end_comment

begin_function
name|rtx
name|get_label_before
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|rtx
name|label
decl_stmt|;
comment|/* Find an existing label at this point      or make a new one if there is none.  */
name|label
operator|=
name|prev_nonnote_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|label
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|label
argument_list|)
operator|!=
name|CODE_LABEL
condition|)
block|{
name|rtx
name|prev
init|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|emit_label_after
argument_list|(
name|label
argument_list|,
name|prev
argument_list|)
expr_stmt|;
name|LABEL_NUSES
argument_list|(
name|label
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|label
return|;
block|}
end_function

begin_comment
comment|/* Return the label after INSN, or put a new label there.  */
end_comment

begin_function
name|rtx
name|get_label_after
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|rtx
name|label
decl_stmt|;
comment|/* Find an existing label at this point      or make a new one if there is none.  */
name|label
operator|=
name|next_nonnote_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|label
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|label
argument_list|)
operator|!=
name|CODE_LABEL
condition|)
block|{
name|label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|emit_label_after
argument_list|(
name|label
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|LABEL_NUSES
argument_list|(
name|label
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|label
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if INSN is a jump that jumps to right after TARGET    only on the condition that TARGET itself would drop through.    Assumes that TARGET is a conditional jump.  */
end_comment

begin_function
specifier|static
name|int
name|jump_back_p
parameter_list|(
name|insn
parameter_list|,
name|target
parameter_list|)
name|rtx
name|insn
decl_stmt|,
name|target
decl_stmt|;
block|{
name|rtx
name|cinsn
decl_stmt|,
name|ctarget
decl_stmt|;
name|enum
name|rtx_code
name|codei
decl_stmt|,
name|codet
decl_stmt|;
if|if
condition|(
name|simplejump_p
argument_list|(
name|insn
argument_list|)
operator|||
operator|!
name|condjump_p
argument_list|(
name|insn
argument_list|)
operator|||
name|simplejump_p
argument_list|(
name|target
argument_list|)
operator|||
name|target
operator|!=
name|prev_real_insn
argument_list|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
name|cinsn
operator|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ctarget
operator|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|target
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|codei
operator|=
name|GET_CODE
argument_list|(
name|cinsn
argument_list|)
expr_stmt|;
name|codet
operator|=
name|GET_CODE
argument_list|(
name|ctarget
argument_list|)
expr_stmt|;
if|if
condition|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
name|pc_rtx
condition|)
block|{
if|if
condition|(
operator|!
name|can_reverse_comparison_p
argument_list|(
name|cinsn
argument_list|,
name|insn
argument_list|)
condition|)
return|return
literal|0
return|;
name|codei
operator|=
name|reverse_condition
argument_list|(
name|codei
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|target
argument_list|)
argument_list|)
argument_list|,
literal|2
argument_list|)
operator|==
name|pc_rtx
condition|)
block|{
if|if
condition|(
operator|!
name|can_reverse_comparison_p
argument_list|(
name|ctarget
argument_list|,
name|target
argument_list|)
condition|)
return|return
literal|0
return|;
name|codet
operator|=
name|reverse_condition
argument_list|(
name|codet
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|codei
operator|==
name|codet
operator|&&
name|rtx_renumbered_equal_p
argument_list|(
name|XEXP
argument_list|(
name|cinsn
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|ctarget
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|rtx_renumbered_equal_p
argument_list|(
name|XEXP
argument_list|(
name|cinsn
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|ctarget
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a comparison, COMPARISON, inside a conditional jump insn, INSN,    return non-zero if it is safe to reverse this comparison.  It is if our    floating-point is not IEEE, if this is an NE or EQ comparison, or if    this is known to be an integer comparison.  */
end_comment

begin_function
name|int
name|can_reverse_comparison_p
parameter_list|(
name|comparison
parameter_list|,
name|insn
parameter_list|)
name|rtx
name|comparison
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
name|rtx
name|arg0
decl_stmt|;
comment|/* If this is not actually a comparison, we can't reverse it.  */
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|comparison
argument_list|)
argument_list|)
operator|!=
literal|'<'
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TARGET_FLOAT_FORMAT
operator|!=
name|IEEE_FLOAT_FORMAT
comment|/* If this is an NE comparison, it is safe to reverse it to an EQ 	 comparison and vice versa, even for floating point.  If no operands 	 are NaNs, the reversal is valid.  If some operand is a NaN, EQ is 	 always false and NE is always true, so the reversal is also valid.  */
operator|||
name|flag_fast_math
operator|||
name|GET_CODE
argument_list|(
name|comparison
argument_list|)
operator|==
name|NE
operator|||
name|GET_CODE
argument_list|(
name|comparison
argument_list|)
operator|==
name|EQ
condition|)
return|return
literal|1
return|;
name|arg0
operator|=
name|XEXP
argument_list|(
name|comparison
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Make sure ARG0 is one of the actual objects being compared.  If we      can't do this, we can't be sure the comparison can be reversed.        Handle cc0 and a MODE_CC register.  */
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|REG
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|==
name|MODE_CC
operator|)
ifdef|#
directive|ifdef
name|HAVE_cc0
operator|||
name|arg0
operator|==
name|cc0_rtx
endif|#
directive|endif
condition|)
block|{
name|rtx
name|prev
init|=
name|prev_nonnote_insn
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|set
init|=
name|single_set
argument_list|(
name|prev
argument_list|)
decl_stmt|;
if|if
condition|(
name|set
operator|==
literal|0
operator|||
name|SET_DEST
argument_list|(
name|set
argument_list|)
operator|!=
name|arg0
condition|)
return|return
literal|0
return|;
name|arg0
operator|=
name|SET_SRC
argument_list|(
name|set
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|COMPARE
condition|)
name|arg0
operator|=
name|XEXP
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* We can reverse this if ARG0 is a CONST_INT or if its mode is      not VOIDmode and neither a MODE_CC nor MODE_FLOAT type.  */
return|return
operator|(
name|GET_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|CONST_INT
operator|||
operator|(
name|GET_MODE
argument_list|(
name|arg0
argument_list|)
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|!=
name|MODE_CC
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|!=
name|MODE_FLOAT
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Given an rtx-code for a comparison, return the code    for the negated comparison.    WATCH OUT!  reverse_condition is not safe to use on a jump    that might be acting on the results of an IEEE floating point comparison,    because of the special treatment of non-signaling nans in comparisons.      Use can_reverse_comparison_p to be sure.  */
end_comment

begin_function
name|enum
name|rtx_code
name|reverse_condition
parameter_list|(
name|code
parameter_list|)
name|enum
name|rtx_code
name|code
decl_stmt|;
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|EQ
case|:
return|return
name|NE
return|;
case|case
name|NE
case|:
return|return
name|EQ
return|;
case|case
name|GT
case|:
return|return
name|LE
return|;
case|case
name|GE
case|:
return|return
name|LT
return|;
case|case
name|LT
case|:
return|return
name|GE
return|;
case|case
name|LE
case|:
return|return
name|GT
return|;
case|case
name|GTU
case|:
return|return
name|LEU
return|;
case|case
name|GEU
case|:
return|return
name|LTU
return|;
case|case
name|LTU
case|:
return|return
name|GEU
return|;
case|case
name|LEU
case|:
return|return
name|GTU
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
return|return
name|UNKNOWN
return|;
block|}
block|}
end_function

begin_comment
comment|/* Similar, but return the code when two operands of a comparison are swapped.    This IS safe for IEEE floating-point.  */
end_comment

begin_function
name|enum
name|rtx_code
name|swap_condition
parameter_list|(
name|code
parameter_list|)
name|enum
name|rtx_code
name|code
decl_stmt|;
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|EQ
case|:
case|case
name|NE
case|:
return|return
name|code
return|;
case|case
name|GT
case|:
return|return
name|LT
return|;
case|case
name|GE
case|:
return|return
name|LE
return|;
case|case
name|LT
case|:
return|return
name|GT
return|;
case|case
name|LE
case|:
return|return
name|GE
return|;
case|case
name|GTU
case|:
return|return
name|LTU
return|;
case|case
name|GEU
case|:
return|return
name|LEU
return|;
case|case
name|LTU
case|:
return|return
name|GTU
return|;
case|case
name|LEU
case|:
return|return
name|GEU
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
return|return
name|UNKNOWN
return|;
block|}
block|}
end_function

begin_comment
comment|/* Given a comparison CODE, return the corresponding unsigned comparison.    If CODE is an equality comparison or already an unsigned comparison,    CODE is returned.  */
end_comment

begin_function
name|enum
name|rtx_code
name|unsigned_condition
parameter_list|(
name|code
parameter_list|)
name|enum
name|rtx_code
name|code
decl_stmt|;
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|EQ
case|:
case|case
name|NE
case|:
case|case
name|GTU
case|:
case|case
name|GEU
case|:
case|case
name|LTU
case|:
case|case
name|LEU
case|:
return|return
name|code
return|;
case|case
name|GT
case|:
return|return
name|GTU
return|;
case|case
name|GE
case|:
return|return
name|GEU
return|;
case|case
name|LT
case|:
return|return
name|LTU
return|;
case|case
name|LE
case|:
return|return
name|LEU
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Similarly, return the signed version of a comparison.  */
end_comment

begin_function
name|enum
name|rtx_code
name|signed_condition
parameter_list|(
name|code
parameter_list|)
name|enum
name|rtx_code
name|code
decl_stmt|;
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|EQ
case|:
case|case
name|NE
case|:
case|case
name|GT
case|:
case|case
name|GE
case|:
case|case
name|LT
case|:
case|case
name|LE
case|:
return|return
name|code
return|;
case|case
name|GTU
case|:
return|return
name|GT
return|;
case|case
name|GEU
case|:
return|return
name|GE
return|;
case|case
name|LTU
case|:
return|return
name|LT
return|;
case|case
name|LEU
case|:
return|return
name|LE
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return non-zero if CODE1 is more strict than CODE2, i.e., if the    truth of CODE1 implies the truth of CODE2.  */
end_comment

begin_function
name|int
name|comparison_dominates_p
parameter_list|(
name|code1
parameter_list|,
name|code2
parameter_list|)
name|enum
name|rtx_code
name|code1
decl_stmt|,
name|code2
decl_stmt|;
block|{
if|if
condition|(
name|code1
operator|==
name|code2
condition|)
return|return
literal|1
return|;
switch|switch
condition|(
name|code1
condition|)
block|{
case|case
name|EQ
case|:
if|if
condition|(
name|code2
operator|==
name|LE
operator|||
name|code2
operator|==
name|LEU
operator|||
name|code2
operator|==
name|GE
operator|||
name|code2
operator|==
name|GEU
condition|)
return|return
literal|1
return|;
break|break;
case|case
name|LT
case|:
if|if
condition|(
name|code2
operator|==
name|LE
operator|||
name|code2
operator|==
name|NE
condition|)
return|return
literal|1
return|;
break|break;
case|case
name|GT
case|:
if|if
condition|(
name|code2
operator|==
name|GE
operator|||
name|code2
operator|==
name|NE
condition|)
return|return
literal|1
return|;
break|break;
case|case
name|LTU
case|:
if|if
condition|(
name|code2
operator|==
name|LEU
operator|||
name|code2
operator|==
name|NE
condition|)
return|return
literal|1
return|;
break|break;
case|case
name|GTU
case|:
if|if
condition|(
name|code2
operator|==
name|GEU
operator|||
name|code2
operator|==
name|NE
condition|)
return|return
literal|1
return|;
break|break;
default|default:
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if INSN is an unconditional jump and nothing else.  */
end_comment

begin_function
name|int
name|simplejump_p
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
return|return
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|PC
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if INSN is a (possibly) conditional jump    and nothing more.  */
end_comment

begin_function
name|int
name|condjump_p
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
specifier|register
name|rtx
name|x
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|SET
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|PC
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|IF_THEN_ELSE
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|2
argument_list|)
operator|==
name|pc_rtx
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|RETURN
operator|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
name|pc_rtx
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|==
name|RETURN
operator|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if INSN is a (possibly) conditional jump    and nothing more.  */
end_comment

begin_function
name|int
name|condjump_in_parallel_p
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
specifier|register
name|rtx
name|x
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|PARALLEL
condition|)
return|return
literal|0
return|;
else|else
name|x
operator|=
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|SET
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|PC
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|IF_THEN_ELSE
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|2
argument_list|)
operator|==
name|pc_rtx
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|RETURN
operator|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
name|pc_rtx
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|==
name|RETURN
operator|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if X is an RTX that does nothing but set the condition codes    and CLOBBER or USE registers.    Return -1 if X does explicitly set the condition codes,    but also does other things.  */
end_comment

begin_function
name|int
name|sets_cc0_p
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|HAVE_cc0
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SET
operator|&&
name|SET_DEST
argument_list|(
name|x
argument_list|)
operator|==
name|cc0_rtx
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|sets_cc0
init|=
literal|0
decl_stmt|;
name|int
name|other_things
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|cc0_rtx
condition|)
name|sets_cc0
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|SET
condition|)
name|other_things
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|!
name|sets_cc0
condition|?
literal|0
else|:
name|other_things
condition|?
operator|-
literal|1
else|:
literal|1
return|;
block|}
return|return
literal|0
return|;
else|#
directive|else
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Follow any unconditional jump at LABEL;    return the ultimate label reached by any such chain of jumps.    If LABEL is not followed by a jump, return LABEL.    If the chain loops or we can't find end, return LABEL,    since that tells caller to avoid changing the insn.     If RELOAD_COMPLETED is 0, we do not chain across a NOTE_INSN_LOOP_BEG or    a USE or CLOBBER.  */
end_comment

begin_function
name|rtx
name|follow_jumps
parameter_list|(
name|label
parameter_list|)
name|rtx
name|label
decl_stmt|;
block|{
specifier|register
name|rtx
name|insn
decl_stmt|;
specifier|register
name|rtx
name|next
decl_stmt|;
specifier|register
name|rtx
name|value
init|=
name|label
decl_stmt|;
specifier|register
name|int
name|depth
decl_stmt|;
for|for
control|(
name|depth
operator|=
literal|0
init|;
operator|(
name|depth
operator|<
literal|10
operator|&&
operator|(
name|insn
operator|=
name|next_active_insn
argument_list|(
name|value
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
operator|(
operator|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
operator|!=
literal|0
operator|&&
name|simplejump_p
argument_list|(
name|insn
argument_list|)
operator|)
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|RETURN
operator|)
operator|&&
operator|(
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|BARRIER
operator|)
condition|;
name|depth
operator|++
control|)
block|{
comment|/* Don't chain through the insn that jumps into a loop 	 from outside the loop, 	 since that would create multiple loop entry jumps 	 and prevent loop optimization.  */
name|rtx
name|tem
decl_stmt|;
if|if
condition|(
operator|!
name|reload_completed
condition|)
for|for
control|(
name|tem
operator|=
name|value
init|;
name|tem
operator|!=
name|insn
condition|;
name|tem
operator|=
name|NEXT_INSN
argument_list|(
name|tem
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|NOTE
operator|&&
operator|(
name|NOTE_LINE_NUMBER
argument_list|(
name|tem
argument_list|)
operator|==
name|NOTE_INSN_LOOP_BEG
comment|/* ??? Optional.  Disables some optimizations, but makes 		     gcov output more accurate with -O.  */
operator|||
operator|(
name|flag_test_coverage
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|tem
argument_list|)
operator|>
literal|0
operator|)
operator|)
condition|)
return|return
name|value
return|;
comment|/* If we have found a cycle, make the insn jump to itself.  */
if|if
condition|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
operator|==
name|label
condition|)
return|return
name|label
return|;
name|tem
operator|=
name|next_active_insn
argument_list|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|tem
argument_list|)
argument_list|)
operator|==
name|ADDR_VEC
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|tem
argument_list|)
argument_list|)
operator|==
name|ADDR_DIFF_VEC
operator|)
condition|)
break|break;
name|value
operator|=
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|depth
operator|==
literal|10
condition|)
return|return
name|label
return|;
return|return
name|value
return|;
block|}
end_function

begin_comment
comment|/* Assuming that field IDX of X is a vector of label_refs,    replace each of them by the ultimate label reached by it.    Return nonzero if a change is made.    If IGNORE_LOOPS is 0, we do not chain across a NOTE_INSN_LOOP_BEG.  */
end_comment

begin_function
specifier|static
name|int
name|tension_vector_labels
parameter_list|(
name|x
parameter_list|,
name|idx
parameter_list|)
specifier|register
name|rtx
name|x
decl_stmt|;
specifier|register
name|int
name|idx
decl_stmt|;
block|{
name|int
name|changed
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|idx
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
specifier|register
name|rtx
name|olabel
init|=
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|idx
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|register
name|rtx
name|nlabel
init|=
name|follow_jumps
argument_list|(
name|olabel
argument_list|)
decl_stmt|;
if|if
condition|(
name|nlabel
operator|&&
name|nlabel
operator|!=
name|olabel
condition|)
block|{
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|idx
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|=
name|nlabel
expr_stmt|;
operator|++
name|LABEL_NUSES
argument_list|(
name|nlabel
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|LABEL_NUSES
argument_list|(
name|olabel
argument_list|)
operator|==
literal|0
condition|)
name|delete_insn
argument_list|(
name|olabel
argument_list|)
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
block|}
block|}
return|return
name|changed
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Find all CODE_LABELs referred to in X, and increment their use counts.    If INSN is a JUMP_INSN and there is at least one CODE_LABEL referenced    in INSN, then store one of them in JUMP_LABEL (INSN).    If INSN is an INSN or a CALL_INSN and there is at least one CODE_LABEL    referenced in INSN, add a REG_LABEL note containing that label to INSN.    Also, when there are consecutive labels, canonicalize on the last of them.     Note that two labels separated by a loop-beginning note    must be kept distinct if we have not yet done loop-optimization,    because the gap between them is where loop-optimize    will want to move invariant code to.  CROSS_JUMP tells us    that loop-optimization is done with.     Once reload has completed (CROSS_JUMP non-zero), we need not consider    two labels distinct if they are separated by only USE or CLOBBER insns.  */
end_comment

begin_function
specifier|static
name|void
name|mark_jump_label
parameter_list|(
name|x
parameter_list|,
name|insn
parameter_list|,
name|cross_jump
parameter_list|)
specifier|register
name|rtx
name|x
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|int
name|cross_jump
decl_stmt|;
block|{
specifier|register
name|RTX_CODE
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PC
case|:
case|case
name|CC0
case|:
case|case
name|REG
case|:
case|case
name|SUBREG
case|:
case|case
name|CONST_INT
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CLOBBER
case|:
case|case
name|CALL
case|:
return|return;
case|case
name|MEM
case|:
comment|/* If this is a constant-pool reference, see if it is a label.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|mark_jump_label
argument_list|(
name|get_pool_constant
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|insn
argument_list|,
name|cross_jump
argument_list|)
expr_stmt|;
break|break;
case|case
name|LABEL_REF
case|:
block|{
name|rtx
name|label
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|olabel
init|=
name|label
decl_stmt|;
name|rtx
name|note
decl_stmt|;
name|rtx
name|next
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|label
argument_list|)
operator|!=
name|CODE_LABEL
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Ignore references to labels of containing functions.  */
if|if
condition|(
name|LABEL_REF_NONLOCAL_P
argument_list|(
name|x
argument_list|)
condition|)
break|break;
comment|/* If there are other labels following this one, 	   replace it with the last of the consecutive labels.  */
for|for
control|(
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|label
argument_list|)
init|;
name|next
condition|;
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|next
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|CODE_LABEL
condition|)
name|label
operator|=
name|next
expr_stmt|;
elseif|else
if|if
condition|(
name|cross_jump
operator|&&
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|INSN
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|next
argument_list|)
argument_list|)
operator|==
name|USE
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|next
argument_list|)
argument_list|)
operator|==
name|CLOBBER
operator|)
condition|)
continue|continue;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|!=
name|NOTE
condition|)
break|break;
elseif|else
if|if
condition|(
operator|!
name|cross_jump
operator|&&
operator|(
name|NOTE_LINE_NUMBER
argument_list|(
name|next
argument_list|)
operator|==
name|NOTE_INSN_LOOP_BEG
operator|||
name|NOTE_LINE_NUMBER
argument_list|(
name|next
argument_list|)
operator|==
name|NOTE_INSN_FUNCTION_END
comment|/* ??? Optional.  Disables some optimizations, but 			    makes gcov output more accurate with -O.  */
operator|||
operator|(
name|flag_test_coverage
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|next
argument_list|)
operator|>
literal|0
operator|)
operator|)
condition|)
break|break;
block|}
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|=
name|label
expr_stmt|;
if|if
condition|(
operator|!
name|insn
operator|||
operator|!
name|INSN_DELETED_P
argument_list|(
name|insn
argument_list|)
condition|)
operator|++
name|LABEL_NUSES
argument_list|(
name|label
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
operator|=
name|label
expr_stmt|;
comment|/* If we've changed OLABEL and we had a REG_LABEL note 	       for it, update it as well.  */
elseif|else
if|if
condition|(
name|label
operator|!=
name|olabel
operator|&&
operator|(
name|note
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_LABEL
argument_list|,
name|olabel
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
operator|=
name|label
expr_stmt|;
comment|/* Otherwise, add a REG_LABEL note for LABEL unless there already 	       is one.  */
elseif|else
if|if
condition|(
operator|!
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_LABEL
argument_list|,
name|label
argument_list|)
condition|)
block|{
comment|/* This code used to ignore labels which refered to dispatch 		   tables to avoid flow.c generating worse code.  		   However, in the presense of global optimizations like 		   gcse which call find_basic_blocks without calling 		   life_analysis, not recording such labels will lead 		   to compiler aborts because of inconsistencies in the 		   flow graph.  So we go ahead and record the label.  		   It may also be the case that the optimization argument 		   is no longer valid because of the more accurate cfg 		   we build in find_basic_blocks -- it no longer pessimizes 		   code when it finds a REG_LABEL note.  */
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_LABEL
argument_list|,
name|label
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
comment|/* Do walk the labels in a vector, but not the first operand of an      ADDR_DIFF_VEC.  Don't set the JUMP_LABEL of a vector.  */
case|case
name|ADDR_VEC
case|:
case|case
name|ADDR_DIFF_VEC
case|:
if|if
condition|(
operator|!
name|INSN_DELETED_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|int
name|eltnum
init|=
name|code
operator|==
name|ADDR_DIFF_VEC
condition|?
literal|1
else|:
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|eltnum
argument_list|)
condition|;
name|i
operator|++
control|)
name|mark_jump_label
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|eltnum
argument_list|,
name|i
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|cross_jump
argument_list|)
expr_stmt|;
block|}
return|return;
default|default:
break|break;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|mark_jump_label
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|insn
argument_list|,
name|cross_jump
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|mark_jump_label
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|insn
argument_list|,
name|cross_jump
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* If all INSN does is set the pc, delete it,    and delete the insn that set the condition codes for it    if that's what the previous thing was.  */
end_comment

begin_function
name|void
name|delete_jump
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
specifier|register
name|rtx
name|set
init|=
name|single_set
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|set
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|PC
condition|)
name|delete_computation
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Delete INSN and recursively delete insns that compute values used only    by INSN.  This uses the REG_DEAD notes computed during flow analysis.    If we are running before flow.c, we need do nothing since flow.c will    delete dead code.  We also can't know if the registers being used are    dead or not at this point.     Otherwise, look at all our REG_DEAD notes.  If a previous insn does    nothing other than set a register that dies in this insn, we can delete    that insn as well.     On machines with CC0, if CC0 is used in this insn, we may be able to    delete the insn that set it.  */
end_comment

begin_function
specifier|static
name|void
name|delete_computation
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|rtx
name|note
decl_stmt|,
name|next
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_cc0
if|if
condition|(
name|reg_referenced_p
argument_list|(
name|cc0_rtx
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|prev
init|=
name|prev_nonnote_insn
argument_list|(
name|insn
argument_list|)
decl_stmt|;
comment|/* We assume that at this stage 	 CC's are always set explicitly 	 and always immediately before the jump that 	 will use them.  So if the previous insn 	 exists to set the CC's, delete it 	 (unless it performs auto-increments, etc.).  */
if|if
condition|(
name|prev
operator|&&
name|GET_CODE
argument_list|(
name|prev
argument_list|)
operator|==
name|INSN
operator|&&
name|sets_cc0_p
argument_list|(
name|PATTERN
argument_list|(
name|prev
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|sets_cc0_p
argument_list|(
name|PATTERN
argument_list|(
name|prev
argument_list|)
argument_list|)
operator|>
literal|0
operator|&&
operator|!
name|FIND_REG_INC_NOTE
argument_list|(
name|prev
argument_list|,
name|NULL_RTX
argument_list|)
condition|)
name|delete_computation
argument_list|(
name|prev
argument_list|)
expr_stmt|;
else|else
comment|/* Otherwise, show that cc0 won't be used.  */
name|REG_NOTES
argument_list|(
name|prev
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_UNUSED
argument_list|,
name|cc0_rtx
argument_list|,
name|REG_NOTES
argument_list|(
name|prev
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INSN_SCHEDULING
comment|/* ?!? The schedulers do not keep REG_DEAD notes accurate after      reload has completed.  The schedulers need to be fixed.  Until      they are, we must not rely on the death notes here.  */
if|if
condition|(
name|reload_completed
operator|&&
name|flag_schedule_insns_after_reload
condition|)
block|{
name|delete_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
for|for
control|(
name|note
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|note
condition|;
name|note
operator|=
name|next
control|)
block|{
name|rtx
name|our_prev
decl_stmt|;
name|next
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
operator|!=
name|REG_DEAD
comment|/* Verify that the REG_NOTE is legitimate.  */
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|REG
condition|)
continue|continue;
for|for
control|(
name|our_prev
operator|=
name|prev_nonnote_insn
argument_list|(
name|insn
argument_list|)
init|;
name|our_prev
operator|&&
name|GET_CODE
argument_list|(
name|our_prev
argument_list|)
operator|==
name|INSN
condition|;
name|our_prev
operator|=
name|prev_nonnote_insn
argument_list|(
name|our_prev
argument_list|)
control|)
block|{
comment|/* If we reach a SEQUENCE, it is too complex to try to 	     do anything with it, so give up.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|our_prev
argument_list|)
argument_list|)
operator|==
name|SEQUENCE
condition|)
break|break;
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|our_prev
argument_list|)
argument_list|)
operator|==
name|USE
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|our_prev
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|INSN
condition|)
comment|/* reorg creates USEs that look like this.  We leave them 	       alone because reorg needs them for its own purposes.  */
break|break;
if|if
condition|(
name|reg_set_p
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|PATTERN
argument_list|(
name|our_prev
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|FIND_REG_INC_NOTE
argument_list|(
name|our_prev
argument_list|,
name|NULL_RTX
argument_list|)
condition|)
break|break;
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|our_prev
argument_list|)
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
comment|/* If we find a SET of something else, we can't 		     delete the insn.  */
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|our_prev
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|part
init|=
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|our_prev
argument_list|)
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|part
argument_list|)
operator|==
name|SET
operator|&&
name|SET_DEST
argument_list|(
name|part
argument_list|)
operator|!=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|our_prev
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
name|delete_computation
argument_list|(
name|our_prev
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|our_prev
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|our_prev
argument_list|)
argument_list|)
operator|==
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
condition|)
name|delete_computation
argument_list|(
name|our_prev
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* If OUR_PREV references the register that dies here, it is an 	     additional use.  Hence any prior SET isn't dead.  However, this 	     insn becomes the new place for the REG_DEAD note.  */
if|if
condition|(
name|reg_overlap_mentioned_p
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|PATTERN
argument_list|(
name|our_prev
argument_list|)
argument_list|)
condition|)
block|{
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
operator|=
name|REG_NOTES
argument_list|(
name|our_prev
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|our_prev
argument_list|)
operator|=
name|note
expr_stmt|;
break|break;
block|}
block|}
block|}
name|delete_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Delete insn INSN from the chain of insns and update label ref counts.    May delete some following insns as a consequence; may even delete    a label elsewhere and insns that follow it.     Returns the first insn after INSN that was not deleted.  */
end_comment

begin_function
name|rtx
name|delete_insn
parameter_list|(
name|insn
parameter_list|)
specifier|register
name|rtx
name|insn
decl_stmt|;
block|{
specifier|register
name|rtx
name|next
init|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
specifier|register
name|rtx
name|prev
init|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
specifier|register
name|int
name|was_code_label
init|=
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
operator|)
decl_stmt|;
specifier|register
name|int
name|dont_really_delete
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|next
operator|&&
name|INSN_DELETED_P
argument_list|(
name|next
argument_list|)
condition|)
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|next
argument_list|)
expr_stmt|;
comment|/* This insn is already deleted => return first following nondeleted.  */
if|if
condition|(
name|INSN_DELETED_P
argument_list|(
name|insn
argument_list|)
condition|)
return|return
name|next
return|;
comment|/* Don't delete user-declared labels.  Convert them to special NOTEs      instead.  */
if|if
condition|(
name|was_code_label
operator|&&
name|LABEL_NAME
argument_list|(
name|insn
argument_list|)
operator|!=
literal|0
operator|&&
name|optimize
operator|&&
operator|!
name|dont_really_delete
condition|)
block|{
name|PUT_CODE
argument_list|(
name|insn
argument_list|,
name|NOTE
argument_list|)
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|=
name|NOTE_INSN_DELETED_LABEL
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
operator|=
literal|0
expr_stmt|;
name|dont_really_delete
operator|=
literal|1
expr_stmt|;
block|}
else|else
comment|/* Mark this insn as deleted.  */
name|INSN_DELETED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* If this is an unconditional jump, delete it from the jump chain.  */
if|if
condition|(
name|simplejump_p
argument_list|(
name|insn
argument_list|)
condition|)
name|delete_from_jump_chain
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* If instruction is followed by a barrier,      delete the barrier too.  */
if|if
condition|(
name|next
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|BARRIER
condition|)
block|{
name|INSN_DELETED_P
argument_list|(
name|next
argument_list|)
operator|=
literal|1
expr_stmt|;
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|next
argument_list|)
expr_stmt|;
block|}
comment|/* Patch out INSN (and the barrier if any) */
if|if
condition|(
name|optimize
operator|&&
operator|!
name|dont_really_delete
condition|)
block|{
if|if
condition|(
name|prev
condition|)
block|{
name|NEXT_INSN
argument_list|(
name|prev
argument_list|)
operator|=
name|next
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|prev
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|prev
argument_list|)
argument_list|)
operator|==
name|SEQUENCE
condition|)
name|NEXT_INSN
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|prev
argument_list|)
argument_list|,
literal|0
argument_list|,
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|prev
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
argument_list|)
argument_list|)
operator|=
name|next
expr_stmt|;
block|}
if|if
condition|(
name|next
condition|)
block|{
name|PREV_INSN
argument_list|(
name|next
argument_list|)
operator|=
name|prev
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|next
argument_list|)
argument_list|)
operator|==
name|SEQUENCE
condition|)
name|PREV_INSN
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|next
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|=
name|prev
expr_stmt|;
block|}
if|if
condition|(
name|prev
operator|&&
name|NEXT_INSN
argument_list|(
name|prev
argument_list|)
operator|==
literal|0
condition|)
name|set_last_insn
argument_list|(
name|prev
argument_list|)
expr_stmt|;
block|}
comment|/* If deleting a jump, decrement the count of the label,      and delete the label if it is now unused.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
condition|)
if|if
condition|(
operator|--
name|LABEL_NUSES
argument_list|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* This can delete NEXT or PREV, 	   either directly if NEXT is JUMP_LABEL (INSN), 	   or indirectly through more levels of jumps.  */
name|delete_insn
argument_list|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* I feel a little doubtful about this loop, 	   but I see no clean and sure alternative way 	   to find the first insn after INSN that is not now deleted. 	   I hope this works.  */
while|while
condition|(
name|next
operator|&&
name|INSN_DELETED_P
argument_list|(
name|next
argument_list|)
condition|)
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|next
argument_list|)
expr_stmt|;
return|return
name|next
return|;
block|}
comment|/* Likewise if we're deleting a dispatch table.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|ADDR_VEC
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|ADDR_DIFF_VEC
operator|)
condition|)
block|{
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|diff_vec_p
init|=
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|ADDR_DIFF_VEC
decl_stmt|;
name|int
name|len
init|=
name|XVECLEN
argument_list|(
name|pat
argument_list|,
name|diff_vec_p
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|--
name|LABEL_NUSES
argument_list|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
name|diff_vec_p
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|delete_insn
argument_list|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
name|diff_vec_p
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|next
operator|&&
name|INSN_DELETED_P
argument_list|(
name|next
argument_list|)
condition|)
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|next
argument_list|)
expr_stmt|;
return|return
name|next
return|;
block|}
while|while
condition|(
name|prev
operator|&&
operator|(
name|INSN_DELETED_P
argument_list|(
name|prev
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|prev
argument_list|)
operator|==
name|NOTE
operator|)
condition|)
name|prev
operator|=
name|PREV_INSN
argument_list|(
name|prev
argument_list|)
expr_stmt|;
comment|/* If INSN was a label and a dispatch table follows it,      delete the dispatch table.  The tablejump must have gone already.      It isn't useful to fall through into a table.  */
if|if
condition|(
name|was_code_label
operator|&&
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|ADDR_VEC
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|ADDR_DIFF_VEC
operator|)
condition|)
name|next
operator|=
name|delete_insn
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If INSN was a label, delete insns following it if now unreachable.  */
if|if
condition|(
name|was_code_label
operator|&&
name|prev
operator|&&
name|GET_CODE
argument_list|(
name|prev
argument_list|)
operator|==
name|BARRIER
condition|)
block|{
specifier|register
name|RTX_CODE
name|code
decl_stmt|;
while|while
condition|(
name|next
operator|!=
literal|0
operator|&&
operator|(
name|GET_RTX_CLASS
argument_list|(
name|code
operator|=
name|GET_CODE
argument_list|(
name|next
argument_list|)
argument_list|)
operator|==
literal|'i'
operator|||
name|code
operator|==
name|NOTE
operator|||
name|code
operator|==
name|BARRIER
operator|||
operator|(
name|code
operator|==
name|CODE_LABEL
operator|&&
name|INSN_DELETED_P
argument_list|(
name|next
argument_list|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|code
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|next
argument_list|)
operator|!=
name|NOTE_INSN_FUNCTION_END
condition|)
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|next
argument_list|)
expr_stmt|;
comment|/* Keep going past other deleted labels to delete what follows.  */
elseif|else
if|if
condition|(
name|code
operator|==
name|CODE_LABEL
operator|&&
name|INSN_DELETED_P
argument_list|(
name|next
argument_list|)
condition|)
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|next
argument_list|)
expr_stmt|;
else|else
comment|/* Note: if this deletes a jump, it can cause more 	       deletion of unreachable code, after a different label. 	       As long as the value from this recursive call is correct, 	       this invocation functions correctly.  */
name|next
operator|=
name|delete_insn
argument_list|(
name|next
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|next
return|;
block|}
end_function

begin_comment
comment|/* Advance from INSN till reaching something not deleted    then return that.  May return INSN itself.  */
end_comment

begin_function
name|rtx
name|next_nondeleted_insn
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
while|while
condition|(
name|INSN_DELETED_P
argument_list|(
name|insn
argument_list|)
condition|)
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
return|return
name|insn
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Delete a range of insns from FROM to TO, inclusive.    This is for the sake of peephole optimization, so assume    that whatever these insns do will still be done by a new    peephole insn that will replace them.  */
end_comment

begin_function
name|void
name|delete_for_peephole
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|)
specifier|register
name|rtx
name|from
decl_stmt|,
name|to
decl_stmt|;
block|{
specifier|register
name|rtx
name|insn
init|=
name|from
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
specifier|register
name|rtx
name|next
init|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
specifier|register
name|rtx
name|prev
init|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE
condition|)
block|{
name|INSN_DELETED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Patch this insn out of the chain.  */
comment|/* We don't do this all at once, because we 	     must preserve all NOTEs.  */
if|if
condition|(
name|prev
condition|)
name|NEXT_INSN
argument_list|(
name|prev
argument_list|)
operator|=
name|next
expr_stmt|;
if|if
condition|(
name|next
condition|)
name|PREV_INSN
argument_list|(
name|next
argument_list|)
operator|=
name|prev
expr_stmt|;
block|}
if|if
condition|(
name|insn
operator|==
name|to
condition|)
break|break;
name|insn
operator|=
name|next
expr_stmt|;
block|}
comment|/* Note that if TO is an unconditional jump      we *do not* delete the BARRIER that follows,      since the peephole that replaces this sequence      is also an unconditional jump in that case.  */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Invert the condition of the jump JUMP, and make it jump    to label NLABEL instead of where it jumps now.  */
end_comment

begin_function
name|int
name|invert_jump
parameter_list|(
name|jump
parameter_list|,
name|nlabel
parameter_list|)
name|rtx
name|jump
decl_stmt|,
name|nlabel
decl_stmt|;
block|{
comment|/* We have to either invert the condition and change the label or      do neither.  Either operation could fail.  We first try to invert      the jump. If that succeeds, we try changing the label.  If that fails,      we invert the jump back to what it was.  */
if|if
condition|(
operator|!
name|invert_exp
argument_list|(
name|PATTERN
argument_list|(
name|jump
argument_list|)
argument_list|,
name|jump
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|redirect_jump
argument_list|(
name|jump
argument_list|,
name|nlabel
argument_list|)
condition|)
block|{
if|if
condition|(
name|flag_branch_probabilities
condition|)
block|{
name|rtx
name|note
init|=
name|find_reg_note
argument_list|(
name|jump
argument_list|,
name|REG_BR_PROB
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* An inverted jump means that a probability taken becomes a 	     probability not taken.  Subtract the branch probability from the 	     probability base to convert it back to a taken probability. 	     (We don't flip the probability on a branch that's never taken.  */
if|if
condition|(
name|note
operator|&&
name|XINT
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|>=
literal|0
condition|)
name|XINT
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|=
name|REG_BR_PROB_BASE
operator|-
name|XINT
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|invert_exp
argument_list|(
name|PATTERN
argument_list|(
name|jump
argument_list|)
argument_list|,
name|jump
argument_list|)
condition|)
comment|/* This should just be putting it back the way it was.  */
name|abort
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Invert the jump condition of rtx X contained in jump insn, INSN.      Return 1 if we can do so, 0 if we cannot find a way to do so that    matches a pattern.  */
end_comment

begin_function
name|int
name|invert_exp
parameter_list|(
name|x
parameter_list|,
name|insn
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
specifier|register
name|RTX_CODE
name|code
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|IF_THEN_ELSE
condition|)
block|{
specifier|register
name|rtx
name|comp
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|register
name|rtx
name|tem
decl_stmt|;
comment|/* We can do this in two ways:  The preferable way, which can only 	 be done if this is not an integer comparison, is to reverse 	 the comparison code.  Otherwise, swap the THEN-part and ELSE-part 	 of the IF_THEN_ELSE.  If we can't do either, fail.  */
if|if
condition|(
name|can_reverse_comparison_p
argument_list|(
name|comp
argument_list|,
name|insn
argument_list|)
operator|&&
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|gen_rtx_fmt_ee
argument_list|(
name|reverse_condition
argument_list|(
name|GET_CODE
argument_list|(
name|comp
argument_list|)
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|comp
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|comp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|comp
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|1
return|;
name|tem
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
argument_list|,
name|tem
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|apply_change_group
argument_list|()
return|;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
if|if
condition|(
operator|!
name|invert_exp
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|insn
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|!
name|invert_exp
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|insn
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Make jump JUMP jump to label NLABEL instead of where it jumps now.    If the old jump target label is unused as a result,    it and the code following it may be deleted.     If NLABEL is zero, we are to turn the jump into a (possibly conditional)    RETURN insn.     The return value will be 1 if the change was made, 0 if it wasn't (this    can only occur for NLABEL == 0).  */
end_comment

begin_function
name|int
name|redirect_jump
parameter_list|(
name|jump
parameter_list|,
name|nlabel
parameter_list|)
name|rtx
name|jump
decl_stmt|,
name|nlabel
decl_stmt|;
block|{
specifier|register
name|rtx
name|olabel
init|=
name|JUMP_LABEL
argument_list|(
name|jump
argument_list|)
decl_stmt|;
if|if
condition|(
name|nlabel
operator|==
name|olabel
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
name|redirect_exp
argument_list|(
operator|&
name|PATTERN
argument_list|(
name|jump
argument_list|)
argument_list|,
name|olabel
argument_list|,
name|nlabel
argument_list|,
name|jump
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* If this is an unconditional branch, delete it from the jump_chain of      OLABEL and add it to the jump_chain of NLABEL (assuming both labels      have UID's in range and JUMP_CHAIN is valid).  */
if|if
condition|(
name|jump_chain
operator|&&
operator|(
name|simplejump_p
argument_list|(
name|jump
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|jump
argument_list|)
argument_list|)
operator|==
name|RETURN
operator|)
condition|)
block|{
name|int
name|label_index
init|=
name|nlabel
condition|?
name|INSN_UID
argument_list|(
name|nlabel
argument_list|)
else|:
literal|0
decl_stmt|;
name|delete_from_jump_chain
argument_list|(
name|jump
argument_list|)
expr_stmt|;
if|if
condition|(
name|label_index
operator|<
name|max_jump_chain
operator|&&
name|INSN_UID
argument_list|(
name|jump
argument_list|)
operator|<
name|max_jump_chain
condition|)
block|{
name|jump_chain
index|[
name|INSN_UID
argument_list|(
name|jump
argument_list|)
index|]
operator|=
name|jump_chain
index|[
name|label_index
index|]
expr_stmt|;
name|jump_chain
index|[
name|label_index
index|]
operator|=
name|jump
expr_stmt|;
block|}
block|}
name|JUMP_LABEL
argument_list|(
name|jump
argument_list|)
operator|=
name|nlabel
expr_stmt|;
if|if
condition|(
name|nlabel
condition|)
operator|++
name|LABEL_NUSES
argument_list|(
name|nlabel
argument_list|)
expr_stmt|;
if|if
condition|(
name|olabel
operator|&&
operator|--
name|LABEL_NUSES
argument_list|(
name|olabel
argument_list|)
operator|==
literal|0
condition|)
name|delete_insn
argument_list|(
name|olabel
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Delete the instruction JUMP from any jump chain it might be on.  */
end_comment

begin_function
specifier|static
name|void
name|delete_from_jump_chain
parameter_list|(
name|jump
parameter_list|)
name|rtx
name|jump
decl_stmt|;
block|{
name|int
name|index
decl_stmt|;
name|rtx
name|olabel
init|=
name|JUMP_LABEL
argument_list|(
name|jump
argument_list|)
decl_stmt|;
comment|/* Handle unconditional jumps.  */
if|if
condition|(
name|jump_chain
operator|&&
name|olabel
operator|!=
literal|0
operator|&&
name|INSN_UID
argument_list|(
name|olabel
argument_list|)
operator|<
name|max_jump_chain
operator|&&
name|simplejump_p
argument_list|(
name|jump
argument_list|)
condition|)
name|index
operator|=
name|INSN_UID
argument_list|(
name|olabel
argument_list|)
expr_stmt|;
comment|/* Handle return insns.  */
elseif|else
if|if
condition|(
name|jump_chain
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|jump
argument_list|)
argument_list|)
operator|==
name|RETURN
condition|)
name|index
operator|=
literal|0
expr_stmt|;
else|else
return|return;
if|if
condition|(
name|jump_chain
index|[
name|index
index|]
operator|==
name|jump
condition|)
name|jump_chain
index|[
name|index
index|]
operator|=
name|jump_chain
index|[
name|INSN_UID
argument_list|(
name|jump
argument_list|)
index|]
expr_stmt|;
else|else
block|{
name|rtx
name|insn
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|jump_chain
index|[
name|index
index|]
init|;
name|insn
operator|!=
literal|0
condition|;
name|insn
operator|=
name|jump_chain
index|[
name|INSN_UID
argument_list|(
name|insn
argument_list|)
index|]
control|)
if|if
condition|(
name|jump_chain
index|[
name|INSN_UID
argument_list|(
name|insn
argument_list|)
index|]
operator|==
name|jump
condition|)
block|{
name|jump_chain
index|[
name|INSN_UID
argument_list|(
name|insn
argument_list|)
index|]
operator|=
name|jump_chain
index|[
name|INSN_UID
argument_list|(
name|jump
argument_list|)
index|]
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* If NLABEL is nonzero, throughout the rtx at LOC,    alter (LABEL_REF OLABEL) to (LABEL_REF NLABEL).  If OLABEL is    zero, alter (RETURN) to (LABEL_REF NLABEL).     If NLABEL is zero, alter (LABEL_REF OLABEL) to (RETURN) and check    validity with validate_change.  Convert (set (pc) (label_ref olabel))    to (return).     Return 0 if we found a change we would like to make but it is invalid.    Otherwise, return 1.  */
end_comment

begin_function
name|int
name|redirect_exp
parameter_list|(
name|loc
parameter_list|,
name|olabel
parameter_list|,
name|nlabel
parameter_list|,
name|insn
parameter_list|)
name|rtx
modifier|*
name|loc
decl_stmt|;
name|rtx
name|olabel
decl_stmt|,
name|nlabel
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
specifier|register
name|rtx
name|x
init|=
operator|*
name|loc
decl_stmt|;
specifier|register
name|RTX_CODE
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|LABEL_REF
condition|)
block|{
if|if
condition|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|olabel
condition|)
block|{
if|if
condition|(
name|nlabel
condition|)
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|=
name|nlabel
expr_stmt|;
else|else
return|return
name|validate_change
argument_list|(
name|insn
argument_list|,
name|loc
argument_list|,
name|gen_rtx_RETURN
argument_list|(
name|VOIDmode
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
return|return
literal|1
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|RETURN
operator|&&
name|olabel
operator|==
literal|0
condition|)
block|{
name|x
operator|=
name|gen_rtx_LABEL_REF
argument_list|(
name|VOIDmode
argument_list|,
name|nlabel
argument_list|)
expr_stmt|;
if|if
condition|(
name|loc
operator|==
operator|&
name|PATTERN
argument_list|(
name|insn
argument_list|)
condition|)
name|x
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|pc_rtx
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return
name|validate_change
argument_list|(
name|insn
argument_list|,
name|loc
argument_list|,
name|x
argument_list|,
literal|0
argument_list|)
return|;
block|}
if|if
condition|(
name|code
operator|==
name|SET
operator|&&
name|nlabel
operator|==
literal|0
operator|&&
name|SET_DEST
argument_list|(
name|x
argument_list|)
operator|==
name|pc_rtx
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|&&
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|olabel
condition|)
return|return
name|validate_change
argument_list|(
name|insn
argument_list|,
name|loc
argument_list|,
name|gen_rtx_RETURN
argument_list|(
name|VOIDmode
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
if|if
condition|(
operator|!
name|redirect_exp
argument_list|(
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|olabel
argument_list|,
name|nlabel
argument_list|,
name|insn
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|!
name|redirect_exp
argument_list|(
operator|&
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|olabel
argument_list|,
name|nlabel
argument_list|,
name|insn
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Make jump JUMP jump to label NLABEL, assuming it used to be a tablejump.     If the old jump target label (before the dispatch table) becomes unused,    it and the dispatch table may be deleted.  In that case, find the insn    before the jump references that label and delete it and logical successors    too.  */
end_comment

begin_function
specifier|static
name|void
name|redirect_tablejump
parameter_list|(
name|jump
parameter_list|,
name|nlabel
parameter_list|)
name|rtx
name|jump
decl_stmt|,
name|nlabel
decl_stmt|;
block|{
specifier|register
name|rtx
name|olabel
init|=
name|JUMP_LABEL
argument_list|(
name|jump
argument_list|)
decl_stmt|;
comment|/* Add this jump to the jump_chain of NLABEL.  */
if|if
condition|(
name|jump_chain
operator|&&
name|INSN_UID
argument_list|(
name|nlabel
argument_list|)
operator|<
name|max_jump_chain
operator|&&
name|INSN_UID
argument_list|(
name|jump
argument_list|)
operator|<
name|max_jump_chain
condition|)
block|{
name|jump_chain
index|[
name|INSN_UID
argument_list|(
name|jump
argument_list|)
index|]
operator|=
name|jump_chain
index|[
name|INSN_UID
argument_list|(
name|nlabel
argument_list|)
index|]
expr_stmt|;
name|jump_chain
index|[
name|INSN_UID
argument_list|(
name|nlabel
argument_list|)
index|]
operator|=
name|jump
expr_stmt|;
block|}
name|PATTERN
argument_list|(
name|jump
argument_list|)
operator|=
name|gen_jump
argument_list|(
name|nlabel
argument_list|)
expr_stmt|;
name|JUMP_LABEL
argument_list|(
name|jump
argument_list|)
operator|=
name|nlabel
expr_stmt|;
operator|++
name|LABEL_NUSES
argument_list|(
name|nlabel
argument_list|)
expr_stmt|;
name|INSN_CODE
argument_list|(
name|jump
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|--
name|LABEL_NUSES
argument_list|(
name|olabel
argument_list|)
operator|==
literal|0
condition|)
block|{
name|delete_labelref_insn
argument_list|(
name|jump
argument_list|,
name|olabel
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|delete_insn
argument_list|(
name|olabel
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Find the insn referencing LABEL that is a logical predecessor of INSN.    If we found one, delete it and then delete this insn if DELETE_THIS is    non-zero.  Return non-zero if INSN or a predecessor references LABEL.  */
end_comment

begin_function
specifier|static
name|int
name|delete_labelref_insn
parameter_list|(
name|insn
parameter_list|,
name|label
parameter_list|,
name|delete_this
parameter_list|)
name|rtx
name|insn
decl_stmt|,
name|label
decl_stmt|;
name|int
name|delete_this
decl_stmt|;
block|{
name|int
name|deleted
init|=
literal|0
decl_stmt|;
name|rtx
name|link
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE
operator|&&
name|reg_mentioned_p
argument_list|(
name|label
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|delete_this
condition|)
block|{
name|delete_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|deleted
operator|=
literal|1
expr_stmt|;
block|}
else|else
return|return
literal|1
return|;
block|}
for|for
control|(
name|link
operator|=
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|delete_labelref_insn
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|,
name|label
argument_list|,
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
name|delete_this
condition|)
block|{
name|delete_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|deleted
operator|=
literal|1
expr_stmt|;
block|}
else|else
return|return
literal|1
return|;
block|}
return|return
name|deleted
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Like rtx_equal_p except that it considers two REGs as equal    if they renumber to the same value and considers two commutative    operations to be the same if the order of the operands has been    reversed.  */
end_comment

begin_function
name|int
name|rtx_renumbered_equal_p
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|y
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|RTX_CODE
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|x
operator|==
name|y
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|(
name|code
operator|==
name|REG
operator|||
operator|(
name|code
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|REG
operator|)
operator|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|REG
operator|||
operator|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|y
argument_list|)
argument_list|)
operator|==
name|REG
operator|)
operator|)
condition|)
block|{
name|int
name|reg_x
init|=
operator|-
literal|1
decl_stmt|,
name|reg_y
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|word_x
init|=
literal|0
decl_stmt|,
name|word_y
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|y
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* If we haven't done any renumbering, don't 	 make any assumptions.  */
if|if
condition|(
name|reg_renumber
operator|==
literal|0
condition|)
return|return
name|rtx_equal_p
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|SUBREG
condition|)
block|{
name|reg_x
operator|=
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|word_x
operator|=
name|SUBREG_WORD
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_renumber
index|[
name|reg_x
index|]
operator|>=
literal|0
condition|)
block|{
name|reg_x
operator|=
name|reg_renumber
index|[
name|reg_x
index|]
operator|+
name|word_x
expr_stmt|;
name|word_x
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|reg_x
operator|=
name|REGNO
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_renumber
index|[
name|reg_x
index|]
operator|>=
literal|0
condition|)
name|reg_x
operator|=
name|reg_renumber
index|[
name|reg_x
index|]
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
name|reg_y
operator|=
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|y
argument_list|)
argument_list|)
expr_stmt|;
name|word_y
operator|=
name|SUBREG_WORD
argument_list|(
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_renumber
index|[
name|reg_y
index|]
operator|>=
literal|0
condition|)
block|{
name|reg_y
operator|=
name|reg_renumber
index|[
name|reg_y
index|]
expr_stmt|;
name|word_y
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|reg_y
operator|=
name|REGNO
argument_list|(
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_renumber
index|[
name|reg_y
index|]
operator|>=
literal|0
condition|)
name|reg_y
operator|=
name|reg_renumber
index|[
name|reg_y
index|]
expr_stmt|;
block|}
return|return
name|reg_x
operator|>=
literal|0
operator|&&
name|reg_x
operator|==
name|reg_y
operator|&&
name|word_x
operator|==
name|word_y
return|;
block|}
comment|/* Now we have disposed of all the cases       in which different rtx codes can match.  */
if|if
condition|(
name|code
operator|!=
name|GET_CODE
argument_list|(
name|y
argument_list|)
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PC
case|:
case|case
name|CC0
case|:
case|case
name|ADDR_VEC
case|:
case|case
name|ADDR_DIFF_VEC
case|:
return|return
literal|0
return|;
case|case
name|CONST_INT
case|:
return|return
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|==
name|INTVAL
argument_list|(
name|y
argument_list|)
return|;
case|case
name|LABEL_REF
case|:
comment|/* We can't assume nonlocal labels have their following insns yet.  */
if|if
condition|(
name|LABEL_REF_NONLOCAL_P
argument_list|(
name|x
argument_list|)
operator|||
name|LABEL_REF_NONLOCAL_P
argument_list|(
name|y
argument_list|)
condition|)
return|return
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
return|;
comment|/* Two label-refs are equivalent if they point at labels 	 in the same position in the instruction stream.  */
return|return
operator|(
name|next_real_insn
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|next_real_insn
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|SYMBOL_REF
case|:
return|return
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|XSTR
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|CODE_LABEL
case|:
comment|/* If we didn't match EQ equality above, they aren't the same.  */
return|return
literal|0
return|;
default|default:
break|break;
block|}
comment|/* (MULT:SI x y) and (MULT:HI x y) are NOT equivalent.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|y
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* For commutative operations, the RTX match if the operand match in any      order.  Also handle the simple binary and unary cases without a loop.  */
if|if
condition|(
name|code
operator|==
name|EQ
operator|||
name|code
operator|==
name|NE
operator|||
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'c'
condition|)
return|return
operator|(
operator|(
name|rtx_renumbered_equal_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|rtx_renumbered_equal_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|rtx_renumbered_equal_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|rtx_renumbered_equal_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|)
return|;
elseif|else
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'<'
operator|||
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'2'
condition|)
return|return
operator|(
name|rtx_renumbered_equal_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|rtx_renumbered_equal_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'1'
condition|)
return|return
name|rtx_renumbered_equal_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
comment|/* Compare the elements.  If any pair of corresponding elements      fail to match, return 0 for the whole things.  */
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
switch|switch
condition|(
name|fmt
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'w'
case|:
if|if
condition|(
name|XWINT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
name|XWINT
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'i'
case|:
if|if
condition|(
name|XINT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
name|XINT
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'s'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|XSTR
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|XSTR
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'e'
case|:
if|if
condition|(
operator|!
name|rtx_renumbered_equal_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'u'
case|:
if|if
condition|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
name|XEXP
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* fall through.  */
case|case
literal|'0'
case|:
break|break;
case|case
literal|'E'
case|:
if|if
condition|(
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
name|XVECLEN
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
operator|!
name|rtx_renumbered_equal_p
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|XVECEXP
argument_list|(
name|y
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If X is a hard register or equivalent to one or a subregister of one,    return the hard register number.  If X is a pseudo register that was not    assigned a hard register, return the pseudo register number.  Otherwise,    return -1.  Any rtx is valid for X.  */
end_comment

begin_function
name|int
name|true_regnum
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
block|{
if|if
condition|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|reg_renumber
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
operator|>=
literal|0
condition|)
return|return
name|reg_renumber
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
return|;
return|return
name|REGNO
argument_list|(
name|x
argument_list|)
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
name|int
name|base
init|=
name|true_regnum
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|base
operator|>=
literal|0
operator|&&
name|base
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
return|return
name|SUBREG_WORD
argument_list|(
name|x
argument_list|)
operator|+
name|base
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Optimize code of the form:  	for (x = a[i]; x; ...) 	  ... 	for (x = a[i]; x; ...) 	  ...       foo:     Loop optimize will change the above code into  	if (x = a[i]) 	  for (;;) 	     { ...; if (! (x = ...)) break; } 	if (x = a[i]) 	  for (;;) 	     { ...; if (! (x = ...)) break; }       foo:     In general, if the first test fails, the program can branch    directly to `foo' and skip the second try which is doomed to fail.    We run this after loop optimization and before flow analysis.  */
end_comment

begin_comment
comment|/* When comparing the insn patterns, we track the fact that different    pseudo-register numbers may have been used in each computation.    The following array stores an equivalence -- same_regs[I] == J means    that pseudo register I was used in the first set of tests in a context    where J was used in the second set.  We also count the number of such    pending equivalences.  If nonzero, the expressions really aren't the    same.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|same_regs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|num_same_regs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Track any registers modified between the target of the first jump and    the second jump.  They never compare equal.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|modified_regs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Record if memory was modified.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|modified_mem
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Called via note_stores on each insn between the target of the first     branch and the second branch.  It marks any changed registers.  */
end_comment

begin_function
specifier|static
name|void
name|mark_modified_reg
parameter_list|(
name|dest
parameter_list|,
name|x
parameter_list|)
name|rtx
name|dest
decl_stmt|;
name|rtx
name|x
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|int
name|regno
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
condition|)
name|dest
operator|=
name|SUBREG_REG
argument_list|(
name|dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|MEM
condition|)
name|modified_mem
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|!=
name|REG
condition|)
return|return;
name|regno
operator|=
name|REGNO
argument_list|(
name|dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
name|modified_regs
index|[
name|regno
index|]
operator|=
literal|1
expr_stmt|;
else|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
condition|;
name|i
operator|++
control|)
name|modified_regs
index|[
name|regno
operator|+
name|i
index|]
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* F is the first insn in the chain of insns.  */
end_comment

begin_function
name|void
name|thread_jumps
parameter_list|(
name|f
parameter_list|,
name|max_reg
parameter_list|,
name|flag_before_loop
parameter_list|)
name|rtx
name|f
decl_stmt|;
name|int
name|max_reg
decl_stmt|;
name|int
name|flag_before_loop
decl_stmt|;
block|{
comment|/* Basic algorithm is to find a conditional branch,      the label it may branch to, and the branch after      that label.  If the two branches test the same condition,      walk back from both branch paths until the insn patterns      differ, or code labels are hit.  If we make it back to      the target of the first branch, then we know that the first branch      will either always succeed or always fail depending on the relative      senses of the two branches.  So adjust the first branch accordingly      in this case.  */
name|rtx
name|label
decl_stmt|,
name|b1
decl_stmt|,
name|b2
decl_stmt|,
name|t1
decl_stmt|,
name|t2
decl_stmt|;
name|enum
name|rtx_code
name|code1
decl_stmt|,
name|code2
decl_stmt|;
name|rtx
name|b1op0
decl_stmt|,
name|b1op1
decl_stmt|,
name|b2op0
decl_stmt|,
name|b2op1
decl_stmt|;
name|int
name|changed
init|=
literal|1
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
modifier|*
name|all_reset
decl_stmt|;
comment|/* Allocate register tables and quick-reset table.  */
name|modified_regs
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|max_reg
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
name|same_regs
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|max_reg
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|all_reset
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|max_reg
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_reg
condition|;
name|i
operator|++
control|)
name|all_reset
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|changed
condition|)
block|{
name|changed
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|b1
operator|=
name|f
init|;
name|b1
condition|;
name|b1
operator|=
name|NEXT_INSN
argument_list|(
name|b1
argument_list|)
control|)
block|{
comment|/* Get to a candidate branch insn.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|b1
argument_list|)
operator|!=
name|JUMP_INSN
operator|||
operator|!
name|condjump_p
argument_list|(
name|b1
argument_list|)
operator|||
name|simplejump_p
argument_list|(
name|b1
argument_list|)
operator|||
name|JUMP_LABEL
argument_list|(
name|b1
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
name|bzero
argument_list|(
name|modified_regs
argument_list|,
name|max_reg
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
name|modified_mem
operator|=
literal|0
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|all_reset
argument_list|,
operator|(
name|char
operator|*
operator|)
name|same_regs
argument_list|,
name|max_reg
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|num_same_regs
operator|=
literal|0
expr_stmt|;
name|label
operator|=
name|JUMP_LABEL
argument_list|(
name|b1
argument_list|)
expr_stmt|;
comment|/* Look for a branch after the target.  Record any registers and 	     memory modified between the target and the branch.  Stop when we 	     get to a label since we can't know what was changed there.  */
for|for
control|(
name|b2
operator|=
name|NEXT_INSN
argument_list|(
name|label
argument_list|)
init|;
name|b2
condition|;
name|b2
operator|=
name|NEXT_INSN
argument_list|(
name|b2
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|b2
argument_list|)
operator|==
name|CODE_LABEL
condition|)
break|break;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|b2
argument_list|)
operator|==
name|JUMP_INSN
condition|)
block|{
comment|/* If this is an unconditional jump and is the only use of 		     its target label, we can follow it.  */
if|if
condition|(
name|simplejump_p
argument_list|(
name|b2
argument_list|)
operator|&&
name|JUMP_LABEL
argument_list|(
name|b2
argument_list|)
operator|!=
literal|0
operator|&&
name|LABEL_NUSES
argument_list|(
name|JUMP_LABEL
argument_list|(
name|b2
argument_list|)
argument_list|)
operator|==
literal|1
condition|)
block|{
name|b2
operator|=
name|JUMP_LABEL
argument_list|(
name|b2
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
break|break;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|b2
argument_list|)
operator|!=
name|CALL_INSN
operator|&&
name|GET_CODE
argument_list|(
name|b2
argument_list|)
operator|!=
name|INSN
condition|)
continue|continue;
if|if
condition|(
name|GET_CODE
argument_list|(
name|b2
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
name|modified_mem
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|call_used_regs
index|[
name|i
index|]
operator|&&
operator|!
name|fixed_regs
index|[
name|i
index|]
operator|&&
name|i
operator|!=
name|STACK_POINTER_REGNUM
operator|&&
name|i
operator|!=
name|FRAME_POINTER_REGNUM
operator|&&
name|i
operator|!=
name|HARD_FRAME_POINTER_REGNUM
operator|&&
name|i
operator|!=
name|ARG_POINTER_REGNUM
condition|)
name|modified_regs
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
block|}
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|b2
argument_list|)
argument_list|,
name|mark_modified_reg
argument_list|)
expr_stmt|;
block|}
comment|/* Check the next candidate branch insn from the label 	     of the first.  */
if|if
condition|(
name|b2
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|b2
argument_list|)
operator|!=
name|JUMP_INSN
operator|||
name|b2
operator|==
name|b1
operator|||
operator|!
name|condjump_p
argument_list|(
name|b2
argument_list|)
operator|||
name|simplejump_p
argument_list|(
name|b2
argument_list|)
condition|)
continue|continue;
comment|/* Get the comparison codes and operands, reversing the 	     codes if appropriate.  If we don't have comparison codes, 	     we can't do anything.  */
name|b1op0
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|b1
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|b1op1
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|b1
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|code1
operator|=
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|b1
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|b1
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
name|pc_rtx
condition|)
name|code1
operator|=
name|reverse_condition
argument_list|(
name|code1
argument_list|)
expr_stmt|;
name|b2op0
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|b2
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|b2op1
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|b2
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|code2
operator|=
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|b2
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|b2
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
name|pc_rtx
condition|)
name|code2
operator|=
name|reverse_condition
argument_list|(
name|code2
argument_list|)
expr_stmt|;
comment|/* If they test the same things and knowing that B1 branches 	     tells us whether or not B2 branches, check if we 	     can thread the branch.  */
if|if
condition|(
name|rtx_equal_for_thread_p
argument_list|(
name|b1op0
argument_list|,
name|b2op0
argument_list|,
name|b2
argument_list|)
operator|&&
name|rtx_equal_for_thread_p
argument_list|(
name|b1op1
argument_list|,
name|b2op1
argument_list|,
name|b2
argument_list|)
operator|&&
operator|(
name|comparison_dominates_p
argument_list|(
name|code1
argument_list|,
name|code2
argument_list|)
operator|||
operator|(
name|comparison_dominates_p
argument_list|(
name|code1
argument_list|,
name|reverse_condition
argument_list|(
name|code2
argument_list|)
argument_list|)
operator|&&
name|can_reverse_comparison_p
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|b1
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|b1
argument_list|)
operator|)
operator|)
condition|)
block|{
name|t1
operator|=
name|prev_nonnote_insn
argument_list|(
name|b1
argument_list|)
expr_stmt|;
name|t2
operator|=
name|prev_nonnote_insn
argument_list|(
name|b2
argument_list|)
expr_stmt|;
while|while
condition|(
name|t1
operator|!=
literal|0
operator|&&
name|t2
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|t2
operator|==
name|label
condition|)
block|{
comment|/* We have reached the target of the first branch. 		         If there are no pending register equivalents, 			 we know that this branch will either always 			 succeed (if the senses of the two branches are 			 the same) or always fail (if not).  */
name|rtx
name|new_label
decl_stmt|;
if|if
condition|(
name|num_same_regs
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
name|comparison_dominates_p
argument_list|(
name|code1
argument_list|,
name|code2
argument_list|)
condition|)
name|new_label
operator|=
name|JUMP_LABEL
argument_list|(
name|b2
argument_list|)
expr_stmt|;
else|else
name|new_label
operator|=
name|get_label_after
argument_list|(
name|b2
argument_list|)
expr_stmt|;
if|if
condition|(
name|JUMP_LABEL
argument_list|(
name|b1
argument_list|)
operator|!=
name|new_label
condition|)
block|{
name|rtx
name|prev
init|=
name|PREV_INSN
argument_list|(
name|new_label
argument_list|)
decl_stmt|;
if|if
condition|(
name|flag_before_loop
operator|&&
name|GET_CODE
argument_list|(
name|prev
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|prev
argument_list|)
operator|==
name|NOTE_INSN_LOOP_BEG
condition|)
block|{
comment|/* Don't thread to the loop label.  If a loop 				 label is reused, loop optimization will 				 be disabled for that loop.  */
name|new_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|emit_label_after
argument_list|(
name|new_label
argument_list|,
name|PREV_INSN
argument_list|(
name|prev
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|changed
operator||=
name|redirect_jump
argument_list|(
name|b1
argument_list|,
name|new_label
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
comment|/* If either of these is not a normal insn (it might be 		     a JUMP_INSN, CALL_INSN, or CODE_LABEL) we fail.  (NOTEs 		     have already been skipped above.)  Similarly, fail 		     if the insns are different.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|t1
argument_list|)
operator|!=
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|t2
argument_list|)
operator|!=
name|INSN
operator|||
name|recog_memoized
argument_list|(
name|t1
argument_list|)
operator|!=
name|recog_memoized
argument_list|(
name|t2
argument_list|)
operator|||
operator|!
name|rtx_equal_for_thread_p
argument_list|(
name|PATTERN
argument_list|(
name|t1
argument_list|)
argument_list|,
name|PATTERN
argument_list|(
name|t2
argument_list|)
argument_list|,
name|t2
argument_list|)
condition|)
break|break;
name|t1
operator|=
name|prev_nonnote_insn
argument_list|(
name|t1
argument_list|)
expr_stmt|;
name|t2
operator|=
name|prev_nonnote_insn
argument_list|(
name|t2
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This is like RTX_EQUAL_P except that it knows about our handling of    possibly equivalent registers and knows to consider volatile and    modified objects as not equal.        YINSN is the insn containing Y.  */
end_comment

begin_function
name|int
name|rtx_equal_for_thread_p
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|yinsn
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|y
decl_stmt|;
name|rtx
name|yinsn
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
specifier|register
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* Rtx's of different codes cannot be equal.  */
if|if
condition|(
name|code
operator|!=
name|GET_CODE
argument_list|(
name|y
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* (MULT:SI x y) and (MULT:HI x y) are NOT equivalent.      (REG:SI x) and (REG:HI x) are NOT equivalent.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|y
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* For floating-point, consider everything unequal.  This is a bit      pessimistic, but this pass would only rarely do anything for FP      anyway.  */
if|if
condition|(
name|TARGET_FLOAT_FORMAT
operator|==
name|IEEE_FLOAT_FORMAT
operator|&&
name|FLOAT_MODE_P
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|&&
operator|!
name|flag_fast_math
condition|)
return|return
literal|0
return|;
comment|/* For commutative operations, the RTX match if the operand match in any      order.  Also handle the simple binary and unary cases without a loop.  */
if|if
condition|(
name|code
operator|==
name|EQ
operator|||
name|code
operator|==
name|NE
operator|||
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'c'
condition|)
return|return
operator|(
operator|(
name|rtx_equal_for_thread_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|,
name|yinsn
argument_list|)
operator|&&
name|rtx_equal_for_thread_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
argument_list|,
name|yinsn
argument_list|)
operator|)
operator|||
operator|(
name|rtx_equal_for_thread_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
argument_list|,
name|yinsn
argument_list|)
operator|&&
name|rtx_equal_for_thread_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|,
name|yinsn
argument_list|)
operator|)
operator|)
return|;
elseif|else
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'<'
operator|||
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'2'
condition|)
return|return
operator|(
name|rtx_equal_for_thread_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|,
name|yinsn
argument_list|)
operator|&&
name|rtx_equal_for_thread_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
argument_list|,
name|yinsn
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'1'
condition|)
return|return
name|rtx_equal_for_thread_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|,
name|yinsn
argument_list|)
return|;
comment|/* Handle special-cases first.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|REG
case|:
if|if
condition|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|==
name|REGNO
argument_list|(
name|y
argument_list|)
operator|&&
operator|!
name|modified_regs
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
condition|)
return|return
literal|1
return|;
comment|/* If neither is user variable or hard register, check for possible 	 equivalence.  */
if|if
condition|(
name|REG_USERVAR_P
argument_list|(
name|x
argument_list|)
operator|||
name|REG_USERVAR_P
argument_list|(
name|y
argument_list|)
operator|||
name|REGNO
argument_list|(
name|x
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|||
name|REGNO
argument_list|(
name|y
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|same_regs
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
operator|==
operator|-
literal|1
condition|)
block|{
name|same_regs
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
operator|=
name|REGNO
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|num_same_regs
operator|++
expr_stmt|;
comment|/* If this is the first time we are seeing a register on the `Y' 	     side, see if it is the last use.  If not, we can't thread the  	     jump, so mark it as not equivalent.  */
if|if
condition|(
name|REGNO_LAST_UID
argument_list|(
name|REGNO
argument_list|(
name|y
argument_list|)
argument_list|)
operator|!=
name|INSN_UID
argument_list|(
name|yinsn
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
else|else
return|return
operator|(
name|same_regs
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
operator|==
name|REGNO
argument_list|(
name|y
argument_list|)
operator|)
return|;
break|break;
case|case
name|MEM
case|:
comment|/* If memory modified or either volatile, not equivalent. 	 Else, check address.  */
if|if
condition|(
name|modified_mem
operator|||
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
operator|||
name|MEM_VOLATILE_P
argument_list|(
name|y
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|rtx_equal_for_thread_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|,
name|yinsn
argument_list|)
return|;
case|case
name|ASM_INPUT
case|:
if|if
condition|(
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
operator|||
name|MEM_VOLATILE_P
argument_list|(
name|y
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
name|SET
case|:
comment|/* Cancel a pending `same_regs' if setting equivalenced registers. 	 Then process source.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|y
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
if|if
condition|(
name|same_regs
index|[
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
index|]
operator|==
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|y
argument_list|)
argument_list|)
condition|)
block|{
name|same_regs
index|[
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|num_same_regs
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|y
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|rtx_equal_for_thread_p
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
name|SET_DEST
argument_list|(
name|y
argument_list|)
argument_list|,
name|yinsn
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
return|return
name|rtx_equal_for_thread_p
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|SET_SRC
argument_list|(
name|y
argument_list|)
argument_list|,
name|yinsn
argument_list|)
return|;
case|case
name|LABEL_REF
case|:
return|return
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|SYMBOL_REF
case|:
return|return
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|XSTR
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
return|;
default|default:
break|break;
block|}
if|if
condition|(
name|x
operator|==
name|y
condition|)
return|return
literal|1
return|;
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
switch|switch
condition|(
name|fmt
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'w'
case|:
if|if
condition|(
name|XWINT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
name|XWINT
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'n'
case|:
case|case
literal|'i'
case|:
if|if
condition|(
name|XINT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
name|XINT
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'V'
case|:
case|case
literal|'E'
case|:
comment|/* Two vectors must have the same length.  */
if|if
condition|(
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
name|XVECLEN
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* And the corresponding elements must match.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|rtx_equal_for_thread_p
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|XVECEXP
argument_list|(
name|y
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|yinsn
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'e'
case|:
if|if
condition|(
name|rtx_equal_for_thread_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
argument_list|,
name|yinsn
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'S'
case|:
case|case
literal|'s'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|XSTR
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|XSTR
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'u'
case|:
comment|/* These are just backpointers, so they don't matter.  */
break|break;
case|case
literal|'0'
case|:
break|break;
comment|/* It is believed that rtx's at this level will never 	     contain anything but integers and other rtx's, 	     except for within LABEL_REFs and SYMBOL_REFs.  */
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_cc0
end_ifndef

begin_comment
comment|/* Return the insn that NEW can be safely inserted in front of starting at    the jump insn INSN.  Return 0 if it is not safe to do this jump    optimization.  Note that NEW must contain a single set. */
end_comment

begin_function
specifier|static
name|rtx
name|find_insert_position
parameter_list|(
name|insn
parameter_list|,
name|new
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|rtx
name|new
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|rtx
name|prev
decl_stmt|;
comment|/* If NEW does not clobber, it is safe to insert NEW before INSN. */
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|new
argument_list|)
argument_list|)
operator|!=
name|PARALLEL
condition|)
return|return
name|insn
return|;
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|new
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|new
argument_list|)
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|CLOBBER
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|new
argument_list|)
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn
argument_list|)
condition|)
break|break;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
return|return
name|insn
return|;
comment|/* There is a good chance that the previous insn PREV sets the thing      being clobbered (often the CC in a hard reg).  If PREV does not      use what NEW sets, we can insert NEW before PREV. */
name|prev
operator|=
name|prev_active_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|new
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|new
argument_list|)
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|CLOBBER
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|new
argument_list|)
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn
argument_list|)
operator|&&
operator|!
name|modified_in_p
argument_list|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|new
argument_list|)
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|prev
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|reg_mentioned_p
argument_list|(
name|SET_DEST
argument_list|(
name|single_set
argument_list|(
name|new
argument_list|)
argument_list|)
argument_list|,
name|prev
argument_list|)
condition|?
literal|0
else|:
name|prev
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !HAVE_cc0 */
end_comment

end_unit

