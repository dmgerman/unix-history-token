begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Inline functions for tree-flow.h    Copyright (C) 2001, 2003, 2005, 2006 Free Software Foundation, Inc.    Contributed by Diego Novillo<dnovillo@redhat.com>  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_TREE_FLOW_INLINE_H
end_ifndef

begin_define
define|#
directive|define
name|_TREE_FLOW_INLINE_H
value|1
end_define

begin_comment
comment|/* Inline functions for manipulating various data structures defined in    tree-flow.h.  See tree-flow.h for documentation.  */
end_comment

begin_comment
comment|/* Initialize the hashtable iterator HTI to point to hashtable TABLE */
end_comment

begin_function
specifier|static
specifier|inline
name|void
modifier|*
name|first_htab_element
parameter_list|(
name|htab_iterator
modifier|*
name|hti
parameter_list|,
name|htab_t
name|table
parameter_list|)
block|{
name|hti
operator|->
name|htab
operator|=
name|table
expr_stmt|;
name|hti
operator|->
name|slot
operator|=
name|table
operator|->
name|entries
expr_stmt|;
name|hti
operator|->
name|limit
operator|=
name|hti
operator|->
name|slot
operator|+
name|htab_size
argument_list|(
name|table
argument_list|)
expr_stmt|;
do|do
block|{
name|PTR
name|x
init|=
operator|*
operator|(
name|hti
operator|->
name|slot
operator|)
decl_stmt|;
if|if
condition|(
name|x
operator|!=
name|HTAB_EMPTY_ENTRY
operator|&&
name|x
operator|!=
name|HTAB_DELETED_ENTRY
condition|)
break|break;
block|}
do|while
condition|(
operator|++
operator|(
name|hti
operator|->
name|slot
operator|)
operator|<
name|hti
operator|->
name|limit
condition|)
do|;
if|if
condition|(
name|hti
operator|->
name|slot
operator|<
name|hti
operator|->
name|limit
condition|)
return|return
operator|*
operator|(
name|hti
operator|->
name|slot
operator|)
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Return current non-empty/deleted slot of the hashtable pointed to by HTI,    or NULL if we have  reached the end.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|end_htab_p
parameter_list|(
name|htab_iterator
modifier|*
name|hti
parameter_list|)
block|{
if|if
condition|(
name|hti
operator|->
name|slot
operator|>=
name|hti
operator|->
name|limit
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Advance the hashtable iterator pointed to by HTI to the next element of the    hashtable.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
modifier|*
name|next_htab_element
parameter_list|(
name|htab_iterator
modifier|*
name|hti
parameter_list|)
block|{
while|while
condition|(
operator|++
operator|(
name|hti
operator|->
name|slot
operator|)
operator|<
name|hti
operator|->
name|limit
condition|)
block|{
name|PTR
name|x
init|=
operator|*
operator|(
name|hti
operator|->
name|slot
operator|)
decl_stmt|;
if|if
condition|(
name|x
operator|!=
name|HTAB_EMPTY_ENTRY
operator|&&
name|x
operator|!=
name|HTAB_DELETED_ENTRY
condition|)
return|return
name|x
return|;
block|}
empty_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Initialize ITER to point to the first referenced variable in the    referenced_vars hashtable, and return that variable.  */
end_comment

begin_function
specifier|static
specifier|inline
name|tree
name|first_referenced_var
parameter_list|(
name|referenced_var_iterator
modifier|*
name|iter
parameter_list|)
block|{
name|struct
name|int_tree_map
modifier|*
name|itm
decl_stmt|;
name|itm
operator|=
operator|(
expr|struct
name|int_tree_map
operator|*
operator|)
name|first_htab_element
argument_list|(
operator|&
name|iter
operator|->
name|hti
argument_list|,
name|referenced_vars
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|itm
condition|)
return|return
name|NULL
return|;
return|return
name|itm
operator|->
name|to
return|;
block|}
end_function

begin_comment
comment|/* Return true if we have hit the end of the referenced variables ITER is    iterating through.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|end_referenced_vars_p
parameter_list|(
name|referenced_var_iterator
modifier|*
name|iter
parameter_list|)
block|{
return|return
name|end_htab_p
argument_list|(
operator|&
name|iter
operator|->
name|hti
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Make ITER point to the next referenced_var in the referenced_var hashtable,    and return that variable.  */
end_comment

begin_function
specifier|static
specifier|inline
name|tree
name|next_referenced_var
parameter_list|(
name|referenced_var_iterator
modifier|*
name|iter
parameter_list|)
block|{
name|struct
name|int_tree_map
modifier|*
name|itm
decl_stmt|;
name|itm
operator|=
operator|(
expr|struct
name|int_tree_map
operator|*
operator|)
name|next_htab_element
argument_list|(
operator|&
name|iter
operator|->
name|hti
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|itm
condition|)
return|return
name|NULL
return|;
return|return
name|itm
operator|->
name|to
return|;
block|}
end_function

begin_comment
comment|/* Fill up VEC with the variables in the referenced vars hashtable.  */
end_comment

begin_decl_stmt
specifier|static
specifier|inline
name|void
name|fill_referenced_var_vec
argument_list|(
name|VEC
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|)
operator|*
operator|*
name|vec
argument_list|)
block|{
name|referenced_var_iterator
name|rvi
decl_stmt|;
name|tree
name|var
decl_stmt|;
operator|*
name|vec
operator|=
name|NULL
expr_stmt|;
name|FOR_EACH_REFERENCED_VAR
argument_list|(
argument|var
argument_list|,
argument|rvi
argument_list|)
name|VEC_safe_push
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
operator|*
name|vec
argument_list|,
name|var
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* Return the variable annotation for T, which must be a _DECL node.    Return NULL if the variable annotation doesn't already exist.  */
end_comment

begin_function
specifier|static
specifier|inline
name|var_ann_t
name|var_ann
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|DECL_P
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|FUNCTION_DECL
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|t
operator|->
name|common
operator|.
name|ann
operator|||
name|t
operator|->
name|common
operator|.
name|ann
operator|->
name|common
operator|.
name|type
operator|==
name|VAR_ANN
argument_list|)
expr_stmt|;
return|return
operator|(
name|var_ann_t
operator|)
name|t
operator|->
name|common
operator|.
name|ann
return|;
block|}
end_function

begin_comment
comment|/* Return the variable annotation for T, which must be a _DECL node.    Create the variable annotation if it doesn't exist.  */
end_comment

begin_function
specifier|static
specifier|inline
name|var_ann_t
name|get_var_ann
parameter_list|(
name|tree
name|var
parameter_list|)
block|{
name|var_ann_t
name|ann
init|=
name|var_ann
argument_list|(
name|var
argument_list|)
decl_stmt|;
return|return
operator|(
name|ann
operator|)
condition|?
name|ann
else|:
name|create_var_ann
argument_list|(
name|var
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the function annotation for T, which must be a FUNCTION_DECL node.    Return NULL if the function annotation doesn't already exist.  */
end_comment

begin_function
specifier|static
specifier|inline
name|function_ann_t
name|function_ann
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|FUNCTION_DECL
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|t
operator|->
name|common
operator|.
name|ann
operator|||
name|t
operator|->
name|common
operator|.
name|ann
operator|->
name|common
operator|.
name|type
operator|==
name|FUNCTION_ANN
argument_list|)
expr_stmt|;
return|return
operator|(
name|function_ann_t
operator|)
name|t
operator|->
name|common
operator|.
name|ann
return|;
block|}
end_function

begin_comment
comment|/* Return the function annotation for T, which must be a FUNCTION_DECL node.    Create the function annotation if it doesn't exist.  */
end_comment

begin_function
specifier|static
specifier|inline
name|function_ann_t
name|get_function_ann
parameter_list|(
name|tree
name|var
parameter_list|)
block|{
name|function_ann_t
name|ann
init|=
name|function_ann
argument_list|(
name|var
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|var
operator|->
name|common
operator|.
name|ann
operator|||
name|var
operator|->
name|common
operator|.
name|ann
operator|->
name|common
operator|.
name|type
operator|==
name|FUNCTION_ANN
argument_list|)
expr_stmt|;
return|return
operator|(
name|ann
operator|)
condition|?
name|ann
else|:
name|create_function_ann
argument_list|(
name|var
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the statement annotation for T, which must be a statement    node.  Return NULL if the statement annotation doesn't exist.  */
end_comment

begin_function
specifier|static
specifier|inline
name|stmt_ann_t
name|stmt_ann
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
name|gcc_assert
argument_list|(
name|is_gimple_stmt
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|gcc_assert
argument_list|(
operator|!
name|t
operator|->
name|common
operator|.
name|ann
operator|||
name|t
operator|->
name|common
operator|.
name|ann
operator|->
name|common
operator|.
name|type
operator|==
name|STMT_ANN
argument_list|)
expr_stmt|;
return|return
operator|(
name|stmt_ann_t
operator|)
name|t
operator|->
name|common
operator|.
name|ann
return|;
block|}
end_function

begin_comment
comment|/* Return the statement annotation for T, which must be a statement    node.  Create the statement annotation if it doesn't exist.  */
end_comment

begin_function
specifier|static
specifier|inline
name|stmt_ann_t
name|get_stmt_ann
parameter_list|(
name|tree
name|stmt
parameter_list|)
block|{
name|stmt_ann_t
name|ann
init|=
name|stmt_ann
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
return|return
operator|(
name|ann
operator|)
condition|?
name|ann
else|:
name|create_stmt_ann
argument_list|(
name|stmt
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the annotation type for annotation ANN.  */
end_comment

begin_function
specifier|static
specifier|inline
name|enum
name|tree_ann_type
name|ann_type
parameter_list|(
name|tree_ann_t
name|ann
parameter_list|)
block|{
return|return
name|ann
operator|->
name|common
operator|.
name|type
return|;
block|}
end_function

begin_comment
comment|/* Return the basic block for statement T.  */
end_comment

begin_function
specifier|static
specifier|inline
name|basic_block
name|bb_for_stmt
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|stmt_ann_t
name|ann
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|PHI_NODE
condition|)
return|return
name|PHI_BB
argument_list|(
name|t
argument_list|)
return|;
name|ann
operator|=
name|stmt_ann
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|ann
condition|?
name|ann
operator|->
name|bb
else|:
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Return the may_aliases varray for variable VAR, or NULL if it has    no may aliases.  */
end_comment

begin_expr_stmt
specifier|static
specifier|inline
name|VEC
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|)
operator|*
name|may_aliases
argument_list|(
argument|tree var
argument_list|)
block|{
name|var_ann_t
name|ann
operator|=
name|var_ann
argument_list|(
name|var
argument_list|)
block|;
return|return
name|ann
condition|?
name|ann
operator|->
name|may_aliases
else|:
name|NULL
return|;
block|}
end_expr_stmt

begin_comment
comment|/* Return the line number for EXPR, or return -1 if we have no line    number information for it.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|get_lineno
parameter_list|(
name|tree
name|expr
parameter_list|)
block|{
if|if
condition|(
name|expr
operator|==
name|NULL_TREE
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|COMPOUND_EXPR
condition|)
name|expr
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|EXPR_HAS_LOCATION
argument_list|(
name|expr
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|EXPR_LINENO
argument_list|(
name|expr
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the file name for EXPR, or return "???" if we have no    filename information.  */
end_comment

begin_function
specifier|static
specifier|inline
specifier|const
name|char
modifier|*
name|get_filename
parameter_list|(
name|tree
name|expr
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
if|if
condition|(
name|expr
operator|==
name|NULL_TREE
condition|)
return|return
literal|"???"
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|COMPOUND_EXPR
condition|)
name|expr
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|EXPR_HAS_LOCATION
argument_list|(
name|expr
argument_list|)
operator|&&
operator|(
name|filename
operator|=
name|EXPR_FILENAME
argument_list|(
name|expr
argument_list|)
operator|)
condition|)
return|return
name|filename
return|;
else|else
return|return
literal|"???"
return|;
block|}
end_function

begin_comment
comment|/* Return true if T is a noreturn call.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|noreturn_call_p
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|tree
name|call
init|=
name|get_call_expr_in
argument_list|(
name|t
argument_list|)
decl_stmt|;
return|return
name|call
operator|!=
literal|0
operator|&&
operator|(
name|call_expr_flags
argument_list|(
name|call
argument_list|)
operator|&
name|ECF_NORETURN
operator|)
operator|!=
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Mark statement T as modified.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|mark_stmt_modified
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|stmt_ann_t
name|ann
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|PHI_NODE
condition|)
return|return;
name|ann
operator|=
name|stmt_ann
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|ann
operator|==
name|NULL
condition|)
name|ann
operator|=
name|create_stmt_ann
argument_list|(
name|t
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|noreturn_call_p
argument_list|(
name|t
argument_list|)
condition|)
name|VEC_safe_push
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|,
name|modified_noreturn_calls
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|ann
operator|->
name|modified
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Mark statement T as modified, and update it.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|update_stmt
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|PHI_NODE
condition|)
return|return;
name|mark_stmt_modified
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|update_stmt_operands
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|update_stmt_if_modified
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
if|if
condition|(
name|stmt_modified_p
argument_list|(
name|t
argument_list|)
condition|)
name|update_stmt_operands
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return true if T is marked as modified, false otherwise.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|stmt_modified_p
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|stmt_ann_t
name|ann
init|=
name|stmt_ann
argument_list|(
name|t
argument_list|)
decl_stmt|;
comment|/* Note that if the statement doesn't yet have an annotation, we consider it      modified.  This will force the next call to update_stmt_operands to scan       the statement.  */
return|return
name|ann
condition|?
name|ann
operator|->
name|modified
else|:
name|true
return|;
block|}
end_function

begin_comment
comment|/* Delink an immediate_uses node from its chain.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|delink_imm_use
parameter_list|(
name|ssa_use_operand_t
modifier|*
name|linknode
parameter_list|)
block|{
comment|/* Return if this node is not in a list.  */
if|if
condition|(
name|linknode
operator|->
name|prev
operator|==
name|NULL
condition|)
return|return;
name|linknode
operator|->
name|prev
operator|->
name|next
operator|=
name|linknode
operator|->
name|next
expr_stmt|;
name|linknode
operator|->
name|next
operator|->
name|prev
operator|=
name|linknode
operator|->
name|prev
expr_stmt|;
name|linknode
operator|->
name|prev
operator|=
name|NULL
expr_stmt|;
name|linknode
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Link ssa_imm_use node LINKNODE into the chain for LIST.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|link_imm_use_to_list
parameter_list|(
name|ssa_use_operand_t
modifier|*
name|linknode
parameter_list|,
name|ssa_use_operand_t
modifier|*
name|list
parameter_list|)
block|{
comment|/* Link the new node at the head of the list.  If we are in the process of       traversing the list, we won't visit any new nodes added to it.  */
name|linknode
operator|->
name|prev
operator|=
name|list
expr_stmt|;
name|linknode
operator|->
name|next
operator|=
name|list
operator|->
name|next
expr_stmt|;
name|list
operator|->
name|next
operator|->
name|prev
operator|=
name|linknode
expr_stmt|;
name|list
operator|->
name|next
operator|=
name|linknode
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Link ssa_imm_use node LINKNODE into the chain for DEF.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|link_imm_use
parameter_list|(
name|ssa_use_operand_t
modifier|*
name|linknode
parameter_list|,
name|tree
name|def
parameter_list|)
block|{
name|ssa_use_operand_t
modifier|*
name|root
decl_stmt|;
if|if
condition|(
operator|!
name|def
operator|||
name|TREE_CODE
argument_list|(
name|def
argument_list|)
operator|!=
name|SSA_NAME
condition|)
name|linknode
operator|->
name|prev
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|root
operator|=
operator|&
operator|(
name|SSA_NAME_IMM_USE_NODE
argument_list|(
name|def
argument_list|)
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
if|if
condition|(
name|linknode
operator|->
name|use
condition|)
name|gcc_assert
argument_list|(
operator|*
operator|(
name|linknode
operator|->
name|use
operator|)
operator|==
name|def
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|link_imm_use_to_list
argument_list|(
name|linknode
argument_list|,
name|root
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Set the value of a use pointed to by USE to VAL.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|set_ssa_use_from_ptr
parameter_list|(
name|use_operand_p
name|use
parameter_list|,
name|tree
name|val
parameter_list|)
block|{
name|delink_imm_use
argument_list|(
name|use
argument_list|)
expr_stmt|;
operator|*
operator|(
name|use
operator|->
name|use
operator|)
operator|=
name|val
expr_stmt|;
name|link_imm_use
argument_list|(
name|use
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Link ssa_imm_use node LINKNODE into the chain for DEF, with use occurring     in STMT.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|link_imm_use_stmt
parameter_list|(
name|ssa_use_operand_t
modifier|*
name|linknode
parameter_list|,
name|tree
name|def
parameter_list|,
name|tree
name|stmt
parameter_list|)
block|{
if|if
condition|(
name|stmt
condition|)
name|link_imm_use
argument_list|(
name|linknode
argument_list|,
name|def
argument_list|)
expr_stmt|;
else|else
name|link_imm_use
argument_list|(
name|linknode
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|linknode
operator|->
name|stmt
operator|=
name|stmt
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Relink a new node in place of an old node in the list.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|relink_imm_use
parameter_list|(
name|ssa_use_operand_t
modifier|*
name|node
parameter_list|,
name|ssa_use_operand_t
modifier|*
name|old
parameter_list|)
block|{
comment|/* The node one had better be in the same list.  */
name|gcc_assert
argument_list|(
operator|*
operator|(
name|old
operator|->
name|use
operator|)
operator|==
operator|*
operator|(
name|node
operator|->
name|use
operator|)
argument_list|)
expr_stmt|;
name|node
operator|->
name|prev
operator|=
name|old
operator|->
name|prev
expr_stmt|;
name|node
operator|->
name|next
operator|=
name|old
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|old
operator|->
name|prev
condition|)
block|{
name|old
operator|->
name|prev
operator|->
name|next
operator|=
name|node
expr_stmt|;
name|old
operator|->
name|next
operator|->
name|prev
operator|=
name|node
expr_stmt|;
comment|/* Remove the old node from the list.  */
name|old
operator|->
name|prev
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Relink ssa_imm_use node LINKNODE into the chain for OLD, with use occurring     in STMT.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|relink_imm_use_stmt
parameter_list|(
name|ssa_use_operand_t
modifier|*
name|linknode
parameter_list|,
name|ssa_use_operand_t
modifier|*
name|old
parameter_list|,
name|tree
name|stmt
parameter_list|)
block|{
if|if
condition|(
name|stmt
condition|)
name|relink_imm_use
argument_list|(
name|linknode
argument_list|,
name|old
argument_list|)
expr_stmt|;
else|else
name|link_imm_use
argument_list|(
name|linknode
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|linknode
operator|->
name|stmt
operator|=
name|stmt
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return true is IMM has reached the end of the immediate use list.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|end_readonly_imm_use_p
parameter_list|(
name|imm_use_iterator
modifier|*
name|imm
parameter_list|)
block|{
return|return
operator|(
name|imm
operator|->
name|imm_use
operator|==
name|imm
operator|->
name|end_p
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Initialize iterator IMM to process the list for VAR.  */
end_comment

begin_function
specifier|static
specifier|inline
name|use_operand_p
name|first_readonly_imm_use
parameter_list|(
name|imm_use_iterator
modifier|*
name|imm
parameter_list|,
name|tree
name|var
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|var
argument_list|)
operator|==
name|SSA_NAME
argument_list|)
expr_stmt|;
name|imm
operator|->
name|end_p
operator|=
operator|&
operator|(
name|SSA_NAME_IMM_USE_NODE
argument_list|(
name|var
argument_list|)
operator|)
expr_stmt|;
name|imm
operator|->
name|imm_use
operator|=
name|imm
operator|->
name|end_p
operator|->
name|next
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
name|imm
operator|->
name|iter_node
operator|.
name|next
operator|=
name|imm
operator|->
name|imm_use
operator|->
name|next
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|end_readonly_imm_use_p
argument_list|(
name|imm
argument_list|)
condition|)
return|return
name|NULL_USE_OPERAND_P
return|;
return|return
name|imm
operator|->
name|imm_use
return|;
block|}
end_function

begin_comment
comment|/* Bump IMM to the next use in the list.  */
end_comment

begin_function
specifier|static
specifier|inline
name|use_operand_p
name|next_readonly_imm_use
parameter_list|(
name|imm_use_iterator
modifier|*
name|imm
parameter_list|)
block|{
name|use_operand_p
name|old
init|=
name|imm
operator|->
name|imm_use
decl_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
comment|/* If this assertion fails, it indicates the 'next' pointer has changed       since we the last bump.  This indicates that the list is being modified      via stmt changes, or SET_USE, or somesuch thing, and you need to be      using the SAFE version of the iterator.  */
name|gcc_assert
argument_list|(
name|imm
operator|->
name|iter_node
operator|.
name|next
operator|==
name|old
operator|->
name|next
argument_list|)
expr_stmt|;
name|imm
operator|->
name|iter_node
operator|.
name|next
operator|=
name|old
operator|->
name|next
operator|->
name|next
expr_stmt|;
endif|#
directive|endif
name|imm
operator|->
name|imm_use
operator|=
name|old
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|end_readonly_imm_use_p
argument_list|(
name|imm
argument_list|)
condition|)
return|return
name|old
return|;
return|return
name|imm
operator|->
name|imm_use
return|;
block|}
end_function

begin_comment
comment|/* Return true if VAR has no uses.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|has_zero_uses
parameter_list|(
name|tree
name|var
parameter_list|)
block|{
name|ssa_use_operand_t
modifier|*
name|ptr
decl_stmt|;
name|ptr
operator|=
operator|&
operator|(
name|SSA_NAME_IMM_USE_NODE
argument_list|(
name|var
argument_list|)
operator|)
expr_stmt|;
comment|/* A single use means there is no items in the list.  */
return|return
operator|(
name|ptr
operator|==
name|ptr
operator|->
name|next
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if VAR has a single use.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|has_single_use
parameter_list|(
name|tree
name|var
parameter_list|)
block|{
name|ssa_use_operand_t
modifier|*
name|ptr
decl_stmt|;
name|ptr
operator|=
operator|&
operator|(
name|SSA_NAME_IMM_USE_NODE
argument_list|(
name|var
argument_list|)
operator|)
expr_stmt|;
comment|/* A single use means there is one item in the list.  */
return|return
operator|(
name|ptr
operator|!=
name|ptr
operator|->
name|next
operator|&&
name|ptr
operator|==
name|ptr
operator|->
name|next
operator|->
name|next
operator|)
return|;
block|}
end_function

begin_comment
comment|/* If VAR has only a single immediate use, return true, and set USE_P and STMT    to the use pointer and stmt of occurrence.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|single_imm_use
parameter_list|(
name|tree
name|var
parameter_list|,
name|use_operand_p
modifier|*
name|use_p
parameter_list|,
name|tree
modifier|*
name|stmt
parameter_list|)
block|{
name|ssa_use_operand_t
modifier|*
name|ptr
decl_stmt|;
name|ptr
operator|=
operator|&
operator|(
name|SSA_NAME_IMM_USE_NODE
argument_list|(
name|var
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|!=
name|ptr
operator|->
name|next
operator|&&
name|ptr
operator|==
name|ptr
operator|->
name|next
operator|->
name|next
condition|)
block|{
operator|*
name|use_p
operator|=
name|ptr
operator|->
name|next
expr_stmt|;
operator|*
name|stmt
operator|=
name|ptr
operator|->
name|next
operator|->
name|stmt
expr_stmt|;
return|return
name|true
return|;
block|}
operator|*
name|use_p
operator|=
name|NULL_USE_OPERAND_P
expr_stmt|;
operator|*
name|stmt
operator|=
name|NULL_TREE
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Return the number of immediate uses of VAR.  */
end_comment

begin_function
specifier|static
specifier|inline
name|unsigned
name|int
name|num_imm_uses
parameter_list|(
name|tree
name|var
parameter_list|)
block|{
name|ssa_use_operand_t
modifier|*
name|ptr
decl_stmt|,
modifier|*
name|start
decl_stmt|;
name|unsigned
name|int
name|num
decl_stmt|;
name|start
operator|=
operator|&
operator|(
name|SSA_NAME_IMM_USE_NODE
argument_list|(
name|var
argument_list|)
operator|)
expr_stmt|;
name|num
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ptr
operator|=
name|start
operator|->
name|next
init|;
name|ptr
operator|!=
name|start
condition|;
name|ptr
operator|=
name|ptr
operator|->
name|next
control|)
name|num
operator|++
expr_stmt|;
return|return
name|num
return|;
block|}
end_function

begin_comment
comment|/* Return the tree pointer to by USE.  */
end_comment

begin_function
specifier|static
specifier|inline
name|tree
name|get_use_from_ptr
parameter_list|(
name|use_operand_p
name|use
parameter_list|)
block|{
return|return
operator|*
operator|(
name|use
operator|->
name|use
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the tree pointer to by DEF.  */
end_comment

begin_function
specifier|static
specifier|inline
name|tree
name|get_def_from_ptr
parameter_list|(
name|def_operand_p
name|def
parameter_list|)
block|{
return|return
operator|*
name|def
return|;
block|}
end_function

begin_comment
comment|/* Return a def_operand_p pointer for the result of PHI.  */
end_comment

begin_function
specifier|static
specifier|inline
name|def_operand_p
name|get_phi_result_ptr
parameter_list|(
name|tree
name|phi
parameter_list|)
block|{
return|return
operator|&
operator|(
name|PHI_RESULT_TREE
argument_list|(
name|phi
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return a use_operand_p pointer for argument I of phinode PHI.  */
end_comment

begin_function
specifier|static
specifier|inline
name|use_operand_p
name|get_phi_arg_def_ptr
parameter_list|(
name|tree
name|phi
parameter_list|,
name|int
name|i
parameter_list|)
block|{
return|return
operator|&
operator|(
name|PHI_ARG_IMM_USE_NODE
argument_list|(
name|phi
argument_list|,
name|i
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the bitmap of addresses taken by STMT, or NULL if it takes    no addresses.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bitmap
name|addresses_taken
parameter_list|(
name|tree
name|stmt
parameter_list|)
block|{
name|stmt_ann_t
name|ann
init|=
name|stmt_ann
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
return|return
name|ann
condition|?
name|ann
operator|->
name|addresses_taken
else|:
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Return the PHI nodes for basic block BB, or NULL if there are no    PHI nodes.  */
end_comment

begin_function
specifier|static
specifier|inline
name|tree
name|phi_nodes
parameter_list|(
name|basic_block
name|bb
parameter_list|)
block|{
return|return
name|bb
operator|->
name|phi_nodes
return|;
block|}
end_function

begin_comment
comment|/* Set list of phi nodes of a basic block BB to L.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|set_phi_nodes
parameter_list|(
name|basic_block
name|bb
parameter_list|,
name|tree
name|l
parameter_list|)
block|{
name|tree
name|phi
decl_stmt|;
name|bb
operator|->
name|phi_nodes
operator|=
name|l
expr_stmt|;
for|for
control|(
name|phi
operator|=
name|l
init|;
name|phi
condition|;
name|phi
operator|=
name|PHI_CHAIN
argument_list|(
name|phi
argument_list|)
control|)
name|set_bb_for_stmt
argument_list|(
name|phi
argument_list|,
name|bb
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the phi argument which contains the specified use.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|phi_arg_index_from_use
parameter_list|(
name|use_operand_p
name|use
parameter_list|)
block|{
name|struct
name|phi_arg_d
modifier|*
name|element
decl_stmt|,
modifier|*
name|root
decl_stmt|;
name|int
name|index
decl_stmt|;
name|tree
name|phi
decl_stmt|;
comment|/* Since the use is the first thing in a PHI argument element, we can      calculate its index based on casting it to an argument, and performing      pointer arithmetic.  */
name|phi
operator|=
name|USE_STMT
argument_list|(
name|use
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|phi
argument_list|)
operator|==
name|PHI_NODE
argument_list|)
expr_stmt|;
name|element
operator|=
operator|(
expr|struct
name|phi_arg_d
operator|*
operator|)
name|use
expr_stmt|;
name|root
operator|=
operator|&
operator|(
name|PHI_ARG_ELT
argument_list|(
name|phi
argument_list|,
literal|0
argument_list|)
operator|)
expr_stmt|;
name|index
operator|=
name|element
operator|-
name|root
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
comment|/* Make sure the calculation doesn't have any leftover bytes.  If it does,       then imm_use is likely not the first element in phi_arg_d.  */
name|gcc_assert
argument_list|(
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
name|element
operator|-
operator|(
name|char
operator|*
operator|)
name|root
operator|)
operator|%
sizeof|sizeof
argument_list|(
expr|struct
name|phi_arg_d
argument_list|)
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|index
operator|>=
literal|0
operator|&&
name|index
operator|<
name|PHI_ARG_CAPACITY
argument_list|(
name|phi
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|index
return|;
block|}
end_function

begin_comment
comment|/* Mark VAR as used, so that it'll be preserved during rtl expansion.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|set_is_used
parameter_list|(
name|tree
name|var
parameter_list|)
block|{
name|var_ann_t
name|ann
init|=
name|get_var_ann
argument_list|(
name|var
argument_list|)
decl_stmt|;
name|ann
operator|->
name|used
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  -----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* Return true if T is an executable statement.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|is_exec_stmt
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
return|return
operator|(
name|t
operator|&&
operator|!
name|IS_EMPTY_STMT
argument_list|(
name|t
argument_list|)
operator|&&
name|t
operator|!=
name|error_mark_node
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if this stmt can be the target of a control transfer stmt such    as a goto.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|is_label_stmt
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
if|if
condition|(
name|t
condition|)
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|LABEL_DECL
case|:
case|case
name|LABEL_EXPR
case|:
case|case
name|CASE_LABEL_EXPR
case|:
return|return
name|true
return|;
default|default:
return|return
name|false
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* PHI nodes should contain only ssa_names and invariants.  A test    for ssa_name is definitely simpler; don't let invalid contents    slip in in the meantime.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|phi_ssa_name_p
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|SSA_NAME
condition|)
return|return
name|true
return|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
name|gcc_assert
argument_list|(
name|is_gimple_min_invariant
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/*  -----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* Return a block_stmt_iterator that points to beginning of basic    block BB.  */
end_comment

begin_function
specifier|static
specifier|inline
name|block_stmt_iterator
name|bsi_start
parameter_list|(
name|basic_block
name|bb
parameter_list|)
block|{
name|block_stmt_iterator
name|bsi
decl_stmt|;
if|if
condition|(
name|bb
operator|->
name|stmt_list
condition|)
name|bsi
operator|.
name|tsi
operator|=
name|tsi_start
argument_list|(
name|bb
operator|->
name|stmt_list
argument_list|)
expr_stmt|;
else|else
block|{
name|gcc_assert
argument_list|(
name|bb
operator|->
name|index
operator|<
name|NUM_FIXED_BLOCKS
argument_list|)
expr_stmt|;
name|bsi
operator|.
name|tsi
operator|.
name|ptr
operator|=
name|NULL
expr_stmt|;
name|bsi
operator|.
name|tsi
operator|.
name|container
operator|=
name|NULL
expr_stmt|;
block|}
name|bsi
operator|.
name|bb
operator|=
name|bb
expr_stmt|;
return|return
name|bsi
return|;
block|}
end_function

begin_comment
comment|/* Return a block statement iterator that points to the first non-label    statement in block BB.  */
end_comment

begin_function
specifier|static
specifier|inline
name|block_stmt_iterator
name|bsi_after_labels
parameter_list|(
name|basic_block
name|bb
parameter_list|)
block|{
name|block_stmt_iterator
name|bsi
init|=
name|bsi_start
argument_list|(
name|bb
argument_list|)
decl_stmt|;
while|while
condition|(
operator|!
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
argument_list|)
operator|==
name|LABEL_EXPR
condition|)
name|bsi_next
argument_list|(
operator|&
name|bsi
argument_list|)
expr_stmt|;
return|return
name|bsi
return|;
block|}
end_function

begin_comment
comment|/* Return a block statement iterator that points to the end of basic    block BB.  */
end_comment

begin_function
specifier|static
specifier|inline
name|block_stmt_iterator
name|bsi_last
parameter_list|(
name|basic_block
name|bb
parameter_list|)
block|{
name|block_stmt_iterator
name|bsi
decl_stmt|;
if|if
condition|(
name|bb
operator|->
name|stmt_list
condition|)
name|bsi
operator|.
name|tsi
operator|=
name|tsi_last
argument_list|(
name|bb
operator|->
name|stmt_list
argument_list|)
expr_stmt|;
else|else
block|{
name|gcc_assert
argument_list|(
name|bb
operator|->
name|index
operator|<
name|NUM_FIXED_BLOCKS
argument_list|)
expr_stmt|;
name|bsi
operator|.
name|tsi
operator|.
name|ptr
operator|=
name|NULL
expr_stmt|;
name|bsi
operator|.
name|tsi
operator|.
name|container
operator|=
name|NULL
expr_stmt|;
block|}
name|bsi
operator|.
name|bb
operator|=
name|bb
expr_stmt|;
return|return
name|bsi
return|;
block|}
end_function

begin_comment
comment|/* Return true if block statement iterator I has reached the end of    the basic block.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|bsi_end_p
parameter_list|(
name|block_stmt_iterator
name|i
parameter_list|)
block|{
return|return
name|tsi_end_p
argument_list|(
name|i
operator|.
name|tsi
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Modify block statement iterator I so that it is at the next    statement in the basic block.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|bsi_next
parameter_list|(
name|block_stmt_iterator
modifier|*
name|i
parameter_list|)
block|{
name|tsi_next
argument_list|(
operator|&
name|i
operator|->
name|tsi
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Modify block statement iterator I so that it is at the previous    statement in the basic block.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|bsi_prev
parameter_list|(
name|block_stmt_iterator
modifier|*
name|i
parameter_list|)
block|{
name|tsi_prev
argument_list|(
operator|&
name|i
operator|->
name|tsi
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the statement that block statement iterator I is currently    at.  */
end_comment

begin_function
specifier|static
specifier|inline
name|tree
name|bsi_stmt
parameter_list|(
name|block_stmt_iterator
name|i
parameter_list|)
block|{
return|return
name|tsi_stmt
argument_list|(
name|i
operator|.
name|tsi
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return a pointer to the statement that block statement iterator I    is currently at.  */
end_comment

begin_function
specifier|static
specifier|inline
name|tree
modifier|*
name|bsi_stmt_ptr
parameter_list|(
name|block_stmt_iterator
name|i
parameter_list|)
block|{
return|return
name|tsi_stmt_ptr
argument_list|(
name|i
operator|.
name|tsi
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns the loop of the statement STMT.  */
end_comment

begin_function
specifier|static
specifier|inline
name|struct
name|loop
modifier|*
name|loop_containing_stmt
parameter_list|(
name|tree
name|stmt
parameter_list|)
block|{
name|basic_block
name|bb
init|=
name|bb_for_stmt
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|bb
condition|)
return|return
name|NULL
return|;
return|return
name|bb
operator|->
name|loop_father
return|;
block|}
end_function

begin_comment
comment|/* Return true if VAR is a clobbered by function calls.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|is_call_clobbered
parameter_list|(
name|tree
name|var
parameter_list|)
block|{
if|if
condition|(
operator|!
name|MTAG_P
argument_list|(
name|var
argument_list|)
condition|)
return|return
name|DECL_CALL_CLOBBERED
argument_list|(
name|var
argument_list|)
return|;
else|else
return|return
name|bitmap_bit_p
argument_list|(
name|call_clobbered_vars
argument_list|,
name|DECL_UID
argument_list|(
name|var
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Mark variable VAR as being clobbered by function calls.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|mark_call_clobbered
parameter_list|(
name|tree
name|var
parameter_list|,
name|unsigned
name|int
name|escape_type
parameter_list|)
block|{
name|var_ann
argument_list|(
name|var
argument_list|)
operator|->
name|escape_mask
operator||=
name|escape_type
expr_stmt|;
if|if
condition|(
operator|!
name|MTAG_P
argument_list|(
name|var
argument_list|)
condition|)
name|DECL_CALL_CLOBBERED
argument_list|(
name|var
argument_list|)
operator|=
name|true
expr_stmt|;
name|bitmap_set_bit
argument_list|(
name|call_clobbered_vars
argument_list|,
name|DECL_UID
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Clear the call-clobbered attribute from variable VAR.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|clear_call_clobbered
parameter_list|(
name|tree
name|var
parameter_list|)
block|{
name|var_ann_t
name|ann
init|=
name|var_ann
argument_list|(
name|var
argument_list|)
decl_stmt|;
name|ann
operator|->
name|escape_mask
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|MTAG_P
argument_list|(
name|var
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|var
argument_list|)
operator|!=
name|STRUCT_FIELD_TAG
condition|)
name|MTAG_GLOBAL
argument_list|(
name|var
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|MTAG_P
argument_list|(
name|var
argument_list|)
condition|)
name|DECL_CALL_CLOBBERED
argument_list|(
name|var
argument_list|)
operator|=
name|false
expr_stmt|;
name|bitmap_clear_bit
argument_list|(
name|call_clobbered_vars
argument_list|,
name|DECL_UID
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Mark variable VAR as being non-addressable.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|mark_non_addressable
parameter_list|(
name|tree
name|var
parameter_list|)
block|{
if|if
condition|(
operator|!
name|MTAG_P
argument_list|(
name|var
argument_list|)
condition|)
name|DECL_CALL_CLOBBERED
argument_list|(
name|var
argument_list|)
operator|=
name|false
expr_stmt|;
name|bitmap_clear_bit
argument_list|(
name|call_clobbered_vars
argument_list|,
name|DECL_UID
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_ADDRESSABLE
argument_list|(
name|var
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the common annotation for T.  Return NULL if the annotation    doesn't already exist.  */
end_comment

begin_function
specifier|static
specifier|inline
name|tree_ann_common_t
name|tree_common_ann
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
return|return
operator|&
name|t
operator|->
name|common
operator|.
name|ann
operator|->
name|common
return|;
block|}
end_function

begin_comment
comment|/* Return a common annotation for T.  Create the constant annotation if it    doesn't exist.  */
end_comment

begin_function
specifier|static
specifier|inline
name|tree_ann_common_t
name|get_tree_common_ann
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|tree_ann_common_t
name|ann
init|=
name|tree_common_ann
argument_list|(
name|t
argument_list|)
decl_stmt|;
return|return
operator|(
name|ann
operator|)
condition|?
name|ann
else|:
name|create_tree_common_ann
argument_list|(
name|t
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  -----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* The following set of routines are used to iterator over various type of    SSA operands.  */
end_comment

begin_comment
comment|/* Return true if PTR is finished iterating.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|op_iter_done
parameter_list|(
name|ssa_op_iter
modifier|*
name|ptr
parameter_list|)
block|{
return|return
name|ptr
operator|->
name|done
return|;
block|}
end_function

begin_comment
comment|/* Get the next iterator use value for PTR.  */
end_comment

begin_function
specifier|static
specifier|inline
name|use_operand_p
name|op_iter_next_use
parameter_list|(
name|ssa_op_iter
modifier|*
name|ptr
parameter_list|)
block|{
name|use_operand_p
name|use_p
decl_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
name|gcc_assert
argument_list|(
name|ptr
operator|->
name|iter_type
operator|==
name|ssa_op_iter_use
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ptr
operator|->
name|uses
condition|)
block|{
name|use_p
operator|=
name|USE_OP_PTR
argument_list|(
name|ptr
operator|->
name|uses
argument_list|)
expr_stmt|;
name|ptr
operator|->
name|uses
operator|=
name|ptr
operator|->
name|uses
operator|->
name|next
expr_stmt|;
return|return
name|use_p
return|;
block|}
if|if
condition|(
name|ptr
operator|->
name|vuses
condition|)
block|{
name|use_p
operator|=
name|VUSE_OP_PTR
argument_list|(
name|ptr
operator|->
name|vuses
argument_list|)
expr_stmt|;
name|ptr
operator|->
name|vuses
operator|=
name|ptr
operator|->
name|vuses
operator|->
name|next
expr_stmt|;
return|return
name|use_p
return|;
block|}
if|if
condition|(
name|ptr
operator|->
name|mayuses
condition|)
block|{
name|use_p
operator|=
name|MAYDEF_OP_PTR
argument_list|(
name|ptr
operator|->
name|mayuses
argument_list|)
expr_stmt|;
name|ptr
operator|->
name|mayuses
operator|=
name|ptr
operator|->
name|mayuses
operator|->
name|next
expr_stmt|;
return|return
name|use_p
return|;
block|}
if|if
condition|(
name|ptr
operator|->
name|mustkills
condition|)
block|{
name|use_p
operator|=
name|MUSTDEF_KILL_PTR
argument_list|(
name|ptr
operator|->
name|mustkills
argument_list|)
expr_stmt|;
name|ptr
operator|->
name|mustkills
operator|=
name|ptr
operator|->
name|mustkills
operator|->
name|next
expr_stmt|;
return|return
name|use_p
return|;
block|}
if|if
condition|(
name|ptr
operator|->
name|phi_i
operator|<
name|ptr
operator|->
name|num_phi
condition|)
block|{
return|return
name|PHI_ARG_DEF_PTR
argument_list|(
name|ptr
operator|->
name|phi_stmt
argument_list|,
operator|(
name|ptr
operator|->
name|phi_i
operator|)
operator|++
argument_list|)
return|;
block|}
name|ptr
operator|->
name|done
operator|=
name|true
expr_stmt|;
return|return
name|NULL_USE_OPERAND_P
return|;
block|}
end_function

begin_comment
comment|/* Get the next iterator def value for PTR.  */
end_comment

begin_function
specifier|static
specifier|inline
name|def_operand_p
name|op_iter_next_def
parameter_list|(
name|ssa_op_iter
modifier|*
name|ptr
parameter_list|)
block|{
name|def_operand_p
name|def_p
decl_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
name|gcc_assert
argument_list|(
name|ptr
operator|->
name|iter_type
operator|==
name|ssa_op_iter_def
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ptr
operator|->
name|defs
condition|)
block|{
name|def_p
operator|=
name|DEF_OP_PTR
argument_list|(
name|ptr
operator|->
name|defs
argument_list|)
expr_stmt|;
name|ptr
operator|->
name|defs
operator|=
name|ptr
operator|->
name|defs
operator|->
name|next
expr_stmt|;
return|return
name|def_p
return|;
block|}
if|if
condition|(
name|ptr
operator|->
name|mustdefs
condition|)
block|{
name|def_p
operator|=
name|MUSTDEF_RESULT_PTR
argument_list|(
name|ptr
operator|->
name|mustdefs
argument_list|)
expr_stmt|;
name|ptr
operator|->
name|mustdefs
operator|=
name|ptr
operator|->
name|mustdefs
operator|->
name|next
expr_stmt|;
return|return
name|def_p
return|;
block|}
if|if
condition|(
name|ptr
operator|->
name|maydefs
condition|)
block|{
name|def_p
operator|=
name|MAYDEF_RESULT_PTR
argument_list|(
name|ptr
operator|->
name|maydefs
argument_list|)
expr_stmt|;
name|ptr
operator|->
name|maydefs
operator|=
name|ptr
operator|->
name|maydefs
operator|->
name|next
expr_stmt|;
return|return
name|def_p
return|;
block|}
name|ptr
operator|->
name|done
operator|=
name|true
expr_stmt|;
return|return
name|NULL_DEF_OPERAND_P
return|;
block|}
end_function

begin_comment
comment|/* Get the next iterator tree value for PTR.  */
end_comment

begin_function
specifier|static
specifier|inline
name|tree
name|op_iter_next_tree
parameter_list|(
name|ssa_op_iter
modifier|*
name|ptr
parameter_list|)
block|{
name|tree
name|val
decl_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
name|gcc_assert
argument_list|(
name|ptr
operator|->
name|iter_type
operator|==
name|ssa_op_iter_tree
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ptr
operator|->
name|uses
condition|)
block|{
name|val
operator|=
name|USE_OP
argument_list|(
name|ptr
operator|->
name|uses
argument_list|)
expr_stmt|;
name|ptr
operator|->
name|uses
operator|=
name|ptr
operator|->
name|uses
operator|->
name|next
expr_stmt|;
return|return
name|val
return|;
block|}
if|if
condition|(
name|ptr
operator|->
name|vuses
condition|)
block|{
name|val
operator|=
name|VUSE_OP
argument_list|(
name|ptr
operator|->
name|vuses
argument_list|)
expr_stmt|;
name|ptr
operator|->
name|vuses
operator|=
name|ptr
operator|->
name|vuses
operator|->
name|next
expr_stmt|;
return|return
name|val
return|;
block|}
if|if
condition|(
name|ptr
operator|->
name|mayuses
condition|)
block|{
name|val
operator|=
name|MAYDEF_OP
argument_list|(
name|ptr
operator|->
name|mayuses
argument_list|)
expr_stmt|;
name|ptr
operator|->
name|mayuses
operator|=
name|ptr
operator|->
name|mayuses
operator|->
name|next
expr_stmt|;
return|return
name|val
return|;
block|}
if|if
condition|(
name|ptr
operator|->
name|mustkills
condition|)
block|{
name|val
operator|=
name|MUSTDEF_KILL
argument_list|(
name|ptr
operator|->
name|mustkills
argument_list|)
expr_stmt|;
name|ptr
operator|->
name|mustkills
operator|=
name|ptr
operator|->
name|mustkills
operator|->
name|next
expr_stmt|;
return|return
name|val
return|;
block|}
if|if
condition|(
name|ptr
operator|->
name|defs
condition|)
block|{
name|val
operator|=
name|DEF_OP
argument_list|(
name|ptr
operator|->
name|defs
argument_list|)
expr_stmt|;
name|ptr
operator|->
name|defs
operator|=
name|ptr
operator|->
name|defs
operator|->
name|next
expr_stmt|;
return|return
name|val
return|;
block|}
if|if
condition|(
name|ptr
operator|->
name|mustdefs
condition|)
block|{
name|val
operator|=
name|MUSTDEF_RESULT
argument_list|(
name|ptr
operator|->
name|mustdefs
argument_list|)
expr_stmt|;
name|ptr
operator|->
name|mustdefs
operator|=
name|ptr
operator|->
name|mustdefs
operator|->
name|next
expr_stmt|;
return|return
name|val
return|;
block|}
if|if
condition|(
name|ptr
operator|->
name|maydefs
condition|)
block|{
name|val
operator|=
name|MAYDEF_RESULT
argument_list|(
name|ptr
operator|->
name|maydefs
argument_list|)
expr_stmt|;
name|ptr
operator|->
name|maydefs
operator|=
name|ptr
operator|->
name|maydefs
operator|->
name|next
expr_stmt|;
return|return
name|val
return|;
block|}
name|ptr
operator|->
name|done
operator|=
name|true
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* This functions clears the iterator PTR, and marks it done.  This is normally    used to prevent warnings in the compile about might be uninitialized    components.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|clear_and_done_ssa_iter
parameter_list|(
name|ssa_op_iter
modifier|*
name|ptr
parameter_list|)
block|{
name|ptr
operator|->
name|defs
operator|=
name|NULL
expr_stmt|;
name|ptr
operator|->
name|uses
operator|=
name|NULL
expr_stmt|;
name|ptr
operator|->
name|vuses
operator|=
name|NULL
expr_stmt|;
name|ptr
operator|->
name|maydefs
operator|=
name|NULL
expr_stmt|;
name|ptr
operator|->
name|mayuses
operator|=
name|NULL
expr_stmt|;
name|ptr
operator|->
name|mustdefs
operator|=
name|NULL
expr_stmt|;
name|ptr
operator|->
name|mustkills
operator|=
name|NULL
expr_stmt|;
name|ptr
operator|->
name|iter_type
operator|=
name|ssa_op_iter_none
expr_stmt|;
name|ptr
operator|->
name|phi_i
operator|=
literal|0
expr_stmt|;
name|ptr
operator|->
name|num_phi
operator|=
literal|0
expr_stmt|;
name|ptr
operator|->
name|phi_stmt
operator|=
name|NULL_TREE
expr_stmt|;
name|ptr
operator|->
name|done
operator|=
name|true
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize the iterator PTR to the virtual defs in STMT.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|op_iter_init
parameter_list|(
name|ssa_op_iter
modifier|*
name|ptr
parameter_list|,
name|tree
name|stmt
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
name|gcc_assert
argument_list|(
name|stmt_ann
argument_list|(
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ptr
operator|->
name|defs
operator|=
operator|(
name|flags
operator|&
name|SSA_OP_DEF
operator|)
condition|?
name|DEF_OPS
argument_list|(
name|stmt
argument_list|)
else|:
name|NULL
expr_stmt|;
name|ptr
operator|->
name|uses
operator|=
operator|(
name|flags
operator|&
name|SSA_OP_USE
operator|)
condition|?
name|USE_OPS
argument_list|(
name|stmt
argument_list|)
else|:
name|NULL
expr_stmt|;
name|ptr
operator|->
name|vuses
operator|=
operator|(
name|flags
operator|&
name|SSA_OP_VUSE
operator|)
condition|?
name|VUSE_OPS
argument_list|(
name|stmt
argument_list|)
else|:
name|NULL
expr_stmt|;
name|ptr
operator|->
name|maydefs
operator|=
operator|(
name|flags
operator|&
name|SSA_OP_VMAYDEF
operator|)
condition|?
name|MAYDEF_OPS
argument_list|(
name|stmt
argument_list|)
else|:
name|NULL
expr_stmt|;
name|ptr
operator|->
name|mayuses
operator|=
operator|(
name|flags
operator|&
name|SSA_OP_VMAYUSE
operator|)
condition|?
name|MAYDEF_OPS
argument_list|(
name|stmt
argument_list|)
else|:
name|NULL
expr_stmt|;
name|ptr
operator|->
name|mustdefs
operator|=
operator|(
name|flags
operator|&
name|SSA_OP_VMUSTDEF
operator|)
condition|?
name|MUSTDEF_OPS
argument_list|(
name|stmt
argument_list|)
else|:
name|NULL
expr_stmt|;
name|ptr
operator|->
name|mustkills
operator|=
operator|(
name|flags
operator|&
name|SSA_OP_VMUSTKILL
operator|)
condition|?
name|MUSTDEF_OPS
argument_list|(
name|stmt
argument_list|)
else|:
name|NULL
expr_stmt|;
name|ptr
operator|->
name|done
operator|=
name|false
expr_stmt|;
name|ptr
operator|->
name|phi_i
operator|=
literal|0
expr_stmt|;
name|ptr
operator|->
name|num_phi
operator|=
literal|0
expr_stmt|;
name|ptr
operator|->
name|phi_stmt
operator|=
name|NULL_TREE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize iterator PTR to the use operands in STMT based on FLAGS. Return    the first use.  */
end_comment

begin_function
specifier|static
specifier|inline
name|use_operand_p
name|op_iter_init_use
parameter_list|(
name|ssa_op_iter
modifier|*
name|ptr
parameter_list|,
name|tree
name|stmt
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|gcc_assert
argument_list|(
operator|(
name|flags
operator|&
name|SSA_OP_ALL_DEFS
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|op_iter_init
argument_list|(
name|ptr
argument_list|,
name|stmt
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|ptr
operator|->
name|iter_type
operator|=
name|ssa_op_iter_use
expr_stmt|;
return|return
name|op_iter_next_use
argument_list|(
name|ptr
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Initialize iterator PTR to the def operands in STMT based on FLAGS. Return    the first def.  */
end_comment

begin_function
specifier|static
specifier|inline
name|def_operand_p
name|op_iter_init_def
parameter_list|(
name|ssa_op_iter
modifier|*
name|ptr
parameter_list|,
name|tree
name|stmt
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|gcc_assert
argument_list|(
operator|(
name|flags
operator|&
operator|(
name|SSA_OP_ALL_USES
operator||
name|SSA_OP_VIRTUAL_KILLS
operator|)
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|op_iter_init
argument_list|(
name|ptr
argument_list|,
name|stmt
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|ptr
operator|->
name|iter_type
operator|=
name|ssa_op_iter_def
expr_stmt|;
return|return
name|op_iter_next_def
argument_list|(
name|ptr
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Initialize iterator PTR to the operands in STMT based on FLAGS. Return    the first operand as a tree.  */
end_comment

begin_function
specifier|static
specifier|inline
name|tree
name|op_iter_init_tree
parameter_list|(
name|ssa_op_iter
modifier|*
name|ptr
parameter_list|,
name|tree
name|stmt
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|op_iter_init
argument_list|(
name|ptr
argument_list|,
name|stmt
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|ptr
operator|->
name|iter_type
operator|=
name|ssa_op_iter_tree
expr_stmt|;
return|return
name|op_iter_next_tree
argument_list|(
name|ptr
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Get the next iterator mustdef value for PTR, returning the mustdef values in    KILL and DEF.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|op_iter_next_maymustdef
parameter_list|(
name|use_operand_p
modifier|*
name|use
parameter_list|,
name|def_operand_p
modifier|*
name|def
parameter_list|,
name|ssa_op_iter
modifier|*
name|ptr
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
name|gcc_assert
argument_list|(
name|ptr
operator|->
name|iter_type
operator|==
name|ssa_op_iter_maymustdef
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ptr
operator|->
name|mayuses
condition|)
block|{
operator|*
name|def
operator|=
name|MAYDEF_RESULT_PTR
argument_list|(
name|ptr
operator|->
name|mayuses
argument_list|)
expr_stmt|;
operator|*
name|use
operator|=
name|MAYDEF_OP_PTR
argument_list|(
name|ptr
operator|->
name|mayuses
argument_list|)
expr_stmt|;
name|ptr
operator|->
name|mayuses
operator|=
name|ptr
operator|->
name|mayuses
operator|->
name|next
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ptr
operator|->
name|mustkills
condition|)
block|{
operator|*
name|def
operator|=
name|MUSTDEF_RESULT_PTR
argument_list|(
name|ptr
operator|->
name|mustkills
argument_list|)
expr_stmt|;
operator|*
name|use
operator|=
name|MUSTDEF_KILL_PTR
argument_list|(
name|ptr
operator|->
name|mustkills
argument_list|)
expr_stmt|;
name|ptr
operator|->
name|mustkills
operator|=
name|ptr
operator|->
name|mustkills
operator|->
name|next
expr_stmt|;
return|return;
block|}
operator|*
name|def
operator|=
name|NULL_DEF_OPERAND_P
expr_stmt|;
operator|*
name|use
operator|=
name|NULL_USE_OPERAND_P
expr_stmt|;
name|ptr
operator|->
name|done
operator|=
name|true
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* Initialize iterator PTR to the operands in STMT.  Return the first operands    in USE and DEF.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|op_iter_init_maydef
parameter_list|(
name|ssa_op_iter
modifier|*
name|ptr
parameter_list|,
name|tree
name|stmt
parameter_list|,
name|use_operand_p
modifier|*
name|use
parameter_list|,
name|def_operand_p
modifier|*
name|def
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|!=
name|PHI_NODE
argument_list|)
expr_stmt|;
name|op_iter_init
argument_list|(
name|ptr
argument_list|,
name|stmt
argument_list|,
name|SSA_OP_VMAYUSE
argument_list|)
expr_stmt|;
name|ptr
operator|->
name|iter_type
operator|=
name|ssa_op_iter_maymustdef
expr_stmt|;
name|op_iter_next_maymustdef
argument_list|(
name|use
argument_list|,
name|def
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize iterator PTR to the operands in STMT.  Return the first operands    in KILL and DEF.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|op_iter_init_mustdef
parameter_list|(
name|ssa_op_iter
modifier|*
name|ptr
parameter_list|,
name|tree
name|stmt
parameter_list|,
name|use_operand_p
modifier|*
name|kill
parameter_list|,
name|def_operand_p
modifier|*
name|def
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|!=
name|PHI_NODE
argument_list|)
expr_stmt|;
name|op_iter_init
argument_list|(
name|ptr
argument_list|,
name|stmt
argument_list|,
name|SSA_OP_VMUSTKILL
argument_list|)
expr_stmt|;
name|ptr
operator|->
name|iter_type
operator|=
name|ssa_op_iter_maymustdef
expr_stmt|;
name|op_iter_next_maymustdef
argument_list|(
name|kill
argument_list|,
name|def
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize iterator PTR to the operands in STMT.  Return the first operands    in KILL and DEF.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|op_iter_init_must_and_may_def
parameter_list|(
name|ssa_op_iter
modifier|*
name|ptr
parameter_list|,
name|tree
name|stmt
parameter_list|,
name|use_operand_p
modifier|*
name|kill
parameter_list|,
name|def_operand_p
modifier|*
name|def
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|!=
name|PHI_NODE
argument_list|)
expr_stmt|;
name|op_iter_init
argument_list|(
name|ptr
argument_list|,
name|stmt
argument_list|,
name|SSA_OP_VMUSTKILL
operator||
name|SSA_OP_VMAYUSE
argument_list|)
expr_stmt|;
name|ptr
operator|->
name|iter_type
operator|=
name|ssa_op_iter_maymustdef
expr_stmt|;
name|op_iter_next_maymustdef
argument_list|(
name|kill
argument_list|,
name|def
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If there is a single operand in STMT matching FLAGS, return it.  Otherwise    return NULL.  */
end_comment

begin_function
specifier|static
specifier|inline
name|tree
name|single_ssa_tree_operand
parameter_list|(
name|tree
name|stmt
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|tree
name|var
decl_stmt|;
name|ssa_op_iter
name|iter
decl_stmt|;
name|var
operator|=
name|op_iter_init_tree
argument_list|(
operator|&
name|iter
argument_list|,
name|stmt
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|op_iter_done
argument_list|(
operator|&
name|iter
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
name|op_iter_next_tree
argument_list|(
operator|&
name|iter
argument_list|)
expr_stmt|;
if|if
condition|(
name|op_iter_done
argument_list|(
operator|&
name|iter
argument_list|)
condition|)
return|return
name|var
return|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* If there is a single operand in STMT matching FLAGS, return it.  Otherwise    return NULL.  */
end_comment

begin_function
specifier|static
specifier|inline
name|use_operand_p
name|single_ssa_use_operand
parameter_list|(
name|tree
name|stmt
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|use_operand_p
name|var
decl_stmt|;
name|ssa_op_iter
name|iter
decl_stmt|;
name|var
operator|=
name|op_iter_init_use
argument_list|(
operator|&
name|iter
argument_list|,
name|stmt
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|op_iter_done
argument_list|(
operator|&
name|iter
argument_list|)
condition|)
return|return
name|NULL_USE_OPERAND_P
return|;
name|op_iter_next_use
argument_list|(
operator|&
name|iter
argument_list|)
expr_stmt|;
if|if
condition|(
name|op_iter_done
argument_list|(
operator|&
name|iter
argument_list|)
condition|)
return|return
name|var
return|;
return|return
name|NULL_USE_OPERAND_P
return|;
block|}
end_function

begin_comment
comment|/* If there is a single operand in STMT matching FLAGS, return it.  Otherwise    return NULL.  */
end_comment

begin_function
specifier|static
specifier|inline
name|def_operand_p
name|single_ssa_def_operand
parameter_list|(
name|tree
name|stmt
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|def_operand_p
name|var
decl_stmt|;
name|ssa_op_iter
name|iter
decl_stmt|;
name|var
operator|=
name|op_iter_init_def
argument_list|(
operator|&
name|iter
argument_list|,
name|stmt
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|op_iter_done
argument_list|(
operator|&
name|iter
argument_list|)
condition|)
return|return
name|NULL_DEF_OPERAND_P
return|;
name|op_iter_next_def
argument_list|(
operator|&
name|iter
argument_list|)
expr_stmt|;
if|if
condition|(
name|op_iter_done
argument_list|(
operator|&
name|iter
argument_list|)
condition|)
return|return
name|var
return|;
return|return
name|NULL_DEF_OPERAND_P
return|;
block|}
end_function

begin_comment
comment|/* Return true if there are zero operands in STMT matching the type     given in FLAGS.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|zero_ssa_operands
parameter_list|(
name|tree
name|stmt
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|ssa_op_iter
name|iter
decl_stmt|;
name|op_iter_init_tree
argument_list|(
operator|&
name|iter
argument_list|,
name|stmt
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
name|op_iter_done
argument_list|(
operator|&
name|iter
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the number of operands matching FLAGS in STMT.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|num_ssa_operands
parameter_list|(
name|tree
name|stmt
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|ssa_op_iter
name|iter
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|int
name|num
init|=
literal|0
decl_stmt|;
name|FOR_EACH_SSA_TREE_OPERAND
argument_list|(
argument|t
argument_list|,
argument|stmt
argument_list|,
argument|iter
argument_list|,
argument|flags
argument_list|)
name|num
operator|++
expr_stmt|;
return|return
name|num
return|;
block|}
end_function

begin_comment
comment|/* Delink all immediate_use information for STMT.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|delink_stmt_imm_use
parameter_list|(
name|tree
name|stmt
parameter_list|)
block|{
name|ssa_op_iter
name|iter
decl_stmt|;
name|use_operand_p
name|use_p
decl_stmt|;
if|if
condition|(
name|ssa_operands_active
argument_list|()
condition|)
name|FOR_EACH_SSA_USE_OPERAND
argument_list|(
argument|use_p
argument_list|,
argument|stmt
argument_list|,
argument|iter
argument_list|,
argument|(SSA_OP_ALL_USES | SSA_OP_ALL_KILLS)
argument_list|)
name|delink_imm_use
argument_list|(
name|use_p
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This routine will compare all the operands matching FLAGS in STMT1 to those    in STMT2.  TRUE is returned if they are the same.  STMTs can be NULL.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|compare_ssa_operands_equal
parameter_list|(
name|tree
name|stmt1
parameter_list|,
name|tree
name|stmt2
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|ssa_op_iter
name|iter1
decl_stmt|,
name|iter2
decl_stmt|;
name|tree
name|op1
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|op2
init|=
name|NULL_TREE
decl_stmt|;
name|bool
name|look1
decl_stmt|,
name|look2
decl_stmt|;
if|if
condition|(
name|stmt1
operator|==
name|stmt2
condition|)
return|return
name|true
return|;
name|look1
operator|=
name|stmt1
operator|&&
name|stmt_ann
argument_list|(
name|stmt1
argument_list|)
expr_stmt|;
name|look2
operator|=
name|stmt2
operator|&&
name|stmt_ann
argument_list|(
name|stmt2
argument_list|)
expr_stmt|;
if|if
condition|(
name|look1
condition|)
block|{
name|op1
operator|=
name|op_iter_init_tree
argument_list|(
operator|&
name|iter1
argument_list|,
name|stmt1
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|look2
condition|)
return|return
name|op_iter_done
argument_list|(
operator|&
name|iter1
argument_list|)
return|;
block|}
else|else
name|clear_and_done_ssa_iter
argument_list|(
operator|&
name|iter1
argument_list|)
expr_stmt|;
if|if
condition|(
name|look2
condition|)
block|{
name|op2
operator|=
name|op_iter_init_tree
argument_list|(
operator|&
name|iter2
argument_list|,
name|stmt2
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|look1
condition|)
return|return
name|op_iter_done
argument_list|(
operator|&
name|iter2
argument_list|)
return|;
block|}
else|else
name|clear_and_done_ssa_iter
argument_list|(
operator|&
name|iter2
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|op_iter_done
argument_list|(
operator|&
name|iter1
argument_list|)
operator|&&
operator|!
name|op_iter_done
argument_list|(
operator|&
name|iter2
argument_list|)
condition|)
block|{
if|if
condition|(
name|op1
operator|!=
name|op2
condition|)
return|return
name|false
return|;
name|op1
operator|=
name|op_iter_next_tree
argument_list|(
operator|&
name|iter1
argument_list|)
expr_stmt|;
name|op2
operator|=
name|op_iter_next_tree
argument_list|(
operator|&
name|iter2
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|op_iter_done
argument_list|(
operator|&
name|iter1
argument_list|)
operator|&&
name|op_iter_done
argument_list|(
operator|&
name|iter2
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* If there is a single DEF in the PHI node which matches FLAG, return it.    Otherwise return NULL_DEF_OPERAND_P.  */
end_comment

begin_function
specifier|static
specifier|inline
name|tree
name|single_phi_def
parameter_list|(
name|tree
name|stmt
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|tree
name|def
init|=
name|PHI_RESULT
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|SSA_OP_DEF
operator|)
operator|&&
name|is_gimple_reg
argument_list|(
name|def
argument_list|)
condition|)
return|return
name|def
return|;
if|if
condition|(
operator|(
name|flags
operator|&
name|SSA_OP_VIRTUAL_DEFS
operator|)
operator|&&
operator|!
name|is_gimple_reg
argument_list|(
name|def
argument_list|)
condition|)
return|return
name|def
return|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Initialize the iterator PTR for uses matching FLAGS in PHI.  FLAGS should    be either SSA_OP_USES or SSA_OP_VIRTUAL_USES.  */
end_comment

begin_function
specifier|static
specifier|inline
name|use_operand_p
name|op_iter_init_phiuse
parameter_list|(
name|ssa_op_iter
modifier|*
name|ptr
parameter_list|,
name|tree
name|phi
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|tree
name|phi_def
init|=
name|PHI_RESULT
argument_list|(
name|phi
argument_list|)
decl_stmt|;
name|int
name|comp
decl_stmt|;
name|clear_and_done_ssa_iter
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|ptr
operator|->
name|done
operator|=
name|false
expr_stmt|;
name|gcc_assert
argument_list|(
operator|(
name|flags
operator|&
operator|(
name|SSA_OP_USE
operator||
name|SSA_OP_VIRTUAL_USES
operator|)
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|comp
operator|=
operator|(
name|is_gimple_reg
argument_list|(
name|phi_def
argument_list|)
condition|?
name|SSA_OP_USE
else|:
name|SSA_OP_VIRTUAL_USES
operator|)
expr_stmt|;
comment|/* If the PHI node doesn't the operand type we care about, we're done.  */
if|if
condition|(
operator|(
name|flags
operator|&
name|comp
operator|)
operator|==
literal|0
condition|)
block|{
name|ptr
operator|->
name|done
operator|=
name|true
expr_stmt|;
return|return
name|NULL_USE_OPERAND_P
return|;
block|}
name|ptr
operator|->
name|phi_stmt
operator|=
name|phi
expr_stmt|;
name|ptr
operator|->
name|num_phi
operator|=
name|PHI_NUM_ARGS
argument_list|(
name|phi
argument_list|)
expr_stmt|;
name|ptr
operator|->
name|iter_type
operator|=
name|ssa_op_iter_use
expr_stmt|;
return|return
name|op_iter_next_use
argument_list|(
name|ptr
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Start an iterator for a PHI definition.  */
end_comment

begin_function
specifier|static
specifier|inline
name|def_operand_p
name|op_iter_init_phidef
parameter_list|(
name|ssa_op_iter
modifier|*
name|ptr
parameter_list|,
name|tree
name|phi
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|tree
name|phi_def
init|=
name|PHI_RESULT
argument_list|(
name|phi
argument_list|)
decl_stmt|;
name|int
name|comp
decl_stmt|;
name|clear_and_done_ssa_iter
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|ptr
operator|->
name|done
operator|=
name|false
expr_stmt|;
name|gcc_assert
argument_list|(
operator|(
name|flags
operator|&
operator|(
name|SSA_OP_DEF
operator||
name|SSA_OP_VIRTUAL_DEFS
operator|)
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|comp
operator|=
operator|(
name|is_gimple_reg
argument_list|(
name|phi_def
argument_list|)
condition|?
name|SSA_OP_DEF
else|:
name|SSA_OP_VIRTUAL_DEFS
operator|)
expr_stmt|;
comment|/* If the PHI node doesn't the operand type we care about, we're done.  */
if|if
condition|(
operator|(
name|flags
operator|&
name|comp
operator|)
operator|==
literal|0
condition|)
block|{
name|ptr
operator|->
name|done
operator|=
name|true
expr_stmt|;
return|return
name|NULL_USE_OPERAND_P
return|;
block|}
name|ptr
operator|->
name|iter_type
operator|=
name|ssa_op_iter_def
expr_stmt|;
comment|/* The first call to op_iter_next_def will terminate the iterator since      all the fields are NULL.  Simply return the result here as the first and      therefore only result.  */
return|return
name|PHI_RESULT_PTR
argument_list|(
name|phi
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return true is IMM has reached the end of the immediate use stmt list.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|end_imm_use_stmt_p
parameter_list|(
name|imm_use_iterator
modifier|*
name|imm
parameter_list|)
block|{
return|return
operator|(
name|imm
operator|->
name|imm_use
operator|==
name|imm
operator|->
name|end_p
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Finished the traverse of an immediate use stmt list IMM by removing the    placeholder node from the list.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|end_imm_use_stmt_traverse
parameter_list|(
name|imm_use_iterator
modifier|*
name|imm
parameter_list|)
block|{
name|delink_imm_use
argument_list|(
operator|&
operator|(
name|imm
operator|->
name|iter_node
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Immediate use traversal of uses within a stmt require that all the    uses on a stmt be sequentially listed.  This routine is used to build up    this sequential list by adding USE_P to the end of the current list     currently delimited by HEAD and LAST_P.  The new LAST_P value is     returned.  */
end_comment

begin_function
specifier|static
specifier|inline
name|use_operand_p
name|move_use_after_head
parameter_list|(
name|use_operand_p
name|use_p
parameter_list|,
name|use_operand_p
name|head
parameter_list|,
name|use_operand_p
name|last_p
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|USE_FROM_PTR
argument_list|(
name|use_p
argument_list|)
operator|==
name|USE_FROM_PTR
argument_list|(
name|head
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Skip head when we find it.  */
if|if
condition|(
name|use_p
operator|!=
name|head
condition|)
block|{
comment|/* If use_p is already linked in after last_p, continue.  */
if|if
condition|(
name|last_p
operator|->
name|next
operator|==
name|use_p
condition|)
name|last_p
operator|=
name|use_p
expr_stmt|;
else|else
block|{
comment|/* Delink from current location, and link in at last_p.  */
name|delink_imm_use
argument_list|(
name|use_p
argument_list|)
expr_stmt|;
name|link_imm_use_to_list
argument_list|(
name|use_p
argument_list|,
name|last_p
argument_list|)
expr_stmt|;
name|last_p
operator|=
name|use_p
expr_stmt|;
block|}
block|}
return|return
name|last_p
return|;
block|}
end_function

begin_comment
comment|/* This routine will relink all uses with the same stmt as HEAD into the list    immediately following HEAD for iterator IMM.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|link_use_stmts_after
parameter_list|(
name|use_operand_p
name|head
parameter_list|,
name|imm_use_iterator
modifier|*
name|imm
parameter_list|)
block|{
name|use_operand_p
name|use_p
decl_stmt|;
name|use_operand_p
name|last_p
init|=
name|head
decl_stmt|;
name|tree
name|head_stmt
init|=
name|USE_STMT
argument_list|(
name|head
argument_list|)
decl_stmt|;
name|tree
name|use
init|=
name|USE_FROM_PTR
argument_list|(
name|head
argument_list|)
decl_stmt|;
name|ssa_op_iter
name|op_iter
decl_stmt|;
name|int
name|flag
decl_stmt|;
comment|/* Only look at virtual or real uses, depending on the type of HEAD.  */
name|flag
operator|=
operator|(
name|is_gimple_reg
argument_list|(
name|use
argument_list|)
condition|?
name|SSA_OP_USE
else|:
name|SSA_OP_VIRTUAL_USES
operator|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|head_stmt
argument_list|)
operator|==
name|PHI_NODE
condition|)
block|{
name|FOR_EACH_PHI_ARG
argument_list|(
argument|use_p
argument_list|,
argument|head_stmt
argument_list|,
argument|op_iter
argument_list|,
argument|flag
argument_list|)
if|if
condition|(
name|USE_FROM_PTR
argument_list|(
name|use_p
argument_list|)
operator|==
name|use
condition|)
name|last_p
operator|=
name|move_use_after_head
argument_list|(
name|use_p
argument_list|,
name|head
argument_list|,
name|last_p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|FOR_EACH_SSA_USE_OPERAND
argument_list|(
argument|use_p
argument_list|,
argument|head_stmt
argument_list|,
argument|op_iter
argument_list|,
argument|flag
argument_list|)
if|if
condition|(
name|USE_FROM_PTR
argument_list|(
name|use_p
argument_list|)
operator|==
name|use
condition|)
name|last_p
operator|=
name|move_use_after_head
argument_list|(
name|use_p
argument_list|,
name|head
argument_list|,
name|last_p
argument_list|)
expr_stmt|;
block|}
comment|/* LInk iter node in after last_p.  */
if|if
condition|(
name|imm
operator|->
name|iter_node
operator|.
name|prev
operator|!=
name|NULL
condition|)
name|delink_imm_use
argument_list|(
operator|&
name|imm
operator|->
name|iter_node
argument_list|)
expr_stmt|;
name|link_imm_use_to_list
argument_list|(
operator|&
operator|(
name|imm
operator|->
name|iter_node
operator|)
argument_list|,
name|last_p
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize IMM to traverse over uses of VAR.  Return the first statement.  */
end_comment

begin_function
specifier|static
specifier|inline
name|tree
name|first_imm_use_stmt
parameter_list|(
name|imm_use_iterator
modifier|*
name|imm
parameter_list|,
name|tree
name|var
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|var
argument_list|)
operator|==
name|SSA_NAME
argument_list|)
expr_stmt|;
name|imm
operator|->
name|end_p
operator|=
operator|&
operator|(
name|SSA_NAME_IMM_USE_NODE
argument_list|(
name|var
argument_list|)
operator|)
expr_stmt|;
name|imm
operator|->
name|imm_use
operator|=
name|imm
operator|->
name|end_p
operator|->
name|next
expr_stmt|;
name|imm
operator|->
name|next_imm_name
operator|=
name|NULL_USE_OPERAND_P
expr_stmt|;
comment|/* iter_node is used as a marker within the immediate use list to indicate      where the end of the current stmt's uses are.  Initialize it to NULL      stmt and use, which indicates a marker node.  */
name|imm
operator|->
name|iter_node
operator|.
name|prev
operator|=
name|NULL_USE_OPERAND_P
expr_stmt|;
name|imm
operator|->
name|iter_node
operator|.
name|next
operator|=
name|NULL_USE_OPERAND_P
expr_stmt|;
name|imm
operator|->
name|iter_node
operator|.
name|stmt
operator|=
name|NULL_TREE
expr_stmt|;
name|imm
operator|->
name|iter_node
operator|.
name|use
operator|=
name|NULL_USE_OPERAND_P
expr_stmt|;
if|if
condition|(
name|end_imm_use_stmt_p
argument_list|(
name|imm
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
name|link_use_stmts_after
argument_list|(
name|imm
operator|->
name|imm_use
argument_list|,
name|imm
argument_list|)
expr_stmt|;
return|return
name|USE_STMT
argument_list|(
name|imm
operator|->
name|imm_use
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Bump IMM to the next stmt which has a use of var.  */
end_comment

begin_function
specifier|static
specifier|inline
name|tree
name|next_imm_use_stmt
parameter_list|(
name|imm_use_iterator
modifier|*
name|imm
parameter_list|)
block|{
name|imm
operator|->
name|imm_use
operator|=
name|imm
operator|->
name|iter_node
operator|.
name|next
expr_stmt|;
if|if
condition|(
name|end_imm_use_stmt_p
argument_list|(
name|imm
argument_list|)
condition|)
block|{
if|if
condition|(
name|imm
operator|->
name|iter_node
operator|.
name|prev
operator|!=
name|NULL
condition|)
name|delink_imm_use
argument_list|(
operator|&
name|imm
operator|->
name|iter_node
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
name|link_use_stmts_after
argument_list|(
name|imm
operator|->
name|imm_use
argument_list|,
name|imm
argument_list|)
expr_stmt|;
return|return
name|USE_STMT
argument_list|(
name|imm
operator|->
name|imm_use
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* This routine will return the first use on the stmt IMM currently refers    to.  */
end_comment

begin_function
specifier|static
specifier|inline
name|use_operand_p
name|first_imm_use_on_stmt
parameter_list|(
name|imm_use_iterator
modifier|*
name|imm
parameter_list|)
block|{
name|imm
operator|->
name|next_imm_name
operator|=
name|imm
operator|->
name|imm_use
operator|->
name|next
expr_stmt|;
return|return
name|imm
operator|->
name|imm_use
return|;
block|}
end_function

begin_comment
comment|/*  Return TRUE if the last use on the stmt IMM refers to has been visited.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|end_imm_use_on_stmt_p
parameter_list|(
name|imm_use_iterator
modifier|*
name|imm
parameter_list|)
block|{
return|return
operator|(
name|imm
operator|->
name|imm_use
operator|==
operator|&
operator|(
name|imm
operator|->
name|iter_node
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Bump to the next use on the stmt IMM refers to, return NULL if done.  */
end_comment

begin_function
specifier|static
specifier|inline
name|use_operand_p
name|next_imm_use_on_stmt
parameter_list|(
name|imm_use_iterator
modifier|*
name|imm
parameter_list|)
block|{
name|imm
operator|->
name|imm_use
operator|=
name|imm
operator|->
name|next_imm_name
expr_stmt|;
if|if
condition|(
name|end_imm_use_on_stmt_p
argument_list|(
name|imm
argument_list|)
condition|)
return|return
name|NULL_USE_OPERAND_P
return|;
else|else
block|{
name|imm
operator|->
name|next_imm_name
operator|=
name|imm
operator|->
name|imm_use
operator|->
name|next
expr_stmt|;
return|return
name|imm
operator|->
name|imm_use
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return true if VAR cannot be modified by the program.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|unmodifiable_var_p
parameter_list|(
name|tree
name|var
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|var
argument_list|)
operator|==
name|SSA_NAME
condition|)
name|var
operator|=
name|SSA_NAME_VAR
argument_list|(
name|var
argument_list|)
expr_stmt|;
if|if
condition|(
name|MTAG_P
argument_list|(
name|var
argument_list|)
condition|)
return|return
name|TREE_READONLY
argument_list|(
name|var
argument_list|)
operator|&&
operator|(
name|TREE_STATIC
argument_list|(
name|var
argument_list|)
operator|||
name|MTAG_GLOBAL
argument_list|(
name|var
argument_list|)
operator|)
return|;
return|return
name|TREE_READONLY
argument_list|(
name|var
argument_list|)
operator|&&
operator|(
name|TREE_STATIC
argument_list|(
name|var
argument_list|)
operator|||
name|DECL_EXTERNAL
argument_list|(
name|var
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if REF, an ARRAY_REF, has an INDIRECT_REF somewhere in it.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|array_ref_contains_indirect_ref
parameter_list|(
name|tree
name|ref
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|ref
argument_list|)
operator|==
name|ARRAY_REF
argument_list|)
expr_stmt|;
do|do
block|{
name|ref
operator|=
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|handled_component_p
argument_list|(
name|ref
argument_list|)
condition|)
do|;
return|return
name|TREE_CODE
argument_list|(
name|ref
argument_list|)
operator|==
name|INDIRECT_REF
return|;
block|}
end_function

begin_comment
comment|/* Return true if REF, a handled component reference, has an ARRAY_REF    somewhere in it.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|ref_contains_array_ref
parameter_list|(
name|tree
name|ref
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|handled_component_p
argument_list|(
name|ref
argument_list|)
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ref
argument_list|)
operator|==
name|ARRAY_REF
condition|)
return|return
name|true
return|;
name|ref
operator|=
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|handled_component_p
argument_list|(
name|ref
argument_list|)
condition|)
do|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Given a variable VAR, lookup and return a pointer to the list of    subvariables for it.  */
end_comment

begin_function
specifier|static
specifier|inline
name|subvar_t
modifier|*
name|lookup_subvars_for_var
parameter_list|(
name|tree
name|var
parameter_list|)
block|{
name|var_ann_t
name|ann
init|=
name|var_ann
argument_list|(
name|var
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
name|ann
argument_list|)
expr_stmt|;
return|return
operator|&
name|ann
operator|->
name|subvars
return|;
block|}
end_function

begin_comment
comment|/* Given a variable VAR, return a linked list of subvariables for VAR, or    NULL, if there are no subvariables.  */
end_comment

begin_function
specifier|static
specifier|inline
name|subvar_t
name|get_subvars_for_var
parameter_list|(
name|tree
name|var
parameter_list|)
block|{
name|subvar_t
name|subvars
decl_stmt|;
name|gcc_assert
argument_list|(
name|SSA_VAR_P
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|var
argument_list|)
operator|==
name|SSA_NAME
condition|)
name|subvars
operator|=
operator|*
operator|(
name|lookup_subvars_for_var
argument_list|(
name|SSA_NAME_VAR
argument_list|(
name|var
argument_list|)
argument_list|)
operator|)
expr_stmt|;
else|else
name|subvars
operator|=
operator|*
operator|(
name|lookup_subvars_for_var
argument_list|(
name|var
argument_list|)
operator|)
expr_stmt|;
return|return
name|subvars
return|;
block|}
end_function

begin_comment
comment|/* Return the subvariable of VAR at offset OFFSET.  */
end_comment

begin_function
specifier|static
specifier|inline
name|tree
name|get_subvar_at
parameter_list|(
name|tree
name|var
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|offset
parameter_list|)
block|{
name|subvar_t
name|sv
decl_stmt|;
for|for
control|(
name|sv
operator|=
name|get_subvars_for_var
argument_list|(
name|var
argument_list|)
init|;
name|sv
condition|;
name|sv
operator|=
name|sv
operator|->
name|next
control|)
if|if
condition|(
name|SFT_OFFSET
argument_list|(
name|sv
operator|->
name|var
argument_list|)
operator|==
name|offset
condition|)
return|return
name|sv
operator|->
name|var
return|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Return true if V is a tree that we can have subvars for.    Normally, this is any aggregate type.  Also complex    types which are not gimple registers can have subvars.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|var_can_have_subvars
parameter_list|(
name|tree
name|v
parameter_list|)
block|{
comment|/* Volatile variables should never have subvars.  */
if|if
condition|(
name|TREE_THIS_VOLATILE
argument_list|(
name|v
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Non decls or memory tags can never have subvars.  */
if|if
condition|(
operator|!
name|DECL_P
argument_list|(
name|v
argument_list|)
operator|||
name|MTAG_P
argument_list|(
name|v
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Aggregates can have subvars.  */
if|if
condition|(
name|AGGREGATE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|v
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
comment|/* Complex types variables which are not also a gimple register can     have subvars. */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|v
argument_list|)
argument_list|)
operator|==
name|COMPLEX_TYPE
operator|&&
operator|!
name|DECL_COMPLEX_GIMPLE_REG_P
argument_list|(
name|v
argument_list|)
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Return true if OFFSET and SIZE define a range that overlaps with some    portion of the range of SV, a subvar.  If there was an exact overlap,    *EXACT will be set to true upon return. */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|overlap_subvar
parameter_list|(
name|unsigned
name|HOST_WIDE_INT
name|offset
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|size
parameter_list|,
name|tree
name|sv
parameter_list|,
name|bool
modifier|*
name|exact
parameter_list|)
block|{
comment|/* There are three possible cases of overlap.      1. We can have an exact overlap, like so:         |offset, offset + size             |      |sv->offset, sv->offset + sv->size |            2. We can have offset starting after sv->offset, like so:                  |offset, offset + size              |      |sv->offset, sv->offset + sv->size  |       3. We can have offset starting before sv->offset, like so:            |offset, offset + size    |        |sv->offset, sv->offset + sv->size|   */
if|if
condition|(
name|exact
condition|)
operator|*
name|exact
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|offset
operator|==
name|SFT_OFFSET
argument_list|(
name|sv
argument_list|)
operator|&&
name|size
operator|==
name|SFT_SIZE
argument_list|(
name|sv
argument_list|)
condition|)
block|{
if|if
condition|(
name|exact
condition|)
operator|*
name|exact
operator|=
name|true
expr_stmt|;
return|return
name|true
return|;
block|}
elseif|else
if|if
condition|(
name|offset
operator|>=
name|SFT_OFFSET
argument_list|(
name|sv
argument_list|)
operator|&&
name|offset
operator|<
operator|(
name|SFT_OFFSET
argument_list|(
name|sv
argument_list|)
operator|+
name|SFT_SIZE
argument_list|(
name|sv
argument_list|)
operator|)
condition|)
block|{
return|return
name|true
return|;
block|}
elseif|else
if|if
condition|(
name|offset
operator|<
name|SFT_OFFSET
argument_list|(
name|sv
argument_list|)
operator|&&
operator|(
name|size
operator|>
name|SFT_OFFSET
argument_list|(
name|sv
argument_list|)
operator|-
name|offset
operator|)
condition|)
block|{
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _TREE_FLOW_INLINE_H  */
end_comment

end_unit

