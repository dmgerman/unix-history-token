begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Post reload partially redundant load elimination    Copyright (C) 2004, 2005    Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"intl.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"hashtab.h"
end_include

begin_include
include|#
directive|include
file|"params.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"tree-pass.h"
end_include

begin_comment
comment|/* The following code implements gcse after reload, the purpose of this    pass is to cleanup redundant loads generated by reload and other    optimizations that come after gcse. It searches for simple inter-block    redundancies and tries to eliminate them by adding moves and loads    in cold places.     Perform partially redundant load elimination, try to eliminate redundant    loads created by the reload pass.  We try to look for full or partial    redundant loads fed by one or more loads/stores in predecessor BBs,    and try adding loads to make them fully redundant.  We also check if    it's worth adding loads to be able to delete the redundant load.     Algorithm:    1. Build available expressions hash table:        For each load/store instruction, if the loaded/stored memory didn't        change until the end of the basic block add this memory expression to        the hash table.    2. Perform Redundancy elimination:       For each load instruction do the following: 	 perform partial redundancy elimination, check if it's worth adding 	 loads to make the load fully redundant.  If so add loads and 	 register copies and delete the load.    3. Delete instructions made redundant in step 2.     Future enhancement:      If the loaded register is used/defined between load and some store,      look for some other free register between load and all its stores,      and replace the load with a copy from this register to the loaded      register. */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Keep statistics of this pass.  */
end_comment

begin_struct
specifier|static
struct|struct
block|{
name|int
name|moves_inserted
decl_stmt|;
name|int
name|copies_inserted
decl_stmt|;
name|int
name|insns_deleted
decl_stmt|;
block|}
name|stats
struct|;
end_struct

begin_comment
comment|/* We need to keep a hash table of expressions.  The table entries are of    type 'struct expr', and for each expression there is a single linked    list of occurrences.  */
end_comment

begin_comment
comment|/* The table itself.  */
end_comment

begin_decl_stmt
specifier|static
name|htab_t
name|expr_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Expression elements in the hash table.  */
end_comment

begin_struct
struct|struct
name|expr
block|{
comment|/* The expression (SET_SRC for expressions, PATTERN for assignments).  */
name|rtx
name|expr
decl_stmt|;
comment|/* The same hash for this entry.  */
name|hashval_t
name|hash
decl_stmt|;
comment|/* List of available occurrence in basic blocks in the function.  */
name|struct
name|occr
modifier|*
name|avail_occr
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|expr_obstack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Occurrence of an expression.    There is at most one occurrence per basic block.  If a pattern appears    more than once, the last appearance is used.  */
end_comment

begin_struct
struct|struct
name|occr
block|{
comment|/* Next occurrence of this expression.  */
name|struct
name|occr
modifier|*
name|next
decl_stmt|;
comment|/* The insn that computes the expression.  */
name|rtx
name|insn
decl_stmt|;
comment|/* Nonzero if this [anticipatable] occurrence has been deleted.  */
name|char
name|deleted_p
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|occr_obstack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The following structure holds the information about the occurrences of    the redundant instructions.  */
end_comment

begin_struct
struct|struct
name|unoccr
block|{
name|struct
name|unoccr
modifier|*
name|next
decl_stmt|;
name|edge
name|pred
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|unoccr_obstack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Array where each element is the CUID if the insn that last set the hard    register with the number of the element, since the start of the current    basic block.     This array is used during the building of the hash table (step 1) to    determine if a reg is killed before the end of a basic block.     It is also used when eliminating partial redundancies (step 2) to see    if a reg was modified since the start of a basic block.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|reg_avail_info
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A list of insns that may modify memory within the current basic block.  */
end_comment

begin_struct
struct|struct
name|modifies_mem
block|{
name|rtx
name|insn
decl_stmt|;
name|struct
name|modifies_mem
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|modifies_mem
modifier|*
name|modifies_mem_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The modifies_mem structs also go on an obstack, only this obstack is    freed each time after completing the analysis or transformations on    a basic block.  So we allocate a dummy modifies_mem_obstack_bottom    object on the obstack to keep track of the bottom of the obstack.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|modifies_mem_obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|modifies_mem
modifier|*
name|modifies_mem_obstack_bottom
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Mapping of insn UIDs to CUIDs.    CUIDs are like UIDs except they increase monotonically in each basic    block, have no gaps, and only apply to real insns.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|uid_cuid
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|INSN_CUID
parameter_list|(
name|INSN
parameter_list|)
value|(uid_cuid[INSN_UID (INSN)])
end_define

begin_escape
end_escape

begin_comment
comment|/* Helpers for memory allocation/freeing.  */
end_comment

begin_function_decl
specifier|static
name|void
name|alloc_mem
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_mem
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Support for hash table construction and transformations.  */
end_comment

begin_function_decl
specifier|static
name|bool
name|oprs_unchanged_p
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|record_last_reg_set_info
parameter_list|(
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|record_last_mem_set_info
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|record_last_set_info
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|record_opr_changes
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|find_mem_conflicts
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|load_killed_in_block_p
parameter_list|(
name|int
parameter_list|,
name|rtx
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|reset_opr_set_tables
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Hash table support.  */
end_comment

begin_function_decl
specifier|static
name|hashval_t
name|hash_expr
parameter_list|(
name|rtx
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|hashval_t
name|hash_expr_for_htab
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|expr_equiv_p
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|insert_expr_in_table
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|expr
modifier|*
name|lookup_expr_in_table
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dump_hash_table_entry
parameter_list|(
name|void
modifier|*
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_hash_table
parameter_list|(
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Helpers for eliminate_partially_redundant_load.  */
end_comment

begin_function_decl
specifier|static
name|bool
name|reg_killed_on_edge
parameter_list|(
name|rtx
parameter_list|,
name|edge
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|reg_used_on_edge
parameter_list|(
name|rtx
parameter_list|,
name|edge
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|get_avail_load_store_reg
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|bb_has_well_behaved_predecessors
parameter_list|(
name|basic_block
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|occr
modifier|*
name|get_bb_avail_insn
parameter_list|(
name|basic_block
parameter_list|,
name|struct
name|occr
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hash_scan_set
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|compute_hash_table
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* The work horses of this pass.  */
end_comment

begin_function_decl
specifier|static
name|void
name|eliminate_partially_redundant_load
parameter_list|(
name|basic_block
parameter_list|,
name|rtx
parameter_list|,
name|struct
name|expr
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|eliminate_partially_redundant_loads
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* Allocate memory for the CUID mapping array and register/memory    tracking tables.  */
end_comment

begin_function
specifier|static
name|void
name|alloc_mem
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
comment|/* Find the largest UID and create a mapping from UIDs to CUIDs.  */
name|uid_cuid
operator|=
name|XCNEWVEC
argument_list|(
name|int
argument_list|,
name|get_max_uid
argument_list|()
operator|+
literal|1
argument_list|)
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
name|FOR_BB_INSNS
argument_list|(
argument|bb
argument_list|,
argument|insn
argument_list|)
block|{
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
name|uid_cuid
index|[
name|INSN_UID
argument_list|(
name|insn
argument_list|)
index|]
operator|=
name|i
operator|++
expr_stmt|;
else|else
name|uid_cuid
index|[
name|INSN_UID
argument_list|(
name|insn
argument_list|)
index|]
operator|=
name|i
expr_stmt|;
block|}
comment|/* Allocate the available expressions hash table.  We don't want to      make the hash table too small, but unnecessarily making it too large      also doesn't help.  The i/4 is a gcse.c relic, and seems like a      reasonable choice.  */
name|expr_table
operator|=
name|htab_create
argument_list|(
name|MAX
argument_list|(
name|i
operator|/
literal|4
argument_list|,
literal|13
argument_list|)
argument_list|,
name|hash_expr_for_htab
argument_list|,
name|expr_equiv_p
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* We allocate everything on obstacks because we often can roll back      the whole obstack to some point.  Freeing obstacks is very fast.  */
name|gcc_obstack_init
argument_list|(
operator|&
name|expr_obstack
argument_list|)
expr_stmt|;
name|gcc_obstack_init
argument_list|(
operator|&
name|occr_obstack
argument_list|)
expr_stmt|;
name|gcc_obstack_init
argument_list|(
operator|&
name|unoccr_obstack
argument_list|)
expr_stmt|;
name|gcc_obstack_init
argument_list|(
operator|&
name|modifies_mem_obstack
argument_list|)
expr_stmt|;
comment|/* Working array used to track the last set for each register      in the current block.  */
name|reg_avail_info
operator|=
operator|(
name|int
operator|*
operator|)
name|xmalloc
argument_list|(
name|FIRST_PSEUDO_REGISTER
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Put a dummy modifies_mem object on the modifies_mem_obstack, so we      can roll it back in reset_opr_set_tables.  */
name|modifies_mem_obstack_bottom
operator|=
operator|(
expr|struct
name|modifies_mem
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|modifies_mem_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|modifies_mem
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Free memory allocated by alloc_mem.  */
end_comment

begin_function
specifier|static
name|void
name|free_mem
parameter_list|(
name|void
parameter_list|)
block|{
name|free
argument_list|(
name|uid_cuid
argument_list|)
expr_stmt|;
name|htab_delete
argument_list|(
name|expr_table
argument_list|)
expr_stmt|;
name|obstack_free
argument_list|(
operator|&
name|expr_obstack
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|obstack_free
argument_list|(
operator|&
name|occr_obstack
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|obstack_free
argument_list|(
operator|&
name|unoccr_obstack
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|obstack_free
argument_list|(
operator|&
name|modifies_mem_obstack
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|reg_avail_info
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Hash expression X.    DO_NOT_RECORD_P is a boolean indicating if a volatile operand is found    or if the expression contains something we don't want to insert in the    table.  */
end_comment

begin_function
specifier|static
name|hashval_t
name|hash_expr
parameter_list|(
name|rtx
name|x
parameter_list|,
name|int
modifier|*
name|do_not_record_p
parameter_list|)
block|{
operator|*
name|do_not_record_p
operator|=
literal|0
expr_stmt|;
return|return
name|hash_rtx
argument_list|(
name|x
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|do_not_record_p
argument_list|,
name|NULL
argument_list|,
comment|/*have_reg_qty=*/
name|false
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Callback for hashtab.    Return the hash value for expression EXP.  We don't actually hash    here, we just return the cached hash value.  */
end_comment

begin_function
specifier|static
name|hashval_t
name|hash_expr_for_htab
parameter_list|(
specifier|const
name|void
modifier|*
name|expp
parameter_list|)
block|{
name|struct
name|expr
modifier|*
name|exp
init|=
operator|(
expr|struct
name|expr
operator|*
operator|)
name|expp
decl_stmt|;
return|return
name|exp
operator|->
name|hash
return|;
block|}
end_function

begin_comment
comment|/* Callback for hashtab.    Return nonzero if exp1 is equivalent to exp2.  */
end_comment

begin_function
specifier|static
name|int
name|expr_equiv_p
parameter_list|(
specifier|const
name|void
modifier|*
name|exp1p
parameter_list|,
specifier|const
name|void
modifier|*
name|exp2p
parameter_list|)
block|{
name|struct
name|expr
modifier|*
name|exp1
init|=
operator|(
expr|struct
name|expr
operator|*
operator|)
name|exp1p
decl_stmt|;
name|struct
name|expr
modifier|*
name|exp2
init|=
operator|(
expr|struct
name|expr
operator|*
operator|)
name|exp2p
decl_stmt|;
name|int
name|equiv_p
init|=
name|exp_equiv_p
argument_list|(
name|exp1
operator|->
name|expr
argument_list|,
name|exp2
operator|->
name|expr
argument_list|,
literal|0
argument_list|,
name|true
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|equiv_p
operator|||
name|exp1
operator|->
name|hash
operator|==
name|exp2
operator|->
name|hash
argument_list|)
expr_stmt|;
return|return
name|equiv_p
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Insert expression X in INSN in the hash TABLE.    If it is already present, record it as the last occurrence in INSN's    basic block.  */
end_comment

begin_function
specifier|static
name|void
name|insert_expr_in_table
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
name|insn
parameter_list|)
block|{
name|int
name|do_not_record_p
decl_stmt|;
name|hashval_t
name|hash
decl_stmt|;
name|struct
name|expr
modifier|*
name|cur_expr
decl_stmt|,
modifier|*
modifier|*
name|slot
decl_stmt|;
name|struct
name|occr
modifier|*
name|avail_occr
decl_stmt|,
modifier|*
name|last_occr
init|=
name|NULL
decl_stmt|;
name|hash
operator|=
name|hash_expr
argument_list|(
name|x
argument_list|,
operator|&
name|do_not_record_p
argument_list|)
expr_stmt|;
comment|/* Do not insert expression in the table if it contains volatile operands,      or if hash_expr determines the expression is something we don't want      to or can't handle.  */
if|if
condition|(
name|do_not_record_p
condition|)
return|return;
comment|/* We anticipate that redundant expressions are rare, so for convenience      allocate a new hash table element here already and set its fields.      If we don't do this, we need a hack with a static struct expr.  Anyway,      obstack_free is really fast and one more obstack_alloc doesn't hurt if      we're going to see more expressions later on.  */
name|cur_expr
operator|=
operator|(
expr|struct
name|expr
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|expr_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|expr
argument_list|)
argument_list|)
expr_stmt|;
name|cur_expr
operator|->
name|expr
operator|=
name|x
expr_stmt|;
name|cur_expr
operator|->
name|hash
operator|=
name|hash
expr_stmt|;
name|cur_expr
operator|->
name|avail_occr
operator|=
name|NULL
expr_stmt|;
name|slot
operator|=
operator|(
expr|struct
name|expr
operator|*
operator|*
operator|)
name|htab_find_slot_with_hash
argument_list|(
name|expr_table
argument_list|,
name|cur_expr
argument_list|,
name|hash
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|slot
operator|)
condition|)
comment|/* The expression isn't found, so insert it.  */
operator|*
name|slot
operator|=
name|cur_expr
expr_stmt|;
else|else
block|{
comment|/* The expression is already in the table, so roll back the 	 obstack and use the existing table entry.  */
name|obstack_free
argument_list|(
operator|&
name|expr_obstack
argument_list|,
name|cur_expr
argument_list|)
expr_stmt|;
name|cur_expr
operator|=
operator|*
name|slot
expr_stmt|;
block|}
comment|/* Search for another occurrence in the same basic block.  */
name|avail_occr
operator|=
name|cur_expr
operator|->
name|avail_occr
expr_stmt|;
while|while
condition|(
name|avail_occr
operator|&&
name|BLOCK_NUM
argument_list|(
name|avail_occr
operator|->
name|insn
argument_list|)
operator|!=
name|BLOCK_NUM
argument_list|(
name|insn
argument_list|)
condition|)
block|{
comment|/* If an occurrence isn't found, save a pointer to the end of 	 the list.  */
name|last_occr
operator|=
name|avail_occr
expr_stmt|;
name|avail_occr
operator|=
name|avail_occr
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|avail_occr
condition|)
comment|/* Found another instance of the expression in the same basic block.        Prefer this occurrence to the currently recorded one.  We want        the last one in the block and the block is scanned from start        to end.  */
name|avail_occr
operator|->
name|insn
operator|=
name|insn
expr_stmt|;
else|else
block|{
comment|/* First occurrence of this expression in this basic block.  */
name|avail_occr
operator|=
operator|(
expr|struct
name|occr
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|occr_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|occr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* First occurrence of this expression in any block?  */
if|if
condition|(
name|cur_expr
operator|->
name|avail_occr
operator|==
name|NULL
condition|)
name|cur_expr
operator|->
name|avail_occr
operator|=
name|avail_occr
expr_stmt|;
else|else
name|last_occr
operator|->
name|next
operator|=
name|avail_occr
expr_stmt|;
name|avail_occr
operator|->
name|insn
operator|=
name|insn
expr_stmt|;
name|avail_occr
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|avail_occr
operator|->
name|deleted_p
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Lookup pattern PAT in the expression hash table.    The result is a pointer to the table entry, or NULL if not found.  */
end_comment

begin_function
specifier|static
name|struct
name|expr
modifier|*
name|lookup_expr_in_table
parameter_list|(
name|rtx
name|pat
parameter_list|)
block|{
name|int
name|do_not_record_p
decl_stmt|;
name|struct
name|expr
modifier|*
modifier|*
name|slot
decl_stmt|,
modifier|*
name|tmp_expr
decl_stmt|;
name|hashval_t
name|hash
init|=
name|hash_expr
argument_list|(
name|pat
argument_list|,
operator|&
name|do_not_record_p
argument_list|)
decl_stmt|;
if|if
condition|(
name|do_not_record_p
condition|)
return|return
name|NULL
return|;
name|tmp_expr
operator|=
operator|(
expr|struct
name|expr
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|expr_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|expr
argument_list|)
argument_list|)
expr_stmt|;
name|tmp_expr
operator|->
name|expr
operator|=
name|pat
expr_stmt|;
name|tmp_expr
operator|->
name|hash
operator|=
name|hash
expr_stmt|;
name|tmp_expr
operator|->
name|avail_occr
operator|=
name|NULL
expr_stmt|;
name|slot
operator|=
operator|(
expr|struct
name|expr
operator|*
operator|*
operator|)
name|htab_find_slot_with_hash
argument_list|(
name|expr_table
argument_list|,
name|tmp_expr
argument_list|,
name|hash
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
name|obstack_free
argument_list|(
operator|&
name|expr_obstack
argument_list|,
name|tmp_expr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|slot
condition|)
return|return
name|NULL
return|;
else|else
return|return
operator|(
operator|*
name|slot
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Dump all expressions and occurrences that are currently in the    expression hash table to FILE.  */
end_comment

begin_comment
comment|/* This helper is called via htab_traverse.  */
end_comment

begin_function
specifier|static
name|int
name|dump_hash_table_entry
parameter_list|(
name|void
modifier|*
modifier|*
name|slot
parameter_list|,
name|void
modifier|*
name|filep
parameter_list|)
block|{
name|struct
name|expr
modifier|*
name|expr
init|=
operator|(
expr|struct
name|expr
operator|*
operator|)
operator|*
name|slot
decl_stmt|;
name|FILE
modifier|*
name|file
init|=
operator|(
name|FILE
operator|*
operator|)
name|filep
decl_stmt|;
name|struct
name|occr
modifier|*
name|occr
decl_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"expr: "
argument_list|)
expr_stmt|;
name|print_rtl
argument_list|(
name|file
argument_list|,
name|expr
operator|->
name|expr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\nhashcode: %u\n"
argument_list|,
name|expr
operator|->
name|hash
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"list of occurrences:\n"
argument_list|)
expr_stmt|;
name|occr
operator|=
name|expr
operator|->
name|avail_occr
expr_stmt|;
while|while
condition|(
name|occr
condition|)
block|{
name|rtx
name|insn
init|=
name|occr
operator|->
name|insn
decl_stmt|;
name|print_rtl_single
argument_list|(
name|file
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|occr
operator|=
name|occr
operator|->
name|next
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dump_hash_table
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n\nexpression hash table\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"size %ld, %ld elements, %f collision/search ratio\n"
argument_list|,
operator|(
name|long
operator|)
name|htab_size
argument_list|(
name|expr_table
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|htab_elements
argument_list|(
name|expr_table
argument_list|)
argument_list|,
name|htab_collisions
argument_list|(
name|expr_table
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab_elements
argument_list|(
name|expr_table
argument_list|)
operator|>
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n\ntable entries:\n"
argument_list|)
expr_stmt|;
name|htab_traverse
argument_list|(
name|expr_table
argument_list|,
name|dump_hash_table_entry
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return true if register X is recorded as being set by an instruction    whose CUID is greater than the one given.  */
end_comment

begin_function
specifier|static
name|bool
name|reg_changed_after_insn_p
parameter_list|(
name|rtx
name|x
parameter_list|,
name|int
name|cuid
parameter_list|)
block|{
name|unsigned
name|int
name|regno
decl_stmt|,
name|end_regno
decl_stmt|;
name|regno
operator|=
name|REGNO
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|end_regno
operator|=
name|END_HARD_REGNO
argument_list|(
name|x
argument_list|)
expr_stmt|;
do|do
if|if
condition|(
name|reg_avail_info
index|[
name|regno
index|]
operator|>
name|cuid
condition|)
return|return
name|true
return|;
do|while
condition|(
operator|++
name|regno
operator|<
name|end_regno
condition|)
do|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if the operands of expression X are unchanged    1) from the start of INSN's basic block up to but not including INSN       if AFTER_INSN is false, or    2) from INSN to the end of INSN's basic block if AFTER_INSN is true.  */
end_comment

begin_function
specifier|static
name|bool
name|oprs_unchanged_p
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
name|insn
parameter_list|,
name|bool
name|after_insn
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return
literal|1
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|REG
case|:
comment|/* We are called after register allocation.  */
name|gcc_assert
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
argument_list|)
expr_stmt|;
if|if
condition|(
name|after_insn
condition|)
return|return
operator|!
name|reg_changed_after_insn_p
argument_list|(
name|x
argument_list|,
name|INSN_CUID
argument_list|(
name|insn
argument_list|)
operator|-
literal|1
argument_list|)
return|;
else|else
return|return
operator|!
name|reg_changed_after_insn_p
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|MEM
case|:
if|if
condition|(
name|load_killed_in_block_p
argument_list|(
name|INSN_CUID
argument_list|(
name|insn
argument_list|)
argument_list|,
name|x
argument_list|,
name|after_insn
argument_list|)
condition|)
return|return
literal|0
return|;
else|else
return|return
name|oprs_unchanged_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn
argument_list|,
name|after_insn
argument_list|)
return|;
case|case
name|PC
case|:
case|case
name|CC0
case|:
comment|/*FIXME*/
case|case
name|CONST
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CONST_VECTOR
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
case|case
name|ADDR_VEC
case|:
case|case
name|ADDR_DIFF_VEC
case|:
return|return
literal|1
return|;
case|case
name|PRE_DEC
case|:
case|case
name|PRE_INC
case|:
case|case
name|POST_DEC
case|:
case|case
name|POST_INC
case|:
case|case
name|PRE_MODIFY
case|:
case|case
name|POST_MODIFY
case|:
if|if
condition|(
name|after_insn
condition|)
return|return
literal|0
return|;
break|break;
default|default:
break|break;
block|}
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
operator|,
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
if|if
condition|(
operator|!
name|oprs_unchanged_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|insn
argument_list|,
name|after_insn
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|!
name|oprs_unchanged_p
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|insn
argument_list|,
name|after_insn
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Used for communication between find_mem_conflicts and    load_killed_in_block_p.  Nonzero if find_mem_conflicts finds a    conflict between two memory references.    This is a bit of a hack to work around the limitations of note_stores.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mems_conflict_p
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* DEST is the output of an instruction.  If it is a memory reference, and    possibly conflicts with the load found in DATA, then set mems_conflict_p    to a nonzero value.  */
end_comment

begin_function
specifier|static
name|void
name|find_mem_conflicts
parameter_list|(
name|rtx
name|dest
parameter_list|,
name|rtx
name|setter
name|ATTRIBUTE_UNUSED
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|rtx
name|mem_op
init|=
operator|(
name|rtx
operator|)
name|data
decl_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|STRICT_LOW_PART
condition|)
name|dest
operator|=
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If DEST is not a MEM, then it will not conflict with the load.  Note      that function calls are assumed to clobber memory, but are handled      elsewhere.  */
if|if
condition|(
operator|!
name|MEM_P
argument_list|(
name|dest
argument_list|)
condition|)
return|return;
if|if
condition|(
name|true_dependence
argument_list|(
name|dest
argument_list|,
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|,
name|mem_op
argument_list|,
name|rtx_addr_varies_p
argument_list|)
condition|)
name|mems_conflict_p
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return nonzero if the expression in X (a memory reference) is killed    in the current basic block before (if AFTER_INSN is false) or after    (if AFTER_INSN is true) the insn with the CUID in UID_LIMIT.     This function assumes that the modifies_mem table is flushed when    the hash table construction or redundancy elimination phases start    processing a new basic block.  */
end_comment

begin_function
specifier|static
name|int
name|load_killed_in_block_p
parameter_list|(
name|int
name|uid_limit
parameter_list|,
name|rtx
name|x
parameter_list|,
name|bool
name|after_insn
parameter_list|)
block|{
name|struct
name|modifies_mem
modifier|*
name|list_entry
init|=
name|modifies_mem_list
decl_stmt|;
while|while
condition|(
name|list_entry
condition|)
block|{
name|rtx
name|setter
init|=
name|list_entry
operator|->
name|insn
decl_stmt|;
comment|/* Ignore entries in the list that do not apply.  */
if|if
condition|(
operator|(
name|after_insn
operator|&&
name|INSN_CUID
argument_list|(
name|setter
argument_list|)
operator|<
name|uid_limit
operator|)
operator|||
operator|(
operator|!
name|after_insn
operator|&&
name|INSN_CUID
argument_list|(
name|setter
argument_list|)
operator|>
name|uid_limit
operator|)
condition|)
block|{
name|list_entry
operator|=
name|list_entry
operator|->
name|next
expr_stmt|;
continue|continue;
block|}
comment|/* If SETTER is a call everything is clobbered.  Note that calls 	 to pure functions are never put on the list, so we need not 	 worry about them.  */
if|if
condition|(
name|CALL_P
argument_list|(
name|setter
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* SETTER must be an insn of some kind that sets memory.  Call 	 note_stores to examine each hunk of memory that is modified. 	 It will set mems_conflict_p to nonzero if there may be a 	 conflict between X and SETTER.  */
name|mems_conflict_p
operator|=
literal|0
expr_stmt|;
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|setter
argument_list|)
argument_list|,
name|find_mem_conflicts
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|mems_conflict_p
condition|)
return|return
literal|1
return|;
name|list_entry
operator|=
name|list_entry
operator|->
name|next
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Record register first/last/block set information for REGNO in INSN.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|record_last_reg_set_info
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|int
name|regno
parameter_list|)
block|{
name|reg_avail_info
index|[
name|regno
index|]
operator|=
name|INSN_CUID
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Record memory modification information for INSN.  We do not actually care    about the memory location(s) that are set, or even how they are set (consider    a CALL_INSN).  We merely need to record which insns modify memory.  */
end_comment

begin_function
specifier|static
name|void
name|record_last_mem_set_info
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|struct
name|modifies_mem
modifier|*
name|list_entry
decl_stmt|;
name|list_entry
operator|=
operator|(
expr|struct
name|modifies_mem
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|modifies_mem_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|modifies_mem
argument_list|)
argument_list|)
expr_stmt|;
name|list_entry
operator|->
name|insn
operator|=
name|insn
expr_stmt|;
name|list_entry
operator|->
name|next
operator|=
name|modifies_mem_list
expr_stmt|;
name|modifies_mem_list
operator|=
name|list_entry
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called from compute_hash_table via note_stores to handle one    SET or CLOBBER in an insn.  DATA is really the instruction in which    the SET is taking place.  */
end_comment

begin_function
specifier|static
name|void
name|record_last_set_info
parameter_list|(
name|rtx
name|dest
parameter_list|,
name|rtx
name|setter
name|ATTRIBUTE_UNUSED
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|rtx
name|last_set_insn
init|=
operator|(
name|rtx
operator|)
name|data
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
condition|)
name|dest
operator|=
name|SUBREG_REG
argument_list|(
name|dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|REG_P
argument_list|(
name|dest
argument_list|)
condition|)
name|record_last_reg_set_info
argument_list|(
name|last_set_insn
argument_list|,
name|REGNO
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|MEM_P
argument_list|(
name|dest
argument_list|)
condition|)
block|{
comment|/* Ignore pushes, they don't clobber memory.  They may still 	 clobber the stack pointer though.  Some targets do argument 	 pushes without adding REG_INC notes.  See e.g. PR25196, 	 where a pushsi2 on i386 doesn't have REG_INC notes.  Note 	 such changes here too.  */
if|if
condition|(
operator|!
name|push_operand
argument_list|(
name|dest
argument_list|,
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
condition|)
name|record_last_mem_set_info
argument_list|(
name|last_set_insn
argument_list|)
expr_stmt|;
else|else
name|record_last_reg_set_info
argument_list|(
name|last_set_insn
argument_list|,
name|STACK_POINTER_REGNUM
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Reset tables used to keep track of what's still available since the    start of the block.  */
end_comment

begin_function
specifier|static
name|void
name|reset_opr_set_tables
parameter_list|(
name|void
parameter_list|)
block|{
name|memset
argument_list|(
name|reg_avail_info
argument_list|,
literal|0
argument_list|,
name|FIRST_PSEUDO_REGISTER
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|obstack_free
argument_list|(
operator|&
name|modifies_mem_obstack
argument_list|,
name|modifies_mem_obstack_bottom
argument_list|)
expr_stmt|;
name|modifies_mem_list
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Record things set by INSN.    This data is used by oprs_unchanged_p.  */
end_comment

begin_function
specifier|static
name|void
name|record_opr_changes
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|rtx
name|note
decl_stmt|;
comment|/* Find all stores and record them.  */
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|record_last_set_info
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* Also record autoincremented REGs for this insn as changed.  */
for|for
control|(
name|note
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|note
condition|;
name|note
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
operator|==
name|REG_INC
condition|)
name|record_last_reg_set_info
argument_list|(
name|insn
argument_list|,
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Finally, if this is a call, record all call clobbers.  */
if|if
condition|(
name|CALL_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|unsigned
name|int
name|regno
decl_stmt|,
name|end_regno
decl_stmt|;
name|rtx
name|link
decl_stmt|,
name|x
decl_stmt|;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|regs_invalidated_by_call
argument_list|,
name|regno
argument_list|)
condition|)
name|record_last_reg_set_info
argument_list|(
name|insn
argument_list|,
name|regno
argument_list|)
expr_stmt|;
for|for
control|(
name|link
operator|=
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CLOBBER
condition|)
block|{
name|x
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|REG_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|gcc_assert
argument_list|(
name|HARD_REGISTER_P
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|regno
operator|=
name|REGNO
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|end_regno
operator|=
name|END_HARD_REGNO
argument_list|(
name|x
argument_list|)
expr_stmt|;
do|do
name|record_last_reg_set_info
argument_list|(
name|insn
argument_list|,
name|regno
argument_list|)
expr_stmt|;
do|while
condition|(
operator|++
name|regno
operator|<
name|end_regno
condition|)
do|;
block|}
block|}
if|if
condition|(
operator|!
name|CONST_OR_PURE_CALL_P
argument_list|(
name|insn
argument_list|)
condition|)
name|record_last_mem_set_info
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Scan the pattern of INSN and add an entry to the hash TABLE.    After reload we are interested in loads/stores only.  */
end_comment

begin_function
specifier|static
name|void
name|hash_scan_set
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|src
init|=
name|SET_SRC
argument_list|(
name|pat
argument_list|)
decl_stmt|;
name|rtx
name|dest
init|=
name|SET_DEST
argument_list|(
name|pat
argument_list|)
decl_stmt|;
comment|/* We are only interested in loads and stores.  */
if|if
condition|(
operator|!
name|MEM_P
argument_list|(
name|src
argument_list|)
operator|&&
operator|!
name|MEM_P
argument_list|(
name|dest
argument_list|)
condition|)
return|return;
comment|/* Don't mess with jumps and nops.  */
if|if
condition|(
name|JUMP_P
argument_list|(
name|insn
argument_list|)
operator|||
name|set_noop_p
argument_list|(
name|pat
argument_list|)
condition|)
return|return;
if|if
condition|(
name|REG_P
argument_list|(
name|dest
argument_list|)
condition|)
block|{
if|if
condition|(
comment|/* Don't CSE something if we can't do a reg/reg copy.  */
name|can_copy_p
argument_list|(
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
comment|/* Is SET_SRC something we want to gcse?  */
operator|&&
name|general_operand
argument_list|(
name|src
argument_list|,
name|GET_MODE
argument_list|(
name|src
argument_list|)
argument_list|)
ifdef|#
directive|ifdef
name|STACK_REGS
comment|/* Never consider insns touching the register stack.  It may 	     create situations that reg-stack cannot handle (e.g. a stack 	     register live across an abnormal edge).  */
operator|&&
operator|(
name|REGNO
argument_list|(
name|dest
argument_list|)
operator|<
name|FIRST_STACK_REG
operator|||
name|REGNO
argument_list|(
name|dest
argument_list|)
operator|>
name|LAST_STACK_REG
operator|)
endif|#
directive|endif
comment|/* An expression is not available if its operands are 	     subsequently modified, including this insn.  */
operator|&&
name|oprs_unchanged_p
argument_list|(
name|src
argument_list|,
name|insn
argument_list|,
name|true
argument_list|)
condition|)
block|{
name|insert_expr_in_table
argument_list|(
name|src
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|REG_P
argument_list|(
name|src
argument_list|)
condition|)
block|{
comment|/* Only record sets of pseudo-regs in the hash table.  */
if|if
condition|(
comment|/* Don't CSE something if we can't do a reg/reg copy.  */
name|can_copy_p
argument_list|(
name|GET_MODE
argument_list|(
name|src
argument_list|)
argument_list|)
comment|/* Is SET_DEST something we want to gcse?  */
operator|&&
name|general_operand
argument_list|(
name|dest
argument_list|,
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
ifdef|#
directive|ifdef
name|STACK_REGS
comment|/* As above for STACK_REGS.  */
operator|&&
operator|(
name|REGNO
argument_list|(
name|src
argument_list|)
operator|<
name|FIRST_STACK_REG
operator|||
name|REGNO
argument_list|(
name|src
argument_list|)
operator|>
name|LAST_STACK_REG
operator|)
endif|#
directive|endif
operator|&&
operator|!
operator|(
name|flag_float_store
operator|&&
name|FLOAT_MODE_P
argument_list|(
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|)
comment|/* Check if the memory expression is killed after insn.  */
operator|&&
operator|!
name|load_killed_in_block_p
argument_list|(
name|INSN_CUID
argument_list|(
name|insn
argument_list|)
operator|+
literal|1
argument_list|,
name|dest
argument_list|,
name|true
argument_list|)
operator|&&
name|oprs_unchanged_p
argument_list|(
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn
argument_list|,
name|true
argument_list|)
condition|)
block|{
name|insert_expr_in_table
argument_list|(
name|dest
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Create hash table of memory expressions available at end of basic    blocks.  Basically you should think of this hash table as the    representation of AVAIL_OUT.  This is the set of expressions that    is generated in a basic block and not killed before the end of the    same basic block.  Notice that this is really a local computation.  */
end_comment

begin_function
specifier|static
name|void
name|compute_hash_table
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|rtx
name|insn
decl_stmt|;
comment|/* First pass over the instructions records information used to 	 determine when registers and memory are last set. 	 Since we compute a "local" AVAIL_OUT, reset the tables that 	 help us keep track of what has been modified since the start 	 of the block.  */
name|reset_opr_set_tables
argument_list|()
expr_stmt|;
name|FOR_BB_INSNS
argument_list|(
argument|bb
argument_list|,
argument|insn
argument_list|)
block|{
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
name|record_opr_changes
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
comment|/* The next pass actually builds the hash table.  */
name|FOR_BB_INSNS
argument_list|(
argument|bb
argument_list|,
argument|insn
argument_list|)
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
condition|)
name|hash_scan_set
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Check if register REG is killed in any insn waiting to be inserted on    edge E.  This function is required to check that our data flow analysis    is still valid prior to commit_edge_insertions.  */
end_comment

begin_function
specifier|static
name|bool
name|reg_killed_on_edge
parameter_list|(
name|rtx
name|reg
parameter_list|,
name|edge
name|e
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|e
operator|->
name|insns
operator|.
name|r
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|reg_set_p
argument_list|(
name|reg
argument_list|,
name|insn
argument_list|)
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Similar to above - check if register REG is used in any insn waiting    to be inserted on edge E.    Assumes no such insn can be a CALL_INSN; if so call reg_used_between_p    with PREV(insn),NEXT(insn) instead of calling reg_overlap_mentioned_p.  */
end_comment

begin_function
specifier|static
name|bool
name|reg_used_on_edge
parameter_list|(
name|rtx
name|reg
parameter_list|,
name|edge
name|e
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|e
operator|->
name|insns
operator|.
name|r
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|reg
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the loaded/stored register of a load/store instruction.  */
end_comment

begin_function
specifier|static
name|rtx
name|get_avail_load_store_reg
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
if|if
condition|(
name|REG_P
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
condition|)
comment|/* A load.  */
return|return
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
return|;
else|else
block|{
comment|/* A store.  */
name|gcc_assert
argument_list|(
name|REG_P
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return nonzero if the predecessors of BB are "well behaved".  */
end_comment

begin_function
specifier|static
name|bool
name|bb_has_well_behaved_predecessors
parameter_list|(
name|basic_block
name|bb
parameter_list|)
block|{
name|edge
name|pred
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
if|if
condition|(
name|EDGE_COUNT
argument_list|(
name|bb
operator|->
name|preds
argument_list|)
operator|==
literal|0
condition|)
return|return
name|false
return|;
name|FOR_EACH_EDGE
argument_list|(
argument|pred
argument_list|,
argument|ei
argument_list|,
argument|bb->preds
argument_list|)
block|{
if|if
condition|(
operator|(
name|pred
operator|->
name|flags
operator|&
name|EDGE_ABNORMAL
operator|)
operator|&&
name|EDGE_CRITICAL_P
argument_list|(
name|pred
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|JUMP_TABLE_DATA_P
argument_list|(
name|BB_END
argument_list|(
name|pred
operator|->
name|src
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Search for the occurrences of expression in BB.  */
end_comment

begin_function
specifier|static
name|struct
name|occr
modifier|*
name|get_bb_avail_insn
parameter_list|(
name|basic_block
name|bb
parameter_list|,
name|struct
name|occr
modifier|*
name|occr
parameter_list|)
block|{
for|for
control|(
init|;
name|occr
operator|!=
name|NULL
condition|;
name|occr
operator|=
name|occr
operator|->
name|next
control|)
if|if
condition|(
name|BLOCK_FOR_INSN
argument_list|(
name|occr
operator|->
name|insn
argument_list|)
operator|==
name|bb
condition|)
return|return
name|occr
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* This handles the case where several stores feed a partially redundant    load. It checks if the redundancy elimination is possible and if it's    worth it.     Redundancy elimination is possible if,    1) None of the operands of an insn have been modified since the start       of the current basic block.    2) In any predecessor of the current basic block, the same expression       is generated.     See the function body for the heuristics that determine if eliminating    a redundancy is also worth doing, assuming it is possible.  */
end_comment

begin_function
specifier|static
name|void
name|eliminate_partially_redundant_load
parameter_list|(
name|basic_block
name|bb
parameter_list|,
name|rtx
name|insn
parameter_list|,
name|struct
name|expr
modifier|*
name|expr
parameter_list|)
block|{
name|edge
name|pred
decl_stmt|;
name|rtx
name|avail_insn
init|=
name|NULL_RTX
decl_stmt|;
name|rtx
name|avail_reg
decl_stmt|;
name|rtx
name|dest
decl_stmt|,
name|pat
decl_stmt|;
name|struct
name|occr
modifier|*
name|a_occr
decl_stmt|;
name|struct
name|unoccr
modifier|*
name|occr
decl_stmt|,
modifier|*
name|avail_occrs
init|=
name|NULL
decl_stmt|;
name|struct
name|unoccr
modifier|*
name|unoccr
decl_stmt|,
modifier|*
name|unavail_occrs
init|=
name|NULL
decl_stmt|,
modifier|*
name|rollback_unoccr
init|=
name|NULL
decl_stmt|;
name|int
name|npred_ok
init|=
literal|0
decl_stmt|;
name|gcov_type
name|ok_count
init|=
literal|0
decl_stmt|;
comment|/* Redundant load execution count.  */
name|gcov_type
name|critical_count
init|=
literal|0
decl_stmt|;
comment|/* Execution count of critical edges.  */
name|edge_iterator
name|ei
decl_stmt|;
name|bool
name|critical_edge_split
init|=
name|false
decl_stmt|;
comment|/* The execution count of the loads to be added to make the      load fully redundant.  */
name|gcov_type
name|not_ok_count
init|=
literal|0
decl_stmt|;
name|basic_block
name|pred_bb
decl_stmt|;
name|pat
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|dest
operator|=
name|SET_DEST
argument_list|(
name|pat
argument_list|)
expr_stmt|;
comment|/* Check that the loaded register is not used, set, or killed from the      beginning of the block.  */
if|if
condition|(
name|reg_changed_after_insn_p
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
operator|||
name|reg_used_between_p
argument_list|(
name|dest
argument_list|,
name|PREV_INSN
argument_list|(
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
argument_list|)
argument_list|,
name|insn
argument_list|)
condition|)
return|return;
comment|/* Check potential for replacing load with copy for predecessors.  */
name|FOR_EACH_EDGE
argument_list|(
argument|pred
argument_list|,
argument|ei
argument_list|,
argument|bb->preds
argument_list|)
block|{
name|rtx
name|next_pred_bb_end
decl_stmt|;
name|avail_insn
operator|=
name|NULL_RTX
expr_stmt|;
name|avail_reg
operator|=
name|NULL_RTX
expr_stmt|;
name|pred_bb
operator|=
name|pred
operator|->
name|src
expr_stmt|;
name|next_pred_bb_end
operator|=
name|NEXT_INSN
argument_list|(
name|BB_END
argument_list|(
name|pred_bb
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|a_occr
operator|=
name|get_bb_avail_insn
argument_list|(
name|pred_bb
argument_list|,
name|expr
operator|->
name|avail_occr
argument_list|)
init|;
name|a_occr
condition|;
name|a_occr
operator|=
name|get_bb_avail_insn
argument_list|(
name|pred_bb
argument_list|,
name|a_occr
operator|->
name|next
argument_list|)
control|)
block|{
comment|/* Check if the loaded register is not used.  */
name|avail_insn
operator|=
name|a_occr
operator|->
name|insn
expr_stmt|;
name|avail_reg
operator|=
name|get_avail_load_store_reg
argument_list|(
name|avail_insn
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|avail_reg
argument_list|)
expr_stmt|;
comment|/* Make sure we can generate a move from register avail_reg to 	     dest.  */
name|extract_insn
argument_list|(
name|gen_move_insn
argument_list|(
name|copy_rtx
argument_list|(
name|dest
argument_list|)
argument_list|,
name|copy_rtx
argument_list|(
name|avail_reg
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|constrain_operands
argument_list|(
literal|1
argument_list|)
operator|||
name|reg_killed_on_edge
argument_list|(
name|avail_reg
argument_list|,
name|pred
argument_list|)
operator|||
name|reg_used_on_edge
argument_list|(
name|dest
argument_list|,
name|pred
argument_list|)
condition|)
block|{
name|avail_insn
operator|=
name|NULL
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|reg_set_between_p
argument_list|(
name|avail_reg
argument_list|,
name|avail_insn
argument_list|,
name|next_pred_bb_end
argument_list|)
condition|)
comment|/* AVAIL_INSN remains non-null.  */
break|break;
else|else
name|avail_insn
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|EDGE_CRITICAL_P
argument_list|(
name|pred
argument_list|)
condition|)
name|critical_count
operator|+=
name|pred
operator|->
name|count
expr_stmt|;
if|if
condition|(
name|avail_insn
operator|!=
name|NULL_RTX
condition|)
block|{
name|npred_ok
operator|++
expr_stmt|;
name|ok_count
operator|+=
name|pred
operator|->
name|count
expr_stmt|;
if|if
condition|(
operator|!
name|set_noop_p
argument_list|(
name|PATTERN
argument_list|(
name|gen_move_insn
argument_list|(
name|copy_rtx
argument_list|(
name|dest
argument_list|)
argument_list|,
name|copy_rtx
argument_list|(
name|avail_reg
argument_list|)
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Check if there is going to be a split.  */
if|if
condition|(
name|EDGE_CRITICAL_P
argument_list|(
name|pred
argument_list|)
condition|)
name|critical_edge_split
operator|=
name|true
expr_stmt|;
block|}
else|else
comment|/* Its a dead move no need to generate.  */
continue|continue;
name|occr
operator|=
operator|(
expr|struct
name|unoccr
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|unoccr_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|unoccr
argument_list|)
argument_list|)
expr_stmt|;
name|occr
operator|->
name|insn
operator|=
name|avail_insn
expr_stmt|;
name|occr
operator|->
name|pred
operator|=
name|pred
expr_stmt|;
name|occr
operator|->
name|next
operator|=
name|avail_occrs
expr_stmt|;
name|avail_occrs
operator|=
name|occr
expr_stmt|;
if|if
condition|(
operator|!
name|rollback_unoccr
condition|)
name|rollback_unoccr
operator|=
name|occr
expr_stmt|;
block|}
else|else
block|{
comment|/* Adding a load on a critical edge will cause a split.  */
if|if
condition|(
name|EDGE_CRITICAL_P
argument_list|(
name|pred
argument_list|)
condition|)
name|critical_edge_split
operator|=
name|true
expr_stmt|;
name|not_ok_count
operator|+=
name|pred
operator|->
name|count
expr_stmt|;
name|unoccr
operator|=
operator|(
expr|struct
name|unoccr
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|unoccr_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|unoccr
argument_list|)
argument_list|)
expr_stmt|;
name|unoccr
operator|->
name|insn
operator|=
name|NULL_RTX
expr_stmt|;
name|unoccr
operator|->
name|pred
operator|=
name|pred
expr_stmt|;
name|unoccr
operator|->
name|next
operator|=
name|unavail_occrs
expr_stmt|;
name|unavail_occrs
operator|=
name|unoccr
expr_stmt|;
if|if
condition|(
operator|!
name|rollback_unoccr
condition|)
name|rollback_unoccr
operator|=
name|unoccr
expr_stmt|;
block|}
block|}
if|if
condition|(
comment|/* No load can be replaced by copy.  */
name|npred_ok
operator|==
literal|0
comment|/* Prevent exploding the code.  */
operator|||
operator|(
name|optimize_size
operator|&&
name|npred_ok
operator|>
literal|1
operator|)
comment|/* If we don't have profile information we cannot tell if splitting           a critical edge is profitable or not so don't do it.  */
operator|||
operator|(
operator|(
operator|!
name|profile_info
operator|||
operator|!
name|flag_branch_probabilities
operator|||
name|targetm
operator|.
name|cannot_modify_jumps_p
argument_list|()
operator|)
operator|&&
name|critical_edge_split
operator|)
condition|)
goto|goto
name|cleanup
goto|;
comment|/* Check if it's worth applying the partial redundancy elimination.  */
if|if
condition|(
name|ok_count
operator|<
name|GCSE_AFTER_RELOAD_PARTIAL_FRACTION
operator|*
name|not_ok_count
condition|)
goto|goto
name|cleanup
goto|;
if|if
condition|(
name|ok_count
operator|<
name|GCSE_AFTER_RELOAD_CRITICAL_FRACTION
operator|*
name|critical_count
condition|)
goto|goto
name|cleanup
goto|;
comment|/* Generate moves to the loaded register from where      the memory is available.  */
for|for
control|(
name|occr
operator|=
name|avail_occrs
init|;
name|occr
condition|;
name|occr
operator|=
name|occr
operator|->
name|next
control|)
block|{
name|avail_insn
operator|=
name|occr
operator|->
name|insn
expr_stmt|;
name|pred
operator|=
name|occr
operator|->
name|pred
expr_stmt|;
comment|/* Set avail_reg to be the register having the value of the 	 memory.  */
name|avail_reg
operator|=
name|get_avail_load_store_reg
argument_list|(
name|avail_insn
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|avail_reg
argument_list|)
expr_stmt|;
name|insert_insn_on_edge
argument_list|(
name|gen_move_insn
argument_list|(
name|copy_rtx
argument_list|(
name|dest
argument_list|)
argument_list|,
name|copy_rtx
argument_list|(
name|avail_reg
argument_list|)
argument_list|)
argument_list|,
name|pred
argument_list|)
expr_stmt|;
name|stats
operator|.
name|moves_inserted
operator|++
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"generating move from %d to %d on edge from %d to %d\n"
argument_list|,
name|REGNO
argument_list|(
name|avail_reg
argument_list|)
argument_list|,
name|REGNO
argument_list|(
name|dest
argument_list|)
argument_list|,
name|pred
operator|->
name|src
operator|->
name|index
argument_list|,
name|pred
operator|->
name|dest
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
comment|/* Regenerate loads where the memory is unavailable.  */
for|for
control|(
name|unoccr
operator|=
name|unavail_occrs
init|;
name|unoccr
condition|;
name|unoccr
operator|=
name|unoccr
operator|->
name|next
control|)
block|{
name|pred
operator|=
name|unoccr
operator|->
name|pred
expr_stmt|;
name|insert_insn_on_edge
argument_list|(
name|copy_insn
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|,
name|pred
argument_list|)
expr_stmt|;
name|stats
operator|.
name|copies_inserted
operator|++
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"generating on edge from %d to %d a copy of load: "
argument_list|,
name|pred
operator|->
name|src
operator|->
name|index
argument_list|,
name|pred
operator|->
name|dest
operator|->
name|index
argument_list|)
expr_stmt|;
name|print_rtl
argument_list|(
name|dump_file
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Delete the insn if it is not available in this block and mark it      for deletion if it is available. If insn is available it may help      discover additional redundancies, so mark it for later deletion.  */
for|for
control|(
name|a_occr
operator|=
name|get_bb_avail_insn
argument_list|(
name|bb
argument_list|,
name|expr
operator|->
name|avail_occr
argument_list|)
init|;
name|a_occr
operator|&&
operator|(
name|a_occr
operator|->
name|insn
operator|!=
name|insn
operator|)
condition|;
name|a_occr
operator|=
name|get_bb_avail_insn
argument_list|(
name|bb
argument_list|,
name|a_occr
operator|->
name|next
argument_list|)
control|)
empty_stmt|;
if|if
condition|(
operator|!
name|a_occr
condition|)
block|{
name|stats
operator|.
name|insns_deleted
operator|++
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"deleting insn:\n"
argument_list|)
expr_stmt|;
name|print_rtl_single
argument_list|(
name|dump_file
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|delete_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
else|else
name|a_occr
operator|->
name|deleted_p
operator|=
literal|1
expr_stmt|;
name|cleanup
label|:
if|if
condition|(
name|rollback_unoccr
condition|)
name|obstack_free
argument_list|(
operator|&
name|unoccr_obstack
argument_list|,
name|rollback_unoccr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Performing the redundancy elimination as described before.  */
end_comment

begin_function
specifier|static
name|void
name|eliminate_partially_redundant_loads
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
comment|/* Note we start at block 1.  */
if|if
condition|(
name|ENTRY_BLOCK_PTR
operator|->
name|next_bb
operator|==
name|EXIT_BLOCK_PTR
condition|)
return|return;
name|FOR_BB_BETWEEN
argument_list|(
argument|bb
argument_list|,
argument|ENTRY_BLOCK_PTR->next_bb->next_bb
argument_list|,
argument|EXIT_BLOCK_PTR
argument_list|,
argument|next_bb
argument_list|)
block|{
comment|/* Don't try anything on basic blocks with strange predecessors.  */
if|if
condition|(
operator|!
name|bb_has_well_behaved_predecessors
argument_list|(
name|bb
argument_list|)
condition|)
continue|continue;
comment|/* Do not try anything on cold basic blocks.  */
if|if
condition|(
name|probably_cold_bb_p
argument_list|(
name|bb
argument_list|)
condition|)
continue|continue;
comment|/* Reset the table of things changed since the start of the current 	 basic block.  */
name|reset_opr_set_tables
argument_list|()
expr_stmt|;
comment|/* Look at all insns in the current basic block and see if there are 	 any loads in it that we can record.  */
name|FOR_BB_INSNS
argument_list|(
argument|bb
argument_list|,
argument|insn
argument_list|)
block|{
comment|/* Is it a load - of the form (set (reg) (mem))?  */
if|if
condition|(
name|NONJUMP_INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|REG_P
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|MEM_P
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|src
init|=
name|SET_SRC
argument_list|(
name|pat
argument_list|)
decl_stmt|;
name|struct
name|expr
modifier|*
name|expr
decl_stmt|;
if|if
condition|(
operator|!
name|MEM_VOLATILE_P
argument_list|(
name|src
argument_list|)
operator|&&
name|GET_MODE
argument_list|(
name|src
argument_list|)
operator|!=
name|BLKmode
operator|&&
name|general_operand
argument_list|(
name|src
argument_list|,
name|GET_MODE
argument_list|(
name|src
argument_list|)
argument_list|)
comment|/* Are the operands unchanged since the start of the 		     block?  */
operator|&&
name|oprs_unchanged_p
argument_list|(
name|src
argument_list|,
name|insn
argument_list|,
name|false
argument_list|)
operator|&&
operator|!
operator|(
name|flag_non_call_exceptions
operator|&&
name|may_trap_p
argument_list|(
name|src
argument_list|)
operator|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|src
argument_list|)
comment|/* Is the expression recorded?  */
operator|&&
operator|(
name|expr
operator|=
name|lookup_expr_in_table
argument_list|(
name|src
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* We now have a load (insn) and an available memory at 		     its BB start (expr). Try to remove the loads if it is 		     redundant.  */
name|eliminate_partially_redundant_load
argument_list|(
name|bb
argument_list|,
name|insn
argument_list|,
name|expr
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Keep track of everything modified by this insn, so that we 	     know what has been modified since the start of the current 	     basic block.  */
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
name|record_opr_changes
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
name|commit_edge_insertions
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Go over the expression hash table and delete insns that were    marked for later deletion.  */
end_comment

begin_comment
comment|/* This helper is called via htab_traverse.  */
end_comment

begin_function
specifier|static
name|int
name|delete_redundant_insns_1
parameter_list|(
name|void
modifier|*
modifier|*
name|slot
parameter_list|,
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|struct
name|expr
modifier|*
name|expr
init|=
operator|(
expr|struct
name|expr
operator|*
operator|)
operator|*
name|slot
decl_stmt|;
name|struct
name|occr
modifier|*
name|occr
decl_stmt|;
for|for
control|(
name|occr
operator|=
name|expr
operator|->
name|avail_occr
init|;
name|occr
operator|!=
name|NULL
condition|;
name|occr
operator|=
name|occr
operator|->
name|next
control|)
block|{
if|if
condition|(
name|occr
operator|->
name|deleted_p
condition|)
block|{
name|delete_insn
argument_list|(
name|occr
operator|->
name|insn
argument_list|)
expr_stmt|;
name|stats
operator|.
name|insns_deleted
operator|++
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"deleting insn:\n"
argument_list|)
expr_stmt|;
name|print_rtl_single
argument_list|(
name|dump_file
argument_list|,
name|occr
operator|->
name|insn
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|delete_redundant_insns
parameter_list|(
name|void
parameter_list|)
block|{
name|htab_traverse
argument_list|(
name|expr_table
argument_list|,
name|delete_redundant_insns_1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Main entry point of the GCSE after reload - clean some redundant loads    due to spilling.  */
end_comment

begin_function
specifier|static
name|void
name|gcse_after_reload_main
parameter_list|(
name|rtx
name|f
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|memset
argument_list|(
operator|&
name|stats
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|stats
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Allocate ememory for this pass.      Also computes and initializes the insns' CUIDs.  */
name|alloc_mem
argument_list|()
expr_stmt|;
comment|/* We need alias analysis.  */
name|init_alias_analysis
argument_list|()
expr_stmt|;
name|compute_hash_table
argument_list|()
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
name|dump_hash_table
argument_list|(
name|dump_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab_elements
argument_list|(
name|expr_table
argument_list|)
operator|>
literal|0
condition|)
block|{
name|eliminate_partially_redundant_loads
argument_list|()
expr_stmt|;
name|delete_redundant_insns
argument_list|()
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"GCSE AFTER RELOAD stats:\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"copies inserted: %d\n"
argument_list|,
name|stats
operator|.
name|copies_inserted
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"moves inserted:  %d\n"
argument_list|,
name|stats
operator|.
name|moves_inserted
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"insns deleted:   %d\n"
argument_list|,
name|stats
operator|.
name|insns_deleted
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n\n"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* We are finished with alias.  */
name|end_alias_analysis
argument_list|()
expr_stmt|;
name|free_mem
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|bool
name|gate_handle_gcse2
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|optimize
operator|>
literal|0
operator|&&
name|flag_gcse_after_reload
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|rest_of_handle_gcse2
parameter_list|(
name|void
parameter_list|)
block|{
name|gcse_after_reload_main
argument_list|(
name|get_insns
argument_list|()
argument_list|)
expr_stmt|;
name|rebuild_jump_labels
argument_list|(
name|get_insns
argument_list|()
argument_list|)
expr_stmt|;
name|delete_trivially_dead_insns
argument_list|(
name|get_insns
argument_list|()
argument_list|,
name|max_reg_num
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|tree_opt_pass
name|pass_gcse2
init|=
block|{
literal|"gcse2"
block|,
comment|/* name */
name|gate_handle_gcse2
block|,
comment|/* gate */
name|rest_of_handle_gcse2
block|,
comment|/* execute */
name|NULL
block|,
comment|/* sub */
name|NULL
block|,
comment|/* next */
literal|0
block|,
comment|/* static_pass_number */
name|TV_GCSE_AFTER_RELOAD
block|,
comment|/* tv_id */
literal|0
block|,
comment|/* properties_required */
literal|0
block|,
comment|/* properties_provided */
literal|0
block|,
comment|/* properties_destroyed */
literal|0
block|,
comment|/* todo_flags_start */
name|TODO_dump_func
operator||
name|TODO_verify_flow
operator||
name|TODO_ggc_collect
block|,
comment|/* todo_flags_finish */
literal|'J'
comment|/* letter */
block|}
decl_stmt|;
end_decl_stmt

end_unit

