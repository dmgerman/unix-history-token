begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Map logical line numbers to (source file, line number) pairs.    Copyright (C) 2001, 2003    Free Software Foundation, Inc.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.   In other words, you are welcome to use, share and improve this program.  You are forbidden to forbid anyone else to use, share and improve  what you give them.   Help stamp out software-hoarding!  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"line-map.h"
end_include

begin_include
include|#
directive|include
file|"intl.h"
end_include

begin_function_decl
specifier|static
name|void
name|trace_include
parameter_list|(
specifier|const
name|struct
name|line_maps
modifier|*
parameter_list|,
specifier|const
name|struct
name|line_map
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Initialize a line map set.  */
end_comment

begin_function
name|void
name|linemap_init
parameter_list|(
name|struct
name|line_maps
modifier|*
name|set
parameter_list|)
block|{
name|set
operator|->
name|maps
operator|=
literal|0
expr_stmt|;
name|set
operator|->
name|allocated
operator|=
literal|0
expr_stmt|;
name|set
operator|->
name|used
operator|=
literal|0
expr_stmt|;
name|set
operator|->
name|last_listed
operator|=
operator|-
literal|1
expr_stmt|;
name|set
operator|->
name|trace_includes
operator|=
name|false
expr_stmt|;
name|set
operator|->
name|depth
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Free a line map set.  */
end_comment

begin_function
name|void
name|linemap_free
parameter_list|(
name|struct
name|line_maps
modifier|*
name|set
parameter_list|)
block|{
if|if
condition|(
name|set
operator|->
name|maps
condition|)
block|{
name|struct
name|line_map
modifier|*
name|map
decl_stmt|;
comment|/* Depending upon whether we are handling preprocessed input or 	 not, this can be a user error or an ICE.  */
for|for
control|(
name|map
operator|=
name|CURRENT_LINE_MAP
argument_list|(
name|set
argument_list|)
init|;
operator|!
name|MAIN_FILE_P
argument_list|(
name|map
argument_list|)
condition|;
name|map
operator|=
name|INCLUDED_FROM
argument_list|(
name|set
argument_list|,
name|map
argument_list|)
control|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"line-map.c: file \"%s\" entered but not left\n"
argument_list|,
name|map
operator|->
name|to_file
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|set
operator|->
name|maps
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Add a mapping of logical source line to physical source file and    line number.     The text pointed to by TO_FILE must have a lifetime    at least as long as the final call to lookup_line ().  An empty    TO_FILE means standard input.  If reason is LC_LEAVE, and    TO_FILE is NULL, then TO_FILE, TO_LINE and SYSP are given their    natural values considering the file we are returning to.     FROM_LINE should be monotonic increasing across calls to this    function.  A call to this function can relocate the previous set of    maps, so any stored line_map pointers should not be used.  */
end_comment

begin_function
specifier|const
name|struct
name|line_map
modifier|*
name|linemap_add
parameter_list|(
name|struct
name|line_maps
modifier|*
name|set
parameter_list|,
name|enum
name|lc_reason
name|reason
parameter_list|,
name|unsigned
name|int
name|sysp
parameter_list|,
name|source_location
name|from_line
parameter_list|,
specifier|const
name|char
modifier|*
name|to_file
parameter_list|,
name|unsigned
name|int
name|to_line
parameter_list|)
block|{
name|struct
name|line_map
modifier|*
name|map
decl_stmt|;
if|if
condition|(
name|set
operator|->
name|used
operator|&&
name|from_line
operator|<
name|set
operator|->
name|maps
index|[
name|set
operator|->
name|used
operator|-
literal|1
index|]
operator|.
name|from_line
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|set
operator|->
name|used
operator|==
name|set
operator|->
name|allocated
condition|)
block|{
name|set
operator|->
name|allocated
operator|=
literal|2
operator|*
name|set
operator|->
name|allocated
operator|+
literal|256
expr_stmt|;
name|set
operator|->
name|maps
operator|=
name|xrealloc
argument_list|(
name|set
operator|->
name|maps
argument_list|,
name|set
operator|->
name|allocated
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|line_map
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|map
operator|=
operator|&
name|set
operator|->
name|maps
index|[
name|set
operator|->
name|used
operator|++
index|]
expr_stmt|;
if|if
condition|(
name|to_file
operator|&&
operator|*
name|to_file
operator|==
literal|'\0'
condition|)
name|to_file
operator|=
literal|"<stdin>"
expr_stmt|;
comment|/* If we don't keep our line maps consistent, we can easily      segfault.  Don't rely on the client to do it for us.  */
if|if
condition|(
name|set
operator|->
name|depth
operator|==
literal|0
condition|)
name|reason
operator|=
name|LC_ENTER
expr_stmt|;
elseif|else
if|if
condition|(
name|reason
operator|==
name|LC_LEAVE
condition|)
block|{
name|struct
name|line_map
modifier|*
name|from
decl_stmt|;
name|bool
name|error
decl_stmt|;
if|if
condition|(
name|MAIN_FILE_P
argument_list|(
name|map
operator|-
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
name|to_file
operator|==
name|NULL
condition|)
block|{
name|set
operator|->
name|depth
operator|--
expr_stmt|;
name|set
operator|->
name|used
operator|--
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|error
operator|=
name|true
expr_stmt|;
name|reason
operator|=
name|LC_RENAME
expr_stmt|;
name|from
operator|=
name|map
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|from
operator|=
name|INCLUDED_FROM
argument_list|(
name|set
argument_list|,
name|map
operator|-
literal|1
argument_list|)
expr_stmt|;
name|error
operator|=
name|to_file
operator|&&
name|strcmp
argument_list|(
name|from
operator|->
name|to_file
argument_list|,
name|to_file
argument_list|)
expr_stmt|;
block|}
comment|/* Depending upon whether we are handling preprocessed input or 	 not, this can be a user error or an ICE.  */
if|if
condition|(
name|error
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"line-map.c: file \"%s\" left but not entered\n"
argument_list|,
name|to_file
argument_list|)
expr_stmt|;
comment|/* A TO_FILE of NULL is special - we use the natural values.  */
if|if
condition|(
name|error
operator|||
name|to_file
operator|==
name|NULL
condition|)
block|{
name|to_file
operator|=
name|from
operator|->
name|to_file
expr_stmt|;
name|to_line
operator|=
name|LAST_SOURCE_LINE
argument_list|(
name|from
argument_list|)
operator|+
literal|1
expr_stmt|;
name|sysp
operator|=
name|from
operator|->
name|sysp
expr_stmt|;
block|}
block|}
name|map
operator|->
name|reason
operator|=
name|reason
expr_stmt|;
name|map
operator|->
name|sysp
operator|=
name|sysp
expr_stmt|;
name|map
operator|->
name|from_line
operator|=
name|from_line
expr_stmt|;
name|map
operator|->
name|to_file
operator|=
name|to_file
expr_stmt|;
name|map
operator|->
name|to_line
operator|=
name|to_line
expr_stmt|;
if|if
condition|(
name|reason
operator|==
name|LC_ENTER
condition|)
block|{
name|map
operator|->
name|included_from
operator|=
name|set
operator|->
name|depth
operator|==
literal|0
condition|?
operator|-
literal|1
else|:
call|(
name|int
call|)
argument_list|(
name|set
operator|->
name|used
operator|-
literal|2
argument_list|)
expr_stmt|;
name|set
operator|->
name|depth
operator|++
expr_stmt|;
if|if
condition|(
name|set
operator|->
name|trace_includes
condition|)
name|trace_include
argument_list|(
name|set
argument_list|,
name|map
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|reason
operator|==
name|LC_RENAME
condition|)
name|map
operator|->
name|included_from
operator|=
name|map
index|[
operator|-
literal|1
index|]
operator|.
name|included_from
expr_stmt|;
elseif|else
if|if
condition|(
name|reason
operator|==
name|LC_LEAVE
condition|)
block|{
name|set
operator|->
name|depth
operator|--
expr_stmt|;
name|map
operator|->
name|included_from
operator|=
name|INCLUDED_FROM
argument_list|(
name|set
argument_list|,
name|map
operator|-
literal|1
argument_list|)
operator|->
name|included_from
expr_stmt|;
block|}
return|return
name|map
return|;
block|}
end_function

begin_comment
comment|/* Given a logical line, returns the map from which the corresponding    (source file, line) pair can be deduced.  Since the set is built    chronologically, the logical lines are monotonic increasing, and so    the list is sorted and we can use a binary search.  */
end_comment

begin_function
specifier|const
name|struct
name|line_map
modifier|*
name|linemap_lookup
parameter_list|(
name|struct
name|line_maps
modifier|*
name|set
parameter_list|,
name|source_location
name|line
parameter_list|)
block|{
name|unsigned
name|int
name|md
decl_stmt|,
name|mn
init|=
literal|0
decl_stmt|,
name|mx
init|=
name|set
operator|->
name|used
decl_stmt|;
if|if
condition|(
name|mx
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
while|while
condition|(
name|mx
operator|-
name|mn
operator|>
literal|1
condition|)
block|{
name|md
operator|=
operator|(
name|mn
operator|+
name|mx
operator|)
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|set
operator|->
name|maps
index|[
name|md
index|]
operator|.
name|from_line
operator|>
name|line
condition|)
name|mx
operator|=
name|md
expr_stmt|;
else|else
name|mn
operator|=
name|md
expr_stmt|;
block|}
return|return
operator|&
name|set
operator|->
name|maps
index|[
name|mn
index|]
return|;
block|}
end_function

begin_comment
comment|/* Print the file names and line numbers of the #include commands    which led to the map MAP, if any, to stderr.  Nothing is output if    the most recently listed stack is the same as the current one.  */
end_comment

begin_function
name|void
name|linemap_print_containing_files
parameter_list|(
name|struct
name|line_maps
modifier|*
name|set
parameter_list|,
specifier|const
name|struct
name|line_map
modifier|*
name|map
parameter_list|)
block|{
if|if
condition|(
name|MAIN_FILE_P
argument_list|(
name|map
argument_list|)
operator|||
name|set
operator|->
name|last_listed
operator|==
name|map
operator|->
name|included_from
condition|)
return|return;
name|set
operator|->
name|last_listed
operator|=
name|map
operator|->
name|included_from
expr_stmt|;
name|map
operator|=
name|INCLUDED_FROM
argument_list|(
name|set
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"In file included from %s:%u"
argument_list|)
argument_list|,
name|map
operator|->
name|to_file
argument_list|,
name|LAST_SOURCE_LINE
argument_list|(
name|map
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|MAIN_FILE_P
argument_list|(
name|map
argument_list|)
condition|)
block|{
name|map
operator|=
name|INCLUDED_FROM
argument_list|(
name|set
argument_list|,
name|map
argument_list|)
expr_stmt|;
comment|/* Translators note: this message is used in conjunction 	 with "In file included from %s:%ld" and some other 	 tricks.  We want something like this:  	 | In file included from sys/select.h:123, 	 |                  from sys/types.h:234, 	 |                  from userfile.c:31: 	 | bits/select.h:45:<error message here>  	 with all the "from"s lined up. 	 The trailing comma is at the beginning of this message, 	 and the trailing colon is not translated.  */
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|",\n                 from %s:%u"
argument_list|)
argument_list|,
name|map
operator|->
name|to_file
argument_list|,
name|LAST_SOURCE_LINE
argument_list|(
name|map
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fputs
argument_list|(
literal|":\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print an include trace, for e.g. the -H option of the preprocessor.  */
end_comment

begin_function
specifier|static
name|void
name|trace_include
parameter_list|(
specifier|const
name|struct
name|line_maps
modifier|*
name|set
parameter_list|,
specifier|const
name|struct
name|line_map
modifier|*
name|map
parameter_list|)
block|{
name|unsigned
name|int
name|i
init|=
name|set
operator|->
name|depth
decl_stmt|;
while|while
condition|(
operator|--
name|i
condition|)
name|putc
argument_list|(
literal|'.'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %s\n"
argument_list|,
name|map
operator|->
name|to_file
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

