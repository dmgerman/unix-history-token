begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Threads compatibility routines for libgcc2 and libobjc.  */
end_comment

begin_comment
comment|/* Compile this one with gcc.  */
end_comment

begin_comment
comment|/* Copyright (C) 1999, 2000, 2002, 2003, 2004  Free Software Foundation, Inc.    Contributed by Mumit Khan<khan@xraylith.wisc.edu>.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* As a special exception, if you link this library with other files,    some of which are compiled with GCC, to produce an executable,    this library does not by itself cause the resulting executable    to be covered by the GNU General Public License.    This exception does not however invalidate any other reasons why    the executable file might be covered by the GNU General Public License.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|GCC_GTHR_WIN32_H
end_ifndef

begin_define
define|#
directive|define
name|GCC_GTHR_WIN32_H
end_define

begin_comment
comment|/* Windows32 threads specific definitions. The windows32 threading model    does not map well into pthread-inspired gcc's threading model, and so    there are caveats one needs to be aware of.     1. The destructor supplied to __gthread_key_create is ignored for       generic x86-win32 ports. This will certainly cause memory leaks       due to unreclaimed eh contexts (sizeof (eh_context) is at least       24 bytes for x86 currently).        This memory leak may be significant for long-running applications       that make heavy use of C++ EH.        However, Mingw runtime (version 0.3 or newer) provides a mechanism       to emulate pthreads key dtors; the runtime provides a special DLL,       linked in if -mthreads option is specified, that runs the dtors in       the reverse order of registration when each thread exits. If       -mthreads option is not given, a stub is linked in instead of the       DLL, which results in memory leak. Other x86-win32 ports can use       the same technique of course to avoid the leak.     2. The error codes returned are non-POSIX like, and cast into ints.       This may cause incorrect error return due to truncation values on       hw where sizeof (DWORD)> sizeof (int).     3. We are currently using a special mutex instead of the Critical       Sections, since Win9x does not support TryEnterCriticalSection       (while NT does).     The basic framework should work well enough. In the long term, GCC    needs to use Structured Exception Handling on Windows32.  */
end_comment

begin_define
define|#
directive|define
name|__GTHREADS
value|1
end_define

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__MINGW32__
end_ifdef

begin_include
include|#
directive|include
file|<_mingw.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|_LIBOBJC
end_ifdef

begin_comment
comment|/* This is necessary to prevent windef.h (included from windows.h) from    defining it's own BOOL as a typedef.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__OBJC__
end_ifndef

begin_define
define|#
directive|define
name|__OBJC__
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<windows.h>
end_include

begin_comment
comment|/* Now undef the windows BOOL.  */
end_comment

begin_undef
undef|#
directive|undef
name|BOOL
end_undef

begin_comment
comment|/* Key structure for maintaining thread specific storage */
end_comment

begin_decl_stmt
specifier|static
name|DWORD
name|__gthread_objc_data_tls
init|=
operator|(
name|DWORD
operator|)
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Backend initialization functions */
end_comment

begin_comment
comment|/* Initialize the threads subsystem.  */
end_comment

begin_function
name|int
name|__gthread_objc_init_thread_system
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Initialize the thread storage key */
if|if
condition|(
operator|(
name|__gthread_objc_data_tls
operator|=
name|TlsAlloc
argument_list|()
operator|)
operator|!=
operator|(
name|DWORD
operator|)
operator|-
literal|1
condition|)
return|return
literal|0
return|;
else|else
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Close the threads subsystem.  */
end_comment

begin_function
name|int
name|__gthread_objc_close_thread_system
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|__gthread_objc_data_tls
operator|!=
operator|(
name|DWORD
operator|)
operator|-
literal|1
condition|)
name|TlsFree
argument_list|(
name|__gthread_objc_data_tls
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Backend thread functions */
end_comment

begin_comment
comment|/* Create a new thread of execution.  */
end_comment

begin_function
name|objc_thread_t
name|__gthread_objc_thread_detach
parameter_list|(
name|void
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|DWORD
name|thread_id
init|=
literal|0
decl_stmt|;
name|HANDLE
name|win32_handle
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|win32_handle
operator|=
name|CreateThread
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
operator|(
name|LPTHREAD_START_ROUTINE
operator|)
name|func
argument_list|,
name|arg
argument_list|,
literal|0
argument_list|,
operator|&
name|thread_id
argument_list|)
operator|)
condition|)
name|thread_id
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|objc_thread_t
operator|)
name|thread_id
return|;
block|}
end_function

begin_comment
comment|/* Set the current thread's priority.  */
end_comment

begin_function
name|int
name|__gthread_objc_thread_set_priority
parameter_list|(
name|int
name|priority
parameter_list|)
block|{
name|int
name|sys_priority
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|priority
condition|)
block|{
case|case
name|OBJC_THREAD_INTERACTIVE_PRIORITY
case|:
name|sys_priority
operator|=
name|THREAD_PRIORITY_NORMAL
expr_stmt|;
break|break;
default|default:
case|case
name|OBJC_THREAD_BACKGROUND_PRIORITY
case|:
name|sys_priority
operator|=
name|THREAD_PRIORITY_BELOW_NORMAL
expr_stmt|;
break|break;
case|case
name|OBJC_THREAD_LOW_PRIORITY
case|:
name|sys_priority
operator|=
name|THREAD_PRIORITY_LOWEST
expr_stmt|;
break|break;
block|}
comment|/* Change priority */
if|if
condition|(
name|SetThreadPriority
argument_list|(
name|GetCurrentThread
argument_list|()
argument_list|,
name|sys_priority
argument_list|)
condition|)
return|return
literal|0
return|;
else|else
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return the current thread's priority.  */
end_comment

begin_function
name|int
name|__gthread_objc_thread_get_priority
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|sys_priority
decl_stmt|;
name|sys_priority
operator|=
name|GetThreadPriority
argument_list|(
name|GetCurrentThread
argument_list|()
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sys_priority
condition|)
block|{
case|case
name|THREAD_PRIORITY_HIGHEST
case|:
case|case
name|THREAD_PRIORITY_TIME_CRITICAL
case|:
case|case
name|THREAD_PRIORITY_ABOVE_NORMAL
case|:
case|case
name|THREAD_PRIORITY_NORMAL
case|:
return|return
name|OBJC_THREAD_INTERACTIVE_PRIORITY
return|;
default|default:
case|case
name|THREAD_PRIORITY_BELOW_NORMAL
case|:
return|return
name|OBJC_THREAD_BACKGROUND_PRIORITY
return|;
case|case
name|THREAD_PRIORITY_IDLE
case|:
case|case
name|THREAD_PRIORITY_LOWEST
case|:
return|return
name|OBJC_THREAD_LOW_PRIORITY
return|;
block|}
comment|/* Couldn't get priority.  */
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Yield our process time to another thread.  */
end_comment

begin_function
name|void
name|__gthread_objc_thread_yield
parameter_list|(
name|void
parameter_list|)
block|{
name|Sleep
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Terminate the current thread.  */
end_comment

begin_function
name|int
name|__gthread_objc_thread_exit
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* exit the thread */
name|ExitThread
argument_list|(
name|__objc_thread_exit_status
argument_list|)
expr_stmt|;
comment|/* Failed if we reached here */
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Returns an integer value which uniquely describes a thread.  */
end_comment

begin_function
name|objc_thread_t
name|__gthread_objc_thread_id
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|objc_thread_t
operator|)
name|GetCurrentThreadId
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/* Sets the thread's local storage pointer.  */
end_comment

begin_function
name|int
name|__gthread_objc_thread_set_data
parameter_list|(
name|void
modifier|*
name|value
parameter_list|)
block|{
if|if
condition|(
name|TlsSetValue
argument_list|(
name|__gthread_objc_data_tls
argument_list|,
name|value
argument_list|)
condition|)
return|return
literal|0
return|;
else|else
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Returns the thread's local storage pointer.  */
end_comment

begin_function
name|void
modifier|*
name|__gthread_objc_thread_get_data
parameter_list|(
name|void
parameter_list|)
block|{
name|DWORD
name|lasterror
decl_stmt|;
name|void
modifier|*
name|ptr
decl_stmt|;
name|lasterror
operator|=
name|GetLastError
argument_list|()
expr_stmt|;
name|ptr
operator|=
name|TlsGetValue
argument_list|(
name|__gthread_objc_data_tls
argument_list|)
expr_stmt|;
comment|/* Return thread data.  */
name|SetLastError
argument_list|(
name|lasterror
argument_list|)
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_comment
comment|/* Backend mutex functions */
end_comment

begin_comment
comment|/* Allocate a mutex.  */
end_comment

begin_function
name|int
name|__gthread_objc_mutex_allocate
parameter_list|(
name|objc_mutex_t
name|mutex
parameter_list|)
block|{
if|if
condition|(
operator|(
name|mutex
operator|->
name|backend
operator|=
operator|(
name|void
operator|*
operator|)
name|CreateMutex
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Deallocate a mutex.  */
end_comment

begin_function
name|int
name|__gthread_objc_mutex_deallocate
parameter_list|(
name|objc_mutex_t
name|mutex
parameter_list|)
block|{
name|CloseHandle
argument_list|(
call|(
name|HANDLE
call|)
argument_list|(
name|mutex
operator|->
name|backend
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Grab a lock on a mutex.  */
end_comment

begin_function
name|int
name|__gthread_objc_mutex_lock
parameter_list|(
name|objc_mutex_t
name|mutex
parameter_list|)
block|{
name|int
name|status
decl_stmt|;
name|status
operator|=
name|WaitForSingleObject
argument_list|(
call|(
name|HANDLE
call|)
argument_list|(
name|mutex
operator|->
name|backend
argument_list|)
argument_list|,
name|INFINITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|WAIT_OBJECT_0
operator|&&
name|status
operator|!=
name|WAIT_ABANDONED
condition|)
return|return
operator|-
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Try to grab a lock on a mutex.  */
end_comment

begin_function
name|int
name|__gthread_objc_mutex_trylock
parameter_list|(
name|objc_mutex_t
name|mutex
parameter_list|)
block|{
name|int
name|status
decl_stmt|;
name|status
operator|=
name|WaitForSingleObject
argument_list|(
call|(
name|HANDLE
call|)
argument_list|(
name|mutex
operator|->
name|backend
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|WAIT_OBJECT_0
operator|&&
name|status
operator|!=
name|WAIT_ABANDONED
condition|)
return|return
operator|-
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Unlock the mutex */
end_comment

begin_function
name|int
name|__gthread_objc_mutex_unlock
parameter_list|(
name|objc_mutex_t
name|mutex
parameter_list|)
block|{
if|if
condition|(
name|ReleaseMutex
argument_list|(
call|(
name|HANDLE
call|)
argument_list|(
name|mutex
operator|->
name|backend
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Backend condition mutex functions */
end_comment

begin_comment
comment|/* Allocate a condition.  */
end_comment

begin_function
name|int
name|__gthread_objc_condition_allocate
parameter_list|(
name|objc_condition_t
name|condition
parameter_list|)
block|{
comment|/* Unimplemented.  */
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Deallocate a condition.  */
end_comment

begin_function
name|int
name|__gthread_objc_condition_deallocate
parameter_list|(
name|objc_condition_t
name|condition
parameter_list|)
block|{
comment|/* Unimplemented.  */
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Wait on the condition */
end_comment

begin_function
name|int
name|__gthread_objc_condition_wait
parameter_list|(
name|objc_condition_t
name|condition
parameter_list|,
name|objc_mutex_t
name|mutex
parameter_list|)
block|{
comment|/* Unimplemented.  */
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Wake up all threads waiting on this condition.  */
end_comment

begin_function
name|int
name|__gthread_objc_condition_broadcast
parameter_list|(
name|objc_condition_t
name|condition
parameter_list|)
block|{
comment|/* Unimplemented.  */
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Wake up one thread waiting on this condition.  */
end_comment

begin_function
name|int
name|__gthread_objc_condition_signal
parameter_list|(
name|objc_condition_t
name|condition
parameter_list|)
block|{
comment|/* Unimplemented.  */
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* _LIBOBJC */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef

begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
typedef|typedef
name|unsigned
name|long
name|__gthread_key_t
typedef|;
typedef|typedef
struct|struct
block|{
name|int
name|done
decl_stmt|;
name|long
name|started
decl_stmt|;
block|}
name|__gthread_once_t
typedef|;
typedef|typedef
struct|struct
block|{
name|long
name|counter
decl_stmt|;
name|void
modifier|*
name|sema
decl_stmt|;
block|}
name|__gthread_mutex_t
typedef|;
define|#
directive|define
name|__GTHREAD_ONCE_INIT
value|{0, -1}
define|#
directive|define
name|__GTHREAD_MUTEX_INIT_FUNCTION
value|__gthread_mutex_init_function
define|#
directive|define
name|__GTHREAD_MUTEX_INIT_DEFAULT
value|{-1, 0}
if|#
directive|if
name|__MINGW32_MAJOR_VERSION
operator|>=
literal|1
operator|||
expr|\
operator|(
name|__MINGW32_MAJOR_VERSION
operator|==
literal|0
operator|&&
name|__MINGW32_MINOR_VERSION
operator|>
literal|2
operator|)
define|#
directive|define
name|MINGW32_SUPPORTS_MT_EH
value|1
comment|/* Mingw runtime>= v0.3 provides a magic variable that is set to nonzero    if -mthreads option was specified, or 0 otherwise. This is to get around    the lack of weak symbols in PE-COFF.  */
specifier|extern
name|int
name|_CRT_MT
decl_stmt|;
specifier|extern
name|int
name|__mingwthr_key_dtor
parameter_list|(
name|unsigned
name|long
parameter_list|,
name|void
function_decl|(
modifier|*
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|)
function_decl|;
endif|#
directive|endif
comment|/* __MINGW32__ version */
ifdef|#
directive|ifdef
name|__GTHREAD_I486_INLINE_LOCK_PRIMITIVES
specifier|static
specifier|inline
name|long
name|__gthr_i486_lock_cmp_xchg
parameter_list|(
name|long
modifier|*
name|dest
parameter_list|,
name|long
name|xchg
parameter_list|,
name|long
name|comperand
parameter_list|)
block|{
name|long
name|result
decl_stmt|;
asm|__asm__
specifier|__volatile__
asm|("\n\ 	lock\n\ 	cmpxchg{l} {%4, %1|%1, %4}\n" 	: "=a" (result), "=m" (*dest) 	: "0" (comperand), "m" (*dest), "r" (xchg) 	: "cc");
return|return
name|result
return|;
block|}
define|#
directive|define
name|__GTHR_W32_InterlockedCompareExchange
value|__gthr_i486_lock_cmp_xchg
else|#
directive|else
comment|/* __GTHREAD_I486_INLINE_LOCK_PRIMITIVES */
define|#
directive|define
name|__GTHR_W32_InterlockedCompareExchange
value|InterlockedCompareExchange
endif|#
directive|endif
comment|/* __GTHREAD_I486_INLINE_LOCK_PRIMITIVES */
specifier|static
specifier|inline
name|int
name|__gthread_active_p
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|MINGW32_SUPPORTS_MT_EH
return|return
name|_CRT_MT
return|;
else|#
directive|else
return|return
literal|1
return|;
endif|#
directive|endif
block|}
if|#
directive|if
name|__GTHREAD_HIDE_WIN32API
comment|/* The implementations are in config/i386/gthr-win32.c in libgcc.a.    Only stubs are exposed to avoid polluting the C++ namespace with    windows api definitions.  */
specifier|extern
name|int
name|__gthr_win32_once
parameter_list|(
name|__gthread_once_t
modifier|*
parameter_list|,
name|void
function_decl|(
modifier|*
function_decl|)
parameter_list|(
name|void
parameter_list|)
parameter_list|)
function_decl|;
specifier|extern
name|int
name|__gthr_win32_key_create
parameter_list|(
name|__gthread_key_t
modifier|*
parameter_list|,
name|void
function_decl|(
modifier|*
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|)
function_decl|;
specifier|extern
name|int
name|__gthr_win32_key_delete
parameter_list|(
name|__gthread_key_t
parameter_list|)
function_decl|;
specifier|extern
name|void
modifier|*
name|__gthr_win32_getspecific
parameter_list|(
name|__gthread_key_t
parameter_list|)
function_decl|;
specifier|extern
name|int
name|__gthr_win32_setspecific
parameter_list|(
name|__gthread_key_t
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|void
name|__gthr_win32_mutex_init_function
parameter_list|(
name|__gthread_mutex_t
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|int
name|__gthr_win32_mutex_lock
parameter_list|(
name|__gthread_mutex_t
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|int
name|__gthr_win32_mutex_trylock
parameter_list|(
name|__gthread_mutex_t
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|int
name|__gthr_win32_mutex_unlock
parameter_list|(
name|__gthread_mutex_t
modifier|*
parameter_list|)
function_decl|;
specifier|static
specifier|inline
name|int
name|__gthread_once
parameter_list|(
name|__gthread_once_t
modifier|*
name|once
parameter_list|,
name|void
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|void
parameter_list|)
parameter_list|)
block|{
if|if
condition|(
name|__gthread_active_p
argument_list|()
condition|)
return|return
name|__gthr_win32_once
argument_list|(
name|once
argument_list|,
name|func
argument_list|)
return|;
else|else
return|return
operator|-
literal|1
return|;
block|}
specifier|static
specifier|inline
name|int
name|__gthread_key_create
parameter_list|(
name|__gthread_key_t
modifier|*
name|key
parameter_list|,
name|void
function_decl|(
modifier|*
name|dtor
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|)
block|{
return|return
name|__gthr_win32_key_create
argument_list|(
name|key
argument_list|,
name|dtor
argument_list|)
return|;
block|}
specifier|static
specifier|inline
name|int
name|__gthread_key_delete
parameter_list|(
name|__gthread_key_t
name|key
parameter_list|)
block|{
return|return
name|__gthr_win32_key_delete
argument_list|(
name|key
argument_list|)
return|;
block|}
specifier|static
specifier|inline
name|void
modifier|*
name|__gthread_getspecific
parameter_list|(
name|__gthread_key_t
name|key
parameter_list|)
block|{
return|return
name|__gthr_win32_getspecific
argument_list|(
name|key
argument_list|)
return|;
block|}
specifier|static
specifier|inline
name|int
name|__gthread_setspecific
parameter_list|(
name|__gthread_key_t
name|key
parameter_list|,
specifier|const
name|void
modifier|*
name|ptr
parameter_list|)
block|{
return|return
name|__gthr_win32_setspecific
argument_list|(
name|key
argument_list|,
name|ptr
argument_list|)
return|;
block|}
specifier|static
specifier|inline
name|void
name|__gthread_mutex_init_function
parameter_list|(
name|__gthread_mutex_t
modifier|*
name|mutex
parameter_list|)
block|{
name|__gthr_win32_mutex_init_function
argument_list|(
name|mutex
argument_list|)
expr_stmt|;
block|}
specifier|static
specifier|inline
name|int
name|__gthread_mutex_lock
parameter_list|(
name|__gthread_mutex_t
modifier|*
name|mutex
parameter_list|)
block|{
if|if
condition|(
name|__gthread_active_p
argument_list|()
condition|)
return|return
name|__gthr_win32_mutex_lock
argument_list|(
name|mutex
argument_list|)
return|;
else|else
return|return
literal|0
return|;
block|}
specifier|static
specifier|inline
name|int
name|__gthread_mutex_trylock
parameter_list|(
name|__gthread_mutex_t
modifier|*
name|mutex
parameter_list|)
block|{
if|if
condition|(
name|__gthread_active_p
argument_list|()
condition|)
return|return
name|__gthr_win32_mutex_trylock
argument_list|(
name|mutex
argument_list|)
return|;
else|else
return|return
literal|0
return|;
block|}
specifier|static
specifier|inline
name|int
name|__gthread_mutex_unlock
parameter_list|(
name|__gthread_mutex_t
modifier|*
name|mutex
parameter_list|)
block|{
if|if
condition|(
name|__gthread_active_p
argument_list|()
condition|)
return|return
name|__gthr_win32_mutex_unlock
argument_list|(
name|mutex
argument_list|)
return|;
else|else
return|return
literal|0
return|;
block|}
else|#
directive|else
comment|/* ! __GTHREAD_HIDE_WIN32API */
include|#
directive|include
file|<windows.h>
include|#
directive|include
file|<errno.h>
specifier|static
specifier|inline
name|int
name|__gthread_once
parameter_list|(
name|__gthread_once_t
modifier|*
name|once
parameter_list|,
name|void
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|void
parameter_list|)
parameter_list|)
block|{
if|if
condition|(
operator|!
name|__gthread_active_p
argument_list|()
condition|)
return|return
operator|-
literal|1
return|;
elseif|else
if|if
condition|(
name|once
operator|==
name|NULL
operator|||
name|func
operator|==
name|NULL
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
operator|!
name|once
operator|->
name|done
condition|)
block|{
if|if
condition|(
name|InterlockedIncrement
argument_list|(
operator|&
operator|(
name|once
operator|->
name|started
operator|)
argument_list|)
operator|==
literal|0
condition|)
block|{
call|(
modifier|*
name|func
call|)
argument_list|()
expr_stmt|;
name|once
operator|->
name|done
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
comment|/* Another thread is currently executing the code, so wait for it 	     to finish; yield the CPU in the meantime.  If performance 	     does become an issue, the solution is to use an Event that 	     we wait on here (and set above), but that implies a place to 	     create the event before this routine is called.  */
while|while
condition|(
operator|!
name|once
operator|->
name|done
condition|)
name|Sleep
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
comment|/* Windows32 thread local keys don't support destructors; this leads to    leaks, especially in threaded applications making extensive use of    C++ EH. Mingw uses a thread-support DLL to work-around this problem.  */
specifier|static
specifier|inline
name|int
name|__gthread_key_create
parameter_list|(
name|__gthread_key_t
modifier|*
name|key
parameter_list|,
name|void
function_decl|(
modifier|*
name|dtor
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|)
block|{
name|int
name|status
init|=
literal|0
decl_stmt|;
name|DWORD
name|tls_index
init|=
name|TlsAlloc
argument_list|()
decl_stmt|;
if|if
condition|(
name|tls_index
operator|!=
literal|0xFFFFFFFF
condition|)
block|{
operator|*
name|key
operator|=
name|tls_index
expr_stmt|;
ifdef|#
directive|ifdef
name|MINGW32_SUPPORTS_MT_EH
comment|/* Mingw runtime will run the dtors in reverse order for each thread          when the thread exits.  */
name|status
operator|=
name|__mingwthr_key_dtor
argument_list|(
operator|*
name|key
argument_list|,
name|dtor
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
name|status
operator|=
operator|(
name|int
operator|)
name|GetLastError
argument_list|()
expr_stmt|;
return|return
name|status
return|;
block|}
specifier|static
specifier|inline
name|int
name|__gthread_key_delete
parameter_list|(
name|__gthread_key_t
name|key
parameter_list|)
block|{
return|return
operator|(
name|TlsFree
argument_list|(
name|key
argument_list|)
operator|!=
literal|0
operator|)
condition|?
literal|0
else|:
operator|(
name|int
operator|)
name|GetLastError
argument_list|()
return|;
block|}
specifier|static
specifier|inline
name|void
modifier|*
name|__gthread_getspecific
parameter_list|(
name|__gthread_key_t
name|key
parameter_list|)
block|{
name|DWORD
name|lasterror
decl_stmt|;
name|void
modifier|*
name|ptr
decl_stmt|;
name|lasterror
operator|=
name|GetLastError
argument_list|()
expr_stmt|;
name|ptr
operator|=
name|TlsGetValue
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|SetLastError
argument_list|(
name|lasterror
argument_list|)
expr_stmt|;
return|return
name|ptr
return|;
block|}
specifier|static
specifier|inline
name|int
name|__gthread_setspecific
parameter_list|(
name|__gthread_key_t
name|key
parameter_list|,
specifier|const
name|void
modifier|*
name|ptr
parameter_list|)
block|{
return|return
operator|(
name|TlsSetValue
argument_list|(
name|key
argument_list|,
operator|(
name|void
operator|*
operator|)
name|ptr
argument_list|)
operator|!=
literal|0
operator|)
condition|?
literal|0
else|:
operator|(
name|int
operator|)
name|GetLastError
argument_list|()
return|;
block|}
specifier|static
specifier|inline
name|void
name|__gthread_mutex_init_function
parameter_list|(
name|__gthread_mutex_t
modifier|*
name|mutex
parameter_list|)
block|{
name|mutex
operator|->
name|counter
operator|=
operator|-
literal|1
expr_stmt|;
name|mutex
operator|->
name|sema
operator|=
name|CreateSemaphore
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
literal|65535
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
specifier|static
specifier|inline
name|int
name|__gthread_mutex_lock
parameter_list|(
name|__gthread_mutex_t
modifier|*
name|mutex
parameter_list|)
block|{
name|int
name|status
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|__gthread_active_p
argument_list|()
condition|)
block|{
if|if
condition|(
name|InterlockedIncrement
argument_list|(
operator|&
name|mutex
operator|->
name|counter
argument_list|)
operator|==
literal|0
operator|||
name|WaitForSingleObject
argument_list|(
name|mutex
operator|->
name|sema
argument_list|,
name|INFINITE
argument_list|)
operator|==
name|WAIT_OBJECT_0
condition|)
name|status
operator|=
literal|0
expr_stmt|;
else|else
block|{
comment|/* WaitForSingleObject returns WAIT_FAILED, and we can only do 	     some best-effort cleanup here.  */
name|InterlockedDecrement
argument_list|(
operator|&
name|mutex
operator|->
name|counter
argument_list|)
expr_stmt|;
name|status
operator|=
literal|1
expr_stmt|;
block|}
block|}
return|return
name|status
return|;
block|}
specifier|static
specifier|inline
name|int
name|__gthread_mutex_trylock
parameter_list|(
name|__gthread_mutex_t
modifier|*
name|mutex
parameter_list|)
block|{
name|int
name|status
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|__gthread_active_p
argument_list|()
condition|)
block|{
if|if
condition|(
name|__GTHR_W32_InterlockedCompareExchange
argument_list|(
operator|&
name|mutex
operator|->
name|counter
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
operator|<
literal|0
condition|)
name|status
operator|=
literal|0
expr_stmt|;
else|else
name|status
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
specifier|static
specifier|inline
name|int
name|__gthread_mutex_unlock
parameter_list|(
name|__gthread_mutex_t
modifier|*
name|mutex
parameter_list|)
block|{
if|if
condition|(
name|__gthread_active_p
argument_list|()
condition|)
block|{
if|if
condition|(
name|InterlockedDecrement
argument_list|(
operator|&
name|mutex
operator|->
name|counter
argument_list|)
operator|>=
literal|0
condition|)
return|return
name|ReleaseSemaphore
argument_list|(
name|mutex
operator|->
name|sema
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
condition|?
literal|0
else|:
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
endif|#
directive|endif
comment|/*  __GTHREAD_HIDE_WIN32API */
ifdef|#
directive|ifdef
name|__cplusplus
block|}
end_extern

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _LIBOBJC */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! GCC_GTHR_WIN32_H */
end_comment

end_unit

