begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Threads compatibility routines for libgcc2 and libobjc.  */
end_comment

begin_comment
comment|/* Compile this one with gcc.  */
end_comment

begin_comment
comment|/* Copyright (C) 1999, 2000, 2002 Free Software Foundation, Inc.    Contributed by Mumit Khan<khan@xraylith.wisc.edu>.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* As a special exception, if you link this library with other files,    some of which are compiled with GCC, to produce an executable,    this library does not by itself cause the resulting executable    to be covered by the GNU General Public License.    This exception does not however invalidate any other reasons why    the executable file might be covered by the GNU General Public License.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|GCC_GTHR_WIN32_H
end_ifndef

begin_define
define|#
directive|define
name|GCC_GTHR_WIN32_H
end_define

begin_comment
comment|/* Windows32 threads specific definitions. The windows32 threading model    does not map well into pthread-inspired gcc's threading model, and so     there are caveats one needs to be aware of.     1. The destructor supplied to __gthread_key_create is ignored for       generic x86-win32 ports. This will certainly cause memory leaks        due to unreclaimed eh contexts (sizeof (eh_context) is at least        24 bytes for x86 currently).        This memory leak may be significant for long-running applications       that make heavy use of C++ EH.        However, Mingw runtime (version 0.3 or newer) provides a mechanism       to emulate pthreads key dtors; the runtime provides a special DLL,       linked in if -mthreads option is specified, that runs the dtors in       the reverse order of registration when each thread exits. If       -mthreads option is not given, a stub is linked in instead of the       DLL, which results in memory leak. Other x86-win32 ports can use        the same technique of course to avoid the leak.     2. The error codes returned are non-POSIX like, and cast into ints.       This may cause incorrect error return due to truncation values on        hw where sizeof (DWORD)> sizeof (int).        3. We might consider using Critical Sections instead of Windows32        mutexes for better performance, but emulating __gthread_mutex_trylock        interface becomes more complicated (Win9x does not support       TryEnterCriticalSectioni, while NT does).       The basic framework should work well enough. In the long term, GCC    needs to use Structured Exception Handling on Windows32.  */
end_comment

begin_define
define|#
directive|define
name|__GTHREADS
value|1
end_define

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__MINGW32__
end_ifdef

begin_include
include|#
directive|include
file|<_mingw.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|_LIBOBJC
end_ifdef

begin_comment
comment|/* This is necessary to prevent windef.h (included from windows.h) from    defining it's own BOOL as a typedef.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__OBJC__
end_ifndef

begin_define
define|#
directive|define
name|__OBJC__
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<windows.h>
end_include

begin_comment
comment|/* Now undef the windows BOOL.  */
end_comment

begin_undef
undef|#
directive|undef
name|BOOL
end_undef

begin_comment
comment|/* Key structure for maintaining thread specific storage */
end_comment

begin_decl_stmt
specifier|static
name|DWORD
name|__gthread_objc_data_tls
init|=
operator|(
name|DWORD
operator|)
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Backend initialization functions */
end_comment

begin_comment
comment|/* Initialize the threads subsystem.  */
end_comment

begin_function
name|int
name|__gthread_objc_init_thread_system
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Initialize the thread storage key */
if|if
condition|(
operator|(
name|__gthread_objc_data_tls
operator|=
name|TlsAlloc
argument_list|()
operator|)
operator|!=
operator|(
name|DWORD
operator|)
operator|-
literal|1
condition|)
return|return
literal|0
return|;
else|else
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Close the threads subsystem.  */
end_comment

begin_function
name|int
name|__gthread_objc_close_thread_system
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|__gthread_objc_data_tls
operator|!=
operator|(
name|DWORD
operator|)
operator|-
literal|1
condition|)
name|TlsFree
argument_list|(
name|__gthread_objc_data_tls
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Backend thread functions */
end_comment

begin_comment
comment|/* Create a new thread of execution.  */
end_comment

begin_function
name|objc_thread_t
name|__gthread_objc_thread_detach
parameter_list|(
name|void
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|DWORD
name|thread_id
init|=
literal|0
decl_stmt|;
name|HANDLE
name|win32_handle
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|win32_handle
operator|=
name|CreateThread
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
operator|(
name|LPTHREAD_START_ROUTINE
operator|)
name|func
argument_list|,
name|arg
argument_list|,
literal|0
argument_list|,
operator|&
name|thread_id
argument_list|)
operator|)
condition|)
name|thread_id
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|objc_thread_t
operator|)
name|thread_id
return|;
block|}
end_function

begin_comment
comment|/* Set the current thread's priority.  */
end_comment

begin_function
name|int
name|__gthread_objc_thread_set_priority
parameter_list|(
name|int
name|priority
parameter_list|)
block|{
name|int
name|sys_priority
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|priority
condition|)
block|{
case|case
name|OBJC_THREAD_INTERACTIVE_PRIORITY
case|:
name|sys_priority
operator|=
name|THREAD_PRIORITY_NORMAL
expr_stmt|;
break|break;
default|default:
case|case
name|OBJC_THREAD_BACKGROUND_PRIORITY
case|:
name|sys_priority
operator|=
name|THREAD_PRIORITY_BELOW_NORMAL
expr_stmt|;
break|break;
case|case
name|OBJC_THREAD_LOW_PRIORITY
case|:
name|sys_priority
operator|=
name|THREAD_PRIORITY_LOWEST
expr_stmt|;
break|break;
block|}
comment|/* Change priority */
if|if
condition|(
name|SetThreadPriority
argument_list|(
name|GetCurrentThread
argument_list|()
argument_list|,
name|sys_priority
argument_list|)
condition|)
return|return
literal|0
return|;
else|else
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return the current thread's priority.  */
end_comment

begin_function
name|int
name|__gthread_objc_thread_get_priority
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|sys_priority
decl_stmt|;
name|sys_priority
operator|=
name|GetThreadPriority
argument_list|(
name|GetCurrentThread
argument_list|()
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sys_priority
condition|)
block|{
case|case
name|THREAD_PRIORITY_HIGHEST
case|:
case|case
name|THREAD_PRIORITY_TIME_CRITICAL
case|:
case|case
name|THREAD_PRIORITY_ABOVE_NORMAL
case|:
case|case
name|THREAD_PRIORITY_NORMAL
case|:
return|return
name|OBJC_THREAD_INTERACTIVE_PRIORITY
return|;
default|default:
case|case
name|THREAD_PRIORITY_BELOW_NORMAL
case|:
return|return
name|OBJC_THREAD_BACKGROUND_PRIORITY
return|;
case|case
name|THREAD_PRIORITY_IDLE
case|:
case|case
name|THREAD_PRIORITY_LOWEST
case|:
return|return
name|OBJC_THREAD_LOW_PRIORITY
return|;
block|}
comment|/* Couldn't get priority.  */
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Yield our process time to another thread.  */
end_comment

begin_function
name|void
name|__gthread_objc_thread_yield
parameter_list|(
name|void
parameter_list|)
block|{
name|Sleep
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Terminate the current thread.  */
end_comment

begin_function
name|int
name|__gthread_objc_thread_exit
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* exit the thread */
name|ExitThread
argument_list|(
name|__objc_thread_exit_status
argument_list|)
expr_stmt|;
comment|/* Failed if we reached here */
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Returns an integer value which uniquely describes a thread.  */
end_comment

begin_function
name|objc_thread_t
name|__gthread_objc_thread_id
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|objc_thread_t
operator|)
name|GetCurrentThreadId
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/* Sets the thread's local storage pointer.  */
end_comment

begin_function
name|int
name|__gthread_objc_thread_set_data
parameter_list|(
name|void
modifier|*
name|value
parameter_list|)
block|{
if|if
condition|(
name|TlsSetValue
argument_list|(
name|__gthread_objc_data_tls
argument_list|,
name|value
argument_list|)
condition|)
return|return
literal|0
return|;
else|else
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Returns the thread's local storage pointer.  */
end_comment

begin_function
name|void
modifier|*
name|__gthread_objc_thread_get_data
parameter_list|(
name|void
parameter_list|)
block|{
name|DWORD
name|lasterror
decl_stmt|;
name|void
modifier|*
name|ptr
decl_stmt|;
name|lasterror
operator|=
name|GetLastError
argument_list|()
expr_stmt|;
name|ptr
operator|=
name|TlsGetValue
argument_list|(
name|__gthread_objc_data_tls
argument_list|)
expr_stmt|;
comment|/* Return thread data.  */
name|SetLastError
argument_list|(
name|lasterror
argument_list|)
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_comment
comment|/* Backend mutex functions */
end_comment

begin_comment
comment|/* Allocate a mutex.  */
end_comment

begin_function
name|int
name|__gthread_objc_mutex_allocate
parameter_list|(
name|objc_mutex_t
name|mutex
parameter_list|)
block|{
if|if
condition|(
operator|(
name|mutex
operator|->
name|backend
operator|=
operator|(
name|void
operator|*
operator|)
name|CreateMutex
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Deallocate a mutex.  */
end_comment

begin_function
name|int
name|__gthread_objc_mutex_deallocate
parameter_list|(
name|objc_mutex_t
name|mutex
parameter_list|)
block|{
name|CloseHandle
argument_list|(
call|(
name|HANDLE
call|)
argument_list|(
name|mutex
operator|->
name|backend
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Grab a lock on a mutex.  */
end_comment

begin_function
name|int
name|__gthread_objc_mutex_lock
parameter_list|(
name|objc_mutex_t
name|mutex
parameter_list|)
block|{
name|int
name|status
decl_stmt|;
name|status
operator|=
name|WaitForSingleObject
argument_list|(
call|(
name|HANDLE
call|)
argument_list|(
name|mutex
operator|->
name|backend
argument_list|)
argument_list|,
name|INFINITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|WAIT_OBJECT_0
operator|&&
name|status
operator|!=
name|WAIT_ABANDONED
condition|)
return|return
operator|-
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Try to grab a lock on a mutex.  */
end_comment

begin_function
name|int
name|__gthread_objc_mutex_trylock
parameter_list|(
name|objc_mutex_t
name|mutex
parameter_list|)
block|{
name|int
name|status
decl_stmt|;
name|status
operator|=
name|WaitForSingleObject
argument_list|(
call|(
name|HANDLE
call|)
argument_list|(
name|mutex
operator|->
name|backend
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|WAIT_OBJECT_0
operator|&&
name|status
operator|!=
name|WAIT_ABANDONED
condition|)
return|return
operator|-
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Unlock the mutex */
end_comment

begin_function
name|int
name|__gthread_objc_mutex_unlock
parameter_list|(
name|objc_mutex_t
name|mutex
parameter_list|)
block|{
if|if
condition|(
name|ReleaseMutex
argument_list|(
call|(
name|HANDLE
call|)
argument_list|(
name|mutex
operator|->
name|backend
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Backend condition mutex functions */
end_comment

begin_comment
comment|/* Allocate a condition.  */
end_comment

begin_function
name|int
name|__gthread_objc_condition_allocate
parameter_list|(
name|objc_condition_t
name|condition
parameter_list|)
block|{
comment|/* Unimplemented.  */
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Deallocate a condition.  */
end_comment

begin_function
name|int
name|__gthread_objc_condition_deallocate
parameter_list|(
name|objc_condition_t
name|condition
parameter_list|)
block|{
comment|/* Unimplemented.  */
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Wait on the condition */
end_comment

begin_function
name|int
name|__gthread_objc_condition_wait
parameter_list|(
name|objc_condition_t
name|condition
parameter_list|,
name|objc_mutex_t
name|mutex
parameter_list|)
block|{
comment|/* Unimplemented.  */
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Wake up all threads waiting on this condition.  */
end_comment

begin_function
name|int
name|__gthread_objc_condition_broadcast
parameter_list|(
name|objc_condition_t
name|condition
parameter_list|)
block|{
comment|/* Unimplemented.  */
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Wake up one thread waiting on this condition.  */
end_comment

begin_function
name|int
name|__gthread_objc_condition_signal
parameter_list|(
name|objc_condition_t
name|condition
parameter_list|)
block|{
comment|/* Unimplemented.  */
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* _LIBOBJC */
end_comment

begin_include
include|#
directive|include
file|<windows.h>
end_include

begin_typedef
typedef|typedef
name|DWORD
name|__gthread_key_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|int
name|done
decl_stmt|;
name|long
name|started
decl_stmt|;
block|}
name|__gthread_once_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|HANDLE
name|__gthread_mutex_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|__GTHREAD_ONCE_INIT
value|{FALSE, -1}
end_define

begin_define
define|#
directive|define
name|__GTHREAD_MUTEX_INIT_FUNCTION
value|__gthread_mutex_init_function
end_define

begin_if
if|#
directive|if
name|__MINGW32_MAJOR_VERSION
operator|>=
literal|1
operator|||
expr|\
operator|(
name|__MINGW32_MAJOR_VERSION
operator|==
literal|0
operator|&&
name|__MINGW32_MINOR_VERSION
operator|>
literal|2
operator|)
end_if

begin_define
define|#
directive|define
name|MINGW32_SUPPORTS_MT_EH
value|1
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef

begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
specifier|extern
name|int
name|__mingwthr_key_dtor
parameter_list|(
name|DWORD
parameter_list|,
name|void
function_decl|(
modifier|*
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|)
function_decl|;
ifdef|#
directive|ifdef
name|__cplusplus
block|}
end_extern

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Mingw runtime>= v0.3 provides a magic variable that is set to non-zero    if -mthreads option was specified, or 0 otherwise. This is to get around     the lack of weak symbols in PE-COFF.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|_CRT_MT
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
specifier|inline
name|int
name|__gthread_active_p
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|MINGW32_SUPPORTS_MT_EH
return|return
name|_CRT_MT
return|;
else|#
directive|else
return|return
literal|1
return|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|__gthread_once
parameter_list|(
name|__gthread_once_t
modifier|*
name|once
parameter_list|,
name|void
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|void
parameter_list|)
parameter_list|)
block|{
if|if
condition|(
operator|!
name|__gthread_active_p
argument_list|()
condition|)
return|return
operator|-
literal|1
return|;
elseif|else
if|if
condition|(
name|once
operator|==
name|NULL
operator|||
name|func
operator|==
name|NULL
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
operator|!
name|once
operator|->
name|done
condition|)
block|{
if|if
condition|(
name|InterlockedIncrement
argument_list|(
operator|&
operator|(
name|once
operator|->
name|started
operator|)
argument_list|)
operator|==
literal|0
condition|)
block|{
call|(
modifier|*
name|func
call|)
argument_list|()
expr_stmt|;
name|once
operator|->
name|done
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
comment|/* Another thread is currently executing the code, so wait for it  	     to finish; yield the CPU in the meantime.  If performance  	     does become an issue, the solution is to use an Event that  	     we wait on here (and set above), but that implies a place to  	     create the event before this routine is called.  */
while|while
condition|(
operator|!
name|once
operator|->
name|done
condition|)
name|Sleep
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Windows32 thread local keys don't support destructors; this leads to    leaks, especially in threaded applications making extensive use of     C++ EH. Mingw uses a thread-support DLL to work-around this problem.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|__gthread_key_create
parameter_list|(
name|__gthread_key_t
modifier|*
name|key
parameter_list|,
name|void
function_decl|(
modifier|*
name|dtor
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|)
block|{
name|int
name|status
init|=
literal|0
decl_stmt|;
name|DWORD
name|tls_index
init|=
name|TlsAlloc
argument_list|()
decl_stmt|;
if|if
condition|(
name|tls_index
operator|!=
literal|0xFFFFFFFF
condition|)
block|{
operator|*
name|key
operator|=
name|tls_index
expr_stmt|;
ifdef|#
directive|ifdef
name|MINGW32_SUPPORTS_MT_EH
comment|/* Mingw runtime will run the dtors in reverse order for each thread          when the thread exits.  */
name|status
operator|=
name|__mingwthr_key_dtor
argument_list|(
operator|*
name|key
argument_list|,
name|dtor
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
name|status
operator|=
operator|(
name|int
operator|)
name|GetLastError
argument_list|()
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/* Currently, this routine is called only for Mingw runtime, and if    -mthreads option is chosen to link in the thread support DLL.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|__gthread_key_dtor
parameter_list|(
name|__gthread_key_t
name|key
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|)
block|{
comment|/* Nothing needed.  */
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|__gthread_key_delete
parameter_list|(
name|__gthread_key_t
name|key
parameter_list|)
block|{
return|return
operator|(
name|TlsFree
argument_list|(
name|key
argument_list|)
operator|!=
literal|0
operator|)
condition|?
literal|0
else|:
operator|(
name|int
operator|)
name|GetLastError
argument_list|()
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
modifier|*
name|__gthread_getspecific
parameter_list|(
name|__gthread_key_t
name|key
parameter_list|)
block|{
name|DWORD
name|lasterror
decl_stmt|;
name|void
modifier|*
name|ptr
decl_stmt|;
name|lasterror
operator|=
name|GetLastError
argument_list|()
expr_stmt|;
name|ptr
operator|=
name|TlsGetValue
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|SetLastError
argument_list|(
name|lasterror
argument_list|)
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|__gthread_setspecific
parameter_list|(
name|__gthread_key_t
name|key
parameter_list|,
specifier|const
name|void
modifier|*
name|ptr
parameter_list|)
block|{
return|return
operator|(
name|TlsSetValue
argument_list|(
name|key
argument_list|,
operator|(
name|void
operator|*
operator|)
name|ptr
argument_list|)
operator|!=
literal|0
operator|)
condition|?
literal|0
else|:
operator|(
name|int
operator|)
name|GetLastError
argument_list|()
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|__gthread_mutex_init_function
parameter_list|(
name|__gthread_mutex_t
modifier|*
name|mutex
parameter_list|)
block|{
comment|/* Create unnamed mutex with default security attr and no initial owner.  */
operator|*
name|mutex
operator|=
name|CreateMutex
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|__gthread_mutex_lock
parameter_list|(
name|__gthread_mutex_t
modifier|*
name|mutex
parameter_list|)
block|{
name|int
name|status
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|__gthread_active_p
argument_list|()
condition|)
block|{
if|if
condition|(
name|WaitForSingleObject
argument_list|(
operator|*
name|mutex
argument_list|,
name|INFINITE
argument_list|)
operator|==
name|WAIT_OBJECT_0
condition|)
name|status
operator|=
literal|0
expr_stmt|;
else|else
name|status
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|__gthread_mutex_trylock
parameter_list|(
name|__gthread_mutex_t
modifier|*
name|mutex
parameter_list|)
block|{
name|int
name|status
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|__gthread_active_p
argument_list|()
condition|)
block|{
if|if
condition|(
name|WaitForSingleObject
argument_list|(
operator|*
name|mutex
argument_list|,
literal|0
argument_list|)
operator|==
name|WAIT_OBJECT_0
condition|)
name|status
operator|=
literal|0
expr_stmt|;
else|else
name|status
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|__gthread_mutex_unlock
parameter_list|(
name|__gthread_mutex_t
modifier|*
name|mutex
parameter_list|)
block|{
if|if
condition|(
name|__gthread_active_p
argument_list|()
condition|)
return|return
operator|(
name|ReleaseMutex
argument_list|(
operator|*
name|mutex
argument_list|)
operator|!=
literal|0
operator|)
condition|?
literal|0
else|:
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _LIBOBJC */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! GCC_GTHR_WIN32_H */
end_comment

end_unit

