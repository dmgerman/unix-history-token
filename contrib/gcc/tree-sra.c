begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Scalar Replacement of Aggregates (SRA) converts some structure    references into scalar references, exposing them to the scalar    optimizers.    Copyright (C) 2003, 2004, 2005, 2006, 2007    Free Software Foundation, Inc.    Contributed by Diego Novillo<dnovillo@redhat.com>  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_comment
comment|/* These RTL headers are needed for basic-block.h.  */
end_comment

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_include
include|#
directive|include
file|"tree-inline.h"
end_include

begin_include
include|#
directive|include
file|"tree-flow.h"
end_include

begin_include
include|#
directive|include
file|"tree-gimple.h"
end_include

begin_include
include|#
directive|include
file|"tree-dump.h"
end_include

begin_include
include|#
directive|include
file|"tree-pass.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"bitmap.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_comment
comment|/* expr.h is needed for MOVE_RATIO.  */
end_comment

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"params.h"
end_include

begin_comment
comment|/* This object of this pass is to replace a non-addressable aggregate with a    set of independent variables.  Most of the time, all of these variables    will be scalars.  But a secondary objective is to break up larger    aggregates into smaller aggregates.  In the process we may find that some    bits of the larger aggregate can be deleted as unreferenced.     This substitution is done globally.  More localized substitutions would    be the purvey of a load-store motion pass.     The optimization proceeds in phases:       (1) Identify variables that have types that are candidates for 	 decomposition.       (2) Scan the function looking for the ways these variables are used. 	 In particular we're interested in the number of times a variable 	 (or member) is needed as a complete unit, and the number of times 	 a variable (or member) is copied.       (3) Based on the usage profile, instantiate substitution variables.       (4) Scan the function making replacements. */
end_comment

begin_comment
comment|/* The set of todo flags to return from tree_sra.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|todoflags
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The set of aggregate variables that are candidates for scalarization.  */
end_comment

begin_decl_stmt
specifier|static
name|bitmap
name|sra_candidates
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set of scalarizable PARM_DECLs that need copy-in operations at the    beginning of the function.  */
end_comment

begin_decl_stmt
specifier|static
name|bitmap
name|needs_copy_in
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Sets of bit pairs that cache type decomposition and instantiation.  */
end_comment

begin_decl_stmt
specifier|static
name|bitmap
name|sra_type_decomp_cache
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bitmap
name|sra_type_inst_cache
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* One of these structures is created for each candidate aggregate and    each (accessed) member or group of members of such an aggregate.  */
end_comment

begin_struct
struct|struct
name|sra_elt
block|{
comment|/* A tree of the elements.  Used when we want to traverse everything.  */
name|struct
name|sra_elt
modifier|*
name|parent
decl_stmt|;
name|struct
name|sra_elt
modifier|*
name|groups
decl_stmt|;
name|struct
name|sra_elt
modifier|*
name|children
decl_stmt|;
name|struct
name|sra_elt
modifier|*
name|sibling
decl_stmt|;
comment|/* If this element is a root, then this is the VAR_DECL.  If this is      a sub-element, this is some token used to identify the reference.      In the case of COMPONENT_REF, this is the FIELD_DECL.  In the case      of an ARRAY_REF, this is the (constant) index.  In the case of an      ARRAY_RANGE_REF, this is the (constant) RANGE_EXPR.  In the case      of a complex number, this is a zero or one.  */
name|tree
name|element
decl_stmt|;
comment|/* The type of the element.  */
name|tree
name|type
decl_stmt|;
comment|/* A VAR_DECL, for any sub-element we've decided to replace.  */
name|tree
name|replacement
decl_stmt|;
comment|/* The number of times the element is referenced as a whole.  I.e.      given "a.b.c", this would be incremented for C, but not for A or B.  */
name|unsigned
name|int
name|n_uses
decl_stmt|;
comment|/* The number of times the element is copied to or from another      scalarizable element.  */
name|unsigned
name|int
name|n_copies
decl_stmt|;
comment|/* True if TYPE is scalar.  */
name|bool
name|is_scalar
decl_stmt|;
comment|/* True if this element is a group of members of its parent.  */
name|bool
name|is_group
decl_stmt|;
comment|/* True if we saw something about this element that prevents scalarization,      such as non-constant indexing.  */
name|bool
name|cannot_scalarize
decl_stmt|;
comment|/* True if we've decided that structure-to-structure assignment      should happen via memcpy and not per-element.  */
name|bool
name|use_block_copy
decl_stmt|;
comment|/* True if everything under this element has been marked TREE_NO_WARNING.  */
name|bool
name|all_no_warning
decl_stmt|;
comment|/* A flag for use with/after random access traversals.  */
name|bool
name|visited
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|IS_ELEMENT_FOR_GROUP
parameter_list|(
name|ELEMENT
parameter_list|)
value|(TREE_CODE (ELEMENT) == RANGE_EXPR)
end_define

begin_define
define|#
directive|define
name|FOR_EACH_ACTUAL_CHILD
parameter_list|(
name|CHILD
parameter_list|,
name|ELT
parameter_list|)
define|\
value|for ((CHILD) = (ELT)->is_group				\ 		 ? next_child_for_group (NULL, (ELT))		\ 		 : (ELT)->children;				\        (CHILD);							\        (CHILD) = (ELT)->is_group				\ 		 ? next_child_for_group ((CHILD), (ELT))	\ 		 : (CHILD)->sibling)
end_define

begin_comment
comment|/* Helper function for above macro.  Return next child in group.  */
end_comment

begin_function
specifier|static
name|struct
name|sra_elt
modifier|*
name|next_child_for_group
parameter_list|(
name|struct
name|sra_elt
modifier|*
name|child
parameter_list|,
name|struct
name|sra_elt
modifier|*
name|group
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|group
operator|->
name|is_group
argument_list|)
expr_stmt|;
comment|/* Find the next child in the parent.  */
if|if
condition|(
name|child
condition|)
name|child
operator|=
name|child
operator|->
name|sibling
expr_stmt|;
else|else
name|child
operator|=
name|group
operator|->
name|parent
operator|->
name|children
expr_stmt|;
comment|/* Skip siblings that do not belong to the group.  */
while|while
condition|(
name|child
condition|)
block|{
name|tree
name|g_elt
init|=
name|group
operator|->
name|element
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|g_elt
argument_list|)
operator|==
name|RANGE_EXPR
condition|)
block|{
if|if
condition|(
operator|!
name|tree_int_cst_lt
argument_list|(
name|child
operator|->
name|element
argument_list|,
name|TREE_OPERAND
argument_list|(
name|g_elt
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
operator|!
name|tree_int_cst_lt
argument_list|(
name|TREE_OPERAND
argument_list|(
name|g_elt
argument_list|,
literal|1
argument_list|)
argument_list|,
name|child
operator|->
name|element
argument_list|)
condition|)
break|break;
block|}
else|else
name|gcc_unreachable
argument_list|()
expr_stmt|;
name|child
operator|=
name|child
operator|->
name|sibling
expr_stmt|;
block|}
return|return
name|child
return|;
block|}
end_function

begin_comment
comment|/* Random access to the child of a parent is performed by hashing.    This prevents quadratic behavior, and allows SRA to function    reasonably on larger records.  */
end_comment

begin_decl_stmt
specifier|static
name|htab_t
name|sra_map
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* All structures are allocated out of the following obstack.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|sra_obstack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Debugging functions.  */
end_comment

begin_function_decl
specifier|static
name|void
name|dump_sra_elt_name
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|struct
name|sra_elt
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|debug_sra_elt_name
parameter_list|(
name|struct
name|sra_elt
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Forward declarations.  */
end_comment

begin_function_decl
specifier|static
name|tree
name|generate_element_ref
parameter_list|(
name|struct
name|sra_elt
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* Return true if DECL is an SRA candidate.  */
end_comment

begin_function
specifier|static
name|bool
name|is_sra_candidate_decl
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
return|return
name|DECL_P
argument_list|(
name|decl
argument_list|)
operator|&&
name|bitmap_bit_p
argument_list|(
name|sra_candidates
argument_list|,
name|DECL_UID
argument_list|(
name|decl
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if TYPE is a scalar type.  */
end_comment

begin_function
specifier|static
name|bool
name|is_sra_scalar_type
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
return|return
operator|(
name|code
operator|==
name|INTEGER_TYPE
operator|||
name|code
operator|==
name|REAL_TYPE
operator|||
name|code
operator|==
name|VECTOR_TYPE
operator|||
name|code
operator|==
name|ENUMERAL_TYPE
operator|||
name|code
operator|==
name|BOOLEAN_TYPE
operator|||
name|code
operator|==
name|POINTER_TYPE
operator|||
name|code
operator|==
name|OFFSET_TYPE
operator|||
name|code
operator|==
name|REFERENCE_TYPE
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if TYPE can be decomposed into a set of independent variables.     Note that this doesn't imply that all elements of TYPE can be    instantiated, just that if we decide to break up the type into    separate pieces that it can be done.  */
end_comment

begin_function
name|bool
name|sra_type_can_be_decomposed_p
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|unsigned
name|int
name|cache
init|=
name|TYPE_UID
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
argument_list|)
operator|*
literal|2
decl_stmt|;
name|tree
name|t
decl_stmt|;
comment|/* Avoid searching the same type twice.  */
if|if
condition|(
name|bitmap_bit_p
argument_list|(
name|sra_type_decomp_cache
argument_list|,
name|cache
operator|+
literal|0
argument_list|)
condition|)
return|return
name|true
return|;
if|if
condition|(
name|bitmap_bit_p
argument_list|(
name|sra_type_decomp_cache
argument_list|,
name|cache
operator|+
literal|1
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* The type must have a definite nonzero size.  */
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|==
name|NULL
operator|||
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
name|integer_zerop
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
goto|goto
name|fail
goto|;
comment|/* The type must be a non-union aggregate.  */
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|RECORD_TYPE
case|:
block|{
name|bool
name|saw_one_field
init|=
name|false
decl_stmt|;
for|for
control|(
name|t
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|FIELD_DECL
condition|)
block|{
comment|/* Reject incorrectly represented bit fields.  */
if|if
condition|(
name|DECL_BIT_FIELD
argument_list|(
name|t
argument_list|)
operator|&&
operator|(
name|tree_low_cst
argument_list|(
name|DECL_SIZE
argument_list|(
name|t
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|!=
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|)
condition|)
goto|goto
name|fail
goto|;
name|saw_one_field
operator|=
name|true
expr_stmt|;
block|}
comment|/* Record types must have at least one field.  */
if|if
condition|(
operator|!
name|saw_one_field
condition|)
goto|goto
name|fail
goto|;
block|}
break|break;
case|case
name|ARRAY_TYPE
case|:
comment|/* Array types must have a fixed lower and upper bound.  */
name|t
operator|=
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
name|TYPE_MIN_VALUE
argument_list|(
name|t
argument_list|)
operator|==
name|NULL
operator|||
operator|!
name|TREE_CONSTANT
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
name|TYPE_MAX_VALUE
argument_list|(
name|t
argument_list|)
operator|==
name|NULL
operator|||
operator|!
name|TREE_CONSTANT
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
goto|goto
name|fail
goto|;
break|break;
case|case
name|COMPLEX_TYPE
case|:
break|break;
default|default:
goto|goto
name|fail
goto|;
block|}
name|bitmap_set_bit
argument_list|(
name|sra_type_decomp_cache
argument_list|,
name|cache
operator|+
literal|0
argument_list|)
expr_stmt|;
return|return
name|true
return|;
name|fail
label|:
name|bitmap_set_bit
argument_list|(
name|sra_type_decomp_cache
argument_list|,
name|cache
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Return true if DECL can be decomposed into a set of independent    (though not necessarily scalar) variables.  */
end_comment

begin_function
specifier|static
name|bool
name|decl_can_be_decomposed_p
parameter_list|(
name|tree
name|var
parameter_list|)
block|{
comment|/* Early out for scalars.  */
if|if
condition|(
name|is_sra_scalar_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|var
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* The variable must not be aliased.  */
if|if
condition|(
operator|!
name|is_gimple_non_addressable
argument_list|(
name|var
argument_list|)
condition|)
block|{
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Cannot scalarize variable "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|var
argument_list|,
name|dump_flags
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|" because it must live in memory\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|false
return|;
block|}
comment|/* The variable must not be volatile.  */
if|if
condition|(
name|TREE_THIS_VOLATILE
argument_list|(
name|var
argument_list|)
condition|)
block|{
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Cannot scalarize variable "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|var
argument_list|,
name|dump_flags
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|" because it is declared volatile\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|false
return|;
block|}
comment|/* We must be able to decompose the variable's type.  */
if|if
condition|(
operator|!
name|sra_type_can_be_decomposed_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|var
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Cannot scalarize variable "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|var
argument_list|,
name|dump_flags
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|" because its type cannot be decomposed\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Return true if TYPE can be *completely* decomposed into scalars.  */
end_comment

begin_function
specifier|static
name|bool
name|type_can_instantiate_all_elements
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
if|if
condition|(
name|is_sra_scalar_type
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|true
return|;
if|if
condition|(
operator|!
name|sra_type_can_be_decomposed_p
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|false
return|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|RECORD_TYPE
case|:
block|{
name|unsigned
name|int
name|cache
init|=
name|TYPE_UID
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
argument_list|)
operator|*
literal|2
decl_stmt|;
name|tree
name|f
decl_stmt|;
if|if
condition|(
name|bitmap_bit_p
argument_list|(
name|sra_type_inst_cache
argument_list|,
name|cache
operator|+
literal|0
argument_list|)
condition|)
return|return
name|true
return|;
if|if
condition|(
name|bitmap_bit_p
argument_list|(
name|sra_type_inst_cache
argument_list|,
name|cache
operator|+
literal|1
argument_list|)
condition|)
return|return
name|false
return|;
for|for
control|(
name|f
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|f
condition|;
name|f
operator|=
name|TREE_CHAIN
argument_list|(
name|f
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|f
argument_list|)
operator|==
name|FIELD_DECL
condition|)
block|{
if|if
condition|(
operator|!
name|type_can_instantiate_all_elements
argument_list|(
name|TREE_TYPE
argument_list|(
name|f
argument_list|)
argument_list|)
condition|)
block|{
name|bitmap_set_bit
argument_list|(
name|sra_type_inst_cache
argument_list|,
name|cache
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
name|bitmap_set_bit
argument_list|(
name|sra_type_inst_cache
argument_list|,
name|cache
operator|+
literal|0
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
case|case
name|ARRAY_TYPE
case|:
return|return
name|type_can_instantiate_all_elements
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
return|;
case|case
name|COMPLEX_TYPE
case|:
return|return
name|true
return|;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Test whether ELT or some sub-element cannot be scalarized.  */
end_comment

begin_function
specifier|static
name|bool
name|can_completely_scalarize_p
parameter_list|(
name|struct
name|sra_elt
modifier|*
name|elt
parameter_list|)
block|{
name|struct
name|sra_elt
modifier|*
name|c
decl_stmt|;
if|if
condition|(
name|elt
operator|->
name|cannot_scalarize
condition|)
return|return
name|false
return|;
for|for
control|(
name|c
operator|=
name|elt
operator|->
name|children
init|;
name|c
condition|;
name|c
operator|=
name|c
operator|->
name|sibling
control|)
if|if
condition|(
operator|!
name|can_completely_scalarize_p
argument_list|(
name|c
argument_list|)
condition|)
return|return
name|false
return|;
for|for
control|(
name|c
operator|=
name|elt
operator|->
name|groups
init|;
name|c
condition|;
name|c
operator|=
name|c
operator|->
name|sibling
control|)
if|if
condition|(
operator|!
name|can_completely_scalarize_p
argument_list|(
name|c
argument_list|)
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* A simplified tree hashing algorithm that only handles the types of    trees we expect to find in sra_elt->element.  */
end_comment

begin_function
specifier|static
name|hashval_t
name|sra_hash_tree
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|hashval_t
name|h
decl_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|VAR_DECL
case|:
case|case
name|PARM_DECL
case|:
case|case
name|RESULT_DECL
case|:
name|h
operator|=
name|DECL_UID
argument_list|(
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|INTEGER_CST
case|:
name|h
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|t
argument_list|)
operator|^
name|TREE_INT_CST_HIGH
argument_list|(
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|RANGE_EXPR
case|:
name|h
operator|=
name|iterative_hash_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|h
operator|=
name|iterative_hash_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|h
argument_list|)
expr_stmt|;
break|break;
case|case
name|FIELD_DECL
case|:
comment|/* We can have types that are compatible, but have different member 	 lists, so we can't hash fields by ID.  Use offsets instead.  */
name|h
operator|=
name|iterative_hash_expr
argument_list|(
name|DECL_FIELD_OFFSET
argument_list|(
name|t
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|h
operator|=
name|iterative_hash_expr
argument_list|(
name|DECL_FIELD_BIT_OFFSET
argument_list|(
name|t
argument_list|)
argument_list|,
name|h
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
return|return
name|h
return|;
block|}
end_function

begin_comment
comment|/* Hash function for type SRA_PAIR.  */
end_comment

begin_function
specifier|static
name|hashval_t
name|sra_elt_hash
parameter_list|(
specifier|const
name|void
modifier|*
name|x
parameter_list|)
block|{
specifier|const
name|struct
name|sra_elt
modifier|*
name|e
init|=
name|x
decl_stmt|;
specifier|const
name|struct
name|sra_elt
modifier|*
name|p
decl_stmt|;
name|hashval_t
name|h
decl_stmt|;
name|h
operator|=
name|sra_hash_tree
argument_list|(
name|e
operator|->
name|element
argument_list|)
expr_stmt|;
comment|/* Take into account everything back up the chain.  Given that chain      lengths are rarely very long, this should be acceptable.  If we      truly identify this as a performance problem, it should work to      hash the pointer value "e->parent".  */
for|for
control|(
name|p
operator|=
name|e
operator|->
name|parent
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|parent
control|)
name|h
operator|=
operator|(
name|h
operator|*
literal|65521
operator|)
operator|^
name|sra_hash_tree
argument_list|(
name|p
operator|->
name|element
argument_list|)
expr_stmt|;
return|return
name|h
return|;
block|}
end_function

begin_comment
comment|/* Equality function for type SRA_PAIR.  */
end_comment

begin_function
specifier|static
name|int
name|sra_elt_eq
parameter_list|(
specifier|const
name|void
modifier|*
name|x
parameter_list|,
specifier|const
name|void
modifier|*
name|y
parameter_list|)
block|{
specifier|const
name|struct
name|sra_elt
modifier|*
name|a
init|=
name|x
decl_stmt|;
specifier|const
name|struct
name|sra_elt
modifier|*
name|b
init|=
name|y
decl_stmt|;
name|tree
name|ae
decl_stmt|,
name|be
decl_stmt|;
if|if
condition|(
name|a
operator|->
name|parent
operator|!=
name|b
operator|->
name|parent
condition|)
return|return
name|false
return|;
name|ae
operator|=
name|a
operator|->
name|element
expr_stmt|;
name|be
operator|=
name|b
operator|->
name|element
expr_stmt|;
if|if
condition|(
name|ae
operator|==
name|be
condition|)
return|return
name|true
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ae
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|be
argument_list|)
condition|)
return|return
name|false
return|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|ae
argument_list|)
condition|)
block|{
case|case
name|VAR_DECL
case|:
case|case
name|PARM_DECL
case|:
case|case
name|RESULT_DECL
case|:
comment|/* These are all pointer unique.  */
return|return
name|false
return|;
case|case
name|INTEGER_CST
case|:
comment|/* Integers are not pointer unique, so compare their values.  */
return|return
name|tree_int_cst_equal
argument_list|(
name|ae
argument_list|,
name|be
argument_list|)
return|;
case|case
name|RANGE_EXPR
case|:
return|return
name|tree_int_cst_equal
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ae
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|be
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|tree_int_cst_equal
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ae
argument_list|,
literal|1
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|be
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
case|case
name|FIELD_DECL
case|:
comment|/* Fields are unique within a record, but not between 	 compatible records.  */
if|if
condition|(
name|DECL_FIELD_CONTEXT
argument_list|(
name|ae
argument_list|)
operator|==
name|DECL_FIELD_CONTEXT
argument_list|(
name|be
argument_list|)
condition|)
return|return
name|false
return|;
return|return
name|fields_compatible_p
argument_list|(
name|ae
argument_list|,
name|be
argument_list|)
return|;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Create or return the SRA_ELT structure for CHILD in PARENT.  PARENT    may be null, in which case CHILD must be a DECL.  */
end_comment

begin_function
specifier|static
name|struct
name|sra_elt
modifier|*
name|lookup_element
parameter_list|(
name|struct
name|sra_elt
modifier|*
name|parent
parameter_list|,
name|tree
name|child
parameter_list|,
name|tree
name|type
parameter_list|,
name|enum
name|insert_option
name|insert
parameter_list|)
block|{
name|struct
name|sra_elt
name|dummy
decl_stmt|;
name|struct
name|sra_elt
modifier|*
modifier|*
name|slot
decl_stmt|;
name|struct
name|sra_elt
modifier|*
name|elt
decl_stmt|;
if|if
condition|(
name|parent
condition|)
name|dummy
operator|.
name|parent
operator|=
name|parent
operator|->
name|is_group
condition|?
name|parent
operator|->
name|parent
else|:
name|parent
expr_stmt|;
else|else
name|dummy
operator|.
name|parent
operator|=
name|NULL
expr_stmt|;
name|dummy
operator|.
name|element
operator|=
name|child
expr_stmt|;
name|slot
operator|=
operator|(
expr|struct
name|sra_elt
operator|*
operator|*
operator|)
name|htab_find_slot
argument_list|(
name|sra_map
argument_list|,
operator|&
name|dummy
argument_list|,
name|insert
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|slot
operator|&&
name|insert
operator|==
name|NO_INSERT
condition|)
return|return
name|NULL
return|;
name|elt
operator|=
operator|*
name|slot
expr_stmt|;
if|if
condition|(
operator|!
name|elt
operator|&&
name|insert
operator|==
name|INSERT
condition|)
block|{
operator|*
name|slot
operator|=
name|elt
operator|=
name|obstack_alloc
argument_list|(
operator|&
name|sra_obstack
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|elt
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|elt
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|elt
argument_list|)
argument_list|)
expr_stmt|;
name|elt
operator|->
name|parent
operator|=
name|parent
expr_stmt|;
name|elt
operator|->
name|element
operator|=
name|child
expr_stmt|;
name|elt
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|elt
operator|->
name|is_scalar
operator|=
name|is_sra_scalar_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|parent
condition|)
block|{
if|if
condition|(
name|IS_ELEMENT_FOR_GROUP
argument_list|(
name|elt
operator|->
name|element
argument_list|)
condition|)
block|{
name|elt
operator|->
name|is_group
operator|=
name|true
expr_stmt|;
name|elt
operator|->
name|sibling
operator|=
name|parent
operator|->
name|groups
expr_stmt|;
name|parent
operator|->
name|groups
operator|=
name|elt
expr_stmt|;
block|}
else|else
block|{
name|elt
operator|->
name|sibling
operator|=
name|parent
operator|->
name|children
expr_stmt|;
name|parent
operator|->
name|children
operator|=
name|elt
expr_stmt|;
block|}
block|}
comment|/* If this is a parameter, then if we want to scalarize, we have 	 one copy from the true function parameter.  Count it now.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|child
argument_list|)
operator|==
name|PARM_DECL
condition|)
block|{
name|elt
operator|->
name|n_copies
operator|=
literal|1
expr_stmt|;
name|bitmap_set_bit
argument_list|(
name|needs_copy_in
argument_list|,
name|DECL_UID
argument_list|(
name|child
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|elt
return|;
block|}
end_function

begin_comment
comment|/* Create or return the SRA_ELT structure for EXPR if the expression    refers to a scalarizable variable.  */
end_comment

begin_function
specifier|static
name|struct
name|sra_elt
modifier|*
name|maybe_lookup_element_for_expr
parameter_list|(
name|tree
name|expr
parameter_list|)
block|{
name|struct
name|sra_elt
modifier|*
name|elt
decl_stmt|;
name|tree
name|child
decl_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
condition|)
block|{
case|case
name|VAR_DECL
case|:
case|case
name|PARM_DECL
case|:
case|case
name|RESULT_DECL
case|:
if|if
condition|(
name|is_sra_candidate_decl
argument_list|(
name|expr
argument_list|)
condition|)
return|return
name|lookup_element
argument_list|(
name|NULL
argument_list|,
name|expr
argument_list|,
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|,
name|INSERT
argument_list|)
return|;
return|return
name|NULL
return|;
case|case
name|ARRAY_REF
case|:
comment|/* We can't scalarize variable array indices.  */
if|if
condition|(
name|in_array_bounds_p
argument_list|(
name|expr
argument_list|)
condition|)
name|child
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
return|return
name|NULL
return|;
break|break;
case|case
name|ARRAY_RANGE_REF
case|:
comment|/* We can't scalarize variable array indices.  */
if|if
condition|(
name|range_in_array_bounds_p
argument_list|(
name|expr
argument_list|)
condition|)
block|{
name|tree
name|domain
init|=
name|TYPE_DOMAIN
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
decl_stmt|;
name|child
operator|=
name|build2
argument_list|(
name|RANGE_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|TYPE_MIN_VALUE
argument_list|(
name|domain
argument_list|)
argument_list|,
name|TYPE_MAX_VALUE
argument_list|(
name|domain
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
return|return
name|NULL
return|;
break|break;
case|case
name|COMPONENT_REF
case|:
comment|/* Don't look through unions.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|RECORD_TYPE
condition|)
return|return
name|NULL
return|;
name|child
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|REALPART_EXPR
case|:
name|child
operator|=
name|integer_zero_node
expr_stmt|;
break|break;
case|case
name|IMAGPART_EXPR
case|:
name|child
operator|=
name|integer_one_node
expr_stmt|;
break|break;
default|default:
return|return
name|NULL
return|;
block|}
name|elt
operator|=
name|maybe_lookup_element_for_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|elt
condition|)
return|return
name|lookup_element
argument_list|(
name|elt
argument_list|,
name|child
argument_list|,
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|,
name|INSERT
argument_list|)
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Functions to walk just enough of the tree to see all scalarizable    references, and categorize them.  */
end_comment

begin_comment
comment|/* A set of callbacks for phases 2 and 4.  They'll be invoked for the    various kinds of references seen.  In all cases, *BSI is an iterator    pointing to the statement being processed.  */
end_comment

begin_struct
struct|struct
name|sra_walk_fns
block|{
comment|/* Invoked when ELT is required as a unit.  Note that ELT might refer to      a leaf node, in which case this is a simple scalar reference.  *EXPR_P      points to the location of the expression.  IS_OUTPUT is true if this      is a left-hand-side reference.  USE_ALL is true if we saw something we      couldn't quite identify and had to force the use of the entire object.  */
name|void
function_decl|(
modifier|*
name|use
function_decl|)
parameter_list|(
name|struct
name|sra_elt
modifier|*
name|elt
parameter_list|,
name|tree
modifier|*
name|expr_p
parameter_list|,
name|block_stmt_iterator
modifier|*
name|bsi
parameter_list|,
name|bool
name|is_output
parameter_list|,
name|bool
name|use_all
parameter_list|)
function_decl|;
comment|/* Invoked when we have a copy between two scalarizable references.  */
name|void
function_decl|(
modifier|*
name|copy
function_decl|)
parameter_list|(
name|struct
name|sra_elt
modifier|*
name|lhs_elt
parameter_list|,
name|struct
name|sra_elt
modifier|*
name|rhs_elt
parameter_list|,
name|block_stmt_iterator
modifier|*
name|bsi
parameter_list|)
function_decl|;
comment|/* Invoked when ELT is initialized from a constant.  VALUE may be NULL,      in which case it should be treated as an empty CONSTRUCTOR.  */
name|void
function_decl|(
modifier|*
name|init
function_decl|)
parameter_list|(
name|struct
name|sra_elt
modifier|*
name|elt
parameter_list|,
name|tree
name|value
parameter_list|,
name|block_stmt_iterator
modifier|*
name|bsi
parameter_list|)
function_decl|;
comment|/* Invoked when we have a copy between one scalarizable reference ELT      and one non-scalarizable reference OTHER without side-effects.       IS_OUTPUT is true if ELT is on the left-hand side.  */
name|void
function_decl|(
modifier|*
name|ldst
function_decl|)
parameter_list|(
name|struct
name|sra_elt
modifier|*
name|elt
parameter_list|,
name|tree
name|other
parameter_list|,
name|block_stmt_iterator
modifier|*
name|bsi
parameter_list|,
name|bool
name|is_output
parameter_list|)
function_decl|;
comment|/* True during phase 2, false during phase 4.  */
comment|/* ??? This is a hack.  */
name|bool
name|initial_scan
decl_stmt|;
block|}
struct|;
end_struct

begin_ifdef
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
end_ifdef

begin_comment
comment|/* Invoked via walk_tree, if *TP contains a candidate decl, return it.  */
end_comment

begin_function
specifier|static
name|tree
name|sra_find_candidate_decl
parameter_list|(
name|tree
modifier|*
name|tp
parameter_list|,
name|int
modifier|*
name|walk_subtrees
parameter_list|,
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|tree
name|t
init|=
operator|*
name|tp
decl_stmt|;
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|VAR_DECL
operator|||
name|code
operator|==
name|PARM_DECL
operator|||
name|code
operator|==
name|RESULT_DECL
condition|)
block|{
operator|*
name|walk_subtrees
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|is_sra_candidate_decl
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|t
return|;
block|}
elseif|else
if|if
condition|(
name|TYPE_P
argument_list|(
name|t
argument_list|)
condition|)
operator|*
name|walk_subtrees
operator|=
literal|0
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Walk most expressions looking for a scalarizable aggregate.    If we find one, invoke FNS->USE.  */
end_comment

begin_function
specifier|static
name|void
name|sra_walk_expr
parameter_list|(
name|tree
modifier|*
name|expr_p
parameter_list|,
name|block_stmt_iterator
modifier|*
name|bsi
parameter_list|,
name|bool
name|is_output
parameter_list|,
specifier|const
name|struct
name|sra_walk_fns
modifier|*
name|fns
parameter_list|)
block|{
name|tree
name|expr
init|=
operator|*
name|expr_p
decl_stmt|;
name|tree
name|inner
init|=
name|expr
decl_stmt|;
name|bool
name|disable_scalarization
init|=
name|false
decl_stmt|;
name|bool
name|use_all_p
init|=
name|false
decl_stmt|;
comment|/* We're looking to collect a reference expression between EXPR and INNER,      such that INNER is a scalarizable decl and all other nodes through EXPR      are references that we can scalarize.  If we come across something that      we can't scalarize, we reset EXPR.  This has the effect of making it      appear that we're referring to the larger expression as a whole.  */
while|while
condition|(
literal|1
condition|)
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|inner
argument_list|)
condition|)
block|{
case|case
name|VAR_DECL
case|:
case|case
name|PARM_DECL
case|:
case|case
name|RESULT_DECL
case|:
comment|/* If there is a scalarizable decl at the bottom, then process it.  */
if|if
condition|(
name|is_sra_candidate_decl
argument_list|(
name|inner
argument_list|)
condition|)
block|{
name|struct
name|sra_elt
modifier|*
name|elt
init|=
name|maybe_lookup_element_for_expr
argument_list|(
name|expr
argument_list|)
decl_stmt|;
if|if
condition|(
name|disable_scalarization
condition|)
name|elt
operator|->
name|cannot_scalarize
operator|=
name|true
expr_stmt|;
else|else
name|fns
operator|->
name|use
argument_list|(
name|elt
argument_list|,
name|expr_p
argument_list|,
name|bsi
argument_list|,
name|is_output
argument_list|,
name|use_all_p
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
name|ARRAY_REF
case|:
comment|/* Non-constant index means any member may be accessed.  Prevent the 	   expression from being scalarized.  If we were to treat this as a 	   reference to the whole array, we can wind up with a single dynamic 	   index reference inside a loop being overridden by several constant 	   index references during loop setup.  It's possible that this could 	   be avoided by using dynamic usage counts based on BB trip counts 	   (based on loop analysis or profiling), but that hardly seems worth 	   the effort.  */
comment|/* ??? Hack.  Figure out how to push this into the scan routines 	   without duplicating too much code.  */
if|if
condition|(
operator|!
name|in_array_bounds_p
argument_list|(
name|inner
argument_list|)
condition|)
block|{
name|disable_scalarization
operator|=
name|true
expr_stmt|;
goto|goto
name|use_all
goto|;
block|}
comment|/* ??? Are we assured that non-constant bounds and stride will have 	   the same value everywhere?  I don't think Fortran will...  */
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|inner
argument_list|,
literal|2
argument_list|)
operator|||
name|TREE_OPERAND
argument_list|(
name|inner
argument_list|,
literal|3
argument_list|)
condition|)
goto|goto
name|use_all
goto|;
name|inner
operator|=
name|TREE_OPERAND
argument_list|(
name|inner
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARRAY_RANGE_REF
case|:
if|if
condition|(
operator|!
name|range_in_array_bounds_p
argument_list|(
name|inner
argument_list|)
condition|)
block|{
name|disable_scalarization
operator|=
name|true
expr_stmt|;
goto|goto
name|use_all
goto|;
block|}
comment|/* ??? See above non-constant bounds and stride .  */
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|inner
argument_list|,
literal|2
argument_list|)
operator|||
name|TREE_OPERAND
argument_list|(
name|inner
argument_list|,
literal|3
argument_list|)
condition|)
goto|goto
name|use_all
goto|;
name|inner
operator|=
name|TREE_OPERAND
argument_list|(
name|inner
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|COMPONENT_REF
case|:
comment|/* A reference to a union member constitutes a reference to the 	   entire union.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|inner
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|RECORD_TYPE
condition|)
goto|goto
name|use_all
goto|;
comment|/* ??? See above re non-constant stride.  */
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|inner
argument_list|,
literal|2
argument_list|)
condition|)
goto|goto
name|use_all
goto|;
name|inner
operator|=
name|TREE_OPERAND
argument_list|(
name|inner
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|REALPART_EXPR
case|:
case|case
name|IMAGPART_EXPR
case|:
name|inner
operator|=
name|TREE_OPERAND
argument_list|(
name|inner
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|BIT_FIELD_REF
case|:
comment|/* A bit field reference (access to *multiple* fields simultaneously) 	   is not currently scalarized.  Consider this an access to the 	   complete outer element, to which walk_tree will bring us next.  */
goto|goto
name|use_all
goto|;
case|case
name|VIEW_CONVERT_EXPR
case|:
case|case
name|NOP_EXPR
case|:
comment|/* Similarly, a view/nop explicitly wants to look at an object in a 	   type other than the one we've scalarized.  */
goto|goto
name|use_all
goto|;
case|case
name|WITH_SIZE_EXPR
case|:
comment|/* This is a transparent wrapper.  The entire inner expression really 	   is being used.  */
goto|goto
name|use_all
goto|;
name|use_all
label|:
name|expr_p
operator|=
operator|&
name|TREE_OPERAND
argument_list|(
name|inner
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|inner
operator|=
name|expr
operator|=
operator|*
name|expr_p
expr_stmt|;
name|use_all_p
operator|=
name|true
expr_stmt|;
break|break;
default|default:
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
comment|/* Validate that we're not missing any references.  */
name|gcc_assert
argument_list|(
operator|!
name|walk_tree
argument_list|(
operator|&
name|inner
argument_list|,
name|sra_find_candidate_decl
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
block|}
end_function

begin_comment
comment|/* Walk a TREE_LIST of values looking for scalarizable aggregates.    If we find one, invoke FNS->USE.  */
end_comment

begin_function
specifier|static
name|void
name|sra_walk_tree_list
parameter_list|(
name|tree
name|list
parameter_list|,
name|block_stmt_iterator
modifier|*
name|bsi
parameter_list|,
name|bool
name|is_output
parameter_list|,
specifier|const
name|struct
name|sra_walk_fns
modifier|*
name|fns
parameter_list|)
block|{
name|tree
name|op
decl_stmt|;
for|for
control|(
name|op
operator|=
name|list
init|;
name|op
condition|;
name|op
operator|=
name|TREE_CHAIN
argument_list|(
name|op
argument_list|)
control|)
name|sra_walk_expr
argument_list|(
operator|&
name|TREE_VALUE
argument_list|(
name|op
argument_list|)
argument_list|,
name|bsi
argument_list|,
name|is_output
argument_list|,
name|fns
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Walk the arguments of a CALL_EXPR looking for scalarizable aggregates.    If we find one, invoke FNS->USE.  */
end_comment

begin_function
specifier|static
name|void
name|sra_walk_call_expr
parameter_list|(
name|tree
name|expr
parameter_list|,
name|block_stmt_iterator
modifier|*
name|bsi
parameter_list|,
specifier|const
name|struct
name|sra_walk_fns
modifier|*
name|fns
parameter_list|)
block|{
name|sra_walk_tree_list
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|,
name|bsi
argument_list|,
name|false
argument_list|,
name|fns
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Walk the inputs and outputs of an ASM_EXPR looking for scalarizable    aggregates.  If we find one, invoke FNS->USE.  */
end_comment

begin_function
specifier|static
name|void
name|sra_walk_asm_expr
parameter_list|(
name|tree
name|expr
parameter_list|,
name|block_stmt_iterator
modifier|*
name|bsi
parameter_list|,
specifier|const
name|struct
name|sra_walk_fns
modifier|*
name|fns
parameter_list|)
block|{
name|sra_walk_tree_list
argument_list|(
name|ASM_INPUTS
argument_list|(
name|expr
argument_list|)
argument_list|,
name|bsi
argument_list|,
name|false
argument_list|,
name|fns
argument_list|)
expr_stmt|;
name|sra_walk_tree_list
argument_list|(
name|ASM_OUTPUTS
argument_list|(
name|expr
argument_list|)
argument_list|,
name|bsi
argument_list|,
name|true
argument_list|,
name|fns
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Walk a MODIFY_EXPR and categorize the assignment appropriately.  */
end_comment

begin_function
specifier|static
name|void
name|sra_walk_modify_expr
parameter_list|(
name|tree
name|expr
parameter_list|,
name|block_stmt_iterator
modifier|*
name|bsi
parameter_list|,
specifier|const
name|struct
name|sra_walk_fns
modifier|*
name|fns
parameter_list|)
block|{
name|struct
name|sra_elt
modifier|*
name|lhs_elt
decl_stmt|,
modifier|*
name|rhs_elt
decl_stmt|;
name|tree
name|lhs
decl_stmt|,
name|rhs
decl_stmt|;
name|lhs
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rhs
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|lhs_elt
operator|=
name|maybe_lookup_element_for_expr
argument_list|(
name|lhs
argument_list|)
expr_stmt|;
name|rhs_elt
operator|=
name|maybe_lookup_element_for_expr
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
comment|/* If both sides are scalarizable, this is a COPY operation.  */
if|if
condition|(
name|lhs_elt
operator|&&
name|rhs_elt
condition|)
block|{
name|fns
operator|->
name|copy
argument_list|(
name|lhs_elt
argument_list|,
name|rhs_elt
argument_list|,
name|bsi
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If the RHS is scalarizable, handle it.  There are only two cases.  */
if|if
condition|(
name|rhs_elt
condition|)
block|{
if|if
condition|(
operator|!
name|rhs_elt
operator|->
name|is_scalar
operator|&&
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|lhs
argument_list|)
condition|)
name|fns
operator|->
name|ldst
argument_list|(
name|rhs_elt
argument_list|,
name|lhs
argument_list|,
name|bsi
argument_list|,
name|false
argument_list|)
expr_stmt|;
else|else
name|fns
operator|->
name|use
argument_list|(
name|rhs_elt
argument_list|,
operator|&
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|,
name|bsi
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
comment|/* If it isn't scalarizable, there may be scalarizable variables within, so      check for a call or else walk the RHS to see if we need to do any      copy-in operations.  We need to do it before the LHS is scalarized so      that the statements get inserted in the proper place, before any      copy-out operations.  */
else|else
block|{
name|tree
name|call
init|=
name|get_call_expr_in
argument_list|(
name|rhs
argument_list|)
decl_stmt|;
if|if
condition|(
name|call
condition|)
name|sra_walk_call_expr
argument_list|(
name|call
argument_list|,
name|bsi
argument_list|,
name|fns
argument_list|)
expr_stmt|;
else|else
name|sra_walk_expr
argument_list|(
operator|&
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|,
name|bsi
argument_list|,
name|false
argument_list|,
name|fns
argument_list|)
expr_stmt|;
block|}
comment|/* Likewise, handle the LHS being scalarizable.  We have cases similar      to those above, but also want to handle RHS being constant.  */
if|if
condition|(
name|lhs_elt
condition|)
block|{
comment|/* If this is an assignment from a constant, or constructor, then 	 we have access to all of the elements individually.  Invoke INIT.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|COMPLEX_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|COMPLEX_CST
operator|||
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|CONSTRUCTOR
condition|)
name|fns
operator|->
name|init
argument_list|(
name|lhs_elt
argument_list|,
name|rhs
argument_list|,
name|bsi
argument_list|)
expr_stmt|;
comment|/* If this is an assignment from read-only memory, treat this as if 	 we'd been passed the constructor directly.  Invoke INIT.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|TREE_STATIC
argument_list|(
name|rhs
argument_list|)
operator|&&
name|TREE_READONLY
argument_list|(
name|rhs
argument_list|)
operator|&&
name|targetm
operator|.
name|binds_local_p
argument_list|(
name|rhs
argument_list|)
condition|)
name|fns
operator|->
name|init
argument_list|(
name|lhs_elt
argument_list|,
name|DECL_INITIAL
argument_list|(
name|rhs
argument_list|)
argument_list|,
name|bsi
argument_list|)
expr_stmt|;
comment|/* If this is a copy from a non-scalarizable lvalue, invoke LDST. 	 The lvalue requirement prevents us from trying to directly scalarize 	 the result of a function call.  Which would result in trying to call 	 the function multiple times, and other evil things.  */
elseif|else
if|if
condition|(
operator|!
name|lhs_elt
operator|->
name|is_scalar
operator|&&
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|rhs
argument_list|)
operator|&&
name|is_gimple_addressable
argument_list|(
name|rhs
argument_list|)
condition|)
name|fns
operator|->
name|ldst
argument_list|(
name|lhs_elt
argument_list|,
name|rhs
argument_list|,
name|bsi
argument_list|,
name|true
argument_list|)
expr_stmt|;
comment|/* Otherwise we're being used in some context that requires the 	 aggregate to be seen as a whole.  Invoke USE.  */
else|else
name|fns
operator|->
name|use
argument_list|(
name|lhs_elt
argument_list|,
operator|&
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|bsi
argument_list|,
name|true
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
comment|/* Similarly to above, LHS_ELT being null only means that the LHS as a      whole is not a scalarizable reference.  There may be occurrences of      scalarizable variables within, which implies a USE.  */
else|else
name|sra_walk_expr
argument_list|(
operator|&
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|bsi
argument_list|,
name|true
argument_list|,
name|fns
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Entry point to the walk functions.  Search the entire function,    invoking the callbacks in FNS on each of the references to    scalarizable variables.  */
end_comment

begin_function
specifier|static
name|void
name|sra_walk_function
parameter_list|(
specifier|const
name|struct
name|sra_walk_fns
modifier|*
name|fns
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|block_stmt_iterator
name|si
decl_stmt|,
name|ni
decl_stmt|;
comment|/* ??? Phase 4 could derive some benefit to walking the function in      dominator tree order.  */
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
for|for
control|(
name|si
operator|=
name|bsi_start
argument_list|(
name|bb
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|si
argument_list|)
condition|;
name|si
operator|=
name|ni
control|)
block|{
name|tree
name|stmt
decl_stmt|,
name|t
decl_stmt|;
name|stmt_ann_t
name|ann
decl_stmt|;
name|stmt
operator|=
name|bsi_stmt
argument_list|(
name|si
argument_list|)
expr_stmt|;
name|ann
operator|=
name|stmt_ann
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|ni
operator|=
name|si
expr_stmt|;
name|bsi_next
argument_list|(
operator|&
name|ni
argument_list|)
expr_stmt|;
comment|/* If the statement has no virtual operands, then it doesn't 	   make any structure references that we care about.  */
if|if
condition|(
name|ZERO_SSA_OPERANDS
argument_list|(
name|stmt
argument_list|,
operator|(
name|SSA_OP_VIRTUAL_DEFS
operator||
name|SSA_OP_VUSE
operator|)
argument_list|)
condition|)
continue|continue;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
condition|)
block|{
case|case
name|RETURN_EXPR
case|:
comment|/* If we have "return<retval>" then the return value is 	       already exposed for our pleasure.  Walk it as a USE to 	       force all the components back in place for the return.  	       If we have an embedded assignment, then<retval> is of 	       a type that gets returned in registers in this ABI, and 	       we do not wish to extend their lifetimes.  Treat this 	       as a USE of the variable on the RHS of this assignment.  */
name|t
operator|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|MODIFY_EXPR
condition|)
name|sra_walk_expr
argument_list|(
operator|&
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
operator|&
name|si
argument_list|,
name|false
argument_list|,
name|fns
argument_list|)
expr_stmt|;
else|else
name|sra_walk_expr
argument_list|(
operator|&
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|si
argument_list|,
name|false
argument_list|,
name|fns
argument_list|)
expr_stmt|;
break|break;
case|case
name|MODIFY_EXPR
case|:
name|sra_walk_modify_expr
argument_list|(
name|stmt
argument_list|,
operator|&
name|si
argument_list|,
name|fns
argument_list|)
expr_stmt|;
break|break;
case|case
name|CALL_EXPR
case|:
name|sra_walk_call_expr
argument_list|(
name|stmt
argument_list|,
operator|&
name|si
argument_list|,
name|fns
argument_list|)
expr_stmt|;
break|break;
case|case
name|ASM_EXPR
case|:
name|sra_walk_asm_expr
argument_list|(
name|stmt
argument_list|,
operator|&
name|si
argument_list|,
name|fns
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Phase One: Scan all referenced variables in the program looking for    structures that could be decomposed.  */
end_comment

begin_function
specifier|static
name|bool
name|find_candidates_for_sra
parameter_list|(
name|void
parameter_list|)
block|{
name|bool
name|any_set
init|=
name|false
decl_stmt|;
name|tree
name|var
decl_stmt|;
name|referenced_var_iterator
name|rvi
decl_stmt|;
name|FOR_EACH_REFERENCED_VAR
argument_list|(
argument|var
argument_list|,
argument|rvi
argument_list|)
block|{
if|if
condition|(
name|decl_can_be_decomposed_p
argument_list|(
name|var
argument_list|)
condition|)
block|{
name|bitmap_set_bit
argument_list|(
name|sra_candidates
argument_list|,
name|DECL_UID
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
name|any_set
operator|=
name|true
expr_stmt|;
block|}
block|}
return|return
name|any_set
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Phase Two: Scan all references to scalarizable variables.  Count the    number of times they are used or copied respectively.  */
end_comment

begin_comment
comment|/* Callbacks to fill in SRA_WALK_FNS.  Everything but USE is    considered a copy, because we can decompose the reference such that    the sub-elements needn't be contiguous.  */
end_comment

begin_function
specifier|static
name|void
name|scan_use
parameter_list|(
name|struct
name|sra_elt
modifier|*
name|elt
parameter_list|,
name|tree
modifier|*
name|expr_p
name|ATTRIBUTE_UNUSED
parameter_list|,
name|block_stmt_iterator
modifier|*
name|bsi
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bool
name|is_output
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bool
name|use_all
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|elt
operator|->
name|n_uses
operator|+=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|scan_copy
parameter_list|(
name|struct
name|sra_elt
modifier|*
name|lhs_elt
parameter_list|,
name|struct
name|sra_elt
modifier|*
name|rhs_elt
parameter_list|,
name|block_stmt_iterator
modifier|*
name|bsi
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|lhs_elt
operator|->
name|n_copies
operator|+=
literal|1
expr_stmt|;
name|rhs_elt
operator|->
name|n_copies
operator|+=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|scan_init
parameter_list|(
name|struct
name|sra_elt
modifier|*
name|lhs_elt
parameter_list|,
name|tree
name|rhs
name|ATTRIBUTE_UNUSED
parameter_list|,
name|block_stmt_iterator
modifier|*
name|bsi
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|lhs_elt
operator|->
name|n_copies
operator|+=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|scan_ldst
parameter_list|(
name|struct
name|sra_elt
modifier|*
name|elt
parameter_list|,
name|tree
name|other
name|ATTRIBUTE_UNUSED
parameter_list|,
name|block_stmt_iterator
modifier|*
name|bsi
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bool
name|is_output
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|elt
operator|->
name|n_copies
operator|+=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dump the values we collected during the scanning phase.  */
end_comment

begin_function
specifier|static
name|void
name|scan_dump
parameter_list|(
name|struct
name|sra_elt
modifier|*
name|elt
parameter_list|)
block|{
name|struct
name|sra_elt
modifier|*
name|c
decl_stmt|;
name|dump_sra_elt_name
argument_list|(
name|dump_file
argument_list|,
name|elt
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|": n_uses=%u n_copies=%u\n"
argument_list|,
name|elt
operator|->
name|n_uses
argument_list|,
name|elt
operator|->
name|n_copies
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
name|elt
operator|->
name|children
init|;
name|c
condition|;
name|c
operator|=
name|c
operator|->
name|sibling
control|)
name|scan_dump
argument_list|(
name|c
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
name|elt
operator|->
name|groups
init|;
name|c
condition|;
name|c
operator|=
name|c
operator|->
name|sibling
control|)
name|scan_dump
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Entry point to phase 2.  Scan the entire function, building up    scalarization data structures, recording copies and uses.  */
end_comment

begin_function
specifier|static
name|void
name|scan_function
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
specifier|const
name|struct
name|sra_walk_fns
name|fns
init|=
block|{
name|scan_use
block|,
name|scan_copy
block|,
name|scan_init
block|,
name|scan_ldst
block|,
name|true
block|}
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
name|sra_walk_function
argument_list|(
operator|&
name|fns
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|unsigned
name|i
decl_stmt|;
name|fputs
argument_list|(
literal|"\nScan results:\n"
argument_list|,
name|dump_file
argument_list|)
expr_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|sra_candidates
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|bi
argument_list|)
block|{
name|tree
name|var
init|=
name|referenced_var
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|struct
name|sra_elt
modifier|*
name|elt
init|=
name|lookup_element
argument_list|(
name|NULL
argument_list|,
name|var
argument_list|,
name|NULL
argument_list|,
name|NO_INSERT
argument_list|)
decl_stmt|;
if|if
condition|(
name|elt
condition|)
name|scan_dump
argument_list|(
name|elt
argument_list|)
expr_stmt|;
block|}
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|dump_file
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Phase Three: Make decisions about which variables to scalarize, if any.    All elements to be scalarized have replacement variables made for them.  */
end_comment

begin_comment
comment|/* A subroutine of build_element_name.  Recursively build the element    name on the obstack.  */
end_comment

begin_function
specifier|static
name|void
name|build_element_name_1
parameter_list|(
name|struct
name|sra_elt
modifier|*
name|elt
parameter_list|)
block|{
name|tree
name|t
decl_stmt|;
name|char
name|buffer
index|[
literal|32
index|]
decl_stmt|;
if|if
condition|(
name|elt
operator|->
name|parent
condition|)
block|{
name|build_element_name_1
argument_list|(
name|elt
operator|->
name|parent
argument_list|)
expr_stmt|;
name|obstack_1grow
argument_list|(
operator|&
name|sra_obstack
argument_list|,
literal|'$'
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|elt
operator|->
name|parent
operator|->
name|type
argument_list|)
operator|==
name|COMPLEX_TYPE
condition|)
block|{
if|if
condition|(
name|elt
operator|->
name|element
operator|==
name|integer_zero_node
condition|)
name|obstack_grow
argument_list|(
operator|&
name|sra_obstack
argument_list|,
literal|"real"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
else|else
name|obstack_grow
argument_list|(
operator|&
name|sra_obstack
argument_list|,
literal|"imag"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|t
operator|=
name|elt
operator|->
name|element
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
comment|/* ??? Eh.  Don't bother doing double-wide printing.  */
name|sprintf
argument_list|(
name|buffer
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|sra_obstack
argument_list|,
name|buffer
argument_list|,
name|strlen
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tree
name|name
init|=
name|DECL_NAME
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|name
condition|)
name|obstack_grow
argument_list|(
operator|&
name|sra_obstack
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|,
name|IDENTIFIER_LENGTH
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"D%u"
argument_list|,
name|DECL_UID
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|sra_obstack
argument_list|,
name|buffer
argument_list|,
name|strlen
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Construct a pretty variable name for an element's replacement variable.    The name is built on the obstack.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|build_element_name
parameter_list|(
name|struct
name|sra_elt
modifier|*
name|elt
parameter_list|)
block|{
name|build_element_name_1
argument_list|(
name|elt
argument_list|)
expr_stmt|;
name|obstack_1grow
argument_list|(
operator|&
name|sra_obstack
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
return|return
name|XOBFINISH
argument_list|(
operator|&
name|sra_obstack
argument_list|,
name|char
operator|*
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Instantiate an element as an independent variable.  */
end_comment

begin_function
specifier|static
name|void
name|instantiate_element
parameter_list|(
name|struct
name|sra_elt
modifier|*
name|elt
parameter_list|)
block|{
name|struct
name|sra_elt
modifier|*
name|base_elt
decl_stmt|;
name|tree
name|var
decl_stmt|,
name|base
decl_stmt|;
for|for
control|(
name|base_elt
operator|=
name|elt
init|;
name|base_elt
operator|->
name|parent
condition|;
name|base_elt
operator|=
name|base_elt
operator|->
name|parent
control|)
continue|continue;
name|base
operator|=
name|base_elt
operator|->
name|element
expr_stmt|;
name|elt
operator|->
name|replacement
operator|=
name|var
operator|=
name|make_rename_temp
argument_list|(
name|elt
operator|->
name|type
argument_list|,
literal|"SR"
argument_list|)
expr_stmt|;
name|DECL_SOURCE_LOCATION
argument_list|(
name|var
argument_list|)
operator|=
name|DECL_SOURCE_LOCATION
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|var
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_THIS_VOLATILE
argument_list|(
name|elt
operator|->
name|type
argument_list|)
condition|)
block|{
name|TREE_THIS_VOLATILE
argument_list|(
name|var
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|var
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|DECL_NAME
argument_list|(
name|base
argument_list|)
operator|&&
operator|!
name|DECL_IGNORED_P
argument_list|(
name|base
argument_list|)
condition|)
block|{
name|char
modifier|*
name|pretty_name
init|=
name|build_element_name
argument_list|(
name|elt
argument_list|)
decl_stmt|;
name|DECL_NAME
argument_list|(
name|var
argument_list|)
operator|=
name|get_identifier
argument_list|(
name|pretty_name
argument_list|)
expr_stmt|;
name|obstack_free
argument_list|(
operator|&
name|sra_obstack
argument_list|,
name|pretty_name
argument_list|)
expr_stmt|;
name|SET_DECL_DEBUG_EXPR
argument_list|(
name|var
argument_list|,
name|generate_element_ref
argument_list|(
name|elt
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_DEBUG_EXPR_IS_FROM
argument_list|(
name|var
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_IGNORED_P
argument_list|(
name|var
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TREE_NO_WARNING
argument_list|(
name|var
argument_list|)
operator|=
name|TREE_NO_WARNING
argument_list|(
name|base
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DECL_IGNORED_P
argument_list|(
name|var
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* ??? We can't generate any warning that would be meaningful.  */
name|TREE_NO_WARNING
argument_list|(
name|var
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|dump_file
condition|)
block|{
name|fputs
argument_list|(
literal|"  "
argument_list|,
name|dump_file
argument_list|)
expr_stmt|;
name|dump_sra_elt_name
argument_list|(
name|dump_file
argument_list|,
name|elt
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|" -> "
argument_list|,
name|dump_file
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|var
argument_list|,
name|dump_flags
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|dump_file
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Make one pass across an element tree deciding whether or not it's    profitable to instantiate individual leaf scalars.     PARENT_USES and PARENT_COPIES are the sum of the N_USES and N_COPIES    fields all the way up the tree.  */
end_comment

begin_function
specifier|static
name|void
name|decide_instantiation_1
parameter_list|(
name|struct
name|sra_elt
modifier|*
name|elt
parameter_list|,
name|unsigned
name|int
name|parent_uses
parameter_list|,
name|unsigned
name|int
name|parent_copies
parameter_list|)
block|{
if|if
condition|(
name|dump_file
operator|&&
operator|!
name|elt
operator|->
name|parent
condition|)
block|{
name|fputs
argument_list|(
literal|"Initial instantiation for "
argument_list|,
name|dump_file
argument_list|)
expr_stmt|;
name|dump_sra_elt_name
argument_list|(
name|dump_file
argument_list|,
name|elt
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|dump_file
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|elt
operator|->
name|cannot_scalarize
condition|)
return|return;
if|if
condition|(
name|elt
operator|->
name|is_scalar
condition|)
block|{
comment|/* The decision is simple: instantiate if we're used more frequently 	 than the parent needs to be seen as a complete unit.  */
if|if
condition|(
name|elt
operator|->
name|n_uses
operator|+
name|elt
operator|->
name|n_copies
operator|+
name|parent_copies
operator|>
name|parent_uses
condition|)
name|instantiate_element
argument_list|(
name|elt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|sra_elt
modifier|*
name|c
decl_stmt|,
modifier|*
name|group
decl_stmt|;
name|unsigned
name|int
name|this_uses
init|=
name|elt
operator|->
name|n_uses
operator|+
name|parent_uses
decl_stmt|;
name|unsigned
name|int
name|this_copies
init|=
name|elt
operator|->
name|n_copies
operator|+
name|parent_copies
decl_stmt|;
comment|/* Consider groups of sub-elements as weighing in favour of 	 instantiation whatever their size.  */
for|for
control|(
name|group
operator|=
name|elt
operator|->
name|groups
init|;
name|group
condition|;
name|group
operator|=
name|group
operator|->
name|sibling
control|)
name|FOR_EACH_ACTUAL_CHILD
argument_list|(
argument|c
argument_list|,
argument|group
argument_list|)
block|{
name|c
operator|->
name|n_uses
operator|+=
name|group
operator|->
name|n_uses
expr_stmt|;
name|c
operator|->
name|n_copies
operator|+=
name|group
operator|->
name|n_copies
expr_stmt|;
block|}
for|for
control|(
name|c
operator|=
name|elt
operator|->
name|children
init|;
name|c
condition|;
name|c
operator|=
name|c
operator|->
name|sibling
control|)
name|decide_instantiation_1
argument_list|(
name|c
argument_list|,
name|this_uses
argument_list|,
name|this_copies
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Compute the size and number of all instantiated elements below ELT.    We will only care about this if the size of the complete structure    fits in a HOST_WIDE_INT, so we don't have to worry about overflow.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|sum_instantiated_sizes
parameter_list|(
name|struct
name|sra_elt
modifier|*
name|elt
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
modifier|*
name|sizep
parameter_list|)
block|{
if|if
condition|(
name|elt
operator|->
name|replacement
condition|)
block|{
operator|*
name|sizep
operator|+=
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE_UNIT
argument_list|(
name|elt
operator|->
name|type
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
block|{
name|struct
name|sra_elt
modifier|*
name|c
decl_stmt|;
name|unsigned
name|int
name|count
init|=
literal|0
decl_stmt|;
for|for
control|(
name|c
operator|=
name|elt
operator|->
name|children
init|;
name|c
condition|;
name|c
operator|=
name|c
operator|->
name|sibling
control|)
name|count
operator|+=
name|sum_instantiated_sizes
argument_list|(
name|c
argument_list|,
name|sizep
argument_list|)
expr_stmt|;
return|return
name|count
return|;
block|}
block|}
end_function

begin_comment
comment|/* Instantiate fields in ELT->TYPE that are not currently present as    children of ELT.  */
end_comment

begin_function_decl
specifier|static
name|void
name|instantiate_missing_elements
parameter_list|(
name|struct
name|sra_elt
modifier|*
name|elt
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|instantiate_missing_elements_1
parameter_list|(
name|struct
name|sra_elt
modifier|*
name|elt
parameter_list|,
name|tree
name|child
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
name|struct
name|sra_elt
modifier|*
name|sub
init|=
name|lookup_element
argument_list|(
name|elt
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|INSERT
argument_list|)
decl_stmt|;
if|if
condition|(
name|sub
operator|->
name|is_scalar
condition|)
block|{
if|if
condition|(
name|sub
operator|->
name|replacement
operator|==
name|NULL
condition|)
name|instantiate_element
argument_list|(
name|sub
argument_list|)
expr_stmt|;
block|}
else|else
name|instantiate_missing_elements
argument_list|(
name|sub
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|instantiate_missing_elements
parameter_list|(
name|struct
name|sra_elt
modifier|*
name|elt
parameter_list|)
block|{
name|tree
name|type
init|=
name|elt
operator|->
name|type
decl_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|RECORD_TYPE
case|:
block|{
name|tree
name|f
decl_stmt|;
for|for
control|(
name|f
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|f
condition|;
name|f
operator|=
name|TREE_CHAIN
argument_list|(
name|f
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|f
argument_list|)
operator|==
name|FIELD_DECL
condition|)
block|{
name|tree
name|field_type
init|=
name|TREE_TYPE
argument_list|(
name|f
argument_list|)
decl_stmt|;
comment|/* canonicalize_component_ref() unwidens some bit-field 		 types (not marked as DECL_BIT_FIELD in C++), so we 		 must do the same, lest we may introduce type 		 mismatches.  */
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|field_type
argument_list|)
operator|&&
name|DECL_MODE
argument_list|(
name|f
argument_list|)
operator|!=
name|TYPE_MODE
argument_list|(
name|field_type
argument_list|)
condition|)
name|field_type
operator|=
name|TREE_TYPE
argument_list|(
name|get_unwidened
argument_list|(
name|build3
argument_list|(
name|COMPONENT_REF
argument_list|,
name|field_type
argument_list|,
name|elt
operator|->
name|element
argument_list|,
name|f
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
expr_stmt|;
name|instantiate_missing_elements_1
argument_list|(
name|elt
argument_list|,
name|f
argument_list|,
name|field_type
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|ARRAY_TYPE
case|:
block|{
name|tree
name|i
decl_stmt|,
name|max
decl_stmt|,
name|subtype
decl_stmt|;
name|i
operator|=
name|TYPE_MIN_VALUE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|max
operator|=
name|TYPE_MAX_VALUE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|subtype
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|instantiate_missing_elements_1
argument_list|(
name|elt
argument_list|,
name|i
argument_list|,
name|subtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|tree_int_cst_equal
argument_list|(
name|i
argument_list|,
name|max
argument_list|)
condition|)
break|break;
name|i
operator|=
name|int_const_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|i
argument_list|,
name|integer_one_node
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|COMPLEX_TYPE
case|:
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|instantiate_missing_elements_1
argument_list|(
name|elt
argument_list|,
name|integer_zero_node
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|instantiate_missing_elements_1
argument_list|(
name|elt
argument_list|,
name|integer_one_node
argument_list|,
name|type
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Make one pass across an element tree deciding whether to perform block    or element copies.  If we decide on element copies, instantiate all    elements.  Return true if there are any instantiated sub-elements.  */
end_comment

begin_function
specifier|static
name|bool
name|decide_block_copy
parameter_list|(
name|struct
name|sra_elt
modifier|*
name|elt
parameter_list|)
block|{
name|struct
name|sra_elt
modifier|*
name|c
decl_stmt|;
name|bool
name|any_inst
decl_stmt|;
comment|/* We shouldn't be invoked on groups of sub-elements as they must      behave like their parent as far as block copy is concerned.  */
name|gcc_assert
argument_list|(
operator|!
name|elt
operator|->
name|is_group
argument_list|)
expr_stmt|;
comment|/* If scalarization is disabled, respect it.  */
if|if
condition|(
name|elt
operator|->
name|cannot_scalarize
condition|)
block|{
name|elt
operator|->
name|use_block_copy
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
block|{
name|fputs
argument_list|(
literal|"Scalarization disabled for "
argument_list|,
name|dump_file
argument_list|)
expr_stmt|;
name|dump_sra_elt_name
argument_list|(
name|dump_file
argument_list|,
name|elt
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|dump_file
argument_list|)
expr_stmt|;
block|}
comment|/* Disable scalarization of sub-elements */
for|for
control|(
name|c
operator|=
name|elt
operator|->
name|children
init|;
name|c
condition|;
name|c
operator|=
name|c
operator|->
name|sibling
control|)
block|{
name|c
operator|->
name|cannot_scalarize
operator|=
literal|1
expr_stmt|;
name|decide_block_copy
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
comment|/* Groups behave like their parent.  */
for|for
control|(
name|c
operator|=
name|elt
operator|->
name|groups
init|;
name|c
condition|;
name|c
operator|=
name|c
operator|->
name|sibling
control|)
block|{
name|c
operator|->
name|cannot_scalarize
operator|=
literal|1
expr_stmt|;
name|c
operator|->
name|use_block_copy
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|false
return|;
block|}
comment|/* Don't decide if we've no uses.  */
if|if
condition|(
name|elt
operator|->
name|n_uses
operator|==
literal|0
operator|&&
name|elt
operator|->
name|n_copies
operator|==
literal|0
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
operator|!
name|elt
operator|->
name|is_scalar
condition|)
block|{
name|tree
name|size_tree
init|=
name|TYPE_SIZE_UNIT
argument_list|(
name|elt
operator|->
name|type
argument_list|)
decl_stmt|;
name|bool
name|use_block_copy
init|=
name|true
decl_stmt|;
comment|/* Tradeoffs for COMPLEX types pretty much always make it better 	 to go ahead and split the components.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|elt
operator|->
name|type
argument_list|)
operator|==
name|COMPLEX_TYPE
condition|)
name|use_block_copy
operator|=
name|false
expr_stmt|;
comment|/* Don't bother trying to figure out the rest if the structure is 	 so large we can't do easy arithmetic.  This also forces block 	 copies for variable sized structures.  */
elseif|else
if|if
condition|(
name|host_integerp
argument_list|(
name|size_tree
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|full_size
decl_stmt|,
name|inst_size
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|max_size
decl_stmt|,
name|max_count
decl_stmt|,
name|inst_count
decl_stmt|,
name|full_count
decl_stmt|;
comment|/* If the sra-max-structure-size parameter is 0, then the 	     user has not overridden the parameter and we can choose a 	     sensible default.  */
name|max_size
operator|=
name|SRA_MAX_STRUCTURE_SIZE
condition|?
name|SRA_MAX_STRUCTURE_SIZE
else|:
name|MOVE_RATIO
operator|*
name|UNITS_PER_WORD
expr_stmt|;
name|max_count
operator|=
name|SRA_MAX_STRUCTURE_COUNT
condition|?
name|SRA_MAX_STRUCTURE_COUNT
else|:
name|MOVE_RATIO
expr_stmt|;
name|full_size
operator|=
name|tree_low_cst
argument_list|(
name|size_tree
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|full_count
operator|=
name|count_type_elements
argument_list|(
name|elt
operator|->
name|type
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|inst_count
operator|=
name|sum_instantiated_sizes
argument_list|(
name|elt
argument_list|,
operator|&
name|inst_size
argument_list|)
expr_stmt|;
comment|/* ??? What to do here.  If there are two fields, and we've only 	     instantiated one, then instantiating the other is clearly a win. 	     If there are a large number of fields then the size of the copy 	     is much more of a factor.  */
comment|/* If the structure is small, and we've made copies, go ahead 	     and instantiate, hoping that the copies will go away.  */
if|if
condition|(
name|full_size
operator|<=
name|max_size
operator|&&
operator|(
name|full_count
operator|-
name|inst_count
operator|)
operator|<=
name|max_count
operator|&&
name|elt
operator|->
name|n_copies
operator|>
name|elt
operator|->
name|n_uses
condition|)
name|use_block_copy
operator|=
name|false
expr_stmt|;
elseif|else
if|if
condition|(
name|inst_count
operator|*
literal|100
operator|>=
name|full_count
operator|*
name|SRA_FIELD_STRUCTURE_RATIO
operator|&&
name|inst_size
operator|*
literal|100
operator|>=
name|full_size
operator|*
name|SRA_FIELD_STRUCTURE_RATIO
condition|)
name|use_block_copy
operator|=
name|false
expr_stmt|;
comment|/* In order to avoid block copy, we have to be able to instantiate 	     all elements of the type.  See if this is possible.  */
if|if
condition|(
operator|!
name|use_block_copy
operator|&&
operator|(
operator|!
name|can_completely_scalarize_p
argument_list|(
name|elt
argument_list|)
operator|||
operator|!
name|type_can_instantiate_all_elements
argument_list|(
name|elt
operator|->
name|type
argument_list|)
operator|)
condition|)
name|use_block_copy
operator|=
name|true
expr_stmt|;
block|}
name|elt
operator|->
name|use_block_copy
operator|=
name|use_block_copy
expr_stmt|;
comment|/* Groups behave like their parent.  */
for|for
control|(
name|c
operator|=
name|elt
operator|->
name|groups
init|;
name|c
condition|;
name|c
operator|=
name|c
operator|->
name|sibling
control|)
name|c
operator|->
name|use_block_copy
operator|=
name|use_block_copy
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Using %s for "
argument_list|,
name|use_block_copy
condition|?
literal|"block-copy"
else|:
literal|"element-copy"
argument_list|)
expr_stmt|;
name|dump_sra_elt_name
argument_list|(
name|dump_file
argument_list|,
name|elt
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|dump_file
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|use_block_copy
condition|)
block|{
name|instantiate_missing_elements
argument_list|(
name|elt
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
block|}
name|any_inst
operator|=
name|elt
operator|->
name|replacement
operator|!=
name|NULL
expr_stmt|;
for|for
control|(
name|c
operator|=
name|elt
operator|->
name|children
init|;
name|c
condition|;
name|c
operator|=
name|c
operator|->
name|sibling
control|)
name|any_inst
operator||=
name|decide_block_copy
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
name|any_inst
return|;
block|}
end_function

begin_comment
comment|/* Entry point to phase 3.  Instantiate scalar replacement variables.  */
end_comment

begin_function
specifier|static
name|void
name|decide_instantiations
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|bool
name|cleared_any
decl_stmt|;
name|bitmap_head
name|done_head
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
comment|/* We cannot clear bits from a bitmap we're iterating over,      so save up all the bits to clear until the end.  */
name|bitmap_initialize
argument_list|(
operator|&
name|done_head
argument_list|,
operator|&
name|bitmap_default_obstack
argument_list|)
expr_stmt|;
name|cleared_any
operator|=
name|false
expr_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|sra_candidates
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|bi
argument_list|)
block|{
name|tree
name|var
init|=
name|referenced_var
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|struct
name|sra_elt
modifier|*
name|elt
init|=
name|lookup_element
argument_list|(
name|NULL
argument_list|,
name|var
argument_list|,
name|NULL
argument_list|,
name|NO_INSERT
argument_list|)
decl_stmt|;
if|if
condition|(
name|elt
condition|)
block|{
name|decide_instantiation_1
argument_list|(
name|elt
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|decide_block_copy
argument_list|(
name|elt
argument_list|)
condition|)
name|elt
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|elt
condition|)
block|{
name|bitmap_set_bit
argument_list|(
operator|&
name|done_head
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|cleared_any
operator|=
name|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cleared_any
condition|)
block|{
name|bitmap_and_compl_into
argument_list|(
name|sra_candidates
argument_list|,
operator|&
name|done_head
argument_list|)
expr_stmt|;
name|bitmap_and_compl_into
argument_list|(
name|needs_copy_in
argument_list|,
operator|&
name|done_head
argument_list|)
expr_stmt|;
block|}
name|bitmap_clear
argument_list|(
operator|&
name|done_head
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bitmap_empty_p
argument_list|(
name|sra_candidates
argument_list|)
condition|)
name|todoflags
operator||=
name|TODO_update_smt_usage
expr_stmt|;
name|mark_set_for_renaming
argument_list|(
name|sra_candidates
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|dump_file
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Phase Four: Update the function to match the replacements created.  */
end_comment

begin_comment
comment|/* Mark all the variables in V_MAY_DEF or V_MUST_DEF operands for STMT for    renaming. This becomes necessary when we modify all of a non-scalar.  */
end_comment

begin_function
specifier|static
name|void
name|mark_all_v_defs_1
parameter_list|(
name|tree
name|stmt
parameter_list|)
block|{
name|tree
name|sym
decl_stmt|;
name|ssa_op_iter
name|iter
decl_stmt|;
name|update_stmt_if_modified
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|FOR_EACH_SSA_TREE_OPERAND
argument_list|(
argument|sym
argument_list|,
argument|stmt
argument_list|,
argument|iter
argument_list|,
argument|SSA_OP_ALL_VIRTUALS
argument_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|sym
argument_list|)
operator|==
name|SSA_NAME
condition|)
name|sym
operator|=
name|SSA_NAME_VAR
argument_list|(
name|sym
argument_list|)
expr_stmt|;
name|mark_sym_for_renaming
argument_list|(
name|sym
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Mark all the variables in virtual operands in all the statements in    LIST for renaming.  */
end_comment

begin_function
specifier|static
name|void
name|mark_all_v_defs
parameter_list|(
name|tree
name|list
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|list
argument_list|)
operator|!=
name|STATEMENT_LIST
condition|)
name|mark_all_v_defs_1
argument_list|(
name|list
argument_list|)
expr_stmt|;
else|else
block|{
name|tree_stmt_iterator
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|tsi_start
argument_list|(
name|list
argument_list|)
init|;
operator|!
name|tsi_end_p
argument_list|(
name|i
argument_list|)
condition|;
name|tsi_next
argument_list|(
operator|&
name|i
argument_list|)
control|)
name|mark_all_v_defs_1
argument_list|(
name|tsi_stmt
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Mark every replacement under ELT with TREE_NO_WARNING.  */
end_comment

begin_function
specifier|static
name|void
name|mark_no_warning
parameter_list|(
name|struct
name|sra_elt
modifier|*
name|elt
parameter_list|)
block|{
if|if
condition|(
operator|!
name|elt
operator|->
name|all_no_warning
condition|)
block|{
if|if
condition|(
name|elt
operator|->
name|replacement
condition|)
name|TREE_NO_WARNING
argument_list|(
name|elt
operator|->
name|replacement
argument_list|)
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|struct
name|sra_elt
modifier|*
name|c
decl_stmt|;
name|FOR_EACH_ACTUAL_CHILD
argument_list|(
argument|c
argument_list|,
argument|elt
argument_list|)
name|mark_no_warning
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
name|elt
operator|->
name|all_no_warning
operator|=
name|true
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Build a single level component reference to ELT rooted at BASE.  */
end_comment

begin_function
specifier|static
name|tree
name|generate_one_element_ref
parameter_list|(
name|struct
name|sra_elt
modifier|*
name|elt
parameter_list|,
name|tree
name|base
parameter_list|)
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|base
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|RECORD_TYPE
case|:
block|{
name|tree
name|field
init|=
name|elt
operator|->
name|element
decl_stmt|;
comment|/* Watch out for compatible records with differing field lists.  */
if|if
condition|(
name|DECL_FIELD_CONTEXT
argument_list|(
name|field
argument_list|)
operator|!=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|base
argument_list|)
argument_list|)
condition|)
name|field
operator|=
name|find_compatible_field
argument_list|(
name|TREE_TYPE
argument_list|(
name|base
argument_list|)
argument_list|,
name|field
argument_list|)
expr_stmt|;
return|return
name|build3
argument_list|(
name|COMPONENT_REF
argument_list|,
name|elt
operator|->
name|type
argument_list|,
name|base
argument_list|,
name|field
argument_list|,
name|NULL
argument_list|)
return|;
block|}
case|case
name|ARRAY_TYPE
case|:
name|todoflags
operator||=
name|TODO_update_smt_usage
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|elt
operator|->
name|element
argument_list|)
operator|==
name|RANGE_EXPR
condition|)
return|return
name|build4
argument_list|(
name|ARRAY_RANGE_REF
argument_list|,
name|elt
operator|->
name|type
argument_list|,
name|base
argument_list|,
name|TREE_OPERAND
argument_list|(
name|elt
operator|->
name|element
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
else|else
return|return
name|build4
argument_list|(
name|ARRAY_REF
argument_list|,
name|elt
operator|->
name|type
argument_list|,
name|base
argument_list|,
name|elt
operator|->
name|element
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
case|case
name|COMPLEX_TYPE
case|:
if|if
condition|(
name|elt
operator|->
name|element
operator|==
name|integer_zero_node
condition|)
return|return
name|build1
argument_list|(
name|REALPART_EXPR
argument_list|,
name|elt
operator|->
name|type
argument_list|,
name|base
argument_list|)
return|;
else|else
return|return
name|build1
argument_list|(
name|IMAGPART_EXPR
argument_list|,
name|elt
operator|->
name|type
argument_list|,
name|base
argument_list|)
return|;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Build a full component reference to ELT rooted at its native variable.  */
end_comment

begin_function
specifier|static
name|tree
name|generate_element_ref
parameter_list|(
name|struct
name|sra_elt
modifier|*
name|elt
parameter_list|)
block|{
if|if
condition|(
name|elt
operator|->
name|parent
condition|)
return|return
name|generate_one_element_ref
argument_list|(
name|elt
argument_list|,
name|generate_element_ref
argument_list|(
name|elt
operator|->
name|parent
argument_list|)
argument_list|)
return|;
else|else
return|return
name|elt
operator|->
name|element
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|sra_build_assignment
parameter_list|(
name|tree
name|dst
parameter_list|,
name|tree
name|src
parameter_list|)
block|{
comment|/* We need TYPE_CANONICAL to compare the types of dst and src      efficiently, but that's only introduced in GCC 4.3.  */
return|return
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|dst
argument_list|,
name|src
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Generate a set of assignment statements in *LIST_P to copy all    instantiated elements under ELT to or from the equivalent structure    rooted at EXPR.  COPY_OUT controls the direction of the copy, with    true meaning to copy out of EXPR into ELT.  */
end_comment

begin_function
specifier|static
name|void
name|generate_copy_inout
parameter_list|(
name|struct
name|sra_elt
modifier|*
name|elt
parameter_list|,
name|bool
name|copy_out
parameter_list|,
name|tree
name|expr
parameter_list|,
name|tree
modifier|*
name|list_p
parameter_list|)
block|{
name|struct
name|sra_elt
modifier|*
name|c
decl_stmt|;
name|tree
name|t
decl_stmt|;
if|if
condition|(
operator|!
name|copy_out
operator|&&
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|SSA_NAME
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|COMPLEX_TYPE
condition|)
block|{
name|tree
name|r
decl_stmt|,
name|i
decl_stmt|;
name|c
operator|=
name|lookup_element
argument_list|(
name|elt
argument_list|,
name|integer_zero_node
argument_list|,
name|NULL
argument_list|,
name|NO_INSERT
argument_list|)
expr_stmt|;
name|r
operator|=
name|c
operator|->
name|replacement
expr_stmt|;
name|c
operator|=
name|lookup_element
argument_list|(
name|elt
argument_list|,
name|integer_one_node
argument_list|,
name|NULL
argument_list|,
name|NO_INSERT
argument_list|)
expr_stmt|;
name|i
operator|=
name|c
operator|->
name|replacement
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|COMPLEX_EXPR
argument_list|,
name|elt
operator|->
name|type
argument_list|,
name|r
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|t
operator|=
name|sra_build_assignment
argument_list|(
name|expr
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|SSA_NAME_DEF_STMT
argument_list|(
name|expr
argument_list|)
operator|=
name|t
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|t
argument_list|,
name|list_p
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|elt
operator|->
name|replacement
condition|)
block|{
if|if
condition|(
name|copy_out
condition|)
name|t
operator|=
name|sra_build_assignment
argument_list|(
name|elt
operator|->
name|replacement
argument_list|,
name|expr
argument_list|)
expr_stmt|;
else|else
name|t
operator|=
name|sra_build_assignment
argument_list|(
name|expr
argument_list|,
name|elt
operator|->
name|replacement
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|t
argument_list|,
name|list_p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|FOR_EACH_ACTUAL_CHILD
argument_list|(
argument|c
argument_list|,
argument|elt
argument_list|)
block|{
name|t
operator|=
name|generate_one_element_ref
argument_list|(
name|c
argument_list|,
name|unshare_expr
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
name|generate_copy_inout
argument_list|(
name|c
argument_list|,
name|copy_out
argument_list|,
name|t
argument_list|,
name|list_p
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Generate a set of assignment statements in *LIST_P to copy all instantiated    elements under SRC to their counterparts under DST.  There must be a 1-1    correspondence of instantiated elements.  */
end_comment

begin_function
specifier|static
name|void
name|generate_element_copy
parameter_list|(
name|struct
name|sra_elt
modifier|*
name|dst
parameter_list|,
name|struct
name|sra_elt
modifier|*
name|src
parameter_list|,
name|tree
modifier|*
name|list_p
parameter_list|)
block|{
name|struct
name|sra_elt
modifier|*
name|dc
decl_stmt|,
modifier|*
name|sc
decl_stmt|;
name|FOR_EACH_ACTUAL_CHILD
argument_list|(
argument|dc
argument_list|,
argument|dst
argument_list|)
block|{
name|sc
operator|=
name|lookup_element
argument_list|(
name|src
argument_list|,
name|dc
operator|->
name|element
argument_list|,
name|NULL
argument_list|,
name|NO_INSERT
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|generate_element_copy
argument_list|(
name|dc
argument_list|,
name|sc
argument_list|,
name|list_p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dst
operator|->
name|replacement
condition|)
block|{
name|tree
name|t
decl_stmt|;
name|gcc_assert
argument_list|(
name|src
operator|->
name|replacement
argument_list|)
expr_stmt|;
name|t
operator|=
name|sra_build_assignment
argument_list|(
name|dst
operator|->
name|replacement
argument_list|,
name|src
operator|->
name|replacement
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|t
argument_list|,
name|list_p
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Generate a set of assignment statements in *LIST_P to zero all instantiated    elements under ELT.  In addition, do not assign to elements that have been    marked VISITED but do reset the visited flag; this allows easy coordination    with generate_element_init.  */
end_comment

begin_function
specifier|static
name|void
name|generate_element_zero
parameter_list|(
name|struct
name|sra_elt
modifier|*
name|elt
parameter_list|,
name|tree
modifier|*
name|list_p
parameter_list|)
block|{
name|struct
name|sra_elt
modifier|*
name|c
decl_stmt|;
if|if
condition|(
name|elt
operator|->
name|visited
condition|)
block|{
name|elt
operator|->
name|visited
operator|=
name|false
expr_stmt|;
return|return;
block|}
name|FOR_EACH_ACTUAL_CHILD
argument_list|(
argument|c
argument_list|,
argument|elt
argument_list|)
name|generate_element_zero
argument_list|(
name|c
argument_list|,
name|list_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|elt
operator|->
name|replacement
condition|)
block|{
name|tree
name|t
decl_stmt|;
name|gcc_assert
argument_list|(
name|elt
operator|->
name|is_scalar
argument_list|)
expr_stmt|;
name|t
operator|=
name|fold_convert
argument_list|(
name|elt
operator|->
name|type
argument_list|,
name|integer_zero_node
argument_list|)
expr_stmt|;
name|t
operator|=
name|sra_build_assignment
argument_list|(
name|elt
operator|->
name|replacement
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|t
argument_list|,
name|list_p
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Generate an assignment VAR = INIT, where INIT may need gimplification.    Add the result to *LIST_P.  */
end_comment

begin_function
specifier|static
name|void
name|generate_one_element_init
parameter_list|(
name|tree
name|var
parameter_list|,
name|tree
name|init
parameter_list|,
name|tree
modifier|*
name|list_p
parameter_list|)
block|{
comment|/* The replacement can be almost arbitrarily complex.  Gimplify.  */
name|tree
name|stmt
init|=
name|sra_build_assignment
argument_list|(
name|var
argument_list|,
name|init
argument_list|)
decl_stmt|;
name|gimplify_and_add
argument_list|(
name|stmt
argument_list|,
name|list_p
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate a set of assignment statements in *LIST_P to set all instantiated    elements under ELT with the contents of the initializer INIT.  In addition,    mark all assigned elements VISITED; this allows easy coordination with    generate_element_zero.  Return false if we found a case we couldn't    handle.  */
end_comment

begin_function
specifier|static
name|bool
name|generate_element_init_1
parameter_list|(
name|struct
name|sra_elt
modifier|*
name|elt
parameter_list|,
name|tree
name|init
parameter_list|,
name|tree
modifier|*
name|list_p
parameter_list|)
block|{
name|bool
name|result
init|=
name|true
decl_stmt|;
name|enum
name|tree_code
name|init_code
decl_stmt|;
name|struct
name|sra_elt
modifier|*
name|sub
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|idx
decl_stmt|;
name|tree
name|value
decl_stmt|,
name|purpose
decl_stmt|;
comment|/* We can be passed DECL_INITIAL of a static variable.  It might have a      conversion, which we strip off here.  */
name|STRIP_USELESS_TYPE_CONVERSION
argument_list|(
name|init
argument_list|)
expr_stmt|;
name|init_code
operator|=
name|TREE_CODE
argument_list|(
name|init
argument_list|)
expr_stmt|;
if|if
condition|(
name|elt
operator|->
name|is_scalar
condition|)
block|{
if|if
condition|(
name|elt
operator|->
name|replacement
condition|)
block|{
name|generate_one_element_init
argument_list|(
name|elt
operator|->
name|replacement
argument_list|,
name|init
argument_list|,
name|list_p
argument_list|)
expr_stmt|;
name|elt
operator|->
name|visited
operator|=
name|true
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
switch|switch
condition|(
name|init_code
condition|)
block|{
case|case
name|COMPLEX_CST
case|:
case|case
name|COMPLEX_EXPR
case|:
name|FOR_EACH_ACTUAL_CHILD
argument_list|(
argument|sub
argument_list|,
argument|elt
argument_list|)
block|{
if|if
condition|(
name|sub
operator|->
name|element
operator|==
name|integer_zero_node
condition|)
name|t
operator|=
operator|(
name|init_code
operator|==
name|COMPLEX_EXPR
condition|?
name|TREE_OPERAND
argument_list|(
name|init
argument_list|,
literal|0
argument_list|)
else|:
name|TREE_REALPART
argument_list|(
name|init
argument_list|)
operator|)
expr_stmt|;
else|else
name|t
operator|=
operator|(
name|init_code
operator|==
name|COMPLEX_EXPR
condition|?
name|TREE_OPERAND
argument_list|(
name|init
argument_list|,
literal|1
argument_list|)
else|:
name|TREE_IMAGPART
argument_list|(
name|init
argument_list|)
operator|)
expr_stmt|;
name|result
operator|&=
name|generate_element_init_1
argument_list|(
name|sub
argument_list|,
name|t
argument_list|,
name|list_p
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CONSTRUCTOR
case|:
name|FOR_EACH_CONSTRUCTOR_ELT
argument_list|(
argument|CONSTRUCTOR_ELTS (init)
argument_list|,
argument|idx
argument_list|,
argument|purpose
argument_list|,
argument|value
argument_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|purpose
argument_list|)
operator|==
name|RANGE_EXPR
condition|)
block|{
name|tree
name|lower
init|=
name|TREE_OPERAND
argument_list|(
name|purpose
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|upper
init|=
name|TREE_OPERAND
argument_list|(
name|purpose
argument_list|,
literal|1
argument_list|)
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|sub
operator|=
name|lookup_element
argument_list|(
name|elt
argument_list|,
name|lower
argument_list|,
name|NULL
argument_list|,
name|NO_INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
name|sub
operator|!=
name|NULL
condition|)
name|result
operator|&=
name|generate_element_init_1
argument_list|(
name|sub
argument_list|,
name|value
argument_list|,
name|list_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|tree_int_cst_equal
argument_list|(
name|lower
argument_list|,
name|upper
argument_list|)
condition|)
break|break;
name|lower
operator|=
name|int_const_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|lower
argument_list|,
name|integer_one_node
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|sub
operator|=
name|lookup_element
argument_list|(
name|elt
argument_list|,
name|purpose
argument_list|,
name|NULL
argument_list|,
name|NO_INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
name|sub
operator|!=
name|NULL
condition|)
name|result
operator|&=
name|generate_element_init_1
argument_list|(
name|sub
argument_list|,
name|value
argument_list|,
name|list_p
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
default|default:
name|elt
operator|->
name|visited
operator|=
name|true
expr_stmt|;
name|result
operator|=
name|false
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* A wrapper function for generate_element_init_1 that handles cleanup after    gimplification.  */
end_comment

begin_function
specifier|static
name|bool
name|generate_element_init
parameter_list|(
name|struct
name|sra_elt
modifier|*
name|elt
parameter_list|,
name|tree
name|init
parameter_list|,
name|tree
modifier|*
name|list_p
parameter_list|)
block|{
name|bool
name|ret
decl_stmt|;
name|push_gimplify_context
argument_list|()
expr_stmt|;
name|ret
operator|=
name|generate_element_init_1
argument_list|(
name|elt
argument_list|,
name|init
argument_list|,
name|list_p
argument_list|)
expr_stmt|;
name|pop_gimplify_context
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
comment|/* The replacement can expose previously unreferenced variables.  */
if|if
condition|(
name|ret
operator|&&
operator|*
name|list_p
condition|)
block|{
name|tree_stmt_iterator
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|tsi_start
argument_list|(
operator|*
name|list_p
argument_list|)
init|;
operator|!
name|tsi_end_p
argument_list|(
name|i
argument_list|)
condition|;
name|tsi_next
argument_list|(
operator|&
name|i
argument_list|)
control|)
name|find_new_referenced_vars
argument_list|(
name|tsi_stmt_ptr
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Insert STMT on all the outgoing edges out of BB.  Note that if BB    has more than one edge, STMT will be replicated for each edge.  Also,    abnormal edges will be ignored.  */
end_comment

begin_function
name|void
name|insert_edge_copies
parameter_list|(
name|tree
name|stmt
parameter_list|,
name|basic_block
name|bb
parameter_list|)
block|{
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|bool
name|first_copy
decl_stmt|;
name|first_copy
operator|=
name|true
expr_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
block|{
comment|/* We don't need to insert copies on abnormal edges.  The 	 value of the scalar replacement is not guaranteed to 	 be valid through an abnormal edge.  */
if|if
condition|(
operator|!
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_ABNORMAL
operator|)
condition|)
block|{
if|if
condition|(
name|first_copy
condition|)
block|{
name|bsi_insert_on_edge
argument_list|(
name|e
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
name|first_copy
operator|=
name|false
expr_stmt|;
block|}
else|else
name|bsi_insert_on_edge
argument_list|(
name|e
argument_list|,
name|unsave_expr_now
argument_list|(
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Helper function to insert LIST before BSI, and set up line number info.  */
end_comment

begin_function
name|void
name|sra_insert_before
parameter_list|(
name|block_stmt_iterator
modifier|*
name|bsi
parameter_list|,
name|tree
name|list
parameter_list|)
block|{
name|tree
name|stmt
init|=
name|bsi_stmt
argument_list|(
operator|*
name|bsi
argument_list|)
decl_stmt|;
if|if
condition|(
name|EXPR_HAS_LOCATION
argument_list|(
name|stmt
argument_list|)
condition|)
name|annotate_all_with_locus
argument_list|(
operator|&
name|list
argument_list|,
name|EXPR_LOCATION
argument_list|(
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
name|bsi_insert_before
argument_list|(
name|bsi
argument_list|,
name|list
argument_list|,
name|BSI_SAME_STMT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Similarly, but insert after BSI.  Handles insertion onto edges as well.  */
end_comment

begin_function
name|void
name|sra_insert_after
parameter_list|(
name|block_stmt_iterator
modifier|*
name|bsi
parameter_list|,
name|tree
name|list
parameter_list|)
block|{
name|tree
name|stmt
init|=
name|bsi_stmt
argument_list|(
operator|*
name|bsi
argument_list|)
decl_stmt|;
if|if
condition|(
name|EXPR_HAS_LOCATION
argument_list|(
name|stmt
argument_list|)
condition|)
name|annotate_all_with_locus
argument_list|(
operator|&
name|list
argument_list|,
name|EXPR_LOCATION
argument_list|(
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|stmt_ends_bb_p
argument_list|(
name|stmt
argument_list|)
condition|)
name|insert_edge_copies
argument_list|(
name|list
argument_list|,
name|bsi
operator|->
name|bb
argument_list|)
expr_stmt|;
else|else
name|bsi_insert_after
argument_list|(
name|bsi
argument_list|,
name|list
argument_list|,
name|BSI_SAME_STMT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Similarly, but replace the statement at BSI.  */
end_comment

begin_function
specifier|static
name|void
name|sra_replace
parameter_list|(
name|block_stmt_iterator
modifier|*
name|bsi
parameter_list|,
name|tree
name|list
parameter_list|)
block|{
name|sra_insert_before
argument_list|(
name|bsi
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|bsi_remove
argument_list|(
name|bsi
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|bsi_end_p
argument_list|(
operator|*
name|bsi
argument_list|)
condition|)
operator|*
name|bsi
operator|=
name|bsi_last
argument_list|(
name|bsi
operator|->
name|bb
argument_list|)
expr_stmt|;
else|else
name|bsi_prev
argument_list|(
name|bsi
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Scalarize a USE.  To recap, this is either a simple reference to ELT,    if elt is scalar, or some occurrence of ELT that requires a complete    aggregate.  IS_OUTPUT is true if ELT is being modified.  */
end_comment

begin_function
specifier|static
name|void
name|scalarize_use
parameter_list|(
name|struct
name|sra_elt
modifier|*
name|elt
parameter_list|,
name|tree
modifier|*
name|expr_p
parameter_list|,
name|block_stmt_iterator
modifier|*
name|bsi
parameter_list|,
name|bool
name|is_output
parameter_list|,
name|bool
name|use_all
parameter_list|)
block|{
name|tree
name|list
init|=
name|NULL
decl_stmt|,
name|stmt
init|=
name|bsi_stmt
argument_list|(
operator|*
name|bsi
argument_list|)
decl_stmt|;
if|if
condition|(
name|elt
operator|->
name|replacement
condition|)
block|{
comment|/* If we have a replacement, then updating the reference is as 	 simple as modifying the existing statement in place.  */
if|if
condition|(
name|is_output
condition|)
name|mark_all_v_defs
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
operator|*
name|expr_p
operator|=
name|elt
operator|->
name|replacement
expr_stmt|;
name|update_stmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Otherwise we need some copies.  If ELT is being read, then we want 	 to store all (modified) sub-elements back into the structure before 	 the reference takes place.  If ELT is being written, then we want to 	 load the changed values back into our shadow variables.  */
comment|/* ??? We don't check modified for reads, we just always write all of 	 the values.  We should be able to record the SSA number of the VOP 	 for which the values were last read.  If that number matches the 	 SSA number of the VOP in the current statement, then we needn't 	 emit an assignment.  This would also eliminate double writes when 	 a structure is passed as more than one argument to a function call. 	 This optimization would be most effective if sra_walk_function 	 processed the blocks in dominator order.  */
name|generate_copy_inout
argument_list|(
name|elt
argument_list|,
name|is_output
argument_list|,
name|generate_element_ref
argument_list|(
name|elt
argument_list|)
argument_list|,
operator|&
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
name|list
operator|==
name|NULL
condition|)
return|return;
name|mark_all_v_defs
argument_list|(
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_output
condition|)
name|sra_insert_after
argument_list|(
name|bsi
argument_list|,
name|list
argument_list|)
expr_stmt|;
else|else
block|{
name|sra_insert_before
argument_list|(
name|bsi
argument_list|,
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_all
condition|)
name|mark_no_warning
argument_list|(
name|elt
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Scalarize a COPY.  To recap, this is an assignment statement between    two scalarizable references, LHS_ELT and RHS_ELT.  */
end_comment

begin_function
specifier|static
name|void
name|scalarize_copy
parameter_list|(
name|struct
name|sra_elt
modifier|*
name|lhs_elt
parameter_list|,
name|struct
name|sra_elt
modifier|*
name|rhs_elt
parameter_list|,
name|block_stmt_iterator
modifier|*
name|bsi
parameter_list|)
block|{
name|tree
name|list
decl_stmt|,
name|stmt
decl_stmt|;
if|if
condition|(
name|lhs_elt
operator|->
name|replacement
operator|&&
name|rhs_elt
operator|->
name|replacement
condition|)
block|{
comment|/* If we have two scalar operands, modify the existing statement.  */
name|stmt
operator|=
name|bsi_stmt
argument_list|(
operator|*
name|bsi
argument_list|)
expr_stmt|;
comment|/* See the commentary in sra_walk_function concerning 	 RETURN_EXPR, and why we should never see one here.  */
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|MODIFY_EXPR
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
operator|=
name|lhs_elt
operator|->
name|replacement
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
operator|=
name|rhs_elt
operator|->
name|replacement
expr_stmt|;
name|update_stmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lhs_elt
operator|->
name|use_block_copy
operator|||
name|rhs_elt
operator|->
name|use_block_copy
condition|)
block|{
comment|/* If either side requires a block copy, then sync the RHS back 	 to the original structure, leave the original assignment 	 statement (which will perform the block copy), then load the 	 LHS values out of its now-updated original structure.  */
comment|/* ??? Could perform a modified pair-wise element copy.  That 	 would at least allow those elements that are instantiated in 	 both structures to be optimized well.  */
name|list
operator|=
name|NULL
expr_stmt|;
name|generate_copy_inout
argument_list|(
name|rhs_elt
argument_list|,
name|false
argument_list|,
name|generate_element_ref
argument_list|(
name|rhs_elt
argument_list|)
argument_list|,
operator|&
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
name|list
condition|)
block|{
name|mark_all_v_defs
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|sra_insert_before
argument_list|(
name|bsi
argument_list|,
name|list
argument_list|)
expr_stmt|;
block|}
name|list
operator|=
name|NULL
expr_stmt|;
name|generate_copy_inout
argument_list|(
name|lhs_elt
argument_list|,
name|true
argument_list|,
name|generate_element_ref
argument_list|(
name|lhs_elt
argument_list|)
argument_list|,
operator|&
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
name|list
condition|)
block|{
name|mark_all_v_defs
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|sra_insert_after
argument_list|(
name|bsi
argument_list|,
name|list
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Otherwise both sides must be fully instantiated.  In which 	 case perform pair-wise element assignments and replace the 	 original block copy statement.  */
name|stmt
operator|=
name|bsi_stmt
argument_list|(
operator|*
name|bsi
argument_list|)
expr_stmt|;
name|mark_all_v_defs
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|list
operator|=
name|NULL
expr_stmt|;
name|generate_element_copy
argument_list|(
name|lhs_elt
argument_list|,
name|rhs_elt
argument_list|,
operator|&
name|list
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|mark_all_v_defs
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|sra_replace
argument_list|(
name|bsi
argument_list|,
name|list
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Scalarize an INIT.  To recap, this is an assignment to a scalarizable    reference from some form of constructor: CONSTRUCTOR, COMPLEX_CST or    COMPLEX_EXPR.  If RHS is NULL, it should be treated as an empty    CONSTRUCTOR.  */
end_comment

begin_function
specifier|static
name|void
name|scalarize_init
parameter_list|(
name|struct
name|sra_elt
modifier|*
name|lhs_elt
parameter_list|,
name|tree
name|rhs
parameter_list|,
name|block_stmt_iterator
modifier|*
name|bsi
parameter_list|)
block|{
name|bool
name|result
init|=
name|true
decl_stmt|;
name|tree
name|list
init|=
name|NULL
decl_stmt|;
comment|/* Generate initialization statements for all members extant in the RHS.  */
if|if
condition|(
name|rhs
condition|)
block|{
comment|/* Unshare the expression just in case this is from a decl's initial.  */
name|rhs
operator|=
name|unshare_expr
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
name|result
operator|=
name|generate_element_init
argument_list|(
name|lhs_elt
argument_list|,
name|rhs
argument_list|,
operator|&
name|list
argument_list|)
expr_stmt|;
block|}
comment|/* CONSTRUCTOR is defined such that any member not mentioned is assigned      a zero value.  Initialize the rest of the instantiated elements.  */
name|generate_element_zero
argument_list|(
name|lhs_elt
argument_list|,
operator|&
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|result
condition|)
block|{
comment|/* If we failed to convert the entire initializer, then we must 	 leave the structure assignment in place and must load values 	 from the structure into the slots for which we did not find 	 constants.  The easiest way to do this is to generate a complete 	 copy-out, and then follow that with the constant assignments 	 that we were able to build.  DCE will clean things up.  */
name|tree
name|list0
init|=
name|NULL
decl_stmt|;
name|generate_copy_inout
argument_list|(
name|lhs_elt
argument_list|,
name|true
argument_list|,
name|generate_element_ref
argument_list|(
name|lhs_elt
argument_list|)
argument_list|,
operator|&
name|list0
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|list
argument_list|,
operator|&
name|list0
argument_list|)
expr_stmt|;
name|list
operator|=
name|list0
expr_stmt|;
block|}
if|if
condition|(
name|lhs_elt
operator|->
name|use_block_copy
operator|||
operator|!
name|result
condition|)
block|{
comment|/* Since LHS is not fully instantiated, we must leave the structure 	 assignment in place.  Treating this case differently from a USE 	 exposes constants to later optimizations.  */
if|if
condition|(
name|list
condition|)
block|{
name|mark_all_v_defs
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|sra_insert_after
argument_list|(
name|bsi
argument_list|,
name|list
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* The LHS is fully instantiated.  The list of initializations 	 replaces the original structure assignment.  */
name|gcc_assert
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|mark_all_v_defs
argument_list|(
name|bsi_stmt
argument_list|(
operator|*
name|bsi
argument_list|)
argument_list|)
expr_stmt|;
name|mark_all_v_defs
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|sra_replace
argument_list|(
name|bsi
argument_list|,
name|list
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* A subroutine of scalarize_ldst called via walk_tree.  Set TREE_NO_TRAP    on all INDIRECT_REFs.  */
end_comment

begin_function
specifier|static
name|tree
name|mark_notrap
parameter_list|(
name|tree
modifier|*
name|tp
parameter_list|,
name|int
modifier|*
name|walk_subtrees
parameter_list|,
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|tree
name|t
init|=
operator|*
name|tp
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|INDIRECT_REF
condition|)
block|{
name|TREE_THIS_NOTRAP
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
operator|*
name|walk_subtrees
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IS_TYPE_OR_DECL_P
argument_list|(
name|t
argument_list|)
condition|)
operator|*
name|walk_subtrees
operator|=
literal|0
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Scalarize a LDST.  To recap, this is an assignment between one scalarizable    reference ELT and one non-scalarizable reference OTHER.  IS_OUTPUT is true    if ELT is on the left-hand side.  */
end_comment

begin_function
specifier|static
name|void
name|scalarize_ldst
parameter_list|(
name|struct
name|sra_elt
modifier|*
name|elt
parameter_list|,
name|tree
name|other
parameter_list|,
name|block_stmt_iterator
modifier|*
name|bsi
parameter_list|,
name|bool
name|is_output
parameter_list|)
block|{
comment|/* Shouldn't have gotten called for a scalar.  */
name|gcc_assert
argument_list|(
operator|!
name|elt
operator|->
name|replacement
argument_list|)
expr_stmt|;
if|if
condition|(
name|elt
operator|->
name|use_block_copy
condition|)
block|{
comment|/* Since ELT is not fully instantiated, we have to leave the 	 block copy in place.  Treat this as a USE.  */
name|scalarize_use
argument_list|(
name|elt
argument_list|,
name|NULL
argument_list|,
name|bsi
argument_list|,
name|is_output
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* The interesting case is when ELT is fully instantiated.  In this 	 case we can have each element stored/loaded directly to/from the 	 corresponding slot in OTHER.  This avoids a block copy.  */
name|tree
name|list
init|=
name|NULL
decl_stmt|,
name|stmt
init|=
name|bsi_stmt
argument_list|(
operator|*
name|bsi
argument_list|)
decl_stmt|;
name|mark_all_v_defs
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|generate_copy_inout
argument_list|(
name|elt
argument_list|,
name|is_output
argument_list|,
name|other
argument_list|,
operator|&
name|list
argument_list|)
expr_stmt|;
name|mark_all_v_defs
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|list
argument_list|)
expr_stmt|;
comment|/* Preserve EH semantics.  */
if|if
condition|(
name|stmt_ends_bb_p
argument_list|(
name|stmt
argument_list|)
condition|)
block|{
name|tree_stmt_iterator
name|tsi
decl_stmt|;
name|tree
name|first
decl_stmt|;
comment|/* Extract the first statement from LIST.  */
name|tsi
operator|=
name|tsi_start
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|first
operator|=
name|tsi_stmt
argument_list|(
name|tsi
argument_list|)
expr_stmt|;
name|tsi_delink
argument_list|(
operator|&
name|tsi
argument_list|)
expr_stmt|;
comment|/* Replace the old statement with this new representative.  */
name|bsi_replace
argument_list|(
name|bsi
argument_list|,
name|first
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tsi_end_p
argument_list|(
name|tsi
argument_list|)
condition|)
block|{
comment|/* If any reference would trap, then they all would.  And more 		 to the point, the first would.  Therefore none of the rest 		 will trap since the first didn't.  Indicate this by 		 iterating over the remaining statements and set 		 TREE_THIS_NOTRAP in all INDIRECT_REFs.  */
do|do
block|{
name|walk_tree
argument_list|(
name|tsi_stmt_ptr
argument_list|(
name|tsi
argument_list|)
argument_list|,
name|mark_notrap
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|tsi_next
argument_list|(
operator|&
name|tsi
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|tsi_end_p
argument_list|(
name|tsi
argument_list|)
condition|)
do|;
name|insert_edge_copies
argument_list|(
name|list
argument_list|,
name|bsi
operator|->
name|bb
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|sra_replace
argument_list|(
name|bsi
argument_list|,
name|list
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Generate initializations for all scalarizable parameters.  */
end_comment

begin_function
specifier|static
name|void
name|scalarize_parms
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|list
init|=
name|NULL
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|needs_copy_in
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|bi
argument_list|)
block|{
name|tree
name|var
init|=
name|referenced_var
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|struct
name|sra_elt
modifier|*
name|elt
init|=
name|lookup_element
argument_list|(
name|NULL
argument_list|,
name|var
argument_list|,
name|NULL
argument_list|,
name|NO_INSERT
argument_list|)
decl_stmt|;
name|generate_copy_inout
argument_list|(
name|elt
argument_list|,
name|true
argument_list|,
name|var
argument_list|,
operator|&
name|list
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|list
condition|)
block|{
name|insert_edge_copies
argument_list|(
name|list
argument_list|,
name|ENTRY_BLOCK_PTR
argument_list|)
expr_stmt|;
name|mark_all_v_defs
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Entry point to phase 4.  Update the function to match replacements.  */
end_comment

begin_function
specifier|static
name|void
name|scalarize_function
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
specifier|const
name|struct
name|sra_walk_fns
name|fns
init|=
block|{
name|scalarize_use
block|,
name|scalarize_copy
block|,
name|scalarize_init
block|,
name|scalarize_ldst
block|,
name|false
block|}
decl_stmt|;
name|sra_walk_function
argument_list|(
operator|&
name|fns
argument_list|)
expr_stmt|;
name|scalarize_parms
argument_list|()
expr_stmt|;
name|bsi_commit_edge_inserts
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Debug helper function.  Print ELT in a nice human-readable format.  */
end_comment

begin_function
specifier|static
name|void
name|dump_sra_elt_name
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|,
name|struct
name|sra_elt
modifier|*
name|elt
parameter_list|)
block|{
if|if
condition|(
name|elt
operator|->
name|parent
operator|&&
name|TREE_CODE
argument_list|(
name|elt
operator|->
name|parent
operator|->
name|type
argument_list|)
operator|==
name|COMPLEX_TYPE
condition|)
block|{
name|fputs
argument_list|(
name|elt
operator|->
name|element
operator|==
name|integer_zero_node
condition|?
literal|"__real__ "
else|:
literal|"__imag__ "
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|dump_sra_elt_name
argument_list|(
name|f
argument_list|,
name|elt
operator|->
name|parent
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|elt
operator|->
name|parent
condition|)
name|dump_sra_elt_name
argument_list|(
name|f
argument_list|,
name|elt
operator|->
name|parent
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_P
argument_list|(
name|elt
operator|->
name|element
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|elt
operator|->
name|element
argument_list|)
operator|==
name|FIELD_DECL
condition|)
name|fputc
argument_list|(
literal|'.'
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|f
argument_list|,
name|elt
operator|->
name|element
argument_list|,
name|dump_flags
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|elt
operator|->
name|element
argument_list|)
operator|==
name|RANGE_EXPR
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"["
name|HOST_WIDE_INT_PRINT_DEC
literal|".."
name|HOST_WIDE_INT_PRINT_DEC
literal|"]"
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_OPERAND
argument_list|(
name|elt
operator|->
name|element
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_OPERAND
argument_list|(
name|elt
operator|->
name|element
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"["
name|HOST_WIDE_INT_PRINT_DEC
literal|"]"
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|elt
operator|->
name|element
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Likewise, but callable from the debugger.  */
end_comment

begin_function
name|void
name|debug_sra_elt_name
parameter_list|(
name|struct
name|sra_elt
modifier|*
name|elt
parameter_list|)
block|{
name|dump_sra_elt_name
argument_list|(
name|stderr
argument_list|,
name|elt
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sra_init_cache
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|sra_type_decomp_cache
condition|)
return|return;
name|sra_type_decomp_cache
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|sra_type_inst_cache
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Main entry point.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|tree_sra
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Initialize local variables.  */
name|todoflags
operator|=
literal|0
expr_stmt|;
name|gcc_obstack_init
argument_list|(
operator|&
name|sra_obstack
argument_list|)
expr_stmt|;
name|sra_candidates
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|needs_copy_in
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|sra_init_cache
argument_list|()
expr_stmt|;
name|sra_map
operator|=
name|htab_create
argument_list|(
literal|101
argument_list|,
name|sra_elt_hash
argument_list|,
name|sra_elt_eq
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Scan.  If we find anything, instantiate and scalarize.  */
if|if
condition|(
name|find_candidates_for_sra
argument_list|()
condition|)
block|{
name|scan_function
argument_list|()
expr_stmt|;
name|decide_instantiations
argument_list|()
expr_stmt|;
name|scalarize_function
argument_list|()
expr_stmt|;
block|}
comment|/* Free allocated memory.  */
name|htab_delete
argument_list|(
name|sra_map
argument_list|)
expr_stmt|;
name|sra_map
operator|=
name|NULL
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|sra_candidates
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|needs_copy_in
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|sra_type_decomp_cache
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|sra_type_inst_cache
argument_list|)
expr_stmt|;
name|obstack_free
argument_list|(
operator|&
name|sra_obstack
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|todoflags
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|gate_sra
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|flag_tree_sra
operator|!=
literal|0
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|tree_opt_pass
name|pass_sra
init|=
block|{
literal|"sra"
block|,
comment|/* name */
name|gate_sra
block|,
comment|/* gate */
name|tree_sra
block|,
comment|/* execute */
name|NULL
block|,
comment|/* sub */
name|NULL
block|,
comment|/* next */
literal|0
block|,
comment|/* static_pass_number */
name|TV_TREE_SRA
block|,
comment|/* tv_id */
name|PROP_cfg
operator||
name|PROP_ssa
operator||
name|PROP_alias
block|,
comment|/* properties_required */
literal|0
block|,
comment|/* properties_provided */
name|PROP_smt_usage
block|,
comment|/* properties_destroyed */
literal|0
block|,
comment|/* todo_flags_start */
name|TODO_dump_func
comment|/* todo_flags_finish */
operator||
name|TODO_update_ssa
operator||
name|TODO_ggc_collect
operator||
name|TODO_verify_ssa
block|,
literal|0
comment|/* letter */
block|}
decl_stmt|;
end_decl_stmt

end_unit

