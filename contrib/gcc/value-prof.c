begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Transformations based on profile information for values.    Copyright (C) 2003, 2004, 2005 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"value-prof.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"optabs.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"tree-flow.h"
end_include

begin_include
include|#
directive|include
file|"tree-flow-inline.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_include
include|#
directive|include
file|"coverage.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"gcov-io.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"tree-pass.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_decl_stmt
specifier|static
name|struct
name|value_prof_hooks
modifier|*
name|value_prof_hooks
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* In this file value profile based optimizations are placed.  Currently the    following optimizations are implemented (for more detailed descriptions    see comments at value_profile_transformations):     1) Division/modulo specialization.  Provided that we can determine that the       operands of the division have some special properties, we may use it to       produce more effective code.    2) Speculative prefetching.  If we are able to determine that the difference       between addresses accessed by a memory reference is usually constant, we       may add the prefetch instructions.       FIXME: This transformation was removed together with RTL based value       profiling.     Every such optimization should add its requirements for profiled values to    insn_values_to_profile function.  This function is called from branch_prob    in profile.c and the requested values are instrumented by it in the first    compilation with -fprofile-arcs.  The optimization may then read the    gathered data in the second compilation with -fbranch-probabilities.     The measured data is pointed to from the histograms    field of the statement annotation of the instrumented insns.  It is    kept as a linked list of struct histogram_value_t's, which contain the    same information as above.  */
end_comment

begin_function_decl
specifier|static
name|tree
name|tree_divmod_fixed_value
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|,
name|gcov_type
parameter_list|,
name|gcov_type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|tree_mod_pow2
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|,
name|gcov_type
parameter_list|,
name|gcov_type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|tree_mod_subtract
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|gcov_type
parameter_list|,
name|gcov_type
parameter_list|,
name|gcov_type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|tree_divmod_fixed_value_transform
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|tree_mod_pow2_value_transform
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|tree_mod_subtract_transform
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* The overall number of invocations of the counter should match execution count    of basic block.  Report it as error rather than internal error as it might    mean that user has misused the profile somehow.  */
end_comment

begin_function
specifier|static
name|bool
name|check_counter
parameter_list|(
name|tree
name|stmt
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|gcov_type
name|all
parameter_list|,
name|gcov_type
name|bb_count
parameter_list|)
block|{
if|if
condition|(
name|all
operator|!=
name|bb_count
condition|)
block|{
name|location_t
modifier|*
name|locus
decl_stmt|;
name|locus
operator|=
operator|(
name|stmt
operator|!=
name|NULL
operator|&&
name|EXPR_HAS_LOCATION
argument_list|(
name|stmt
argument_list|)
condition|?
name|EXPR_LOCUS
argument_list|(
name|stmt
argument_list|)
else|:
operator|&
name|DECL_SOURCE_LOCATION
argument_list|(
name|current_function_decl
argument_list|)
operator|)
expr_stmt|;
name|error
argument_list|(
literal|"%HCorrupted value profile: %s profiler overall count (%d) does not match BB count (%d)"
argument_list|,
name|locus
argument_list|,
name|name
argument_list|,
operator|(
name|int
operator|)
name|all
argument_list|,
operator|(
name|int
operator|)
name|bb_count
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Tree based transformations. */
end_comment

begin_function
specifier|static
name|bool
name|tree_value_profile_transformations
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|block_stmt_iterator
name|bsi
decl_stmt|;
name|bool
name|changed
init|=
name|false
decl_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
comment|/* Ignore cold areas -- we are enlarging the code.  */
if|if
condition|(
operator|!
name|maybe_hot_bb_p
argument_list|(
name|bb
argument_list|)
condition|)
continue|continue;
for|for
control|(
name|bsi
operator|=
name|bsi_start
argument_list|(
name|bb
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|;
name|bsi_next
argument_list|(
operator|&
name|bsi
argument_list|)
control|)
block|{
name|tree
name|stmt
init|=
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
decl_stmt|;
name|stmt_ann_t
name|ann
init|=
name|get_stmt_ann
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
name|histogram_value
name|th
init|=
name|ann
operator|->
name|histograms
decl_stmt|;
if|if
condition|(
operator|!
name|th
condition|)
continue|continue;
if|if
condition|(
name|dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Trying transformations on insn "
argument_list|)
expr_stmt|;
name|print_generic_stmt
argument_list|(
name|dump_file
argument_list|,
name|stmt
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
block|}
comment|/* Transformations:  */
comment|/* The order of things in this conditional controls which 	     transformation is used when more than one is applicable.  */
comment|/* It is expected that any code added by the transformations 	     will be added before the current statement, and that the 	     current statement remain valid (although possibly 	     modified) upon return.  */
if|if
condition|(
name|flag_value_profile_transformations
operator|&&
operator|(
name|tree_mod_subtract_transform
argument_list|(
name|stmt
argument_list|)
operator|||
name|tree_divmod_fixed_value_transform
argument_list|(
name|stmt
argument_list|)
operator|||
name|tree_mod_pow2_value_transform
argument_list|(
name|stmt
argument_list|)
operator|)
condition|)
block|{
name|changed
operator|=
name|true
expr_stmt|;
comment|/* Original statement may no longer be in the same block. */
if|if
condition|(
name|bb
operator|!=
name|bb_for_stmt
argument_list|(
name|stmt
argument_list|)
condition|)
block|{
name|bb
operator|=
name|bb_for_stmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|bsi
operator|=
name|bsi_for_stmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Free extra storage from compute_value_histograms.  */
while|while
condition|(
name|th
condition|)
block|{
name|free
argument_list|(
name|th
operator|->
name|hvalue
operator|.
name|counters
argument_list|)
expr_stmt|;
name|th
operator|=
name|th
operator|->
name|hvalue
operator|.
name|next
expr_stmt|;
block|}
name|ann
operator|->
name|histograms
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|changed
condition|)
block|{
name|counts_to_freqs
argument_list|()
expr_stmt|;
block|}
return|return
name|changed
return|;
block|}
end_function

begin_comment
comment|/* Generate code for transformation 1 (with OPERATION, operands OP1    and OP2, whose value is expected to be VALUE, parent modify-expr STMT and    probability of taking the optimal path PROB, which is equivalent to COUNT/ALL    within roundoff error).  This generates the result into a temp and returns     the temp; it does not replace or alter the original STMT.  */
end_comment

begin_function
specifier|static
name|tree
name|tree_divmod_fixed_value
parameter_list|(
name|tree
name|stmt
parameter_list|,
name|tree
name|operation
parameter_list|,
name|tree
name|op1
parameter_list|,
name|tree
name|op2
parameter_list|,
name|tree
name|value
parameter_list|,
name|int
name|prob
parameter_list|,
name|gcov_type
name|count
parameter_list|,
name|gcov_type
name|all
parameter_list|)
block|{
name|tree
name|stmt1
decl_stmt|,
name|stmt2
decl_stmt|,
name|stmt3
decl_stmt|;
name|tree
name|tmp1
decl_stmt|,
name|tmp2
decl_stmt|,
name|tmpv
decl_stmt|;
name|tree
name|label_decl1
init|=
name|create_artificial_label
argument_list|()
decl_stmt|;
name|tree
name|label_decl2
init|=
name|create_artificial_label
argument_list|()
decl_stmt|;
name|tree
name|label_decl3
init|=
name|create_artificial_label
argument_list|()
decl_stmt|;
name|tree
name|label1
decl_stmt|,
name|label2
decl_stmt|,
name|label3
decl_stmt|;
name|tree
name|bb1end
decl_stmt|,
name|bb2end
decl_stmt|,
name|bb3end
decl_stmt|;
name|basic_block
name|bb
decl_stmt|,
name|bb2
decl_stmt|,
name|bb3
decl_stmt|,
name|bb4
decl_stmt|;
name|tree
name|optype
init|=
name|TREE_TYPE
argument_list|(
name|operation
argument_list|)
decl_stmt|;
name|edge
name|e12
decl_stmt|,
name|e13
decl_stmt|,
name|e23
decl_stmt|,
name|e24
decl_stmt|,
name|e34
decl_stmt|;
name|block_stmt_iterator
name|bsi
decl_stmt|;
name|bb
operator|=
name|bb_for_stmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|bsi
operator|=
name|bsi_for_stmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|tmpv
operator|=
name|create_tmp_var
argument_list|(
name|optype
argument_list|,
literal|"PROF"
argument_list|)
expr_stmt|;
name|tmp1
operator|=
name|create_tmp_var
argument_list|(
name|optype
argument_list|,
literal|"PROF"
argument_list|)
expr_stmt|;
name|stmt1
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|optype
argument_list|,
name|tmpv
argument_list|,
name|fold_convert
argument_list|(
name|optype
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|stmt2
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|optype
argument_list|,
name|tmp1
argument_list|,
name|op2
argument_list|)
expr_stmt|;
name|stmt3
operator|=
name|build3
argument_list|(
name|COND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|build2
argument_list|(
name|NE_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|tmp1
argument_list|,
name|tmpv
argument_list|)
argument_list|,
name|build1
argument_list|(
name|GOTO_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|label_decl2
argument_list|)
argument_list|,
name|build1
argument_list|(
name|GOTO_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|label_decl1
argument_list|)
argument_list|)
expr_stmt|;
name|bsi_insert_before
argument_list|(
operator|&
name|bsi
argument_list|,
name|stmt1
argument_list|,
name|BSI_SAME_STMT
argument_list|)
expr_stmt|;
name|bsi_insert_before
argument_list|(
operator|&
name|bsi
argument_list|,
name|stmt2
argument_list|,
name|BSI_SAME_STMT
argument_list|)
expr_stmt|;
name|bsi_insert_before
argument_list|(
operator|&
name|bsi
argument_list|,
name|stmt3
argument_list|,
name|BSI_SAME_STMT
argument_list|)
expr_stmt|;
name|bb1end
operator|=
name|stmt3
expr_stmt|;
name|tmp2
operator|=
name|create_tmp_var
argument_list|(
name|optype
argument_list|,
literal|"PROF"
argument_list|)
expr_stmt|;
name|label1
operator|=
name|build1
argument_list|(
name|LABEL_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|label_decl1
argument_list|)
expr_stmt|;
name|stmt1
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|optype
argument_list|,
name|tmp2
argument_list|,
name|build2
argument_list|(
name|TREE_CODE
argument_list|(
name|operation
argument_list|)
argument_list|,
name|optype
argument_list|,
name|op1
argument_list|,
name|tmpv
argument_list|)
argument_list|)
expr_stmt|;
name|bsi_insert_before
argument_list|(
operator|&
name|bsi
argument_list|,
name|label1
argument_list|,
name|BSI_SAME_STMT
argument_list|)
expr_stmt|;
name|bsi_insert_before
argument_list|(
operator|&
name|bsi
argument_list|,
name|stmt1
argument_list|,
name|BSI_SAME_STMT
argument_list|)
expr_stmt|;
name|bb2end
operator|=
name|stmt1
expr_stmt|;
name|label2
operator|=
name|build1
argument_list|(
name|LABEL_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|label_decl2
argument_list|)
expr_stmt|;
name|stmt1
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|optype
argument_list|,
name|tmp2
argument_list|,
name|build2
argument_list|(
name|TREE_CODE
argument_list|(
name|operation
argument_list|)
argument_list|,
name|optype
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|)
argument_list|)
expr_stmt|;
name|bsi_insert_before
argument_list|(
operator|&
name|bsi
argument_list|,
name|label2
argument_list|,
name|BSI_SAME_STMT
argument_list|)
expr_stmt|;
name|bsi_insert_before
argument_list|(
operator|&
name|bsi
argument_list|,
name|stmt1
argument_list|,
name|BSI_SAME_STMT
argument_list|)
expr_stmt|;
name|bb3end
operator|=
name|stmt1
expr_stmt|;
name|label3
operator|=
name|build1
argument_list|(
name|LABEL_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|label_decl3
argument_list|)
expr_stmt|;
name|bsi_insert_before
argument_list|(
operator|&
name|bsi
argument_list|,
name|label3
argument_list|,
name|BSI_SAME_STMT
argument_list|)
expr_stmt|;
comment|/* Fix CFG. */
comment|/* Edge e23 connects bb2 to bb3, etc. */
name|e12
operator|=
name|split_block
argument_list|(
name|bb
argument_list|,
name|bb1end
argument_list|)
expr_stmt|;
name|bb2
operator|=
name|e12
operator|->
name|dest
expr_stmt|;
name|bb2
operator|->
name|count
operator|=
name|count
expr_stmt|;
name|e23
operator|=
name|split_block
argument_list|(
name|bb2
argument_list|,
name|bb2end
argument_list|)
expr_stmt|;
name|bb3
operator|=
name|e23
operator|->
name|dest
expr_stmt|;
name|bb3
operator|->
name|count
operator|=
name|all
operator|-
name|count
expr_stmt|;
name|e34
operator|=
name|split_block
argument_list|(
name|bb3
argument_list|,
name|bb3end
argument_list|)
expr_stmt|;
name|bb4
operator|=
name|e34
operator|->
name|dest
expr_stmt|;
name|bb4
operator|->
name|count
operator|=
name|all
expr_stmt|;
name|e12
operator|->
name|flags
operator|&=
operator|~
name|EDGE_FALLTHRU
expr_stmt|;
name|e12
operator|->
name|flags
operator||=
name|EDGE_FALSE_VALUE
expr_stmt|;
name|e12
operator|->
name|probability
operator|=
name|prob
expr_stmt|;
name|e12
operator|->
name|count
operator|=
name|count
expr_stmt|;
name|e13
operator|=
name|make_edge
argument_list|(
name|bb
argument_list|,
name|bb3
argument_list|,
name|EDGE_TRUE_VALUE
argument_list|)
expr_stmt|;
name|e13
operator|->
name|probability
operator|=
name|REG_BR_PROB_BASE
operator|-
name|prob
expr_stmt|;
name|e13
operator|->
name|count
operator|=
name|all
operator|-
name|count
expr_stmt|;
name|remove_edge
argument_list|(
name|e23
argument_list|)
expr_stmt|;
name|e24
operator|=
name|make_edge
argument_list|(
name|bb2
argument_list|,
name|bb4
argument_list|,
name|EDGE_FALLTHRU
argument_list|)
expr_stmt|;
name|e24
operator|->
name|probability
operator|=
name|REG_BR_PROB_BASE
expr_stmt|;
name|e24
operator|->
name|count
operator|=
name|count
expr_stmt|;
name|e34
operator|->
name|probability
operator|=
name|REG_BR_PROB_BASE
expr_stmt|;
name|e34
operator|->
name|count
operator|=
name|all
operator|-
name|count
expr_stmt|;
return|return
name|tmp2
return|;
block|}
end_function

begin_comment
comment|/* Do transform 1) on INSN if applicable.  */
end_comment

begin_function
specifier|static
name|bool
name|tree_divmod_fixed_value_transform
parameter_list|(
name|tree
name|stmt
parameter_list|)
block|{
name|stmt_ann_t
name|ann
init|=
name|get_stmt_ann
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
name|histogram_value
name|histogram
decl_stmt|;
name|enum
name|tree_code
name|code
decl_stmt|;
name|gcov_type
name|val
decl_stmt|,
name|count
decl_stmt|,
name|all
decl_stmt|;
name|tree
name|modify
decl_stmt|,
name|op
decl_stmt|,
name|op1
decl_stmt|,
name|op2
decl_stmt|,
name|result
decl_stmt|,
name|value
decl_stmt|,
name|tree_val
decl_stmt|;
name|int
name|prob
decl_stmt|;
name|modify
operator|=
name|stmt
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|RETURN_EXPR
operator|&&
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MODIFY_EXPR
condition|)
name|modify
operator|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|modify
argument_list|)
operator|!=
name|MODIFY_EXPR
condition|)
return|return
name|false
return|;
name|op
operator|=
name|TREE_OPERAND
argument_list|(
name|modify
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|op
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
name|code
operator|=
name|TREE_CODE
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|!=
name|TRUNC_DIV_EXPR
operator|&&
name|code
operator|!=
name|TRUNC_MOD_EXPR
condition|)
return|return
name|false
return|;
name|op1
operator|=
name|TREE_OPERAND
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op2
operator|=
name|TREE_OPERAND
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ann
operator|->
name|histograms
condition|)
return|return
name|false
return|;
for|for
control|(
name|histogram
operator|=
name|ann
operator|->
name|histograms
init|;
name|histogram
condition|;
name|histogram
operator|=
name|histogram
operator|->
name|hvalue
operator|.
name|next
control|)
if|if
condition|(
name|histogram
operator|->
name|type
operator|==
name|HIST_TYPE_SINGLE_VALUE
condition|)
break|break;
if|if
condition|(
operator|!
name|histogram
condition|)
return|return
name|false
return|;
name|value
operator|=
name|histogram
operator|->
name|hvalue
operator|.
name|value
expr_stmt|;
name|val
operator|=
name|histogram
operator|->
name|hvalue
operator|.
name|counters
index|[
literal|0
index|]
expr_stmt|;
name|count
operator|=
name|histogram
operator|->
name|hvalue
operator|.
name|counters
index|[
literal|1
index|]
expr_stmt|;
name|all
operator|=
name|histogram
operator|->
name|hvalue
operator|.
name|counters
index|[
literal|2
index|]
expr_stmt|;
comment|/* We require that count is at least half of all; this means      that for the transformation to fire the value must be constant      at least 50% of time (and 75% gives the guarantee of usage).  */
if|if
condition|(
name|simple_cst_equal
argument_list|(
name|op2
argument_list|,
name|value
argument_list|)
operator|!=
literal|1
operator|||
literal|2
operator|*
name|count
operator|<
name|all
condition|)
return|return
name|false
return|;
if|if
condition|(
name|check_counter
argument_list|(
name|stmt
argument_list|,
literal|"value"
argument_list|,
name|all
argument_list|,
name|bb_for_stmt
argument_list|(
name|stmt
argument_list|)
operator|->
name|count
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Compute probability of taking the optimal path.  */
name|prob
operator|=
operator|(
name|count
operator|*
name|REG_BR_PROB_BASE
operator|+
name|all
operator|/
literal|2
operator|)
operator|/
name|all
expr_stmt|;
name|tree_val
operator|=
name|build_int_cst_wide
argument_list|(
name|get_gcov_type
argument_list|()
argument_list|,
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|val
argument_list|,
name|val
operator|>>
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|-
literal|1
operator|)
operator|>>
literal|1
argument_list|)
expr_stmt|;
name|result
operator|=
name|tree_divmod_fixed_value
argument_list|(
name|stmt
argument_list|,
name|op
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|,
name|tree_val
argument_list|,
name|prob
argument_list|,
name|count
argument_list|,
name|all
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Div/mod by constant "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|value
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"="
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|tree_val
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|" transformation on insn "
argument_list|)
expr_stmt|;
name|print_generic_stmt
argument_list|(
name|dump_file
argument_list|,
name|stmt
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
block|}
name|TREE_OPERAND
argument_list|(
name|modify
argument_list|,
literal|1
argument_list|)
operator|=
name|result
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Generate code for transformation 2 (with OPERATION, operands OP1    and OP2, parent modify-expr STMT and probability of taking the optimal     path PROB, which is equivalent to COUNT/ALL within roundoff error).      This generates the result into a temp and returns     the temp; it does not replace or alter the original STMT.  */
end_comment

begin_function
specifier|static
name|tree
name|tree_mod_pow2
parameter_list|(
name|tree
name|stmt
parameter_list|,
name|tree
name|operation
parameter_list|,
name|tree
name|op1
parameter_list|,
name|tree
name|op2
parameter_list|,
name|int
name|prob
parameter_list|,
name|gcov_type
name|count
parameter_list|,
name|gcov_type
name|all
parameter_list|)
block|{
name|tree
name|stmt1
decl_stmt|,
name|stmt2
decl_stmt|,
name|stmt3
decl_stmt|,
name|stmt4
decl_stmt|;
name|tree
name|tmp2
decl_stmt|,
name|tmp3
decl_stmt|;
name|tree
name|label_decl1
init|=
name|create_artificial_label
argument_list|()
decl_stmt|;
name|tree
name|label_decl2
init|=
name|create_artificial_label
argument_list|()
decl_stmt|;
name|tree
name|label_decl3
init|=
name|create_artificial_label
argument_list|()
decl_stmt|;
name|tree
name|label1
decl_stmt|,
name|label2
decl_stmt|,
name|label3
decl_stmt|;
name|tree
name|bb1end
decl_stmt|,
name|bb2end
decl_stmt|,
name|bb3end
decl_stmt|;
name|basic_block
name|bb
decl_stmt|,
name|bb2
decl_stmt|,
name|bb3
decl_stmt|,
name|bb4
decl_stmt|;
name|tree
name|optype
init|=
name|TREE_TYPE
argument_list|(
name|operation
argument_list|)
decl_stmt|;
name|edge
name|e12
decl_stmt|,
name|e13
decl_stmt|,
name|e23
decl_stmt|,
name|e24
decl_stmt|,
name|e34
decl_stmt|;
name|block_stmt_iterator
name|bsi
decl_stmt|;
name|tree
name|result
init|=
name|create_tmp_var
argument_list|(
name|optype
argument_list|,
literal|"PROF"
argument_list|)
decl_stmt|;
name|bb
operator|=
name|bb_for_stmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|bsi
operator|=
name|bsi_for_stmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|tmp2
operator|=
name|create_tmp_var
argument_list|(
name|optype
argument_list|,
literal|"PROF"
argument_list|)
expr_stmt|;
name|tmp3
operator|=
name|create_tmp_var
argument_list|(
name|optype
argument_list|,
literal|"PROF"
argument_list|)
expr_stmt|;
name|stmt2
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|optype
argument_list|,
name|tmp2
argument_list|,
name|build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|optype
argument_list|,
name|op2
argument_list|,
name|build_int_cst
argument_list|(
name|optype
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|stmt3
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|optype
argument_list|,
name|tmp3
argument_list|,
name|build2
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|optype
argument_list|,
name|tmp2
argument_list|,
name|op2
argument_list|)
argument_list|)
expr_stmt|;
name|stmt4
operator|=
name|build3
argument_list|(
name|COND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|build2
argument_list|(
name|NE_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|tmp3
argument_list|,
name|build_int_cst
argument_list|(
name|optype
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|build1
argument_list|(
name|GOTO_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|label_decl2
argument_list|)
argument_list|,
name|build1
argument_list|(
name|GOTO_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|label_decl1
argument_list|)
argument_list|)
expr_stmt|;
name|bsi_insert_before
argument_list|(
operator|&
name|bsi
argument_list|,
name|stmt2
argument_list|,
name|BSI_SAME_STMT
argument_list|)
expr_stmt|;
name|bsi_insert_before
argument_list|(
operator|&
name|bsi
argument_list|,
name|stmt3
argument_list|,
name|BSI_SAME_STMT
argument_list|)
expr_stmt|;
name|bsi_insert_before
argument_list|(
operator|&
name|bsi
argument_list|,
name|stmt4
argument_list|,
name|BSI_SAME_STMT
argument_list|)
expr_stmt|;
name|bb1end
operator|=
name|stmt4
expr_stmt|;
comment|/* tmp2 == op2-1 inherited from previous block */
name|label1
operator|=
name|build1
argument_list|(
name|LABEL_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|label_decl1
argument_list|)
expr_stmt|;
name|stmt1
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|optype
argument_list|,
name|result
argument_list|,
name|build2
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|optype
argument_list|,
name|op1
argument_list|,
name|tmp2
argument_list|)
argument_list|)
expr_stmt|;
name|bsi_insert_before
argument_list|(
operator|&
name|bsi
argument_list|,
name|label1
argument_list|,
name|BSI_SAME_STMT
argument_list|)
expr_stmt|;
name|bsi_insert_before
argument_list|(
operator|&
name|bsi
argument_list|,
name|stmt1
argument_list|,
name|BSI_SAME_STMT
argument_list|)
expr_stmt|;
name|bb2end
operator|=
name|stmt1
expr_stmt|;
name|label2
operator|=
name|build1
argument_list|(
name|LABEL_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|label_decl2
argument_list|)
expr_stmt|;
name|stmt1
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|optype
argument_list|,
name|result
argument_list|,
name|build2
argument_list|(
name|TREE_CODE
argument_list|(
name|operation
argument_list|)
argument_list|,
name|optype
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|)
argument_list|)
expr_stmt|;
name|bsi_insert_before
argument_list|(
operator|&
name|bsi
argument_list|,
name|label2
argument_list|,
name|BSI_SAME_STMT
argument_list|)
expr_stmt|;
name|bsi_insert_before
argument_list|(
operator|&
name|bsi
argument_list|,
name|stmt1
argument_list|,
name|BSI_SAME_STMT
argument_list|)
expr_stmt|;
name|bb3end
operator|=
name|stmt1
expr_stmt|;
name|label3
operator|=
name|build1
argument_list|(
name|LABEL_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|label_decl3
argument_list|)
expr_stmt|;
name|bsi_insert_before
argument_list|(
operator|&
name|bsi
argument_list|,
name|label3
argument_list|,
name|BSI_SAME_STMT
argument_list|)
expr_stmt|;
comment|/* Fix CFG. */
comment|/* Edge e23 connects bb2 to bb3, etc. */
name|e12
operator|=
name|split_block
argument_list|(
name|bb
argument_list|,
name|bb1end
argument_list|)
expr_stmt|;
name|bb2
operator|=
name|e12
operator|->
name|dest
expr_stmt|;
name|bb2
operator|->
name|count
operator|=
name|count
expr_stmt|;
name|e23
operator|=
name|split_block
argument_list|(
name|bb2
argument_list|,
name|bb2end
argument_list|)
expr_stmt|;
name|bb3
operator|=
name|e23
operator|->
name|dest
expr_stmt|;
name|bb3
operator|->
name|count
operator|=
name|all
operator|-
name|count
expr_stmt|;
name|e34
operator|=
name|split_block
argument_list|(
name|bb3
argument_list|,
name|bb3end
argument_list|)
expr_stmt|;
name|bb4
operator|=
name|e34
operator|->
name|dest
expr_stmt|;
name|bb4
operator|->
name|count
operator|=
name|all
expr_stmt|;
name|e12
operator|->
name|flags
operator|&=
operator|~
name|EDGE_FALLTHRU
expr_stmt|;
name|e12
operator|->
name|flags
operator||=
name|EDGE_FALSE_VALUE
expr_stmt|;
name|e12
operator|->
name|probability
operator|=
name|prob
expr_stmt|;
name|e12
operator|->
name|count
operator|=
name|count
expr_stmt|;
name|e13
operator|=
name|make_edge
argument_list|(
name|bb
argument_list|,
name|bb3
argument_list|,
name|EDGE_TRUE_VALUE
argument_list|)
expr_stmt|;
name|e13
operator|->
name|probability
operator|=
name|REG_BR_PROB_BASE
operator|-
name|prob
expr_stmt|;
name|e13
operator|->
name|count
operator|=
name|all
operator|-
name|count
expr_stmt|;
name|remove_edge
argument_list|(
name|e23
argument_list|)
expr_stmt|;
name|e24
operator|=
name|make_edge
argument_list|(
name|bb2
argument_list|,
name|bb4
argument_list|,
name|EDGE_FALLTHRU
argument_list|)
expr_stmt|;
name|e24
operator|->
name|probability
operator|=
name|REG_BR_PROB_BASE
expr_stmt|;
name|e24
operator|->
name|count
operator|=
name|count
expr_stmt|;
name|e34
operator|->
name|probability
operator|=
name|REG_BR_PROB_BASE
expr_stmt|;
name|e34
operator|->
name|count
operator|=
name|all
operator|-
name|count
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Do transform 2) on INSN if applicable.  */
end_comment

begin_function
specifier|static
name|bool
name|tree_mod_pow2_value_transform
parameter_list|(
name|tree
name|stmt
parameter_list|)
block|{
name|stmt_ann_t
name|ann
init|=
name|get_stmt_ann
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
name|histogram_value
name|histogram
decl_stmt|;
name|enum
name|tree_code
name|code
decl_stmt|;
name|gcov_type
name|count
decl_stmt|,
name|wrong_values
decl_stmt|,
name|all
decl_stmt|;
name|tree
name|modify
decl_stmt|,
name|op
decl_stmt|,
name|op1
decl_stmt|,
name|op2
decl_stmt|,
name|result
decl_stmt|,
name|value
decl_stmt|;
name|int
name|prob
decl_stmt|;
name|modify
operator|=
name|stmt
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|RETURN_EXPR
operator|&&
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MODIFY_EXPR
condition|)
name|modify
operator|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|modify
argument_list|)
operator|!=
name|MODIFY_EXPR
condition|)
return|return
name|false
return|;
name|op
operator|=
name|TREE_OPERAND
argument_list|(
name|modify
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|op
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
name|code
operator|=
name|TREE_CODE
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|!=
name|TRUNC_MOD_EXPR
operator|||
operator|!
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|op
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
name|op1
operator|=
name|TREE_OPERAND
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op2
operator|=
name|TREE_OPERAND
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ann
operator|->
name|histograms
condition|)
return|return
name|false
return|;
for|for
control|(
name|histogram
operator|=
name|ann
operator|->
name|histograms
init|;
name|histogram
condition|;
name|histogram
operator|=
name|histogram
operator|->
name|hvalue
operator|.
name|next
control|)
if|if
condition|(
name|histogram
operator|->
name|type
operator|==
name|HIST_TYPE_POW2
condition|)
break|break;
if|if
condition|(
operator|!
name|histogram
condition|)
return|return
name|false
return|;
name|value
operator|=
name|histogram
operator|->
name|hvalue
operator|.
name|value
expr_stmt|;
name|wrong_values
operator|=
name|histogram
operator|->
name|hvalue
operator|.
name|counters
index|[
literal|0
index|]
expr_stmt|;
name|count
operator|=
name|histogram
operator|->
name|hvalue
operator|.
name|counters
index|[
literal|1
index|]
expr_stmt|;
comment|/* We require that we hit a power of 2 at least half of all evaluations.  */
if|if
condition|(
name|simple_cst_equal
argument_list|(
name|op2
argument_list|,
name|value
argument_list|)
operator|!=
literal|1
operator|||
name|count
operator|<
name|wrong_values
condition|)
return|return
name|false
return|;
if|if
condition|(
name|dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Mod power of 2 transformation on insn "
argument_list|)
expr_stmt|;
name|print_generic_stmt
argument_list|(
name|dump_file
argument_list|,
name|stmt
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
block|}
comment|/* Compute probability of taking the optimal path.  */
name|all
operator|=
name|count
operator|+
name|wrong_values
expr_stmt|;
if|if
condition|(
name|check_counter
argument_list|(
name|stmt
argument_list|,
literal|"pow2"
argument_list|,
name|all
argument_list|,
name|bb_for_stmt
argument_list|(
name|stmt
argument_list|)
operator|->
name|count
argument_list|)
condition|)
return|return
name|false
return|;
name|prob
operator|=
operator|(
name|count
operator|*
name|REG_BR_PROB_BASE
operator|+
name|all
operator|/
literal|2
operator|)
operator|/
name|all
expr_stmt|;
name|result
operator|=
name|tree_mod_pow2
argument_list|(
name|stmt
argument_list|,
name|op
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|,
name|prob
argument_list|,
name|count
argument_list|,
name|all
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|modify
argument_list|,
literal|1
argument_list|)
operator|=
name|result
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Generate code for transformations 3 and 4 (with OPERATION, operands OP1    and OP2, parent modify-expr STMT, and NCOUNTS the number of cases to    support.  Currently only NCOUNTS==0 or 1 is supported and this is    built into this interface.  The probabilities of taking the optimal     paths are PROB1 and PROB2, which are equivalent to COUNT1/ALL and    COUNT2/ALL respectively within roundoff error).  This generates the     result into a temp and returns the temp; it does not replace or alter     the original STMT.  */
end_comment

begin_comment
comment|/* FIXME: Generalize the interface to handle NCOUNTS> 1.  */
end_comment

begin_function
specifier|static
name|tree
name|tree_mod_subtract
parameter_list|(
name|tree
name|stmt
parameter_list|,
name|tree
name|operation
parameter_list|,
name|tree
name|op1
parameter_list|,
name|tree
name|op2
parameter_list|,
name|int
name|prob1
parameter_list|,
name|int
name|prob2
parameter_list|,
name|int
name|ncounts
parameter_list|,
name|gcov_type
name|count1
parameter_list|,
name|gcov_type
name|count2
parameter_list|,
name|gcov_type
name|all
parameter_list|)
block|{
name|tree
name|stmt1
decl_stmt|,
name|stmt2
decl_stmt|,
name|stmt3
decl_stmt|;
name|tree
name|tmp1
decl_stmt|;
name|tree
name|label_decl1
init|=
name|create_artificial_label
argument_list|()
decl_stmt|;
name|tree
name|label_decl2
init|=
name|create_artificial_label
argument_list|()
decl_stmt|;
name|tree
name|label_decl3
init|=
name|create_artificial_label
argument_list|()
decl_stmt|;
name|tree
name|label1
decl_stmt|,
name|label2
decl_stmt|,
name|label3
decl_stmt|;
name|tree
name|bb1end
decl_stmt|,
name|bb2end
init|=
name|NULL_TREE
decl_stmt|,
name|bb3end
decl_stmt|;
name|basic_block
name|bb
decl_stmt|,
name|bb2
decl_stmt|,
name|bb3
decl_stmt|,
name|bb4
decl_stmt|;
name|tree
name|optype
init|=
name|TREE_TYPE
argument_list|(
name|operation
argument_list|)
decl_stmt|;
name|edge
name|e12
decl_stmt|,
name|e23
init|=
literal|0
decl_stmt|,
name|e24
decl_stmt|,
name|e34
decl_stmt|,
name|e14
decl_stmt|;
name|block_stmt_iterator
name|bsi
decl_stmt|;
name|tree
name|result
init|=
name|create_tmp_var
argument_list|(
name|optype
argument_list|,
literal|"PROF"
argument_list|)
decl_stmt|;
name|bb
operator|=
name|bb_for_stmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|bsi
operator|=
name|bsi_for_stmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|tmp1
operator|=
name|create_tmp_var
argument_list|(
name|optype
argument_list|,
literal|"PROF"
argument_list|)
expr_stmt|;
name|stmt1
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|optype
argument_list|,
name|result
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|stmt2
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|optype
argument_list|,
name|tmp1
argument_list|,
name|op2
argument_list|)
expr_stmt|;
name|stmt3
operator|=
name|build3
argument_list|(
name|COND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|build2
argument_list|(
name|LT_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|result
argument_list|,
name|tmp1
argument_list|)
argument_list|,
name|build1
argument_list|(
name|GOTO_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|label_decl3
argument_list|)
argument_list|,
name|build1
argument_list|(
name|GOTO_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|ncounts
condition|?
name|label_decl1
else|:
name|label_decl2
argument_list|)
argument_list|)
expr_stmt|;
name|bsi_insert_before
argument_list|(
operator|&
name|bsi
argument_list|,
name|stmt1
argument_list|,
name|BSI_SAME_STMT
argument_list|)
expr_stmt|;
name|bsi_insert_before
argument_list|(
operator|&
name|bsi
argument_list|,
name|stmt2
argument_list|,
name|BSI_SAME_STMT
argument_list|)
expr_stmt|;
name|bsi_insert_before
argument_list|(
operator|&
name|bsi
argument_list|,
name|stmt3
argument_list|,
name|BSI_SAME_STMT
argument_list|)
expr_stmt|;
name|bb1end
operator|=
name|stmt3
expr_stmt|;
if|if
condition|(
name|ncounts
condition|)
comment|/* Assumed to be 0 or 1 */
block|{
name|label1
operator|=
name|build1
argument_list|(
name|LABEL_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|label_decl1
argument_list|)
expr_stmt|;
name|stmt1
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|optype
argument_list|,
name|result
argument_list|,
name|build2
argument_list|(
name|MINUS_EXPR
argument_list|,
name|optype
argument_list|,
name|result
argument_list|,
name|tmp1
argument_list|)
argument_list|)
expr_stmt|;
name|stmt2
operator|=
name|build3
argument_list|(
name|COND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|build2
argument_list|(
name|LT_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|result
argument_list|,
name|tmp1
argument_list|)
argument_list|,
name|build1
argument_list|(
name|GOTO_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|label_decl3
argument_list|)
argument_list|,
name|build1
argument_list|(
name|GOTO_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|label_decl2
argument_list|)
argument_list|)
expr_stmt|;
name|bsi_insert_before
argument_list|(
operator|&
name|bsi
argument_list|,
name|label1
argument_list|,
name|BSI_SAME_STMT
argument_list|)
expr_stmt|;
name|bsi_insert_before
argument_list|(
operator|&
name|bsi
argument_list|,
name|stmt1
argument_list|,
name|BSI_SAME_STMT
argument_list|)
expr_stmt|;
name|bsi_insert_before
argument_list|(
operator|&
name|bsi
argument_list|,
name|stmt2
argument_list|,
name|BSI_SAME_STMT
argument_list|)
expr_stmt|;
name|bb2end
operator|=
name|stmt2
expr_stmt|;
block|}
comment|/* Fallback case. */
name|label2
operator|=
name|build1
argument_list|(
name|LABEL_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|label_decl2
argument_list|)
expr_stmt|;
name|stmt1
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|optype
argument_list|,
name|result
argument_list|,
name|build2
argument_list|(
name|TREE_CODE
argument_list|(
name|operation
argument_list|)
argument_list|,
name|optype
argument_list|,
name|result
argument_list|,
name|tmp1
argument_list|)
argument_list|)
expr_stmt|;
name|bsi_insert_before
argument_list|(
operator|&
name|bsi
argument_list|,
name|label2
argument_list|,
name|BSI_SAME_STMT
argument_list|)
expr_stmt|;
name|bsi_insert_before
argument_list|(
operator|&
name|bsi
argument_list|,
name|stmt1
argument_list|,
name|BSI_SAME_STMT
argument_list|)
expr_stmt|;
name|bb3end
operator|=
name|stmt1
expr_stmt|;
name|label3
operator|=
name|build1
argument_list|(
name|LABEL_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|label_decl3
argument_list|)
expr_stmt|;
name|bsi_insert_before
argument_list|(
operator|&
name|bsi
argument_list|,
name|label3
argument_list|,
name|BSI_SAME_STMT
argument_list|)
expr_stmt|;
comment|/* Fix CFG. */
comment|/* Edge e23 connects bb2 to bb3, etc. */
comment|/* However block 3 is optional; if it is not there, references      to 3 really refer to block 2. */
name|e12
operator|=
name|split_block
argument_list|(
name|bb
argument_list|,
name|bb1end
argument_list|)
expr_stmt|;
name|bb2
operator|=
name|e12
operator|->
name|dest
expr_stmt|;
name|bb2
operator|->
name|count
operator|=
name|all
operator|-
name|count1
expr_stmt|;
if|if
condition|(
name|ncounts
condition|)
comment|/* Assumed to be 0 or 1.  */
block|{
name|e23
operator|=
name|split_block
argument_list|(
name|bb2
argument_list|,
name|bb2end
argument_list|)
expr_stmt|;
name|bb3
operator|=
name|e23
operator|->
name|dest
expr_stmt|;
name|bb3
operator|->
name|count
operator|=
name|all
operator|-
name|count1
operator|-
name|count2
expr_stmt|;
block|}
name|e34
operator|=
name|split_block
argument_list|(
name|ncounts
condition|?
name|bb3
else|:
name|bb2
argument_list|,
name|bb3end
argument_list|)
expr_stmt|;
name|bb4
operator|=
name|e34
operator|->
name|dest
expr_stmt|;
name|bb4
operator|->
name|count
operator|=
name|all
expr_stmt|;
name|e12
operator|->
name|flags
operator|&=
operator|~
name|EDGE_FALLTHRU
expr_stmt|;
name|e12
operator|->
name|flags
operator||=
name|EDGE_FALSE_VALUE
expr_stmt|;
name|e12
operator|->
name|probability
operator|=
name|REG_BR_PROB_BASE
operator|-
name|prob1
expr_stmt|;
name|e12
operator|->
name|count
operator|=
name|all
operator|-
name|count1
expr_stmt|;
name|e14
operator|=
name|make_edge
argument_list|(
name|bb
argument_list|,
name|bb4
argument_list|,
name|EDGE_TRUE_VALUE
argument_list|)
expr_stmt|;
name|e14
operator|->
name|probability
operator|=
name|prob1
expr_stmt|;
name|e14
operator|->
name|count
operator|=
name|count1
expr_stmt|;
if|if
condition|(
name|ncounts
condition|)
comment|/* Assumed to be 0 or 1.  */
block|{
name|e23
operator|->
name|flags
operator|&=
operator|~
name|EDGE_FALLTHRU
expr_stmt|;
name|e23
operator|->
name|flags
operator||=
name|EDGE_FALSE_VALUE
expr_stmt|;
name|e23
operator|->
name|count
operator|=
name|all
operator|-
name|count1
operator|-
name|count2
expr_stmt|;
name|e23
operator|->
name|probability
operator|=
name|REG_BR_PROB_BASE
operator|-
name|prob2
expr_stmt|;
name|e24
operator|=
name|make_edge
argument_list|(
name|bb2
argument_list|,
name|bb4
argument_list|,
name|EDGE_TRUE_VALUE
argument_list|)
expr_stmt|;
name|e24
operator|->
name|probability
operator|=
name|prob2
expr_stmt|;
name|e24
operator|->
name|count
operator|=
name|count2
expr_stmt|;
block|}
name|e34
operator|->
name|probability
operator|=
name|REG_BR_PROB_BASE
expr_stmt|;
name|e34
operator|->
name|count
operator|=
name|all
operator|-
name|count1
operator|-
name|count2
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Do transforms 3) and 4) on INSN if applicable.  */
end_comment

begin_function
specifier|static
name|bool
name|tree_mod_subtract_transform
parameter_list|(
name|tree
name|stmt
parameter_list|)
block|{
name|stmt_ann_t
name|ann
init|=
name|get_stmt_ann
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
name|histogram_value
name|histogram
decl_stmt|;
name|enum
name|tree_code
name|code
decl_stmt|;
name|gcov_type
name|count
decl_stmt|,
name|wrong_values
decl_stmt|,
name|all
decl_stmt|;
name|tree
name|modify
decl_stmt|,
name|op
decl_stmt|,
name|op1
decl_stmt|,
name|op2
decl_stmt|,
name|result
decl_stmt|,
name|value
decl_stmt|;
name|int
name|prob1
decl_stmt|,
name|prob2
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|modify
operator|=
name|stmt
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|RETURN_EXPR
operator|&&
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MODIFY_EXPR
condition|)
name|modify
operator|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|modify
argument_list|)
operator|!=
name|MODIFY_EXPR
condition|)
return|return
name|false
return|;
name|op
operator|=
name|TREE_OPERAND
argument_list|(
name|modify
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|op
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
name|code
operator|=
name|TREE_CODE
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|!=
name|TRUNC_MOD_EXPR
operator|||
operator|!
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|op
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
name|op1
operator|=
name|TREE_OPERAND
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op2
operator|=
name|TREE_OPERAND
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ann
operator|->
name|histograms
condition|)
return|return
name|false
return|;
for|for
control|(
name|histogram
operator|=
name|ann
operator|->
name|histograms
init|;
name|histogram
condition|;
name|histogram
operator|=
name|histogram
operator|->
name|hvalue
operator|.
name|next
control|)
if|if
condition|(
name|histogram
operator|->
name|type
operator|==
name|HIST_TYPE_INTERVAL
condition|)
break|break;
if|if
condition|(
operator|!
name|histogram
condition|)
return|return
name|false
return|;
name|value
operator|=
name|histogram
operator|->
name|hvalue
operator|.
name|value
expr_stmt|;
name|all
operator|=
literal|0
expr_stmt|;
name|wrong_values
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|histogram
operator|->
name|hdata
operator|.
name|intvl
operator|.
name|steps
condition|;
name|i
operator|++
control|)
name|all
operator|+=
name|histogram
operator|->
name|hvalue
operator|.
name|counters
index|[
name|i
index|]
expr_stmt|;
name|wrong_values
operator|+=
name|histogram
operator|->
name|hvalue
operator|.
name|counters
index|[
name|i
index|]
expr_stmt|;
name|wrong_values
operator|+=
name|histogram
operator|->
name|hvalue
operator|.
name|counters
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|all
operator|+=
name|wrong_values
expr_stmt|;
comment|/* Compute probability of taking the optimal path.  */
if|if
condition|(
name|check_counter
argument_list|(
name|stmt
argument_list|,
literal|"interval"
argument_list|,
name|all
argument_list|,
name|bb_for_stmt
argument_list|(
name|stmt
argument_list|)
operator|->
name|count
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* We require that we use just subtractions in at least 50% of all      evaluations.  */
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|histogram
operator|->
name|hdata
operator|.
name|intvl
operator|.
name|steps
condition|;
name|i
operator|++
control|)
block|{
name|count
operator|+=
name|histogram
operator|->
name|hvalue
operator|.
name|counters
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|count
operator|*
literal|2
operator|>=
name|all
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|histogram
operator|->
name|hdata
operator|.
name|intvl
operator|.
name|steps
condition|)
return|return
name|false
return|;
if|if
condition|(
name|dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Mod subtract transformation on insn "
argument_list|)
expr_stmt|;
name|print_generic_stmt
argument_list|(
name|dump_file
argument_list|,
name|stmt
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
block|}
comment|/* Compute probability of taking the optimal path(s).  */
name|prob1
operator|=
operator|(
name|histogram
operator|->
name|hvalue
operator|.
name|counters
index|[
literal|0
index|]
operator|*
name|REG_BR_PROB_BASE
operator|+
name|all
operator|/
literal|2
operator|)
operator|/
name|all
expr_stmt|;
name|prob2
operator|=
operator|(
name|histogram
operator|->
name|hvalue
operator|.
name|counters
index|[
literal|1
index|]
operator|*
name|REG_BR_PROB_BASE
operator|+
name|all
operator|/
literal|2
operator|)
operator|/
name|all
expr_stmt|;
comment|/* In practice, "steps" is always 2.  This interface reflects this,      and will need to be changed if "steps" can change.  */
name|result
operator|=
name|tree_mod_subtract
argument_list|(
name|stmt
argument_list|,
name|op
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|,
name|prob1
argument_list|,
name|prob2
argument_list|,
name|i
argument_list|,
name|histogram
operator|->
name|hvalue
operator|.
name|counters
index|[
literal|0
index|]
argument_list|,
name|histogram
operator|->
name|hvalue
operator|.
name|counters
index|[
literal|1
index|]
argument_list|,
name|all
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|modify
argument_list|,
literal|1
argument_list|)
operator|=
name|result
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_struct
struct|struct
name|value_prof_hooks
block|{
comment|/* Find list of values for which we want to measure histograms.  */
name|void
function_decl|(
modifier|*
name|find_values_to_profile
function_decl|)
parameter_list|(
name|histogram_values
modifier|*
parameter_list|)
function_decl|;
comment|/* Identify and exploit properties of values that are hard to analyze      statically.  See value-prof.c for more detail.  */
name|bool
function_decl|(
modifier|*
name|value_profile_transformations
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
block|}
struct|;
end_struct

begin_escape
end_escape

begin_comment
comment|/* Find values inside STMT for that we want to measure histograms for    division/modulo optimization.  */
end_comment

begin_function
specifier|static
name|void
name|tree_divmod_values_to_profile
parameter_list|(
name|tree
name|stmt
parameter_list|,
name|histogram_values
modifier|*
name|values
parameter_list|)
block|{
name|tree
name|assign
decl_stmt|,
name|lhs
decl_stmt|,
name|rhs
decl_stmt|,
name|divisor
decl_stmt|,
name|op0
decl_stmt|,
name|type
decl_stmt|;
name|histogram_value
name|hist
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|RETURN_EXPR
condition|)
name|assign
operator|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|assign
operator|=
name|stmt
expr_stmt|;
if|if
condition|(
operator|!
name|assign
operator|||
name|TREE_CODE
argument_list|(
name|assign
argument_list|)
operator|!=
name|MODIFY_EXPR
condition|)
return|return;
name|lhs
operator|=
name|TREE_OPERAND
argument_list|(
name|assign
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
return|return;
name|rhs
operator|=
name|TREE_OPERAND
argument_list|(
name|assign
argument_list|,
literal|1
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
condition|)
block|{
case|case
name|TRUNC_DIV_EXPR
case|:
case|case
name|TRUNC_MOD_EXPR
case|:
name|divisor
operator|=
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|op0
operator|=
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|VEC_reserve
argument_list|(
name|histogram_value
argument_list|,
name|heap
argument_list|,
operator|*
name|values
argument_list|,
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_gimple_reg
argument_list|(
name|divisor
argument_list|)
condition|)
block|{
comment|/* Check for the case where the divisor is the same value most 	     of the time.  */
name|hist
operator|=
name|ggc_alloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|hist
argument_list|)
argument_list|)
expr_stmt|;
name|hist
operator|->
name|hvalue
operator|.
name|value
operator|=
name|divisor
expr_stmt|;
name|hist
operator|->
name|hvalue
operator|.
name|stmt
operator|=
name|stmt
expr_stmt|;
name|hist
operator|->
name|type
operator|=
name|HIST_TYPE_SINGLE_VALUE
expr_stmt|;
name|VEC_quick_push
argument_list|(
name|histogram_value
argument_list|,
operator|*
name|values
argument_list|,
name|hist
argument_list|)
expr_stmt|;
block|}
comment|/* For mod, check whether it is not often a noop (or replaceable by 	 a few subtractions).  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|TRUNC_MOD_EXPR
operator|&&
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* Check for a special case where the divisor is power of 2.  */
name|hist
operator|=
name|ggc_alloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|hist
argument_list|)
argument_list|)
expr_stmt|;
name|hist
operator|->
name|hvalue
operator|.
name|value
operator|=
name|divisor
expr_stmt|;
name|hist
operator|->
name|hvalue
operator|.
name|stmt
operator|=
name|stmt
expr_stmt|;
name|hist
operator|->
name|type
operator|=
name|HIST_TYPE_POW2
expr_stmt|;
name|VEC_quick_push
argument_list|(
name|histogram_value
argument_list|,
operator|*
name|values
argument_list|,
name|hist
argument_list|)
expr_stmt|;
name|hist
operator|=
name|ggc_alloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|hist
argument_list|)
argument_list|)
expr_stmt|;
name|hist
operator|->
name|hvalue
operator|.
name|stmt
operator|=
name|stmt
expr_stmt|;
name|hist
operator|->
name|hvalue
operator|.
name|value
operator|=
name|build2
argument_list|(
name|TRUNC_DIV_EXPR
argument_list|,
name|type
argument_list|,
name|op0
argument_list|,
name|divisor
argument_list|)
expr_stmt|;
name|hist
operator|->
name|type
operator|=
name|HIST_TYPE_INTERVAL
expr_stmt|;
name|hist
operator|->
name|hdata
operator|.
name|intvl
operator|.
name|int_start
operator|=
literal|0
expr_stmt|;
name|hist
operator|->
name|hdata
operator|.
name|intvl
operator|.
name|steps
operator|=
literal|2
expr_stmt|;
name|VEC_quick_push
argument_list|(
name|histogram_value
argument_list|,
operator|*
name|values
argument_list|,
name|hist
argument_list|)
expr_stmt|;
block|}
return|return;
default|default:
return|return;
block|}
block|}
end_function

begin_comment
comment|/* Find values inside STMT for that we want to measure histograms and adds    them to list VALUES.  */
end_comment

begin_function
specifier|static
name|void
name|tree_values_to_profile
parameter_list|(
name|tree
name|stmt
parameter_list|,
name|histogram_values
modifier|*
name|values
parameter_list|)
block|{
if|if
condition|(
name|flag_value_profile_transformations
condition|)
name|tree_divmod_values_to_profile
argument_list|(
name|stmt
argument_list|,
name|values
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|tree_find_values_to_profile
parameter_list|(
name|histogram_values
modifier|*
name|values
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|block_stmt_iterator
name|bsi
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|histogram_value
name|hist
decl_stmt|;
operator|*
name|values
operator|=
name|NULL
expr_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
for|for
control|(
name|bsi
operator|=
name|bsi_start
argument_list|(
name|bb
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|;
name|bsi_next
argument_list|(
operator|&
name|bsi
argument_list|)
control|)
name|tree_values_to_profile
argument_list|(
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
argument_list|,
name|values
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|histogram_value
argument_list|,
operator|*
name|values
argument_list|,
name|i
argument_list|,
name|hist
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|hist
operator|->
name|type
condition|)
block|{
case|case
name|HIST_TYPE_INTERVAL
case|:
if|if
condition|(
name|dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Interval counter for tree "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|hist
operator|->
name|hvalue
operator|.
name|stmt
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|", range %d -- %d.\n"
argument_list|,
name|hist
operator|->
name|hdata
operator|.
name|intvl
operator|.
name|int_start
argument_list|,
operator|(
name|hist
operator|->
name|hdata
operator|.
name|intvl
operator|.
name|int_start
operator|+
name|hist
operator|->
name|hdata
operator|.
name|intvl
operator|.
name|steps
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
name|hist
operator|->
name|n_counters
operator|=
name|hist
operator|->
name|hdata
operator|.
name|intvl
operator|.
name|steps
operator|+
literal|2
expr_stmt|;
break|break;
case|case
name|HIST_TYPE_POW2
case|:
if|if
condition|(
name|dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Pow2 counter for tree "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|hist
operator|->
name|hvalue
operator|.
name|stmt
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|".\n"
argument_list|)
expr_stmt|;
block|}
name|hist
operator|->
name|n_counters
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|HIST_TYPE_SINGLE_VALUE
case|:
if|if
condition|(
name|dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Single value counter for tree "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|hist
operator|->
name|hvalue
operator|.
name|stmt
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|".\n"
argument_list|)
expr_stmt|;
block|}
name|hist
operator|->
name|n_counters
operator|=
literal|3
expr_stmt|;
break|break;
case|case
name|HIST_TYPE_CONST_DELTA
case|:
if|if
condition|(
name|dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Constant delta counter for tree "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|hist
operator|->
name|hvalue
operator|.
name|stmt
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|".\n"
argument_list|)
expr_stmt|;
block|}
name|hist
operator|->
name|n_counters
operator|=
literal|4
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|value_prof_hooks
name|tree_value_prof_hooks
init|=
block|{
name|tree_find_values_to_profile
block|,
name|tree_value_profile_transformations
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|tree_register_value_prof_hooks
parameter_list|(
name|void
parameter_list|)
block|{
name|value_prof_hooks
operator|=
operator|&
name|tree_value_prof_hooks
expr_stmt|;
name|gcc_assert
argument_list|(
name|ir_type
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* IR-independent entry points.  */
end_comment

begin_function
name|void
name|find_values_to_profile
parameter_list|(
name|histogram_values
modifier|*
name|values
parameter_list|)
block|{
call|(
name|value_prof_hooks
operator|->
name|find_values_to_profile
call|)
argument_list|(
name|values
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|bool
name|value_profile_transformations
parameter_list|(
name|void
parameter_list|)
block|{
return|return
call|(
name|value_prof_hooks
operator|->
name|value_profile_transformations
call|)
argument_list|()
return|;
block|}
end_function

begin_escape
end_escape

end_unit

