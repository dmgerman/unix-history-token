begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Transformations based on profile information for values.    Copyright (C) 2003 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"value-prof.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"optabs.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_comment
comment|/* In this file value profile based optimizations will be placed (none are    here just now, but they are hopefully coming soon).     Every such optimization should add its requirements for profiled values to    insn_values_to_profile function.  This function is called from branch_prob    in profile.c and the requested values are instrumented by it in the first    compilation with -fprofile-arcs.  The optimization may then read the    gathered data in the second compilation with -fbranch-probabilities.    The measured data is appended as REG_VALUE_PROFILE note to the instrumented    insn.  The argument to the note consists of an EXPR_LIST where its    members have the following meaning (from the first to the last):        -- type of information gathered (HIST_TYPE*)    -- the expression that is profiled    -- list of counters starting from the first one.  */
end_comment

begin_function_decl
specifier|static
name|void
name|insn_divmod_values_to_profile
parameter_list|(
name|rtx
parameter_list|,
name|unsigned
modifier|*
parameter_list|,
name|struct
name|histogram_value
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|insn_values_to_profile
parameter_list|(
name|rtx
parameter_list|,
name|unsigned
modifier|*
parameter_list|,
name|struct
name|histogram_value
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|gen_divmod_fixed_value
parameter_list|(
name|enum
name|machine_mode
parameter_list|,
name|enum
name|rtx_code
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|gcov_type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|gen_mod_pow2
parameter_list|(
name|enum
name|machine_mode
parameter_list|,
name|enum
name|rtx_code
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|gen_mod_subtract
parameter_list|(
name|enum
name|machine_mode
parameter_list|,
name|enum
name|rtx_code
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|divmod_fixed_value_transform
parameter_list|(
name|rtx
name|insn
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|mod_pow2_value_transform
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|mod_subtract_transform
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* Release the list of VALUES of length N_VALUES for that we want to measure    histograms.  */
end_comment

begin_function
name|void
name|free_profiled_values
parameter_list|(
name|unsigned
name|n_values
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|histogram_value
modifier|*
name|values
parameter_list|)
block|{
name|free
argument_list|(
name|values
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Find values inside INSN for that we want to measure histograms for    division/modulo optimization.  */
end_comment

begin_function
specifier|static
name|void
name|insn_divmod_values_to_profile
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|unsigned
modifier|*
name|n_values
parameter_list|,
name|struct
name|histogram_value
modifier|*
modifier|*
name|values
parameter_list|)
block|{
name|rtx
name|set
decl_stmt|,
name|set_src
decl_stmt|,
name|op1
decl_stmt|,
name|op2
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
return|return;
name|set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|set
condition|)
return|return;
name|mode
operator|=
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|INTEGRAL_MODE_P
argument_list|(
name|mode
argument_list|)
condition|)
return|return;
name|set_src
operator|=
name|SET_SRC
argument_list|(
name|set
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|set_src
argument_list|)
condition|)
block|{
case|case
name|DIV
case|:
case|case
name|MOD
case|:
case|case
name|UDIV
case|:
case|case
name|UMOD
case|:
name|op1
operator|=
name|XEXP
argument_list|(
name|set_src
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op2
operator|=
name|XEXP
argument_list|(
name|set_src
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|side_effects_p
argument_list|(
name|op2
argument_list|)
condition|)
return|return;
comment|/* Check for a special case where the divisor is power of 2.  */
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|set_src
argument_list|)
operator|==
name|UMOD
operator|)
operator|&&
operator|!
name|CONSTANT_P
argument_list|(
name|op2
argument_list|)
condition|)
block|{
operator|*
name|values
operator|=
name|xrealloc
argument_list|(
operator|*
name|values
argument_list|,
operator|(
operator|*
name|n_values
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|histogram_value
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|values
operator|)
index|[
operator|*
name|n_values
index|]
operator|.
name|value
operator|=
name|op2
expr_stmt|;
operator|(
operator|*
name|values
operator|)
index|[
operator|*
name|n_values
index|]
operator|.
name|seq
operator|=
name|NULL_RTX
expr_stmt|;
operator|(
operator|*
name|values
operator|)
index|[
operator|*
name|n_values
index|]
operator|.
name|mode
operator|=
name|mode
expr_stmt|;
operator|(
operator|*
name|values
operator|)
index|[
operator|*
name|n_values
index|]
operator|.
name|insn
operator|=
name|insn
expr_stmt|;
operator|(
operator|*
name|values
operator|)
index|[
operator|*
name|n_values
index|]
operator|.
name|type
operator|=
name|HIST_TYPE_POW2
expr_stmt|;
operator|(
operator|*
name|values
operator|)
index|[
operator|*
name|n_values
index|]
operator|.
name|hdata
operator|.
name|pow2
operator|.
name|may_be_other
operator|=
literal|1
expr_stmt|;
operator|(
operator|*
name|n_values
operator|)
operator|++
expr_stmt|;
block|}
comment|/* Check whether the divisor is not in fact a constant.  */
if|if
condition|(
operator|!
name|CONSTANT_P
argument_list|(
name|op2
argument_list|)
condition|)
block|{
operator|*
name|values
operator|=
name|xrealloc
argument_list|(
operator|*
name|values
argument_list|,
operator|(
operator|*
name|n_values
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|histogram_value
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|values
operator|)
index|[
operator|*
name|n_values
index|]
operator|.
name|value
operator|=
name|op2
expr_stmt|;
operator|(
operator|*
name|values
operator|)
index|[
operator|*
name|n_values
index|]
operator|.
name|mode
operator|=
name|mode
expr_stmt|;
operator|(
operator|*
name|values
operator|)
index|[
operator|*
name|n_values
index|]
operator|.
name|seq
operator|=
name|NULL_RTX
expr_stmt|;
operator|(
operator|*
name|values
operator|)
index|[
operator|*
name|n_values
index|]
operator|.
name|insn
operator|=
name|insn
expr_stmt|;
operator|(
operator|*
name|values
operator|)
index|[
operator|*
name|n_values
index|]
operator|.
name|type
operator|=
name|HIST_TYPE_SINGLE_VALUE
expr_stmt|;
operator|(
operator|*
name|n_values
operator|)
operator|++
expr_stmt|;
block|}
comment|/* For mod, check whether it is not often a noop (or replaceable by 	 a few subtractions).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|set_src
argument_list|)
operator|==
name|UMOD
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|op1
argument_list|)
condition|)
block|{
name|rtx
name|tmp
decl_stmt|;
operator|*
name|values
operator|=
name|xrealloc
argument_list|(
operator|*
name|values
argument_list|,
operator|(
operator|*
name|n_values
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|histogram_value
argument_list|)
argument_list|)
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|tmp
operator|=
name|simplify_gen_binary
argument_list|(
name|DIV
argument_list|,
name|mode
argument_list|,
name|copy_rtx
argument_list|(
name|op1
argument_list|)
argument_list|,
name|copy_rtx
argument_list|(
name|op2
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|values
operator|)
index|[
operator|*
name|n_values
index|]
operator|.
name|value
operator|=
name|force_operand
argument_list|(
name|tmp
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
operator|(
operator|*
name|values
operator|)
index|[
operator|*
name|n_values
index|]
operator|.
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
operator|(
operator|*
name|values
operator|)
index|[
operator|*
name|n_values
index|]
operator|.
name|mode
operator|=
name|mode
expr_stmt|;
operator|(
operator|*
name|values
operator|)
index|[
operator|*
name|n_values
index|]
operator|.
name|insn
operator|=
name|insn
expr_stmt|;
operator|(
operator|*
name|values
operator|)
index|[
operator|*
name|n_values
index|]
operator|.
name|type
operator|=
name|HIST_TYPE_INTERVAL
expr_stmt|;
operator|(
operator|*
name|values
operator|)
index|[
operator|*
name|n_values
index|]
operator|.
name|hdata
operator|.
name|intvl
operator|.
name|int_start
operator|=
literal|0
expr_stmt|;
operator|(
operator|*
name|values
operator|)
index|[
operator|*
name|n_values
index|]
operator|.
name|hdata
operator|.
name|intvl
operator|.
name|steps
operator|=
literal|2
expr_stmt|;
operator|(
operator|*
name|values
operator|)
index|[
operator|*
name|n_values
index|]
operator|.
name|hdata
operator|.
name|intvl
operator|.
name|may_be_less
operator|=
literal|1
expr_stmt|;
operator|(
operator|*
name|values
operator|)
index|[
operator|*
name|n_values
index|]
operator|.
name|hdata
operator|.
name|intvl
operator|.
name|may_be_more
operator|=
literal|1
expr_stmt|;
operator|(
operator|*
name|n_values
operator|)
operator|++
expr_stmt|;
block|}
return|return;
default|default:
return|return;
block|}
block|}
end_function

begin_comment
comment|/* Find values inside INSN for that we want to measure histograms and adds    them to list VALUES (increasing the record of its length in N_VALUES).  */
end_comment

begin_function
specifier|static
name|void
name|insn_values_to_profile
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|unsigned
modifier|*
name|n_values
parameter_list|,
name|struct
name|histogram_value
modifier|*
modifier|*
name|values
parameter_list|)
block|{
if|if
condition|(
name|flag_value_profile_transformations
condition|)
name|insn_divmod_values_to_profile
argument_list|(
name|insn
argument_list|,
name|n_values
argument_list|,
name|values
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Find list of values for that we want to measure histograms.  */
end_comment

begin_function
name|void
name|find_values_to_profile
parameter_list|(
name|unsigned
modifier|*
name|n_values
parameter_list|,
name|struct
name|histogram_value
modifier|*
modifier|*
name|values
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
operator|*
name|n_values
operator|=
literal|0
expr_stmt|;
operator|*
name|values
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
name|insn_values_to_profile
argument_list|(
name|insn
argument_list|,
name|n_values
argument_list|,
name|values
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|*
name|n_values
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
operator|(
operator|*
name|values
operator|)
index|[
name|i
index|]
operator|.
name|type
condition|)
block|{
case|case
name|HIST_TYPE_INTERVAL
case|:
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Interval counter for insn %d, range %d -- %d.\n"
argument_list|,
name|INSN_UID
argument_list|(
operator|(
operator|*
name|values
operator|)
index|[
name|i
index|]
operator|.
name|insn
argument_list|)
argument_list|,
operator|(
operator|*
name|values
operator|)
index|[
name|i
index|]
operator|.
name|hdata
operator|.
name|intvl
operator|.
name|int_start
argument_list|,
operator|(
operator|(
operator|*
name|values
operator|)
index|[
name|i
index|]
operator|.
name|hdata
operator|.
name|intvl
operator|.
name|int_start
operator|+
operator|(
operator|*
name|values
operator|)
index|[
name|i
index|]
operator|.
name|hdata
operator|.
name|intvl
operator|.
name|steps
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|values
operator|)
index|[
name|i
index|]
operator|.
name|n_counters
operator|=
operator|(
operator|*
name|values
operator|)
index|[
name|i
index|]
operator|.
name|hdata
operator|.
name|intvl
operator|.
name|steps
operator|+
operator|(
operator|(
operator|*
name|values
operator|)
index|[
name|i
index|]
operator|.
name|hdata
operator|.
name|intvl
operator|.
name|may_be_less
condition|?
literal|1
else|:
literal|0
operator|)
operator|+
operator|(
operator|(
operator|*
name|values
operator|)
index|[
name|i
index|]
operator|.
name|hdata
operator|.
name|intvl
operator|.
name|may_be_more
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
break|break;
case|case
name|HIST_TYPE_POW2
case|:
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Pow2 counter for insn %d.\n"
argument_list|,
name|INSN_UID
argument_list|(
operator|(
operator|*
name|values
operator|)
index|[
name|i
index|]
operator|.
name|insn
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|values
operator|)
index|[
name|i
index|]
operator|.
name|n_counters
operator|=
name|GET_MODE_BITSIZE
argument_list|(
operator|(
operator|*
name|values
operator|)
index|[
name|i
index|]
operator|.
name|mode
argument_list|)
operator|+
operator|(
operator|(
operator|*
name|values
operator|)
index|[
name|i
index|]
operator|.
name|hdata
operator|.
name|pow2
operator|.
name|may_be_other
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
break|break;
case|case
name|HIST_TYPE_SINGLE_VALUE
case|:
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Single value counter for insn %d.\n"
argument_list|,
name|INSN_UID
argument_list|(
operator|(
operator|*
name|values
operator|)
index|[
name|i
index|]
operator|.
name|insn
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|values
operator|)
index|[
name|i
index|]
operator|.
name|n_counters
operator|=
literal|3
expr_stmt|;
break|break;
case|case
name|HIST_TYPE_CONST_DELTA
case|:
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Constant delta counter for insn %d.\n"
argument_list|,
name|INSN_UID
argument_list|(
operator|(
operator|*
name|values
operator|)
index|[
name|i
index|]
operator|.
name|insn
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|values
operator|)
index|[
name|i
index|]
operator|.
name|n_counters
operator|=
literal|4
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Main entry point.  Finds REG_VALUE_PROFILE notes from profiler and uses    them to identify and exploit properties of values that are hard to analyze    statically.     We do following transformations:     1)     x = a / b;     where b is almost always a constant N is transformed to     if (b == N)      x = a / N;    else      x = a / b;     Analogically with %     2)     x = a % b     where b is almost always a power of 2 and the division is unsigned    TODO -- handle signed case as well     if ((b& (b - 1)) == 0)      x = a& (b - 1);    else      x = x % b;     Note that when b = 0, no error will occur and x = a; this is correct,    as result of such operation is undefined.     3)     x = a % b     where a is almost always less then b and the division is unsigned    TODO -- handle signed case as well     x = a;    if (x>= b)      x %= b;     4)     x = a % b     where a is almost always less then 2 * b and the division is unsigned    TODO -- handle signed case as well     x = a;    if (x>= b)      x -= b;    if (x>= b)      x %= b;     It would be possible to continue analogically for K * b for other small    K's, but it is probably not useful.     TODO:     There are other useful cases that could be handled by a similar mechanism,    for example:        for (i = 0; i< n; i++)      ...        transform to (for constant N):        if (n == N)      for (i = 0; i< N; i++)        ...    else      for (i = 0; i< n; i++)        ...    making unroller happy.  Since this may grow the code significantly,    we would have to be very careful here.  */
end_comment

begin_function
name|bool
name|value_profile_transformations
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|,
name|next
decl_stmt|;
name|int
name|changed
init|=
name|false
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|next
control|)
block|{
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
continue|continue;
comment|/* Scan for insn carrying a histogram.  */
if|if
condition|(
operator|!
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_VALUE_PROFILE
argument_list|,
literal|0
argument_list|)
condition|)
continue|continue;
comment|/* Ignore cold areas -- we are growing a code.  */
if|if
condition|(
operator|!
name|maybe_hot_bb_p
argument_list|(
name|BLOCK_FOR_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|rtl_dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Trying transformations on insn %d\n"
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|print_rtl_single
argument_list|(
name|rtl_dump_file
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
comment|/* Transformations:  */
if|if
condition|(
name|flag_value_profile_transformations
operator|&&
operator|(
name|mod_subtract_transform
argument_list|(
name|insn
argument_list|)
operator|||
name|divmod_fixed_value_transform
argument_list|(
name|insn
argument_list|)
operator|||
name|mod_pow2_value_transform
argument_list|(
name|insn
argument_list|)
operator|)
condition|)
name|changed
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|changed
condition|)
block|{
name|commit_edge_insertions
argument_list|()
expr_stmt|;
name|allocate_reg_info
argument_list|(
name|max_reg_num
argument_list|()
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
return|return
name|changed
return|;
block|}
end_function

begin_comment
comment|/* Generate code for transformation 1 (with MODE and OPERATION, operands OP1    and OP2 whose value is expected to be VALUE and result TARGET).  */
end_comment

begin_function
specifier|static
name|rtx
name|gen_divmod_fixed_value
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|enum
name|rtx_code
name|operation
parameter_list|,
name|rtx
name|target
parameter_list|,
name|rtx
name|op1
parameter_list|,
name|rtx
name|op2
parameter_list|,
name|gcov_type
name|value
parameter_list|)
block|{
name|rtx
name|tmp
decl_stmt|,
name|tmp1
decl_stmt|;
name|rtx
name|neq_label
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|rtx
name|end_label
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|rtx
name|sequence
decl_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|REG_P
argument_list|(
name|op2
argument_list|)
condition|)
block|{
name|tmp
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|tmp
argument_list|,
name|copy_rtx
argument_list|(
name|op2
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|tmp
operator|=
name|op2
expr_stmt|;
name|do_compare_rtx_and_jump
argument_list|(
name|tmp
argument_list|,
name|GEN_INT
argument_list|(
name|value
argument_list|)
argument_list|,
name|NE
argument_list|,
literal|0
argument_list|,
name|mode
argument_list|,
name|NULL_RTX
argument_list|,
name|NULL_RTX
argument_list|,
name|neq_label
argument_list|)
expr_stmt|;
name|tmp1
operator|=
name|simplify_gen_binary
argument_list|(
name|operation
argument_list|,
name|mode
argument_list|,
name|copy_rtx
argument_list|(
name|op1
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|tmp1
operator|=
name|force_operand
argument_list|(
name|tmp1
argument_list|,
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp1
operator|!=
name|target
condition|)
name|emit_move_insn
argument_list|(
name|copy_rtx
argument_list|(
name|target
argument_list|)
argument_list|,
name|copy_rtx
argument_list|(
name|tmp1
argument_list|)
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_jump
argument_list|(
name|end_label
argument_list|)
argument_list|)
expr_stmt|;
name|emit_barrier
argument_list|()
expr_stmt|;
name|emit_label
argument_list|(
name|neq_label
argument_list|)
expr_stmt|;
name|tmp1
operator|=
name|simplify_gen_binary
argument_list|(
name|operation
argument_list|,
name|mode
argument_list|,
name|copy_rtx
argument_list|(
name|op1
argument_list|)
argument_list|,
name|copy_rtx
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
name|tmp1
operator|=
name|force_operand
argument_list|(
name|tmp1
argument_list|,
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp1
operator|!=
name|target
condition|)
name|emit_move_insn
argument_list|(
name|copy_rtx
argument_list|(
name|target
argument_list|)
argument_list|,
name|copy_rtx
argument_list|(
name|tmp1
argument_list|)
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|end_label
argument_list|)
expr_stmt|;
name|sequence
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|rebuild_jump_labels
argument_list|(
name|sequence
argument_list|)
expr_stmt|;
return|return
name|sequence
return|;
block|}
end_function

begin_comment
comment|/* Do transform 1) on INSN if applicable.  */
end_comment

begin_function
specifier|static
name|bool
name|divmod_fixed_value_transform
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|rtx
name|set
decl_stmt|,
name|set_src
decl_stmt|,
name|set_dest
decl_stmt|,
name|op1
decl_stmt|,
name|op2
decl_stmt|,
name|value
decl_stmt|,
name|histogram
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|gcov_type
name|val
decl_stmt|,
name|count
decl_stmt|,
name|all
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|set
condition|)
return|return
name|false
return|;
name|set_src
operator|=
name|SET_SRC
argument_list|(
name|set
argument_list|)
expr_stmt|;
name|set_dest
operator|=
name|SET_DEST
argument_list|(
name|set
argument_list|)
expr_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|set_src
argument_list|)
expr_stmt|;
name|mode
operator|=
name|GET_MODE
argument_list|(
name|set_dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|!=
name|DIV
operator|&&
name|code
operator|!=
name|MOD
operator|&&
name|code
operator|!=
name|UDIV
operator|&&
name|code
operator|!=
name|UMOD
condition|)
return|return
name|false
return|;
name|op1
operator|=
name|XEXP
argument_list|(
name|set_src
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|op2
operator|=
name|XEXP
argument_list|(
name|set_src
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|histogram
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|histogram
condition|;
name|histogram
operator|=
name|XEXP
argument_list|(
name|histogram
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|histogram
argument_list|)
operator|==
name|REG_VALUE_PROFILE
operator|&&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|histogram
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|GEN_INT
argument_list|(
name|HIST_TYPE_SINGLE_VALUE
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|!
name|histogram
condition|)
return|return
name|false
return|;
name|histogram
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|histogram
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|value
operator|=
name|XEXP
argument_list|(
name|histogram
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|histogram
operator|=
name|XEXP
argument_list|(
name|histogram
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|val
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|histogram
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|histogram
operator|=
name|XEXP
argument_list|(
name|histogram
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|count
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|histogram
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|histogram
operator|=
name|XEXP
argument_list|(
name|histogram
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|all
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|histogram
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We require that count is at least half of all; this means      that for the transformation to fire the value must be constant      at least 50% of time (and 75% gives the guarantee of usage).  */
if|if
condition|(
operator|!
name|rtx_equal_p
argument_list|(
name|op2
argument_list|,
name|value
argument_list|)
operator|||
literal|2
operator|*
name|count
operator|<
name|all
condition|)
return|return
name|false
return|;
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Div/mod by constant transformation on insn %d\n"
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|e
operator|=
name|split_block
argument_list|(
name|BLOCK_FOR_INSN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|delete_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|insert_insn_on_edge
argument_list|(
name|gen_divmod_fixed_value
argument_list|(
name|mode
argument_list|,
name|code
argument_list|,
name|set_dest
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|,
name|val
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Generate code for transformation 2 (with MODE and OPERATION, operands OP1    and OP2 and result TARGET).  */
end_comment

begin_function
specifier|static
name|rtx
name|gen_mod_pow2
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|enum
name|rtx_code
name|operation
parameter_list|,
name|rtx
name|target
parameter_list|,
name|rtx
name|op1
parameter_list|,
name|rtx
name|op2
parameter_list|)
block|{
name|rtx
name|tmp
decl_stmt|,
name|tmp1
decl_stmt|,
name|tmp2
decl_stmt|,
name|tmp3
decl_stmt|;
name|rtx
name|neq_label
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|rtx
name|end_label
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|rtx
name|sequence
decl_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|REG_P
argument_list|(
name|op2
argument_list|)
condition|)
block|{
name|tmp
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|tmp
argument_list|,
name|copy_rtx
argument_list|(
name|op2
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|tmp
operator|=
name|op2
expr_stmt|;
name|tmp1
operator|=
name|expand_simple_binop
argument_list|(
name|mode
argument_list|,
name|PLUS
argument_list|,
name|tmp
argument_list|,
name|constm1_rtx
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
name|tmp2
operator|=
name|expand_simple_binop
argument_list|(
name|mode
argument_list|,
name|AND
argument_list|,
name|tmp
argument_list|,
name|tmp1
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
name|do_compare_rtx_and_jump
argument_list|(
name|tmp2
argument_list|,
name|const0_rtx
argument_list|,
name|NE
argument_list|,
literal|0
argument_list|,
name|mode
argument_list|,
name|NULL_RTX
argument_list|,
name|NULL_RTX
argument_list|,
name|neq_label
argument_list|)
expr_stmt|;
name|tmp3
operator|=
name|expand_simple_binop
argument_list|(
name|mode
argument_list|,
name|AND
argument_list|,
name|op1
argument_list|,
name|tmp1
argument_list|,
name|target
argument_list|,
literal|0
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp3
operator|!=
name|target
condition|)
name|emit_move_insn
argument_list|(
name|copy_rtx
argument_list|(
name|target
argument_list|)
argument_list|,
name|tmp3
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_jump
argument_list|(
name|end_label
argument_list|)
argument_list|)
expr_stmt|;
name|emit_barrier
argument_list|()
expr_stmt|;
name|emit_label
argument_list|(
name|neq_label
argument_list|)
expr_stmt|;
name|tmp1
operator|=
name|simplify_gen_binary
argument_list|(
name|operation
argument_list|,
name|mode
argument_list|,
name|copy_rtx
argument_list|(
name|op1
argument_list|)
argument_list|,
name|copy_rtx
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
name|tmp1
operator|=
name|force_operand
argument_list|(
name|tmp1
argument_list|,
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp1
operator|!=
name|target
condition|)
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|tmp1
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|end_label
argument_list|)
expr_stmt|;
name|sequence
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|rebuild_jump_labels
argument_list|(
name|sequence
argument_list|)
expr_stmt|;
return|return
name|sequence
return|;
block|}
end_function

begin_comment
comment|/* Do transform 2) on INSN if applicable.  */
end_comment

begin_function
specifier|static
name|bool
name|mod_pow2_value_transform
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|rtx
name|set
decl_stmt|,
name|set_src
decl_stmt|,
name|set_dest
decl_stmt|,
name|op1
decl_stmt|,
name|op2
decl_stmt|,
name|value
decl_stmt|,
name|histogram
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|gcov_type
name|wrong_values
decl_stmt|,
name|count
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|int
name|i
decl_stmt|;
name|set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|set
condition|)
return|return
name|false
return|;
name|set_src
operator|=
name|SET_SRC
argument_list|(
name|set
argument_list|)
expr_stmt|;
name|set_dest
operator|=
name|SET_DEST
argument_list|(
name|set
argument_list|)
expr_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|set_src
argument_list|)
expr_stmt|;
name|mode
operator|=
name|GET_MODE
argument_list|(
name|set_dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|!=
name|UMOD
condition|)
return|return
name|false
return|;
name|op1
operator|=
name|XEXP
argument_list|(
name|set_src
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op2
operator|=
name|XEXP
argument_list|(
name|set_src
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|histogram
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|histogram
condition|;
name|histogram
operator|=
name|XEXP
argument_list|(
name|histogram
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|histogram
argument_list|)
operator|==
name|REG_VALUE_PROFILE
operator|&&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|histogram
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|GEN_INT
argument_list|(
name|HIST_TYPE_POW2
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|!
name|histogram
condition|)
return|return
name|false
return|;
name|histogram
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|histogram
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|value
operator|=
name|XEXP
argument_list|(
name|histogram
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|histogram
operator|=
name|XEXP
argument_list|(
name|histogram
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|wrong_values
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|histogram
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|histogram
operator|=
name|XEXP
argument_list|(
name|histogram
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|count
operator|+=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|histogram
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|histogram
operator|=
name|XEXP
argument_list|(
name|histogram
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|rtx_equal_p
argument_list|(
name|op2
argument_list|,
name|value
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* We require that we hit a power of two at least half of all evaluations.  */
if|if
condition|(
name|count
operator|<
name|wrong_values
condition|)
return|return
name|false
return|;
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Mod power of 2 transformation on insn %d\n"
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|e
operator|=
name|split_block
argument_list|(
name|BLOCK_FOR_INSN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|delete_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|insert_insn_on_edge
argument_list|(
name|gen_mod_pow2
argument_list|(
name|mode
argument_list|,
name|code
argument_list|,
name|set_dest
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Generate code for transformations 3 and 4 (with MODE and OPERATION,    operands OP1 and OP2, result TARGET and at most SUB subtractions).  */
end_comment

begin_function
specifier|static
name|rtx
name|gen_mod_subtract
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|enum
name|rtx_code
name|operation
parameter_list|,
name|rtx
name|target
parameter_list|,
name|rtx
name|op1
parameter_list|,
name|rtx
name|op2
parameter_list|,
name|int
name|sub
parameter_list|)
block|{
name|rtx
name|tmp
decl_stmt|,
name|tmp1
decl_stmt|;
name|rtx
name|end_label
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|rtx
name|sequence
decl_stmt|;
name|int
name|i
decl_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|REG_P
argument_list|(
name|op2
argument_list|)
condition|)
block|{
name|tmp
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|tmp
argument_list|,
name|copy_rtx
argument_list|(
name|op2
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|tmp
operator|=
name|op2
expr_stmt|;
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|copy_rtx
argument_list|(
name|op1
argument_list|)
argument_list|)
expr_stmt|;
name|do_compare_rtx_and_jump
argument_list|(
name|target
argument_list|,
name|tmp
argument_list|,
name|LTU
argument_list|,
literal|0
argument_list|,
name|mode
argument_list|,
name|NULL_RTX
argument_list|,
name|NULL_RTX
argument_list|,
name|end_label
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sub
condition|;
name|i
operator|++
control|)
block|{
name|tmp1
operator|=
name|expand_simple_binop
argument_list|(
name|mode
argument_list|,
name|MINUS
argument_list|,
name|target
argument_list|,
name|tmp
argument_list|,
name|target
argument_list|,
literal|0
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp1
operator|!=
name|target
condition|)
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|tmp1
argument_list|)
expr_stmt|;
name|do_compare_rtx_and_jump
argument_list|(
name|target
argument_list|,
name|tmp
argument_list|,
name|LTU
argument_list|,
literal|0
argument_list|,
name|mode
argument_list|,
name|NULL_RTX
argument_list|,
name|NULL_RTX
argument_list|,
name|end_label
argument_list|)
expr_stmt|;
block|}
name|tmp1
operator|=
name|simplify_gen_binary
argument_list|(
name|operation
argument_list|,
name|mode
argument_list|,
name|copy_rtx
argument_list|(
name|target
argument_list|)
argument_list|,
name|copy_rtx
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
name|tmp1
operator|=
name|force_operand
argument_list|(
name|tmp1
argument_list|,
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp1
operator|!=
name|target
condition|)
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|tmp1
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|end_label
argument_list|)
expr_stmt|;
name|sequence
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|rebuild_jump_labels
argument_list|(
name|sequence
argument_list|)
expr_stmt|;
return|return
name|sequence
return|;
block|}
end_function

begin_comment
comment|/* Do transforms 3) and 4) on INSN if applicable.  */
end_comment

begin_function
specifier|static
name|bool
name|mod_subtract_transform
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|rtx
name|set
decl_stmt|,
name|set_src
decl_stmt|,
name|set_dest
decl_stmt|,
name|op1
decl_stmt|,
name|op2
decl_stmt|,
name|value
decl_stmt|,
name|histogram
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|gcov_type
name|wrong_values
decl_stmt|,
name|counts
index|[
literal|2
index|]
decl_stmt|,
name|count
decl_stmt|,
name|all
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|int
name|i
decl_stmt|;
name|set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|set
condition|)
return|return
name|false
return|;
name|set_src
operator|=
name|SET_SRC
argument_list|(
name|set
argument_list|)
expr_stmt|;
name|set_dest
operator|=
name|SET_DEST
argument_list|(
name|set
argument_list|)
expr_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|set_src
argument_list|)
expr_stmt|;
name|mode
operator|=
name|GET_MODE
argument_list|(
name|set_dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|!=
name|UMOD
condition|)
return|return
name|false
return|;
name|op1
operator|=
name|XEXP
argument_list|(
name|set_src
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op2
operator|=
name|XEXP
argument_list|(
name|set_src
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|histogram
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|histogram
condition|;
name|histogram
operator|=
name|XEXP
argument_list|(
name|histogram
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|histogram
argument_list|)
operator|==
name|REG_VALUE_PROFILE
operator|&&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|histogram
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|GEN_INT
argument_list|(
name|HIST_TYPE_INTERVAL
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|!
name|histogram
condition|)
return|return
name|false
return|;
name|histogram
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|histogram
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|value
operator|=
name|XEXP
argument_list|(
name|histogram
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|histogram
operator|=
name|XEXP
argument_list|(
name|histogram
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|all
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|counts
index|[
name|i
index|]
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|histogram
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|all
operator|+=
name|counts
index|[
name|i
index|]
expr_stmt|;
name|histogram
operator|=
name|XEXP
argument_list|(
name|histogram
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|wrong_values
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|histogram
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|histogram
operator|=
name|XEXP
argument_list|(
name|histogram
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|wrong_values
operator|+=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|histogram
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|all
operator|+=
name|wrong_values
expr_stmt|;
comment|/* We require that we use just subtractions in at least 50% of all      evaluations.  */
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|count
operator|+=
name|counts
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|count
operator|*
literal|2
operator|>=
name|all
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
literal|2
condition|)
return|return
name|false
return|;
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Mod subtract transformation on insn %d\n"
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|e
operator|=
name|split_block
argument_list|(
name|BLOCK_FOR_INSN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|delete_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|insert_insn_on_edge
argument_list|(
name|gen_mod_subtract
argument_list|(
name|mode
argument_list|,
name|code
argument_list|,
name|set_dest
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|,
name|i
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

end_unit

