begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ET-trees data structure implementation.    Contributed by Pavel Nejedly    Copyright (C) 2002, 2003, 2004, 2005 Free Software Foundation, Inc.  This file is part of the libiberty library. Libiberty is free software; you can redistribute it and/or modify it under the terms of the GNU Library General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  Libiberty is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public License for more details.  You should have received a copy of the GNU Library General Public License along with libiberty; see the file COPYING.LIB.  If not, write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.    The ET-forest structure is described in:     D. D. Sleator and R. E. Tarjan. A data structure for dynamic trees.     J.  G'omput. System Sci., 26(3):362 381, 1983. */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"et-forest.h"
end_include

begin_include
include|#
directive|include
file|"alloc-pool.h"
end_include

begin_comment
comment|/* We do not enable this with ENABLE_CHECKING, since it is awfully slow.  */
end_comment

begin_undef
undef|#
directive|undef
name|DEBUG_ET
end_undef

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG_ET
end_ifdef

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The occurrence of a node in the et tree.  */
end_comment

begin_struct
struct|struct
name|et_occ
block|{
name|struct
name|et_node
modifier|*
name|of
decl_stmt|;
comment|/* The node.  */
name|struct
name|et_occ
modifier|*
name|parent
decl_stmt|;
comment|/* Parent in the splay-tree.  */
name|struct
name|et_occ
modifier|*
name|prev
decl_stmt|;
comment|/* Left son in the splay-tree.  */
name|struct
name|et_occ
modifier|*
name|next
decl_stmt|;
comment|/* Right son in the splay-tree.  */
name|int
name|depth
decl_stmt|;
comment|/* The depth of the node is the sum of depth 				   fields on the path to the root.  */
name|int
name|min
decl_stmt|;
comment|/* The minimum value of the depth in the subtree 				   is obtained by adding sum of depth fields 				   on the path to the root.  */
name|struct
name|et_occ
modifier|*
name|min_occ
decl_stmt|;
comment|/* The occurrence in the subtree with the minimal 				   depth.  */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|alloc_pool
name|et_nodes
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|alloc_pool
name|et_occurrences
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Changes depth of OCC to D.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|set_depth
parameter_list|(
name|struct
name|et_occ
modifier|*
name|occ
parameter_list|,
name|int
name|d
parameter_list|)
block|{
if|if
condition|(
operator|!
name|occ
condition|)
return|return;
name|occ
operator|->
name|min
operator|+=
name|d
operator|-
name|occ
operator|->
name|depth
expr_stmt|;
name|occ
operator|->
name|depth
operator|=
name|d
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Adds D to the depth of OCC.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|set_depth_add
parameter_list|(
name|struct
name|et_occ
modifier|*
name|occ
parameter_list|,
name|int
name|d
parameter_list|)
block|{
if|if
condition|(
operator|!
name|occ
condition|)
return|return;
name|occ
operator|->
name|min
operator|+=
name|d
expr_stmt|;
name|occ
operator|->
name|depth
operator|+=
name|d
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Sets prev field of OCC to P.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|set_prev
parameter_list|(
name|struct
name|et_occ
modifier|*
name|occ
parameter_list|,
name|struct
name|et_occ
modifier|*
name|t
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|DEBUG_ET
name|gcc_assert
argument_list|(
name|occ
operator|!=
name|t
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|occ
operator|->
name|prev
operator|=
name|t
expr_stmt|;
if|if
condition|(
name|t
condition|)
name|t
operator|->
name|parent
operator|=
name|occ
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Sets next field of OCC to P.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|set_next
parameter_list|(
name|struct
name|et_occ
modifier|*
name|occ
parameter_list|,
name|struct
name|et_occ
modifier|*
name|t
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|DEBUG_ET
name|gcc_assert
argument_list|(
name|occ
operator|!=
name|t
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|occ
operator|->
name|next
operator|=
name|t
expr_stmt|;
if|if
condition|(
name|t
condition|)
name|t
operator|->
name|parent
operator|=
name|occ
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Recompute minimum for occurrence OCC.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|et_recomp_min
parameter_list|(
name|struct
name|et_occ
modifier|*
name|occ
parameter_list|)
block|{
name|struct
name|et_occ
modifier|*
name|mson
init|=
name|occ
operator|->
name|prev
decl_stmt|;
if|if
condition|(
operator|!
name|mson
operator|||
operator|(
name|occ
operator|->
name|next
operator|&&
name|mson
operator|->
name|min
operator|>
name|occ
operator|->
name|next
operator|->
name|min
operator|)
condition|)
name|mson
operator|=
name|occ
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|mson
operator|&&
name|mson
operator|->
name|min
operator|<
literal|0
condition|)
block|{
name|occ
operator|->
name|min
operator|=
name|mson
operator|->
name|min
operator|+
name|occ
operator|->
name|depth
expr_stmt|;
name|occ
operator|->
name|min_occ
operator|=
name|mson
operator|->
name|min_occ
expr_stmt|;
block|}
else|else
block|{
name|occ
operator|->
name|min
operator|=
name|occ
operator|->
name|depth
expr_stmt|;
name|occ
operator|->
name|min_occ
operator|=
name|occ
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG_ET
end_ifdef

begin_comment
comment|/* Checks whether neighborhood of OCC seems sane.  */
end_comment

begin_function
specifier|static
name|void
name|et_check_occ_sanity
parameter_list|(
name|struct
name|et_occ
modifier|*
name|occ
parameter_list|)
block|{
if|if
condition|(
operator|!
name|occ
condition|)
return|return;
name|gcc_assert
argument_list|(
name|occ
operator|->
name|parent
operator|!=
name|occ
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|occ
operator|->
name|prev
operator|!=
name|occ
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|occ
operator|->
name|next
operator|!=
name|occ
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|occ
operator|->
name|next
operator|||
name|occ
operator|->
name|next
operator|!=
name|occ
operator|->
name|prev
argument_list|)
expr_stmt|;
if|if
condition|(
name|occ
operator|->
name|next
condition|)
block|{
name|gcc_assert
argument_list|(
name|occ
operator|->
name|next
operator|!=
name|occ
operator|->
name|parent
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|occ
operator|->
name|next
operator|->
name|parent
operator|==
name|occ
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|occ
operator|->
name|prev
condition|)
block|{
name|gcc_assert
argument_list|(
name|occ
operator|->
name|prev
operator|!=
name|occ
operator|->
name|parent
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|occ
operator|->
name|prev
operator|->
name|parent
operator|==
name|occ
argument_list|)
expr_stmt|;
block|}
name|gcc_assert
argument_list|(
operator|!
name|occ
operator|->
name|parent
operator|||
name|occ
operator|->
name|parent
operator|->
name|prev
operator|==
name|occ
operator|||
name|occ
operator|->
name|parent
operator|->
name|next
operator|==
name|occ
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Checks whether tree rooted at OCC is sane.  */
end_comment

begin_function
specifier|static
name|void
name|et_check_sanity
parameter_list|(
name|struct
name|et_occ
modifier|*
name|occ
parameter_list|)
block|{
name|et_check_occ_sanity
argument_list|(
name|occ
argument_list|)
expr_stmt|;
if|if
condition|(
name|occ
operator|->
name|prev
condition|)
name|et_check_sanity
argument_list|(
name|occ
operator|->
name|prev
argument_list|)
expr_stmt|;
if|if
condition|(
name|occ
operator|->
name|next
condition|)
name|et_check_sanity
argument_list|(
name|occ
operator|->
name|next
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Checks whether tree containing OCC is sane.  */
end_comment

begin_function
specifier|static
name|void
name|et_check_tree_sanity
parameter_list|(
name|struct
name|et_occ
modifier|*
name|occ
parameter_list|)
block|{
while|while
condition|(
name|occ
operator|->
name|parent
condition|)
name|occ
operator|=
name|occ
operator|->
name|parent
expr_stmt|;
name|et_check_sanity
argument_list|(
name|occ
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* For recording the paths.  */
end_comment

begin_comment
comment|/* An ad-hoc constant; if the function has more blocks, this won't work,    but since it is used for debugging only, it does not matter.  */
end_comment

begin_define
define|#
directive|define
name|MAX_NODES
value|100000
end_define

begin_decl_stmt
specifier|static
name|int
name|len
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
modifier|*
name|datas
index|[
name|MAX_NODES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|depths
index|[
name|MAX_NODES
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Records the path represented by OCC, with depth incremented by DEPTH.  */
end_comment

begin_function
specifier|static
name|int
name|record_path_before_1
parameter_list|(
name|struct
name|et_occ
modifier|*
name|occ
parameter_list|,
name|int
name|depth
parameter_list|)
block|{
name|int
name|mn
decl_stmt|,
name|m
decl_stmt|;
name|depth
operator|+=
name|occ
operator|->
name|depth
expr_stmt|;
name|mn
operator|=
name|depth
expr_stmt|;
if|if
condition|(
name|occ
operator|->
name|prev
condition|)
block|{
name|m
operator|=
name|record_path_before_1
argument_list|(
name|occ
operator|->
name|prev
argument_list|,
name|depth
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|<
name|mn
condition|)
name|mn
operator|=
name|m
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d (%d); "
argument_list|,
operator|(
operator|(
name|basic_block
operator|)
name|occ
operator|->
name|of
operator|->
name|data
operator|)
operator|->
name|index
argument_list|,
name|depth
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|len
operator|<
name|MAX_NODES
argument_list|)
expr_stmt|;
name|depths
index|[
name|len
index|]
operator|=
name|depth
expr_stmt|;
name|datas
index|[
name|len
index|]
operator|=
name|occ
operator|->
name|of
expr_stmt|;
name|len
operator|++
expr_stmt|;
if|if
condition|(
name|occ
operator|->
name|next
condition|)
block|{
name|m
operator|=
name|record_path_before_1
argument_list|(
name|occ
operator|->
name|next
argument_list|,
name|depth
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|<
name|mn
condition|)
name|mn
operator|=
name|m
expr_stmt|;
block|}
name|gcc_assert
argument_list|(
name|mn
operator|==
name|occ
operator|->
name|min
operator|+
name|depth
operator|-
name|occ
operator|->
name|depth
argument_list|)
expr_stmt|;
return|return
name|mn
return|;
block|}
end_function

begin_comment
comment|/* Records the path represented by a tree containing OCC.  */
end_comment

begin_function
specifier|static
name|void
name|record_path_before
parameter_list|(
name|struct
name|et_occ
modifier|*
name|occ
parameter_list|)
block|{
while|while
condition|(
name|occ
operator|->
name|parent
condition|)
name|occ
operator|=
name|occ
operator|->
name|parent
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
name|record_path_before_1
argument_list|(
name|occ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Checks whether the path represented by OCC, with depth incremented by DEPTH,    was not changed since the last recording.  */
end_comment

begin_function
specifier|static
name|int
name|check_path_after_1
parameter_list|(
name|struct
name|et_occ
modifier|*
name|occ
parameter_list|,
name|int
name|depth
parameter_list|)
block|{
name|int
name|mn
decl_stmt|,
name|m
decl_stmt|;
name|depth
operator|+=
name|occ
operator|->
name|depth
expr_stmt|;
name|mn
operator|=
name|depth
expr_stmt|;
if|if
condition|(
name|occ
operator|->
name|next
condition|)
block|{
name|m
operator|=
name|check_path_after_1
argument_list|(
name|occ
operator|->
name|next
argument_list|,
name|depth
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|<
name|mn
condition|)
name|mn
operator|=
name|m
expr_stmt|;
block|}
name|len
operator|--
expr_stmt|;
name|gcc_assert
argument_list|(
name|depths
index|[
name|len
index|]
operator|==
name|depth
operator|&&
name|datas
index|[
name|len
index|]
operator|==
name|occ
operator|->
name|of
argument_list|)
expr_stmt|;
if|if
condition|(
name|occ
operator|->
name|prev
condition|)
block|{
name|m
operator|=
name|check_path_after_1
argument_list|(
name|occ
operator|->
name|prev
argument_list|,
name|depth
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|<
name|mn
condition|)
name|mn
operator|=
name|m
expr_stmt|;
block|}
name|gcc_assert
argument_list|(
name|mn
operator|==
name|occ
operator|->
name|min
operator|+
name|depth
operator|-
name|occ
operator|->
name|depth
argument_list|)
expr_stmt|;
return|return
name|mn
return|;
block|}
end_function

begin_comment
comment|/* Checks whether the path represented by a tree containing OCC was    not changed since the last recording.  */
end_comment

begin_function
specifier|static
name|void
name|check_path_after
parameter_list|(
name|struct
name|et_occ
modifier|*
name|occ
parameter_list|)
block|{
while|while
condition|(
name|occ
operator|->
name|parent
condition|)
name|occ
operator|=
name|occ
operator|->
name|parent
expr_stmt|;
name|check_path_after_1
argument_list|(
name|occ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Splay the occurrence OCC to the root of the tree.  */
end_comment

begin_function
specifier|static
name|void
name|et_splay
parameter_list|(
name|struct
name|et_occ
modifier|*
name|occ
parameter_list|)
block|{
name|struct
name|et_occ
modifier|*
name|f
decl_stmt|,
modifier|*
name|gf
decl_stmt|,
modifier|*
name|ggf
decl_stmt|;
name|int
name|occ_depth
decl_stmt|,
name|f_depth
decl_stmt|,
name|gf_depth
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_ET
name|record_path_before
argument_list|(
name|occ
argument_list|)
expr_stmt|;
name|et_check_tree_sanity
argument_list|(
name|occ
argument_list|)
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
name|occ
operator|->
name|parent
condition|)
block|{
name|occ_depth
operator|=
name|occ
operator|->
name|depth
expr_stmt|;
name|f
operator|=
name|occ
operator|->
name|parent
expr_stmt|;
name|f_depth
operator|=
name|f
operator|->
name|depth
expr_stmt|;
name|gf
operator|=
name|f
operator|->
name|parent
expr_stmt|;
if|if
condition|(
operator|!
name|gf
condition|)
block|{
name|set_depth_add
argument_list|(
name|occ
argument_list|,
name|f_depth
argument_list|)
expr_stmt|;
name|occ
operator|->
name|min_occ
operator|=
name|f
operator|->
name|min_occ
expr_stmt|;
name|occ
operator|->
name|min
operator|=
name|f
operator|->
name|min
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|prev
operator|==
name|occ
condition|)
block|{
comment|/* zig */
name|set_prev
argument_list|(
name|f
argument_list|,
name|occ
operator|->
name|next
argument_list|)
expr_stmt|;
name|set_next
argument_list|(
name|occ
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|set_depth_add
argument_list|(
name|f
operator|->
name|prev
argument_list|,
name|occ_depth
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* zag */
name|set_next
argument_list|(
name|f
argument_list|,
name|occ
operator|->
name|prev
argument_list|)
expr_stmt|;
name|set_prev
argument_list|(
name|occ
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|set_depth_add
argument_list|(
name|f
operator|->
name|next
argument_list|,
name|occ_depth
argument_list|)
expr_stmt|;
block|}
name|set_depth
argument_list|(
name|f
argument_list|,
operator|-
name|occ_depth
argument_list|)
expr_stmt|;
name|occ
operator|->
name|parent
operator|=
name|NULL
expr_stmt|;
name|et_recomp_min
argument_list|(
name|f
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_ET
name|et_check_tree_sanity
argument_list|(
name|occ
argument_list|)
expr_stmt|;
name|check_path_after
argument_list|(
name|occ
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
name|gf_depth
operator|=
name|gf
operator|->
name|depth
expr_stmt|;
name|set_depth_add
argument_list|(
name|occ
argument_list|,
name|f_depth
operator|+
name|gf_depth
argument_list|)
expr_stmt|;
name|occ
operator|->
name|min_occ
operator|=
name|gf
operator|->
name|min_occ
expr_stmt|;
name|occ
operator|->
name|min
operator|=
name|gf
operator|->
name|min
expr_stmt|;
name|ggf
operator|=
name|gf
operator|->
name|parent
expr_stmt|;
if|if
condition|(
name|gf
operator|->
name|prev
operator|==
name|f
condition|)
block|{
if|if
condition|(
name|f
operator|->
name|prev
operator|==
name|occ
condition|)
block|{
comment|/* zig zig */
name|set_prev
argument_list|(
name|gf
argument_list|,
name|f
operator|->
name|next
argument_list|)
expr_stmt|;
name|set_prev
argument_list|(
name|f
argument_list|,
name|occ
operator|->
name|next
argument_list|)
expr_stmt|;
name|set_next
argument_list|(
name|occ
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|set_next
argument_list|(
name|f
argument_list|,
name|gf
argument_list|)
expr_stmt|;
name|set_depth
argument_list|(
name|f
argument_list|,
operator|-
name|occ_depth
argument_list|)
expr_stmt|;
name|set_depth_add
argument_list|(
name|f
operator|->
name|prev
argument_list|,
name|occ_depth
argument_list|)
expr_stmt|;
name|set_depth
argument_list|(
name|gf
argument_list|,
operator|-
name|f_depth
argument_list|)
expr_stmt|;
name|set_depth_add
argument_list|(
name|gf
operator|->
name|prev
argument_list|,
name|f_depth
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* zag zig */
name|set_prev
argument_list|(
name|gf
argument_list|,
name|occ
operator|->
name|next
argument_list|)
expr_stmt|;
name|set_next
argument_list|(
name|f
argument_list|,
name|occ
operator|->
name|prev
argument_list|)
expr_stmt|;
name|set_prev
argument_list|(
name|occ
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|set_next
argument_list|(
name|occ
argument_list|,
name|gf
argument_list|)
expr_stmt|;
name|set_depth
argument_list|(
name|f
argument_list|,
operator|-
name|occ_depth
argument_list|)
expr_stmt|;
name|set_depth_add
argument_list|(
name|f
operator|->
name|next
argument_list|,
name|occ_depth
argument_list|)
expr_stmt|;
name|set_depth
argument_list|(
name|gf
argument_list|,
operator|-
name|occ_depth
operator|-
name|f_depth
argument_list|)
expr_stmt|;
name|set_depth_add
argument_list|(
name|gf
operator|->
name|prev
argument_list|,
name|occ_depth
operator|+
name|f_depth
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|f
operator|->
name|prev
operator|==
name|occ
condition|)
block|{
comment|/* zig zag */
name|set_next
argument_list|(
name|gf
argument_list|,
name|occ
operator|->
name|prev
argument_list|)
expr_stmt|;
name|set_prev
argument_list|(
name|f
argument_list|,
name|occ
operator|->
name|next
argument_list|)
expr_stmt|;
name|set_prev
argument_list|(
name|occ
argument_list|,
name|gf
argument_list|)
expr_stmt|;
name|set_next
argument_list|(
name|occ
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|set_depth
argument_list|(
name|f
argument_list|,
operator|-
name|occ_depth
argument_list|)
expr_stmt|;
name|set_depth_add
argument_list|(
name|f
operator|->
name|prev
argument_list|,
name|occ_depth
argument_list|)
expr_stmt|;
name|set_depth
argument_list|(
name|gf
argument_list|,
operator|-
name|occ_depth
operator|-
name|f_depth
argument_list|)
expr_stmt|;
name|set_depth_add
argument_list|(
name|gf
operator|->
name|next
argument_list|,
name|occ_depth
operator|+
name|f_depth
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* zag zag */
name|set_next
argument_list|(
name|gf
argument_list|,
name|f
operator|->
name|prev
argument_list|)
expr_stmt|;
name|set_next
argument_list|(
name|f
argument_list|,
name|occ
operator|->
name|prev
argument_list|)
expr_stmt|;
name|set_prev
argument_list|(
name|occ
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|set_prev
argument_list|(
name|f
argument_list|,
name|gf
argument_list|)
expr_stmt|;
name|set_depth
argument_list|(
name|f
argument_list|,
operator|-
name|occ_depth
argument_list|)
expr_stmt|;
name|set_depth_add
argument_list|(
name|f
operator|->
name|next
argument_list|,
name|occ_depth
argument_list|)
expr_stmt|;
name|set_depth
argument_list|(
name|gf
argument_list|,
operator|-
name|f_depth
argument_list|)
expr_stmt|;
name|set_depth_add
argument_list|(
name|gf
operator|->
name|next
argument_list|,
name|f_depth
argument_list|)
expr_stmt|;
block|}
block|}
name|occ
operator|->
name|parent
operator|=
name|ggf
expr_stmt|;
if|if
condition|(
name|ggf
condition|)
block|{
if|if
condition|(
name|ggf
operator|->
name|prev
operator|==
name|gf
condition|)
name|ggf
operator|->
name|prev
operator|=
name|occ
expr_stmt|;
else|else
name|ggf
operator|->
name|next
operator|=
name|occ
expr_stmt|;
block|}
name|et_recomp_min
argument_list|(
name|gf
argument_list|)
expr_stmt|;
name|et_recomp_min
argument_list|(
name|f
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_ET
name|et_check_tree_sanity
argument_list|(
name|occ
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|DEBUG_ET
name|et_check_sanity
argument_list|(
name|occ
argument_list|)
expr_stmt|;
name|check_path_after
argument_list|(
name|occ
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Create a new et tree occurrence of NODE.  */
end_comment

begin_function
specifier|static
name|struct
name|et_occ
modifier|*
name|et_new_occ
parameter_list|(
name|struct
name|et_node
modifier|*
name|node
parameter_list|)
block|{
name|struct
name|et_occ
modifier|*
name|nw
decl_stmt|;
if|if
condition|(
operator|!
name|et_occurrences
condition|)
name|et_occurrences
operator|=
name|create_alloc_pool
argument_list|(
literal|"et_occ pool"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|et_occ
argument_list|)
argument_list|,
literal|300
argument_list|)
expr_stmt|;
name|nw
operator|=
name|pool_alloc
argument_list|(
name|et_occurrences
argument_list|)
expr_stmt|;
name|nw
operator|->
name|of
operator|=
name|node
expr_stmt|;
name|nw
operator|->
name|parent
operator|=
name|NULL
expr_stmt|;
name|nw
operator|->
name|prev
operator|=
name|NULL
expr_stmt|;
name|nw
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|nw
operator|->
name|depth
operator|=
literal|0
expr_stmt|;
name|nw
operator|->
name|min_occ
operator|=
name|nw
expr_stmt|;
name|nw
operator|->
name|min
operator|=
literal|0
expr_stmt|;
return|return
name|nw
return|;
block|}
end_function

begin_comment
comment|/* Create a new et tree containing DATA.  */
end_comment

begin_function
name|struct
name|et_node
modifier|*
name|et_new_tree
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|et_node
modifier|*
name|nw
decl_stmt|;
if|if
condition|(
operator|!
name|et_nodes
condition|)
name|et_nodes
operator|=
name|create_alloc_pool
argument_list|(
literal|"et_node pool"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|et_node
argument_list|)
argument_list|,
literal|300
argument_list|)
expr_stmt|;
name|nw
operator|=
name|pool_alloc
argument_list|(
name|et_nodes
argument_list|)
expr_stmt|;
name|nw
operator|->
name|data
operator|=
name|data
expr_stmt|;
name|nw
operator|->
name|father
operator|=
name|NULL
expr_stmt|;
name|nw
operator|->
name|left
operator|=
name|NULL
expr_stmt|;
name|nw
operator|->
name|right
operator|=
name|NULL
expr_stmt|;
name|nw
operator|->
name|son
operator|=
name|NULL
expr_stmt|;
name|nw
operator|->
name|rightmost_occ
operator|=
name|et_new_occ
argument_list|(
name|nw
argument_list|)
expr_stmt|;
name|nw
operator|->
name|parent_occ
operator|=
name|NULL
expr_stmt|;
return|return
name|nw
return|;
block|}
end_function

begin_comment
comment|/* Releases et tree T.  */
end_comment

begin_function
name|void
name|et_free_tree
parameter_list|(
name|struct
name|et_node
modifier|*
name|t
parameter_list|)
block|{
while|while
condition|(
name|t
operator|->
name|son
condition|)
name|et_split
argument_list|(
name|t
operator|->
name|son
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|father
condition|)
name|et_split
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|pool_free
argument_list|(
name|et_occurrences
argument_list|,
name|t
operator|->
name|rightmost_occ
argument_list|)
expr_stmt|;
name|pool_free
argument_list|(
name|et_nodes
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Releases et tree T without maintaining other nodes.  */
end_comment

begin_function
name|void
name|et_free_tree_force
parameter_list|(
name|struct
name|et_node
modifier|*
name|t
parameter_list|)
block|{
name|pool_free
argument_list|(
name|et_occurrences
argument_list|,
name|t
operator|->
name|rightmost_occ
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|parent_occ
condition|)
name|pool_free
argument_list|(
name|et_occurrences
argument_list|,
name|t
operator|->
name|parent_occ
argument_list|)
expr_stmt|;
name|pool_free
argument_list|(
name|et_nodes
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Release the alloc pools, if they are empty.  */
end_comment

begin_function
name|void
name|et_free_pools
parameter_list|(
name|void
parameter_list|)
block|{
name|free_alloc_pool_if_empty
argument_list|(
operator|&
name|et_occurrences
argument_list|)
expr_stmt|;
name|free_alloc_pool_if_empty
argument_list|(
operator|&
name|et_nodes
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Sets father of et tree T to FATHER.  */
end_comment

begin_function
name|void
name|et_set_father
parameter_list|(
name|struct
name|et_node
modifier|*
name|t
parameter_list|,
name|struct
name|et_node
modifier|*
name|father
parameter_list|)
block|{
name|struct
name|et_node
modifier|*
name|left
decl_stmt|,
modifier|*
name|right
decl_stmt|;
name|struct
name|et_occ
modifier|*
name|rmost
decl_stmt|,
modifier|*
name|left_part
decl_stmt|,
modifier|*
name|new_f_occ
decl_stmt|,
modifier|*
name|p
decl_stmt|;
comment|/* Update the path represented in the splay tree.  */
name|new_f_occ
operator|=
name|et_new_occ
argument_list|(
name|father
argument_list|)
expr_stmt|;
name|rmost
operator|=
name|father
operator|->
name|rightmost_occ
expr_stmt|;
name|et_splay
argument_list|(
name|rmost
argument_list|)
expr_stmt|;
name|left_part
operator|=
name|rmost
operator|->
name|prev
expr_stmt|;
name|p
operator|=
name|t
operator|->
name|rightmost_occ
expr_stmt|;
name|et_splay
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|set_prev
argument_list|(
name|new_f_occ
argument_list|,
name|left_part
argument_list|)
expr_stmt|;
name|set_next
argument_list|(
name|new_f_occ
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|depth
operator|++
expr_stmt|;
name|p
operator|->
name|min
operator|++
expr_stmt|;
name|et_recomp_min
argument_list|(
name|new_f_occ
argument_list|)
expr_stmt|;
name|set_prev
argument_list|(
name|rmost
argument_list|,
name|new_f_occ
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_f_occ
operator|->
name|min
operator|+
name|rmost
operator|->
name|depth
operator|<
name|rmost
operator|->
name|min
condition|)
block|{
name|rmost
operator|->
name|min
operator|=
name|new_f_occ
operator|->
name|min
operator|+
name|rmost
operator|->
name|depth
expr_stmt|;
name|rmost
operator|->
name|min_occ
operator|=
name|new_f_occ
operator|->
name|min_occ
expr_stmt|;
block|}
name|t
operator|->
name|parent_occ
operator|=
name|new_f_occ
expr_stmt|;
comment|/* Update the tree.  */
name|t
operator|->
name|father
operator|=
name|father
expr_stmt|;
name|right
operator|=
name|father
operator|->
name|son
expr_stmt|;
if|if
condition|(
name|right
condition|)
name|left
operator|=
name|right
operator|->
name|left
expr_stmt|;
else|else
name|left
operator|=
name|right
operator|=
name|t
expr_stmt|;
name|left
operator|->
name|right
operator|=
name|t
expr_stmt|;
name|right
operator|->
name|left
operator|=
name|t
expr_stmt|;
name|t
operator|->
name|left
operator|=
name|left
expr_stmt|;
name|t
operator|->
name|right
operator|=
name|right
expr_stmt|;
name|father
operator|->
name|son
operator|=
name|t
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_ET
name|et_check_tree_sanity
argument_list|(
name|rmost
argument_list|)
expr_stmt|;
name|record_path_before
argument_list|(
name|rmost
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Splits the edge from T to its father.  */
end_comment

begin_function
name|void
name|et_split
parameter_list|(
name|struct
name|et_node
modifier|*
name|t
parameter_list|)
block|{
name|struct
name|et_node
modifier|*
name|father
init|=
name|t
operator|->
name|father
decl_stmt|;
name|struct
name|et_occ
modifier|*
name|r
decl_stmt|,
modifier|*
name|l
decl_stmt|,
modifier|*
name|rmost
decl_stmt|,
modifier|*
name|p_occ
decl_stmt|;
comment|/* Update the path represented by the splay tree.  */
name|rmost
operator|=
name|t
operator|->
name|rightmost_occ
expr_stmt|;
name|et_splay
argument_list|(
name|rmost
argument_list|)
expr_stmt|;
for|for
control|(
name|r
operator|=
name|rmost
operator|->
name|next
init|;
name|r
operator|->
name|prev
condition|;
name|r
operator|=
name|r
operator|->
name|prev
control|)
continue|continue;
name|et_splay
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|r
operator|->
name|prev
operator|->
name|parent
operator|=
name|NULL
expr_stmt|;
name|p_occ
operator|=
name|t
operator|->
name|parent_occ
expr_stmt|;
name|et_splay
argument_list|(
name|p_occ
argument_list|)
expr_stmt|;
name|t
operator|->
name|parent_occ
operator|=
name|NULL
expr_stmt|;
name|l
operator|=
name|p_occ
operator|->
name|prev
expr_stmt|;
name|p_occ
operator|->
name|next
operator|->
name|parent
operator|=
name|NULL
expr_stmt|;
name|set_prev
argument_list|(
name|r
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|et_recomp_min
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|et_splay
argument_list|(
name|rmost
argument_list|)
expr_stmt|;
name|rmost
operator|->
name|depth
operator|=
literal|0
expr_stmt|;
name|rmost
operator|->
name|min
operator|=
literal|0
expr_stmt|;
name|pool_free
argument_list|(
name|et_occurrences
argument_list|,
name|p_occ
argument_list|)
expr_stmt|;
comment|/* Update the tree.  */
if|if
condition|(
name|father
operator|->
name|son
operator|==
name|t
condition|)
name|father
operator|->
name|son
operator|=
name|t
operator|->
name|right
expr_stmt|;
if|if
condition|(
name|father
operator|->
name|son
operator|==
name|t
condition|)
name|father
operator|->
name|son
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|t
operator|->
name|left
operator|->
name|right
operator|=
name|t
operator|->
name|right
expr_stmt|;
name|t
operator|->
name|right
operator|->
name|left
operator|=
name|t
operator|->
name|left
expr_stmt|;
block|}
name|t
operator|->
name|left
operator|=
name|t
operator|->
name|right
operator|=
name|NULL
expr_stmt|;
name|t
operator|->
name|father
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_ET
name|et_check_tree_sanity
argument_list|(
name|rmost
argument_list|)
expr_stmt|;
name|record_path_before
argument_list|(
name|rmost
argument_list|)
expr_stmt|;
name|et_check_tree_sanity
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|record_path_before
argument_list|(
name|r
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Finds the nearest common ancestor of the nodes N1 and N2.  */
end_comment

begin_function
name|struct
name|et_node
modifier|*
name|et_nca
parameter_list|(
name|struct
name|et_node
modifier|*
name|n1
parameter_list|,
name|struct
name|et_node
modifier|*
name|n2
parameter_list|)
block|{
name|struct
name|et_occ
modifier|*
name|o1
init|=
name|n1
operator|->
name|rightmost_occ
decl_stmt|,
modifier|*
name|o2
init|=
name|n2
operator|->
name|rightmost_occ
decl_stmt|,
modifier|*
name|om
decl_stmt|;
name|struct
name|et_occ
modifier|*
name|l
decl_stmt|,
modifier|*
name|r
decl_stmt|,
modifier|*
name|ret
decl_stmt|;
name|int
name|mn
decl_stmt|;
if|if
condition|(
name|n1
operator|==
name|n2
condition|)
return|return
name|n1
return|;
name|et_splay
argument_list|(
name|o1
argument_list|)
expr_stmt|;
name|l
operator|=
name|o1
operator|->
name|prev
expr_stmt|;
name|r
operator|=
name|o1
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|l
condition|)
name|l
operator|->
name|parent
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|r
condition|)
name|r
operator|->
name|parent
operator|=
name|NULL
expr_stmt|;
name|et_splay
argument_list|(
name|o2
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|==
name|o2
operator|||
operator|(
name|l
operator|&&
name|l
operator|->
name|parent
operator|!=
name|NULL
operator|)
condition|)
block|{
name|ret
operator|=
name|o2
operator|->
name|next
expr_stmt|;
name|set_prev
argument_list|(
name|o1
argument_list|,
name|o2
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
name|r
operator|->
name|parent
operator|=
name|o1
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|o2
operator|->
name|prev
expr_stmt|;
name|set_next
argument_list|(
name|o1
argument_list|,
name|o2
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
condition|)
name|l
operator|->
name|parent
operator|=
name|o1
expr_stmt|;
block|}
if|if
condition|(
literal|0
operator|<
name|o2
operator|->
name|depth
condition|)
block|{
name|om
operator|=
name|o1
expr_stmt|;
name|mn
operator|=
name|o1
operator|->
name|depth
expr_stmt|;
block|}
else|else
block|{
name|om
operator|=
name|o2
expr_stmt|;
name|mn
operator|=
name|o2
operator|->
name|depth
operator|+
name|o1
operator|->
name|depth
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG_ET
name|et_check_tree_sanity
argument_list|(
name|o2
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ret
operator|&&
name|ret
operator|->
name|min
operator|+
name|o1
operator|->
name|depth
operator|+
name|o2
operator|->
name|depth
operator|<
name|mn
condition|)
return|return
name|ret
operator|->
name|min_occ
operator|->
name|of
return|;
else|else
return|return
name|om
operator|->
name|of
return|;
block|}
end_function

begin_comment
comment|/* Checks whether the node UP is an ancestor of the node DOWN.  */
end_comment

begin_function
name|bool
name|et_below
parameter_list|(
name|struct
name|et_node
modifier|*
name|down
parameter_list|,
name|struct
name|et_node
modifier|*
name|up
parameter_list|)
block|{
name|struct
name|et_occ
modifier|*
name|u
init|=
name|up
operator|->
name|rightmost_occ
decl_stmt|,
modifier|*
name|d
init|=
name|down
operator|->
name|rightmost_occ
decl_stmt|;
name|struct
name|et_occ
modifier|*
name|l
decl_stmt|,
modifier|*
name|r
decl_stmt|;
if|if
condition|(
name|up
operator|==
name|down
condition|)
return|return
name|true
return|;
name|et_splay
argument_list|(
name|u
argument_list|)
expr_stmt|;
name|l
operator|=
name|u
operator|->
name|prev
expr_stmt|;
name|r
operator|=
name|u
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|!
name|l
condition|)
return|return
name|false
return|;
name|l
operator|->
name|parent
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|r
condition|)
name|r
operator|->
name|parent
operator|=
name|NULL
expr_stmt|;
name|et_splay
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|==
name|d
operator|||
name|l
operator|->
name|parent
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|r
condition|)
name|r
operator|->
name|parent
operator|=
name|u
expr_stmt|;
name|set_prev
argument_list|(
name|u
argument_list|,
name|d
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_ET
name|et_check_tree_sanity
argument_list|(
name|u
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|l
operator|->
name|parent
operator|=
name|u
expr_stmt|;
comment|/* In case O1 and O2 are in two different trees, we must just restore the 	 original state.  */
if|if
condition|(
name|r
operator|&&
name|r
operator|->
name|parent
operator|!=
name|NULL
condition|)
name|set_next
argument_list|(
name|u
argument_list|,
name|d
argument_list|)
expr_stmt|;
else|else
name|set_next
argument_list|(
name|u
argument_list|,
name|r
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_ET
name|et_check_tree_sanity
argument_list|(
name|u
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|false
return|;
block|}
if|if
condition|(
literal|0
operator|>=
name|d
operator|->
name|depth
condition|)
return|return
name|false
return|;
return|return
operator|!
name|d
operator|->
name|next
operator|||
name|d
operator|->
name|next
operator|->
name|min
operator|+
name|d
operator|->
name|depth
operator|>=
literal|0
return|;
block|}
end_function

end_unit

