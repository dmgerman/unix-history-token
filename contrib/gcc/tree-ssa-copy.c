begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copy propagation and SSA_NAME replacement support routines.    Copyright (C) 2004, 2005 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"tree-dump.h"
end_include

begin_include
include|#
directive|include
file|"tree-flow.h"
end_include

begin_include
include|#
directive|include
file|"tree-pass.h"
end_include

begin_include
include|#
directive|include
file|"tree-ssa-propagate.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_comment
comment|/* This file implements the copy propagation pass and provides a    handful of interfaces for performing const/copy propagation and    simple expression replacement which keep variable annotations    up-to-date.     We require that for any copy operation where the RHS and LHS have    a non-null memory tag the memory tag be the same.   It is OK    for one or both of the memory tags to be NULL.     We also require tracking if a variable is dereferenced in a load or    store operation.     We enforce these requirements by having all copy propagation and    replacements of one SSA_NAME with a different SSA_NAME to use the    APIs defined in this file.  */
end_comment

begin_comment
comment|/* Return true if we may propagate ORIG into DEST, false otherwise.  */
end_comment

begin_function
name|bool
name|may_propagate_copy
parameter_list|(
name|tree
name|dest
parameter_list|,
name|tree
name|orig
parameter_list|)
block|{
name|tree
name|type_d
init|=
name|TREE_TYPE
argument_list|(
name|dest
argument_list|)
decl_stmt|;
name|tree
name|type_o
init|=
name|TREE_TYPE
argument_list|(
name|orig
argument_list|)
decl_stmt|;
comment|/* Do not copy between types for which we *do* need a conversion.  */
if|if
condition|(
operator|!
name|tree_ssa_useless_type_conversion_1
argument_list|(
name|type_d
argument_list|,
name|type_o
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* FIXME.  GIMPLE is allowing pointer assignments and comparisons of      pointers that have different alias sets.  This means that these      pointers will have different memory tags associated to them.       If we allow copy propagation in these cases, statements de-referencing      the new pointer will now have a reference to a different memory tag      with potentially incorrect SSA information.       This was showing up in libjava/java/util/zip/ZipFile.java with code      like:       	struct java.io.BufferedInputStream *T.660; 	struct java.io.BufferedInputStream *T.647; 	struct java.io.InputStream *is; 	struct java.io.InputStream *is.662; 	[ ... ] 	T.660 = T.647; 	is = T.660;<-- This ought to be type-casted 	is.662 = is;       Also, f/name.c exposed a similar problem with a COND_EXPR predicate      that was causing DOM to generate and equivalence with two pointers of      alias-incompatible types:       	struct _ffename_space *n; 	struct _ffename *ns; 	[ ... ] 	if (n == ns) 	  goto lab; 	... 	lab: 	return n;       I think that GIMPLE should emit the appropriate type-casts.  For the      time being, blocking copy-propagation in these cases is the safe thing      to do.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SSA_NAME
operator|&&
name|TREE_CODE
argument_list|(
name|orig
argument_list|)
operator|==
name|SSA_NAME
operator|&&
name|POINTER_TYPE_P
argument_list|(
name|type_d
argument_list|)
operator|&&
name|POINTER_TYPE_P
argument_list|(
name|type_o
argument_list|)
condition|)
block|{
name|tree
name|mt_dest
init|=
name|var_ann
argument_list|(
name|SSA_NAME_VAR
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|->
name|symbol_mem_tag
decl_stmt|;
name|tree
name|mt_orig
init|=
name|var_ann
argument_list|(
name|SSA_NAME_VAR
argument_list|(
name|orig
argument_list|)
argument_list|)
operator|->
name|symbol_mem_tag
decl_stmt|;
if|if
condition|(
name|mt_dest
operator|&&
name|mt_orig
operator|&&
name|mt_dest
operator|!=
name|mt_orig
condition|)
return|return
name|false
return|;
elseif|else
if|if
condition|(
operator|!
name|lang_hooks
operator|.
name|types_compatible_p
argument_list|(
name|type_d
argument_list|,
name|type_o
argument_list|)
condition|)
return|return
name|false
return|;
elseif|else
if|if
condition|(
name|get_alias_set
argument_list|(
name|TREE_TYPE
argument_list|(
name|type_d
argument_list|)
argument_list|)
operator|!=
name|get_alias_set
argument_list|(
name|TREE_TYPE
argument_list|(
name|type_o
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Also verify flow-sensitive information is compatible.  */
if|if
condition|(
name|SSA_NAME_PTR_INFO
argument_list|(
name|orig
argument_list|)
operator|&&
name|SSA_NAME_PTR_INFO
argument_list|(
name|dest
argument_list|)
condition|)
block|{
name|struct
name|ptr_info_def
modifier|*
name|orig_ptr_info
init|=
name|SSA_NAME_PTR_INFO
argument_list|(
name|orig
argument_list|)
decl_stmt|;
name|struct
name|ptr_info_def
modifier|*
name|dest_ptr_info
init|=
name|SSA_NAME_PTR_INFO
argument_list|(
name|dest
argument_list|)
decl_stmt|;
if|if
condition|(
name|orig_ptr_info
operator|->
name|name_mem_tag
operator|&&
name|dest_ptr_info
operator|->
name|name_mem_tag
operator|&&
name|orig_ptr_info
operator|->
name|pt_vars
operator|&&
name|dest_ptr_info
operator|->
name|pt_vars
operator|&&
operator|!
name|bitmap_intersect_p
argument_list|(
name|dest_ptr_info
operator|->
name|pt_vars
argument_list|,
name|orig_ptr_info
operator|->
name|pt_vars
argument_list|)
condition|)
return|return
name|false
return|;
block|}
block|}
comment|/* If the destination is a SSA_NAME for a virtual operand, then we have      some special cases to handle.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SSA_NAME
operator|&&
operator|!
name|is_gimple_reg
argument_list|(
name|dest
argument_list|)
condition|)
block|{
comment|/* If both operands are SSA_NAMEs referring to virtual operands, then 	 we can always propagate.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|orig
argument_list|)
operator|==
name|SSA_NAME
operator|&&
operator|!
name|is_gimple_reg
argument_list|(
name|orig
argument_list|)
condition|)
return|return
name|true
return|;
comment|/* We have a "copy" from something like a constant into a virtual 	 operand.  Reject these.  */
return|return
name|false
return|;
block|}
comment|/* If ORIG flows in from an abnormal edge, it cannot be propagated.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|orig
argument_list|)
operator|==
name|SSA_NAME
operator|&&
name|SSA_NAME_OCCURS_IN_ABNORMAL_PHI
argument_list|(
name|orig
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* If DEST is an SSA_NAME that flows from an abnormal edge, then it      cannot be replaced.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SSA_NAME
operator|&&
name|SSA_NAME_OCCURS_IN_ABNORMAL_PHI
argument_list|(
name|dest
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Anything else is OK.  */
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Similarly, but we know that we're propagating into an ASM_EXPR.  */
end_comment

begin_function
name|bool
name|may_propagate_copy_into_asm
parameter_list|(
name|tree
name|dest
parameter_list|)
block|{
comment|/* Hard register operands of asms are special.  Do not bypass.  */
return|return
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SSA_NAME
operator|&&
name|TREE_CODE
argument_list|(
name|SSA_NAME_VAR
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_HARD_REGISTER
argument_list|(
name|SSA_NAME_VAR
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Given two SSA_NAMEs pointers ORIG and NEW such that we are copy    propagating NEW into ORIG, consolidate aliasing information so that    they both share the same memory tags.  */
end_comment

begin_function
name|void
name|merge_alias_info
parameter_list|(
name|tree
name|orig
parameter_list|,
name|tree
name|new
parameter_list|)
block|{
name|tree
name|new_sym
init|=
name|SSA_NAME_VAR
argument_list|(
name|new
argument_list|)
decl_stmt|;
name|tree
name|orig_sym
init|=
name|SSA_NAME_VAR
argument_list|(
name|orig
argument_list|)
decl_stmt|;
name|var_ann_t
name|new_ann
init|=
name|var_ann
argument_list|(
name|new_sym
argument_list|)
decl_stmt|;
name|var_ann_t
name|orig_ann
init|=
name|var_ann
argument_list|(
name|orig_sym
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|orig
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|new
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
name|ENABLE_CHECKING
name|gcc_assert
argument_list|(
name|lang_hooks
operator|.
name|types_compatible_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|orig
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|new
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the pointed-to alias sets are different, these two pointers      would never have the same memory tag.  In this case, NEW should      not have been propagated into ORIG.  */
name|gcc_assert
argument_list|(
name|get_alias_set
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|new_sym
argument_list|)
argument_list|)
argument_list|)
operator|==
name|get_alias_set
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|orig_sym
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Synchronize the symbol tags.  If both pointers had a tag and they      are different, then something has gone wrong.  Symbol tags can      always be merged because they are flow insensitive, all the SSA      names of the same base DECL share the same symbol tag.  */
if|if
condition|(
name|new_ann
operator|->
name|symbol_mem_tag
operator|==
name|NULL_TREE
condition|)
name|new_ann
operator|->
name|symbol_mem_tag
operator|=
name|orig_ann
operator|->
name|symbol_mem_tag
expr_stmt|;
elseif|else
if|if
condition|(
name|orig_ann
operator|->
name|symbol_mem_tag
operator|==
name|NULL_TREE
condition|)
name|orig_ann
operator|->
name|symbol_mem_tag
operator|=
name|new_ann
operator|->
name|symbol_mem_tag
expr_stmt|;
else|else
name|gcc_assert
argument_list|(
name|new_ann
operator|->
name|symbol_mem_tag
operator|==
name|orig_ann
operator|->
name|symbol_mem_tag
argument_list|)
expr_stmt|;
comment|/* Check that flow-sensitive information is compatible.  Notice that      we may not merge flow-sensitive information here.  This function      is called when propagating equivalences dictated by the IL, like      a copy operation P_i = Q_j, and from equivalences dictated by      control-flow, like if (P_i == Q_j).            In the former case, P_i and Q_j are equivalent in every block      dominated by the assignment, so their flow-sensitive information      is always the same.  However, in the latter case, the pointers      P_i and Q_j are only equivalent in one of the sub-graphs out of      the predicate, so their flow-sensitive information is not the      same in every block dominated by the predicate.       Since we cannot distinguish one case from another in this      function, we can only make sure that if P_i and Q_j have      flow-sensitive information, they should be compatible.  */
if|if
condition|(
name|SSA_NAME_PTR_INFO
argument_list|(
name|orig
argument_list|)
operator|&&
name|SSA_NAME_PTR_INFO
argument_list|(
name|new
argument_list|)
condition|)
block|{
name|struct
name|ptr_info_def
modifier|*
name|orig_ptr_info
init|=
name|SSA_NAME_PTR_INFO
argument_list|(
name|orig
argument_list|)
decl_stmt|;
name|struct
name|ptr_info_def
modifier|*
name|new_ptr_info
init|=
name|SSA_NAME_PTR_INFO
argument_list|(
name|new
argument_list|)
decl_stmt|;
comment|/* Note that pointer NEW and ORIG may actually have different 	 pointed-to variables (e.g., PR 18291 represented in 	 testsuite/gcc.c-torture/compile/pr18291.c).  However, since 	 NEW is being copy-propagated into ORIG, it must always be 	 true that the pointed-to set for pointer NEW is the same, or 	 a subset, of the pointed-to set for pointer ORIG.  If this 	 isn't the case, we shouldn't have been able to do the 	 propagation of NEW into ORIG.  */
if|if
condition|(
name|orig_ptr_info
operator|->
name|name_mem_tag
operator|&&
name|new_ptr_info
operator|->
name|name_mem_tag
operator|&&
name|orig_ptr_info
operator|->
name|pt_vars
operator|&&
name|new_ptr_info
operator|->
name|pt_vars
condition|)
name|gcc_assert
argument_list|(
name|bitmap_intersect_p
argument_list|(
name|new_ptr_info
operator|->
name|pt_vars
argument_list|,
name|orig_ptr_info
operator|->
name|pt_vars
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Common code for propagate_value and replace_exp.     Replace use operand OP_P with VAL.  FOR_PROPAGATION indicates if the    replacement is done to propagate a value or not.  */
end_comment

begin_function
specifier|static
name|void
name|replace_exp_1
parameter_list|(
name|use_operand_p
name|op_p
parameter_list|,
name|tree
name|val
parameter_list|,
name|bool
name|for_propagation
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|tree
name|op
init|=
name|USE_FROM_PTR
argument_list|(
name|op_p
argument_list|)
decl_stmt|;
if|#
directive|if
name|defined
name|ENABLE_CHECKING
name|gcc_assert
argument_list|(
operator|!
operator|(
name|for_propagation
operator|&&
name|TREE_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SSA_NAME
operator|&&
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|==
name|SSA_NAME
operator|&&
operator|!
name|may_propagate_copy
argument_list|(
name|op
argument_list|,
name|val
argument_list|)
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|==
name|SSA_NAME
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SSA_NAME
operator|&&
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|op
argument_list|)
argument_list|)
condition|)
name|merge_alias_info
argument_list|(
name|op
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|SET_USE
argument_list|(
name|op_p
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
else|else
name|SET_USE
argument_list|(
name|op_p
argument_list|,
name|unsave_expr_now
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Propagate the value VAL (assumed to be a constant or another SSA_NAME)    into the operand pointed to by OP_P.     Use this version for const/copy propagation as it will perform additional    checks to ensure validity of the const/copy propagation.  */
end_comment

begin_function
name|void
name|propagate_value
parameter_list|(
name|use_operand_p
name|op_p
parameter_list|,
name|tree
name|val
parameter_list|)
block|{
name|replace_exp_1
argument_list|(
name|op_p
argument_list|,
name|val
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Propagate the value VAL (assumed to be a constant or another SSA_NAME)    into the tree pointed to by OP_P.     Use this version for const/copy propagation when SSA operands are not    available.  It will perform the additional checks to ensure validity of    the const/copy propagation, but will not update any operand information.    Be sure to mark the stmt as modified.  */
end_comment

begin_function
name|void
name|propagate_tree_value
parameter_list|(
name|tree
modifier|*
name|op_p
parameter_list|,
name|tree
name|val
parameter_list|)
block|{
if|#
directive|if
name|defined
name|ENABLE_CHECKING
name|gcc_assert
argument_list|(
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|==
name|SSA_NAME
operator|&&
name|TREE_CODE
argument_list|(
operator|*
name|op_p
argument_list|)
operator|==
name|SSA_NAME
operator|&&
operator|!
name|may_propagate_copy
argument_list|(
operator|*
name|op_p
argument_list|,
name|val
argument_list|)
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|==
name|SSA_NAME
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|op_p
argument_list|)
operator|==
name|SSA_NAME
operator|&&
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
operator|*
name|op_p
argument_list|)
argument_list|)
condition|)
name|merge_alias_info
argument_list|(
operator|*
name|op_p
argument_list|,
name|val
argument_list|)
expr_stmt|;
operator|*
name|op_p
operator|=
name|val
expr_stmt|;
block|}
else|else
operator|*
name|op_p
operator|=
name|unsave_expr_now
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Replace *OP_P with value VAL (assumed to be a constant or another SSA_NAME).     Use this version when not const/copy propagating values.  For example,    PRE uses this version when building expressions as they would appear    in specific blocks taking into account actions of PHI nodes.  */
end_comment

begin_function
name|void
name|replace_exp
parameter_list|(
name|use_operand_p
name|op_p
parameter_list|,
name|tree
name|val
parameter_list|)
block|{
name|replace_exp_1
argument_list|(
name|op_p
argument_list|,
name|val
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- 				Copy propagation ---------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/* During propagation, we keep chains of variables that are copies of    one another.  If variable X_i is a copy of X_j and X_j is a copy of    X_k, COPY_OF will contain:     	COPY_OF[i].VALUE = X_j 	COPY_OF[j].VALUE = X_k 	COPY_OF[k].VALUE = X_k     After propagation, the copy-of value for each variable X_i is    converted into the final value by walking the copy-of chains and    updating COPY_OF[i].VALUE to be the last element of the chain.  */
end_comment

begin_decl_stmt
specifier|static
name|prop_value_t
modifier|*
name|copy_of
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Used in set_copy_of_val to determine if the last link of a copy-of    chain has changed.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
modifier|*
name|cached_last_copy_of
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* True if we are doing copy propagation on loads and stores.  */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|do_store_copy_prop
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return true if this statement may generate a useful copy.  */
end_comment

begin_function
specifier|static
name|bool
name|stmt_may_generate_copy
parameter_list|(
name|tree
name|stmt
parameter_list|)
block|{
name|tree
name|lhs
decl_stmt|,
name|rhs
decl_stmt|;
name|stmt_ann_t
name|ann
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|PHI_NODE
condition|)
return|return
operator|!
name|SSA_NAME_OCCURS_IN_ABNORMAL_PHI
argument_list|(
name|PHI_RESULT
argument_list|(
name|stmt
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|!=
name|MODIFY_EXPR
condition|)
return|return
name|false
return|;
name|lhs
operator|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rhs
operator|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ann
operator|=
name|stmt_ann
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
comment|/* If the statement has volatile operands, it won't generate a      useful copy.  */
if|if
condition|(
name|ann
operator|->
name|has_volatile_ops
condition|)
return|return
name|false
return|;
comment|/* If we are not doing store copy-prop, statements with loads and/or      stores will never generate a useful copy.  */
if|if
condition|(
operator|!
name|do_store_copy_prop
operator|&&
operator|!
name|ZERO_SSA_OPERANDS
argument_list|(
name|stmt
argument_list|,
name|SSA_OP_ALL_VIRTUALS
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Otherwise, the only statements that generate useful copies are      assignments whose RHS is just an SSA name that doesn't flow      through abnormal edges.  */
return|return
operator|(
name|do_store_copy_prop
operator|&&
name|TREE_CODE
argument_list|(
name|lhs
argument_list|)
operator|==
name|SSA_NAME
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|SSA_NAME
operator|&&
operator|!
name|SSA_NAME_OCCURS_IN_ABNORMAL_PHI
argument_list|(
name|rhs
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the copy-of value for VAR.  */
end_comment

begin_function
specifier|static
specifier|inline
name|prop_value_t
modifier|*
name|get_copy_of_val
parameter_list|(
name|tree
name|var
parameter_list|)
block|{
name|prop_value_t
modifier|*
name|val
init|=
operator|&
name|copy_of
index|[
name|SSA_NAME_VERSION
argument_list|(
name|var
argument_list|)
index|]
decl_stmt|;
if|if
condition|(
name|val
operator|->
name|value
operator|==
name|NULL_TREE
operator|&&
operator|!
name|stmt_may_generate_copy
argument_list|(
name|SSA_NAME_DEF_STMT
argument_list|(
name|var
argument_list|)
argument_list|)
condition|)
block|{
comment|/* If the variable will never generate a useful copy relation, 	 make it its own copy.  */
name|val
operator|->
name|value
operator|=
name|var
expr_stmt|;
name|val
operator|->
name|mem_ref
operator|=
name|NULL_TREE
expr_stmt|;
block|}
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/* Return last link in the copy-of chain for VAR.  */
end_comment

begin_function
specifier|static
name|tree
name|get_last_copy_of
parameter_list|(
name|tree
name|var
parameter_list|)
block|{
name|tree
name|last
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Traverse COPY_OF starting at VAR until we get to the last      link in the chain.  Since it is possible to have cycles in PHI      nodes, the copy-of chain may also contain cycles.            To avoid infinite loops and to avoid traversing lengthy copy-of      chains, we artificially limit the maximum number of chains we are      willing to traverse.       The value 5 was taken from a compiler and runtime library      bootstrap and a mixture of C and C++ code from various sources.      More than 82% of all copy-of chains were shorter than 5 links.  */
define|#
directive|define
name|LIMIT
value|5
name|last
operator|=
name|var
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LIMIT
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|copy
init|=
name|copy_of
index|[
name|SSA_NAME_VERSION
argument_list|(
name|last
argument_list|)
index|]
operator|.
name|value
decl_stmt|;
if|if
condition|(
name|copy
operator|==
name|NULL_TREE
operator|||
name|copy
operator|==
name|last
condition|)
break|break;
name|last
operator|=
name|copy
expr_stmt|;
block|}
comment|/* If we have reached the limit, then we are either in a copy-of      cycle or the copy-of chain is too long.  In this case, just      return VAR so that it is not considered a copy of anything.  */
return|return
operator|(
name|i
operator|<
name|LIMIT
condition|?
name|last
else|:
name|var
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Set FIRST to be the first variable in the copy-of chain for DEST.    If DEST's copy-of value or its copy-of chain has changed, return    true.     MEM_REF is the memory reference where FIRST is stored.  This is    used when DEST is a non-register and we are copy propagating loads    and stores.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|set_copy_of_val
parameter_list|(
name|tree
name|dest
parameter_list|,
name|tree
name|first
parameter_list|,
name|tree
name|mem_ref
parameter_list|)
block|{
name|unsigned
name|int
name|dest_ver
init|=
name|SSA_NAME_VERSION
argument_list|(
name|dest
argument_list|)
decl_stmt|;
name|tree
name|old_first
decl_stmt|,
name|old_last
decl_stmt|,
name|new_last
decl_stmt|;
comment|/* Set FIRST to be the first link in COPY_OF[DEST].  If that      changed, return true.  */
name|old_first
operator|=
name|copy_of
index|[
name|dest_ver
index|]
operator|.
name|value
expr_stmt|;
name|copy_of
index|[
name|dest_ver
index|]
operator|.
name|value
operator|=
name|first
expr_stmt|;
name|copy_of
index|[
name|dest_ver
index|]
operator|.
name|mem_ref
operator|=
name|mem_ref
expr_stmt|;
if|if
condition|(
name|old_first
operator|!=
name|first
condition|)
return|return
name|true
return|;
comment|/* If FIRST and OLD_FIRST are the same, we need to check whether the      copy-of chain starting at FIRST ends in a different variable.  If      the copy-of chain starting at FIRST ends up in a different      variable than the last cached value we had for DEST, then return      true because DEST is now a copy of a different variable.       This test is necessary because even though the first link in the      copy-of chain may not have changed, if any of the variables in      the copy-of chain changed its final value, DEST will now be the      copy of a different variable, so we have to do another round of      propagation for everything that depends on DEST.  */
name|old_last
operator|=
name|cached_last_copy_of
index|[
name|dest_ver
index|]
expr_stmt|;
name|new_last
operator|=
name|get_last_copy_of
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|cached_last_copy_of
index|[
name|dest_ver
index|]
operator|=
name|new_last
expr_stmt|;
return|return
operator|(
name|old_last
operator|!=
name|new_last
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Dump the copy-of value for variable VAR to FILE.  */
end_comment

begin_function
specifier|static
name|void
name|dump_copy_of
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|tree
name|var
parameter_list|)
block|{
name|tree
name|val
decl_stmt|;
name|sbitmap
name|visited
decl_stmt|;
name|print_generic_expr
argument_list|(
name|file
argument_list|,
name|var
argument_list|,
name|dump_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|var
argument_list|)
operator|!=
name|SSA_NAME
condition|)
return|return;
name|visited
operator|=
name|sbitmap_alloc
argument_list|(
name|num_ssa_names
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|visited
argument_list|)
expr_stmt|;
name|SET_BIT
argument_list|(
name|visited
argument_list|,
name|SSA_NAME_VERSION
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" copy-of chain: "
argument_list|)
expr_stmt|;
name|val
operator|=
name|var
expr_stmt|;
name|print_generic_expr
argument_list|(
name|file
argument_list|,
name|val
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
while|while
condition|(
name|copy_of
index|[
name|SSA_NAME_VERSION
argument_list|(
name|val
argument_list|)
index|]
operator|.
name|value
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"-> "
argument_list|)
expr_stmt|;
name|val
operator|=
name|copy_of
index|[
name|SSA_NAME_VERSION
argument_list|(
name|val
argument_list|)
index|]
operator|.
name|value
expr_stmt|;
name|print_generic_expr
argument_list|(
name|file
argument_list|,
name|val
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
if|if
condition|(
name|TEST_BIT
argument_list|(
name|visited
argument_list|,
name|SSA_NAME_VERSION
argument_list|(
name|val
argument_list|)
argument_list|)
condition|)
break|break;
name|SET_BIT
argument_list|(
name|visited
argument_list|,
name|SSA_NAME_VERSION
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|val
operator|=
name|get_copy_of_val
argument_list|(
name|var
argument_list|)
operator|->
name|value
expr_stmt|;
if|if
condition|(
name|val
operator|==
name|NULL_TREE
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"[UNDEFINED]"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|val
operator|!=
name|var
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"[COPY]"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"[NOT A COPY]"
argument_list|)
expr_stmt|;
name|sbitmap_free
argument_list|(
name|visited
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Evaluate the RHS of STMT.  If it produces a valid copy, set the LHS    value and store the LHS into *RESULT_P.  If STMT generates more    than one name (i.e., STMT is an aliased store), it is enough to    store the first name in the V_MAY_DEF list into *RESULT_P.  After    all, the names generated will be VUSEd in the same statements.  */
end_comment

begin_function
specifier|static
name|enum
name|ssa_prop_result
name|copy_prop_visit_assignment
parameter_list|(
name|tree
name|stmt
parameter_list|,
name|tree
modifier|*
name|result_p
parameter_list|)
block|{
name|tree
name|lhs
decl_stmt|,
name|rhs
decl_stmt|;
name|prop_value_t
modifier|*
name|rhs_val
decl_stmt|;
name|lhs
operator|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rhs
operator|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|SSA_NAME
argument_list|)
expr_stmt|;
name|rhs_val
operator|=
name|get_copy_of_val
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|lhs
argument_list|)
operator|==
name|SSA_NAME
condition|)
block|{
comment|/* Straight copy between two SSA names.  First, make sure that 	 we can propagate the RHS into uses of LHS.  */
if|if
condition|(
operator|!
name|may_propagate_copy
argument_list|(
name|lhs
argument_list|,
name|rhs
argument_list|)
condition|)
return|return
name|SSA_PROP_VARYING
return|;
comment|/* Notice that in the case of assignments, we make the LHS be a 	 copy of RHS's value, not of RHS itself.  This avoids keeping 	 unnecessary copy-of chains (assignments cannot be in a cycle 	 like PHI nodes), speeding up the propagation process. 	 This is different from what we do in copy_prop_visit_phi_node.  	 In those cases, we are interested in the copy-of chains.  */
operator|*
name|result_p
operator|=
name|lhs
expr_stmt|;
if|if
condition|(
name|set_copy_of_val
argument_list|(
operator|*
name|result_p
argument_list|,
name|rhs_val
operator|->
name|value
argument_list|,
name|rhs_val
operator|->
name|mem_ref
argument_list|)
condition|)
return|return
name|SSA_PROP_INTERESTING
return|;
else|else
return|return
name|SSA_PROP_NOT_INTERESTING
return|;
block|}
elseif|else
if|if
condition|(
name|stmt_makes_single_store
argument_list|(
name|stmt
argument_list|)
condition|)
block|{
comment|/* Otherwise, set the names in V_MAY_DEF/V_MUST_DEF operands 	 to be a copy of RHS.  */
name|ssa_op_iter
name|i
decl_stmt|;
name|tree
name|vdef
decl_stmt|;
name|bool
name|changed
decl_stmt|;
comment|/* This should only be executed when doing store copy-prop.  */
name|gcc_assert
argument_list|(
name|do_store_copy_prop
argument_list|)
expr_stmt|;
comment|/* Set the value of every VDEF to RHS_VAL.  */
name|changed
operator|=
name|false
expr_stmt|;
name|FOR_EACH_SSA_TREE_OPERAND
argument_list|(
argument|vdef
argument_list|,
argument|stmt
argument_list|,
argument|i
argument_list|,
argument|SSA_OP_VIRTUAL_DEFS
argument_list|)
name|changed
operator||=
name|set_copy_of_val
argument_list|(
name|vdef
argument_list|,
name|rhs_val
operator|->
name|value
argument_list|,
name|lhs
argument_list|)
expr_stmt|;
comment|/* Note that for propagation purposes, we are only interested in 	 visiting statements that load the exact same memory reference 	 stored here.  Those statements will have the exact same list 	 of virtual uses, so it is enough to set the output of this 	 statement to be its first virtual definition.  */
operator|*
name|result_p
operator|=
name|first_vdef
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|changed
condition|)
return|return
name|SSA_PROP_INTERESTING
return|;
else|else
return|return
name|SSA_PROP_NOT_INTERESTING
return|;
block|}
return|return
name|SSA_PROP_VARYING
return|;
block|}
end_function

begin_comment
comment|/* Visit the COND_EXPR STMT.  Return SSA_PROP_INTERESTING    if it can determine which edge will be taken.  Otherwise, return    SSA_PROP_VARYING.  */
end_comment

begin_function
specifier|static
name|enum
name|ssa_prop_result
name|copy_prop_visit_cond_stmt
parameter_list|(
name|tree
name|stmt
parameter_list|,
name|edge
modifier|*
name|taken_edge_p
parameter_list|)
block|{
name|enum
name|ssa_prop_result
name|retval
decl_stmt|;
name|tree
name|cond
decl_stmt|;
name|cond
operator|=
name|COND_EXPR_COND
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|retval
operator|=
name|SSA_PROP_VARYING
expr_stmt|;
comment|/* The only conditionals that we may be able to compute statically      are predicates involving two SSA_NAMEs.  */
if|if
condition|(
name|COMPARISON_CLASS_P
argument_list|(
name|cond
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SSA_NAME
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|SSA_NAME
condition|)
block|{
name|tree
name|op0
init|=
name|get_last_copy_of
argument_list|(
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|op1
init|=
name|get_last_copy_of
argument_list|(
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
comment|/* See if we can determine the predicate's value.  */
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Trying to determine truth value of "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"predicate "
argument_list|)
expr_stmt|;
name|print_generic_stmt
argument_list|(
name|dump_file
argument_list|,
name|cond
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* We can fold COND and get a useful result only when we have 	 the same SSA_NAME on both sides of a comparison operator.  */
if|if
condition|(
name|op0
operator|==
name|op1
condition|)
block|{
name|tree
name|folded_cond
init|=
name|fold_binary
argument_list|(
name|TREE_CODE
argument_list|(
name|cond
argument_list|)
argument_list|,
name|boolean_type_node
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
decl_stmt|;
if|if
condition|(
name|folded_cond
condition|)
block|{
name|basic_block
name|bb
init|=
name|bb_for_stmt
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
operator|*
name|taken_edge_p
operator|=
name|find_taken_edge
argument_list|(
name|bb
argument_list|,
name|folded_cond
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|taken_edge_p
condition|)
name|retval
operator|=
name|SSA_PROP_INTERESTING
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
operator|&&
operator|*
name|taken_edge_p
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\nConditional will always take edge %d->%d\n"
argument_list|,
operator|(
operator|*
name|taken_edge_p
operator|)
operator|->
name|src
operator|->
name|index
argument_list|,
operator|(
operator|*
name|taken_edge_p
operator|)
operator|->
name|dest
operator|->
name|index
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* Evaluate statement STMT.  If the statement produces a new output    value, return SSA_PROP_INTERESTING and store the SSA_NAME holding    the new value in *RESULT_P.     If STMT is a conditional branch and we can determine its truth    value, set *TAKEN_EDGE_P accordingly.     If the new value produced by STMT is varying, return    SSA_PROP_VARYING.  */
end_comment

begin_function
specifier|static
name|enum
name|ssa_prop_result
name|copy_prop_visit_stmt
parameter_list|(
name|tree
name|stmt
parameter_list|,
name|edge
modifier|*
name|taken_edge_p
parameter_list|,
name|tree
modifier|*
name|result_p
parameter_list|)
block|{
name|enum
name|ssa_prop_result
name|retval
decl_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\nVisiting statement:\n"
argument_list|)
expr_stmt|;
name|print_generic_stmt
argument_list|(
name|dump_file
argument_list|,
name|stmt
argument_list|,
name|dump_flags
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|MODIFY_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|SSA_NAME
operator|&&
operator|(
name|do_store_copy_prop
operator|||
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SSA_NAME
operator|)
condition|)
block|{
comment|/* If the statement is a copy assignment, evaluate its RHS to 	 see if the lattice value of its output has changed.  */
name|retval
operator|=
name|copy_prop_visit_assignment
argument_list|(
name|stmt
argument_list|,
name|result_p
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|MODIFY_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SSA_NAME
operator|&&
name|do_store_copy_prop
operator|&&
name|stmt_makes_single_load
argument_list|(
name|stmt
argument_list|)
condition|)
block|{
comment|/* If the statement is a copy assignment with a memory load 	 on the RHS, see if we know the value of this load and 	 update the lattice accordingly.  */
name|prop_value_t
modifier|*
name|val
init|=
name|get_value_loaded_by
argument_list|(
name|stmt
argument_list|,
name|copy_of
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|&&
name|val
operator|->
name|mem_ref
operator|&&
name|is_gimple_reg
argument_list|(
name|val
operator|->
name|value
argument_list|)
operator|&&
name|operand_equal_p
argument_list|(
name|val
operator|->
name|mem_ref
argument_list|,
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|bool
name|changed
decl_stmt|;
name|changed
operator|=
name|set_copy_of_val
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
argument_list|,
name|val
operator|->
name|value
argument_list|,
name|val
operator|->
name|mem_ref
argument_list|)
expr_stmt|;
if|if
condition|(
name|changed
condition|)
block|{
operator|*
name|result_p
operator|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|retval
operator|=
name|SSA_PROP_INTERESTING
expr_stmt|;
block|}
else|else
name|retval
operator|=
name|SSA_PROP_NOT_INTERESTING
expr_stmt|;
block|}
else|else
name|retval
operator|=
name|SSA_PROP_VARYING
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|COND_EXPR
condition|)
block|{
comment|/* See if we can determine which edge goes out of a conditional 	 jump.  */
name|retval
operator|=
name|copy_prop_visit_cond_stmt
argument_list|(
name|stmt
argument_list|,
name|taken_edge_p
argument_list|)
expr_stmt|;
block|}
else|else
name|retval
operator|=
name|SSA_PROP_VARYING
expr_stmt|;
if|if
condition|(
name|retval
operator|==
name|SSA_PROP_VARYING
condition|)
block|{
name|tree
name|def
decl_stmt|;
name|ssa_op_iter
name|i
decl_stmt|;
comment|/* Any other kind of statement is not interesting for constant 	 propagation and, therefore, not worth simulating.  */
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"No interesting values produced.\n"
argument_list|)
expr_stmt|;
comment|/* The assignment is not a copy operation.  Don't visit this 	 statement again and mark all the definitions in the statement 	 to be copies of nothing.  */
name|FOR_EACH_SSA_TREE_OPERAND
argument_list|(
argument|def
argument_list|,
argument|stmt
argument_list|,
argument|i
argument_list|,
argument|SSA_OP_ALL_DEFS
argument_list|)
name|set_copy_of_val
argument_list|(
name|def
argument_list|,
name|def
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* Visit PHI node PHI.  If all the arguments produce the same value,    set it to be the value of the LHS of PHI.  */
end_comment

begin_function
specifier|static
name|enum
name|ssa_prop_result
name|copy_prop_visit_phi_node
parameter_list|(
name|tree
name|phi
parameter_list|)
block|{
name|enum
name|ssa_prop_result
name|retval
decl_stmt|;
name|int
name|i
decl_stmt|;
name|tree
name|lhs
decl_stmt|;
name|prop_value_t
name|phi_val
init|=
block|{
literal|0
block|,
name|NULL_TREE
block|,
name|NULL_TREE
block|}
decl_stmt|;
name|lhs
operator|=
name|PHI_RESULT
argument_list|(
name|phi
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\nVisiting PHI node: "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|phi
argument_list|,
name|dump_flags
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n\n"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PHI_NUM_ARGS
argument_list|(
name|phi
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|prop_value_t
modifier|*
name|arg_val
decl_stmt|;
name|tree
name|arg
init|=
name|PHI_ARG_DEF
argument_list|(
name|phi
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|edge
name|e
init|=
name|PHI_ARG_EDGE
argument_list|(
name|phi
argument_list|,
name|i
argument_list|)
decl_stmt|;
comment|/* We don't care about values flowing through non-executable 	 edges.  */
if|if
condition|(
operator|!
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_EXECUTABLE
operator|)
condition|)
continue|continue;
comment|/* Constants in the argument list never generate a useful copy. 	 Similarly, names that flow through abnormal edges cannot be 	 used to derive copies.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|!=
name|SSA_NAME
operator|||
name|SSA_NAME_OCCURS_IN_ABNORMAL_PHI
argument_list|(
name|arg
argument_list|)
condition|)
block|{
name|phi_val
operator|.
name|value
operator|=
name|lhs
expr_stmt|;
break|break;
block|}
comment|/* Avoid copy propagation from an inner into an outer loop. 	 Otherwise, this may move loop variant variables outside of 	 their loops and prevent coalescing opportunities.  If the 	 value was loop invariant, it will be hoisted by LICM and 	 exposed for copy propagation.  */
if|if
condition|(
name|loop_depth_of_name
argument_list|(
name|arg
argument_list|)
operator|>
name|loop_depth_of_name
argument_list|(
name|lhs
argument_list|)
condition|)
block|{
name|phi_val
operator|.
name|value
operator|=
name|lhs
expr_stmt|;
break|break;
block|}
comment|/* If the LHS appears in the argument list, ignore it.  It is 	 irrelevant as a copy.  */
if|if
condition|(
name|arg
operator|==
name|lhs
operator|||
name|get_last_copy_of
argument_list|(
name|arg
argument_list|)
operator|==
name|lhs
condition|)
continue|continue;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\tArgument #%d: "
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|dump_copy_of
argument_list|(
name|dump_file
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|arg_val
operator|=
name|get_copy_of_val
argument_list|(
name|arg
argument_list|)
expr_stmt|;
comment|/* If the LHS didn't have a value yet, make it a copy of the 	 first argument we find.  Notice that while we make the LHS be 	 a copy of the argument itself, we take the memory reference 	 from the argument's value so that we can compare it to the 	 memory reference of all the other arguments.  */
if|if
condition|(
name|phi_val
operator|.
name|value
operator|==
name|NULL_TREE
condition|)
block|{
name|phi_val
operator|.
name|value
operator|=
name|arg
expr_stmt|;
name|phi_val
operator|.
name|mem_ref
operator|=
name|arg_val
operator|->
name|mem_ref
expr_stmt|;
continue|continue;
block|}
comment|/* If PHI_VAL and ARG don't have a common copy-of chain, then 	 this PHI node cannot be a copy operation.  Also, if we are 	 copy propagating stores and these two arguments came from 	 different memory references, they cannot be considered 	 copies.  */
if|if
condition|(
name|get_last_copy_of
argument_list|(
name|phi_val
operator|.
name|value
argument_list|)
operator|!=
name|get_last_copy_of
argument_list|(
name|arg
argument_list|)
operator|||
operator|(
name|do_store_copy_prop
operator|&&
name|phi_val
operator|.
name|mem_ref
operator|&&
name|arg_val
operator|->
name|mem_ref
operator|&&
name|simple_cst_equal
argument_list|(
name|phi_val
operator|.
name|mem_ref
argument_list|,
name|arg_val
operator|->
name|mem_ref
argument_list|)
operator|!=
literal|1
operator|)
condition|)
block|{
name|phi_val
operator|.
name|value
operator|=
name|lhs
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|phi_val
operator|.
name|value
operator|&&
name|set_copy_of_val
argument_list|(
name|lhs
argument_list|,
name|phi_val
operator|.
name|value
argument_list|,
name|phi_val
operator|.
name|mem_ref
argument_list|)
condition|)
name|retval
operator|=
operator|(
name|phi_val
operator|.
name|value
operator|!=
name|lhs
operator|)
condition|?
name|SSA_PROP_INTERESTING
else|:
name|SSA_PROP_VARYING
expr_stmt|;
else|else
name|retval
operator|=
name|SSA_PROP_NOT_INTERESTING
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\nPHI node "
argument_list|)
expr_stmt|;
name|dump_copy_of
argument_list|(
name|dump_file
argument_list|,
name|lhs
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\nTelling the propagator to "
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
name|SSA_PROP_INTERESTING
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"add SSA edges out of this PHI and continue."
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|retval
operator|==
name|SSA_PROP_VARYING
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"add SSA edges out of this PHI and never visit again."
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"do nothing with SSA edges and keep iterating."
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* Initialize structures used for copy propagation.   PHIS_ONLY is true    if we should only consider PHI nodes as generating copy propagation    opportunities.  */
end_comment

begin_function
specifier|static
name|void
name|init_copy_prop
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|copy_of
operator|=
name|XNEWVEC
argument_list|(
name|prop_value_t
argument_list|,
name|num_ssa_names
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|copy_of
argument_list|,
literal|0
argument_list|,
name|num_ssa_names
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|copy_of
argument_list|)
argument_list|)
expr_stmt|;
name|cached_last_copy_of
operator|=
name|XNEWVEC
argument_list|(
name|tree
argument_list|,
name|num_ssa_names
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|cached_last_copy_of
argument_list|,
literal|0
argument_list|,
name|num_ssa_names
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|cached_last_copy_of
argument_list|)
argument_list|)
expr_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|block_stmt_iterator
name|si
decl_stmt|;
name|tree
name|phi
decl_stmt|,
name|def
decl_stmt|;
name|int
name|depth
init|=
name|bb
operator|->
name|loop_depth
decl_stmt|;
for|for
control|(
name|si
operator|=
name|bsi_start
argument_list|(
name|bb
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|si
argument_list|)
condition|;
name|bsi_next
argument_list|(
operator|&
name|si
argument_list|)
control|)
block|{
name|tree
name|stmt
init|=
name|bsi_stmt
argument_list|(
name|si
argument_list|)
decl_stmt|;
name|ssa_op_iter
name|iter
decl_stmt|;
comment|/* The only statements that we care about are those that may 	     generate useful copies.  We also need to mark conditional 	     jumps so that their outgoing edges are added to the work 	     lists of the propagator.  	     Avoid copy propagation from an inner into an outer loop. 	     Otherwise, this may move loop variant variables outside of 	     their loops and prevent coalescing opportunities.  If the 	     value was loop invariant, it will be hoisted by LICM and 	     exposed for copy propagation.  */
if|if
condition|(
name|stmt_ends_bb_p
argument_list|(
name|stmt
argument_list|)
condition|)
name|DONT_SIMULATE_AGAIN
argument_list|(
name|stmt
argument_list|)
operator|=
name|false
expr_stmt|;
elseif|else
if|if
condition|(
name|stmt_may_generate_copy
argument_list|(
name|stmt
argument_list|)
operator|&&
name|loop_depth_of_name
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|<=
name|depth
condition|)
name|DONT_SIMULATE_AGAIN
argument_list|(
name|stmt
argument_list|)
operator|=
name|false
expr_stmt|;
else|else
name|DONT_SIMULATE_AGAIN
argument_list|(
name|stmt
argument_list|)
operator|=
name|true
expr_stmt|;
comment|/* Mark all the outputs of this statement as not being 	     the copy of anything.  */
name|FOR_EACH_SSA_TREE_OPERAND
argument_list|(
argument|def
argument_list|,
argument|stmt
argument_list|,
argument|iter
argument_list|,
argument|SSA_OP_ALL_DEFS
argument_list|)
if|if
condition|(
name|DONT_SIMULATE_AGAIN
argument_list|(
name|stmt
argument_list|)
condition|)
name|set_copy_of_val
argument_list|(
name|def
argument_list|,
name|def
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
else|else
name|cached_last_copy_of
index|[
name|SSA_NAME_VERSION
argument_list|(
name|def
argument_list|)
index|]
operator|=
name|def
expr_stmt|;
block|}
for|for
control|(
name|phi
operator|=
name|phi_nodes
argument_list|(
name|bb
argument_list|)
init|;
name|phi
condition|;
name|phi
operator|=
name|PHI_CHAIN
argument_list|(
name|phi
argument_list|)
control|)
block|{
name|def
operator|=
name|PHI_RESULT
argument_list|(
name|phi
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|do_store_copy_prop
operator|&&
operator|!
name|is_gimple_reg
argument_list|(
name|def
argument_list|)
condition|)
name|DONT_SIMULATE_AGAIN
argument_list|(
name|phi
argument_list|)
operator|=
name|true
expr_stmt|;
else|else
name|DONT_SIMULATE_AGAIN
argument_list|(
name|phi
argument_list|)
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|DONT_SIMULATE_AGAIN
argument_list|(
name|phi
argument_list|)
condition|)
name|set_copy_of_val
argument_list|(
name|def
argument_list|,
name|def
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
else|else
name|cached_last_copy_of
index|[
name|SSA_NAME_VERSION
argument_list|(
name|def
argument_list|)
index|]
operator|=
name|def
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Deallocate memory used in copy propagation and do final    substitution.  */
end_comment

begin_function
specifier|static
name|void
name|fini_copy_prop
parameter_list|(
name|void
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
name|prop_value_t
modifier|*
name|tmp
decl_stmt|;
comment|/* Set the final copy-of value for each variable by traversing the      copy-of chains.  */
name|tmp
operator|=
name|XNEWVEC
argument_list|(
name|prop_value_t
argument_list|,
name|num_ssa_names
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|,
name|num_ssa_names
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|num_ssa_names
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|var
init|=
name|ssa_name
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|var
operator|&&
name|copy_of
index|[
name|i
index|]
operator|.
name|value
operator|&&
name|copy_of
index|[
name|i
index|]
operator|.
name|value
operator|!=
name|var
condition|)
name|tmp
index|[
name|i
index|]
operator|.
name|value
operator|=
name|get_last_copy_of
argument_list|(
name|var
argument_list|)
expr_stmt|;
block|}
name|substitute_and_fold
argument_list|(
name|tmp
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cached_last_copy_of
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|copy_of
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Main entry point to the copy propagator.     PHIS_ONLY is true if we should only consider PHI nodes as generating    copy propagation opportunities.      The algorithm propagates the value COPY-OF using ssa_propagate.  For    every variable X_i, COPY-OF(X_i) indicates which variable is X_i created    from.  The following example shows how the algorithm proceeds at a    high level:  	    1	a_24 = x_1 	    2	a_2 = PHI<a_24, x_1> 	    3	a_5 = PHI<a_2> 	    4	x_1 = PHI<x_298, a_5, a_2>     The end result should be that a_2, a_5, a_24 and x_1 are a copy of    x_298.  Propagation proceeds as follows.     Visit #1: a_24 is copy-of x_1.  Value changed.    Visit #2: a_2 is copy-of x_1.  Value changed.    Visit #3: a_5 is copy-of x_1.  Value changed.    Visit #4: x_1 is copy-of x_298.  Value changed.    Visit #1: a_24 is copy-of x_298.  Value changed.    Visit #2: a_2 is copy-of x_298.  Value changed.    Visit #3: a_5 is copy-of x_298.  Value changed.    Visit #4: x_1 is copy-of x_298.  Stable state reached.        When visiting PHI nodes, we only consider arguments that flow    through edges marked executable by the propagation engine.  So,    when visiting statement #2 for the first time, we will only look at    the first argument (a_24) and optimistically assume that its value    is the copy of a_24 (x_1).     The problem with this approach is that it may fail to discover copy    relations in PHI cycles.  Instead of propagating copy-of    values, we actually propagate copy-of chains.  For instance:     		A_3 = B_1; 		C_9 = A_3; 		D_4 = C_9; 		X_i = D_4;     In this code fragment, COPY-OF (X_i) = { D_4, C_9, A_3, B_1 }.    Obviously, we are only really interested in the last value of the    chain, however the propagator needs to access the copy-of chain    when visiting PHI nodes.     To represent the copy-of chain, we use the array COPY_CHAINS, which    holds the first link in the copy-of chain for every variable.    If variable X_i is a copy of X_j, which in turn is a copy of X_k,    the array will contain:  		COPY_CHAINS[i] = X_j 		COPY_CHAINS[j] = X_k 		COPY_CHAINS[k] = X_k     Keeping copy-of chains instead of copy-of values directly becomes    important when visiting PHI nodes.  Suppose that we had the    following PHI cycle, such that x_52 is already considered a copy of    x_53:  	    1	x_54 = PHI<x_53, x_52> 	    2	x_53 = PHI<x_898, x_54>        Visit #1: x_54 is copy-of x_53 (because x_52 is copy-of x_53)    Visit #2: x_53 is copy-of x_898 (because x_54 is a copy of x_53, 				    so it is considered irrelevant 				    as a copy).    Visit #1: x_54 is copy-of nothing (x_53 is a copy-of x_898 and 				      x_52 is a copy of x_53, so 				      they don't match)    Visit #2: x_53 is copy-of nothing     This problem is avoided by keeping a chain of copies, instead of    the final copy-of value.  Propagation will now only keep the first    element of a variable's copy-of chain.  When visiting PHI nodes,    arguments are considered equal if their copy-of chains end in the    same variable.  So, as long as their copy-of chains overlap, we    know that they will be a copy of the same variable, regardless of    which variable that may be).        Propagation would then proceed as follows (the notation a -> b    means that a is a copy-of b):     Visit #1: x_54 = PHI<x_53, x_52> 		x_53 -> x_53 		x_52 -> x_53 		Result: x_54 -> x_53.  Value changed.  Add SSA edges.     Visit #1: x_53 = PHI<x_898, x_54>    		x_898 -> x_898 		x_54 -> x_53 		Result: x_53 -> x_898.  Value changed.  Add SSA edges.     Visit #2: x_54 = PHI<x_53, x_52>    		x_53 -> x_898 		x_52 -> x_53 -> x_898 		Result: x_54 -> x_898.  Value changed.  Add SSA edges.     Visit #2: x_53 = PHI<x_898, x_54>    		x_898 -> x_898 		x_54 -> x_898 		Result: x_53 -> x_898.  Value didn't change.  Stable state     Once the propagator stabilizes, we end up with the desired result    x_53 and x_54 are both copies of x_898.  */
end_comment

begin_function
specifier|static
name|void
name|execute_copy_prop
parameter_list|(
name|bool
name|store_copy_prop
parameter_list|)
block|{
name|do_store_copy_prop
operator|=
name|store_copy_prop
expr_stmt|;
name|init_copy_prop
argument_list|()
expr_stmt|;
name|ssa_propagate
argument_list|(
name|copy_prop_visit_stmt
argument_list|,
name|copy_prop_visit_phi_node
argument_list|)
expr_stmt|;
name|fini_copy_prop
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bool
name|gate_copy_prop
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|flag_tree_copy_prop
operator|!=
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|do_copy_prop
parameter_list|(
name|void
parameter_list|)
block|{
name|execute_copy_prop
argument_list|(
name|false
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|tree_opt_pass
name|pass_copy_prop
init|=
block|{
literal|"copyprop"
block|,
comment|/* name */
name|gate_copy_prop
block|,
comment|/* gate */
name|do_copy_prop
block|,
comment|/* execute */
name|NULL
block|,
comment|/* sub */
name|NULL
block|,
comment|/* next */
literal|0
block|,
comment|/* static_pass_number */
name|TV_TREE_COPY_PROP
block|,
comment|/* tv_id */
name|PROP_ssa
operator||
name|PROP_alias
operator||
name|PROP_cfg
block|,
comment|/* properties_required */
literal|0
block|,
comment|/* properties_provided */
literal|0
block|,
comment|/* properties_destroyed */
literal|0
block|,
comment|/* todo_flags_start */
name|TODO_cleanup_cfg
operator||
name|TODO_dump_func
operator||
name|TODO_ggc_collect
operator||
name|TODO_verify_ssa
operator||
name|TODO_update_ssa
block|,
comment|/* todo_flags_finish */
literal|0
comment|/* letter */
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|bool
name|gate_store_copy_prop
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* STORE-COPY-PROP is enabled only with -ftree-store-copy-prop, but      when -fno-tree-store-copy-prop is specified, we should run      regular COPY-PROP. That's why the pass is enabled with either      flag.  */
return|return
name|flag_tree_store_copy_prop
operator|!=
literal|0
operator|||
name|flag_tree_copy_prop
operator|!=
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|store_copy_prop
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* If STORE-COPY-PROP is not enabled, we just run regular COPY-PROP.  */
name|execute_copy_prop
argument_list|(
name|flag_tree_store_copy_prop
operator|!=
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|tree_opt_pass
name|pass_store_copy_prop
init|=
block|{
literal|"store_copyprop"
block|,
comment|/* name */
name|gate_store_copy_prop
block|,
comment|/* gate */
name|store_copy_prop
block|,
comment|/* execute */
name|NULL
block|,
comment|/* sub */
name|NULL
block|,
comment|/* next */
literal|0
block|,
comment|/* static_pass_number */
name|TV_TREE_STORE_COPY_PROP
block|,
comment|/* tv_id */
name|PROP_ssa
operator||
name|PROP_alias
operator||
name|PROP_cfg
block|,
comment|/* properties_required */
literal|0
block|,
comment|/* properties_provided */
literal|0
block|,
comment|/* properties_destroyed */
literal|0
block|,
comment|/* todo_flags_start */
name|TODO_dump_func
operator||
name|TODO_cleanup_cfg
operator||
name|TODO_ggc_collect
operator||
name|TODO_verify_ssa
operator||
name|TODO_update_ssa
block|,
comment|/* todo_flags_finish */
literal|0
comment|/* letter */
block|}
decl_stmt|;
end_decl_stmt

end_unit

