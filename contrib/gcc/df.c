begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Dataflow support routines.    Copyright (C) 1999, 2000, 2001, 2002 Free Software Foundation, Inc.    Contributed by Michael P. Hayes (m.hayes@elec.canterbury.ac.nz,                                     mhayes@redhat.com)  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.   OVERVIEW:  This file provides some dataflow routines for computing reaching defs, upward exposed uses, live variables, def-use chains, and use-def chains.  The global dataflow is performed using simple iterative methods with a worklist and could be sped up by ordering the blocks with a depth first search order.  A `struct ref' data structure (ref) is allocated for every register reference (def or use) and this records the insn and bb the ref is found within.  The refs are linked together in chains of uses and defs for each insn and for each register.  Each ref also has a chain field that links all the use refs for a def or all the def refs for a use. This is used to create use-def or def-use chains.   USAGE:  Here's an example of using the dataflow routines.        struct df *df;        df = df_init ();        df_analyse (df, 0, DF_ALL);        df_dump (df, DF_ALL, stderr);        df_finish (df);   df_init simply creates a poor man's object (df) that needs to be passed to all the dataflow routines.  df_finish destroys this object and frees up any allocated memory.  df_analyse performs the following:  1. Records defs and uses by scanning the insns in each basic block    or by scanning the insns queued by df_insn_modify. 2. Links defs and uses into insn-def and insn-use chains. 3. Links defs and uses into reg-def and reg-use chains. 4. Assigns LUIDs to each insn (for modified blocks). 5. Calculates local reaching definitions. 6. Calculates global reaching definitions. 7. Creates use-def chains. 8. Calculates local reaching uses (upwards exposed uses). 9. Calculates global reaching uses. 10. Creates def-use chains. 11. Calculates local live registers. 12. Calculates global live registers. 13. Calculates register lifetimes and determines local registers.   PHILOSOPHY:  Note that the dataflow information is not updated for every newly deleted or created insn.  If the dataflow information requires updating then all the changed, new, or deleted insns needs to be marked with df_insn_modify (or df_insns_modify) either directly or indirectly (say through calling df_insn_delete).  df_insn_modify marks all the modified insns to get processed the next time df_analyse  is called.  Beware that tinkering with insns may invalidate the dataflow information. The philosophy behind these routines is that once the dataflow information has been gathered, the user should store what they require before they tinker with any insn.  Once a reg is replaced, for example, then the reg-def/reg-use chains will point to the wrong place.  Once a whole lot of changes have been made, df_analyse can be called again to update the dataflow information.  Currently, this is not very smart with regard to propagating changes to the dataflow so it should not be called very often.   DATA STRUCTURES:  The basic object is a REF (reference) and this may either be a DEF (definition) or a USE of a register.  These are linked into a variety of lists; namely reg-def, reg-use,   insn-def, insn-use, def-use, and use-def lists.  For example, the reg-def lists contain all the refs that define a given register while the insn-use lists contain all the refs used by an insn.  Note that the reg-def and reg-use chains are generally short (except for the hard registers) and thus it is much faster to search these chains rather than searching the def or use bitmaps.  If the insns are in SSA form then the reg-def and use-def lists should only contain the single defining ref.  TODO:  1) Incremental dataflow analysis.  Note that if a loop invariant insn is hoisted (or sunk), we do not need to change the def-use or use-def chains.  All we have to do is to change the bb field for all the associated defs and uses and to renumber the LUIDs for the original and new basic blocks of the insn.  When shadowing loop mems we create new uses and defs for new pseudos so we do not affect the existing dataflow information.  My current strategy is to queue up all modified, created, or deleted insns so when df_analyse is called we can easily determine all the new or deleted refs.  Currently the global dataflow information is recomputed from scratch but this could be propagated more efficiently.  2) Improved global data flow computation using depth first search.  3) Reduced memory requirements.  We could operate a pool of ref structures.  When a ref is deleted it gets returned to the pool (say by linking on to a chain of free refs). This will require a pair of bitmaps for defs and uses so that we can tell which ones have been changed.  Alternatively, we could periodically squeeze the def and use tables and associated bitmaps and renumber the def and use ids.  4) Ordering of reg-def and reg-use lists.  Should the first entry in the def list be the first def (within a BB)? Similarly, should the first entry in the use list be the last use (within a BB)?  5) Working with a sub-CFG.  Often the whole CFG does not need to be analysed, for example, when optimising a loop, only certain registers are of interest. Perhaps there should be a bitmap argument to df_analyse to specify  which registers should be analysed?   */
end_comment

begin_define
define|#
directive|define
name|HANDLE_SUBREG
end_define

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"sbitmap.h"
end_include

begin_include
include|#
directive|include
file|"bitmap.h"
end_include

begin_include
include|#
directive|include
file|"df.h"
end_include

begin_include
include|#
directive|include
file|"fibheap.h"
end_include

begin_define
define|#
directive|define
name|FOR_ALL_BBS
parameter_list|(
name|BB
parameter_list|,
name|CODE
parameter_list|)
define|\
value|do {								\   int node_;							\   for (node_ = 0; node_< n_basic_blocks; node_++)		\     {(BB) = BASIC_BLOCK (node_); CODE;};} while (0)
end_define

begin_define
define|#
directive|define
name|FOR_EACH_BB_IN_BITMAP
parameter_list|(
name|BITMAP
parameter_list|,
name|MIN
parameter_list|,
name|BB
parameter_list|,
name|CODE
parameter_list|)
define|\
value|do {								\   unsigned int node_;						\   EXECUTE_IF_SET_IN_BITMAP (BITMAP, MIN, node_, 		\     {(BB) = BASIC_BLOCK (node_); CODE;});} while (0)
end_define

begin_define
define|#
directive|define
name|FOR_EACH_BB_IN_BITMAP_REV
parameter_list|(
name|BITMAP
parameter_list|,
name|MIN
parameter_list|,
name|BB
parameter_list|,
name|CODE
parameter_list|)
define|\
value|do {								\   unsigned int node_;						\   EXECUTE_IF_SET_IN_BITMAP_REV (BITMAP, node_, 		\     {(BB) = BASIC_BLOCK (node_); CODE;});} while (0)
end_define

begin_define
define|#
directive|define
name|FOR_EACH_BB_IN_SBITMAP
parameter_list|(
name|BITMAP
parameter_list|,
name|MIN
parameter_list|,
name|BB
parameter_list|,
name|CODE
parameter_list|)
define|\
value|do {                                                            \   unsigned int node_;                                           \   EXECUTE_IF_SET_IN_SBITMAP (BITMAP, MIN, node_,                \     {(BB) = BASIC_BLOCK (node_); CODE;});} while (0)
end_define

begin_define
define|#
directive|define
name|obstack_chunk_alloc
value|xmalloc
end_define

begin_define
define|#
directive|define
name|obstack_chunk_free
value|free
end_define

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|df_ref_obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|df
modifier|*
name|ddf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|df_reg_table_realloc
name|PARAMS
argument_list|(
operator|(
expr|struct
name|df
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static void df_def_table_realloc PARAMS((struct df *, int));
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|df_insn_table_realloc
name|PARAMS
argument_list|(
operator|(
expr|struct
name|df
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|df_bitmaps_alloc
name|PARAMS
argument_list|(
operator|(
expr|struct
name|df
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|df_bitmaps_free
name|PARAMS
argument_list|(
operator|(
expr|struct
name|df
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|df_free
name|PARAMS
argument_list|(
operator|(
expr|struct
name|df
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|df_alloc
name|PARAMS
argument_list|(
operator|(
expr|struct
name|df
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|df_reg_clobber_gen
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|df_reg_use_gen
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|inline
name|struct
name|df_link
modifier|*
name|df_link_create
name|PARAMS
argument_list|(
operator|(
expr|struct
name|ref
operator|*
operator|,
expr|struct
name|df_link
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|df_link
modifier|*
name|df_ref_unlink
name|PARAMS
argument_list|(
operator|(
expr|struct
name|df_link
operator|*
operator|*
operator|,
expr|struct
name|ref
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|df_def_unlink
name|PARAMS
argument_list|(
operator|(
expr|struct
name|df
operator|*
operator|,
expr|struct
name|ref
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|df_use_unlink
name|PARAMS
argument_list|(
operator|(
expr|struct
name|df
operator|*
operator|,
expr|struct
name|ref
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|df_insn_refs_unlink
name|PARAMS
argument_list|(
operator|(
expr|struct
name|df
operator|*
operator|,
name|basic_block
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static void df_bb_refs_unlink PARAMS ((struct df *, basic_block)); static void df_refs_unlink PARAMS ((struct df *, bitmap));
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|struct
name|ref
modifier|*
name|df_ref_create
name|PARAMS
argument_list|(
operator|(
expr|struct
name|df
operator|*
operator|,
name|rtx
operator|,
name|rtx
operator|*
operator|,
name|rtx
operator|,
expr|enum
name|df_ref_type
operator|,
expr|enum
name|df_ref_flags
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|df_ref_record_1
name|PARAMS
argument_list|(
operator|(
expr|struct
name|df
operator|*
operator|,
name|rtx
operator|,
name|rtx
operator|*
operator|,
name|rtx
operator|,
expr|enum
name|df_ref_type
operator|,
expr|enum
name|df_ref_flags
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|df_ref_record
name|PARAMS
argument_list|(
operator|(
expr|struct
name|df
operator|*
operator|,
name|rtx
operator|,
name|rtx
operator|*
operator|,
name|rtx
operator|,
expr|enum
name|df_ref_type
operator|,
expr|enum
name|df_ref_flags
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|df_def_record_1
name|PARAMS
argument_list|(
operator|(
expr|struct
name|df
operator|*
operator|,
name|rtx
operator|,
name|basic_block
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|df_defs_record
name|PARAMS
argument_list|(
operator|(
expr|struct
name|df
operator|*
operator|,
name|rtx
operator|,
name|basic_block
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|df_uses_record
name|PARAMS
argument_list|(
operator|(
expr|struct
name|df
operator|*
operator|,
name|rtx
operator|*
operator|,
expr|enum
name|df_ref_type
operator|,
name|basic_block
operator|,
name|rtx
operator|,
expr|enum
name|df_ref_flags
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|df_insn_refs_record
name|PARAMS
argument_list|(
operator|(
expr|struct
name|df
operator|*
operator|,
name|basic_block
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|df_bb_refs_record
name|PARAMS
argument_list|(
operator|(
expr|struct
name|df
operator|*
operator|,
name|basic_block
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|df_refs_record
name|PARAMS
argument_list|(
operator|(
expr|struct
name|df
operator|*
operator|,
name|bitmap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|df_bb_reg_def_chain_create
name|PARAMS
argument_list|(
operator|(
expr|struct
name|df
operator|*
operator|,
name|basic_block
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|df_reg_def_chain_create
name|PARAMS
argument_list|(
operator|(
expr|struct
name|df
operator|*
operator|,
name|bitmap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|df_bb_reg_use_chain_create
name|PARAMS
argument_list|(
operator|(
expr|struct
name|df
operator|*
operator|,
name|basic_block
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|df_reg_use_chain_create
name|PARAMS
argument_list|(
operator|(
expr|struct
name|df
operator|*
operator|,
name|bitmap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|df_bb_du_chain_create
name|PARAMS
argument_list|(
operator|(
expr|struct
name|df
operator|*
operator|,
name|basic_block
operator|,
name|bitmap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|df_du_chain_create
name|PARAMS
argument_list|(
operator|(
expr|struct
name|df
operator|*
operator|,
name|bitmap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|df_bb_ud_chain_create
name|PARAMS
argument_list|(
operator|(
expr|struct
name|df
operator|*
operator|,
name|basic_block
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|df_ud_chain_create
name|PARAMS
argument_list|(
operator|(
expr|struct
name|df
operator|*
operator|,
name|bitmap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|df_bb_rd_local_compute
name|PARAMS
argument_list|(
operator|(
expr|struct
name|df
operator|*
operator|,
name|basic_block
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|df_rd_local_compute
name|PARAMS
argument_list|(
operator|(
expr|struct
name|df
operator|*
operator|,
name|bitmap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|df_bb_ru_local_compute
name|PARAMS
argument_list|(
operator|(
expr|struct
name|df
operator|*
operator|,
name|basic_block
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|df_ru_local_compute
name|PARAMS
argument_list|(
operator|(
expr|struct
name|df
operator|*
operator|,
name|bitmap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|df_bb_lr_local_compute
name|PARAMS
argument_list|(
operator|(
expr|struct
name|df
operator|*
operator|,
name|basic_block
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|df_lr_local_compute
name|PARAMS
argument_list|(
operator|(
expr|struct
name|df
operator|*
operator|,
name|bitmap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|df_bb_reg_info_compute
name|PARAMS
argument_list|(
operator|(
expr|struct
name|df
operator|*
operator|,
name|basic_block
operator|,
name|bitmap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|df_reg_info_compute
name|PARAMS
argument_list|(
operator|(
expr|struct
name|df
operator|*
operator|,
name|bitmap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|df_bb_luids_set
name|PARAMS
argument_list|(
operator|(
expr|struct
name|df
operator|*
name|df
operator|,
name|basic_block
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|df_luids_set
name|PARAMS
argument_list|(
operator|(
expr|struct
name|df
operator|*
name|df
operator|,
name|bitmap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|df_modified_p
name|PARAMS
argument_list|(
operator|(
expr|struct
name|df
operator|*
operator|,
name|bitmap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|df_refs_queue
name|PARAMS
argument_list|(
operator|(
expr|struct
name|df
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|df_refs_process
name|PARAMS
argument_list|(
operator|(
expr|struct
name|df
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|df_bb_refs_update
name|PARAMS
argument_list|(
operator|(
expr|struct
name|df
operator|*
operator|,
name|basic_block
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|df_refs_update
name|PARAMS
argument_list|(
operator|(
expr|struct
name|df
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|df_analyse_1
name|PARAMS
argument_list|(
operator|(
expr|struct
name|df
operator|*
operator|,
name|bitmap
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|df_insns_modify
name|PARAMS
argument_list|(
operator|(
expr|struct
name|df
operator|*
operator|,
name|basic_block
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|df_rtx_mem_replace
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|df_rtx_reg_replace
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|df_refs_reg_replace
name|PARAMS
argument_list|(
operator|(
expr|struct
name|df
operator|*
operator|,
name|bitmap
operator|,
expr|struct
name|df_link
operator|*
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|df_def_dominates_all_uses_p
name|PARAMS
argument_list|(
operator|(
expr|struct
name|df
operator|*
operator|,
expr|struct
name|ref
operator|*
name|def
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|df_def_dominates_uses_p
name|PARAMS
argument_list|(
operator|(
expr|struct
name|df
operator|*
operator|,
expr|struct
name|ref
operator|*
name|def
operator|,
name|bitmap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ref
modifier|*
name|df_bb_regno_last_use_find
name|PARAMS
argument_list|(
operator|(
expr|struct
name|df
operator|*
operator|,
name|basic_block
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ref
modifier|*
name|df_bb_regno_first_def_find
name|PARAMS
argument_list|(
operator|(
expr|struct
name|df
operator|*
operator|,
name|basic_block
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ref
modifier|*
name|df_bb_insn_regno_last_use_find
name|PARAMS
argument_list|(
operator|(
expr|struct
name|df
operator|*
operator|,
name|basic_block
operator|,
name|rtx
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ref
modifier|*
name|df_bb_insn_regno_first_def_find
name|PARAMS
argument_list|(
operator|(
expr|struct
name|df
operator|*
operator|,
name|basic_block
operator|,
name|rtx
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|df_chain_dump
name|PARAMS
argument_list|(
operator|(
expr|struct
name|df_link
operator|*
operator|,
name|FILE
operator|*
name|file
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|df_chain_dump_regno
name|PARAMS
argument_list|(
operator|(
expr|struct
name|df_link
operator|*
operator|,
name|FILE
operator|*
name|file
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|df_regno_debug
name|PARAMS
argument_list|(
operator|(
expr|struct
name|df
operator|*
operator|,
name|unsigned
name|int
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|df_ref_debug
name|PARAMS
argument_list|(
operator|(
expr|struct
name|df
operator|*
operator|,
expr|struct
name|ref
operator|*
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|df_rd_transfer_function
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|*
operator|,
name|bitmap
operator|,
name|bitmap
operator|,
name|bitmap
operator|,
name|bitmap
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|df_ru_transfer_function
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|*
operator|,
name|bitmap
operator|,
name|bitmap
operator|,
name|bitmap
operator|,
name|bitmap
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|df_lr_transfer_function
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|*
operator|,
name|bitmap
operator|,
name|bitmap
operator|,
name|bitmap
operator|,
name|bitmap
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|hybrid_search_bitmap
name|PARAMS
argument_list|(
operator|(
name|basic_block
operator|,
name|bitmap
operator|*
operator|,
name|bitmap
operator|*
operator|,
name|bitmap
operator|*
operator|,
name|bitmap
operator|*
operator|,
expr|enum
name|df_flow_dir
operator|,
expr|enum
name|df_confluence_op
operator|,
name|transfer_function_bitmap
operator|,
name|sbitmap
operator|,
name|sbitmap
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|hybrid_search_sbitmap
name|PARAMS
argument_list|(
operator|(
name|basic_block
operator|,
name|sbitmap
operator|*
operator|,
name|sbitmap
operator|*
operator|,
name|sbitmap
operator|*
operator|,
name|sbitmap
operator|*
operator|,
expr|enum
name|df_flow_dir
operator|,
expr|enum
name|df_confluence_op
operator|,
name|transfer_function_sbitmap
operator|,
name|sbitmap
operator|,
name|sbitmap
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|inline
name|bool
name|read_modify_subreg_p
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Local memory allocation/deallocation routines.  */
end_comment

begin_comment
comment|/* Increase the insn info table by SIZE more elements.  */
end_comment

begin_function
specifier|static
name|void
name|df_insn_table_realloc
parameter_list|(
name|df
parameter_list|,
name|size
parameter_list|)
name|struct
name|df
modifier|*
name|df
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
comment|/* Make table 25 percent larger by default.  */
if|if
condition|(
operator|!
name|size
condition|)
name|size
operator|=
name|df
operator|->
name|insn_size
operator|/
literal|4
expr_stmt|;
name|size
operator|+=
name|df
operator|->
name|insn_size
expr_stmt|;
name|df
operator|->
name|insns
operator|=
operator|(
expr|struct
name|insn_info
operator|*
operator|)
name|xrealloc
argument_list|(
name|df
operator|->
name|insns
argument_list|,
name|size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|insn_info
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|df
operator|->
name|insns
operator|+
name|df
operator|->
name|insn_size
argument_list|,
literal|0
argument_list|,
operator|(
name|size
operator|-
name|df
operator|->
name|insn_size
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|insn_info
argument_list|)
argument_list|)
expr_stmt|;
name|df
operator|->
name|insn_size
operator|=
name|size
expr_stmt|;
if|if
condition|(
operator|!
name|df
operator|->
name|insns_modified
condition|)
block|{
name|df
operator|->
name|insns_modified
operator|=
name|BITMAP_XMALLOC
argument_list|()
expr_stmt|;
name|bitmap_zero
argument_list|(
name|df
operator|->
name|insns_modified
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Increase the reg info table by SIZE more elements.  */
end_comment

begin_function
specifier|static
name|void
name|df_reg_table_realloc
parameter_list|(
name|df
parameter_list|,
name|size
parameter_list|)
name|struct
name|df
modifier|*
name|df
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
comment|/* Make table 25 percent larger by default.  */
if|if
condition|(
operator|!
name|size
condition|)
name|size
operator|=
name|df
operator|->
name|reg_size
operator|/
literal|4
expr_stmt|;
name|size
operator|+=
name|df
operator|->
name|reg_size
expr_stmt|;
name|df
operator|->
name|regs
operator|=
operator|(
expr|struct
name|reg_info
operator|*
operator|)
name|xrealloc
argument_list|(
name|df
operator|->
name|regs
argument_list|,
name|size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|reg_info
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Zero the new entries.  */
name|memset
argument_list|(
name|df
operator|->
name|regs
operator|+
name|df
operator|->
name|reg_size
argument_list|,
literal|0
argument_list|,
operator|(
name|size
operator|-
name|df
operator|->
name|reg_size
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|reg_info
argument_list|)
argument_list|)
expr_stmt|;
name|df
operator|->
name|reg_size
operator|=
name|size
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Not currently used.  */
end_comment

begin_comment
unit|static void df_def_table_realloc (df, size)      struct df *df;      int size; {   int i;   struct ref *refs;
comment|/* Make table 25 percent larger by default.  */
end_comment

begin_comment
unit|if (! size)     size = df->def_size / 4;    df->def_size += size;   df->defs = xrealloc (df->defs, 		       df->def_size * sizeof (*df->defs));
comment|/* Allocate a new block of memory and link into list of blocks      that will need to be freed later.  */
end_comment

begin_comment
unit|refs = xmalloc (size * sizeof (*refs));
comment|/* Link all the new refs together, overloading the chain field.  */
end_comment

begin_endif
unit|for (i = 0; i< size - 1; i++)       refs[i].chain = (struct df_link *)(refs + i + 1);   refs[size - 1].chain = 0; }
endif|#
directive|endif
end_endif

begin_comment
comment|/* Allocate bitmaps for each basic block.  */
end_comment

begin_function
specifier|static
name|void
name|df_bitmaps_alloc
parameter_list|(
name|df
parameter_list|,
name|flags
parameter_list|)
name|struct
name|df
modifier|*
name|df
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|int
name|dflags
init|=
literal|0
decl_stmt|;
comment|/* Free the bitmaps if they need resizing.  */
if|if
condition|(
operator|(
name|flags
operator|&
name|DF_LR
operator|)
operator|&&
name|df
operator|->
name|n_regs
operator|<
operator|(
name|unsigned
name|int
operator|)
name|max_reg_num
argument_list|()
condition|)
name|dflags
operator||=
name|DF_LR
operator||
name|DF_RU
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|DF_RU
operator|)
operator|&&
name|df
operator|->
name|n_uses
operator|<
name|df
operator|->
name|use_id
condition|)
name|dflags
operator||=
name|DF_RU
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|DF_RD
operator|)
operator|&&
name|df
operator|->
name|n_defs
operator|<
name|df
operator|->
name|def_id
condition|)
name|dflags
operator||=
name|DF_RD
expr_stmt|;
if|if
condition|(
name|dflags
condition|)
name|df_bitmaps_free
argument_list|(
name|df
argument_list|,
name|dflags
argument_list|)
expr_stmt|;
name|df
operator|->
name|n_defs
operator|=
name|df
operator|->
name|def_id
expr_stmt|;
name|df
operator|->
name|n_uses
operator|=
name|df
operator|->
name|use_id
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|df
operator|->
name|n_bbs
condition|;
name|i
operator|++
control|)
block|{
name|basic_block
name|bb
init|=
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|struct
name|bb_info
modifier|*
name|bb_info
init|=
name|DF_BB_INFO
argument_list|(
name|df
argument_list|,
name|bb
argument_list|)
decl_stmt|;
if|if
condition|(
name|flags
operator|&
name|DF_RD
operator|&&
operator|!
name|bb_info
operator|->
name|rd_in
condition|)
block|{
comment|/* Allocate bitmaps for reaching definitions.  */
name|bb_info
operator|->
name|rd_kill
operator|=
name|BITMAP_XMALLOC
argument_list|()
expr_stmt|;
name|bitmap_zero
argument_list|(
name|bb_info
operator|->
name|rd_kill
argument_list|)
expr_stmt|;
name|bb_info
operator|->
name|rd_gen
operator|=
name|BITMAP_XMALLOC
argument_list|()
expr_stmt|;
name|bitmap_zero
argument_list|(
name|bb_info
operator|->
name|rd_gen
argument_list|)
expr_stmt|;
name|bb_info
operator|->
name|rd_in
operator|=
name|BITMAP_XMALLOC
argument_list|()
expr_stmt|;
name|bb_info
operator|->
name|rd_out
operator|=
name|BITMAP_XMALLOC
argument_list|()
expr_stmt|;
name|bb_info
operator|->
name|rd_valid
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|DF_RU
operator|&&
operator|!
name|bb_info
operator|->
name|ru_in
condition|)
block|{
comment|/* Allocate bitmaps for upward exposed uses.  */
name|bb_info
operator|->
name|ru_kill
operator|=
name|BITMAP_XMALLOC
argument_list|()
expr_stmt|;
name|bitmap_zero
argument_list|(
name|bb_info
operator|->
name|ru_kill
argument_list|)
expr_stmt|;
comment|/* Note the lack of symmetry.  */
name|bb_info
operator|->
name|ru_gen
operator|=
name|BITMAP_XMALLOC
argument_list|()
expr_stmt|;
name|bitmap_zero
argument_list|(
name|bb_info
operator|->
name|ru_gen
argument_list|)
expr_stmt|;
name|bb_info
operator|->
name|ru_in
operator|=
name|BITMAP_XMALLOC
argument_list|()
expr_stmt|;
name|bb_info
operator|->
name|ru_out
operator|=
name|BITMAP_XMALLOC
argument_list|()
expr_stmt|;
name|bb_info
operator|->
name|ru_valid
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|DF_LR
operator|&&
operator|!
name|bb_info
operator|->
name|lr_in
condition|)
block|{
comment|/* Allocate bitmaps for live variables.  */
name|bb_info
operator|->
name|lr_def
operator|=
name|BITMAP_XMALLOC
argument_list|()
expr_stmt|;
name|bitmap_zero
argument_list|(
name|bb_info
operator|->
name|lr_def
argument_list|)
expr_stmt|;
name|bb_info
operator|->
name|lr_use
operator|=
name|BITMAP_XMALLOC
argument_list|()
expr_stmt|;
name|bitmap_zero
argument_list|(
name|bb_info
operator|->
name|lr_use
argument_list|)
expr_stmt|;
name|bb_info
operator|->
name|lr_in
operator|=
name|BITMAP_XMALLOC
argument_list|()
expr_stmt|;
name|bb_info
operator|->
name|lr_out
operator|=
name|BITMAP_XMALLOC
argument_list|()
expr_stmt|;
name|bb_info
operator|->
name|lr_valid
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Free bitmaps for each basic block.  */
end_comment

begin_function
specifier|static
name|void
name|df_bitmaps_free
parameter_list|(
name|df
parameter_list|,
name|flags
parameter_list|)
name|struct
name|df
modifier|*
name|df
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|df
operator|->
name|n_bbs
condition|;
name|i
operator|++
control|)
block|{
name|basic_block
name|bb
init|=
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|struct
name|bb_info
modifier|*
name|bb_info
init|=
name|DF_BB_INFO
argument_list|(
name|df
argument_list|,
name|bb
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|bb_info
condition|)
continue|continue;
if|if
condition|(
operator|(
name|flags
operator|&
name|DF_RD
operator|)
operator|&&
name|bb_info
operator|->
name|rd_in
condition|)
block|{
comment|/* Free bitmaps for reaching definitions.  */
name|BITMAP_XFREE
argument_list|(
name|bb_info
operator|->
name|rd_kill
argument_list|)
expr_stmt|;
name|bb_info
operator|->
name|rd_kill
operator|=
name|NULL
expr_stmt|;
name|BITMAP_XFREE
argument_list|(
name|bb_info
operator|->
name|rd_gen
argument_list|)
expr_stmt|;
name|bb_info
operator|->
name|rd_gen
operator|=
name|NULL
expr_stmt|;
name|BITMAP_XFREE
argument_list|(
name|bb_info
operator|->
name|rd_in
argument_list|)
expr_stmt|;
name|bb_info
operator|->
name|rd_in
operator|=
name|NULL
expr_stmt|;
name|BITMAP_XFREE
argument_list|(
name|bb_info
operator|->
name|rd_out
argument_list|)
expr_stmt|;
name|bb_info
operator|->
name|rd_out
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|DF_RU
operator|)
operator|&&
name|bb_info
operator|->
name|ru_in
condition|)
block|{
comment|/* Free bitmaps for upward exposed uses.  */
name|BITMAP_XFREE
argument_list|(
name|bb_info
operator|->
name|ru_kill
argument_list|)
expr_stmt|;
name|bb_info
operator|->
name|ru_kill
operator|=
name|NULL
expr_stmt|;
name|BITMAP_XFREE
argument_list|(
name|bb_info
operator|->
name|ru_gen
argument_list|)
expr_stmt|;
name|bb_info
operator|->
name|ru_gen
operator|=
name|NULL
expr_stmt|;
name|BITMAP_XFREE
argument_list|(
name|bb_info
operator|->
name|ru_in
argument_list|)
expr_stmt|;
name|bb_info
operator|->
name|ru_in
operator|=
name|NULL
expr_stmt|;
name|BITMAP_XFREE
argument_list|(
name|bb_info
operator|->
name|ru_out
argument_list|)
expr_stmt|;
name|bb_info
operator|->
name|ru_out
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|DF_LR
operator|)
operator|&&
name|bb_info
operator|->
name|lr_in
condition|)
block|{
comment|/* Free bitmaps for live variables.  */
name|BITMAP_XFREE
argument_list|(
name|bb_info
operator|->
name|lr_def
argument_list|)
expr_stmt|;
name|bb_info
operator|->
name|lr_def
operator|=
name|NULL
expr_stmt|;
name|BITMAP_XFREE
argument_list|(
name|bb_info
operator|->
name|lr_use
argument_list|)
expr_stmt|;
name|bb_info
operator|->
name|lr_use
operator|=
name|NULL
expr_stmt|;
name|BITMAP_XFREE
argument_list|(
name|bb_info
operator|->
name|lr_in
argument_list|)
expr_stmt|;
name|bb_info
operator|->
name|lr_in
operator|=
name|NULL
expr_stmt|;
name|BITMAP_XFREE
argument_list|(
name|bb_info
operator|->
name|lr_out
argument_list|)
expr_stmt|;
name|bb_info
operator|->
name|lr_out
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|df
operator|->
name|flags
operator|&=
operator|~
operator|(
name|flags
operator|&
operator|(
name|DF_RD
operator||
name|DF_RU
operator||
name|DF_LR
operator|)
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Allocate and initialise dataflow memory.  */
end_comment

begin_function
specifier|static
name|void
name|df_alloc
parameter_list|(
name|df
parameter_list|,
name|n_regs
parameter_list|)
name|struct
name|df
modifier|*
name|df
decl_stmt|;
name|int
name|n_regs
decl_stmt|;
block|{
name|int
name|n_insns
decl_stmt|;
name|int
name|i
decl_stmt|;
name|gcc_obstack_init
argument_list|(
operator|&
name|df_ref_obstack
argument_list|)
expr_stmt|;
comment|/* Perhaps we should use LUIDs to save memory for the insn_refs      table.  This is only a small saving; a few pointers.  */
name|n_insns
operator|=
name|get_max_uid
argument_list|()
operator|+
literal|1
expr_stmt|;
name|df
operator|->
name|def_id
operator|=
literal|0
expr_stmt|;
name|df
operator|->
name|n_defs
operator|=
literal|0
expr_stmt|;
comment|/* Approximate number of defs by number of insns.  */
name|df
operator|->
name|def_size
operator|=
name|n_insns
expr_stmt|;
name|df
operator|->
name|defs
operator|=
name|xmalloc
argument_list|(
name|df
operator|->
name|def_size
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|df
operator|->
name|defs
argument_list|)
argument_list|)
expr_stmt|;
name|df
operator|->
name|use_id
operator|=
literal|0
expr_stmt|;
name|df
operator|->
name|n_uses
operator|=
literal|0
expr_stmt|;
comment|/* Approximate number of uses by twice number of insns.  */
name|df
operator|->
name|use_size
operator|=
name|n_insns
operator|*
literal|2
expr_stmt|;
name|df
operator|->
name|uses
operator|=
name|xmalloc
argument_list|(
name|df
operator|->
name|use_size
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|df
operator|->
name|uses
argument_list|)
argument_list|)
expr_stmt|;
name|df
operator|->
name|n_regs
operator|=
name|n_regs
expr_stmt|;
name|df
operator|->
name|n_bbs
operator|=
name|n_basic_blocks
expr_stmt|;
comment|/* Allocate temporary working array used during local dataflow analysis.  */
name|df
operator|->
name|reg_def_last
operator|=
name|xmalloc
argument_list|(
name|df
operator|->
name|n_regs
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ref
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|df_insn_table_realloc
argument_list|(
name|df
argument_list|,
name|n_insns
argument_list|)
expr_stmt|;
name|df_reg_table_realloc
argument_list|(
name|df
argument_list|,
name|df
operator|->
name|n_regs
argument_list|)
expr_stmt|;
name|df
operator|->
name|bbs_modified
operator|=
name|BITMAP_XMALLOC
argument_list|()
expr_stmt|;
name|bitmap_zero
argument_list|(
name|df
operator|->
name|bbs_modified
argument_list|)
expr_stmt|;
name|df
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|df
operator|->
name|bbs
operator|=
name|xcalloc
argument_list|(
name|df
operator|->
name|n_bbs
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|bb_info
argument_list|)
argument_list|)
expr_stmt|;
name|df
operator|->
name|all_blocks
operator|=
name|BITMAP_XMALLOC
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
name|i
operator|++
control|)
name|bitmap_set_bit
argument_list|(
name|df
operator|->
name|all_blocks
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Free all the dataflow info.  */
end_comment

begin_function
specifier|static
name|void
name|df_free
parameter_list|(
name|df
parameter_list|)
name|struct
name|df
modifier|*
name|df
decl_stmt|;
block|{
name|df_bitmaps_free
argument_list|(
name|df
argument_list|,
name|DF_ALL
argument_list|)
expr_stmt|;
if|if
condition|(
name|df
operator|->
name|bbs
condition|)
name|free
argument_list|(
name|df
operator|->
name|bbs
argument_list|)
expr_stmt|;
name|df
operator|->
name|bbs
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|df
operator|->
name|insns
condition|)
name|free
argument_list|(
name|df
operator|->
name|insns
argument_list|)
expr_stmt|;
name|df
operator|->
name|insns
operator|=
literal|0
expr_stmt|;
name|df
operator|->
name|insn_size
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|df
operator|->
name|defs
condition|)
name|free
argument_list|(
name|df
operator|->
name|defs
argument_list|)
expr_stmt|;
name|df
operator|->
name|defs
operator|=
literal|0
expr_stmt|;
name|df
operator|->
name|def_size
operator|=
literal|0
expr_stmt|;
name|df
operator|->
name|def_id
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|df
operator|->
name|uses
condition|)
name|free
argument_list|(
name|df
operator|->
name|uses
argument_list|)
expr_stmt|;
name|df
operator|->
name|uses
operator|=
literal|0
expr_stmt|;
name|df
operator|->
name|use_size
operator|=
literal|0
expr_stmt|;
name|df
operator|->
name|use_id
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|df
operator|->
name|regs
condition|)
name|free
argument_list|(
name|df
operator|->
name|regs
argument_list|)
expr_stmt|;
name|df
operator|->
name|regs
operator|=
literal|0
expr_stmt|;
name|df
operator|->
name|reg_size
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|df
operator|->
name|bbs_modified
condition|)
name|BITMAP_XFREE
argument_list|(
name|df
operator|->
name|bbs_modified
argument_list|)
expr_stmt|;
name|df
operator|->
name|bbs_modified
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|df
operator|->
name|insns_modified
condition|)
name|BITMAP_XFREE
argument_list|(
name|df
operator|->
name|insns_modified
argument_list|)
expr_stmt|;
name|df
operator|->
name|insns_modified
operator|=
literal|0
expr_stmt|;
name|BITMAP_XFREE
argument_list|(
name|df
operator|->
name|all_blocks
argument_list|)
expr_stmt|;
name|df
operator|->
name|all_blocks
operator|=
literal|0
expr_stmt|;
name|obstack_free
argument_list|(
operator|&
name|df_ref_obstack
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Local miscellaneous routines.  */
end_comment

begin_comment
comment|/* Return a USE for register REGNO.  */
end_comment

begin_function
specifier|static
name|rtx
name|df_reg_use_gen
parameter_list|(
name|regno
parameter_list|)
name|unsigned
name|int
name|regno
decl_stmt|;
block|{
name|rtx
name|reg
decl_stmt|;
name|rtx
name|use
decl_stmt|;
name|reg
operator|=
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|?
name|regno_reg_rtx
index|[
name|regno
index|]
else|:
name|gen_rtx_REG
argument_list|(
name|reg_raw_mode
index|[
name|regno
index|]
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|use
operator|=
name|gen_rtx_USE
argument_list|(
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
return|return
name|use
return|;
block|}
end_function

begin_comment
comment|/* Return a CLOBBER for register REGNO.  */
end_comment

begin_function
specifier|static
name|rtx
name|df_reg_clobber_gen
parameter_list|(
name|regno
parameter_list|)
name|unsigned
name|int
name|regno
decl_stmt|;
block|{
name|rtx
name|reg
decl_stmt|;
name|rtx
name|use
decl_stmt|;
name|reg
operator|=
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|?
name|regno_reg_rtx
index|[
name|regno
index|]
else|:
name|gen_rtx_REG
argument_list|(
name|reg_raw_mode
index|[
name|regno
index|]
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|use
operator|=
name|gen_rtx_CLOBBER
argument_list|(
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
return|return
name|use
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Local chain manipulation routines.  */
end_comment

begin_comment
comment|/* Create a link in a def-use or use-def chain.  */
end_comment

begin_function
specifier|static
specifier|inline
name|struct
name|df_link
modifier|*
name|df_link_create
parameter_list|(
name|ref
parameter_list|,
name|next
parameter_list|)
name|struct
name|ref
modifier|*
name|ref
decl_stmt|;
name|struct
name|df_link
modifier|*
name|next
decl_stmt|;
block|{
name|struct
name|df_link
modifier|*
name|link
decl_stmt|;
name|link
operator|=
operator|(
expr|struct
name|df_link
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|df_ref_obstack
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|link
argument_list|)
argument_list|)
expr_stmt|;
name|link
operator|->
name|next
operator|=
name|next
expr_stmt|;
name|link
operator|->
name|ref
operator|=
name|ref
expr_stmt|;
return|return
name|link
return|;
block|}
end_function

begin_comment
comment|/* Add REF to chain head pointed to by PHEAD.  */
end_comment

begin_function
specifier|static
name|struct
name|df_link
modifier|*
name|df_ref_unlink
parameter_list|(
name|phead
parameter_list|,
name|ref
parameter_list|)
name|struct
name|df_link
modifier|*
modifier|*
name|phead
decl_stmt|;
name|struct
name|ref
modifier|*
name|ref
decl_stmt|;
block|{
name|struct
name|df_link
modifier|*
name|link
init|=
operator|*
name|phead
decl_stmt|;
if|if
condition|(
name|link
condition|)
block|{
if|if
condition|(
operator|!
name|link
operator|->
name|next
condition|)
block|{
comment|/* Only a single ref.  It must be the one we want. 	     If not, the def-use and use-def chains are likely to 	     be inconsistent.  */
if|if
condition|(
name|link
operator|->
name|ref
operator|!=
name|ref
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Now have an empty chain.  */
operator|*
name|phead
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
comment|/* Multiple refs.  One of them must be us.  */
if|if
condition|(
name|link
operator|->
name|ref
operator|==
name|ref
condition|)
operator|*
name|phead
operator|=
name|link
operator|->
name|next
expr_stmt|;
else|else
block|{
comment|/* Follow chain.  */
for|for
control|(
init|;
name|link
operator|->
name|next
condition|;
name|link
operator|=
name|link
operator|->
name|next
control|)
block|{
if|if
condition|(
name|link
operator|->
name|next
operator|->
name|ref
operator|==
name|ref
condition|)
block|{
comment|/* Unlink from list.  */
name|link
operator|->
name|next
operator|=
name|link
operator|->
name|next
operator|->
name|next
expr_stmt|;
return|return
name|link
operator|->
name|next
return|;
block|}
block|}
block|}
block|}
block|}
return|return
name|link
return|;
block|}
end_function

begin_comment
comment|/* Unlink REF from all def-use/use-def chains, etc.  */
end_comment

begin_function
name|int
name|df_ref_remove
parameter_list|(
name|df
parameter_list|,
name|ref
parameter_list|)
name|struct
name|df
modifier|*
name|df
decl_stmt|;
name|struct
name|ref
modifier|*
name|ref
decl_stmt|;
block|{
if|if
condition|(
name|DF_REF_REG_DEF_P
argument_list|(
name|ref
argument_list|)
condition|)
block|{
name|df_def_unlink
argument_list|(
name|df
argument_list|,
name|ref
argument_list|)
expr_stmt|;
name|df_ref_unlink
argument_list|(
operator|&
name|df
operator|->
name|insns
index|[
name|DF_REF_INSN_UID
argument_list|(
name|ref
argument_list|)
index|]
operator|.
name|defs
argument_list|,
name|ref
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|df_use_unlink
argument_list|(
name|df
argument_list|,
name|ref
argument_list|)
expr_stmt|;
name|df_ref_unlink
argument_list|(
operator|&
name|df
operator|->
name|insns
index|[
name|DF_REF_INSN_UID
argument_list|(
name|ref
argument_list|)
index|]
operator|.
name|uses
argument_list|,
name|ref
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Unlink DEF from use-def and reg-def chains.  */
end_comment

begin_function
specifier|static
name|void
name|df_def_unlink
parameter_list|(
name|df
parameter_list|,
name|def
parameter_list|)
name|struct
name|df
modifier|*
name|df
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|ref
modifier|*
name|def
decl_stmt|;
block|{
name|struct
name|df_link
modifier|*
name|du_link
decl_stmt|;
name|unsigned
name|int
name|dregno
init|=
name|DF_REF_REGNO
argument_list|(
name|def
argument_list|)
decl_stmt|;
comment|/* Follow def-use chain to find all the uses of this def.  */
for|for
control|(
name|du_link
operator|=
name|DF_REF_CHAIN
argument_list|(
name|def
argument_list|)
init|;
name|du_link
condition|;
name|du_link
operator|=
name|du_link
operator|->
name|next
control|)
block|{
name|struct
name|ref
modifier|*
name|use
init|=
name|du_link
operator|->
name|ref
decl_stmt|;
comment|/* Unlink this def from the use-def chain.  */
name|df_ref_unlink
argument_list|(
operator|&
name|DF_REF_CHAIN
argument_list|(
name|use
argument_list|)
argument_list|,
name|def
argument_list|)
expr_stmt|;
block|}
name|DF_REF_CHAIN
argument_list|(
name|def
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Unlink def from reg-def chain.  */
name|df_ref_unlink
argument_list|(
operator|&
name|df
operator|->
name|regs
index|[
name|dregno
index|]
operator|.
name|defs
argument_list|,
name|def
argument_list|)
expr_stmt|;
name|df
operator|->
name|defs
index|[
name|DF_REF_ID
argument_list|(
name|def
argument_list|)
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Unlink use from def-use and reg-use chains.  */
end_comment

begin_function
specifier|static
name|void
name|df_use_unlink
parameter_list|(
name|df
parameter_list|,
name|use
parameter_list|)
name|struct
name|df
modifier|*
name|df
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|ref
modifier|*
name|use
decl_stmt|;
block|{
name|struct
name|df_link
modifier|*
name|ud_link
decl_stmt|;
name|unsigned
name|int
name|uregno
init|=
name|DF_REF_REGNO
argument_list|(
name|use
argument_list|)
decl_stmt|;
comment|/* Follow use-def chain to find all the defs of this use.  */
for|for
control|(
name|ud_link
operator|=
name|DF_REF_CHAIN
argument_list|(
name|use
argument_list|)
init|;
name|ud_link
condition|;
name|ud_link
operator|=
name|ud_link
operator|->
name|next
control|)
block|{
name|struct
name|ref
modifier|*
name|def
init|=
name|ud_link
operator|->
name|ref
decl_stmt|;
comment|/* Unlink this use from the def-use chain.  */
name|df_ref_unlink
argument_list|(
operator|&
name|DF_REF_CHAIN
argument_list|(
name|def
argument_list|)
argument_list|,
name|use
argument_list|)
expr_stmt|;
block|}
name|DF_REF_CHAIN
argument_list|(
name|use
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Unlink use from reg-use chain.  */
name|df_ref_unlink
argument_list|(
operator|&
name|df
operator|->
name|regs
index|[
name|uregno
index|]
operator|.
name|uses
argument_list|,
name|use
argument_list|)
expr_stmt|;
name|df
operator|->
name|uses
index|[
name|DF_REF_ID
argument_list|(
name|use
argument_list|)
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Local routines for recording refs.  */
end_comment

begin_comment
comment|/* Create a new ref of type DF_REF_TYPE for register REG at address    LOC within INSN of BB.  */
end_comment

begin_function
specifier|static
name|struct
name|ref
modifier|*
name|df_ref_create
parameter_list|(
name|df
parameter_list|,
name|reg
parameter_list|,
name|loc
parameter_list|,
name|insn
parameter_list|,
name|ref_type
parameter_list|,
name|ref_flags
parameter_list|)
name|struct
name|df
modifier|*
name|df
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
name|rtx
modifier|*
name|loc
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|enum
name|df_ref_type
name|ref_type
decl_stmt|;
name|enum
name|df_ref_flags
name|ref_flags
decl_stmt|;
block|{
name|struct
name|ref
modifier|*
name|this_ref
decl_stmt|;
name|unsigned
name|int
name|uid
decl_stmt|;
name|this_ref
operator|=
operator|(
expr|struct
name|ref
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|df_ref_obstack
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|this_ref
argument_list|)
argument_list|)
expr_stmt|;
name|DF_REF_REG
argument_list|(
name|this_ref
argument_list|)
operator|=
name|reg
expr_stmt|;
name|DF_REF_LOC
argument_list|(
name|this_ref
argument_list|)
operator|=
name|loc
expr_stmt|;
name|DF_REF_INSN
argument_list|(
name|this_ref
argument_list|)
operator|=
name|insn
expr_stmt|;
name|DF_REF_CHAIN
argument_list|(
name|this_ref
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DF_REF_TYPE
argument_list|(
name|this_ref
argument_list|)
operator|=
name|ref_type
expr_stmt|;
name|DF_REF_FLAGS
argument_list|(
name|this_ref
argument_list|)
operator|=
name|ref_flags
expr_stmt|;
name|uid
operator|=
name|INSN_UID
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|ref_type
operator|==
name|DF_REF_REG_DEF
condition|)
block|{
if|if
condition|(
name|df
operator|->
name|def_id
operator|>=
name|df
operator|->
name|def_size
condition|)
block|{
comment|/* Make table 25 percent larger.  */
name|df
operator|->
name|def_size
operator|+=
operator|(
name|df
operator|->
name|def_size
operator|/
literal|4
operator|)
expr_stmt|;
name|df
operator|->
name|defs
operator|=
name|xrealloc
argument_list|(
name|df
operator|->
name|defs
argument_list|,
name|df
operator|->
name|def_size
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|df
operator|->
name|defs
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|DF_REF_ID
argument_list|(
name|this_ref
argument_list|)
operator|=
name|df
operator|->
name|def_id
expr_stmt|;
name|df
operator|->
name|defs
index|[
name|df
operator|->
name|def_id
operator|++
index|]
operator|=
name|this_ref
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|df
operator|->
name|use_id
operator|>=
name|df
operator|->
name|use_size
condition|)
block|{
comment|/* Make table 25 percent larger.  */
name|df
operator|->
name|use_size
operator|+=
operator|(
name|df
operator|->
name|use_size
operator|/
literal|4
operator|)
expr_stmt|;
name|df
operator|->
name|uses
operator|=
name|xrealloc
argument_list|(
name|df
operator|->
name|uses
argument_list|,
name|df
operator|->
name|use_size
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|df
operator|->
name|uses
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|DF_REF_ID
argument_list|(
name|this_ref
argument_list|)
operator|=
name|df
operator|->
name|use_id
expr_stmt|;
name|df
operator|->
name|uses
index|[
name|df
operator|->
name|use_id
operator|++
index|]
operator|=
name|this_ref
expr_stmt|;
block|}
return|return
name|this_ref
return|;
block|}
end_function

begin_comment
comment|/* Create a new reference of type DF_REF_TYPE for a single register REG,    used inside the LOC rtx of INSN.  */
end_comment

begin_function
specifier|static
name|void
name|df_ref_record_1
parameter_list|(
name|df
parameter_list|,
name|reg
parameter_list|,
name|loc
parameter_list|,
name|insn
parameter_list|,
name|ref_type
parameter_list|,
name|ref_flags
parameter_list|)
name|struct
name|df
modifier|*
name|df
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
name|rtx
modifier|*
name|loc
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|enum
name|df_ref_type
name|ref_type
decl_stmt|;
name|enum
name|df_ref_flags
name|ref_flags
decl_stmt|;
block|{
name|df_ref_create
argument_list|(
name|df
argument_list|,
name|reg
argument_list|,
name|loc
argument_list|,
name|insn
argument_list|,
name|ref_type
argument_list|,
name|ref_flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create new references of type DF_REF_TYPE for each part of register REG    at address LOC within INSN of BB.  */
end_comment

begin_function
specifier|static
name|void
name|df_ref_record
parameter_list|(
name|df
parameter_list|,
name|reg
parameter_list|,
name|loc
parameter_list|,
name|insn
parameter_list|,
name|ref_type
parameter_list|,
name|ref_flags
parameter_list|)
name|struct
name|df
modifier|*
name|df
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
name|rtx
modifier|*
name|loc
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|enum
name|df_ref_type
name|ref_type
decl_stmt|;
name|enum
name|df_ref_flags
name|ref_flags
decl_stmt|;
block|{
name|unsigned
name|int
name|regno
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|!=
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|!=
name|SUBREG
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* For the reg allocator we are interested in some SUBREG rtx's, but not      all.  Notably only those representing a word extraction from a multi-word      reg.  As written in the docu those should have the form      (subreg:SI (reg:M A) N), with size(SImode)> size(Mmode).      XXX Is that true?  We could also use the global word_mode variable.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SUBREG
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
operator|<
name|GET_MODE_SIZE
argument_list|(
name|word_mode
argument_list|)
operator|||
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
operator|>=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|reg
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|loc
operator|=
operator|&
name|SUBREG_REG
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|reg
operator|=
operator|*
name|loc
expr_stmt|;
block|}
name|regno
operator|=
name|REGNO
argument_list|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SUBREG
condition|?
name|SUBREG_REG
argument_list|(
name|reg
argument_list|)
else|:
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|endregno
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|df
operator|->
name|flags
operator|&
name|DF_HARD_REGS
operator|)
condition|)
return|return;
comment|/* GET_MODE (reg) is correct here.  We don't want to go into a SUBREG          for the mode, because we only want to add references to regs, which 	 are really referenced.  E.g. a (subreg:SI (reg:DI 0) 0) does _not_ 	 reference the whole reg 0 in DI mode (which would also include 	 reg 1, at least, if 0 and 1 are SImode registers).  */
name|endregno
operator|=
name|regno
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|regno
init|;
name|i
operator|<
name|endregno
condition|;
name|i
operator|++
control|)
name|df_ref_record_1
argument_list|(
name|df
argument_list|,
name|gen_rtx_REG
argument_list|(
name|reg_raw_mode
index|[
name|i
index|]
argument_list|,
name|i
argument_list|)
argument_list|,
name|loc
argument_list|,
name|insn
argument_list|,
name|ref_type
argument_list|,
name|ref_flags
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|df_ref_record_1
argument_list|(
name|df
argument_list|,
name|reg
argument_list|,
name|loc
argument_list|,
name|insn
argument_list|,
name|ref_type
argument_list|,
name|ref_flags
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Writes to SUBREG of inndermode wider than word and outermode shorter than    word are read-modify-write.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|read_modify_subreg_p
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|SUBREG
condition|)
return|return
name|false
return|;
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|<=
name|UNITS_PER_WORD
condition|)
return|return
name|false
return|;
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|>
name|UNITS_PER_WORD
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Process all the registers defined in the rtx, X.  */
end_comment

begin_function
specifier|static
name|void
name|df_def_record_1
parameter_list|(
name|df
parameter_list|,
name|x
parameter_list|,
name|bb
parameter_list|,
name|insn
parameter_list|)
name|struct
name|df
modifier|*
name|df
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
name|rtx
modifier|*
name|loc
init|=
operator|&
name|SET_DEST
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|rtx
name|dst
init|=
operator|*
name|loc
decl_stmt|;
name|enum
name|df_ref_flags
name|flags
init|=
literal|0
decl_stmt|;
comment|/* Some targets place small structures in registers for      return values of functions.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|dst
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|GET_MODE
argument_list|(
name|dst
argument_list|)
operator|==
name|BLKmode
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|dst
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|df_def_record_1
argument_list|(
name|df
argument_list|,
name|XVECEXP
argument_list|(
name|dst
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|bb
argument_list|,
name|insn
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* May be, we should flag the use of strict_low_part somehow.  Might be      handy for the reg allocator.  */
while|while
condition|(
name|GET_CODE
argument_list|(
name|dst
argument_list|)
operator|==
name|STRICT_LOW_PART
operator|||
name|GET_CODE
argument_list|(
name|dst
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|dst
argument_list|)
operator|==
name|SIGN_EXTRACT
operator|||
name|read_modify_subreg_p
argument_list|(
name|dst
argument_list|)
condition|)
block|{
comment|/* Strict low part always contains SUBREG, but we don't want to make 	 it appear outside, as whole register is always considered.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|dst
argument_list|)
operator|==
name|STRICT_LOW_PART
condition|)
block|{
name|loc
operator|=
operator|&
name|XEXP
argument_list|(
name|dst
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dst
operator|=
operator|*
name|loc
expr_stmt|;
block|}
name|loc
operator|=
operator|&
name|XEXP
argument_list|(
name|dst
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dst
operator|=
operator|*
name|loc
expr_stmt|;
name|flags
operator||=
name|DF_REF_READ_WRITE
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|dst
argument_list|)
operator|==
name|REG
operator|||
operator|(
name|GET_CODE
argument_list|(
name|dst
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|dst
argument_list|)
argument_list|)
operator|==
name|REG
operator|)
condition|)
name|df_ref_record
argument_list|(
name|df
argument_list|,
name|dst
argument_list|,
name|loc
argument_list|,
name|insn
argument_list|,
name|DF_REF_REG_DEF
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Process all the registers defined in the pattern rtx, X.  */
end_comment

begin_function
specifier|static
name|void
name|df_defs_record
parameter_list|(
name|df
parameter_list|,
name|x
parameter_list|,
name|bb
parameter_list|,
name|insn
parameter_list|)
name|struct
name|df
modifier|*
name|df
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
name|RTX_CODE
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|SET
operator|||
name|code
operator|==
name|CLOBBER
condition|)
block|{
comment|/* Mark the single def within the pattern.  */
name|df_def_record_1
argument_list|(
name|df
argument_list|,
name|x
argument_list|,
name|bb
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|PARALLEL
condition|)
block|{
name|int
name|i
decl_stmt|;
comment|/* Mark the multiple defs within the pattern.  */
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|code
operator|=
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|SET
operator|||
name|code
operator|==
name|CLOBBER
condition|)
name|df_def_record_1
argument_list|(
name|df
argument_list|,
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|bb
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Process all the registers used in the rtx at address LOC.  */
end_comment

begin_function
specifier|static
name|void
name|df_uses_record
parameter_list|(
name|df
parameter_list|,
name|loc
parameter_list|,
name|ref_type
parameter_list|,
name|bb
parameter_list|,
name|insn
parameter_list|,
name|flags
parameter_list|)
name|struct
name|df
modifier|*
name|df
decl_stmt|;
name|rtx
modifier|*
name|loc
decl_stmt|;
name|enum
name|df_ref_type
name|ref_type
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|enum
name|df_ref_flags
name|flags
decl_stmt|;
block|{
name|RTX_CODE
name|code
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|retry
label|:
name|x
operator|=
operator|*
name|loc
expr_stmt|;
if|if
condition|(
operator|!
name|x
condition|)
return|return;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|LABEL_REF
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|PC
case|:
case|case
name|ADDR_VEC
case|:
case|case
name|ADDR_DIFF_VEC
case|:
return|return;
case|case
name|CLOBBER
case|:
comment|/* If we are clobbering a MEM, mark any registers inside the address 	 as being used.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
name|df_uses_record
argument_list|(
name|df
argument_list|,
operator|&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|DF_REF_REG_MEM_STORE
argument_list|,
name|bb
argument_list|,
name|insn
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* If we're clobbering a REG then we have a def so ignore.  */
return|return;
case|case
name|MEM
case|:
name|df_uses_record
argument_list|(
name|df
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|DF_REF_REG_MEM_LOAD
argument_list|,
name|bb
argument_list|,
name|insn
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return;
case|case
name|SUBREG
case|:
comment|/* While we're here, optimize this case.  */
comment|/* In case the SUBREG is not of a register, don't optimize.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|REG
condition|)
block|{
name|loc
operator|=
operator|&
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|df_uses_record
argument_list|(
name|df
argument_list|,
name|loc
argument_list|,
name|ref_type
argument_list|,
name|bb
argument_list|,
name|insn
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* ... Fall through ...  */
case|case
name|REG
case|:
comment|/* See a register (or subreg) other than being set.  */
name|df_ref_record
argument_list|(
name|df
argument_list|,
name|x
argument_list|,
name|loc
argument_list|,
name|insn
argument_list|,
name|ref_type
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return;
case|case
name|SET
case|:
block|{
name|rtx
name|dst
init|=
name|SET_DEST
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|df_uses_record
argument_list|(
name|df
argument_list|,
operator|&
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|DF_REF_REG_USE
argument_list|,
name|bb
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|dst
argument_list|)
condition|)
block|{
case|case
name|SUBREG
case|:
if|if
condition|(
name|read_modify_subreg_p
argument_list|(
name|dst
argument_list|)
condition|)
block|{
name|df_uses_record
argument_list|(
name|df
argument_list|,
operator|&
name|SUBREG_REG
argument_list|(
name|dst
argument_list|)
argument_list|,
name|DF_REF_REG_USE
argument_list|,
name|bb
argument_list|,
name|insn
argument_list|,
name|DF_REF_READ_WRITE
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* ... FALLTHRU ...  */
case|case
name|REG
case|:
case|case
name|PC
case|:
break|break;
case|case
name|MEM
case|:
name|df_uses_record
argument_list|(
name|df
argument_list|,
operator|&
name|XEXP
argument_list|(
name|dst
argument_list|,
literal|0
argument_list|)
argument_list|,
name|DF_REF_REG_MEM_STORE
argument_list|,
name|bb
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|STRICT_LOW_PART
case|:
comment|/* A strict_low_part uses the whole reg not only the subreg.  */
name|dst
operator|=
name|XEXP
argument_list|(
name|dst
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dst
argument_list|)
operator|!=
name|SUBREG
condition|)
name|abort
argument_list|()
expr_stmt|;
name|df_uses_record
argument_list|(
name|df
argument_list|,
operator|&
name|SUBREG_REG
argument_list|(
name|dst
argument_list|)
argument_list|,
name|DF_REF_REG_USE
argument_list|,
name|bb
argument_list|,
name|insn
argument_list|,
name|DF_REF_READ_WRITE
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZERO_EXTRACT
case|:
case|case
name|SIGN_EXTRACT
case|:
name|df_uses_record
argument_list|(
name|df
argument_list|,
operator|&
name|XEXP
argument_list|(
name|dst
argument_list|,
literal|0
argument_list|)
argument_list|,
name|DF_REF_REG_USE
argument_list|,
name|bb
argument_list|,
name|insn
argument_list|,
name|DF_REF_READ_WRITE
argument_list|)
expr_stmt|;
name|df_uses_record
argument_list|(
name|df
argument_list|,
operator|&
name|XEXP
argument_list|(
name|dst
argument_list|,
literal|1
argument_list|)
argument_list|,
name|DF_REF_REG_USE
argument_list|,
name|bb
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|df_uses_record
argument_list|(
name|df
argument_list|,
operator|&
name|XEXP
argument_list|(
name|dst
argument_list|,
literal|2
argument_list|)
argument_list|,
name|DF_REF_REG_USE
argument_list|,
name|bb
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dst
operator|=
name|XEXP
argument_list|(
name|dst
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
return|return;
block|}
case|case
name|RETURN
case|:
break|break;
case|case
name|ASM_OPERANDS
case|:
case|case
name|UNSPEC_VOLATILE
case|:
case|case
name|TRAP_IF
case|:
case|case
name|ASM_INPUT
case|:
block|{
comment|/* Traditional and volatile asm instructions must be considered to use 	   and clobber all hard registers, all pseudo-registers and all of 	   memory.  So must TRAP_IF and UNSPEC_VOLATILE operations.  	   Consider for instance a volatile asm that changes the fpu rounding 	   mode.  An insn should not be moved across this even if it only uses 	   pseudo-regs because it might give an incorrectly rounded result.  	   For now, just mark any regs we can find in ASM_OPERANDS as 	   used.  */
comment|/* For all ASM_OPERANDS, we must traverse the vector of input operands. 	   We can not just fall through here since then we would be confused 	   by the ASM_INPUT rtx inside ASM_OPERANDS, which do not indicate 	   traditional asms unlike their normal usage.  */
if|if
condition|(
name|code
operator|==
name|ASM_OPERANDS
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ASM_OPERANDS_INPUT_LENGTH
argument_list|(
name|x
argument_list|)
condition|;
name|j
operator|++
control|)
name|df_uses_record
argument_list|(
name|df
argument_list|,
operator|&
name|ASM_OPERANDS_INPUT
argument_list|(
name|x
argument_list|,
name|j
argument_list|)
argument_list|,
name|DF_REF_REG_USE
argument_list|,
name|bb
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
block|}
case|case
name|PRE_DEC
case|:
case|case
name|POST_DEC
case|:
case|case
name|PRE_INC
case|:
case|case
name|POST_INC
case|:
case|case
name|PRE_MODIFY
case|:
case|case
name|POST_MODIFY
case|:
comment|/* Catch the def of the register being modified.  */
name|df_ref_record
argument_list|(
name|df
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn
argument_list|,
name|DF_REF_REG_DEF
argument_list|,
name|DF_REF_READ_WRITE
argument_list|)
expr_stmt|;
comment|/* ... Fall through to handle uses ...  */
default|default:
break|break;
block|}
comment|/* Recursively scan the operands of this expression.  */
block|{
specifier|const
name|char
modifier|*
name|fmt
init|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
comment|/* Tail recursive case: save a function call level.  */
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|loc
operator|=
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
name|df_uses_record
argument_list|(
name|df
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|ref_type
argument_list|,
name|bb
argument_list|,
name|insn
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|df_uses_record
argument_list|(
name|df
argument_list|,
operator|&
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|ref_type
argument_list|,
name|bb
argument_list|,
name|insn
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Record all the df within INSN of basic block BB.  */
end_comment

begin_function
specifier|static
name|void
name|df_insn_refs_record
parameter_list|(
name|df
parameter_list|,
name|bb
parameter_list|,
name|insn
parameter_list|)
name|struct
name|df
modifier|*
name|df
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|rtx
name|note
decl_stmt|;
comment|/* Record register defs */
name|df_defs_record
argument_list|(
name|df
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|bb
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|df
operator|->
name|flags
operator|&
name|DF_EQUIV_NOTES
condition|)
for|for
control|(
name|note
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|note
condition|;
name|note
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
control|)
block|{
switch|switch
condition|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
condition|)
block|{
case|case
name|REG_EQUIV
case|:
case|case
name|REG_EQUAL
case|:
name|df_uses_record
argument_list|(
name|df
argument_list|,
operator|&
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|DF_REF_REG_USE
argument_list|,
name|bb
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
default|default:
break|break;
block|}
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
name|rtx
name|note
decl_stmt|;
name|rtx
name|x
decl_stmt|;
comment|/* Record the registers used to pass arguments.  */
for|for
control|(
name|note
operator|=
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|insn
argument_list|)
init|;
name|note
condition|;
name|note
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|USE
condition|)
name|df_uses_record
argument_list|(
name|df
argument_list|,
operator|&
name|SET_DEST
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|DF_REF_REG_USE
argument_list|,
name|bb
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* The stack ptr is used (honorarily) by a CALL insn.  */
name|x
operator|=
name|df_reg_use_gen
argument_list|(
name|STACK_POINTER_REGNUM
argument_list|)
expr_stmt|;
name|df_uses_record
argument_list|(
name|df
argument_list|,
operator|&
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
name|DF_REF_REG_USE
argument_list|,
name|bb
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|df
operator|->
name|flags
operator|&
name|DF_HARD_REGS
condition|)
block|{
comment|/* Calls may also reference any of the global registers, 		 so they are recorded as used.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|global_regs
index|[
name|i
index|]
condition|)
block|{
name|x
operator|=
name|df_reg_use_gen
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|df_uses_record
argument_list|(
name|df
argument_list|,
operator|&
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
name|DF_REF_REG_USE
argument_list|,
name|bb
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Record the register uses.  */
name|df_uses_record
argument_list|(
name|df
argument_list|,
operator|&
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|DF_REF_REG_USE
argument_list|,
name|bb
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
name|rtx
name|note
decl_stmt|;
if|if
condition|(
name|df
operator|->
name|flags
operator|&
name|DF_HARD_REGS
condition|)
block|{
comment|/* Kill all registers invalidated by a call.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|regs_invalidated_by_call
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|rtx
name|reg_clob
init|=
name|df_reg_clobber_gen
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|df_defs_record
argument_list|(
name|df
argument_list|,
name|reg_clob
argument_list|,
name|bb
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* There may be extra registers to be clobbered.  */
for|for
control|(
name|note
operator|=
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|insn
argument_list|)
init|;
name|note
condition|;
name|note
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CLOBBER
condition|)
name|df_defs_record
argument_list|(
name|df
argument_list|,
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|bb
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Record all the refs within the basic block BB.  */
end_comment

begin_function
specifier|static
name|void
name|df_bb_refs_record
parameter_list|(
name|df
parameter_list|,
name|bb
parameter_list|)
name|struct
name|df
modifier|*
name|df
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|;
comment|/* Scan the block an insn at a time from beginning to end.  */
for|for
control|(
name|insn
operator|=
name|bb
operator|->
name|head
init|;
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
comment|/* Record defs within INSN.  */
name|df_insn_refs_record
argument_list|(
name|df
argument_list|,
name|bb
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|insn
operator|==
name|bb
operator|->
name|end
condition|)
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Record all the refs in the basic blocks specified by BLOCKS.  */
end_comment

begin_function
specifier|static
name|void
name|df_refs_record
parameter_list|(
name|df
parameter_list|,
name|blocks
parameter_list|)
name|struct
name|df
modifier|*
name|df
decl_stmt|;
name|bitmap
name|blocks
decl_stmt|;
block|{
name|basic_block
name|bb
decl_stmt|;
name|FOR_EACH_BB_IN_BITMAP
argument_list|(
argument|blocks
argument_list|,
literal|0
argument_list|,
argument|bb
argument_list|,
argument|{       df_bb_refs_record (df, bb);     }
argument_list|)
empty_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Dataflow analysis routines.  */
end_comment

begin_comment
comment|/* Create reg-def chains for basic block BB.  These are a list of    definitions for each register.  */
end_comment

begin_function
specifier|static
name|void
name|df_bb_reg_def_chain_create
parameter_list|(
name|df
parameter_list|,
name|bb
parameter_list|)
name|struct
name|df
modifier|*
name|df
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|;
comment|/* Perhaps the defs should be sorted using a depth first search      of the CFG (or possibly a breadth first search).  We currently      scan the basic blocks in reverse order so that the first defs      appear at the start of the chain.  */
for|for
control|(
name|insn
operator|=
name|bb
operator|->
name|end
init|;
name|insn
operator|&&
name|insn
operator|!=
name|PREV_INSN
argument_list|(
name|bb
operator|->
name|head
argument_list|)
condition|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|struct
name|df_link
modifier|*
name|link
decl_stmt|;
name|unsigned
name|int
name|uid
init|=
name|INSN_UID
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
continue|continue;
for|for
control|(
name|link
operator|=
name|df
operator|->
name|insns
index|[
name|uid
index|]
operator|.
name|defs
init|;
name|link
condition|;
name|link
operator|=
name|link
operator|->
name|next
control|)
block|{
name|struct
name|ref
modifier|*
name|def
init|=
name|link
operator|->
name|ref
decl_stmt|;
name|unsigned
name|int
name|dregno
init|=
name|DF_REF_REGNO
argument_list|(
name|def
argument_list|)
decl_stmt|;
name|df
operator|->
name|regs
index|[
name|dregno
index|]
operator|.
name|defs
operator|=
name|df_link_create
argument_list|(
name|def
argument_list|,
name|df
operator|->
name|regs
index|[
name|dregno
index|]
operator|.
name|defs
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Create reg-def chains for each basic block within BLOCKS.  These    are a list of definitions for each register.  */
end_comment

begin_function
specifier|static
name|void
name|df_reg_def_chain_create
parameter_list|(
name|df
parameter_list|,
name|blocks
parameter_list|)
name|struct
name|df
modifier|*
name|df
decl_stmt|;
name|bitmap
name|blocks
decl_stmt|;
block|{
name|basic_block
name|bb
decl_stmt|;
name|FOR_EACH_BB_IN_BITMAP
comment|/*_REV*/
argument_list|(
argument|blocks
argument_list|,
literal|0
argument_list|,
argument|bb
argument_list|,
argument|{       df_bb_reg_def_chain_create (df, bb);     }
argument_list|)
empty_stmt|;
block|}
end_function

begin_comment
comment|/* Create reg-use chains for basic block BB.  These are a list of uses    for each register.  */
end_comment

begin_function
specifier|static
name|void
name|df_bb_reg_use_chain_create
parameter_list|(
name|df
parameter_list|,
name|bb
parameter_list|)
name|struct
name|df
modifier|*
name|df
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|;
comment|/* Scan in forward order so that the last uses appear at the 	 start of the chain.  */
for|for
control|(
name|insn
operator|=
name|bb
operator|->
name|head
init|;
name|insn
operator|&&
name|insn
operator|!=
name|NEXT_INSN
argument_list|(
name|bb
operator|->
name|end
argument_list|)
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|struct
name|df_link
modifier|*
name|link
decl_stmt|;
name|unsigned
name|int
name|uid
init|=
name|INSN_UID
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
continue|continue;
for|for
control|(
name|link
operator|=
name|df
operator|->
name|insns
index|[
name|uid
index|]
operator|.
name|uses
init|;
name|link
condition|;
name|link
operator|=
name|link
operator|->
name|next
control|)
block|{
name|struct
name|ref
modifier|*
name|use
init|=
name|link
operator|->
name|ref
decl_stmt|;
name|unsigned
name|int
name|uregno
init|=
name|DF_REF_REGNO
argument_list|(
name|use
argument_list|)
decl_stmt|;
name|df
operator|->
name|regs
index|[
name|uregno
index|]
operator|.
name|uses
operator|=
name|df_link_create
argument_list|(
name|use
argument_list|,
name|df
operator|->
name|regs
index|[
name|uregno
index|]
operator|.
name|uses
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Create reg-use chains for each basic block within BLOCKS.  These    are a list of uses for each register.  */
end_comment

begin_function
specifier|static
name|void
name|df_reg_use_chain_create
parameter_list|(
name|df
parameter_list|,
name|blocks
parameter_list|)
name|struct
name|df
modifier|*
name|df
decl_stmt|;
name|bitmap
name|blocks
decl_stmt|;
block|{
name|basic_block
name|bb
decl_stmt|;
name|FOR_EACH_BB_IN_BITMAP
argument_list|(
argument|blocks
argument_list|,
literal|0
argument_list|,
argument|bb
argument_list|,
argument|{       df_bb_reg_use_chain_create (df, bb);     }
argument_list|)
empty_stmt|;
block|}
end_function

begin_comment
comment|/* Create def-use chains from reaching use bitmaps for basic block BB.  */
end_comment

begin_function
specifier|static
name|void
name|df_bb_du_chain_create
parameter_list|(
name|df
parameter_list|,
name|bb
parameter_list|,
name|ru
parameter_list|)
name|struct
name|df
modifier|*
name|df
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|bitmap
name|ru
decl_stmt|;
block|{
name|struct
name|bb_info
modifier|*
name|bb_info
init|=
name|DF_BB_INFO
argument_list|(
name|df
argument_list|,
name|bb
argument_list|)
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|bitmap_copy
argument_list|(
name|ru
argument_list|,
name|bb_info
operator|->
name|ru_out
argument_list|)
expr_stmt|;
comment|/* For each def in BB create a linked list (chain) of uses      reached from the def.  */
for|for
control|(
name|insn
operator|=
name|bb
operator|->
name|end
init|;
name|insn
operator|&&
name|insn
operator|!=
name|PREV_INSN
argument_list|(
name|bb
operator|->
name|head
argument_list|)
condition|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|struct
name|df_link
modifier|*
name|def_link
decl_stmt|;
name|struct
name|df_link
modifier|*
name|use_link
decl_stmt|;
name|unsigned
name|int
name|uid
init|=
name|INSN_UID
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
continue|continue;
comment|/* For each def in insn...  */
for|for
control|(
name|def_link
operator|=
name|df
operator|->
name|insns
index|[
name|uid
index|]
operator|.
name|defs
init|;
name|def_link
condition|;
name|def_link
operator|=
name|def_link
operator|->
name|next
control|)
block|{
name|struct
name|ref
modifier|*
name|def
init|=
name|def_link
operator|->
name|ref
decl_stmt|;
name|unsigned
name|int
name|dregno
init|=
name|DF_REF_REGNO
argument_list|(
name|def
argument_list|)
decl_stmt|;
name|DF_REF_CHAIN
argument_list|(
name|def
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* While the reg-use chains are not essential, it 	     is _much_ faster to search these short lists rather 	     than all the reaching uses, especially for large functions.  */
for|for
control|(
name|use_link
operator|=
name|df
operator|->
name|regs
index|[
name|dregno
index|]
operator|.
name|uses
init|;
name|use_link
condition|;
name|use_link
operator|=
name|use_link
operator|->
name|next
control|)
block|{
name|struct
name|ref
modifier|*
name|use
init|=
name|use_link
operator|->
name|ref
decl_stmt|;
if|if
condition|(
name|bitmap_bit_p
argument_list|(
name|ru
argument_list|,
name|DF_REF_ID
argument_list|(
name|use
argument_list|)
argument_list|)
condition|)
block|{
name|DF_REF_CHAIN
argument_list|(
name|def
argument_list|)
operator|=
name|df_link_create
argument_list|(
name|use
argument_list|,
name|DF_REF_CHAIN
argument_list|(
name|def
argument_list|)
argument_list|)
expr_stmt|;
name|bitmap_clear_bit
argument_list|(
name|ru
argument_list|,
name|DF_REF_ID
argument_list|(
name|use
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* For each use in insn...  */
for|for
control|(
name|use_link
operator|=
name|df
operator|->
name|insns
index|[
name|uid
index|]
operator|.
name|uses
init|;
name|use_link
condition|;
name|use_link
operator|=
name|use_link
operator|->
name|next
control|)
block|{
name|struct
name|ref
modifier|*
name|use
init|=
name|use_link
operator|->
name|ref
decl_stmt|;
name|bitmap_set_bit
argument_list|(
name|ru
argument_list|,
name|DF_REF_ID
argument_list|(
name|use
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Create def-use chains from reaching use bitmaps for basic blocks    in BLOCKS.  */
end_comment

begin_function
specifier|static
name|void
name|df_du_chain_create
parameter_list|(
name|df
parameter_list|,
name|blocks
parameter_list|)
name|struct
name|df
modifier|*
name|df
decl_stmt|;
name|bitmap
name|blocks
decl_stmt|;
block|{
name|bitmap
name|ru
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|ru
operator|=
name|BITMAP_XMALLOC
argument_list|()
expr_stmt|;
name|FOR_EACH_BB_IN_BITMAP
argument_list|(
argument|blocks
argument_list|,
literal|0
argument_list|,
argument|bb
argument_list|,
argument|{       df_bb_du_chain_create (df, bb, ru);     }
argument_list|)
empty_stmt|;
name|BITMAP_XFREE
argument_list|(
name|ru
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create use-def chains from reaching def bitmaps for basic block BB.  */
end_comment

begin_function
specifier|static
name|void
name|df_bb_ud_chain_create
parameter_list|(
name|df
parameter_list|,
name|bb
parameter_list|)
name|struct
name|df
modifier|*
name|df
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
block|{
name|struct
name|bb_info
modifier|*
name|bb_info
init|=
name|DF_BB_INFO
argument_list|(
name|df
argument_list|,
name|bb
argument_list|)
decl_stmt|;
name|struct
name|ref
modifier|*
modifier|*
name|reg_def_last
init|=
name|df
operator|->
name|reg_def_last
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|memset
argument_list|(
name|reg_def_last
argument_list|,
literal|0
argument_list|,
name|df
operator|->
name|n_regs
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ref
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* For each use in BB create a linked list (chain) of defs      that reach the use.  */
for|for
control|(
name|insn
operator|=
name|bb
operator|->
name|head
init|;
name|insn
operator|&&
name|insn
operator|!=
name|NEXT_INSN
argument_list|(
name|bb
operator|->
name|end
argument_list|)
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|unsigned
name|int
name|uid
init|=
name|INSN_UID
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|struct
name|df_link
modifier|*
name|use_link
decl_stmt|;
name|struct
name|df_link
modifier|*
name|def_link
decl_stmt|;
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
continue|continue;
comment|/* For each use in insn...  */
for|for
control|(
name|use_link
operator|=
name|df
operator|->
name|insns
index|[
name|uid
index|]
operator|.
name|uses
init|;
name|use_link
condition|;
name|use_link
operator|=
name|use_link
operator|->
name|next
control|)
block|{
name|struct
name|ref
modifier|*
name|use
init|=
name|use_link
operator|->
name|ref
decl_stmt|;
name|unsigned
name|int
name|regno
init|=
name|DF_REF_REGNO
argument_list|(
name|use
argument_list|)
decl_stmt|;
name|DF_REF_CHAIN
argument_list|(
name|use
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Has regno been defined in this BB yet?  If so, use 	     the last def as the single entry for the use-def 	     chain for this use.  Otherwise, we need to add all 	     the defs using this regno that reach the start of 	     this BB.  */
if|if
condition|(
name|reg_def_last
index|[
name|regno
index|]
condition|)
block|{
name|DF_REF_CHAIN
argument_list|(
name|use
argument_list|)
operator|=
name|df_link_create
argument_list|(
name|reg_def_last
index|[
name|regno
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* While the reg-def chains are not essential, it is 		 _much_ faster to search these short lists rather than 		 all the reaching defs, especially for large 		 functions.  */
for|for
control|(
name|def_link
operator|=
name|df
operator|->
name|regs
index|[
name|regno
index|]
operator|.
name|defs
init|;
name|def_link
condition|;
name|def_link
operator|=
name|def_link
operator|->
name|next
control|)
block|{
name|struct
name|ref
modifier|*
name|def
init|=
name|def_link
operator|->
name|ref
decl_stmt|;
if|if
condition|(
name|bitmap_bit_p
argument_list|(
name|bb_info
operator|->
name|rd_in
argument_list|,
name|DF_REF_ID
argument_list|(
name|def
argument_list|)
argument_list|)
condition|)
block|{
name|DF_REF_CHAIN
argument_list|(
name|use
argument_list|)
operator|=
name|df_link_create
argument_list|(
name|def
argument_list|,
name|DF_REF_CHAIN
argument_list|(
name|use
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* For each def in insn...record the last def of each reg.  */
for|for
control|(
name|def_link
operator|=
name|df
operator|->
name|insns
index|[
name|uid
index|]
operator|.
name|defs
init|;
name|def_link
condition|;
name|def_link
operator|=
name|def_link
operator|->
name|next
control|)
block|{
name|struct
name|ref
modifier|*
name|def
init|=
name|def_link
operator|->
name|ref
decl_stmt|;
name|int
name|dregno
init|=
name|DF_REF_REGNO
argument_list|(
name|def
argument_list|)
decl_stmt|;
name|reg_def_last
index|[
name|dregno
index|]
operator|=
name|def
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Create use-def chains from reaching def bitmaps for basic blocks    within BLOCKS.  */
end_comment

begin_function
specifier|static
name|void
name|df_ud_chain_create
parameter_list|(
name|df
parameter_list|,
name|blocks
parameter_list|)
name|struct
name|df
modifier|*
name|df
decl_stmt|;
name|bitmap
name|blocks
decl_stmt|;
block|{
name|basic_block
name|bb
decl_stmt|;
name|FOR_EACH_BB_IN_BITMAP
argument_list|(
argument|blocks
argument_list|,
literal|0
argument_list|,
argument|bb
argument_list|,
argument|{       df_bb_ud_chain_create (df, bb);     }
argument_list|)
empty_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|df_rd_transfer_function
parameter_list|(
name|bb
parameter_list|,
name|changed
parameter_list|,
name|in
parameter_list|,
name|out
parameter_list|,
name|gen
parameter_list|,
name|kill
parameter_list|,
name|data
parameter_list|)
name|int
name|bb
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
modifier|*
name|changed
decl_stmt|;
name|bitmap
name|in
decl_stmt|,
name|out
decl_stmt|,
name|gen
decl_stmt|,
name|kill
decl_stmt|;
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
operator|*
name|changed
operator|=
name|bitmap_union_of_diff
argument_list|(
name|out
argument_list|,
name|gen
argument_list|,
name|in
argument_list|,
name|kill
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|df_ru_transfer_function
parameter_list|(
name|bb
parameter_list|,
name|changed
parameter_list|,
name|in
parameter_list|,
name|out
parameter_list|,
name|gen
parameter_list|,
name|kill
parameter_list|,
name|data
parameter_list|)
name|int
name|bb
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
modifier|*
name|changed
decl_stmt|;
name|bitmap
name|in
decl_stmt|,
name|out
decl_stmt|,
name|gen
decl_stmt|,
name|kill
decl_stmt|;
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
operator|*
name|changed
operator|=
name|bitmap_union_of_diff
argument_list|(
name|in
argument_list|,
name|gen
argument_list|,
name|out
argument_list|,
name|kill
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|df_lr_transfer_function
parameter_list|(
name|bb
parameter_list|,
name|changed
parameter_list|,
name|in
parameter_list|,
name|out
parameter_list|,
name|use
parameter_list|,
name|def
parameter_list|,
name|data
parameter_list|)
name|int
name|bb
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
modifier|*
name|changed
decl_stmt|;
name|bitmap
name|in
decl_stmt|,
name|out
decl_stmt|,
name|use
decl_stmt|,
name|def
decl_stmt|;
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
operator|*
name|changed
operator|=
name|bitmap_union_of_diff
argument_list|(
name|in
argument_list|,
name|use
argument_list|,
name|out
argument_list|,
name|def
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compute local reaching def info for basic block BB.  */
end_comment

begin_function
specifier|static
name|void
name|df_bb_rd_local_compute
parameter_list|(
name|df
parameter_list|,
name|bb
parameter_list|)
name|struct
name|df
modifier|*
name|df
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
block|{
name|struct
name|bb_info
modifier|*
name|bb_info
init|=
name|DF_BB_INFO
argument_list|(
name|df
argument_list|,
name|bb
argument_list|)
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|bb
operator|->
name|head
init|;
name|insn
operator|&&
name|insn
operator|!=
name|NEXT_INSN
argument_list|(
name|bb
operator|->
name|end
argument_list|)
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|unsigned
name|int
name|uid
init|=
name|INSN_UID
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|struct
name|df_link
modifier|*
name|def_link
decl_stmt|;
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
continue|continue;
for|for
control|(
name|def_link
operator|=
name|df
operator|->
name|insns
index|[
name|uid
index|]
operator|.
name|defs
init|;
name|def_link
condition|;
name|def_link
operator|=
name|def_link
operator|->
name|next
control|)
block|{
name|struct
name|ref
modifier|*
name|def
init|=
name|def_link
operator|->
name|ref
decl_stmt|;
name|unsigned
name|int
name|regno
init|=
name|DF_REF_REGNO
argument_list|(
name|def
argument_list|)
decl_stmt|;
name|struct
name|df_link
modifier|*
name|def2_link
decl_stmt|;
for|for
control|(
name|def2_link
operator|=
name|df
operator|->
name|regs
index|[
name|regno
index|]
operator|.
name|defs
init|;
name|def2_link
condition|;
name|def2_link
operator|=
name|def2_link
operator|->
name|next
control|)
block|{
name|struct
name|ref
modifier|*
name|def2
init|=
name|def2_link
operator|->
name|ref
decl_stmt|;
comment|/* Add all defs of this reg to the set of kills.  This 		 is greedy since many of these defs will not actually 		 be killed by this BB but it keeps things a lot 		 simpler.  */
name|bitmap_set_bit
argument_list|(
name|bb_info
operator|->
name|rd_kill
argument_list|,
name|DF_REF_ID
argument_list|(
name|def2
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Zap from the set of gens for this BB.  */
name|bitmap_clear_bit
argument_list|(
name|bb_info
operator|->
name|rd_gen
argument_list|,
name|DF_REF_ID
argument_list|(
name|def2
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|bitmap_set_bit
argument_list|(
name|bb_info
operator|->
name|rd_gen
argument_list|,
name|DF_REF_ID
argument_list|(
name|def
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|bb_info
operator|->
name|rd_valid
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compute local reaching def info for each basic block within BLOCKS.  */
end_comment

begin_function
specifier|static
name|void
name|df_rd_local_compute
parameter_list|(
name|df
parameter_list|,
name|blocks
parameter_list|)
name|struct
name|df
modifier|*
name|df
decl_stmt|;
name|bitmap
name|blocks
decl_stmt|;
block|{
name|basic_block
name|bb
decl_stmt|;
name|FOR_EACH_BB_IN_BITMAP
argument_list|(
argument|blocks
argument_list|,
literal|0
argument_list|,
argument|bb
argument_list|,
argument|{     df_bb_rd_local_compute (df, bb);   }
argument_list|)
empty_stmt|;
block|}
end_function

begin_comment
comment|/* Compute local reaching use (upward exposed use) info for basic    block BB.  */
end_comment

begin_function
specifier|static
name|void
name|df_bb_ru_local_compute
parameter_list|(
name|df
parameter_list|,
name|bb
parameter_list|)
name|struct
name|df
modifier|*
name|df
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
block|{
comment|/* This is much more tricky than computing reaching defs.  With      reaching defs, defs get killed by other defs.  With upwards      exposed uses, these get killed by defs with the same regno.  */
name|struct
name|bb_info
modifier|*
name|bb_info
init|=
name|DF_BB_INFO
argument_list|(
name|df
argument_list|,
name|bb
argument_list|)
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|bb
operator|->
name|end
init|;
name|insn
operator|&&
name|insn
operator|!=
name|PREV_INSN
argument_list|(
name|bb
operator|->
name|head
argument_list|)
condition|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|unsigned
name|int
name|uid
init|=
name|INSN_UID
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|struct
name|df_link
modifier|*
name|def_link
decl_stmt|;
name|struct
name|df_link
modifier|*
name|use_link
decl_stmt|;
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
continue|continue;
for|for
control|(
name|def_link
operator|=
name|df
operator|->
name|insns
index|[
name|uid
index|]
operator|.
name|defs
init|;
name|def_link
condition|;
name|def_link
operator|=
name|def_link
operator|->
name|next
control|)
block|{
name|struct
name|ref
modifier|*
name|def
init|=
name|def_link
operator|->
name|ref
decl_stmt|;
name|unsigned
name|int
name|dregno
init|=
name|DF_REF_REGNO
argument_list|(
name|def
argument_list|)
decl_stmt|;
for|for
control|(
name|use_link
operator|=
name|df
operator|->
name|regs
index|[
name|dregno
index|]
operator|.
name|uses
init|;
name|use_link
condition|;
name|use_link
operator|=
name|use_link
operator|->
name|next
control|)
block|{
name|struct
name|ref
modifier|*
name|use
init|=
name|use_link
operator|->
name|ref
decl_stmt|;
comment|/* Add all uses of this reg to the set of kills.  This 		 is greedy since many of these uses will not actually 		 be killed by this BB but it keeps things a lot 		 simpler.  */
name|bitmap_set_bit
argument_list|(
name|bb_info
operator|->
name|ru_kill
argument_list|,
name|DF_REF_ID
argument_list|(
name|use
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Zap from the set of gens for this BB.  */
name|bitmap_clear_bit
argument_list|(
name|bb_info
operator|->
name|ru_gen
argument_list|,
name|DF_REF_ID
argument_list|(
name|use
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|use_link
operator|=
name|df
operator|->
name|insns
index|[
name|uid
index|]
operator|.
name|uses
init|;
name|use_link
condition|;
name|use_link
operator|=
name|use_link
operator|->
name|next
control|)
block|{
name|struct
name|ref
modifier|*
name|use
init|=
name|use_link
operator|->
name|ref
decl_stmt|;
comment|/* Add use to set of gens in this BB.  */
name|bitmap_set_bit
argument_list|(
name|bb_info
operator|->
name|ru_gen
argument_list|,
name|DF_REF_ID
argument_list|(
name|use
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|bb_info
operator|->
name|ru_valid
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compute local reaching use (upward exposed use) info for each basic    block within BLOCKS.  */
end_comment

begin_function
specifier|static
name|void
name|df_ru_local_compute
parameter_list|(
name|df
parameter_list|,
name|blocks
parameter_list|)
name|struct
name|df
modifier|*
name|df
decl_stmt|;
name|bitmap
name|blocks
decl_stmt|;
block|{
name|basic_block
name|bb
decl_stmt|;
name|FOR_EACH_BB_IN_BITMAP
argument_list|(
argument|blocks
argument_list|,
literal|0
argument_list|,
argument|bb
argument_list|,
argument|{     df_bb_ru_local_compute (df, bb);   }
argument_list|)
empty_stmt|;
block|}
end_function

begin_comment
comment|/* Compute local live variable info for basic block BB.  */
end_comment

begin_function
specifier|static
name|void
name|df_bb_lr_local_compute
parameter_list|(
name|df
parameter_list|,
name|bb
parameter_list|)
name|struct
name|df
modifier|*
name|df
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
block|{
name|struct
name|bb_info
modifier|*
name|bb_info
init|=
name|DF_BB_INFO
argument_list|(
name|df
argument_list|,
name|bb
argument_list|)
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|bb
operator|->
name|end
init|;
name|insn
operator|&&
name|insn
operator|!=
name|PREV_INSN
argument_list|(
name|bb
operator|->
name|head
argument_list|)
condition|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|unsigned
name|int
name|uid
init|=
name|INSN_UID
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|struct
name|df_link
modifier|*
name|link
decl_stmt|;
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
continue|continue;
for|for
control|(
name|link
operator|=
name|df
operator|->
name|insns
index|[
name|uid
index|]
operator|.
name|defs
init|;
name|link
condition|;
name|link
operator|=
name|link
operator|->
name|next
control|)
block|{
name|struct
name|ref
modifier|*
name|def
init|=
name|link
operator|->
name|ref
decl_stmt|;
name|unsigned
name|int
name|dregno
init|=
name|DF_REF_REGNO
argument_list|(
name|def
argument_list|)
decl_stmt|;
comment|/* Add def to set of defs in this BB.  */
name|bitmap_set_bit
argument_list|(
name|bb_info
operator|->
name|lr_def
argument_list|,
name|dregno
argument_list|)
expr_stmt|;
name|bitmap_clear_bit
argument_list|(
name|bb_info
operator|->
name|lr_use
argument_list|,
name|dregno
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|link
operator|=
name|df
operator|->
name|insns
index|[
name|uid
index|]
operator|.
name|uses
init|;
name|link
condition|;
name|link
operator|=
name|link
operator|->
name|next
control|)
block|{
name|struct
name|ref
modifier|*
name|use
init|=
name|link
operator|->
name|ref
decl_stmt|;
comment|/* Add use to set of uses in this BB.  */
name|bitmap_set_bit
argument_list|(
name|bb_info
operator|->
name|lr_use
argument_list|,
name|DF_REF_REGNO
argument_list|(
name|use
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|bb_info
operator|->
name|lr_valid
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compute local live variable info for each basic block within BLOCKS.  */
end_comment

begin_function
specifier|static
name|void
name|df_lr_local_compute
parameter_list|(
name|df
parameter_list|,
name|blocks
parameter_list|)
name|struct
name|df
modifier|*
name|df
decl_stmt|;
name|bitmap
name|blocks
decl_stmt|;
block|{
name|basic_block
name|bb
decl_stmt|;
name|FOR_EACH_BB_IN_BITMAP
argument_list|(
argument|blocks
argument_list|,
literal|0
argument_list|,
argument|bb
argument_list|,
argument|{     df_bb_lr_local_compute (df, bb);   }
argument_list|)
empty_stmt|;
block|}
end_function

begin_comment
comment|/* Compute register info: lifetime, bb, and number of defs and uses    for basic block BB.  */
end_comment

begin_function
specifier|static
name|void
name|df_bb_reg_info_compute
parameter_list|(
name|df
parameter_list|,
name|bb
parameter_list|,
name|live
parameter_list|)
name|struct
name|df
modifier|*
name|df
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|bitmap
name|live
decl_stmt|;
block|{
name|struct
name|reg_info
modifier|*
name|reg_info
init|=
name|df
operator|->
name|regs
decl_stmt|;
name|struct
name|bb_info
modifier|*
name|bb_info
init|=
name|DF_BB_INFO
argument_list|(
name|df
argument_list|,
name|bb
argument_list|)
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|bitmap_copy
argument_list|(
name|live
argument_list|,
name|bb_info
operator|->
name|lr_out
argument_list|)
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|bb
operator|->
name|end
init|;
name|insn
operator|&&
name|insn
operator|!=
name|PREV_INSN
argument_list|(
name|bb
operator|->
name|head
argument_list|)
condition|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|unsigned
name|int
name|uid
init|=
name|INSN_UID
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|regno
decl_stmt|;
name|struct
name|df_link
modifier|*
name|link
decl_stmt|;
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
continue|continue;
for|for
control|(
name|link
operator|=
name|df
operator|->
name|insns
index|[
name|uid
index|]
operator|.
name|defs
init|;
name|link
condition|;
name|link
operator|=
name|link
operator|->
name|next
control|)
block|{
name|struct
name|ref
modifier|*
name|def
init|=
name|link
operator|->
name|ref
decl_stmt|;
name|unsigned
name|int
name|dregno
init|=
name|DF_REF_REGNO
argument_list|(
name|def
argument_list|)
decl_stmt|;
comment|/* Kill this register.  */
name|bitmap_clear_bit
argument_list|(
name|live
argument_list|,
name|dregno
argument_list|)
expr_stmt|;
name|reg_info
index|[
name|dregno
index|]
operator|.
name|n_defs
operator|++
expr_stmt|;
block|}
for|for
control|(
name|link
operator|=
name|df
operator|->
name|insns
index|[
name|uid
index|]
operator|.
name|uses
init|;
name|link
condition|;
name|link
operator|=
name|link
operator|->
name|next
control|)
block|{
name|struct
name|ref
modifier|*
name|use
init|=
name|link
operator|->
name|ref
decl_stmt|;
name|unsigned
name|int
name|uregno
init|=
name|DF_REF_REGNO
argument_list|(
name|use
argument_list|)
decl_stmt|;
comment|/* This register is now live.  */
name|bitmap_set_bit
argument_list|(
name|live
argument_list|,
name|uregno
argument_list|)
expr_stmt|;
name|reg_info
index|[
name|uregno
index|]
operator|.
name|n_uses
operator|++
expr_stmt|;
block|}
comment|/* Increment lifetimes of all live registers.  */
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|live
argument_list|,
literal|0
argument_list|,
argument|regno
argument_list|,
argument|{ 	reg_info[regno].lifetime++;       }
argument_list|)
empty_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Compute register info: lifetime, bb, and number of defs and uses.  */
end_comment

begin_function
specifier|static
name|void
name|df_reg_info_compute
parameter_list|(
name|df
parameter_list|,
name|blocks
parameter_list|)
name|struct
name|df
modifier|*
name|df
decl_stmt|;
name|bitmap
name|blocks
decl_stmt|;
block|{
name|basic_block
name|bb
decl_stmt|;
name|bitmap
name|live
decl_stmt|;
name|live
operator|=
name|BITMAP_XMALLOC
argument_list|()
expr_stmt|;
name|FOR_EACH_BB_IN_BITMAP
argument_list|(
argument|blocks
argument_list|,
literal|0
argument_list|,
argument|bb
argument_list|,
argument|{     df_bb_reg_info_compute (df, bb, live);   }
argument_list|)
empty_stmt|;
name|BITMAP_XFREE
argument_list|(
name|live
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Assign LUIDs for BB.  */
end_comment

begin_function
specifier|static
name|int
name|df_bb_luids_set
parameter_list|(
name|df
parameter_list|,
name|bb
parameter_list|)
name|struct
name|df
modifier|*
name|df
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|;
name|int
name|luid
init|=
literal|0
decl_stmt|;
comment|/* The LUIDs are monotonically increasing for each basic block.  */
for|for
control|(
name|insn
operator|=
name|bb
operator|->
name|head
init|;
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
name|DF_INSN_LUID
argument_list|(
name|df
argument_list|,
name|insn
argument_list|)
operator|=
name|luid
operator|++
expr_stmt|;
name|DF_INSN_LUID
argument_list|(
name|df
argument_list|,
name|insn
argument_list|)
operator|=
name|luid
expr_stmt|;
if|if
condition|(
name|insn
operator|==
name|bb
operator|->
name|end
condition|)
break|break;
block|}
return|return
name|luid
return|;
block|}
end_function

begin_comment
comment|/* Assign LUIDs for each basic block within BLOCKS.  */
end_comment

begin_function
specifier|static
name|int
name|df_luids_set
parameter_list|(
name|df
parameter_list|,
name|blocks
parameter_list|)
name|struct
name|df
modifier|*
name|df
decl_stmt|;
name|bitmap
name|blocks
decl_stmt|;
block|{
name|basic_block
name|bb
decl_stmt|;
name|int
name|total
init|=
literal|0
decl_stmt|;
name|FOR_EACH_BB_IN_BITMAP
argument_list|(
argument|blocks
argument_list|,
literal|0
argument_list|,
argument|bb
argument_list|,
argument|{       total += df_bb_luids_set (df, bb);     }
argument_list|)
empty_stmt|;
return|return
name|total
return|;
block|}
end_function

begin_comment
comment|/* Perform dataflow analysis using existing DF structure for blocks    within BLOCKS.  If BLOCKS is zero, use all basic blocks in the CFG.  */
end_comment

begin_function
specifier|static
name|void
name|df_analyse_1
parameter_list|(
name|df
parameter_list|,
name|blocks
parameter_list|,
name|flags
parameter_list|,
name|update
parameter_list|)
name|struct
name|df
modifier|*
name|df
decl_stmt|;
name|bitmap
name|blocks
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|int
name|update
decl_stmt|;
block|{
name|int
name|aflags
decl_stmt|;
name|int
name|dflags
decl_stmt|;
name|int
name|i
decl_stmt|;
name|dflags
operator|=
literal|0
expr_stmt|;
name|aflags
operator|=
name|flags
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|DF_UD_CHAIN
condition|)
name|aflags
operator||=
name|DF_RD
operator||
name|DF_RD_CHAIN
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|DF_DU_CHAIN
condition|)
name|aflags
operator||=
name|DF_RU
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|DF_RU
condition|)
name|aflags
operator||=
name|DF_RU_CHAIN
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|DF_REG_INFO
condition|)
name|aflags
operator||=
name|DF_LR
expr_stmt|;
if|if
condition|(
operator|!
name|blocks
condition|)
name|blocks
operator|=
name|df
operator|->
name|all_blocks
expr_stmt|;
name|df
operator|->
name|flags
operator|=
name|flags
expr_stmt|;
if|if
condition|(
name|update
condition|)
block|{
name|df_refs_update
argument_list|(
name|df
argument_list|)
expr_stmt|;
comment|/* More fine grained incremental dataflow analysis would be 	 nice.  For now recompute the whole shebang for the 	 modified blocks.  */
if|#
directive|if
literal|0
block|df_refs_unlink (df, blocks);
endif|#
directive|endif
comment|/* All the def-use, use-def chains can be potentially 	 modified by changes in one block.  The size of the 	 bitmaps can also change.  */
block|}
else|else
block|{
comment|/* Scan the function for all register defs and uses.  */
name|df_refs_queue
argument_list|(
name|df
argument_list|)
expr_stmt|;
name|df_refs_record
argument_list|(
name|df
argument_list|,
name|blocks
argument_list|)
expr_stmt|;
comment|/* Link all the new defs and uses to the insns.  */
name|df_refs_process
argument_list|(
name|df
argument_list|)
expr_stmt|;
block|}
comment|/* Allocate the bitmaps now the total number of defs and uses are      known.  If the number of defs or uses have changed, then      these bitmaps need to be reallocated.  */
name|df_bitmaps_alloc
argument_list|(
name|df
argument_list|,
name|aflags
argument_list|)
expr_stmt|;
comment|/* Set the LUIDs for each specified basic block.  */
name|df_luids_set
argument_list|(
name|df
argument_list|,
name|blocks
argument_list|)
expr_stmt|;
comment|/* Recreate reg-def and reg-use chains from scratch so that first      def is at the head of the reg-def chain and the last use is at      the head of the reg-use chain.  This is only important for      regs local to a basic block as it speeds up searching.  */
if|if
condition|(
name|aflags
operator|&
name|DF_RD_CHAIN
condition|)
block|{
name|df_reg_def_chain_create
argument_list|(
name|df
argument_list|,
name|blocks
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|aflags
operator|&
name|DF_RU_CHAIN
condition|)
block|{
name|df_reg_use_chain_create
argument_list|(
name|df
argument_list|,
name|blocks
argument_list|)
expr_stmt|;
block|}
name|df
operator|->
name|dfs_order
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|df
operator|->
name|rc_order
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|df
operator|->
name|rts_order
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|df
operator|->
name|inverse_dfs_map
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|df
operator|->
name|inverse_rc_map
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|df
operator|->
name|inverse_rts_map
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|flow_depth_first_order_compute
argument_list|(
name|df
operator|->
name|dfs_order
argument_list|,
name|df
operator|->
name|rc_order
argument_list|)
expr_stmt|;
name|flow_reverse_top_sort_order_compute
argument_list|(
name|df
operator|->
name|rts_order
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
name|i
operator|++
control|)
block|{
name|df
operator|->
name|inverse_dfs_map
index|[
name|df
operator|->
name|dfs_order
index|[
name|i
index|]
index|]
operator|=
name|i
expr_stmt|;
name|df
operator|->
name|inverse_rc_map
index|[
name|df
operator|->
name|rc_order
index|[
name|i
index|]
index|]
operator|=
name|i
expr_stmt|;
name|df
operator|->
name|inverse_rts_map
index|[
name|df
operator|->
name|rts_order
index|[
name|i
index|]
index|]
operator|=
name|i
expr_stmt|;
block|}
if|if
condition|(
name|aflags
operator|&
name|DF_RD
condition|)
block|{
comment|/* Compute the sets of gens and kills for the defs of each bb.  */
name|df_rd_local_compute
argument_list|(
name|df
argument_list|,
name|df
operator|->
name|flags
operator|&
name|DF_RD
condition|?
name|blocks
else|:
name|df
operator|->
name|all_blocks
argument_list|)
expr_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|bitmap
modifier|*
name|in
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|bitmap
argument_list|)
operator|*
name|n_basic_blocks
argument_list|)
decl_stmt|;
name|bitmap
modifier|*
name|out
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|bitmap
argument_list|)
operator|*
name|n_basic_blocks
argument_list|)
decl_stmt|;
name|bitmap
modifier|*
name|gen
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|bitmap
argument_list|)
operator|*
name|n_basic_blocks
argument_list|)
decl_stmt|;
name|bitmap
modifier|*
name|kill
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|bitmap
argument_list|)
operator|*
name|n_basic_blocks
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
name|i
operator|++
control|)
block|{
name|in
index|[
name|i
index|]
operator|=
name|DF_BB_INFO
argument_list|(
name|df
argument_list|,
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
argument_list|)
operator|->
name|rd_in
expr_stmt|;
name|out
index|[
name|i
index|]
operator|=
name|DF_BB_INFO
argument_list|(
name|df
argument_list|,
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
argument_list|)
operator|->
name|rd_out
expr_stmt|;
name|gen
index|[
name|i
index|]
operator|=
name|DF_BB_INFO
argument_list|(
name|df
argument_list|,
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
argument_list|)
operator|->
name|rd_gen
expr_stmt|;
name|kill
index|[
name|i
index|]
operator|=
name|DF_BB_INFO
argument_list|(
name|df
argument_list|,
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
argument_list|)
operator|->
name|rd_kill
expr_stmt|;
block|}
name|iterative_dataflow_bitmap
argument_list|(
name|in
argument_list|,
name|out
argument_list|,
name|gen
argument_list|,
name|kill
argument_list|,
name|df
operator|->
name|all_blocks
argument_list|,
name|FORWARD
argument_list|,
name|UNION
argument_list|,
name|df_rd_transfer_function
argument_list|,
name|df
operator|->
name|inverse_rc_map
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|gen
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|kill
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|aflags
operator|&
name|DF_UD_CHAIN
condition|)
block|{
comment|/* Create use-def chains.  */
name|df_ud_chain_create
argument_list|(
name|df
argument_list|,
name|df
operator|->
name|all_blocks
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|DF_RD
operator|)
condition|)
name|dflags
operator||=
name|DF_RD
expr_stmt|;
block|}
if|if
condition|(
name|aflags
operator|&
name|DF_RU
condition|)
block|{
comment|/* Compute the sets of gens and kills for the upwards exposed 	 uses in each bb.  */
name|df_ru_local_compute
argument_list|(
name|df
argument_list|,
name|df
operator|->
name|flags
operator|&
name|DF_RU
condition|?
name|blocks
else|:
name|df
operator|->
name|all_blocks
argument_list|)
expr_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|bitmap
modifier|*
name|in
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|bitmap
argument_list|)
operator|*
name|n_basic_blocks
argument_list|)
decl_stmt|;
name|bitmap
modifier|*
name|out
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|bitmap
argument_list|)
operator|*
name|n_basic_blocks
argument_list|)
decl_stmt|;
name|bitmap
modifier|*
name|gen
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|bitmap
argument_list|)
operator|*
name|n_basic_blocks
argument_list|)
decl_stmt|;
name|bitmap
modifier|*
name|kill
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|bitmap
argument_list|)
operator|*
name|n_basic_blocks
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
name|i
operator|++
control|)
block|{
name|in
index|[
name|i
index|]
operator|=
name|DF_BB_INFO
argument_list|(
name|df
argument_list|,
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
argument_list|)
operator|->
name|ru_in
expr_stmt|;
name|out
index|[
name|i
index|]
operator|=
name|DF_BB_INFO
argument_list|(
name|df
argument_list|,
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
argument_list|)
operator|->
name|ru_out
expr_stmt|;
name|gen
index|[
name|i
index|]
operator|=
name|DF_BB_INFO
argument_list|(
name|df
argument_list|,
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
argument_list|)
operator|->
name|ru_gen
expr_stmt|;
name|kill
index|[
name|i
index|]
operator|=
name|DF_BB_INFO
argument_list|(
name|df
argument_list|,
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
argument_list|)
operator|->
name|ru_kill
expr_stmt|;
block|}
name|iterative_dataflow_bitmap
argument_list|(
name|in
argument_list|,
name|out
argument_list|,
name|gen
argument_list|,
name|kill
argument_list|,
name|df
operator|->
name|all_blocks
argument_list|,
name|BACKWARD
argument_list|,
name|UNION
argument_list|,
name|df_ru_transfer_function
argument_list|,
name|df
operator|->
name|inverse_rts_map
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|gen
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|kill
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|aflags
operator|&
name|DF_DU_CHAIN
condition|)
block|{
comment|/* Create def-use chains.  */
name|df_du_chain_create
argument_list|(
name|df
argument_list|,
name|df
operator|->
name|all_blocks
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|DF_RU
operator|)
condition|)
name|dflags
operator||=
name|DF_RU
expr_stmt|;
block|}
comment|/* Free up bitmaps that are no longer required.  */
if|if
condition|(
name|dflags
condition|)
name|df_bitmaps_free
argument_list|(
name|df
argument_list|,
name|dflags
argument_list|)
expr_stmt|;
if|if
condition|(
name|aflags
operator|&
name|DF_LR
condition|)
block|{
comment|/* Compute the sets of defs and uses of live variables.  */
name|df_lr_local_compute
argument_list|(
name|df
argument_list|,
name|df
operator|->
name|flags
operator|&
name|DF_LR
condition|?
name|blocks
else|:
name|df
operator|->
name|all_blocks
argument_list|)
expr_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|bitmap
modifier|*
name|in
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|bitmap
argument_list|)
operator|*
name|n_basic_blocks
argument_list|)
decl_stmt|;
name|bitmap
modifier|*
name|out
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|bitmap
argument_list|)
operator|*
name|n_basic_blocks
argument_list|)
decl_stmt|;
name|bitmap
modifier|*
name|use
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|bitmap
argument_list|)
operator|*
name|n_basic_blocks
argument_list|)
decl_stmt|;
name|bitmap
modifier|*
name|def
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|bitmap
argument_list|)
operator|*
name|n_basic_blocks
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
name|i
operator|++
control|)
block|{
name|in
index|[
name|i
index|]
operator|=
name|DF_BB_INFO
argument_list|(
name|df
argument_list|,
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
argument_list|)
operator|->
name|lr_in
expr_stmt|;
name|out
index|[
name|i
index|]
operator|=
name|DF_BB_INFO
argument_list|(
name|df
argument_list|,
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
argument_list|)
operator|->
name|lr_out
expr_stmt|;
name|use
index|[
name|i
index|]
operator|=
name|DF_BB_INFO
argument_list|(
name|df
argument_list|,
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
argument_list|)
operator|->
name|lr_use
expr_stmt|;
name|def
index|[
name|i
index|]
operator|=
name|DF_BB_INFO
argument_list|(
name|df
argument_list|,
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
argument_list|)
operator|->
name|lr_def
expr_stmt|;
block|}
name|iterative_dataflow_bitmap
argument_list|(
name|in
argument_list|,
name|out
argument_list|,
name|use
argument_list|,
name|def
argument_list|,
name|df
operator|->
name|all_blocks
argument_list|,
name|BACKWARD
argument_list|,
name|UNION
argument_list|,
name|df_lr_transfer_function
argument_list|,
name|df
operator|->
name|inverse_rts_map
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|use
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|def
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|aflags
operator|&
name|DF_REG_INFO
condition|)
block|{
name|df_reg_info_compute
argument_list|(
name|df
argument_list|,
name|df
operator|->
name|all_blocks
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|df
operator|->
name|dfs_order
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|df
operator|->
name|rc_order
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|df
operator|->
name|rts_order
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|df
operator|->
name|inverse_rc_map
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|df
operator|->
name|inverse_dfs_map
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|df
operator|->
name|inverse_rts_map
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialise dataflow analysis.  */
end_comment

begin_function
name|struct
name|df
modifier|*
name|df_init
parameter_list|()
block|{
name|struct
name|df
modifier|*
name|df
decl_stmt|;
name|df
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|df
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Squirrel away a global for debugging.  */
name|ddf
operator|=
name|df
expr_stmt|;
return|return
name|df
return|;
block|}
end_function

begin_comment
comment|/* Start queuing refs.  */
end_comment

begin_function
specifier|static
name|int
name|df_refs_queue
parameter_list|(
name|df
parameter_list|)
name|struct
name|df
modifier|*
name|df
decl_stmt|;
block|{
name|df
operator|->
name|def_id_save
operator|=
name|df
operator|->
name|def_id
expr_stmt|;
name|df
operator|->
name|use_id_save
operator|=
name|df
operator|->
name|use_id
expr_stmt|;
comment|/* ???? Perhaps we should save current obstack state so that we can      unwind it.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Process queued refs.  */
end_comment

begin_function
specifier|static
name|int
name|df_refs_process
parameter_list|(
name|df
parameter_list|)
name|struct
name|df
modifier|*
name|df
decl_stmt|;
block|{
name|unsigned
name|int
name|i
decl_stmt|;
comment|/* Build new insn-def chains.  */
for|for
control|(
name|i
operator|=
name|df
operator|->
name|def_id_save
init|;
name|i
operator|!=
name|df
operator|->
name|def_id
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ref
modifier|*
name|def
init|=
name|df
operator|->
name|defs
index|[
name|i
index|]
decl_stmt|;
name|unsigned
name|int
name|uid
init|=
name|DF_REF_INSN_UID
argument_list|(
name|def
argument_list|)
decl_stmt|;
comment|/* Add def to head of def list for INSN.  */
name|df
operator|->
name|insns
index|[
name|uid
index|]
operator|.
name|defs
operator|=
name|df_link_create
argument_list|(
name|def
argument_list|,
name|df
operator|->
name|insns
index|[
name|uid
index|]
operator|.
name|defs
argument_list|)
expr_stmt|;
block|}
comment|/* Build new insn-use chains.  */
for|for
control|(
name|i
operator|=
name|df
operator|->
name|use_id_save
init|;
name|i
operator|!=
name|df
operator|->
name|use_id
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ref
modifier|*
name|use
init|=
name|df
operator|->
name|uses
index|[
name|i
index|]
decl_stmt|;
name|unsigned
name|int
name|uid
init|=
name|DF_REF_INSN_UID
argument_list|(
name|use
argument_list|)
decl_stmt|;
comment|/* Add use to head of use list for INSN.  */
name|df
operator|->
name|insns
index|[
name|uid
index|]
operator|.
name|uses
operator|=
name|df_link_create
argument_list|(
name|use
argument_list|,
name|df
operator|->
name|insns
index|[
name|uid
index|]
operator|.
name|uses
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Update refs for basic block BB.  */
end_comment

begin_function
specifier|static
name|int
name|df_bb_refs_update
parameter_list|(
name|df
parameter_list|,
name|bb
parameter_list|)
name|struct
name|df
modifier|*
name|df
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
comment|/* While we have to scan the chain of insns for this BB, we don't      need to allocate and queue a long chain of BB/INSN pairs.  Using      a bitmap for insns_modified saves memory and avoids queuing      duplicates.  */
for|for
control|(
name|insn
operator|=
name|bb
operator|->
name|head
init|;
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|unsigned
name|int
name|uid
decl_stmt|;
name|uid
operator|=
name|INSN_UID
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitmap_bit_p
argument_list|(
name|df
operator|->
name|insns_modified
argument_list|,
name|uid
argument_list|)
condition|)
block|{
comment|/* Delete any allocated refs of this insn.  MPH,  FIXME.  */
name|df_insn_refs_unlink
argument_list|(
name|df
argument_list|,
name|bb
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* Scan the insn for refs.  */
name|df_insn_refs_record
argument_list|(
name|df
argument_list|,
name|bb
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|bitmap_clear_bit
argument_list|(
name|df
operator|->
name|insns_modified
argument_list|,
name|uid
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|insn
operator|==
name|bb
operator|->
name|end
condition|)
break|break;
block|}
return|return
name|count
return|;
block|}
end_function

begin_comment
comment|/* Process all the modified/deleted insns that were queued.  */
end_comment

begin_function
specifier|static
name|int
name|df_refs_update
parameter_list|(
name|df
parameter_list|)
name|struct
name|df
modifier|*
name|df
decl_stmt|;
block|{
name|basic_block
name|bb
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|unsigned
name|int
operator|)
name|max_reg_num
argument_list|()
operator|>=
name|df
operator|->
name|reg_size
condition|)
name|df_reg_table_realloc
argument_list|(
name|df
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|df_refs_queue
argument_list|(
name|df
argument_list|)
expr_stmt|;
name|FOR_EACH_BB_IN_BITMAP
argument_list|(
argument|df->bbs_modified
argument_list|,
literal|0
argument_list|,
argument|bb
argument_list|,
argument|{       count += df_bb_refs_update (df, bb);     }
argument_list|)
empty_stmt|;
name|df_refs_process
argument_list|(
name|df
argument_list|)
expr_stmt|;
return|return
name|count
return|;
block|}
end_function

begin_comment
comment|/* Return non-zero if any of the requested blocks in the bitmap    BLOCKS have been modified.  */
end_comment

begin_function
specifier|static
name|int
name|df_modified_p
parameter_list|(
name|df
parameter_list|,
name|blocks
parameter_list|)
name|struct
name|df
modifier|*
name|df
decl_stmt|;
name|bitmap
name|blocks
decl_stmt|;
block|{
name|unsigned
name|int
name|j
decl_stmt|;
name|int
name|update
init|=
literal|0
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|df
operator|->
name|n_bbs
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|bitmap_bit_p
argument_list|(
name|df
operator|->
name|bbs_modified
argument_list|,
name|j
argument_list|)
operator|&&
operator|(
operator|!
name|blocks
operator|||
operator|(
name|blocks
operator|==
operator|(
name|bitmap
operator|)
operator|-
literal|1
operator|)
operator|||
name|bitmap_bit_p
argument_list|(
name|blocks
argument_list|,
name|j
argument_list|)
operator|)
condition|)
block|{
name|update
operator|=
literal|1
expr_stmt|;
break|break;
block|}
return|return
name|update
return|;
block|}
end_function

begin_comment
comment|/* Analyse dataflow info for the basic blocks specified by the bitmap    BLOCKS, or for the whole CFG if BLOCKS is zero, or just for the    modified blocks if BLOCKS is -1.  */
end_comment

begin_function
name|int
name|df_analyse
parameter_list|(
name|df
parameter_list|,
name|blocks
parameter_list|,
name|flags
parameter_list|)
name|struct
name|df
modifier|*
name|df
decl_stmt|;
name|bitmap
name|blocks
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|int
name|update
decl_stmt|;
comment|/* We could deal with additional basic blocks being created by      rescanning everything again.  */
if|if
condition|(
name|df
operator|->
name|n_bbs
operator|&&
name|df
operator|->
name|n_bbs
operator|!=
operator|(
name|unsigned
name|int
operator|)
name|n_basic_blocks
condition|)
name|abort
argument_list|()
expr_stmt|;
name|update
operator|=
name|df_modified_p
argument_list|(
name|df
argument_list|,
name|blocks
argument_list|)
expr_stmt|;
if|if
condition|(
name|update
operator|||
operator|(
name|flags
operator|!=
name|df
operator|->
name|flags
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|blocks
condition|)
block|{
if|if
condition|(
name|df
operator|->
name|n_bbs
condition|)
block|{
comment|/* Recompute everything from scratch.  */
name|df_free
argument_list|(
name|df
argument_list|)
expr_stmt|;
block|}
comment|/* Allocate and initialise data structures.  */
name|df_alloc
argument_list|(
name|df
argument_list|,
name|max_reg_num
argument_list|()
argument_list|)
expr_stmt|;
name|df_analyse_1
argument_list|(
name|df
argument_list|,
literal|0
argument_list|,
name|flags
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|update
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|blocks
operator|==
operator|(
name|bitmap
operator|)
operator|-
literal|1
condition|)
name|blocks
operator|=
name|df
operator|->
name|bbs_modified
expr_stmt|;
if|if
condition|(
operator|!
name|df
operator|->
name|n_bbs
condition|)
name|abort
argument_list|()
expr_stmt|;
name|df_analyse_1
argument_list|(
name|df
argument_list|,
name|blocks
argument_list|,
name|flags
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|bitmap_zero
argument_list|(
name|df
operator|->
name|bbs_modified
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|update
return|;
block|}
end_function

begin_comment
comment|/* Free all the dataflow info and the DF structure.  */
end_comment

begin_function
name|void
name|df_finish
parameter_list|(
name|df
parameter_list|)
name|struct
name|df
modifier|*
name|df
decl_stmt|;
block|{
name|df_free
argument_list|(
name|df
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|df
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Unlink INSN from its reference information.  */
end_comment

begin_function
specifier|static
name|void
name|df_insn_refs_unlink
parameter_list|(
name|df
parameter_list|,
name|bb
parameter_list|,
name|insn
parameter_list|)
name|struct
name|df
modifier|*
name|df
decl_stmt|;
name|basic_block
name|bb
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
name|struct
name|df_link
modifier|*
name|link
decl_stmt|;
name|unsigned
name|int
name|uid
decl_stmt|;
name|uid
operator|=
name|INSN_UID
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Unlink all refs defined by this insn.  */
for|for
control|(
name|link
operator|=
name|df
operator|->
name|insns
index|[
name|uid
index|]
operator|.
name|defs
init|;
name|link
condition|;
name|link
operator|=
name|link
operator|->
name|next
control|)
name|df_def_unlink
argument_list|(
name|df
argument_list|,
name|link
operator|->
name|ref
argument_list|)
expr_stmt|;
comment|/* Unlink all refs used by this insn.  */
for|for
control|(
name|link
operator|=
name|df
operator|->
name|insns
index|[
name|uid
index|]
operator|.
name|uses
init|;
name|link
condition|;
name|link
operator|=
name|link
operator|->
name|next
control|)
name|df_use_unlink
argument_list|(
name|df
argument_list|,
name|link
operator|->
name|ref
argument_list|)
expr_stmt|;
name|df
operator|->
name|insns
index|[
name|uid
index|]
operator|.
name|defs
operator|=
literal|0
expr_stmt|;
name|df
operator|->
name|insns
index|[
name|uid
index|]
operator|.
name|uses
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Unlink all the insns within BB from their reference information.  */
end_comment

begin_comment
unit|static void df_bb_refs_unlink (df, bb)      struct df *df;      basic_block bb; {   rtx insn;
comment|/* Scan the block an insn at a time from beginning to end.  */
end_comment

begin_comment
unit|for (insn = bb->head; ; insn = NEXT_INSN (insn))     {       if (INSN_P (insn)) 	{
comment|/* Unlink refs for INSN.  */
end_comment

begin_comment
unit|df_insn_refs_unlink (df, bb, insn); 	}       if (insn == bb->end) 	break;     } }
comment|/* Unlink all the refs in the basic blocks specified by BLOCKS.    Not currently used.  */
end_comment

begin_endif
unit|static void df_refs_unlink (df, blocks)      struct df *df;      bitmap blocks; {   basic_block bb;    if (blocks)     {       FOR_EACH_BB_IN_BITMAP (blocks, 0, bb,       { 	df_bb_refs_unlink (df, bb);       });     }   else     {       FOR_ALL_BBS (bb,       { 	df_bb_refs_unlink (df, bb);       });     } }
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Functions to modify insns.  */
end_comment

begin_comment
comment|/* Delete INSN and all its reference information.  */
end_comment

begin_function
name|rtx
name|df_insn_delete
parameter_list|(
name|df
parameter_list|,
name|bb
parameter_list|,
name|insn
parameter_list|)
name|struct
name|df
modifier|*
name|df
decl_stmt|;
name|basic_block
name|bb
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
comment|/* If the insn is a jump, we should perhaps call delete_insn to      handle the JUMP_LABEL?  */
comment|/* We should not be deleting the NOTE_INSN_BASIC_BLOCK or label.  */
if|if
condition|(
name|insn
operator|==
name|bb
operator|->
name|head
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Delete the insn.  */
name|delete_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|df_insn_modify
argument_list|(
name|df
argument_list|,
name|bb
argument_list|,
name|insn
argument_list|)
expr_stmt|;
return|return
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Mark that INSN within BB may have changed  (created/modified/deleted).    This may be called multiple times for the same insn.  There is no    harm calling this function if the insn wasn't changed; it will just    slow down the rescanning of refs.  */
end_comment

begin_function
name|void
name|df_insn_modify
parameter_list|(
name|df
parameter_list|,
name|bb
parameter_list|,
name|insn
parameter_list|)
name|struct
name|df
modifier|*
name|df
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
name|unsigned
name|int
name|uid
decl_stmt|;
name|uid
operator|=
name|INSN_UID
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|uid
operator|>=
name|df
operator|->
name|insn_size
condition|)
name|df_insn_table_realloc
argument_list|(
name|df
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bitmap_set_bit
argument_list|(
name|df
operator|->
name|bbs_modified
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|bitmap_set_bit
argument_list|(
name|df
operator|->
name|insns_modified
argument_list|,
name|uid
argument_list|)
expr_stmt|;
comment|/* For incremental updating on the fly, perhaps we could make a copy      of all the refs of the original insn and turn them into      anti-refs.  When df_refs_update finds these anti-refs, it annihilates      the original refs.  If validate_change fails then these anti-refs      will just get ignored.  */
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
name|replace_args
block|{
name|rtx
name|match
decl_stmt|;
name|rtx
name|replacement
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|int
name|modified
decl_stmt|;
block|}
name|replace_args
typedef|;
end_typedef

begin_comment
comment|/* Replace mem pointed to by PX with its associated pseudo register.    DATA is actually a pointer to a structure describing the    instruction currently being scanned and the MEM we are currently    replacing.  */
end_comment

begin_function
specifier|static
name|int
name|df_rtx_mem_replace
parameter_list|(
name|px
parameter_list|,
name|data
parameter_list|)
name|rtx
modifier|*
name|px
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
name|replace_args
modifier|*
name|args
init|=
operator|(
name|replace_args
operator|*
operator|)
name|data
decl_stmt|;
name|rtx
name|mem
init|=
operator|*
name|px
decl_stmt|;
if|if
condition|(
name|mem
operator|==
name|NULL_RTX
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|mem
argument_list|)
condition|)
block|{
case|case
name|MEM
case|:
break|break;
case|case
name|CONST_DOUBLE
case|:
comment|/* We're not interested in the MEM associated with a 	 CONST_DOUBLE, so there's no need to traverse into one.  */
return|return
operator|-
literal|1
return|;
default|default:
comment|/* This is not a MEM.  */
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|rtx_equal_p
argument_list|(
name|args
operator|->
name|match
argument_list|,
name|mem
argument_list|)
condition|)
comment|/* This is not the MEM we are currently replacing.  */
return|return
literal|0
return|;
comment|/* Actually replace the MEM.  */
name|validate_change
argument_list|(
name|args
operator|->
name|insn
argument_list|,
name|px
argument_list|,
name|args
operator|->
name|replacement
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|args
operator|->
name|modified
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|df_insn_mem_replace
parameter_list|(
name|df
parameter_list|,
name|bb
parameter_list|,
name|insn
parameter_list|,
name|mem
parameter_list|,
name|reg
parameter_list|)
name|struct
name|df
modifier|*
name|df
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|rtx
name|mem
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
block|{
name|replace_args
name|args
decl_stmt|;
name|args
operator|.
name|insn
operator|=
name|insn
expr_stmt|;
name|args
operator|.
name|match
operator|=
name|mem
expr_stmt|;
name|args
operator|.
name|replacement
operator|=
name|reg
expr_stmt|;
name|args
operator|.
name|modified
operator|=
literal|0
expr_stmt|;
comment|/* Search and replace all matching mems within insn.  */
name|for_each_rtx
argument_list|(
operator|&
name|insn
argument_list|,
name|df_rtx_mem_replace
argument_list|,
operator|&
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|.
name|modified
condition|)
name|df_insn_modify
argument_list|(
name|df
argument_list|,
name|bb
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* ???? FIXME.  We may have a new def or one or more new uses of REG      in INSN.  REG should be a new pseudo so it won't affect the      dataflow information that we currently have.  We should add      the new uses and defs to INSN and then recreate the chains      when df_analyse is called.  */
return|return
name|args
operator|.
name|modified
return|;
block|}
end_function

begin_comment
comment|/* Replace one register with another.  Called through for_each_rtx; PX    points to the rtx being scanned.  DATA is actually a pointer to a    structure of arguments.  */
end_comment

begin_function
specifier|static
name|int
name|df_rtx_reg_replace
parameter_list|(
name|px
parameter_list|,
name|data
parameter_list|)
name|rtx
modifier|*
name|px
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
name|rtx
name|x
init|=
operator|*
name|px
decl_stmt|;
name|replace_args
modifier|*
name|args
init|=
operator|(
name|replace_args
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
name|x
operator|==
name|NULL_RTX
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|x
operator|==
name|args
operator|->
name|match
condition|)
block|{
name|validate_change
argument_list|(
name|args
operator|->
name|insn
argument_list|,
name|px
argument_list|,
name|args
operator|->
name|replacement
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|args
operator|->
name|modified
operator|++
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Replace the reg within every ref on CHAIN that is within the set    BLOCKS of basic blocks with NEWREG.  Also update the regs within    REG_NOTES.  */
end_comment

begin_function
name|void
name|df_refs_reg_replace
parameter_list|(
name|df
parameter_list|,
name|blocks
parameter_list|,
name|chain
parameter_list|,
name|oldreg
parameter_list|,
name|newreg
parameter_list|)
name|struct
name|df
modifier|*
name|df
decl_stmt|;
name|bitmap
name|blocks
decl_stmt|;
name|struct
name|df_link
modifier|*
name|chain
decl_stmt|;
name|rtx
name|oldreg
decl_stmt|;
name|rtx
name|newreg
decl_stmt|;
block|{
name|struct
name|df_link
modifier|*
name|link
decl_stmt|;
name|replace_args
name|args
decl_stmt|;
if|if
condition|(
operator|!
name|blocks
condition|)
name|blocks
operator|=
name|df
operator|->
name|all_blocks
expr_stmt|;
name|args
operator|.
name|match
operator|=
name|oldreg
expr_stmt|;
name|args
operator|.
name|replacement
operator|=
name|newreg
expr_stmt|;
name|args
operator|.
name|modified
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|link
operator|=
name|chain
init|;
name|link
condition|;
name|link
operator|=
name|link
operator|->
name|next
control|)
block|{
name|struct
name|ref
modifier|*
name|ref
init|=
name|link
operator|->
name|ref
decl_stmt|;
name|rtx
name|insn
init|=
name|DF_REF_INSN
argument_list|(
name|ref
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|bitmap_bit_p
argument_list|(
name|blocks
argument_list|,
name|DF_REF_BBNO
argument_list|(
name|ref
argument_list|)
argument_list|)
condition|)
block|{
name|df_ref_reg_replace
argument_list|(
name|df
argument_list|,
name|ref
argument_list|,
name|oldreg
argument_list|,
name|newreg
argument_list|)
expr_stmt|;
comment|/* Replace occurrences of the reg within the REG_NOTES.  */
if|if
condition|(
operator|(
operator|!
name|link
operator|->
name|next
operator|||
name|DF_REF_INSN
argument_list|(
name|ref
argument_list|)
operator|!=
name|DF_REF_INSN
argument_list|(
name|link
operator|->
name|next
operator|->
name|ref
argument_list|)
operator|)
operator|&&
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|args
operator|.
name|insn
operator|=
name|insn
expr_stmt|;
name|for_each_rtx
argument_list|(
operator|&
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|,
name|df_rtx_reg_replace
argument_list|,
operator|&
name|args
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Temporary check to ensure that we have a grip on which 	     regs should be replaced.  */
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Replace all occurrences of register OLDREG with register NEWREG in    blocks defined by bitmap BLOCKS.  This also replaces occurrences of    OLDREG in the REG_NOTES but only for insns containing OLDREG.  This    routine expects the reg-use and reg-def chains to be valid.  */
end_comment

begin_function
name|int
name|df_reg_replace
parameter_list|(
name|df
parameter_list|,
name|blocks
parameter_list|,
name|oldreg
parameter_list|,
name|newreg
parameter_list|)
name|struct
name|df
modifier|*
name|df
decl_stmt|;
name|bitmap
name|blocks
decl_stmt|;
name|rtx
name|oldreg
decl_stmt|;
name|rtx
name|newreg
decl_stmt|;
block|{
name|unsigned
name|int
name|oldregno
init|=
name|REGNO
argument_list|(
name|oldreg
argument_list|)
decl_stmt|;
name|df_refs_reg_replace
argument_list|(
name|df
argument_list|,
name|blocks
argument_list|,
name|df
operator|->
name|regs
index|[
name|oldregno
index|]
operator|.
name|defs
argument_list|,
name|oldreg
argument_list|,
name|newreg
argument_list|)
expr_stmt|;
name|df_refs_reg_replace
argument_list|(
name|df
argument_list|,
name|blocks
argument_list|,
name|df
operator|->
name|regs
index|[
name|oldregno
index|]
operator|.
name|uses
argument_list|,
name|oldreg
argument_list|,
name|newreg
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Try replacing the reg within REF with NEWREG.  Do not modify    def-use/use-def chains.  */
end_comment

begin_function
name|int
name|df_ref_reg_replace
parameter_list|(
name|df
parameter_list|,
name|ref
parameter_list|,
name|oldreg
parameter_list|,
name|newreg
parameter_list|)
name|struct
name|df
modifier|*
name|df
decl_stmt|;
name|struct
name|ref
modifier|*
name|ref
decl_stmt|;
name|rtx
name|oldreg
decl_stmt|;
name|rtx
name|newreg
decl_stmt|;
block|{
comment|/* Check that insn was deleted by being converted into a NOTE.  If    so ignore this insn.  */
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|DF_REF_INSN
argument_list|(
name|ref
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|oldreg
operator|&&
name|oldreg
operator|!=
name|DF_REF_REG
argument_list|(
name|ref
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|validate_change
argument_list|(
name|DF_REF_INSN
argument_list|(
name|ref
argument_list|)
argument_list|,
name|DF_REF_LOC
argument_list|(
name|ref
argument_list|)
argument_list|,
name|newreg
argument_list|,
literal|1
argument_list|)
condition|)
return|return
literal|0
return|;
name|df_insn_modify
argument_list|(
name|df
argument_list|,
name|DF_REF_BB
argument_list|(
name|ref
argument_list|)
argument_list|,
name|DF_REF_INSN
argument_list|(
name|ref
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|struct
name|ref
modifier|*
name|df_bb_def_use_swap
parameter_list|(
name|df
parameter_list|,
name|bb
parameter_list|,
name|def_insn
parameter_list|,
name|use_insn
parameter_list|,
name|regno
parameter_list|)
name|struct
name|df
modifier|*
name|df
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|rtx
name|def_insn
decl_stmt|;
name|rtx
name|use_insn
decl_stmt|;
name|unsigned
name|int
name|regno
decl_stmt|;
block|{
name|struct
name|ref
modifier|*
name|def
decl_stmt|;
name|struct
name|ref
modifier|*
name|use
decl_stmt|;
name|int
name|def_uid
decl_stmt|;
name|int
name|use_uid
decl_stmt|;
name|struct
name|df_link
modifier|*
name|link
decl_stmt|;
name|def
operator|=
name|df_bb_insn_regno_first_def_find
argument_list|(
name|df
argument_list|,
name|bb
argument_list|,
name|def_insn
argument_list|,
name|regno
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|def
condition|)
return|return
literal|0
return|;
name|use
operator|=
name|df_bb_insn_regno_last_use_find
argument_list|(
name|df
argument_list|,
name|bb
argument_list|,
name|use_insn
argument_list|,
name|regno
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|use
condition|)
return|return
literal|0
return|;
comment|/* The USE no longer exists.  */
name|use_uid
operator|=
name|INSN_UID
argument_list|(
name|use_insn
argument_list|)
expr_stmt|;
name|df_use_unlink
argument_list|(
name|df
argument_list|,
name|use
argument_list|)
expr_stmt|;
name|df_ref_unlink
argument_list|(
operator|&
name|df
operator|->
name|insns
index|[
name|use_uid
index|]
operator|.
name|uses
argument_list|,
name|use
argument_list|)
expr_stmt|;
comment|/* The DEF requires shifting so remove it from DEF_INSN      and add it to USE_INSN by reusing LINK.  */
name|def_uid
operator|=
name|INSN_UID
argument_list|(
name|def_insn
argument_list|)
expr_stmt|;
name|link
operator|=
name|df_ref_unlink
argument_list|(
operator|&
name|df
operator|->
name|insns
index|[
name|def_uid
index|]
operator|.
name|defs
argument_list|,
name|def
argument_list|)
expr_stmt|;
name|link
operator|->
name|ref
operator|=
name|def
expr_stmt|;
name|link
operator|->
name|next
operator|=
name|df
operator|->
name|insns
index|[
name|use_uid
index|]
operator|.
name|defs
expr_stmt|;
name|df
operator|->
name|insns
index|[
name|use_uid
index|]
operator|.
name|defs
operator|=
name|link
expr_stmt|;
if|#
directive|if
literal|0
block|link = df_ref_unlink (&df->regs[regno].defs, def);   link->ref = def;   link->next = df->regs[regno].defs;   df->insns[regno].defs = link;
endif|#
directive|endif
name|DF_REF_INSN
argument_list|(
name|def
argument_list|)
operator|=
name|use_insn
expr_stmt|;
return|return
name|def
return|;
block|}
end_function

begin_comment
comment|/* Record df between FIRST_INSN and LAST_INSN inclusive.  All new    insns must be processed by this routine.  */
end_comment

begin_function
specifier|static
name|void
name|df_insns_modify
parameter_list|(
name|df
parameter_list|,
name|bb
parameter_list|,
name|first_insn
parameter_list|,
name|last_insn
parameter_list|)
name|struct
name|df
modifier|*
name|df
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|rtx
name|first_insn
decl_stmt|;
name|rtx
name|last_insn
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|first_insn
init|;
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|unsigned
name|int
name|uid
decl_stmt|;
comment|/* A non-const call should not have slipped through the net.  If 	 it does, we need to create a new basic block.  Ouch.  The 	 same applies for a label.  */
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
operator|&&
operator|!
name|CONST_OR_PURE_CALL_P
argument_list|(
name|insn
argument_list|)
operator|)
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|uid
operator|=
name|INSN_UID
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|uid
operator|>=
name|df
operator|->
name|insn_size
condition|)
name|df_insn_table_realloc
argument_list|(
name|df
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|df_insn_modify
argument_list|(
name|df
argument_list|,
name|bb
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|==
name|last_insn
condition|)
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Emit PATTERN before INSN within BB.  */
end_comment

begin_function
name|rtx
name|df_pattern_emit_before
parameter_list|(
name|df
parameter_list|,
name|pattern
parameter_list|,
name|bb
parameter_list|,
name|insn
parameter_list|)
name|struct
name|df
modifier|*
name|df
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|rtx
name|pattern
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
name|rtx
name|ret_insn
decl_stmt|;
name|rtx
name|prev_insn
init|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
comment|/* We should not be inserting before the start of the block.  */
if|if
condition|(
name|insn
operator|==
name|bb
operator|->
name|head
condition|)
name|abort
argument_list|()
expr_stmt|;
name|ret_insn
operator|=
name|emit_insn_before
argument_list|(
name|pattern
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_insn
operator|==
name|insn
condition|)
return|return
name|ret_insn
return|;
name|df_insns_modify
argument_list|(
name|df
argument_list|,
name|bb
argument_list|,
name|NEXT_INSN
argument_list|(
name|prev_insn
argument_list|)
argument_list|,
name|ret_insn
argument_list|)
expr_stmt|;
return|return
name|ret_insn
return|;
block|}
end_function

begin_comment
comment|/* Emit PATTERN after INSN within BB.  */
end_comment

begin_function
name|rtx
name|df_pattern_emit_after
parameter_list|(
name|df
parameter_list|,
name|pattern
parameter_list|,
name|bb
parameter_list|,
name|insn
parameter_list|)
name|struct
name|df
modifier|*
name|df
decl_stmt|;
name|rtx
name|pattern
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
name|rtx
name|ret_insn
decl_stmt|;
name|ret_insn
operator|=
name|emit_insn_after
argument_list|(
name|pattern
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_insn
operator|==
name|insn
condition|)
return|return
name|ret_insn
return|;
name|df_insns_modify
argument_list|(
name|df
argument_list|,
name|bb
argument_list|,
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|ret_insn
argument_list|)
expr_stmt|;
return|return
name|ret_insn
return|;
block|}
end_function

begin_comment
comment|/* Emit jump PATTERN after INSN within BB.  */
end_comment

begin_function
name|rtx
name|df_jump_pattern_emit_after
parameter_list|(
name|df
parameter_list|,
name|pattern
parameter_list|,
name|bb
parameter_list|,
name|insn
parameter_list|)
name|struct
name|df
modifier|*
name|df
decl_stmt|;
name|rtx
name|pattern
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
name|rtx
name|ret_insn
decl_stmt|;
name|ret_insn
operator|=
name|emit_jump_insn_after
argument_list|(
name|pattern
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_insn
operator|==
name|insn
condition|)
return|return
name|ret_insn
return|;
name|df_insns_modify
argument_list|(
name|df
argument_list|,
name|bb
argument_list|,
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|ret_insn
argument_list|)
expr_stmt|;
return|return
name|ret_insn
return|;
block|}
end_function

begin_comment
comment|/* Move INSN within BB before BEFORE_INSN within BEFORE_BB.     This function should only be used to move loop invariant insns    out of a loop where it has been proven that the def-use info    will still be valid.  */
end_comment

begin_function
name|rtx
name|df_insn_move_before
parameter_list|(
name|df
parameter_list|,
name|bb
parameter_list|,
name|insn
parameter_list|,
name|before_bb
parameter_list|,
name|before_insn
parameter_list|)
name|struct
name|df
modifier|*
name|df
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|basic_block
name|before_bb
decl_stmt|;
name|rtx
name|before_insn
decl_stmt|;
block|{
name|struct
name|df_link
modifier|*
name|link
decl_stmt|;
name|unsigned
name|int
name|uid
decl_stmt|;
if|if
condition|(
operator|!
name|bb
condition|)
return|return
name|df_pattern_emit_before
argument_list|(
name|df
argument_list|,
name|insn
argument_list|,
name|before_bb
argument_list|,
name|before_insn
argument_list|)
return|;
name|uid
operator|=
name|INSN_UID
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Change bb for all df defined and used by this insn.  */
for|for
control|(
name|link
operator|=
name|df
operator|->
name|insns
index|[
name|uid
index|]
operator|.
name|defs
init|;
name|link
condition|;
name|link
operator|=
name|link
operator|->
name|next
control|)
name|DF_REF_BB
argument_list|(
name|link
operator|->
name|ref
argument_list|)
operator|=
name|before_bb
expr_stmt|;
for|for
control|(
name|link
operator|=
name|df
operator|->
name|insns
index|[
name|uid
index|]
operator|.
name|uses
init|;
name|link
condition|;
name|link
operator|=
name|link
operator|->
name|next
control|)
name|DF_REF_BB
argument_list|(
name|link
operator|->
name|ref
argument_list|)
operator|=
name|before_bb
expr_stmt|;
comment|/* The lifetimes of the registers used in this insn will be reduced      while the lifetimes of the registers defined in this insn      are likely to be increased.  */
comment|/* ???? Perhaps all the insns moved should be stored on a list      which df_analyse removes when it recalculates data flow.  */
return|return
name|emit_insn_before
argument_list|(
name|insn
argument_list|,
name|before_insn
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Functions to query dataflow information.  */
end_comment

begin_function
name|int
name|df_insn_regno_def_p
parameter_list|(
name|df
parameter_list|,
name|bb
parameter_list|,
name|insn
parameter_list|,
name|regno
parameter_list|)
name|struct
name|df
modifier|*
name|df
decl_stmt|;
name|basic_block
name|bb
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|unsigned
name|int
name|regno
decl_stmt|;
block|{
name|unsigned
name|int
name|uid
decl_stmt|;
name|struct
name|df_link
modifier|*
name|link
decl_stmt|;
name|uid
operator|=
name|INSN_UID
argument_list|(
name|insn
argument_list|)
expr_stmt|;
for|for
control|(
name|link
operator|=
name|df
operator|->
name|insns
index|[
name|uid
index|]
operator|.
name|defs
init|;
name|link
condition|;
name|link
operator|=
name|link
operator|->
name|next
control|)
block|{
name|struct
name|ref
modifier|*
name|def
init|=
name|link
operator|->
name|ref
decl_stmt|;
if|if
condition|(
name|DF_REF_REGNO
argument_list|(
name|def
argument_list|)
operator|==
name|regno
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|df_def_dominates_all_uses_p
parameter_list|(
name|df
parameter_list|,
name|def
parameter_list|)
name|struct
name|df
modifier|*
name|df
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|ref
modifier|*
name|def
decl_stmt|;
block|{
name|struct
name|df_link
modifier|*
name|du_link
decl_stmt|;
comment|/* Follow def-use chain to find all the uses of this def.  */
for|for
control|(
name|du_link
operator|=
name|DF_REF_CHAIN
argument_list|(
name|def
argument_list|)
init|;
name|du_link
condition|;
name|du_link
operator|=
name|du_link
operator|->
name|next
control|)
block|{
name|struct
name|ref
modifier|*
name|use
init|=
name|du_link
operator|->
name|ref
decl_stmt|;
name|struct
name|df_link
modifier|*
name|ud_link
decl_stmt|;
comment|/* Follow use-def chain to check all the defs for this use.  */
for|for
control|(
name|ud_link
operator|=
name|DF_REF_CHAIN
argument_list|(
name|use
argument_list|)
init|;
name|ud_link
condition|;
name|ud_link
operator|=
name|ud_link
operator|->
name|next
control|)
if|if
condition|(
name|ud_link
operator|->
name|ref
operator|!=
name|def
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|df_insn_dominates_all_uses_p
parameter_list|(
name|df
parameter_list|,
name|bb
parameter_list|,
name|insn
parameter_list|)
name|struct
name|df
modifier|*
name|df
decl_stmt|;
name|basic_block
name|bb
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
name|unsigned
name|int
name|uid
decl_stmt|;
name|struct
name|df_link
modifier|*
name|link
decl_stmt|;
name|uid
operator|=
name|INSN_UID
argument_list|(
name|insn
argument_list|)
expr_stmt|;
for|for
control|(
name|link
operator|=
name|df
operator|->
name|insns
index|[
name|uid
index|]
operator|.
name|defs
init|;
name|link
condition|;
name|link
operator|=
name|link
operator|->
name|next
control|)
block|{
name|struct
name|ref
modifier|*
name|def
init|=
name|link
operator|->
name|ref
decl_stmt|;
if|if
condition|(
operator|!
name|df_def_dominates_all_uses_p
argument_list|(
name|df
argument_list|,
name|def
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return non-zero if all DF dominates all the uses within the bitmap    BLOCKS.  */
end_comment

begin_function
specifier|static
name|int
name|df_def_dominates_uses_p
parameter_list|(
name|df
parameter_list|,
name|def
parameter_list|,
name|blocks
parameter_list|)
name|struct
name|df
modifier|*
name|df
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|ref
modifier|*
name|def
decl_stmt|;
name|bitmap
name|blocks
decl_stmt|;
block|{
name|struct
name|df_link
modifier|*
name|du_link
decl_stmt|;
comment|/* Follow def-use chain to find all the uses of this def.  */
for|for
control|(
name|du_link
operator|=
name|DF_REF_CHAIN
argument_list|(
name|def
argument_list|)
init|;
name|du_link
condition|;
name|du_link
operator|=
name|du_link
operator|->
name|next
control|)
block|{
name|struct
name|ref
modifier|*
name|use
init|=
name|du_link
operator|->
name|ref
decl_stmt|;
name|struct
name|df_link
modifier|*
name|ud_link
decl_stmt|;
comment|/* Only worry about the uses within BLOCKS.  For example,       consider a register defined within a loop that is live at the       loop exits.  */
if|if
condition|(
name|bitmap_bit_p
argument_list|(
name|blocks
argument_list|,
name|DF_REF_BBNO
argument_list|(
name|use
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Follow use-def chain to check all the defs for this use.  */
for|for
control|(
name|ud_link
operator|=
name|DF_REF_CHAIN
argument_list|(
name|use
argument_list|)
init|;
name|ud_link
condition|;
name|ud_link
operator|=
name|ud_link
operator|->
name|next
control|)
if|if
condition|(
name|ud_link
operator|->
name|ref
operator|!=
name|def
condition|)
return|return
literal|0
return|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return non-zero if all the defs of INSN within BB dominates    all the corresponding uses.  */
end_comment

begin_function
name|int
name|df_insn_dominates_uses_p
parameter_list|(
name|df
parameter_list|,
name|bb
parameter_list|,
name|insn
parameter_list|,
name|blocks
parameter_list|)
name|struct
name|df
modifier|*
name|df
decl_stmt|;
name|basic_block
name|bb
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|bitmap
name|blocks
decl_stmt|;
block|{
name|unsigned
name|int
name|uid
decl_stmt|;
name|struct
name|df_link
modifier|*
name|link
decl_stmt|;
name|uid
operator|=
name|INSN_UID
argument_list|(
name|insn
argument_list|)
expr_stmt|;
for|for
control|(
name|link
operator|=
name|df
operator|->
name|insns
index|[
name|uid
index|]
operator|.
name|defs
init|;
name|link
condition|;
name|link
operator|=
name|link
operator|->
name|next
control|)
block|{
name|struct
name|ref
modifier|*
name|def
init|=
name|link
operator|->
name|ref
decl_stmt|;
comment|/* Only consider the defs within BLOCKS.  */
if|if
condition|(
name|bitmap_bit_p
argument_list|(
name|blocks
argument_list|,
name|DF_REF_BBNO
argument_list|(
name|def
argument_list|)
argument_list|)
operator|&&
operator|!
name|df_def_dominates_uses_p
argument_list|(
name|df
argument_list|,
name|def
argument_list|,
name|blocks
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return the basic block that REG referenced in or NULL if referenced    in multiple basic blocks.  */
end_comment

begin_function
name|basic_block
name|df_regno_bb
parameter_list|(
name|df
parameter_list|,
name|regno
parameter_list|)
name|struct
name|df
modifier|*
name|df
decl_stmt|;
name|unsigned
name|int
name|regno
decl_stmt|;
block|{
name|struct
name|df_link
modifier|*
name|defs
init|=
name|df
operator|->
name|regs
index|[
name|regno
index|]
operator|.
name|defs
decl_stmt|;
name|struct
name|df_link
modifier|*
name|uses
init|=
name|df
operator|->
name|regs
index|[
name|regno
index|]
operator|.
name|uses
decl_stmt|;
name|struct
name|ref
modifier|*
name|def
init|=
name|defs
condition|?
name|defs
operator|->
name|ref
else|:
literal|0
decl_stmt|;
name|struct
name|ref
modifier|*
name|use
init|=
name|uses
condition|?
name|uses
operator|->
name|ref
else|:
literal|0
decl_stmt|;
name|basic_block
name|bb_def
init|=
name|def
condition|?
name|DF_REF_BB
argument_list|(
name|def
argument_list|)
else|:
literal|0
decl_stmt|;
name|basic_block
name|bb_use
init|=
name|use
condition|?
name|DF_REF_BB
argument_list|(
name|use
argument_list|)
else|:
literal|0
decl_stmt|;
comment|/* Compare blocks of first def and last use.  ???? FIXME.  What if      the reg-def and reg-use lists are not correctly ordered.  */
return|return
name|bb_def
operator|==
name|bb_use
condition|?
name|bb_def
else|:
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return non-zero if REG used in multiple basic blocks.  */
end_comment

begin_function
name|int
name|df_reg_global_p
parameter_list|(
name|df
parameter_list|,
name|reg
parameter_list|)
name|struct
name|df
modifier|*
name|df
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
block|{
return|return
name|df_regno_bb
argument_list|(
name|df
argument_list|,
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|)
operator|!=
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return total lifetime (in insns) of REG.  */
end_comment

begin_function
name|int
name|df_reg_lifetime
parameter_list|(
name|df
parameter_list|,
name|reg
parameter_list|)
name|struct
name|df
modifier|*
name|df
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
block|{
return|return
name|df
operator|->
name|regs
index|[
name|REGNO
argument_list|(
name|reg
argument_list|)
index|]
operator|.
name|lifetime
return|;
block|}
end_function

begin_comment
comment|/* Return non-zero if REG live at start of BB.  */
end_comment

begin_function
name|int
name|df_bb_reg_live_start_p
parameter_list|(
name|df
parameter_list|,
name|bb
parameter_list|,
name|reg
parameter_list|)
name|struct
name|df
modifier|*
name|df
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
block|{
name|struct
name|bb_info
modifier|*
name|bb_info
init|=
name|DF_BB_INFO
argument_list|(
name|df
argument_list|,
name|bb
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
if|if
condition|(
operator|!
name|bb_info
operator|->
name|lr_in
condition|)
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
return|return
name|bitmap_bit_p
argument_list|(
name|bb_info
operator|->
name|lr_in
argument_list|,
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return non-zero if REG live at end of BB.  */
end_comment

begin_function
name|int
name|df_bb_reg_live_end_p
parameter_list|(
name|df
parameter_list|,
name|bb
parameter_list|,
name|reg
parameter_list|)
name|struct
name|df
modifier|*
name|df
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
block|{
name|struct
name|bb_info
modifier|*
name|bb_info
init|=
name|DF_BB_INFO
argument_list|(
name|df
argument_list|,
name|bb
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
if|if
condition|(
operator|!
name|bb_info
operator|->
name|lr_in
condition|)
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
return|return
name|bitmap_bit_p
argument_list|(
name|bb_info
operator|->
name|lr_out
argument_list|,
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return -1 if life of REG1 before life of REG2, 1 if life of REG1    after life of REG2, or 0, if the lives overlap.  */
end_comment

begin_function
name|int
name|df_bb_regs_lives_compare
parameter_list|(
name|df
parameter_list|,
name|bb
parameter_list|,
name|reg1
parameter_list|,
name|reg2
parameter_list|)
name|struct
name|df
modifier|*
name|df
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|rtx
name|reg1
decl_stmt|;
name|rtx
name|reg2
decl_stmt|;
block|{
name|unsigned
name|int
name|regno1
init|=
name|REGNO
argument_list|(
name|reg1
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|regno2
init|=
name|REGNO
argument_list|(
name|reg2
argument_list|)
decl_stmt|;
name|struct
name|ref
modifier|*
name|def1
decl_stmt|;
name|struct
name|ref
modifier|*
name|use1
decl_stmt|;
name|struct
name|ref
modifier|*
name|def2
decl_stmt|;
name|struct
name|ref
modifier|*
name|use2
decl_stmt|;
comment|/* The regs must be local to BB.  */
if|if
condition|(
name|df_regno_bb
argument_list|(
name|df
argument_list|,
name|regno1
argument_list|)
operator|!=
name|bb
operator|||
name|df_regno_bb
argument_list|(
name|df
argument_list|,
name|regno2
argument_list|)
operator|!=
name|bb
condition|)
name|abort
argument_list|()
expr_stmt|;
name|def2
operator|=
name|df_bb_regno_first_def_find
argument_list|(
name|df
argument_list|,
name|bb
argument_list|,
name|regno2
argument_list|)
expr_stmt|;
name|use1
operator|=
name|df_bb_regno_last_use_find
argument_list|(
name|df
argument_list|,
name|bb
argument_list|,
name|regno1
argument_list|)
expr_stmt|;
if|if
condition|(
name|DF_INSN_LUID
argument_list|(
name|df
argument_list|,
name|DF_REF_INSN
argument_list|(
name|def2
argument_list|)
argument_list|)
operator|>
name|DF_INSN_LUID
argument_list|(
name|df
argument_list|,
name|DF_REF_INSN
argument_list|(
name|use1
argument_list|)
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|def1
operator|=
name|df_bb_regno_first_def_find
argument_list|(
name|df
argument_list|,
name|bb
argument_list|,
name|regno1
argument_list|)
expr_stmt|;
name|use2
operator|=
name|df_bb_regno_last_use_find
argument_list|(
name|df
argument_list|,
name|bb
argument_list|,
name|regno2
argument_list|)
expr_stmt|;
if|if
condition|(
name|DF_INSN_LUID
argument_list|(
name|df
argument_list|,
name|DF_REF_INSN
argument_list|(
name|def1
argument_list|)
argument_list|)
operator|>
name|DF_INSN_LUID
argument_list|(
name|df
argument_list|,
name|DF_REF_INSN
argument_list|(
name|use2
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return last use of REGNO within BB.  */
end_comment

begin_function
specifier|static
name|struct
name|ref
modifier|*
name|df_bb_regno_last_use_find
parameter_list|(
name|df
parameter_list|,
name|bb
parameter_list|,
name|regno
parameter_list|)
name|struct
name|df
modifier|*
name|df
decl_stmt|;
name|basic_block
name|bb
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|unsigned
name|int
name|regno
decl_stmt|;
block|{
name|struct
name|df_link
modifier|*
name|link
decl_stmt|;
comment|/* This assumes that the reg-use list is ordered such that for any      BB, the last use is found first.  However, since the BBs are not      ordered, the first use in the chain is not necessarily the last      use in the function.  */
for|for
control|(
name|link
operator|=
name|df
operator|->
name|regs
index|[
name|regno
index|]
operator|.
name|uses
init|;
name|link
condition|;
name|link
operator|=
name|link
operator|->
name|next
control|)
block|{
name|struct
name|ref
modifier|*
name|use
init|=
name|link
operator|->
name|ref
decl_stmt|;
if|if
condition|(
name|DF_REF_BB
argument_list|(
name|use
argument_list|)
operator|==
name|bb
condition|)
return|return
name|use
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return first def of REGNO within BB.  */
end_comment

begin_function
specifier|static
name|struct
name|ref
modifier|*
name|df_bb_regno_first_def_find
parameter_list|(
name|df
parameter_list|,
name|bb
parameter_list|,
name|regno
parameter_list|)
name|struct
name|df
modifier|*
name|df
decl_stmt|;
name|basic_block
name|bb
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|unsigned
name|int
name|regno
decl_stmt|;
block|{
name|struct
name|df_link
modifier|*
name|link
decl_stmt|;
comment|/* This assumes that the reg-def list is ordered such that for any      BB, the first def is found first.  However, since the BBs are not      ordered, the first def in the chain is not necessarily the first      def in the function.  */
for|for
control|(
name|link
operator|=
name|df
operator|->
name|regs
index|[
name|regno
index|]
operator|.
name|defs
init|;
name|link
condition|;
name|link
operator|=
name|link
operator|->
name|next
control|)
block|{
name|struct
name|ref
modifier|*
name|def
init|=
name|link
operator|->
name|ref
decl_stmt|;
if|if
condition|(
name|DF_REF_BB
argument_list|(
name|def
argument_list|)
operator|==
name|bb
condition|)
return|return
name|def
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return first use of REGNO inside INSN within BB.  */
end_comment

begin_function
specifier|static
name|struct
name|ref
modifier|*
name|df_bb_insn_regno_last_use_find
parameter_list|(
name|df
parameter_list|,
name|bb
parameter_list|,
name|insn
parameter_list|,
name|regno
parameter_list|)
name|struct
name|df
modifier|*
name|df
decl_stmt|;
name|basic_block
name|bb
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|unsigned
name|int
name|regno
decl_stmt|;
block|{
name|unsigned
name|int
name|uid
decl_stmt|;
name|struct
name|df_link
modifier|*
name|link
decl_stmt|;
name|uid
operator|=
name|INSN_UID
argument_list|(
name|insn
argument_list|)
expr_stmt|;
for|for
control|(
name|link
operator|=
name|df
operator|->
name|insns
index|[
name|uid
index|]
operator|.
name|uses
init|;
name|link
condition|;
name|link
operator|=
name|link
operator|->
name|next
control|)
block|{
name|struct
name|ref
modifier|*
name|use
init|=
name|link
operator|->
name|ref
decl_stmt|;
if|if
condition|(
name|DF_REF_REGNO
argument_list|(
name|use
argument_list|)
operator|==
name|regno
condition|)
return|return
name|use
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return first def of REGNO inside INSN within BB.  */
end_comment

begin_function
specifier|static
name|struct
name|ref
modifier|*
name|df_bb_insn_regno_first_def_find
parameter_list|(
name|df
parameter_list|,
name|bb
parameter_list|,
name|insn
parameter_list|,
name|regno
parameter_list|)
name|struct
name|df
modifier|*
name|df
decl_stmt|;
name|basic_block
name|bb
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|unsigned
name|int
name|regno
decl_stmt|;
block|{
name|unsigned
name|int
name|uid
decl_stmt|;
name|struct
name|df_link
modifier|*
name|link
decl_stmt|;
name|uid
operator|=
name|INSN_UID
argument_list|(
name|insn
argument_list|)
expr_stmt|;
for|for
control|(
name|link
operator|=
name|df
operator|->
name|insns
index|[
name|uid
index|]
operator|.
name|defs
init|;
name|link
condition|;
name|link
operator|=
name|link
operator|->
name|next
control|)
block|{
name|struct
name|ref
modifier|*
name|def
init|=
name|link
operator|->
name|ref
decl_stmt|;
if|if
condition|(
name|DF_REF_REGNO
argument_list|(
name|def
argument_list|)
operator|==
name|regno
condition|)
return|return
name|def
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return insn using REG if the BB contains only a single    use and def of REG.  */
end_comment

begin_function
name|rtx
name|df_bb_single_def_use_insn_find
parameter_list|(
name|df
parameter_list|,
name|bb
parameter_list|,
name|insn
parameter_list|,
name|reg
parameter_list|)
name|struct
name|df
modifier|*
name|df
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
block|{
name|struct
name|ref
modifier|*
name|def
decl_stmt|;
name|struct
name|ref
modifier|*
name|use
decl_stmt|;
name|struct
name|df_link
modifier|*
name|du_link
decl_stmt|;
name|def
operator|=
name|df_bb_insn_regno_first_def_find
argument_list|(
name|df
argument_list|,
name|bb
argument_list|,
name|insn
argument_list|,
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|def
condition|)
name|abort
argument_list|()
expr_stmt|;
name|du_link
operator|=
name|DF_REF_CHAIN
argument_list|(
name|def
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|du_link
condition|)
return|return
name|NULL_RTX
return|;
name|use
operator|=
name|du_link
operator|->
name|ref
expr_stmt|;
comment|/* Check if def is dead.  */
if|if
condition|(
operator|!
name|use
condition|)
return|return
name|NULL_RTX
return|;
comment|/* Check for multiple uses.  */
if|if
condition|(
name|du_link
operator|->
name|next
condition|)
return|return
name|NULL_RTX
return|;
return|return
name|DF_REF_INSN
argument_list|(
name|use
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Functions for debugging/dumping dataflow information.  */
end_comment

begin_comment
comment|/* Dump a def-use or use-def chain for REF to FILE.  */
end_comment

begin_function
specifier|static
name|void
name|df_chain_dump
parameter_list|(
name|link
parameter_list|,
name|file
parameter_list|)
name|struct
name|df_link
modifier|*
name|link
decl_stmt|;
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"{ "
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|link
condition|;
name|link
operator|=
name|link
operator|->
name|next
control|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%c%d "
argument_list|,
name|DF_REF_REG_DEF_P
argument_list|(
name|link
operator|->
name|ref
argument_list|)
condition|?
literal|'d'
else|:
literal|'u'
argument_list|,
name|DF_REF_ID
argument_list|(
name|link
operator|->
name|ref
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"}"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|df_chain_dump_regno
parameter_list|(
name|link
parameter_list|,
name|file
parameter_list|)
name|struct
name|df_link
modifier|*
name|link
decl_stmt|;
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"{ "
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|link
condition|;
name|link
operator|=
name|link
operator|->
name|next
control|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%c%d(%d) "
argument_list|,
name|DF_REF_REG_DEF_P
argument_list|(
name|link
operator|->
name|ref
argument_list|)
condition|?
literal|'d'
else|:
literal|'u'
argument_list|,
name|DF_REF_ID
argument_list|(
name|link
operator|->
name|ref
argument_list|)
argument_list|,
name|DF_REF_REGNO
argument_list|(
name|link
operator|->
name|ref
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"}"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dump dataflow info.  */
end_comment

begin_function
name|void
name|df_dump
parameter_list|(
name|df
parameter_list|,
name|flags
parameter_list|,
name|file
parameter_list|)
name|struct
name|df
modifier|*
name|df
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|j
decl_stmt|;
if|if
condition|(
operator|!
name|df
operator|||
operator|!
name|file
condition|)
return|return;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\nDataflow summary:\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"n_regs = %d, n_defs = %d, n_uses = %d, n_bbs = %d\n"
argument_list|,
name|df
operator|->
name|n_regs
argument_list|,
name|df
operator|->
name|n_defs
argument_list|,
name|df
operator|->
name|n_uses
argument_list|,
name|df
operator|->
name|n_bbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|DF_RD
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"Reaching defs:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|df
operator|->
name|n_bbs
condition|;
name|i
operator|++
control|)
block|{
name|basic_block
name|bb
init|=
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|struct
name|bb_info
modifier|*
name|bb_info
init|=
name|DF_BB_INFO
argument_list|(
name|df
argument_list|,
name|bb
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|bb_info
operator|->
name|rd_in
condition|)
continue|continue;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"bb %d in  \t"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|dump_bitmap
argument_list|(
name|file
argument_list|,
name|bb_info
operator|->
name|rd_in
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"bb %d gen \t"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|dump_bitmap
argument_list|(
name|file
argument_list|,
name|bb_info
operator|->
name|rd_gen
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"bb %d kill\t"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|dump_bitmap
argument_list|(
name|file
argument_list|,
name|bb_info
operator|->
name|rd_kill
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"bb %d out \t"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|dump_bitmap
argument_list|(
name|file
argument_list|,
name|bb_info
operator|->
name|rd_out
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|flags
operator|&
name|DF_UD_CHAIN
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"Use-def chains:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|df
operator|->
name|n_defs
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|df
operator|->
name|defs
index|[
name|j
index|]
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"d%d bb %d luid %d insn %d reg %d "
argument_list|,
name|j
argument_list|,
name|DF_REF_BBNO
argument_list|(
name|df
operator|->
name|defs
index|[
name|j
index|]
argument_list|)
argument_list|,
name|DF_INSN_LUID
argument_list|(
name|df
argument_list|,
name|DF_REF_INSN
argument_list|(
name|df
operator|->
name|defs
index|[
name|j
index|]
argument_list|)
argument_list|)
argument_list|,
name|DF_REF_INSN_UID
argument_list|(
name|df
operator|->
name|defs
index|[
name|j
index|]
argument_list|)
argument_list|,
name|DF_REF_REGNO
argument_list|(
name|df
operator|->
name|defs
index|[
name|j
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|df
operator|->
name|defs
index|[
name|j
index|]
operator|->
name|flags
operator|&
name|DF_REF_READ_WRITE
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"read/write "
argument_list|)
expr_stmt|;
name|df_chain_dump
argument_list|(
name|DF_REF_CHAIN
argument_list|(
name|df
operator|->
name|defs
index|[
name|j
index|]
argument_list|)
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|flags
operator|&
name|DF_RU
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"Reaching uses:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|df
operator|->
name|n_bbs
condition|;
name|i
operator|++
control|)
block|{
name|basic_block
name|bb
init|=
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|struct
name|bb_info
modifier|*
name|bb_info
init|=
name|DF_BB_INFO
argument_list|(
name|df
argument_list|,
name|bb
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|bb_info
operator|->
name|ru_in
condition|)
continue|continue;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"bb %d in  \t"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|dump_bitmap
argument_list|(
name|file
argument_list|,
name|bb_info
operator|->
name|ru_in
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"bb %d gen \t"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|dump_bitmap
argument_list|(
name|file
argument_list|,
name|bb_info
operator|->
name|ru_gen
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"bb %d kill\t"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|dump_bitmap
argument_list|(
name|file
argument_list|,
name|bb_info
operator|->
name|ru_kill
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"bb %d out \t"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|dump_bitmap
argument_list|(
name|file
argument_list|,
name|bb_info
operator|->
name|ru_out
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|flags
operator|&
name|DF_DU_CHAIN
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"Def-use chains:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|df
operator|->
name|n_uses
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|df
operator|->
name|uses
index|[
name|j
index|]
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"u%d bb %d luid %d insn %d reg %d "
argument_list|,
name|j
argument_list|,
name|DF_REF_BBNO
argument_list|(
name|df
operator|->
name|uses
index|[
name|j
index|]
argument_list|)
argument_list|,
name|DF_INSN_LUID
argument_list|(
name|df
argument_list|,
name|DF_REF_INSN
argument_list|(
name|df
operator|->
name|uses
index|[
name|j
index|]
argument_list|)
argument_list|)
argument_list|,
name|DF_REF_INSN_UID
argument_list|(
name|df
operator|->
name|uses
index|[
name|j
index|]
argument_list|)
argument_list|,
name|DF_REF_REGNO
argument_list|(
name|df
operator|->
name|uses
index|[
name|j
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|df
operator|->
name|uses
index|[
name|j
index|]
operator|->
name|flags
operator|&
name|DF_REF_READ_WRITE
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"read/write "
argument_list|)
expr_stmt|;
name|df_chain_dump
argument_list|(
name|DF_REF_CHAIN
argument_list|(
name|df
operator|->
name|uses
index|[
name|j
index|]
argument_list|)
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|flags
operator|&
name|DF_LR
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"Live regs:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|df
operator|->
name|n_bbs
condition|;
name|i
operator|++
control|)
block|{
name|basic_block
name|bb
init|=
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|struct
name|bb_info
modifier|*
name|bb_info
init|=
name|DF_BB_INFO
argument_list|(
name|df
argument_list|,
name|bb
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|bb_info
operator|->
name|lr_in
condition|)
continue|continue;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"bb %d in  \t"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|dump_bitmap
argument_list|(
name|file
argument_list|,
name|bb_info
operator|->
name|lr_in
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"bb %d use \t"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|dump_bitmap
argument_list|(
name|file
argument_list|,
name|bb_info
operator|->
name|lr_use
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"bb %d def \t"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|dump_bitmap
argument_list|(
name|file
argument_list|,
name|bb_info
operator|->
name|lr_def
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"bb %d out \t"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|dump_bitmap
argument_list|(
name|file
argument_list|,
name|bb_info
operator|->
name|lr_out
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|flags
operator|&
operator|(
name|DF_REG_INFO
operator||
name|DF_RD_CHAIN
operator||
name|DF_RU_CHAIN
operator|)
condition|)
block|{
name|struct
name|reg_info
modifier|*
name|reg_info
init|=
name|df
operator|->
name|regs
decl_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"Register info:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|df
operator|->
name|n_regs
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|flags
operator|&
name|DF_REG_INFO
operator|)
operator|&&
operator|(
name|reg_info
index|[
name|j
index|]
operator|.
name|n_uses
operator|||
name|reg_info
index|[
name|j
index|]
operator|.
name|n_defs
operator|)
operator|)
operator|||
operator|(
operator|(
name|flags
operator|&
name|DF_RD_CHAIN
operator|)
operator|&&
name|reg_info
index|[
name|j
index|]
operator|.
name|defs
operator|)
operator|||
operator|(
operator|(
name|flags
operator|&
name|DF_RU_CHAIN
operator|)
operator|&&
name|reg_info
index|[
name|j
index|]
operator|.
name|uses
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"reg %d"
argument_list|,
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|DF_RD_CHAIN
operator|)
operator|&&
operator|(
name|flags
operator|&
name|DF_RU_CHAIN
operator|)
condition|)
block|{
name|basic_block
name|bb
init|=
name|df_regno_bb
argument_list|(
name|df
argument_list|,
name|j
argument_list|)
decl_stmt|;
if|if
condition|(
name|bb
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" bb %d"
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" bb ?"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|DF_REG_INFO
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" life %d"
argument_list|,
name|reg_info
index|[
name|j
index|]
operator|.
name|lifetime
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|DF_REG_INFO
operator|)
operator|||
operator|(
name|flags
operator|&
name|DF_RD_CHAIN
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" defs "
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|DF_REG_INFO
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d "
argument_list|,
name|reg_info
index|[
name|j
index|]
operator|.
name|n_defs
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|DF_RD_CHAIN
condition|)
name|df_chain_dump
argument_list|(
name|reg_info
index|[
name|j
index|]
operator|.
name|defs
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|DF_REG_INFO
operator|)
operator|||
operator|(
name|flags
operator|&
name|DF_RU_CHAIN
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" uses "
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|DF_REG_INFO
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d "
argument_list|,
name|reg_info
index|[
name|j
index|]
operator|.
name|n_uses
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|DF_RU_CHAIN
condition|)
name|df_chain_dump
argument_list|(
name|reg_info
index|[
name|j
index|]
operator|.
name|uses
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|df_insn_debug
parameter_list|(
name|df
parameter_list|,
name|insn
parameter_list|,
name|file
parameter_list|)
name|struct
name|df
modifier|*
name|df
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
name|unsigned
name|int
name|uid
decl_stmt|;
name|int
name|bbi
decl_stmt|;
name|uid
operator|=
name|INSN_UID
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|uid
operator|>=
name|df
operator|->
name|insn_size
condition|)
return|return;
if|if
condition|(
name|df
operator|->
name|insns
index|[
name|uid
index|]
operator|.
name|defs
condition|)
name|bbi
operator|=
name|DF_REF_BBNO
argument_list|(
name|df
operator|->
name|insns
index|[
name|uid
index|]
operator|.
name|defs
operator|->
name|ref
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|df
operator|->
name|insns
index|[
name|uid
index|]
operator|.
name|uses
condition|)
name|bbi
operator|=
name|DF_REF_BBNO
argument_list|(
name|df
operator|->
name|insns
index|[
name|uid
index|]
operator|.
name|uses
operator|->
name|ref
argument_list|)
expr_stmt|;
else|else
name|bbi
operator|=
operator|-
literal|1
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"insn %d bb %d luid %d defs "
argument_list|,
name|uid
argument_list|,
name|bbi
argument_list|,
name|DF_INSN_LUID
argument_list|(
name|df
argument_list|,
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|df_chain_dump
argument_list|(
name|df
operator|->
name|insns
index|[
name|uid
index|]
operator|.
name|defs
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" uses "
argument_list|)
expr_stmt|;
name|df_chain_dump
argument_list|(
name|df
operator|->
name|insns
index|[
name|uid
index|]
operator|.
name|uses
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|df_insn_debug_regno
parameter_list|(
name|df
parameter_list|,
name|insn
parameter_list|,
name|file
parameter_list|)
name|struct
name|df
modifier|*
name|df
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
name|unsigned
name|int
name|uid
decl_stmt|;
name|int
name|bbi
decl_stmt|;
name|uid
operator|=
name|INSN_UID
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|uid
operator|>=
name|df
operator|->
name|insn_size
condition|)
return|return;
if|if
condition|(
name|df
operator|->
name|insns
index|[
name|uid
index|]
operator|.
name|defs
condition|)
name|bbi
operator|=
name|DF_REF_BBNO
argument_list|(
name|df
operator|->
name|insns
index|[
name|uid
index|]
operator|.
name|defs
operator|->
name|ref
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|df
operator|->
name|insns
index|[
name|uid
index|]
operator|.
name|uses
condition|)
name|bbi
operator|=
name|DF_REF_BBNO
argument_list|(
name|df
operator|->
name|insns
index|[
name|uid
index|]
operator|.
name|uses
operator|->
name|ref
argument_list|)
expr_stmt|;
else|else
name|bbi
operator|=
operator|-
literal|1
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"insn %d bb %d luid %d defs "
argument_list|,
name|uid
argument_list|,
name|bbi
argument_list|,
name|DF_INSN_LUID
argument_list|(
name|df
argument_list|,
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|df_chain_dump_regno
argument_list|(
name|df
operator|->
name|insns
index|[
name|uid
index|]
operator|.
name|defs
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" uses "
argument_list|)
expr_stmt|;
name|df_chain_dump_regno
argument_list|(
name|df
operator|->
name|insns
index|[
name|uid
index|]
operator|.
name|uses
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|df_regno_debug
parameter_list|(
name|df
parameter_list|,
name|regno
parameter_list|,
name|file
parameter_list|)
name|struct
name|df
modifier|*
name|df
decl_stmt|;
name|unsigned
name|int
name|regno
decl_stmt|;
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
if|if
condition|(
name|regno
operator|>=
name|df
operator|->
name|reg_size
condition|)
return|return;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"reg %d life %d defs "
argument_list|,
name|regno
argument_list|,
name|df
operator|->
name|regs
index|[
name|regno
index|]
operator|.
name|lifetime
argument_list|)
expr_stmt|;
name|df_chain_dump
argument_list|(
name|df
operator|->
name|regs
index|[
name|regno
index|]
operator|.
name|defs
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" uses "
argument_list|)
expr_stmt|;
name|df_chain_dump
argument_list|(
name|df
operator|->
name|regs
index|[
name|regno
index|]
operator|.
name|uses
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|df_ref_debug
parameter_list|(
name|df
parameter_list|,
name|ref
parameter_list|,
name|file
parameter_list|)
name|struct
name|df
modifier|*
name|df
decl_stmt|;
name|struct
name|ref
modifier|*
name|ref
decl_stmt|;
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%c%d "
argument_list|,
name|DF_REF_REG_DEF_P
argument_list|(
name|ref
argument_list|)
condition|?
literal|'d'
else|:
literal|'u'
argument_list|,
name|DF_REF_ID
argument_list|(
name|ref
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"reg %d bb %d luid %d insn %d chain "
argument_list|,
name|DF_REF_REGNO
argument_list|(
name|ref
argument_list|)
argument_list|,
name|DF_REF_BBNO
argument_list|(
name|ref
argument_list|)
argument_list|,
name|DF_INSN_LUID
argument_list|(
name|df
argument_list|,
name|DF_REF_INSN
argument_list|(
name|ref
argument_list|)
argument_list|)
argument_list|,
name|INSN_UID
argument_list|(
name|DF_REF_INSN
argument_list|(
name|ref
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|df_chain_dump
argument_list|(
name|DF_REF_CHAIN
argument_list|(
name|ref
argument_list|)
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|debug_df_insn
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|df_insn_debug
argument_list|(
name|ddf
argument_list|,
name|insn
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|debug_rtx
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|debug_df_reg
parameter_list|(
name|reg
parameter_list|)
name|rtx
name|reg
decl_stmt|;
block|{
name|df_regno_debug
argument_list|(
name|ddf
argument_list|,
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|debug_df_regno
parameter_list|(
name|regno
parameter_list|)
name|unsigned
name|int
name|regno
decl_stmt|;
block|{
name|df_regno_debug
argument_list|(
name|ddf
argument_list|,
name|regno
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|debug_df_ref
parameter_list|(
name|ref
parameter_list|)
name|struct
name|ref
modifier|*
name|ref
decl_stmt|;
block|{
name|df_ref_debug
argument_list|(
name|ddf
argument_list|,
name|ref
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|debug_df_defno
parameter_list|(
name|defno
parameter_list|)
name|unsigned
name|int
name|defno
decl_stmt|;
block|{
name|df_ref_debug
argument_list|(
name|ddf
argument_list|,
name|ddf
operator|->
name|defs
index|[
name|defno
index|]
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|debug_df_useno
parameter_list|(
name|defno
parameter_list|)
name|unsigned
name|int
name|defno
decl_stmt|;
block|{
name|df_ref_debug
argument_list|(
name|ddf
argument_list|,
name|ddf
operator|->
name|uses
index|[
name|defno
index|]
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|debug_df_chain
parameter_list|(
name|link
parameter_list|)
name|struct
name|df_link
modifier|*
name|link
decl_stmt|;
block|{
name|df_chain_dump
argument_list|(
name|link
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Hybrid search algorithm from "Implementation Techniques for    Efficient Data-Flow Analysis of Large Programs".  */
end_comment

begin_function
specifier|static
name|void
name|hybrid_search_bitmap
parameter_list|(
name|block
parameter_list|,
name|in
parameter_list|,
name|out
parameter_list|,
name|gen
parameter_list|,
name|kill
parameter_list|,
name|dir
parameter_list|,
name|conf_op
parameter_list|,
name|transfun
parameter_list|,
name|visited
parameter_list|,
name|pending
parameter_list|,
name|data
parameter_list|)
name|basic_block
name|block
decl_stmt|;
name|bitmap
modifier|*
name|in
decl_stmt|,
decl|*
name|out
decl_stmt|,
modifier|*
name|gen
decl_stmt|,
modifier|*
name|kill
decl_stmt|;
end_function

begin_decl_stmt
name|enum
name|df_flow_dir
name|dir
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|df_confluence_op
name|conf_op
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|transfer_function_bitmap
name|transfun
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|sbitmap
name|visited
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|sbitmap
name|pending
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
modifier|*
name|data
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|changed
decl_stmt|;
name|int
name|i
init|=
name|block
operator|->
name|index
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|basic_block
name|bb
init|=
name|block
decl_stmt|;
name|SET_BIT
argument_list|(
name|visited
argument_list|,
name|block
operator|->
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|TEST_BIT
argument_list|(
name|pending
argument_list|,
name|block
operator|->
name|index
argument_list|)
condition|)
block|{
if|if
condition|(
name|dir
operator|==
name|FORWARD
condition|)
block|{
comment|/*  Calculate<conf_op> of predecessor_outs */
name|bitmap_zero
argument_list|(
name|in
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|pred
init|;
name|e
operator|!=
literal|0
condition|;
name|e
operator|=
name|e
operator|->
name|pred_next
control|)
block|{
if|if
condition|(
name|e
operator|->
name|src
operator|==
name|ENTRY_BLOCK_PTR
condition|)
continue|continue;
switch|switch
condition|(
name|conf_op
condition|)
block|{
case|case
name|UNION
case|:
name|bitmap_a_or_b
argument_list|(
name|in
index|[
name|i
index|]
argument_list|,
name|in
index|[
name|i
index|]
argument_list|,
name|out
index|[
name|e
operator|->
name|src
operator|->
name|index
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|INTERSECTION
case|:
name|bitmap_a_and_b
argument_list|(
name|in
index|[
name|i
index|]
argument_list|,
name|in
index|[
name|i
index|]
argument_list|,
name|out
index|[
name|e
operator|->
name|src
operator|->
name|index
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
else|else
block|{
comment|/* Calculate<conf_op> of successor ins */
name|bitmap_zero
argument_list|(
name|out
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|succ
init|;
name|e
operator|!=
literal|0
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
block|{
if|if
condition|(
name|e
operator|->
name|dest
operator|==
name|EXIT_BLOCK_PTR
condition|)
continue|continue;
switch|switch
condition|(
name|conf_op
condition|)
block|{
case|case
name|UNION
case|:
name|bitmap_a_or_b
argument_list|(
name|out
index|[
name|i
index|]
argument_list|,
name|out
index|[
name|i
index|]
argument_list|,
name|in
index|[
name|e
operator|->
name|dest
operator|->
name|index
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|INTERSECTION
case|:
name|bitmap_a_and_b
argument_list|(
name|out
index|[
name|i
index|]
argument_list|,
name|out
index|[
name|i
index|]
argument_list|,
name|in
index|[
name|e
operator|->
name|dest
operator|->
name|index
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* Common part */
call|(
modifier|*
name|transfun
call|)
argument_list|(
name|i
argument_list|,
operator|&
name|changed
argument_list|,
name|in
index|[
name|i
index|]
argument_list|,
name|out
index|[
name|i
index|]
argument_list|,
name|gen
index|[
name|i
index|]
argument_list|,
name|kill
index|[
name|i
index|]
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|RESET_BIT
argument_list|(
name|pending
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|changed
condition|)
block|{
if|if
condition|(
name|dir
operator|==
name|FORWARD
condition|)
block|{
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|succ
init|;
name|e
operator|!=
literal|0
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
block|{
if|if
condition|(
name|e
operator|->
name|dest
operator|==
name|EXIT_BLOCK_PTR
operator|||
name|e
operator|->
name|dest
operator|->
name|index
operator|==
name|i
condition|)
continue|continue;
name|SET_BIT
argument_list|(
name|pending
argument_list|,
name|e
operator|->
name|dest
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|pred
init|;
name|e
operator|!=
literal|0
condition|;
name|e
operator|=
name|e
operator|->
name|pred_next
control|)
block|{
if|if
condition|(
name|e
operator|->
name|src
operator|==
name|ENTRY_BLOCK_PTR
operator|||
name|e
operator|->
name|dest
operator|->
name|index
operator|==
name|i
condition|)
continue|continue;
name|SET_BIT
argument_list|(
name|pending
argument_list|,
name|e
operator|->
name|src
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|dir
operator|==
name|FORWARD
condition|)
block|{
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|succ
init|;
name|e
operator|!=
literal|0
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
block|{
if|if
condition|(
name|e
operator|->
name|dest
operator|==
name|EXIT_BLOCK_PTR
operator|||
name|e
operator|->
name|dest
operator|->
name|index
operator|==
name|i
condition|)
continue|continue;
if|if
condition|(
operator|!
name|TEST_BIT
argument_list|(
name|visited
argument_list|,
name|e
operator|->
name|dest
operator|->
name|index
argument_list|)
condition|)
name|hybrid_search_bitmap
argument_list|(
name|e
operator|->
name|dest
argument_list|,
name|in
argument_list|,
name|out
argument_list|,
name|gen
argument_list|,
name|kill
argument_list|,
name|dir
argument_list|,
name|conf_op
argument_list|,
name|transfun
argument_list|,
name|visited
argument_list|,
name|pending
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|pred
init|;
name|e
operator|!=
literal|0
condition|;
name|e
operator|=
name|e
operator|->
name|pred_next
control|)
block|{
if|if
condition|(
name|e
operator|->
name|src
operator|==
name|ENTRY_BLOCK_PTR
operator|||
name|e
operator|->
name|src
operator|->
name|index
operator|==
name|i
condition|)
continue|continue;
if|if
condition|(
operator|!
name|TEST_BIT
argument_list|(
name|visited
argument_list|,
name|e
operator|->
name|src
operator|->
name|index
argument_list|)
condition|)
name|hybrid_search_bitmap
argument_list|(
name|e
operator|->
name|src
argument_list|,
name|in
argument_list|,
name|out
argument_list|,
name|gen
argument_list|,
name|kill
argument_list|,
name|dir
argument_list|,
name|conf_op
argument_list|,
name|transfun
argument_list|,
name|visited
argument_list|,
name|pending
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/* Hybrid search for sbitmaps, rather than bitmaps.  */
end_comment

begin_function
specifier|static
name|void
name|hybrid_search_sbitmap
parameter_list|(
name|block
parameter_list|,
name|in
parameter_list|,
name|out
parameter_list|,
name|gen
parameter_list|,
name|kill
parameter_list|,
name|dir
parameter_list|,
name|conf_op
parameter_list|,
name|transfun
parameter_list|,
name|visited
parameter_list|,
name|pending
parameter_list|,
name|data
parameter_list|)
name|basic_block
name|block
decl_stmt|;
name|sbitmap
modifier|*
name|in
decl_stmt|,
decl|*
name|out
decl_stmt|,
modifier|*
name|gen
decl_stmt|,
modifier|*
name|kill
decl_stmt|;
end_function

begin_decl_stmt
name|enum
name|df_flow_dir
name|dir
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|df_confluence_op
name|conf_op
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|transfer_function_sbitmap
name|transfun
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|sbitmap
name|visited
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|sbitmap
name|pending
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
modifier|*
name|data
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|changed
decl_stmt|;
name|int
name|i
init|=
name|block
operator|->
name|index
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|basic_block
name|bb
init|=
name|block
decl_stmt|;
name|SET_BIT
argument_list|(
name|visited
argument_list|,
name|block
operator|->
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|TEST_BIT
argument_list|(
name|pending
argument_list|,
name|block
operator|->
name|index
argument_list|)
condition|)
block|{
if|if
condition|(
name|dir
operator|==
name|FORWARD
condition|)
block|{
comment|/*  Calculate<conf_op> of predecessor_outs */
name|sbitmap_zero
argument_list|(
name|in
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|pred
init|;
name|e
operator|!=
literal|0
condition|;
name|e
operator|=
name|e
operator|->
name|pred_next
control|)
block|{
if|if
condition|(
name|e
operator|->
name|src
operator|==
name|ENTRY_BLOCK_PTR
condition|)
continue|continue;
switch|switch
condition|(
name|conf_op
condition|)
block|{
case|case
name|UNION
case|:
name|sbitmap_a_or_b
argument_list|(
name|in
index|[
name|i
index|]
argument_list|,
name|in
index|[
name|i
index|]
argument_list|,
name|out
index|[
name|e
operator|->
name|src
operator|->
name|index
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|INTERSECTION
case|:
name|sbitmap_a_and_b
argument_list|(
name|in
index|[
name|i
index|]
argument_list|,
name|in
index|[
name|i
index|]
argument_list|,
name|out
index|[
name|e
operator|->
name|src
operator|->
name|index
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
else|else
block|{
comment|/* Calculate<conf_op> of successor ins */
name|sbitmap_zero
argument_list|(
name|out
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|succ
init|;
name|e
operator|!=
literal|0
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
block|{
if|if
condition|(
name|e
operator|->
name|dest
operator|==
name|EXIT_BLOCK_PTR
condition|)
continue|continue;
switch|switch
condition|(
name|conf_op
condition|)
block|{
case|case
name|UNION
case|:
name|sbitmap_a_or_b
argument_list|(
name|out
index|[
name|i
index|]
argument_list|,
name|out
index|[
name|i
index|]
argument_list|,
name|in
index|[
name|e
operator|->
name|dest
operator|->
name|index
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|INTERSECTION
case|:
name|sbitmap_a_and_b
argument_list|(
name|out
index|[
name|i
index|]
argument_list|,
name|out
index|[
name|i
index|]
argument_list|,
name|in
index|[
name|e
operator|->
name|dest
operator|->
name|index
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* Common part */
call|(
modifier|*
name|transfun
call|)
argument_list|(
name|i
argument_list|,
operator|&
name|changed
argument_list|,
name|in
index|[
name|i
index|]
argument_list|,
name|out
index|[
name|i
index|]
argument_list|,
name|gen
index|[
name|i
index|]
argument_list|,
name|kill
index|[
name|i
index|]
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|RESET_BIT
argument_list|(
name|pending
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|changed
condition|)
block|{
if|if
condition|(
name|dir
operator|==
name|FORWARD
condition|)
block|{
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|succ
init|;
name|e
operator|!=
literal|0
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
block|{
if|if
condition|(
name|e
operator|->
name|dest
operator|==
name|EXIT_BLOCK_PTR
operator|||
name|e
operator|->
name|dest
operator|->
name|index
operator|==
name|i
condition|)
continue|continue;
name|SET_BIT
argument_list|(
name|pending
argument_list|,
name|e
operator|->
name|dest
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|pred
init|;
name|e
operator|!=
literal|0
condition|;
name|e
operator|=
name|e
operator|->
name|pred_next
control|)
block|{
if|if
condition|(
name|e
operator|->
name|src
operator|==
name|ENTRY_BLOCK_PTR
operator|||
name|e
operator|->
name|dest
operator|->
name|index
operator|==
name|i
condition|)
continue|continue;
name|SET_BIT
argument_list|(
name|pending
argument_list|,
name|e
operator|->
name|src
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|dir
operator|==
name|FORWARD
condition|)
block|{
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|succ
init|;
name|e
operator|!=
literal|0
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
block|{
if|if
condition|(
name|e
operator|->
name|dest
operator|==
name|EXIT_BLOCK_PTR
operator|||
name|e
operator|->
name|dest
operator|->
name|index
operator|==
name|i
condition|)
continue|continue;
if|if
condition|(
operator|!
name|TEST_BIT
argument_list|(
name|visited
argument_list|,
name|e
operator|->
name|dest
operator|->
name|index
argument_list|)
condition|)
name|hybrid_search_sbitmap
argument_list|(
name|e
operator|->
name|dest
argument_list|,
name|in
argument_list|,
name|out
argument_list|,
name|gen
argument_list|,
name|kill
argument_list|,
name|dir
argument_list|,
name|conf_op
argument_list|,
name|transfun
argument_list|,
name|visited
argument_list|,
name|pending
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|pred
init|;
name|e
operator|!=
literal|0
condition|;
name|e
operator|=
name|e
operator|->
name|pred_next
control|)
block|{
if|if
condition|(
name|e
operator|->
name|src
operator|==
name|ENTRY_BLOCK_PTR
operator|||
name|e
operator|->
name|src
operator|->
name|index
operator|==
name|i
condition|)
continue|continue;
if|if
condition|(
operator|!
name|TEST_BIT
argument_list|(
name|visited
argument_list|,
name|e
operator|->
name|src
operator|->
name|index
argument_list|)
condition|)
name|hybrid_search_sbitmap
argument_list|(
name|e
operator|->
name|src
argument_list|,
name|in
argument_list|,
name|out
argument_list|,
name|gen
argument_list|,
name|kill
argument_list|,
name|dir
argument_list|,
name|conf_op
argument_list|,
name|transfun
argument_list|,
name|visited
argument_list|,
name|pending
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/* gen = GEN set.    kill = KILL set.    in, out = Filled in by function.    blocks = Blocks to analyze.    dir = Dataflow direction.    conf_op = Confluence operation.    transfun = Transfer function.    order = Order to iterate in. (Should map block numbers -> order)    data = Whatever you want.  It's passed to the transfer function.        This function will perform iterative bitvector dataflow, producing    the in and out sets.  Even if you only want to perform it for a    small number of blocks, the vectors for in and out must be large    enough for *all* blocks, because changing one block might affect    others.  However, it'll only put what you say to analyze on the    initial worklist.        For forward problems, you probably want to pass in a mapping of    block number to rc_order (like df->inverse_rc_map). */
end_comment

begin_function
name|void
name|iterative_dataflow_sbitmap
parameter_list|(
name|in
parameter_list|,
name|out
parameter_list|,
name|gen
parameter_list|,
name|kill
parameter_list|,
name|blocks
parameter_list|,
name|dir
parameter_list|,
name|conf_op
parameter_list|,
name|transfun
parameter_list|,
name|order
parameter_list|,
name|data
parameter_list|)
name|sbitmap
modifier|*
name|in
decl_stmt|,
decl|*
name|out
decl_stmt|,
modifier|*
name|gen
decl_stmt|,
modifier|*
name|kill
decl_stmt|;
end_function

begin_decl_stmt
name|bitmap
name|blocks
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|df_flow_dir
name|dir
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|df_confluence_op
name|conf_op
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|transfer_function_sbitmap
name|transfun
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|order
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
modifier|*
name|data
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
name|fibheap_t
name|worklist
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|sbitmap
name|visited
decl_stmt|,
name|pending
decl_stmt|;
name|pending
operator|=
name|sbitmap_alloc
argument_list|(
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|visited
operator|=
name|sbitmap_alloc
argument_list|(
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|pending
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|visited
argument_list|)
expr_stmt|;
name|worklist
operator|=
name|fibheap_new
argument_list|()
expr_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|blocks
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|{     fibheap_insert (worklist, order[i], (void *) (size_t) i);      SET_BIT (pending, i);     if (dir == FORWARD)       sbitmap_copy (out[i], gen[i]);     else       sbitmap_copy (in[i], gen[i]);   }
argument_list|)
empty_stmt|;
while|while
condition|(
name|sbitmap_first_set_bit
argument_list|(
name|pending
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
while|while
condition|(
operator|!
name|fibheap_empty
argument_list|(
name|worklist
argument_list|)
condition|)
block|{
name|i
operator|=
operator|(
name|size_t
operator|)
name|fibheap_extract_min
argument_list|(
name|worklist
argument_list|)
expr_stmt|;
name|bb
operator|=
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TEST_BIT
argument_list|(
name|visited
argument_list|,
name|bb
operator|->
name|index
argument_list|)
condition|)
name|hybrid_search_sbitmap
argument_list|(
name|bb
argument_list|,
name|in
argument_list|,
name|out
argument_list|,
name|gen
argument_list|,
name|kill
argument_list|,
name|dir
argument_list|,
name|conf_op
argument_list|,
name|transfun
argument_list|,
name|visited
argument_list|,
name|pending
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sbitmap_first_set_bit
argument_list|(
name|pending
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|blocks
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|{ 	    fibheap_insert (worklist, order[i], (void *) (size_t) i); 	  }
argument_list|)
empty_stmt|;
name|sbitmap_zero
argument_list|(
name|visited
argument_list|)
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
name|sbitmap_free
argument_list|(
name|pending
argument_list|)
expr_stmt|;
name|sbitmap_free
argument_list|(
name|visited
argument_list|)
expr_stmt|;
name|fibheap_delete
argument_list|(
name|worklist
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Exactly the same as iterative_dataflow_sbitmap, except it works on    bitmaps instead */
end_comment

begin_function
name|void
name|iterative_dataflow_bitmap
parameter_list|(
name|in
parameter_list|,
name|out
parameter_list|,
name|gen
parameter_list|,
name|kill
parameter_list|,
name|blocks
parameter_list|,
name|dir
parameter_list|,
name|conf_op
parameter_list|,
name|transfun
parameter_list|,
name|order
parameter_list|,
name|data
parameter_list|)
name|bitmap
modifier|*
name|in
decl_stmt|,
decl|*
name|out
decl_stmt|,
modifier|*
name|gen
decl_stmt|,
modifier|*
name|kill
decl_stmt|;
end_function

begin_decl_stmt
name|bitmap
name|blocks
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|df_flow_dir
name|dir
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|df_confluence_op
name|conf_op
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|transfer_function_bitmap
name|transfun
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|order
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
modifier|*
name|data
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
name|fibheap_t
name|worklist
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|sbitmap
name|visited
decl_stmt|,
name|pending
decl_stmt|;
name|pending
operator|=
name|sbitmap_alloc
argument_list|(
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|visited
operator|=
name|sbitmap_alloc
argument_list|(
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|pending
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|visited
argument_list|)
expr_stmt|;
name|worklist
operator|=
name|fibheap_new
argument_list|()
expr_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|blocks
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|{     fibheap_insert (worklist, order[i], (void *) (size_t) i);     SET_BIT (pending, i);     if (dir == FORWARD)       bitmap_copy (out[i], gen[i]);     else       bitmap_copy (in[i], gen[i]);   }
argument_list|)
empty_stmt|;
while|while
condition|(
name|sbitmap_first_set_bit
argument_list|(
name|pending
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
while|while
condition|(
operator|!
name|fibheap_empty
argument_list|(
name|worklist
argument_list|)
condition|)
block|{
name|i
operator|=
operator|(
name|size_t
operator|)
name|fibheap_extract_min
argument_list|(
name|worklist
argument_list|)
expr_stmt|;
name|bb
operator|=
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TEST_BIT
argument_list|(
name|visited
argument_list|,
name|bb
operator|->
name|index
argument_list|)
condition|)
name|hybrid_search_bitmap
argument_list|(
name|bb
argument_list|,
name|in
argument_list|,
name|out
argument_list|,
name|gen
argument_list|,
name|kill
argument_list|,
name|dir
argument_list|,
name|conf_op
argument_list|,
name|transfun
argument_list|,
name|visited
argument_list|,
name|pending
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sbitmap_first_set_bit
argument_list|(
name|pending
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|blocks
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|{ 	    fibheap_insert (worklist, order[i], (void *) (size_t) i); 	  }
argument_list|)
empty_stmt|;
name|sbitmap_zero
argument_list|(
name|visited
argument_list|)
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
name|sbitmap_free
argument_list|(
name|pending
argument_list|)
expr_stmt|;
name|sbitmap_free
argument_list|(
name|visited
argument_list|)
expr_stmt|;
name|fibheap_delete
argument_list|(
name|worklist
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

