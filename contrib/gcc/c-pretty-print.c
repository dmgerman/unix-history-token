begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Subroutines common to both C and C++ pretty-printers.    Copyright (C) 2002, 2003, 2004 Free Software Foundation, Inc.    Contributed by Gabriel Dos Reis<gdr@integrable-solutions.net>  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"c-pretty-print.h"
end_include

begin_include
include|#
directive|include
file|"c-tree.h"
end_include

begin_comment
comment|/* The pretty-printer code is primarily designed to closely follow    (GNU) C and C++ grammars.  That is to be contrasted with spaghetti    codes we used to have in the past.  Following a structured    approach (preferably the official grammars) is believed to make it    much easier to add extensions and nifty pretty-printing effects that    takes expression or declaration contexts into account.  */
end_comment

begin_define
define|#
directive|define
name|pp_c_maybe_whitespace
parameter_list|(
name|PP
parameter_list|)
define|\
value|do {                                      \      if (pp_base (PP)->padding == pp_before) \        pp_c_whitespace (PP);                 \    } while (0)
end_define

begin_define
define|#
directive|define
name|pp_c_left_bracket
parameter_list|(
name|PP
parameter_list|)
define|\
value|do {                                \     pp_left_bracket (PP);             \     pp_base (PP)->padding = pp_none;  \   } while (0)
end_define

begin_define
define|#
directive|define
name|pp_c_right_bracket
parameter_list|(
name|PP
parameter_list|)
define|\
value|do {                                \     pp_right_bracket (PP);            \     pp_base (PP)->padding = pp_none;  \   } while (0)
end_define

begin_define
define|#
directive|define
name|pp_c_star
parameter_list|(
name|PP
parameter_list|)
define|\
value|do {                                \     pp_star (PP);                     \     pp_base (PP)->padding = pp_none;  \   } while (0)
end_define

begin_comment
comment|/* literal  */
end_comment

begin_function_decl
specifier|static
name|void
name|pp_c_char
parameter_list|(
name|c_pretty_printer
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* postfix-expression  */
end_comment

begin_function_decl
specifier|static
name|void
name|pp_c_initializer_list
parameter_list|(
name|c_pretty_printer
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pp_c_brace_enclosed_initializer_list
parameter_list|(
name|c_pretty_printer
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pp_c_multiplicative_expression
parameter_list|(
name|c_pretty_printer
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pp_c_additive_expression
parameter_list|(
name|c_pretty_printer
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pp_c_shift_expression
parameter_list|(
name|c_pretty_printer
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pp_c_relational_expression
parameter_list|(
name|c_pretty_printer
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pp_c_equality_expression
parameter_list|(
name|c_pretty_printer
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pp_c_and_expression
parameter_list|(
name|c_pretty_printer
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pp_c_exclusive_or_expression
parameter_list|(
name|c_pretty_printer
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pp_c_inclusive_or_expression
parameter_list|(
name|c_pretty_printer
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pp_c_logical_and_expression
parameter_list|(
name|c_pretty_printer
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pp_c_conditional_expression
parameter_list|(
name|c_pretty_printer
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pp_c_assignment_expression
parameter_list|(
name|c_pretty_printer
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* declarations.  */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Helper functions.  */
end_comment

begin_function
name|void
name|pp_c_whitespace
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|)
block|{
name|pp_space
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_base
argument_list|(
name|pp
argument_list|)
operator|->
name|padding
operator|=
name|pp_none
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pp_c_left_paren
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|)
block|{
name|pp_left_paren
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_base
argument_list|(
name|pp
argument_list|)
operator|->
name|padding
operator|=
name|pp_none
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pp_c_right_paren
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|)
block|{
name|pp_right_paren
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_base
argument_list|(
name|pp
argument_list|)
operator|->
name|padding
operator|=
name|pp_none
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pp_c_left_brace
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|)
block|{
name|pp_left_brace
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_base
argument_list|(
name|pp
argument_list|)
operator|->
name|padding
operator|=
name|pp_none
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pp_c_right_brace
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|)
block|{
name|pp_right_brace
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_base
argument_list|(
name|pp
argument_list|)
operator|->
name|padding
operator|=
name|pp_none
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pp_c_dot
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|)
block|{
name|pp_dot
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_base
argument_list|(
name|pp
argument_list|)
operator|->
name|padding
operator|=
name|pp_none
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pp_c_ampersand
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|)
block|{
name|pp_ampersand
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_base
argument_list|(
name|pp
argument_list|)
operator|->
name|padding
operator|=
name|pp_none
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pp_c_arrow
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|)
block|{
name|pp_arrow
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_base
argument_list|(
name|pp
argument_list|)
operator|->
name|padding
operator|=
name|pp_none
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pp_c_semicolon
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|)
block|{
name|pp_semicolon
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_base
argument_list|(
name|pp
argument_list|)
operator|->
name|padding
operator|=
name|pp_none
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|pp_c_cv_qualifier
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|,
specifier|const
name|char
modifier|*
name|cv
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
init|=
name|pp_last_position_in_text
argument_list|(
name|pp
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
operator|&&
operator|*
name|p
operator|==
literal|'*'
condition|)
name|pp_c_whitespace
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_c_identifier
argument_list|(
name|pp
argument_list|,
name|cv
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Pretty-print T using the type-cast notation '( type-name )'.  */
end_comment

begin_function
specifier|static
name|void
name|pp_c_type_cast
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|t
parameter_list|)
block|{
name|pp_c_left_paren
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_type_id
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|pp_c_right_paren
argument_list|(
name|pp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pp_c_space_for_pointer_operator
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|t
parameter_list|)
block|{
if|if
condition|(
name|POINTER_TYPE_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|tree
name|pointee
init|=
name|strip_pointer_operator
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|pointee
argument_list|)
operator|!=
name|ARRAY_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|pointee
argument_list|)
operator|!=
name|FUNCTION_TYPE
condition|)
name|pp_c_whitespace
argument_list|(
name|pp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Declarations.  */
end_comment

begin_comment
comment|/* C++ cv-qualifiers are called type-qualifiers in C.  Print out the    cv-qualifiers of T.  If T is a declaration then it is the cv-qualifier    of its type.  Take care of possible extensions.     type-qualifier-list:        type-qualifier        type-qualifier-list type-qualifier     type-qualifier:        const        restrict                              -- C99        __restrict__                          -- GNU C        volatile    */
end_comment

begin_function
name|void
name|pp_c_type_qualifier_list
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|t
parameter_list|)
block|{
name|int
name|qualifiers
decl_stmt|;
if|if
condition|(
operator|!
name|TYPE_P
argument_list|(
name|t
argument_list|)
condition|)
name|t
operator|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|qualifiers
operator|=
name|TYPE_QUALS
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|qualifiers
operator|&
name|TYPE_QUAL_CONST
condition|)
name|pp_c_cv_qualifier
argument_list|(
name|pp
argument_list|,
literal|"const"
argument_list|)
expr_stmt|;
if|if
condition|(
name|qualifiers
operator|&
name|TYPE_QUAL_VOLATILE
condition|)
name|pp_c_cv_qualifier
argument_list|(
name|pp
argument_list|,
literal|"volatile"
argument_list|)
expr_stmt|;
if|if
condition|(
name|qualifiers
operator|&
name|TYPE_QUAL_RESTRICT
condition|)
name|pp_c_cv_qualifier
argument_list|(
name|pp
argument_list|,
name|flag_isoc99
condition|?
literal|"restrict"
else|:
literal|"__restrict__"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* pointer:       * type-qualifier-list(opt)       * type-qualifier-list(opt) pointer  */
end_comment

begin_function
specifier|static
name|void
name|pp_c_pointer
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|t
parameter_list|)
block|{
if|if
condition|(
operator|!
name|TYPE_P
argument_list|(
name|t
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|TYPE_DECL
condition|)
name|t
operator|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|POINTER_TYPE
case|:
comment|/* It is easier to handle C++ reference types here.  */
case|case
name|REFERENCE_TYPE
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
name|pp_c_pointer
argument_list|(
name|pp
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
name|pp_c_star
argument_list|(
name|pp
argument_list|)
expr_stmt|;
else|else
name|pp_c_ampersand
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_c_type_qualifier_list
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
default|default:
name|pp_unsupported_tree
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* type-specifier:       void       char       short       int       long       float       double       signed       unsigned       _Bool                          -- C99       _Complex                       -- C99       _Imaginary                     -- C99       struct-or-union-specifier       enum-specifier       typedef-name.    GNU extensions.   simple-type-specifier:       __complex__       __vector__   */
end_comment

begin_function
name|void
name|pp_c_type_specifier
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|t
parameter_list|)
block|{
specifier|const
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|t
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|ERROR_MARK
case|:
name|pp_c_identifier
argument_list|(
name|pp
argument_list|,
literal|"<type-error>"
argument_list|)
expr_stmt|;
break|break;
case|case
name|IDENTIFIER_NODE
case|:
name|pp_c_tree_identifier
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|VOID_TYPE
case|:
case|case
name|BOOLEAN_TYPE
case|:
case|case
name|CHAR_TYPE
case|:
case|case
name|INTEGER_TYPE
case|:
case|case
name|REAL_TYPE
case|:
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
condition|)
name|t
operator|=
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
expr_stmt|;
else|else
name|t
operator|=
name|c_common_type_for_mode
argument_list|(
name|TYPE_MODE
argument_list|(
name|t
argument_list|)
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|pp_c_type_specifier
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_DECL
case|:
if|if
condition|(
name|DECL_NAME
argument_list|(
name|t
argument_list|)
condition|)
name|pp_id_expression
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
else|else
name|pp_c_identifier
argument_list|(
name|pp
argument_list|,
literal|"<typedef-error>"
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNION_TYPE
case|:
case|case
name|RECORD_TYPE
case|:
case|case
name|ENUMERAL_TYPE
case|:
if|if
condition|(
name|code
operator|==
name|UNION_TYPE
condition|)
name|pp_c_identifier
argument_list|(
name|pp
argument_list|,
literal|"union"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|RECORD_TYPE
condition|)
name|pp_c_identifier
argument_list|(
name|pp
argument_list|,
literal|"struct"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|ENUMERAL_TYPE
condition|)
name|pp_c_identifier
argument_list|(
name|pp
argument_list|,
literal|"enum"
argument_list|)
expr_stmt|;
else|else
name|pp_c_identifier
argument_list|(
name|pp
argument_list|,
literal|"<tag-error>"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
condition|)
name|pp_id_expression
argument_list|(
name|pp
argument_list|,
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|pp_c_identifier
argument_list|(
name|pp
argument_list|,
literal|"<anonymous>"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|pp_unsupported_tree
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* specifier-qualifier-list:       type-specifier specifier-qualifier-list-opt       type-qualifier specifier-qualifier-list-opt     Implementation note:  Because of the non-linearities in array or   function declarations, this routine prints not just the   specifier-qualifier-list of such entities or types of such entities,   but also the 'pointer' production part of their declarators.  The   remaining part is done by pp_declarator or pp_c_abstract_declarator.  */
end_comment

begin_function
name|void
name|pp_c_specifier_qualifier_list
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|t
parameter_list|)
block|{
specifier|const
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|POINTER_TYPE
condition|)
name|pp_c_type_qualifier_list
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|REFERENCE_TYPE
case|:
case|case
name|POINTER_TYPE
case|:
block|{
comment|/* Get the types-specifier of this type.  */
name|tree
name|pointee
init|=
name|strip_pointer_operator
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
decl_stmt|;
name|pp_c_specifier_qualifier_list
argument_list|(
name|pp
argument_list|,
name|pointee
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|pointee
argument_list|)
operator|==
name|ARRAY_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|pointee
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
name|pp_c_whitespace
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_c_left_paren
argument_list|(
name|pp
argument_list|)
expr_stmt|;
block|}
name|pp_ptr_operator
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|FUNCTION_TYPE
case|:
case|case
name|ARRAY_TYPE
case|:
name|pp_c_specifier_qualifier_list
argument_list|(
name|pp
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|VECTOR_TYPE
case|:
case|case
name|COMPLEX_TYPE
case|:
name|pp_c_specifier_qualifier_list
argument_list|(
name|pp
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|COMPLEX_TYPE
condition|)
name|pp_c_identifier
argument_list|(
name|pp
argument_list|,
name|flag_isoc99
condition|?
literal|"_Complex"
else|:
literal|"__complex__"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|VECTOR_TYPE
condition|)
name|pp_c_identifier
argument_list|(
name|pp
argument_list|,
literal|"__vector__"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|pp_simple_type_specifier
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* parameter-type-list:       parameter-list       parameter-list , ...     parameter-list:       parameter-declaration       parameter-list , parameter-declaration     parameter-declaration:       declaration-specifiers declarator       declaration-specifiers abstract-declarator(opt)   */
end_comment

begin_function
name|void
name|pp_c_parameter_type_list
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|t
parameter_list|)
block|{
name|bool
name|want_parm_decl
init|=
name|DECL_P
argument_list|(
name|t
argument_list|)
operator|&&
operator|!
operator|(
name|pp
operator|->
name|flags
operator|&
name|pp_c_flag_abstract
operator|)
decl_stmt|;
name|tree
name|parms
init|=
name|want_parm_decl
condition|?
name|DECL_ARGUMENTS
argument_list|(
name|t
argument_list|)
else|:
name|TYPE_ARG_TYPES
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|pp_c_left_paren
argument_list|(
name|pp
argument_list|)
expr_stmt|;
if|if
condition|(
name|parms
operator|==
name|void_list_node
condition|)
name|pp_c_identifier
argument_list|(
name|pp
argument_list|,
literal|"void"
argument_list|)
expr_stmt|;
else|else
block|{
name|bool
name|first
init|=
name|true
decl_stmt|;
for|for
control|(
init|;
name|parms
operator|&&
name|parms
operator|!=
name|void_list_node
condition|;
name|parms
operator|=
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|first
condition|)
name|pp_separate_with
argument_list|(
name|pp
argument_list|,
literal|','
argument_list|)
expr_stmt|;
name|first
operator|=
name|false
expr_stmt|;
name|pp_declaration_specifiers
argument_list|(
name|pp
argument_list|,
name|want_parm_decl
condition|?
name|parms
else|:
name|TREE_VALUE
argument_list|(
name|parms
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|want_parm_decl
condition|)
name|pp_declarator
argument_list|(
name|pp
argument_list|,
name|parms
argument_list|)
expr_stmt|;
else|else
name|pp_abstract_declarator
argument_list|(
name|pp
argument_list|,
name|TREE_VALUE
argument_list|(
name|parms
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|pp_c_right_paren
argument_list|(
name|pp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* abstract-declarator:       pointer       pointer(opt) direct-abstract-declarator  */
end_comment

begin_function
specifier|static
name|void
name|pp_c_abstract_declarator
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|t
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|pp_c_right_paren
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|t
operator|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
name|pp_direct_abstract_declarator
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* direct-abstract-declarator:       ( abstract-declarator )       direct-abstract-declarator(opt) [ assignment-expression(opt) ]       direct-abstract-declarator(opt) [ * ]       direct-abstract-declarator(opt) ( parameter-type-list(opt) )  */
end_comment

begin_function
name|void
name|pp_c_direct_abstract_declarator
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|POINTER_TYPE
case|:
name|pp_abstract_declarator
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|FUNCTION_TYPE
case|:
name|pp_c_parameter_type_list
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|pp_direct_abstract_declarator
argument_list|(
name|pp
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARRAY_TYPE
case|:
name|pp_c_left_bracket
argument_list|(
name|pp
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_DOMAIN
argument_list|(
name|t
argument_list|)
condition|)
name|pp_expression
argument_list|(
name|pp
argument_list|,
name|TYPE_MAX_VALUE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|pp_c_right_bracket
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_direct_abstract_declarator
argument_list|(
name|pp
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|IDENTIFIER_NODE
case|:
case|case
name|VOID_TYPE
case|:
case|case
name|BOOLEAN_TYPE
case|:
case|case
name|INTEGER_TYPE
case|:
case|case
name|REAL_TYPE
case|:
case|case
name|ENUMERAL_TYPE
case|:
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
case|case
name|VECTOR_TYPE
case|:
case|case
name|COMPLEX_TYPE
case|:
case|case
name|TYPE_DECL
case|:
break|break;
default|default:
name|pp_unsupported_tree
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* type-name:       specifier-qualifier-list  abstract-declarator(opt)  */
end_comment

begin_function
name|void
name|pp_c_type_id
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|t
parameter_list|)
block|{
name|pp_c_specifier_qualifier_list
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|pp_abstract_declarator
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* storage-class-specifier:       typedef       extern       static       auto       register  */
end_comment

begin_function
name|void
name|pp_c_storage_class_specifier
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|t
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|pp_c_identifier
argument_list|(
name|pp
argument_list|,
literal|"typedef"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
if|if
condition|(
name|DECL_REGISTER
argument_list|(
name|t
argument_list|)
condition|)
name|pp_c_identifier
argument_list|(
name|pp
argument_list|,
literal|"register"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|t
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|VAR_DECL
condition|)
name|pp_c_identifier
argument_list|(
name|pp
argument_list|,
literal|"static"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* function-specifier:       inline   */
end_comment

begin_function
name|void
name|pp_c_function_specifier
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|t
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_DECLARED_INLINE_P
argument_list|(
name|t
argument_list|)
condition|)
name|pp_c_identifier
argument_list|(
name|pp
argument_list|,
literal|"inline"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* declaration-specifiers:       storage-class-specifier declaration-specifiers(opt)       type-specifier declaration-specifiers(opt)       type-qualifier declaration-specifiers(opt)       function-specifier declaration-specifiers(opt)  */
end_comment

begin_function
name|void
name|pp_c_declaration_specifiers
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|t
parameter_list|)
block|{
name|pp_storage_class_specifier
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|pp_function_specifier
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|pp_c_specifier_qualifier_list
argument_list|(
name|pp
argument_list|,
name|DECL_P
argument_list|(
name|t
argument_list|)
condition|?
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
else|:
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* direct-declarator       identifier       ( declarator )       direct-declarator [ type-qualifier-list(opt) assignment-expression(opt) ]       direct-declarator [ static type-qualifier-list(opt) assignment-expression(opt)]       direct-declarator [ type-qualifier-list static assignment-expression ]       direct-declarator [ type-qualifier-list * ]       direct-declaratpr ( parameter-type-list )       direct-declarator ( identifier-list(opt) )  */
end_comment

begin_function
name|void
name|pp_c_direct_declarator
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|VAR_DECL
case|:
case|case
name|PARM_DECL
case|:
case|case
name|TYPE_DECL
case|:
case|case
name|FIELD_DECL
case|:
case|case
name|LABEL_DECL
case|:
if|if
condition|(
name|DECL_NAME
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|pp_c_space_for_pointer_operator
argument_list|(
name|pp
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|pp_c_tree_identifier
argument_list|(
name|pp
argument_list|,
name|DECL_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
case|case
name|ARRAY_TYPE
case|:
case|case
name|POINTER_TYPE
case|:
name|pp_abstract_declarator
argument_list|(
name|pp
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FUNCTION_TYPE
case|:
name|pp_parameter_list
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|pp_abstract_declarator
argument_list|(
name|pp
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FUNCTION_DECL
case|:
name|pp_c_space_for_pointer_operator
argument_list|(
name|pp
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|pp_c_tree_identifier
argument_list|(
name|pp
argument_list|,
name|DECL_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pp_c_base
argument_list|(
name|pp
argument_list|)
operator|->
name|flags
operator|&
name|pp_c_flag_abstract
condition|)
name|pp_abstract_declarator
argument_list|(
name|pp
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|pp_parameter_list
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|pp_abstract_declarator
argument_list|(
name|pp
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|INTEGER_TYPE
case|:
case|case
name|REAL_TYPE
case|:
case|case
name|ENUMERAL_TYPE
case|:
case|case
name|UNION_TYPE
case|:
case|case
name|RECORD_TYPE
case|:
break|break;
default|default:
name|pp_unsupported_tree
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* declarator:       pointer(opt)  direct-declarator   */
end_comment

begin_function
name|void
name|pp_c_declarator
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|INTEGER_TYPE
case|:
case|case
name|REAL_TYPE
case|:
case|case
name|ENUMERAL_TYPE
case|:
case|case
name|UNION_TYPE
case|:
case|case
name|RECORD_TYPE
case|:
break|break;
case|case
name|VAR_DECL
case|:
case|case
name|PARM_DECL
case|:
case|case
name|FIELD_DECL
case|:
case|case
name|ARRAY_TYPE
case|:
case|case
name|FUNCTION_TYPE
case|:
case|case
name|FUNCTION_DECL
case|:
case|case
name|TYPE_DECL
case|:
name|pp_direct_declarator
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
default|default:
name|pp_unsupported_tree
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* declaration:       declaration-specifiers init-declarator-list(opt) ;  */
end_comment

begin_function
name|void
name|pp_c_declaration
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|t
parameter_list|)
block|{
name|pp_declaration_specifiers
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|pp_c_init_declarator
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Pretty-print ATTRIBUTES using GNU C extension syntax.  */
end_comment

begin_function
name|void
name|pp_c_attributes
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|attributes
parameter_list|)
block|{
if|if
condition|(
name|attributes
operator|==
name|NULL_TREE
condition|)
return|return;
name|pp_c_identifier
argument_list|(
name|pp
argument_list|,
literal|"__attribute__"
argument_list|)
expr_stmt|;
name|pp_c_left_paren
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_c_left_paren
argument_list|(
name|pp
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|attributes
operator|!=
name|NULL_TREE
condition|;
name|attributes
operator|=
name|TREE_CHAIN
argument_list|(
name|attributes
argument_list|)
control|)
block|{
name|pp_tree_identifier
argument_list|(
name|pp
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|attributes
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|attributes
argument_list|)
condition|)
name|pp_c_call_argument_list
argument_list|(
name|pp
argument_list|,
name|TREE_VALUE
argument_list|(
name|attributes
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|attributes
argument_list|)
condition|)
name|pp_separate_with
argument_list|(
name|pp
argument_list|,
literal|','
argument_list|)
expr_stmt|;
block|}
name|pp_c_right_paren
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_c_right_paren
argument_list|(
name|pp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* function-definition:       declaration-specifiers declarator compound-statement  */
end_comment

begin_function
name|void
name|pp_c_function_definition
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|t
parameter_list|)
block|{
name|pp_declaration_specifiers
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|pp_declarator
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|pp_needs_newline
argument_list|(
name|pp
argument_list|)
operator|=
name|true
expr_stmt|;
name|pp_statement
argument_list|(
name|pp
argument_list|,
name|DECL_SAVED_TREE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|pp_newline
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_flush
argument_list|(
name|pp
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Expressions.  */
end_comment

begin_comment
comment|/* Print out a c-char.  */
end_comment

begin_function
specifier|static
name|void
name|pp_c_char
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|,
name|int
name|c
parameter_list|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|TARGET_NEWLINE
case|:
name|pp_string
argument_list|(
name|pp
argument_list|,
literal|"\\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TARGET_TAB
case|:
name|pp_string
argument_list|(
name|pp
argument_list|,
literal|"\\t"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TARGET_VT
case|:
name|pp_string
argument_list|(
name|pp
argument_list|,
literal|"\\v"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TARGET_BS
case|:
name|pp_string
argument_list|(
name|pp
argument_list|,
literal|"\\b"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TARGET_CR
case|:
name|pp_string
argument_list|(
name|pp
argument_list|,
literal|"\\r"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TARGET_FF
case|:
name|pp_string
argument_list|(
name|pp
argument_list|,
literal|"\\f"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TARGET_BELL
case|:
name|pp_string
argument_list|(
name|pp
argument_list|,
literal|"\\a"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
name|pp_string
argument_list|(
name|pp
argument_list|,
literal|"\\\\"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\''
case|:
name|pp_string
argument_list|(
name|pp
argument_list|,
literal|"\\'"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\"'
case|:
name|pp_string
argument_list|(
name|pp
argument_list|,
literal|"\\\""
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|ISPRINT
argument_list|(
name|c
argument_list|)
condition|)
name|pp_character
argument_list|(
name|pp
argument_list|,
name|c
argument_list|)
expr_stmt|;
else|else
name|pp_scalar
argument_list|(
name|pp
argument_list|,
literal|"\\%03o"
argument_list|,
operator|(
name|unsigned
operator|)
name|c
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Print out a STRING literal.  */
end_comment

begin_function
name|void
name|pp_c_string_literal
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|s
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
init|=
name|TREE_STRING_POINTER
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|int
name|n
init|=
name|TREE_STRING_LENGTH
argument_list|(
name|s
argument_list|)
operator|-
literal|1
decl_stmt|;
name|int
name|i
decl_stmt|;
name|pp_doublequote
argument_list|(
name|pp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
name|pp_c_char
argument_list|(
name|pp
argument_list|,
name|p
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|pp_doublequote
argument_list|(
name|pp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|pp_c_integer_constant
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|i
parameter_list|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_INT_CST_HIGH
argument_list|(
name|i
argument_list|)
operator|==
literal|0
condition|)
name|pp_wide_integer
argument_list|(
name|pp
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|tree_int_cst_sgn
argument_list|(
name|i
argument_list|)
operator|<
literal|0
condition|)
block|{
name|pp_c_char
argument_list|(
name|pp
argument_list|,
literal|'-'
argument_list|)
expr_stmt|;
name|i
operator|=
name|build_int_2
argument_list|(
operator|-
name|TREE_INT_CST_LOW
argument_list|(
name|i
argument_list|)
argument_list|,
operator|~
name|TREE_INT_CST_HIGH
argument_list|(
name|i
argument_list|)
operator|+
operator|!
name|TREE_INT_CST_LOW
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|pp_buffer
argument_list|(
name|pp
argument_list|)
operator|->
name|digit_buffer
argument_list|,
name|HOST_WIDE_INT_PRINT_DOUBLE_HEX
argument_list|,
name|TREE_INT_CST_HIGH
argument_list|(
name|i
argument_list|)
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|pp_string
argument_list|(
name|pp
argument_list|,
name|pp_buffer
argument_list|(
name|pp
argument_list|)
operator|->
name|digit_buffer
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|)
name|pp_character
argument_list|(
name|pp
argument_list|,
literal|'u'
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|long_integer_type_node
operator|||
name|type
operator|==
name|long_unsigned_type_node
condition|)
name|pp_character
argument_list|(
name|pp
argument_list|,
literal|'l'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|long_long_integer_type_node
operator|||
name|type
operator|==
name|long_long_unsigned_type_node
condition|)
name|pp_string
argument_list|(
name|pp
argument_list|,
literal|"ll"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print out a CHARACTER literal.  */
end_comment

begin_function
specifier|static
name|void
name|pp_c_character_constant
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|c
parameter_list|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|c
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|wchar_type_node
condition|)
name|pp_character
argument_list|(
name|pp
argument_list|,
literal|'L'
argument_list|)
expr_stmt|;
name|pp_quote
argument_list|(
name|pp
argument_list|)
expr_stmt|;
if|if
condition|(
name|host_integerp
argument_list|(
name|c
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
name|pp_c_char
argument_list|(
name|pp
argument_list|,
name|tree_low_cst
argument_list|(
name|c
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|pp_scalar
argument_list|(
name|pp
argument_list|,
literal|"\\x%x"
argument_list|,
operator|(
name|unsigned
operator|)
name|TREE_INT_CST_LOW
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|pp_quote
argument_list|(
name|pp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print out a BOOLEAN literal.  */
end_comment

begin_function
specifier|static
name|void
name|pp_c_bool_constant
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|b
parameter_list|)
block|{
if|if
condition|(
name|b
operator|==
name|boolean_false_node
condition|)
block|{
if|if
condition|(
name|c_dialect_cxx
argument_list|()
condition|)
name|pp_c_identifier
argument_list|(
name|pp
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|flag_isoc99
condition|)
name|pp_c_identifier
argument_list|(
name|pp
argument_list|,
literal|"_False"
argument_list|)
expr_stmt|;
else|else
name|pp_unsupported_tree
argument_list|(
name|pp
argument_list|,
name|b
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|b
operator|==
name|boolean_true_node
condition|)
block|{
if|if
condition|(
name|c_dialect_cxx
argument_list|()
condition|)
name|pp_c_identifier
argument_list|(
name|pp
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|flag_isoc99
condition|)
name|pp_c_identifier
argument_list|(
name|pp
argument_list|,
literal|"_True"
argument_list|)
expr_stmt|;
else|else
name|pp_unsupported_tree
argument_list|(
name|pp
argument_list|,
name|b
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|b
argument_list|)
operator|==
name|INTEGER_CST
condition|)
name|pp_c_integer_constant
argument_list|(
name|pp
argument_list|,
name|b
argument_list|)
expr_stmt|;
else|else
name|pp_unsupported_tree
argument_list|(
name|pp
argument_list|,
name|b
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Attempt to print out an ENUMERATOR.  Return true on success.  Else return    false; that means the value was obtained by a cast, in which case    print out the type-id part of the cast-expression -- the casted value    is then printed by pp_c_integer_literal.  */
end_comment

begin_function
specifier|static
name|bool
name|pp_c_enumeration_constant
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|e
parameter_list|)
block|{
name|bool
name|value_is_named
init|=
name|true
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|e
argument_list|)
decl_stmt|;
name|tree
name|value
decl_stmt|;
comment|/* Find the name of this constant.  */
for|for
control|(
name|value
operator|=
name|TYPE_VALUES
argument_list|(
name|type
argument_list|)
init|;
name|value
operator|!=
name|NULL_TREE
operator|&&
operator|!
name|tree_int_cst_equal
argument_list|(
name|TREE_VALUE
argument_list|(
name|value
argument_list|)
argument_list|,
name|e
argument_list|)
condition|;
name|value
operator|=
name|TREE_CHAIN
argument_list|(
name|value
argument_list|)
control|)
empty_stmt|;
if|if
condition|(
name|value
operator|!=
name|NULL_TREE
condition|)
name|pp_id_expression
argument_list|(
name|pp
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Value must have been cast.  */
name|pp_c_type_cast
argument_list|(
name|pp
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|value_is_named
operator|=
name|false
expr_stmt|;
block|}
return|return
name|value_is_named
return|;
block|}
end_function

begin_comment
comment|/* Print out a REAL value as a decimal-floating-constant.  */
end_comment

begin_function
specifier|static
name|void
name|pp_c_floating_constant
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|r
parameter_list|)
block|{
name|real_to_decimal
argument_list|(
name|pp_buffer
argument_list|(
name|pp
argument_list|)
operator|->
name|digit_buffer
argument_list|,
operator|&
name|TREE_REAL_CST
argument_list|(
name|r
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|pp_buffer
argument_list|(
name|pp
argument_list|)
operator|->
name|digit_buffer
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pp_string
argument_list|(
name|pp
argument_list|,
name|pp_buffer
argument_list|(
name|pp
argument_list|)
operator|->
name|digit_buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|r
argument_list|)
operator|==
name|float_type_node
condition|)
name|pp_character
argument_list|(
name|pp
argument_list|,
literal|'f'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|r
argument_list|)
operator|==
name|long_double_type_node
condition|)
name|pp_character
argument_list|(
name|pp
argument_list|,
literal|'l'
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Pretty-print a compound literal expression.  GNU extensions include    vector constants.  */
end_comment

begin_function
specifier|static
name|void
name|pp_c_compound_literal
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|e
parameter_list|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|e
argument_list|)
decl_stmt|;
name|pp_c_type_cast
argument_list|(
name|pp
argument_list|,
name|type
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
case|case
name|ARRAY_TYPE
case|:
case|case
name|VECTOR_TYPE
case|:
case|case
name|COMPLEX_TYPE
case|:
name|pp_c_brace_enclosed_initializer_list
argument_list|(
name|pp
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
default|default:
name|pp_unsupported_tree
argument_list|(
name|pp
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* constant:       integer-constant       floating-constant       enumeration-constant       character-constant   */
end_comment

begin_function
name|void
name|pp_c_constant
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|e
parameter_list|)
block|{
specifier|const
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|e
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|INTEGER_CST
case|:
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|e
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|boolean_type_node
condition|)
name|pp_c_bool_constant
argument_list|(
name|pp
argument_list|,
name|e
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|char_type_node
condition|)
name|pp_c_character_constant
argument_list|(
name|pp
argument_list|,
name|e
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|&&
name|pp_c_enumeration_constant
argument_list|(
name|pp
argument_list|,
name|e
argument_list|)
condition|)
empty_stmt|;
else|else
name|pp_c_integer_constant
argument_list|(
name|pp
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|REAL_CST
case|:
name|pp_c_floating_constant
argument_list|(
name|pp
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|STRING_CST
case|:
name|pp_c_string_literal
argument_list|(
name|pp
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
default|default:
name|pp_unsupported_tree
argument_list|(
name|pp
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
name|void
name|pp_c_identifier
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|,
specifier|const
name|char
modifier|*
name|id
parameter_list|)
block|{
name|pp_c_maybe_whitespace
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_identifier
argument_list|(
name|pp
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|pp_base
argument_list|(
name|pp
argument_list|)
operator|->
name|padding
operator|=
name|pp_before
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Pretty-print a C primary-expression.    primary-expression:       identifier       constant       string-literal       ( expression )   */
end_comment

begin_function
name|void
name|pp_c_primary_expression
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|e
parameter_list|)
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|e
argument_list|)
condition|)
block|{
case|case
name|VAR_DECL
case|:
case|case
name|PARM_DECL
case|:
case|case
name|FIELD_DECL
case|:
case|case
name|CONST_DECL
case|:
case|case
name|FUNCTION_DECL
case|:
case|case
name|LABEL_DECL
case|:
name|e
operator|=
name|DECL_NAME
argument_list|(
name|e
argument_list|)
expr_stmt|;
comment|/* Fall through.  */
case|case
name|IDENTIFIER_NODE
case|:
name|pp_c_tree_identifier
argument_list|(
name|pp
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|ERROR_MARK
case|:
name|pp_c_identifier
argument_list|(
name|pp
argument_list|,
literal|"<erroneous-expression>"
argument_list|)
expr_stmt|;
break|break;
case|case
name|RESULT_DECL
case|:
name|pp_c_identifier
argument_list|(
name|pp
argument_list|,
literal|"<return-value>"
argument_list|)
expr_stmt|;
break|break;
case|case
name|INTEGER_CST
case|:
case|case
name|REAL_CST
case|:
case|case
name|STRING_CST
case|:
name|pp_c_constant
argument_list|(
name|pp
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|STMT_EXPR
case|:
name|pp_c_left_paren
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_statement
argument_list|(
name|pp
argument_list|,
name|STMT_EXPR_STMT
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
name|pp_c_right_paren
argument_list|(
name|pp
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* FIXME:  Make sure we won't get into an infinie loop.  */
name|pp_c_left_paren
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_expression
argument_list|(
name|pp
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|pp_c_right_paren
argument_list|(
name|pp
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Print out a C initializer -- also support C compound-literals.    initializer:       assignment-expression:       { initializer-list }       { initializer-list , }   */
end_comment

begin_function
specifier|static
name|void
name|pp_c_initializer
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|e
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|e
argument_list|)
operator|==
name|CONSTRUCTOR
condition|)
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|e
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|RECORD_TYPE
operator|||
name|code
operator|==
name|UNION_TYPE
operator|||
name|code
operator|==
name|ARRAY_TYPE
condition|)
name|pp_c_brace_enclosed_initializer_list
argument_list|(
name|pp
argument_list|,
name|e
argument_list|)
expr_stmt|;
else|else
name|pp_unsupported_tree
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|pp_expression
argument_list|(
name|pp
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* init-declarator:       declarator:       declarator = initializer   */
end_comment

begin_function
name|void
name|pp_c_init_declarator
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|t
parameter_list|)
block|{
name|pp_declarator
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|tree
name|init
init|=
name|DECL_INITIAL
argument_list|(
name|t
argument_list|)
decl_stmt|;
comment|/* This C++ bit is handled here because it is easier to do so.          In templates, the C++ parser builds a TREE_LIST for a          direct-initialization; the TREE_PURPOSE is the variable to          initialize and the TREE_VALUE is the initializer.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
name|pp_c_left_paren
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_expression
argument_list|(
name|pp
argument_list|,
name|TREE_VALUE
argument_list|(
name|init
argument_list|)
argument_list|)
expr_stmt|;
name|pp_right_paren
argument_list|(
name|pp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pp_space
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_equal
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_space
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_c_initializer
argument_list|(
name|pp
argument_list|,
name|init
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* initializer-list:       designation(opt) initializer       initializer-list , designation(opt) initializer     designation:       designator-list =     designator-list:       designator       designator-list designator     designator:       [ constant-expression ]       identifier   */
end_comment

begin_function
specifier|static
name|void
name|pp_c_initializer_list
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|e
parameter_list|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|e
argument_list|)
decl_stmt|;
specifier|const
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
case|case
name|ARRAY_TYPE
case|:
block|{
name|tree
name|init
init|=
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
decl_stmt|;
for|for
control|(
init|;
name|init
operator|!=
name|NULL_TREE
condition|;
name|init
operator|=
name|TREE_CHAIN
argument_list|(
name|init
argument_list|)
control|)
block|{
if|if
condition|(
name|code
operator|==
name|RECORD_TYPE
operator|||
name|code
operator|==
name|UNION_TYPE
condition|)
block|{
name|pp_c_dot
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_c_primary_expression
argument_list|(
name|pp
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|init
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pp_c_left_bracket
argument_list|(
name|pp
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|init
argument_list|)
condition|)
name|pp_c_constant
argument_list|(
name|pp
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|init
argument_list|)
argument_list|)
expr_stmt|;
name|pp_c_right_bracket
argument_list|(
name|pp
argument_list|)
expr_stmt|;
block|}
name|pp_c_whitespace
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_equal
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_c_whitespace
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_initializer
argument_list|(
name|pp
argument_list|,
name|TREE_VALUE
argument_list|(
name|init
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|init
argument_list|)
condition|)
name|pp_separate_with
argument_list|(
name|pp
argument_list|,
literal|','
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|VECTOR_TYPE
case|:
name|pp_c_expression_list
argument_list|(
name|pp
argument_list|,
name|TREE_VECTOR_CST_ELTS
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|COMPLEX_TYPE
case|:
block|{
specifier|const
name|bool
name|cst
init|=
name|TREE_CODE
argument_list|(
name|e
argument_list|)
operator|==
name|COMPLEX_CST
decl_stmt|;
name|pp_expression
argument_list|(
name|pp
argument_list|,
name|cst
condition|?
name|TREE_REALPART
argument_list|(
name|e
argument_list|)
else|:
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|pp_separate_with
argument_list|(
name|pp
argument_list|,
literal|','
argument_list|)
expr_stmt|;
name|pp_expression
argument_list|(
name|pp
argument_list|,
name|cst
condition|?
name|TREE_IMAGPART
argument_list|(
name|e
argument_list|)
else|:
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|pp_unsupported_tree
argument_list|(
name|pp
argument_list|,
name|type
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Pretty-print a brace-enclosed initializer-list.  */
end_comment

begin_function
specifier|static
name|void
name|pp_c_brace_enclosed_initializer_list
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|l
parameter_list|)
block|{
name|pp_c_left_brace
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_c_initializer_list
argument_list|(
name|pp
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|pp_c_right_brace
argument_list|(
name|pp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  This is a convenient function, used to bridge gap between C and C++     grammars.      id-expression:        identifier  */
end_comment

begin_function
name|void
name|pp_c_id_expression
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|VAR_DECL
case|:
case|case
name|PARM_DECL
case|:
case|case
name|CONST_DECL
case|:
case|case
name|TYPE_DECL
case|:
case|case
name|FUNCTION_DECL
case|:
case|case
name|FIELD_DECL
case|:
case|case
name|LABEL_DECL
case|:
name|t
operator|=
name|DECL_NAME
argument_list|(
name|t
argument_list|)
expr_stmt|;
case|case
name|IDENTIFIER_NODE
case|:
name|pp_c_tree_identifier
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
default|default:
name|pp_unsupported_tree
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* postfix-expression:       primary-expression       postfix-expression [ expression ]       postfix-expression ( argument-expression-list(opt) )       postfix-expression . identifier       postfix-expression -> identifier       postfix-expression ++       postfix-expression --       ( type-name ) { initializer-list }       ( type-name ) { initializer-list , }  */
end_comment

begin_function
name|void
name|pp_c_postfix_expression
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|e
parameter_list|)
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|e
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|POSTINCREMENT_EXPR
case|:
case|case
name|POSTDECREMENT_EXPR
case|:
name|pp_postfix_expression
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|pp_identifier
argument_list|(
name|pp
argument_list|,
name|code
operator|==
name|POSTINCREMENT_EXPR
condition|?
literal|"++"
else|:
literal|"--"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARROW_EXPR
case|:
name|pp_postfix_expression
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|pp_c_arrow
argument_list|(
name|pp
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARRAY_REF
case|:
name|pp_postfix_expression
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|pp_c_left_bracket
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_expression
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|pp_c_right_bracket
argument_list|(
name|pp
argument_list|)
expr_stmt|;
break|break;
case|case
name|CALL_EXPR
case|:
name|pp_postfix_expression
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|pp_c_call_argument_list
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ABS_EXPR
case|:
name|pp_c_identifier
argument_list|(
name|pp
argument_list|,
literal|"__builtin_abs"
argument_list|)
expr_stmt|;
name|pp_c_left_paren
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_expression
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|pp_c_right_paren
argument_list|(
name|pp
argument_list|)
expr_stmt|;
break|break;
case|case
name|COMPONENT_REF
case|:
block|{
name|tree
name|object
init|=
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|object
argument_list|)
operator|==
name|INDIRECT_REF
condition|)
block|{
name|pp_postfix_expression
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|object
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|pp_c_arrow
argument_list|(
name|pp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pp_postfix_expression
argument_list|(
name|pp
argument_list|,
name|object
argument_list|)
expr_stmt|;
name|pp_c_dot
argument_list|(
name|pp
argument_list|)
expr_stmt|;
block|}
name|pp_expression
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|COMPLEX_CST
case|:
case|case
name|VECTOR_CST
case|:
case|case
name|COMPLEX_EXPR
case|:
name|pp_c_compound_literal
argument_list|(
name|pp
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|COMPOUND_LITERAL_EXPR
case|:
name|e
operator|=
name|DECL_INITIAL
argument_list|(
name|COMPOUND_LITERAL_EXPR_DECL
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fall through.  */
case|case
name|CONSTRUCTOR
case|:
name|pp_initializer
argument_list|(
name|pp
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|VA_ARG_EXPR
case|:
name|pp_c_identifier
argument_list|(
name|pp
argument_list|,
literal|"__builtin_va_arg"
argument_list|)
expr_stmt|;
name|pp_c_left_paren
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_assignment_expression
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|pp_separate_with
argument_list|(
name|pp
argument_list|,
literal|','
argument_list|)
expr_stmt|;
name|pp_type_id
argument_list|(
name|pp
argument_list|,
name|TREE_TYPE
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
name|pp_c_right_paren
argument_list|(
name|pp
argument_list|)
expr_stmt|;
break|break;
case|case
name|ADDR_EXPR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|pp_c_id_expression
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* else fall through.  */
default|default:
name|pp_primary_expression
argument_list|(
name|pp
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Print out an expression-list; E is expected to be a TREE_LIST.  */
end_comment

begin_function
name|void
name|pp_c_expression_list
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|e
parameter_list|)
block|{
for|for
control|(
init|;
name|e
operator|!=
name|NULL_TREE
condition|;
name|e
operator|=
name|TREE_CHAIN
argument_list|(
name|e
argument_list|)
control|)
block|{
name|pp_expression
argument_list|(
name|pp
argument_list|,
name|TREE_VALUE
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|e
argument_list|)
condition|)
name|pp_separate_with
argument_list|(
name|pp
argument_list|,
literal|','
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print out an expression-list in parens, as in a function call.  */
end_comment

begin_function
name|void
name|pp_c_call_argument_list
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|t
parameter_list|)
block|{
name|pp_c_left_paren
argument_list|(
name|pp
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|pp_c_expression_list
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|pp_c_right_paren
argument_list|(
name|pp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* unary-expression:       postfix-expression       ++ cast-expression       -- cast-expression       unary-operator cast-expression       sizeof unary-expression       sizeof ( type-id )    unary-operator: one of       *&  + - ! ~           GNU extensions.    unary-expression:       __alignof__ unary-expression       __alignof__ ( type-id )       __real__ unary-expression       __imag__ unary-expression  */
end_comment

begin_function
name|void
name|pp_c_unary_expression
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|e
parameter_list|)
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|e
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PREINCREMENT_EXPR
case|:
case|case
name|PREDECREMENT_EXPR
case|:
name|pp_identifier
argument_list|(
name|pp
argument_list|,
name|code
operator|==
name|PREINCREMENT_EXPR
condition|?
literal|"++"
else|:
literal|"--"
argument_list|)
expr_stmt|;
name|pp_c_unary_expression
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ADDR_EXPR
case|:
case|case
name|INDIRECT_REF
case|:
case|case
name|NEGATE_EXPR
case|:
case|case
name|BIT_NOT_EXPR
case|:
case|case
name|TRUTH_NOT_EXPR
case|:
case|case
name|CONJ_EXPR
case|:
comment|/* String literal are used by address.  */
if|if
condition|(
name|code
operator|==
name|ADDR_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|STRING_CST
condition|)
name|pp_ampersand
argument_list|(
name|pp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|INDIRECT_REF
condition|)
name|pp_c_star
argument_list|(
name|pp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|NEGATE_EXPR
condition|)
name|pp_minus
argument_list|(
name|pp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|BIT_NOT_EXPR
operator|||
name|code
operator|==
name|CONJ_EXPR
condition|)
name|pp_complement
argument_list|(
name|pp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|TRUTH_NOT_EXPR
condition|)
name|pp_exclamation
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_c_cast_expression
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIZEOF_EXPR
case|:
case|case
name|ALIGNOF_EXPR
case|:
name|pp_c_identifier
argument_list|(
name|pp
argument_list|,
name|code
operator|==
name|SIZEOF_EXPR
condition|?
literal|"sizeof"
else|:
literal|"__alignof__"
argument_list|)
expr_stmt|;
name|pp_c_whitespace
argument_list|(
name|pp
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_P
argument_list|(
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|pp_c_type_cast
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|pp_unary_expression
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|REALPART_EXPR
case|:
case|case
name|IMAGPART_EXPR
case|:
name|pp_c_identifier
argument_list|(
name|pp
argument_list|,
name|code
operator|==
name|REALPART_EXPR
condition|?
literal|"__real__"
else|:
literal|"__imag__"
argument_list|)
expr_stmt|;
name|pp_c_whitespace
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_unary_expression
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|pp_postfix_expression
argument_list|(
name|pp
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* cast-expression:       unary-expression       ( type-name ) cast-expression  */
end_comment

begin_function
name|void
name|pp_c_cast_expression
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|e
parameter_list|)
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|e
argument_list|)
condition|)
block|{
case|case
name|FLOAT_EXPR
case|:
case|case
name|FIX_TRUNC_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
name|pp_c_type_cast
argument_list|(
name|pp
argument_list|,
name|TREE_TYPE
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
name|pp_c_cast_expression
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|pp_unary_expression
argument_list|(
name|pp
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* multiplicative-expression:       cast-expression       multiplicative-expression * cast-expression       multiplicative-expression / cast-expression       multiplicative-expression % cast-expression   */
end_comment

begin_function
specifier|static
name|void
name|pp_c_multiplicative_expression
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|e
parameter_list|)
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|e
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|MULT_EXPR
case|:
case|case
name|TRUNC_DIV_EXPR
case|:
case|case
name|TRUNC_MOD_EXPR
case|:
name|pp_multiplicative_expression
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|pp_c_whitespace
argument_list|(
name|pp
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|MULT_EXPR
condition|)
name|pp_c_star
argument_list|(
name|pp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|TRUNC_DIV_EXPR
condition|)
name|pp_slash
argument_list|(
name|pp
argument_list|)
expr_stmt|;
else|else
name|pp_modulo
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_c_whitespace
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_c_cast_expression
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|pp_c_cast_expression
argument_list|(
name|pp
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* additive-expression:       multiplicative-expression       additive-expression + multiplicative-expression       additive-expression - multiplicative-expression   */
end_comment

begin_function
specifier|static
name|void
name|pp_c_additive_expression
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|e
parameter_list|)
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|e
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PLUS_EXPR
case|:
case|case
name|MINUS_EXPR
case|:
name|pp_c_additive_expression
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|pp_c_whitespace
argument_list|(
name|pp
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|PLUS_EXPR
condition|)
name|pp_plus
argument_list|(
name|pp
argument_list|)
expr_stmt|;
else|else
name|pp_minus
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_c_whitespace
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_multiplicative_expression
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|pp_multiplicative_expression
argument_list|(
name|pp
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* additive-expression:       additive-expression       shift-expression<< additive-expression       shift-expression>> additive-expression   */
end_comment

begin_function
specifier|static
name|void
name|pp_c_shift_expression
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|e
parameter_list|)
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|e
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|LSHIFT_EXPR
case|:
case|case
name|RSHIFT_EXPR
case|:
name|pp_c_shift_expression
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|pp_c_whitespace
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_identifier
argument_list|(
name|pp
argument_list|,
name|code
operator|==
name|LSHIFT_EXPR
condition|?
literal|"<<"
else|:
literal|">>"
argument_list|)
expr_stmt|;
name|pp_c_whitespace
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_c_additive_expression
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|pp_c_additive_expression
argument_list|(
name|pp
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* relational-expression:       shift-expression       relational-expression< shift-expression       relational-expression> shift-expression       relational-expression<= shift-expression       relational-expression>= shift-expression   */
end_comment

begin_function
specifier|static
name|void
name|pp_c_relational_expression
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|e
parameter_list|)
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|e
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|LT_EXPR
case|:
case|case
name|GT_EXPR
case|:
case|case
name|LE_EXPR
case|:
case|case
name|GE_EXPR
case|:
name|pp_c_relational_expression
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|pp_c_whitespace
argument_list|(
name|pp
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|LT_EXPR
condition|)
name|pp_less
argument_list|(
name|pp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|GT_EXPR
condition|)
name|pp_greater
argument_list|(
name|pp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|LE_EXPR
condition|)
name|pp_identifier
argument_list|(
name|pp
argument_list|,
literal|"<="
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|GE_EXPR
condition|)
name|pp_identifier
argument_list|(
name|pp
argument_list|,
literal|">="
argument_list|)
expr_stmt|;
name|pp_c_whitespace
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_c_shift_expression
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|pp_c_shift_expression
argument_list|(
name|pp
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* equality-expression:       relational-expression       equality-expression == relational-expression       equality-equality != relational-expression  */
end_comment

begin_function
specifier|static
name|void
name|pp_c_equality_expression
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|e
parameter_list|)
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|e
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|EQ_EXPR
case|:
case|case
name|NE_EXPR
case|:
name|pp_c_equality_expression
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|pp_c_whitespace
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_identifier
argument_list|(
name|pp
argument_list|,
name|code
operator|==
name|EQ_EXPR
condition|?
literal|"=="
else|:
literal|"!="
argument_list|)
expr_stmt|;
name|pp_c_whitespace
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_c_relational_expression
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|pp_c_relational_expression
argument_list|(
name|pp
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* AND-expression:       equality-expression       AND-expression& equality-equality   */
end_comment

begin_function
specifier|static
name|void
name|pp_c_and_expression
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|e
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|e
argument_list|)
operator|==
name|BIT_AND_EXPR
condition|)
block|{
name|pp_c_and_expression
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|pp_c_whitespace
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_ampersand
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_c_whitespace
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_c_equality_expression
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|pp_c_equality_expression
argument_list|(
name|pp
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* exclusive-OR-expression:      AND-expression      exclusive-OR-expression ^ AND-expression  */
end_comment

begin_function
specifier|static
name|void
name|pp_c_exclusive_or_expression
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|e
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|e
argument_list|)
operator|==
name|BIT_XOR_EXPR
condition|)
block|{
name|pp_c_exclusive_or_expression
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|pp_c_maybe_whitespace
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_carret
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_c_whitespace
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_c_and_expression
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|pp_c_and_expression
argument_list|(
name|pp
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* inclusive-OR-expression:      exclusive-OR-expression      inclusive-OR-expression | exclusive-OR-expression  */
end_comment

begin_function
specifier|static
name|void
name|pp_c_inclusive_or_expression
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|e
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|e
argument_list|)
operator|==
name|BIT_IOR_EXPR
condition|)
block|{
name|pp_c_exclusive_or_expression
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|pp_c_whitespace
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_bar
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_c_whitespace
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_c_exclusive_or_expression
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|pp_c_exclusive_or_expression
argument_list|(
name|pp
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* logical-AND-expression:       inclusive-OR-expression       logical-AND-expression&& inclusive-OR-expression  */
end_comment

begin_function
specifier|static
name|void
name|pp_c_logical_and_expression
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|e
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|e
argument_list|)
operator|==
name|TRUTH_ANDIF_EXPR
condition|)
block|{
name|pp_c_logical_and_expression
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|pp_c_whitespace
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_identifier
argument_list|(
name|pp
argument_list|,
literal|"&&"
argument_list|)
expr_stmt|;
name|pp_c_whitespace
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_c_inclusive_or_expression
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|pp_c_inclusive_or_expression
argument_list|(
name|pp
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* logical-OR-expression:       logical-AND-expression       logical-OR-expression || logical-AND-expression  */
end_comment

begin_function
name|void
name|pp_c_logical_or_expression
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|e
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|e
argument_list|)
operator|==
name|TRUTH_ORIF_EXPR
condition|)
block|{
name|pp_c_logical_or_expression
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|pp_c_whitespace
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_identifier
argument_list|(
name|pp
argument_list|,
literal|"||"
argument_list|)
expr_stmt|;
name|pp_c_whitespace
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_c_logical_and_expression
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|pp_c_logical_and_expression
argument_list|(
name|pp
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* conditional-expression:       logical-OR-expression       logical-OR-expression ? expression : conditional-expression  */
end_comment

begin_function
specifier|static
name|void
name|pp_c_conditional_expression
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|e
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|e
argument_list|)
operator|==
name|COND_EXPR
condition|)
block|{
name|pp_c_logical_or_expression
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|pp_c_whitespace
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_question
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_c_whitespace
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_expression
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|pp_c_whitespace
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_colon
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_c_whitespace
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_c_conditional_expression
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|pp_c_logical_or_expression
argument_list|(
name|pp
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* assignment-expression:       conditional-expression       unary-expression assignment-operator  assignment-expression      assignment-expression: one of       =    *=    /=    %=    +=    -=>>=<<=&=    ^=    |=  */
end_comment

begin_function
specifier|static
name|void
name|pp_c_assignment_expression
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|e
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|e
argument_list|)
operator|==
name|MODIFY_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|e
argument_list|)
operator|==
name|INIT_EXPR
condition|)
block|{
name|pp_c_unary_expression
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|pp_c_whitespace
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_equal
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_space
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_c_expression
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|pp_c_conditional_expression
argument_list|(
name|pp
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* expression:        assignment-expression        expression , assignment-expression    Implementation note:  instead of going through the usual recursion   chain, I take the liberty of dispatching nodes to the appropriate   functions.  This makes some redundancy, but it worths it. That also   prevents a possible infinite recursion between pp_c_primary_expression ()   and pp_c_expression ().  */
end_comment

begin_function
name|void
name|pp_c_expression
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|e
parameter_list|)
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|e
argument_list|)
condition|)
block|{
case|case
name|INTEGER_CST
case|:
name|pp_c_integer_constant
argument_list|(
name|pp
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|REAL_CST
case|:
name|pp_c_floating_constant
argument_list|(
name|pp
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|STRING_CST
case|:
name|pp_c_string_literal
argument_list|(
name|pp
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|IDENTIFIER_NODE
case|:
case|case
name|FUNCTION_DECL
case|:
case|case
name|VAR_DECL
case|:
case|case
name|CONST_DECL
case|:
case|case
name|PARM_DECL
case|:
case|case
name|RESULT_DECL
case|:
case|case
name|FIELD_DECL
case|:
case|case
name|LABEL_DECL
case|:
case|case
name|ERROR_MARK
case|:
case|case
name|STMT_EXPR
case|:
name|pp_primary_expression
argument_list|(
name|pp
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|POSTINCREMENT_EXPR
case|:
case|case
name|POSTDECREMENT_EXPR
case|:
case|case
name|ARROW_EXPR
case|:
case|case
name|ARRAY_REF
case|:
case|case
name|CALL_EXPR
case|:
case|case
name|COMPONENT_REF
case|:
case|case
name|COMPLEX_CST
case|:
case|case
name|COMPLEX_EXPR
case|:
case|case
name|VECTOR_CST
case|:
case|case
name|ABS_EXPR
case|:
case|case
name|CONSTRUCTOR
case|:
case|case
name|COMPOUND_LITERAL_EXPR
case|:
case|case
name|VA_ARG_EXPR
case|:
name|pp_postfix_expression
argument_list|(
name|pp
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONJ_EXPR
case|:
case|case
name|ADDR_EXPR
case|:
case|case
name|INDIRECT_REF
case|:
case|case
name|NEGATE_EXPR
case|:
case|case
name|BIT_NOT_EXPR
case|:
case|case
name|TRUTH_NOT_EXPR
case|:
case|case
name|PREINCREMENT_EXPR
case|:
case|case
name|PREDECREMENT_EXPR
case|:
case|case
name|SIZEOF_EXPR
case|:
case|case
name|ALIGNOF_EXPR
case|:
case|case
name|REALPART_EXPR
case|:
case|case
name|IMAGPART_EXPR
case|:
name|pp_c_unary_expression
argument_list|(
name|pp
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|FLOAT_EXPR
case|:
case|case
name|FIX_TRUNC_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
name|pp_c_cast_expression
argument_list|(
name|pp
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|MULT_EXPR
case|:
case|case
name|TRUNC_MOD_EXPR
case|:
case|case
name|TRUNC_DIV_EXPR
case|:
name|pp_multiplicative_expression
argument_list|(
name|pp
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|LSHIFT_EXPR
case|:
case|case
name|RSHIFT_EXPR
case|:
name|pp_c_shift_expression
argument_list|(
name|pp
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|LT_EXPR
case|:
case|case
name|GT_EXPR
case|:
case|case
name|LE_EXPR
case|:
case|case
name|GE_EXPR
case|:
name|pp_c_relational_expression
argument_list|(
name|pp
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|BIT_AND_EXPR
case|:
name|pp_c_and_expression
argument_list|(
name|pp
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|BIT_XOR_EXPR
case|:
name|pp_c_exclusive_or_expression
argument_list|(
name|pp
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|BIT_IOR_EXPR
case|:
name|pp_c_inclusive_or_expression
argument_list|(
name|pp
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|TRUTH_ANDIF_EXPR
case|:
name|pp_c_logical_and_expression
argument_list|(
name|pp
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|TRUTH_ORIF_EXPR
case|:
name|pp_c_logical_or_expression
argument_list|(
name|pp
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|EQ_EXPR
case|:
case|case
name|NE_EXPR
case|:
name|pp_c_equality_expression
argument_list|(
name|pp
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|COND_EXPR
case|:
name|pp_conditional_expression
argument_list|(
name|pp
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|PLUS_EXPR
case|:
case|case
name|MINUS_EXPR
case|:
name|pp_c_additive_expression
argument_list|(
name|pp
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|MODIFY_EXPR
case|:
case|case
name|INIT_EXPR
case|:
name|pp_assignment_expression
argument_list|(
name|pp
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|COMPOUND_EXPR
case|:
name|pp_c_left_paren
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_expression
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|pp_separate_with
argument_list|(
name|pp
argument_list|,
literal|','
argument_list|)
expr_stmt|;
name|pp_assignment_expression
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|pp_c_right_paren
argument_list|(
name|pp
argument_list|)
expr_stmt|;
break|break;
case|case
name|NOP_EXPR
case|:
case|case
name|NON_LVALUE_EXPR
case|:
case|case
name|SAVE_EXPR
case|:
case|case
name|UNSAVE_EXPR
case|:
name|pp_expression
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TARGET_EXPR
case|:
name|pp_postfix_expression
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|pp_unsupported_tree
argument_list|(
name|pp
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Statements.  */
end_comment

begin_comment
comment|/* statement:       labeled-statement       compound-statement       expression-statement       selection-statement       iteration-statement       jump-statement   */
end_comment

begin_function
name|void
name|pp_c_statement
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|stmt
parameter_list|)
block|{
name|enum
name|tree_code
name|code
decl_stmt|;
if|if
condition|(
name|stmt
operator|==
name|NULL
condition|)
return|return;
name|code
operator|=
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
comment|/* labeled-statement:              identifier : statement              case constant-expression : statement              default : statement   */
case|case
name|LABEL_STMT
case|:
case|case
name|CASE_LABEL
case|:
if|if
condition|(
name|pp_needs_newline
argument_list|(
name|pp
argument_list|)
condition|)
name|pp_newline_and_indent
argument_list|(
name|pp
argument_list|,
operator|-
literal|3
argument_list|)
expr_stmt|;
else|else
name|pp_indentation
argument_list|(
name|pp
argument_list|)
operator|-=
literal|3
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|LABEL_STMT
condition|)
name|pp_tree_identifier
argument_list|(
name|pp
argument_list|,
name|DECL_NAME
argument_list|(
name|LABEL_STMT_LABEL
argument_list|(
name|stmt
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|CASE_LABEL
condition|)
block|{
if|if
condition|(
name|CASE_LOW
argument_list|(
name|stmt
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|pp_identifier
argument_list|(
name|pp
argument_list|,
literal|"default"
argument_list|)
expr_stmt|;
else|else
block|{
name|pp_c_identifier
argument_list|(
name|pp
argument_list|,
literal|"case"
argument_list|)
expr_stmt|;
name|pp_c_whitespace
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_conditional_expression
argument_list|(
name|pp
argument_list|,
name|CASE_LOW
argument_list|(
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|CASE_HIGH
argument_list|(
name|stmt
argument_list|)
condition|)
block|{
name|pp_identifier
argument_list|(
name|pp
argument_list|,
literal|"..."
argument_list|)
expr_stmt|;
name|pp_conditional_expression
argument_list|(
name|pp
argument_list|,
name|CASE_HIGH
argument_list|(
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|pp_colon
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_indentation
argument_list|(
name|pp
argument_list|)
operator|+=
literal|3
expr_stmt|;
name|pp_needs_newline
argument_list|(
name|pp
argument_list|)
operator|=
name|true
expr_stmt|;
break|break;
comment|/* compound-statement:             {  block-item-list(opt) }           block-item-list:             block-item             block-item-list block-item           block-item:             declaration             statement   */
case|case
name|COMPOUND_STMT
case|:
if|if
condition|(
name|pp_needs_newline
argument_list|(
name|pp
argument_list|)
condition|)
name|pp_newline_and_indent
argument_list|(
name|pp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pp_c_left_brace
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_newline_and_indent
argument_list|(
name|pp
argument_list|,
literal|3
argument_list|)
expr_stmt|;
for|for
control|(
name|stmt
operator|=
name|COMPOUND_BODY
argument_list|(
name|stmt
argument_list|)
init|;
name|stmt
condition|;
name|stmt
operator|=
name|TREE_CHAIN
argument_list|(
name|stmt
argument_list|)
control|)
name|pp_statement
argument_list|(
name|pp
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
name|pp_newline_and_indent
argument_list|(
name|pp
argument_list|,
operator|-
literal|3
argument_list|)
expr_stmt|;
name|pp_c_right_brace
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_needs_newline
argument_list|(
name|pp
argument_list|)
operator|=
name|true
expr_stmt|;
break|break;
comment|/* expression-statement:             expression(opt) ;  */
case|case
name|EXPR_STMT
case|:
case|case
name|CLEANUP_STMT
case|:
if|if
condition|(
name|pp_needs_newline
argument_list|(
name|pp
argument_list|)
condition|)
name|pp_newline_and_indent
argument_list|(
name|pp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|{
name|tree
name|e
init|=
name|code
operator|==
name|EXPR_STMT
condition|?
name|EXPR_STMT_EXPR
argument_list|(
name|stmt
argument_list|)
else|:
name|CLEANUP_EXPR
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
if|if
condition|(
name|e
condition|)
name|pp_expression
argument_list|(
name|pp
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|pp_c_semicolon
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_needs_newline
argument_list|(
name|pp
argument_list|)
operator|=
name|true
expr_stmt|;
break|break;
comment|/* selection-statement:             if ( expression ) statement             if ( expression ) statement else statement             switch ( expression ) statement   */
case|case
name|IF_STMT
case|:
if|if
condition|(
name|pp_needs_newline
argument_list|(
name|pp
argument_list|)
condition|)
name|pp_newline_and_indent
argument_list|(
name|pp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pp_c_identifier
argument_list|(
name|pp
argument_list|,
literal|"if"
argument_list|)
expr_stmt|;
name|pp_c_whitespace
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_c_left_paren
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_expression
argument_list|(
name|pp
argument_list|,
name|IF_COND
argument_list|(
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
name|pp_c_right_paren
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_newline_and_indent
argument_list|(
name|pp
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|pp_statement
argument_list|(
name|pp
argument_list|,
name|THEN_CLAUSE
argument_list|(
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
name|pp_newline_and_indent
argument_list|(
name|pp
argument_list|,
operator|-
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|ELSE_CLAUSE
argument_list|(
name|stmt
argument_list|)
condition|)
block|{
name|tree
name|else_clause
init|=
name|ELSE_CLAUSE
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
name|pp_c_identifier
argument_list|(
name|pp
argument_list|,
literal|"else"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|else_clause
argument_list|)
operator|==
name|IF_STMT
condition|)
name|pp_c_whitespace
argument_list|(
name|pp
argument_list|)
expr_stmt|;
else|else
name|pp_newline_and_indent
argument_list|(
name|pp
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|pp_statement
argument_list|(
name|pp
argument_list|,
name|else_clause
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|else_clause
argument_list|)
operator|!=
name|IF_STMT
condition|)
name|pp_newline_and_indent
argument_list|(
name|pp
argument_list|,
operator|-
literal|3
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SWITCH_STMT
case|:
if|if
condition|(
name|pp_needs_newline
argument_list|(
name|pp
argument_list|)
condition|)
name|pp_newline_and_indent
argument_list|(
name|pp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pp_c_identifier
argument_list|(
name|pp
argument_list|,
literal|"switch"
argument_list|)
expr_stmt|;
name|pp_space
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_c_left_paren
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_expression
argument_list|(
name|pp
argument_list|,
name|SWITCH_COND
argument_list|(
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
name|pp_c_right_paren
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_indentation
argument_list|(
name|pp
argument_list|)
operator|+=
literal|3
expr_stmt|;
name|pp_needs_newline
argument_list|(
name|pp
argument_list|)
operator|=
name|true
expr_stmt|;
name|pp_statement
argument_list|(
name|pp
argument_list|,
name|SWITCH_BODY
argument_list|(
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
name|pp_newline_and_indent
argument_list|(
name|pp
argument_list|,
operator|-
literal|3
argument_list|)
expr_stmt|;
break|break;
comment|/* iteration-statement:             while ( expression ) statement             do statement while ( expression ) ;             for ( expression(opt) ; expression(opt) ; expression(opt) ) statement             for ( declaration expression(opt) ; expression(opt) ) statement  */
case|case
name|WHILE_STMT
case|:
if|if
condition|(
name|pp_needs_newline
argument_list|(
name|pp
argument_list|)
condition|)
name|pp_newline_and_indent
argument_list|(
name|pp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pp_c_identifier
argument_list|(
name|pp
argument_list|,
literal|"while"
argument_list|)
expr_stmt|;
name|pp_space
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_c_left_paren
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_expression
argument_list|(
name|pp
argument_list|,
name|WHILE_COND
argument_list|(
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
name|pp_c_right_paren
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_newline_and_indent
argument_list|(
name|pp
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|pp_statement
argument_list|(
name|pp
argument_list|,
name|WHILE_BODY
argument_list|(
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
name|pp_indentation
argument_list|(
name|pp
argument_list|)
operator|-=
literal|3
expr_stmt|;
name|pp_needs_newline
argument_list|(
name|pp
argument_list|)
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|DO_STMT
case|:
if|if
condition|(
name|pp_needs_newline
argument_list|(
name|pp
argument_list|)
condition|)
name|pp_newline_and_indent
argument_list|(
name|pp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pp_c_identifier
argument_list|(
name|pp
argument_list|,
literal|"do"
argument_list|)
expr_stmt|;
name|pp_newline_and_indent
argument_list|(
name|pp
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|pp_statement
argument_list|(
name|pp
argument_list|,
name|DO_BODY
argument_list|(
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
name|pp_newline_and_indent
argument_list|(
name|pp
argument_list|,
operator|-
literal|3
argument_list|)
expr_stmt|;
name|pp_c_identifier
argument_list|(
name|pp
argument_list|,
literal|"while"
argument_list|)
expr_stmt|;
name|pp_space
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_c_left_paren
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_expression
argument_list|(
name|pp
argument_list|,
name|DO_COND
argument_list|(
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
name|pp_c_right_paren
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_c_semicolon
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_needs_newline
argument_list|(
name|pp
argument_list|)
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|FOR_STMT
case|:
if|if
condition|(
name|pp_needs_newline
argument_list|(
name|pp
argument_list|)
condition|)
name|pp_newline_and_indent
argument_list|(
name|pp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pp_c_identifier
argument_list|(
name|pp
argument_list|,
literal|"for"
argument_list|)
expr_stmt|;
name|pp_space
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_c_left_paren
argument_list|(
name|pp
argument_list|)
expr_stmt|;
if|if
condition|(
name|FOR_INIT_STMT
argument_list|(
name|stmt
argument_list|)
condition|)
name|pp_statement
argument_list|(
name|pp
argument_list|,
name|FOR_INIT_STMT
argument_list|(
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|pp_c_semicolon
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_needs_newline
argument_list|(
name|pp
argument_list|)
operator|=
name|false
expr_stmt|;
name|pp_c_whitespace
argument_list|(
name|pp
argument_list|)
expr_stmt|;
if|if
condition|(
name|FOR_COND
argument_list|(
name|stmt
argument_list|)
condition|)
name|pp_expression
argument_list|(
name|pp
argument_list|,
name|FOR_COND
argument_list|(
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
name|pp_c_semicolon
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_needs_newline
argument_list|(
name|pp
argument_list|)
operator|=
name|false
expr_stmt|;
name|pp_c_whitespace
argument_list|(
name|pp
argument_list|)
expr_stmt|;
if|if
condition|(
name|FOR_EXPR
argument_list|(
name|stmt
argument_list|)
condition|)
name|pp_expression
argument_list|(
name|pp
argument_list|,
name|FOR_EXPR
argument_list|(
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
name|pp_c_right_paren
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_newline_and_indent
argument_list|(
name|pp
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|pp_statement
argument_list|(
name|pp
argument_list|,
name|FOR_BODY
argument_list|(
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
name|pp_indentation
argument_list|(
name|pp
argument_list|)
operator|-=
literal|3
expr_stmt|;
name|pp_needs_newline
argument_list|(
name|pp
argument_list|)
operator|=
name|true
expr_stmt|;
break|break;
comment|/* jump-statement:             goto identifier;             continue ;             return expression(opt) ;  */
case|case
name|BREAK_STMT
case|:
case|case
name|CONTINUE_STMT
case|:
if|if
condition|(
name|pp_needs_newline
argument_list|(
name|pp
argument_list|)
condition|)
name|pp_newline_and_indent
argument_list|(
name|pp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pp_identifier
argument_list|(
name|pp
argument_list|,
name|code
operator|==
name|BREAK_STMT
condition|?
literal|"break"
else|:
literal|"continue"
argument_list|)
expr_stmt|;
name|pp_c_semicolon
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_needs_newline
argument_list|(
name|pp
argument_list|)
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|RETURN_STMT
case|:
case|case
name|GOTO_STMT
case|:
block|{
name|tree
name|e
init|=
name|code
operator|==
name|RETURN_STMT
condition|?
name|RETURN_STMT_EXPR
argument_list|(
name|stmt
argument_list|)
else|:
name|GOTO_DESTINATION
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
if|if
condition|(
name|pp_needs_newline
argument_list|(
name|pp
argument_list|)
condition|)
name|pp_newline_and_indent
argument_list|(
name|pp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pp_c_identifier
argument_list|(
name|pp
argument_list|,
name|code
operator|==
name|RETURN_STMT
condition|?
literal|"return"
else|:
literal|"goto"
argument_list|)
expr_stmt|;
name|pp_c_whitespace
argument_list|(
name|pp
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|e
argument_list|)
operator|==
name|INIT_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|RESULT_DECL
condition|)
name|e
operator|=
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pp_expression
argument_list|(
name|pp
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|pp_c_semicolon
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_needs_newline
argument_list|(
name|pp
argument_list|)
operator|=
name|true
expr_stmt|;
block|}
break|break;
case|case
name|SCOPE_STMT
case|:
if|if
condition|(
operator|!
name|SCOPE_NULLIFIED_P
argument_list|(
name|stmt
argument_list|)
operator|&&
name|SCOPE_NO_CLEANUPS_P
argument_list|(
name|stmt
argument_list|)
condition|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|pp_needs_newline
argument_list|(
name|pp
argument_list|)
condition|)
name|pp_newline_and_indent
argument_list|(
name|pp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|SCOPE_BEGIN_P
argument_list|(
name|stmt
argument_list|)
condition|)
block|{
name|pp_left_brace
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|i
operator|=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|SCOPE_END_P
argument_list|(
name|stmt
argument_list|)
condition|)
block|{
name|pp_right_brace
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|i
operator|=
operator|-
literal|3
expr_stmt|;
block|}
name|pp_indentation
argument_list|(
name|pp
argument_list|)
operator|+=
name|i
expr_stmt|;
name|pp_needs_newline
argument_list|(
name|pp
argument_list|)
operator|=
name|true
expr_stmt|;
block|}
break|break;
case|case
name|DECL_STMT
case|:
if|if
condition|(
name|pp_needs_newline
argument_list|(
name|pp
argument_list|)
condition|)
name|pp_newline_and_indent
argument_list|(
name|pp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pp_declaration
argument_list|(
name|pp
argument_list|,
name|DECL_STMT_DECL
argument_list|(
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
name|pp_needs_newline
argument_list|(
name|pp
argument_list|)
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|ASM_STMT
case|:
block|{
name|bool
name|has_volatile_p
init|=
name|ASM_VOLATILE_P
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
name|bool
name|is_extended
init|=
name|has_volatile_p
operator|||
name|ASM_INPUTS
argument_list|(
name|stmt
argument_list|)
operator|||
name|ASM_OUTPUTS
argument_list|(
name|stmt
argument_list|)
operator|||
name|ASM_CLOBBERS
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
name|pp_c_identifier
argument_list|(
name|pp
argument_list|,
name|is_extended
condition|?
literal|"__asm__"
else|:
literal|"asm"
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_volatile_p
condition|)
name|pp_c_identifier
argument_list|(
name|pp
argument_list|,
literal|"__volatile__"
argument_list|)
expr_stmt|;
name|pp_space
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_c_left_paren
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_c_string_literal
argument_list|(
name|pp
argument_list|,
name|ASM_STRING
argument_list|(
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_extended
condition|)
block|{
name|pp_space
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_separate_with
argument_list|(
name|pp
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|ASM_OUTPUTS
argument_list|(
name|stmt
argument_list|)
condition|)
name|pp_expression
argument_list|(
name|pp
argument_list|,
name|ASM_OUTPUTS
argument_list|(
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
name|pp_space
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_separate_with
argument_list|(
name|pp
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|ASM_INPUTS
argument_list|(
name|stmt
argument_list|)
condition|)
name|pp_expression
argument_list|(
name|pp
argument_list|,
name|ASM_INPUTS
argument_list|(
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
name|pp_space
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_separate_with
argument_list|(
name|pp
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|ASM_CLOBBERS
argument_list|(
name|stmt
argument_list|)
condition|)
name|pp_expression
argument_list|(
name|pp
argument_list|,
name|ASM_CLOBBERS
argument_list|(
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|pp_c_right_paren
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_newline
argument_list|(
name|pp
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|FILE_STMT
case|:
name|pp_c_identifier
argument_list|(
name|pp
argument_list|,
literal|"__FILE__"
argument_list|)
expr_stmt|;
name|pp_space
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_equal
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_c_whitespace
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_c_identifier
argument_list|(
name|pp
argument_list|,
name|FILE_STMT_FILENAME
argument_list|(
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
name|pp_c_semicolon
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_needs_newline
argument_list|(
name|pp
argument_list|)
operator|=
name|true
expr_stmt|;
break|break;
default|default:
name|pp_unsupported_tree
argument_list|(
name|pp
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Initialize the PRETTY-PRINTER for handling C codes.  */
end_comment

begin_function
name|void
name|pp_c_pretty_printer_init
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|)
block|{
name|pp
operator|->
name|offset_list
operator|=
literal|0
expr_stmt|;
name|pp
operator|->
name|declaration
operator|=
name|pp_c_declaration
expr_stmt|;
name|pp
operator|->
name|declaration_specifiers
operator|=
name|pp_c_declaration_specifiers
expr_stmt|;
name|pp
operator|->
name|declarator
operator|=
name|pp_c_declarator
expr_stmt|;
name|pp
operator|->
name|direct_declarator
operator|=
name|pp_c_direct_declarator
expr_stmt|;
name|pp
operator|->
name|type_specifier_seq
operator|=
name|pp_c_specifier_qualifier_list
expr_stmt|;
name|pp
operator|->
name|abstract_declarator
operator|=
name|pp_c_abstract_declarator
expr_stmt|;
name|pp
operator|->
name|direct_abstract_declarator
operator|=
name|pp_c_direct_abstract_declarator
expr_stmt|;
name|pp
operator|->
name|ptr_operator
operator|=
name|pp_c_pointer
expr_stmt|;
name|pp
operator|->
name|parameter_list
operator|=
name|pp_c_parameter_type_list
expr_stmt|;
name|pp
operator|->
name|type_id
operator|=
name|pp_c_type_id
expr_stmt|;
name|pp
operator|->
name|simple_type_specifier
operator|=
name|pp_c_type_specifier
expr_stmt|;
name|pp
operator|->
name|function_specifier
operator|=
name|pp_c_function_specifier
expr_stmt|;
name|pp
operator|->
name|storage_class_specifier
operator|=
name|pp_c_storage_class_specifier
expr_stmt|;
name|pp
operator|->
name|statement
operator|=
name|pp_c_statement
expr_stmt|;
name|pp
operator|->
name|id_expression
operator|=
name|pp_c_id_expression
expr_stmt|;
name|pp
operator|->
name|primary_expression
operator|=
name|pp_c_primary_expression
expr_stmt|;
name|pp
operator|->
name|postfix_expression
operator|=
name|pp_c_postfix_expression
expr_stmt|;
name|pp
operator|->
name|unary_expression
operator|=
name|pp_c_unary_expression
expr_stmt|;
name|pp
operator|->
name|initializer
operator|=
name|pp_c_initializer
expr_stmt|;
name|pp
operator|->
name|multiplicative_expression
operator|=
name|pp_c_multiplicative_expression
expr_stmt|;
name|pp
operator|->
name|conditional_expression
operator|=
name|pp_c_conditional_expression
expr_stmt|;
name|pp
operator|->
name|assignment_expression
operator|=
name|pp_c_assignment_expression
expr_stmt|;
name|pp
operator|->
name|expression
operator|=
name|pp_c_expression
expr_stmt|;
block|}
end_function

end_unit

