begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Output sdb-format symbol table information from GNU compiler.    Copyright (C) 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,    2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/*  mike@tredysvr.Tredydev.Unisys.COM says: I modified the struct.c example and have a nm of a .o resulting from the AT&T C compiler.  From the example below I would conclude the following:  1. All .defs from structures are emitted as scanned.  The example below    clearly shows the symbol table entries for BoxRec2 are after the first    function.  2. All functions and their locals (including statics) are emitted as scanned.  3. All nested unnamed union and structure .defs must be emitted before    the structure in which they are nested.  The AT&T assembler is a    one pass beast as far as symbolics are concerned.  4. All structure .defs are emitted before the typedefs that refer to them.  5. All top level static and external variable definitions are moved to the    end of file with all top level statics occurring first before externs.  6. All undefined references are at the end of the file. */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"debug.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|tree
name|anonymous_types
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Counter for sdbout_source_line.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|int
name|sdbout_source_line_counter
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Counter to generate unique "names" for nameless struct members.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|int
name|unnamed_struct_number
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|SDB_DEBUGGING_INFO
end_ifdef

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"reload.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"gsyms.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_comment
comment|/* 1 if PARM is passed to this function in memory.  */
end_comment

begin_define
define|#
directive|define
name|PARM_PASSED_IN_MEMORY
parameter_list|(
name|PARM
parameter_list|)
define|\
value|(GET_CODE (DECL_INCOMING_RTL (PARM)) == MEM)
end_define

begin_comment
comment|/* A C expression for the integer offset value of an automatic variable    (C_AUTO) having address X (an RTX).  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DEBUGGER_AUTO_OFFSET
end_ifndef

begin_define
define|#
directive|define
name|DEBUGGER_AUTO_OFFSET
parameter_list|(
name|X
parameter_list|)
define|\
value|(GET_CODE (X) == PLUS ? INTVAL (XEXP (X, 1)) : 0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* A C expression for the integer offset value of an argument (C_ARG)    having address X (an RTX).  The nominal offset is OFFSET.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DEBUGGER_ARG_OFFSET
end_ifndef

begin_define
define|#
directive|define
name|DEBUGGER_ARG_OFFSET
parameter_list|(
name|OFFSET
parameter_list|,
name|X
parameter_list|)
value|(OFFSET)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Line number of beginning of current function, minus one.    Negative means not in a function or not using sdb.  */
end_comment

begin_decl_stmt
name|int
name|sdb_begin_function_line
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|FILE
modifier|*
name|asm_out_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|tree
name|current_function_decl
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|"sdbout.h"
end_include

begin_function_decl
specifier|static
name|void
name|sdbout_init
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sdbout_finish
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sdbout_start_source_file
parameter_list|(
name|unsigned
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sdbout_end_source_file
parameter_list|(
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sdbout_begin_block
parameter_list|(
name|unsigned
name|int
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sdbout_end_block
parameter_list|(
name|unsigned
name|int
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sdbout_source_line
parameter_list|(
name|unsigned
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sdbout_end_epilogue
parameter_list|(
name|unsigned
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sdbout_global_decl
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|MIPS_DEBUGGING_INFO
end_ifndef

begin_function_decl
specifier|static
name|void
name|sdbout_begin_prologue
parameter_list|(
name|unsigned
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|sdbout_end_prologue
parameter_list|(
name|unsigned
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sdbout_begin_function
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sdbout_end_function
parameter_list|(
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sdbout_toplevel_data
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sdbout_label
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|gen_fake_label
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|plain_type
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|template_name_p
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sdbout_record_type_name
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|plain_type_1
parameter_list|(
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sdbout_block
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sdbout_syms
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|SDB_ALLOW_FORWARD_REFERENCES
end_ifdef

begin_function_decl
specifier|static
name|void
name|sdbout_queue_anonymous_type
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sdbout_dequeue_anonymous_types
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|sdbout_type
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sdbout_field_types
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sdbout_one_type
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sdbout_parms
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sdbout_reg_parms
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sdbout_global_decl
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Random macros describing parts of SDB data.  */
end_comment

begin_comment
comment|/* Default value of delimiter is ";".  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SDB_DELIM
end_ifndef

begin_define
define|#
directive|define
name|SDB_DELIM
value|";"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Maximum number of dimensions the assembler will allow.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SDB_MAX_DIM
end_ifndef

begin_define
define|#
directive|define
name|SDB_MAX_DIM
value|4
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PUT_SDB_SCL
end_ifndef

begin_define
define|#
directive|define
name|PUT_SDB_SCL
parameter_list|(
name|a
parameter_list|)
value|fprintf(asm_out_file, "\t.scl\t%d%s", (a), SDB_DELIM)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PUT_SDB_INT_VAL
end_ifndef

begin_define
define|#
directive|define
name|PUT_SDB_INT_VAL
parameter_list|(
name|a
parameter_list|)
define|\
value|do {									\    fprintf (asm_out_file, "\t.val\t" HOST_WIDE_INT_PRINT_DEC "%s",	\ 	    (HOST_WIDE_INT) (a), SDB_DELIM);				\  } while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PUT_SDB_VAL
end_ifndef

begin_define
define|#
directive|define
name|PUT_SDB_VAL
parameter_list|(
name|a
parameter_list|)
define|\
value|( fputs ("\t.val\t", asm_out_file),		\   output_addr_const (asm_out_file, (a)),	\   fprintf (asm_out_file, SDB_DELIM))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PUT_SDB_DEF
end_ifndef

begin_define
define|#
directive|define
name|PUT_SDB_DEF
parameter_list|(
name|a
parameter_list|)
define|\
value|do { fprintf (asm_out_file, "\t.def\t");	\      assemble_name (asm_out_file, a);	\      fprintf (asm_out_file, SDB_DELIM); } while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PUT_SDB_PLAIN_DEF
end_ifndef

begin_define
define|#
directive|define
name|PUT_SDB_PLAIN_DEF
parameter_list|(
name|a
parameter_list|)
value|fprintf(asm_out_file,"\t.def\t.%s%s",a, SDB_DELIM)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PUT_SDB_ENDEF
end_ifndef

begin_define
define|#
directive|define
name|PUT_SDB_ENDEF
value|fputs("\t.endef\n", asm_out_file)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PUT_SDB_TYPE
end_ifndef

begin_define
define|#
directive|define
name|PUT_SDB_TYPE
parameter_list|(
name|a
parameter_list|)
value|fprintf(asm_out_file, "\t.type\t0%o%s", a, SDB_DELIM)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PUT_SDB_SIZE
end_ifndef

begin_define
define|#
directive|define
name|PUT_SDB_SIZE
parameter_list|(
name|a
parameter_list|)
define|\
value|do {									\    fprintf (asm_out_file, "\t.size\t" HOST_WIDE_INT_PRINT_DEC "%s",	\ 	    (HOST_WIDE_INT) (a), SDB_DELIM);				\  } while(0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PUT_SDB_START_DIM
end_ifndef

begin_define
define|#
directive|define
name|PUT_SDB_START_DIM
value|fprintf(asm_out_file, "\t.dim\t")
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PUT_SDB_NEXT_DIM
end_ifndef

begin_define
define|#
directive|define
name|PUT_SDB_NEXT_DIM
parameter_list|(
name|a
parameter_list|)
value|fprintf(asm_out_file, "%d,", a)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PUT_SDB_LAST_DIM
end_ifndef

begin_define
define|#
directive|define
name|PUT_SDB_LAST_DIM
parameter_list|(
name|a
parameter_list|)
value|fprintf(asm_out_file, "%d%s", a, SDB_DELIM)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PUT_SDB_TAG
end_ifndef

begin_define
define|#
directive|define
name|PUT_SDB_TAG
parameter_list|(
name|a
parameter_list|)
define|\
value|do { fprintf (asm_out_file, "\t.tag\t");	\      assemble_name (asm_out_file, a);	\      fprintf (asm_out_file, SDB_DELIM); } while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PUT_SDB_BLOCK_START
end_ifndef

begin_define
define|#
directive|define
name|PUT_SDB_BLOCK_START
parameter_list|(
name|LINE
parameter_list|)
define|\
value|fprintf (asm_out_file,			\ 	   "\t.def\t.bb%s\t.val\t.%s\t.scl\t100%s\t.line\t%d%s\t.endef\n", \ 	   SDB_DELIM, SDB_DELIM, SDB_DELIM, (LINE), SDB_DELIM)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PUT_SDB_BLOCK_END
end_ifndef

begin_define
define|#
directive|define
name|PUT_SDB_BLOCK_END
parameter_list|(
name|LINE
parameter_list|)
define|\
value|fprintf (asm_out_file,			\ 	   "\t.def\t.eb%s\t.val\t.%s\t.scl\t100%s\t.line\t%d%s\t.endef\n",  \ 	   SDB_DELIM, SDB_DELIM, SDB_DELIM, (LINE), SDB_DELIM)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PUT_SDB_FUNCTION_START
end_ifndef

begin_define
define|#
directive|define
name|PUT_SDB_FUNCTION_START
parameter_list|(
name|LINE
parameter_list|)
define|\
value|fprintf (asm_out_file,			\ 	   "\t.def\t.bf%s\t.val\t.%s\t.scl\t101%s\t.line\t%d%s\t.endef\n", \ 	   SDB_DELIM, SDB_DELIM, SDB_DELIM, (LINE), SDB_DELIM)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PUT_SDB_FUNCTION_END
end_ifndef

begin_define
define|#
directive|define
name|PUT_SDB_FUNCTION_END
parameter_list|(
name|LINE
parameter_list|)
define|\
value|fprintf (asm_out_file,			\ 	   "\t.def\t.ef%s\t.val\t.%s\t.scl\t101%s\t.line\t%d%s\t.endef\n", \ 	   SDB_DELIM, SDB_DELIM, SDB_DELIM, (LINE), SDB_DELIM)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SDB_GENERATE_FAKE
end_ifndef

begin_define
define|#
directive|define
name|SDB_GENERATE_FAKE
parameter_list|(
name|BUFFER
parameter_list|,
name|NUMBER
parameter_list|)
define|\
value|sprintf ((BUFFER), ".%dfake", (NUMBER));
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Return the sdb tag identifier string for TYPE    if TYPE has already been defined; otherwise return a null pointer.  */
end_comment

begin_define
define|#
directive|define
name|KNOWN_TYPE_TAG
parameter_list|(
name|type
parameter_list|)
value|TYPE_SYMTAB_POINTER (type)
end_define

begin_comment
comment|/* Set the sdb tag identifier string for TYPE to NAME.  */
end_comment

begin_define
define|#
directive|define
name|SET_KNOWN_TYPE_TAG
parameter_list|(
name|TYPE
parameter_list|,
name|NAME
parameter_list|)
define|\
value|TYPE_SYMTAB_POINTER (TYPE) = (char *)(NAME)
end_define

begin_comment
comment|/* Return the name (a string) of the struct, union or enum tag    described by the TREE_LIST node LINK.  This is 0 for an anonymous one.  */
end_comment

begin_define
define|#
directive|define
name|TAG_NAME
parameter_list|(
name|link
parameter_list|)
define|\
value|(((link)&& TREE_PURPOSE ((link)) \&& IDENTIFIER_POINTER (TREE_PURPOSE ((link)))) \    ? IDENTIFIER_POINTER (TREE_PURPOSE ((link))) : (char *) 0)
end_define

begin_comment
comment|/* Ensure we don't output a negative line number.  */
end_comment

begin_define
define|#
directive|define
name|MAKE_LINE_SAFE
parameter_list|(
name|line
parameter_list|)
define|\
value|if ((int) line<= sdb_begin_function_line) \     line = sdb_begin_function_line + 1
end_define

begin_comment
comment|/* Perform linker optimization of merging header file definitions together    for targets with MIPS_DEBUGGING_INFO defined.  This won't work without a    post 960826 version of GAS.  Nothing breaks with earlier versions of GAS,    the optimization just won't be done.  The native assembler already has the    necessary support.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|MIPS_DEBUGGING_INFO
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|PUT_SDB_SRC_FILE
end_ifndef

begin_define
define|#
directive|define
name|PUT_SDB_SRC_FILE
parameter_list|(
name|FILENAME
parameter_list|)
define|\
value|output_file_directive (asm_out_file, (FILENAME))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ECOFF linkers have an optimization that does the same kind of thing as    N_BINCL/E_INCL in stabs: eliminate duplicate debug information in the    executable.  To achieve this, GCC must output a .file for each file    name change.  */
end_comment

begin_comment
comment|/* This is a stack of input files.  */
end_comment

begin_struct
struct|struct
name|sdb_file
block|{
name|struct
name|sdb_file
modifier|*
name|next
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This is the top of the stack.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|sdb_file
modifier|*
name|current_file
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MIPS_DEBUGGING_INFO */
end_comment

begin_comment
comment|/* The debug hooks structure.  */
end_comment

begin_decl_stmt
specifier|const
name|struct
name|gcc_debug_hooks
name|sdb_debug_hooks
init|=
block|{
name|sdbout_init
block|,
comment|/* init */
name|sdbout_finish
block|,
comment|/* finish */
name|debug_nothing_int_charstar
block|,
comment|/* define */
name|debug_nothing_int_charstar
block|,
comment|/* undef */
name|sdbout_start_source_file
block|,
comment|/* start_source_file */
name|sdbout_end_source_file
block|,
comment|/* end_source_file */
name|sdbout_begin_block
block|,
comment|/* begin_block */
name|sdbout_end_block
block|,
comment|/* end_block */
name|debug_true_tree
block|,
comment|/* ignore_block */
name|sdbout_source_line
block|,
comment|/* source_line */
ifdef|#
directive|ifdef
name|MIPS_DEBUGGING_INFO
comment|/* Defer on MIPS systems so that parameter descriptions follow      function entry.  */
name|debug_nothing_int_charstar
block|,
comment|/* begin_prologue */
name|sdbout_end_prologue
block|,
comment|/* end_prologue */
else|#
directive|else
name|sdbout_begin_prologue
block|,
comment|/* begin_prologue */
name|debug_nothing_int_charstar
block|,
comment|/* end_prologue */
endif|#
directive|endif
name|sdbout_end_epilogue
block|,
comment|/* end_epilogue */
name|sdbout_begin_function
block|,
comment|/* begin_function */
name|sdbout_end_function
block|,
comment|/* end_function */
name|debug_nothing_tree
block|,
comment|/* function_decl */
name|sdbout_global_decl
block|,
comment|/* global_decl */
name|debug_nothing_tree
block|,
comment|/* deferred_inline_function */
name|debug_nothing_tree
block|,
comment|/* outlining_inline_function */
name|sdbout_label
block|,
comment|/* label */
name|debug_nothing_int
comment|/* handle_pch */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return a unique string to name an anonymous type.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|gen_fake_label
parameter_list|(
name|void
parameter_list|)
block|{
name|char
name|label
index|[
literal|10
index|]
decl_stmt|;
name|char
modifier|*
name|labelstr
decl_stmt|;
name|SDB_GENERATE_FAKE
argument_list|(
name|label
argument_list|,
name|unnamed_struct_number
argument_list|)
expr_stmt|;
name|unnamed_struct_number
operator|++
expr_stmt|;
name|labelstr
operator|=
name|xstrdup
argument_list|(
name|label
argument_list|)
expr_stmt|;
return|return
name|labelstr
return|;
block|}
end_function

begin_comment
comment|/* Return the number which describes TYPE for SDB.    For pointers, etc., this function is recursive.    Each record, union or enumeral type must already have had a    tag number output.  */
end_comment

begin_comment
comment|/* The number is given by d6d5d4d3d2d1bbbb    where bbbb is 4 bit basic type, and di indicate  one of notype,ptr,fn,array.    Thus, char *foo () has bbbb=T_CHAR 			  d1=D_FCN 			  d2=D_PTR  N_BTMASK=     017       1111     basic type field.  N_TSHIFT=       2                derived type shift  N_BTSHFT=       4                Basic type shift */
end_comment

begin_comment
comment|/* Produce the number that describes a pointer, function or array type.    PREV is the number describing the target, value or element type.    DT_type describes how to transform that type.  */
end_comment

begin_define
define|#
directive|define
name|PUSH_DERIVED_LEVEL
parameter_list|(
name|DT_type
parameter_list|,
name|PREV
parameter_list|)
define|\
value|((((PREV)& ~(int) N_BTMASK)<< (int) N_TSHIFT)		\    | ((int) DT_type<< (int) N_BTSHFT)			\    | ((PREV)& (int) N_BTMASK))
end_define

begin_comment
comment|/* Number of elements used in sdb_dims.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|sdb_n_dims
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Table of array dimensions of current type.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|sdb_dims
index|[
name|SDB_MAX_DIM
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Size of outermost array currently being processed.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|sdb_type_size
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|plain_type
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|int
name|val
init|=
name|plain_type_1
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* If we have already saved up some array dimensions, print them now.  */
if|if
condition|(
name|sdb_n_dims
operator|>
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
name|PUT_SDB_START_DIM
expr_stmt|;
for|for
control|(
name|i
operator|=
name|sdb_n_dims
operator|-
literal|1
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
name|PUT_SDB_NEXT_DIM
argument_list|(
name|sdb_dims
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|PUT_SDB_LAST_DIM
argument_list|(
name|sdb_dims
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|sdb_n_dims
operator|=
literal|0
expr_stmt|;
name|sdb_type_size
operator|=
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* Don't kill sdb if type is not laid out or has variable size.  */
if|if
condition|(
name|sdb_type_size
operator|<
literal|0
condition|)
name|sdb_type_size
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If we have computed the size of an array containing this type,      print it now.  */
if|if
condition|(
name|sdb_type_size
operator|>=
literal|0
condition|)
block|{
name|PUT_SDB_SIZE
argument_list|(
name|sdb_type_size
argument_list|)
expr_stmt|;
name|sdb_type_size
operator|=
operator|-
literal|1
expr_stmt|;
block|}
return|return
name|val
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|template_name_p
parameter_list|(
name|tree
name|name
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|ptr
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
decl_stmt|;
while|while
condition|(
operator|*
name|ptr
operator|&&
operator|*
name|ptr
operator|!=
literal|'<'
condition|)
name|ptr
operator|++
expr_stmt|;
return|return
operator|*
name|ptr
operator|!=
literal|'\0'
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sdbout_record_type_name
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
literal|0
decl_stmt|;
name|int
name|no_name
decl_stmt|;
if|if
condition|(
name|KNOWN_TYPE_TAG
argument_list|(
name|type
argument_list|)
condition|)
return|return;
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|tree
name|t
init|=
literal|0
decl_stmt|;
comment|/* Find the IDENTIFIER_NODE for the type name.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
name|t
operator|=
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
name|t
operator|=
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The DECL_NAME for templates includes "<>", which breaks 	     most assemblers.  Use its assembler name instead, which 	     has been mangled into being safe.  */
if|if
condition|(
name|t
operator|&&
name|template_name_p
argument_list|(
name|t
argument_list|)
condition|)
name|t
operator|=
name|DECL_ASSEMBLER_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Now get the name as a string, or invent one.  */
if|if
condition|(
name|t
operator|!=
name|NULL_TREE
condition|)
name|name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
name|no_name
operator|=
operator|(
name|name
operator|==
literal|0
operator|||
operator|*
name|name
operator|==
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|no_name
condition|)
name|name
operator|=
name|gen_fake_label
argument_list|()
expr_stmt|;
name|SET_KNOWN_TYPE_TAG
argument_list|(
name|type
argument_list|,
name|name
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SDB_ALLOW_FORWARD_REFERENCES
if|if
condition|(
name|no_name
condition|)
name|sdbout_queue_anonymous_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Return the .type value for type TYPE.     LEVEL indicates how many levels deep we have recursed into the type.    The SDB debug format can only represent 6 derived levels of types.    After that, we must output inaccurate debug info.  We deliberately    stop before the 7th level, so that ADA recursive types will not give an    infinite loop.  */
end_comment

begin_function
specifier|static
name|int
name|plain_type_1
parameter_list|(
name|tree
name|type
parameter_list|,
name|int
name|level
parameter_list|)
block|{
if|if
condition|(
name|type
operator|==
literal|0
condition|)
name|type
operator|=
name|void_type_node
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
name|type
operator|=
name|integer_type_node
expr_stmt|;
else|else
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|VOID_TYPE
case|:
return|return
name|T_VOID
return|;
case|case
name|BOOLEAN_TYPE
case|:
case|case
name|INTEGER_TYPE
case|:
block|{
name|int
name|size
init|=
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
operator|*
name|BITS_PER_UNIT
decl_stmt|;
comment|/* Carefully distinguish all the standard types of C, 	   without messing up if the language is not C. 	   Note that we check only for the names that contain spaces; 	   other names might occur by coincidence in other languages.  */
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
block|{
specifier|const
name|char
modifier|*
specifier|const
name|name
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"char"
argument_list|)
condition|)
return|return
name|T_CHAR
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"unsigned char"
argument_list|)
condition|)
return|return
name|T_UCHAR
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"signed char"
argument_list|)
condition|)
return|return
name|T_CHAR
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"int"
argument_list|)
condition|)
return|return
name|T_INT
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"unsigned int"
argument_list|)
condition|)
return|return
name|T_UINT
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"short int"
argument_list|)
condition|)
return|return
name|T_SHORT
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"short unsigned int"
argument_list|)
condition|)
return|return
name|T_USHORT
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"long int"
argument_list|)
condition|)
return|return
name|T_LONG
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"long unsigned int"
argument_list|)
condition|)
return|return
name|T_ULONG
return|;
block|}
if|if
condition|(
name|size
operator|==
name|INT_TYPE_SIZE
condition|)
return|return
operator|(
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|?
name|T_UINT
else|:
name|T_INT
operator|)
return|;
if|if
condition|(
name|size
operator|==
name|CHAR_TYPE_SIZE
condition|)
return|return
operator|(
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|?
name|T_UCHAR
else|:
name|T_CHAR
operator|)
return|;
if|if
condition|(
name|size
operator|==
name|SHORT_TYPE_SIZE
condition|)
return|return
operator|(
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|?
name|T_USHORT
else|:
name|T_SHORT
operator|)
return|;
if|if
condition|(
name|size
operator|==
name|LONG_TYPE_SIZE
condition|)
return|return
operator|(
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|?
name|T_ULONG
else|:
name|T_LONG
operator|)
return|;
if|if
condition|(
name|size
operator|==
name|LONG_LONG_TYPE_SIZE
condition|)
comment|/* better than nothing */
return|return
operator|(
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|?
name|T_ULONG
else|:
name|T_LONG
operator|)
return|;
return|return
literal|0
return|;
block|}
case|case
name|REAL_TYPE
case|:
block|{
name|int
name|precision
init|=
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|precision
operator|==
name|FLOAT_TYPE_SIZE
condition|)
return|return
name|T_FLOAT
return|;
if|if
condition|(
name|precision
operator|==
name|DOUBLE_TYPE_SIZE
condition|)
return|return
name|T_DOUBLE
return|;
ifdef|#
directive|ifdef
name|EXTENDED_SDB_BASIC_TYPES
if|if
condition|(
name|precision
operator|==
name|LONG_DOUBLE_TYPE_SIZE
condition|)
return|return
name|T_LNGDBL
return|;
else|#
directive|else
if|if
condition|(
name|precision
operator|==
name|LONG_DOUBLE_TYPE_SIZE
condition|)
return|return
name|T_DOUBLE
return|;
comment|/* better than nothing */
endif|#
directive|endif
return|return
literal|0
return|;
block|}
case|case
name|ARRAY_TYPE
case|:
block|{
name|int
name|m
decl_stmt|;
if|if
condition|(
name|level
operator|>=
literal|6
condition|)
return|return
name|T_VOID
return|;
else|else
name|m
operator|=
name|plain_type_1
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|level
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sdb_n_dims
operator|<
name|SDB_MAX_DIM
condition|)
name|sdb_dims
index|[
name|sdb_n_dims
operator|++
index|]
operator|=
operator|(
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_MIN_VALUE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
argument_list|)
operator|!=
literal|0
operator|&&
name|TYPE_MAX_VALUE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
argument_list|)
operator|!=
literal|0
operator|&&
name|host_integerp
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|&&
name|host_integerp
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|?
operator|(
name|tree_low_cst
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|-
name|tree_low_cst
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|+
literal|1
operator|)
else|:
literal|0
operator|)
expr_stmt|;
return|return
name|PUSH_DERIVED_LEVEL
argument_list|(
name|DT_ARY
argument_list|,
name|m
argument_list|)
return|;
block|}
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
case|case
name|QUAL_UNION_TYPE
case|:
case|case
name|ENUMERAL_TYPE
case|:
block|{
name|char
modifier|*
name|tag
decl_stmt|;
ifdef|#
directive|ifdef
name|SDB_ALLOW_FORWARD_REFERENCES
name|sdbout_record_type_name
argument_list|(
name|type
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|SDB_ALLOW_UNKNOWN_REFERENCES
if|if
condition|(
operator|(
name|TREE_ASM_WRITTEN
argument_list|(
name|type
argument_list|)
operator|&&
name|KNOWN_TYPE_TAG
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
operator|)
ifdef|#
directive|ifdef
name|SDB_ALLOW_FORWARD_REFERENCES
operator|||
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|!=
name|VOIDmode
endif|#
directive|endif
condition|)
endif|#
directive|endif
block|{
comment|/* Output the referenced structure tag name 	       only if the .def has already been finished. 	       At least on 386, the Unix assembler 	       cannot handle forward references to tags.  */
comment|/* But the 88100, it requires them, sigh...  */
comment|/* And the MIPS requires unknown refs as well...  */
name|tag
operator|=
name|KNOWN_TYPE_TAG
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|PUT_SDB_TAG
argument_list|(
name|tag
argument_list|)
expr_stmt|;
comment|/* These 3 lines used to follow the close brace. 	       However, a size of 0 without a tag implies a tag of 0, 	       so if we don't know a tag, we can't mention the size.  */
name|sdb_type_size
operator|=
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|sdb_type_size
operator|<
literal|0
condition|)
name|sdb_type_size
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
operator|)
condition|?
name|T_STRUCT
else|:
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|UNION_TYPE
operator|)
condition|?
name|T_UNION
else|:
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|QUAL_UNION_TYPE
operator|)
condition|?
name|T_UNION
else|:
name|T_ENUM
operator|)
return|;
block|}
case|case
name|POINTER_TYPE
case|:
case|case
name|REFERENCE_TYPE
case|:
block|{
name|int
name|m
decl_stmt|;
if|if
condition|(
name|level
operator|>=
literal|6
condition|)
return|return
name|T_VOID
return|;
else|else
name|m
operator|=
name|plain_type_1
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|level
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|PUSH_DERIVED_LEVEL
argument_list|(
name|DT_PTR
argument_list|,
name|m
argument_list|)
return|;
block|}
case|case
name|FUNCTION_TYPE
case|:
case|case
name|METHOD_TYPE
case|:
block|{
name|int
name|m
decl_stmt|;
if|if
condition|(
name|level
operator|>=
literal|6
condition|)
return|return
name|T_VOID
return|;
else|else
name|m
operator|=
name|plain_type_1
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|level
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|PUSH_DERIVED_LEVEL
argument_list|(
name|DT_FCN
argument_list|,
name|m
argument_list|)
return|;
block|}
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Output the symbols defined in block number DO_BLOCK.     This function works by walking the tree structure of blocks,    counting blocks until it finds the desired block.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|do_block
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|sdbout_block
parameter_list|(
name|tree
name|block
parameter_list|)
block|{
while|while
condition|(
name|block
condition|)
block|{
comment|/* Ignore blocks never expanded or otherwise marked as real.  */
if|if
condition|(
name|TREE_USED
argument_list|(
name|block
argument_list|)
condition|)
block|{
comment|/* When we reach the specified block, output its symbols.  */
if|if
condition|(
name|BLOCK_NUMBER
argument_list|(
name|block
argument_list|)
operator|==
name|do_block
condition|)
name|sdbout_syms
argument_list|(
name|BLOCK_VARS
argument_list|(
name|block
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we are past the specified block, stop the scan.  */
if|if
condition|(
name|BLOCK_NUMBER
argument_list|(
name|block
argument_list|)
operator|>
name|do_block
condition|)
return|return;
comment|/* Scan the blocks within this block.  */
name|sdbout_block
argument_list|(
name|BLOCK_SUBBLOCKS
argument_list|(
name|block
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|block
operator|=
name|BLOCK_CHAIN
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Call sdbout_symbol on each decl in the chain SYMS.  */
end_comment

begin_function
specifier|static
name|void
name|sdbout_syms
parameter_list|(
name|tree
name|syms
parameter_list|)
block|{
while|while
condition|(
name|syms
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|syms
argument_list|)
operator|!=
name|LABEL_DECL
condition|)
name|sdbout_symbol
argument_list|(
name|syms
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|syms
operator|=
name|TREE_CHAIN
argument_list|(
name|syms
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Output SDB information for a symbol described by DECL.    LOCAL is nonzero if the symbol is not file-scope.  */
end_comment

begin_function
name|void
name|sdbout_symbol
parameter_list|(
name|tree
name|decl
parameter_list|,
name|int
name|local
parameter_list|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|tree
name|context
init|=
name|NULL_TREE
decl_stmt|;
name|rtx
name|value
decl_stmt|;
name|int
name|regno
init|=
operator|-
literal|1
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|sdbout_one_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
condition|)
block|{
case|case
name|CONST_DECL
case|:
comment|/* Enum values are defined by defining the enum type.  */
return|return;
case|case
name|FUNCTION_DECL
case|:
comment|/* Don't mention a nested function under its parent.  */
name|context
operator|=
name|decl_function_context
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|context
operator|==
name|current_function_decl
condition|)
return|return;
comment|/* Check DECL_INITIAL to distinguish declarations from definitions. 	 Don't output debug info here for declarations; they will have 	 a DECL_INITIAL value of 0.  */
if|if
condition|(
operator|!
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
condition|)
return|return;
if|if
condition|(
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
name|MEM
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|SYMBOL_REF
condition|)
return|return;
name|PUT_SDB_DEF
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|PUT_SDB_VAL
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|PUT_SDB_SCL
argument_list|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|?
name|C_EXT
else|:
name|C_STAT
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_DECL
case|:
comment|/* Done with tagged types.  */
if|if
condition|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|DECL_IGNORED_P
argument_list|(
name|decl
argument_list|)
condition|)
return|return;
comment|/* Output typedef name.  */
if|if
condition|(
name|template_name_p
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
name|PUT_SDB_DEF
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|PUT_SDB_DEF
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|PUT_SDB_SCL
argument_list|(
name|C_TPDEF
argument_list|)
expr_stmt|;
break|break;
case|case
name|PARM_DECL
case|:
comment|/* Parm decls go in their own separate chains 	 and are output by sdbout_reg_parms and sdbout_parms.  */
name|abort
argument_list|()
expr_stmt|;
case|case
name|VAR_DECL
case|:
comment|/* Don't mention a variable that is external. 	 Let the file that defines it describe it.  */
if|if
condition|(
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
return|return;
comment|/* Ignore __FUNCTION__, etc.  */
if|if
condition|(
name|DECL_IGNORED_P
argument_list|(
name|decl
argument_list|)
condition|)
return|return;
comment|/* If there was an error in the declaration, don't dump core 	 if there is no RTL associated with the variable doesn't 	 exist.  */
if|if
condition|(
operator|!
name|DECL_RTL_SET_P
argument_list|(
name|decl
argument_list|)
condition|)
return|return;
name|SET_DECL_RTL
argument_list|(
name|decl
argument_list|,
name|eliminate_regs
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULL_RTX
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LEAF_REG_REMAP
if|if
condition|(
name|current_function_uses_only_leaf_regs
condition|)
name|leaf_renumber_regs_insn
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|value
operator|=
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* Don't mention a variable at all 	 if it was completely optimized into nothingness.  	 If DECL was from an inline function, then its rtl 	 is not identically the rtl that was used in this 	 particular compilation.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|REG
condition|)
block|{
name|regno
operator|=
name|REGNO
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
return|return;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
while|while
condition|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|SUBREG
condition|)
name|value
operator|=
name|SUBREG_REG
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|REG
condition|)
block|{
if|if
condition|(
name|REGNO
argument_list|(
name|value
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
return|return;
block|}
name|regno
operator|=
name|REGNO
argument_list|(
name|alter_subreg
argument_list|(
operator|&
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|SET_DECL_RTL
argument_list|(
name|decl
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
comment|/* Don't output anything if an auto variable 	 gets RTL that is static. 	 GAS version 2.2 can't handle such output.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|MEM
operator|&&
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
operator|!
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
condition|)
return|return;
comment|/* Emit any structure, union, or enum type that has not been output. 	 This occurs for tag-less structs (et al) used to declare variables 	 within functions.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|UNION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|QUAL_UNION_TYPE
condition|)
block|{
if|if
condition|(
name|COMPLETE_TYPE_P
argument_list|(
name|type
argument_list|)
comment|/* not a forward reference */
operator|&&
name|KNOWN_TYPE_TAG
argument_list|(
name|type
argument_list|)
operator|==
literal|0
condition|)
comment|/* not yet declared */
name|sdbout_one_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
comment|/* Defer SDB information for top-level initialized variables! */
if|if
condition|(
operator|!
name|local
operator|&&
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|MEM
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
condition|)
return|return;
comment|/* C++ in 2.3 makes nameless symbols.  That will be fixed later. 	 For now, avoid crashing.  */
if|if
condition|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL_TREE
condition|)
return|return;
comment|/* Record the name for, starting a symtab entry.  */
if|if
condition|(
name|local
condition|)
name|name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
block|{
name|PUT_SDB_DEF
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|PUT_SDB_VAL
argument_list|(
name|XEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|PUT_SDB_SCL
argument_list|(
name|C_EXT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|PUT_SDB_VAL
argument_list|(
name|XEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|PUT_SDB_SCL
argument_list|(
name|C_STAT
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|regno
operator|>=
literal|0
condition|)
block|{
name|PUT_SDB_DEF
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|PUT_SDB_INT_VAL
argument_list|(
name|DBX_REGISTER_NUMBER
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
name|PUT_SDB_SCL
argument_list|(
name|C_REG
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|MEM
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MEM
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|HARD_FRAME_POINTER_REGNUM
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|STACK_POINTER_REGNUM
operator|)
operator|)
condition|)
comment|/* If the value is indirect by memory or by a register 	   that isn't the frame pointer 	   then it means the object is variable-sized and address through 	   that register or stack slot.  COFF has no way to represent this 	   so all we can do is output the variable as a pointer.  */
block|{
name|PUT_SDB_DEF
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|PUT_SDB_INT_VAL
argument_list|(
name|DBX_REGISTER_NUMBER
argument_list|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|PUT_SDB_SCL
argument_list|(
name|C_REG
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* DECL_RTL looks like (MEM (MEM (PLUS (REG...) 		 (CONST_INT...)))). 		 We want the value of that CONST_INT.  */
comment|/* Encore compiler hates a newline in a macro arg, it seems.  */
name|PUT_SDB_INT_VAL
argument_list|(
name|DEBUGGER_AUTO_OFFSET
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|PUT_SDB_SCL
argument_list|(
name|C_AUTO
argument_list|)
expr_stmt|;
block|}
comment|/* Effectively do build_pointer_type, but don't cache this type, 	     since it might be temporary whereas the type it points to 	     might have been saved for inlining.  */
comment|/* Don't use REFERENCE_TYPE because dbx can't handle that.  */
name|type
operator|=
name|make_node
argument_list|(
name|POINTER_TYPE
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|MEM
operator|&&
operator|(
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|)
comment|/* This is for variables which are at offset zero from 		      the frame pointer.  This happens on the Alpha. 		      Non-frame pointer registers are excluded above.  */
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|)
operator|)
condition|)
block|{
comment|/* DECL_RTL looks like (MEM (PLUS (REG...) (CONST_INT...))) 	     or (MEM (REG...)).  We want the value of that CONST_INT 	     or zero.  */
name|PUT_SDB_DEF
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|PUT_SDB_INT_VAL
argument_list|(
name|DEBUGGER_AUTO_OFFSET
argument_list|(
name|XEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|PUT_SDB_SCL
argument_list|(
name|C_AUTO
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* It is something we don't know how to represent for SDB.  */
return|return;
block|}
break|break;
default|default:
break|break;
block|}
name|PUT_SDB_TYPE
argument_list|(
name|plain_type
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|PUT_SDB_ENDEF
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output SDB information for a top-level initialized variable    that has been delayed.  */
end_comment

begin_function
specifier|static
name|void
name|sdbout_toplevel_data
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|DECL_IGNORED_P
argument_list|(
name|decl
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|PUT_SDB_DEF
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|PUT_SDB_VAL
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|PUT_SDB_SCL
argument_list|(
name|C_EXT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|PUT_SDB_SCL
argument_list|(
name|C_STAT
argument_list|)
expr_stmt|;
block|}
name|PUT_SDB_TYPE
argument_list|(
name|plain_type
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|PUT_SDB_ENDEF
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SDB_ALLOW_FORWARD_REFERENCES
end_ifdef

begin_comment
comment|/* Machinery to record and output anonymous types.  */
end_comment

begin_function
specifier|static
name|void
name|sdbout_queue_anonymous_type
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|anonymous_types
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|type
argument_list|,
name|anonymous_types
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sdbout_dequeue_anonymous_types
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|types
decl_stmt|,
name|link
decl_stmt|;
while|while
condition|(
name|anonymous_types
condition|)
block|{
name|types
operator|=
name|nreverse
argument_list|(
name|anonymous_types
argument_list|)
expr_stmt|;
name|anonymous_types
operator|=
name|NULL_TREE
expr_stmt|;
for|for
control|(
name|link
operator|=
name|types
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
block|{
name|tree
name|type
init|=
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|&&
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|type
argument_list|)
condition|)
name|sdbout_one_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Given a chain of ..._TYPE nodes, all of which have names,    output definitions of those names, as typedefs.  */
end_comment

begin_function
name|void
name|sdbout_types
parameter_list|(
name|tree
name|types
parameter_list|)
block|{
name|tree
name|link
decl_stmt|;
for|for
control|(
name|link
operator|=
name|types
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
name|sdbout_one_type
argument_list|(
name|link
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SDB_ALLOW_FORWARD_REFERENCES
name|sdbout_dequeue_anonymous_types
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|sdbout_type
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
name|type
operator|=
name|integer_type_node
expr_stmt|;
name|PUT_SDB_TYPE
argument_list|(
name|plain_type
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output types of the fields of type TYPE, if they are structs.     Formerly did not chase through pointer types, since that could be circular.    They must come before TYPE, since forward refs are not allowed.    Now james@bigtex.cactus.org says to try them.  */
end_comment

begin_function
specifier|static
name|void
name|sdbout_field_types
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|tree
name|tail
decl_stmt|;
for|for
control|(
name|tail
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|tail
condition|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
control|)
comment|/* This condition should match the one for emitting the actual        members below.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|tail
argument_list|)
operator|==
name|FIELD_DECL
operator|&&
name|DECL_NAME
argument_list|(
name|tail
argument_list|)
operator|&&
name|DECL_SIZE
argument_list|(
name|tail
argument_list|)
operator|&&
name|host_integerp
argument_list|(
name|DECL_SIZE
argument_list|(
name|tail
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|&&
name|host_integerp
argument_list|(
name|bit_position
argument_list|(
name|tail
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
block|{
if|if
condition|(
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|tail
argument_list|)
argument_list|)
condition|)
name|sdbout_one_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|tail
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|sdbout_one_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|tail
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Use this to put out the top level defined record and union types    for later reference.  If this is a struct with a name, then put that    name out.  Other unnamed structs will have .xxfake labels generated so    that they may be referred to later.    The label will be stored in the KNOWN_TYPE_TAG slot of a type.    It may NOT be called recursively.  */
end_comment

begin_function
specifier|static
name|void
name|sdbout_one_type
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
if|if
condition|(
name|current_function_decl
operator|!=
name|NULL_TREE
operator|&&
name|DECL_SECTION_NAME
argument_list|(
name|current_function_decl
argument_list|)
operator|!=
name|NULL_TREE
condition|)
empty_stmt|;
comment|/* Don't change section amid function.  */
else|else
name|text_section
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
case|case
name|QUAL_UNION_TYPE
case|:
case|case
name|ENUMERAL_TYPE
case|:
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* Don't output a type twice.  */
if|if
condition|(
name|TREE_ASM_WRITTEN
argument_list|(
name|type
argument_list|)
condition|)
comment|/* James said test TREE_ASM_BEING_WRITTEN here.  */
return|return;
comment|/* Output nothing if type is not yet defined.  */
if|if
condition|(
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
return|return;
name|TREE_ASM_WRITTEN
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* This is reputed to cause trouble with the following case, 	 but perhaps checking TYPE_SIZE above will fix it.  */
comment|/* Here is a testcase:  	struct foo { 	  struct badstr *bbb; 	} forwardref;  	typedef struct intermediate { 	  int aaaa; 	} intermediate_ref;  	typedef struct badstr { 	  int ccccc; 	} badtype;   */
comment|/* This change, which ought to make better output, 	 used to make the COFF assembler unhappy. 	 Changes involving KNOWN_TYPE_TAG may fix the problem.  */
comment|/* Before really doing anything, output types we want to refer to.  */
comment|/* Note that in version 1 the following two lines 	 are not used if forward references are in use.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|ENUMERAL_TYPE
condition|)
name|sdbout_field_types
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* Output a structure type.  */
block|{
name|int
name|size
init|=
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|int
name|member_scl
init|=
literal|0
decl_stmt|;
name|tree
name|tem
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n_baseclasses
init|=
literal|0
decl_stmt|;
comment|/* Record the type tag, but not in its permanent place just yet.  */
name|sdbout_record_type_name
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|PUT_SDB_DEF
argument_list|(
name|KNOWN_TYPE_TAG
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|UNION_TYPE
case|:
case|case
name|QUAL_UNION_TYPE
case|:
name|PUT_SDB_SCL
argument_list|(
name|C_UNTAG
argument_list|)
expr_stmt|;
name|PUT_SDB_TYPE
argument_list|(
name|T_UNION
argument_list|)
expr_stmt|;
name|member_scl
operator|=
name|C_MOU
expr_stmt|;
break|break;
case|case
name|RECORD_TYPE
case|:
name|PUT_SDB_SCL
argument_list|(
name|C_STRTAG
argument_list|)
expr_stmt|;
name|PUT_SDB_TYPE
argument_list|(
name|T_STRUCT
argument_list|)
expr_stmt|;
name|member_scl
operator|=
name|C_MOS
expr_stmt|;
break|break;
case|case
name|ENUMERAL_TYPE
case|:
name|PUT_SDB_SCL
argument_list|(
name|C_ENTAG
argument_list|)
expr_stmt|;
name|PUT_SDB_TYPE
argument_list|(
name|T_ENUM
argument_list|)
expr_stmt|;
name|member_scl
operator|=
name|C_MOE
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|PUT_SDB_SIZE
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|PUT_SDB_ENDEF
expr_stmt|;
comment|/* Print out the base class information with fields 	   named after the types they hold.  */
comment|/* This is only relevant to aggregate types.  TYPE_BINFO is used 	   for other purposes in an ENUMERAL_TYPE, so we must exclude that 	   case.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|ENUMERAL_TYPE
condition|)
block|{
if|if
condition|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_BINFO_BASETYPES
argument_list|(
name|type
argument_list|)
condition|)
name|n_baseclasses
operator|=
name|TREE_VEC_LENGTH
argument_list|(
name|TYPE_BINFO_BASETYPES
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baseclasses
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|child
init|=
name|TREE_VEC_ELT
argument_list|(
name|BINFO_BASETYPES
argument_list|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|tree
name|child_type
init|=
name|BINFO_TYPE
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|tree
name|child_type_name
decl_stmt|;
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|child_type
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|child_type
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
name|child_type_name
operator|=
name|TYPE_NAME
argument_list|(
name|child_type
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|child_type
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
name|child_type_name
operator|=
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|child_type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|child_type_name
operator|&&
name|template_name_p
argument_list|(
name|child_type_name
argument_list|)
condition|)
name|child_type_name
operator|=
name|DECL_ASSEMBLER_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|child_type
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
continue|continue;
name|PUT_SDB_DEF
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|child_type_name
argument_list|)
argument_list|)
expr_stmt|;
name|PUT_SDB_INT_VAL
argument_list|(
name|tree_low_cst
argument_list|(
name|BINFO_OFFSET
argument_list|(
name|child
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|PUT_SDB_SCL
argument_list|(
name|member_scl
argument_list|)
expr_stmt|;
name|sdbout_type
argument_list|(
name|BINFO_TYPE
argument_list|(
name|child
argument_list|)
argument_list|)
expr_stmt|;
name|PUT_SDB_ENDEF
expr_stmt|;
block|}
block|}
comment|/* Output the individual fields.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
block|{
for|for
control|(
name|tem
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|tem
condition|;
name|tem
operator|=
name|TREE_CHAIN
argument_list|(
name|tem
argument_list|)
control|)
if|if
condition|(
name|host_integerp
argument_list|(
name|TREE_VALUE
argument_list|(
name|tem
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|PUT_SDB_DEF
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|tem
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|PUT_SDB_INT_VAL
argument_list|(
name|tree_low_cst
argument_list|(
name|TREE_VALUE
argument_list|(
name|tem
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|PUT_SDB_SCL
argument_list|(
name|C_MOE
argument_list|)
expr_stmt|;
name|PUT_SDB_TYPE
argument_list|(
name|T_MOE
argument_list|)
expr_stmt|;
name|PUT_SDB_ENDEF
expr_stmt|;
block|}
block|}
else|else
comment|/* record or union type */
for|for
control|(
name|tem
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|tem
condition|;
name|tem
operator|=
name|TREE_CHAIN
argument_list|(
name|tem
argument_list|)
control|)
comment|/* Output the name, type, position (in bits), size (in bits) 	       of each field.  */
comment|/* Omit here the nameless fields that are used to skip bits. 	       Also omit fields with variable size or position. 	       Also omit non FIELD_DECL nodes that GNU C++ may put here.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|FIELD_DECL
operator|&&
name|DECL_NAME
argument_list|(
name|tem
argument_list|)
operator|&&
name|DECL_SIZE
argument_list|(
name|tem
argument_list|)
operator|&&
name|host_integerp
argument_list|(
name|DECL_SIZE
argument_list|(
name|tem
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|&&
name|host_integerp
argument_list|(
name|bit_position
argument_list|(
name|tem
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|tem
argument_list|)
argument_list|)
expr_stmt|;
name|PUT_SDB_DEF
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_BIT_FIELD_TYPE
argument_list|(
name|tem
argument_list|)
condition|)
block|{
name|PUT_SDB_INT_VAL
argument_list|(
name|int_bit_position
argument_list|(
name|tem
argument_list|)
argument_list|)
expr_stmt|;
name|PUT_SDB_SCL
argument_list|(
name|C_FIELD
argument_list|)
expr_stmt|;
name|sdbout_type
argument_list|(
name|DECL_BIT_FIELD_TYPE
argument_list|(
name|tem
argument_list|)
argument_list|)
expr_stmt|;
name|PUT_SDB_SIZE
argument_list|(
name|tree_low_cst
argument_list|(
name|DECL_SIZE
argument_list|(
name|tem
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|PUT_SDB_INT_VAL
argument_list|(
name|int_bit_position
argument_list|(
name|tem
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
name|PUT_SDB_SCL
argument_list|(
name|member_scl
argument_list|)
expr_stmt|;
name|sdbout_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|PUT_SDB_ENDEF
expr_stmt|;
block|}
comment|/* Output end of a structure,union, or enumeral definition.  */
name|PUT_SDB_PLAIN_DEF
argument_list|(
literal|"eos"
argument_list|)
expr_stmt|;
name|PUT_SDB_INT_VAL
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|PUT_SDB_SCL
argument_list|(
name|C_EOS
argument_list|)
expr_stmt|;
name|PUT_SDB_TAG
argument_list|(
name|KNOWN_TYPE_TAG
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|PUT_SDB_SIZE
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|PUT_SDB_ENDEF
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* The following two functions output definitions of function parameters.    Each parameter gets a definition locating it in the parameter list.    Each parameter that is a register variable gets a second definition    locating it in the register.     Printing or argument lists in gdb uses the definitions that    locate in the parameter list.  But reference to the variable in    expressions uses preferentially the definition as a register.  */
end_comment

begin_comment
comment|/* Output definitions, referring to storage in the parmlist,    of all the parms in PARMS, which is a chain of PARM_DECL nodes.  */
end_comment

begin_function
specifier|static
name|void
name|sdbout_parms
parameter_list|(
name|tree
name|parms
parameter_list|)
block|{
for|for
control|(
init|;
name|parms
condition|;
name|parms
operator|=
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
control|)
if|if
condition|(
name|DECL_NAME
argument_list|(
name|parms
argument_list|)
condition|)
block|{
name|int
name|current_sym_value
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|parms
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|name
operator|==
literal|0
operator|||
operator|*
name|name
operator|==
literal|0
condition|)
name|name
operator|=
name|gen_fake_label
argument_list|()
expr_stmt|;
comment|/* Perform any necessary register eliminations on the parameter's rtl, 	   so that the debugging output will be accurate.  */
name|DECL_INCOMING_RTL
argument_list|(
name|parms
argument_list|)
operator|=
name|eliminate_regs
argument_list|(
name|DECL_INCOMING_RTL
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|SET_DECL_RTL
argument_list|(
name|parms
argument_list|,
name|eliminate_regs
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULL_RTX
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|PARM_PASSED_IN_MEMORY
argument_list|(
name|parms
argument_list|)
condition|)
block|{
name|rtx
name|addr
init|=
name|XEXP
argument_list|(
name|DECL_INCOMING_RTL
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|type
decl_stmt|;
comment|/* ??? Here we assume that the parm address is indexed 	       off the frame pointer or arg pointer. 	       If that is not true, we produce meaningless results, 	       but do not crash.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
name|current_sym_value
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|current_sym_value
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
name|type
operator|=
name|DECL_ARG_TYPE
argument_list|(
name|parms
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|original_sym_value
init|=
name|current_sym_value
decl_stmt|;
comment|/* This is the case where the parm is passed as an int or 		   double and it is converted to a char, short or float 		   and stored back in the parmlist.  In this case, describe 		   the parm with the variable's declared type, and adjust 		   the address if the least significant bytes (which we are 		   using) are not the first ones.  */
if|if
condition|(
name|BYTES_BIG_ENDIAN
operator|&&
name|TREE_TYPE
argument_list|(
name|parms
argument_list|)
operator|!=
name|DECL_ARG_TYPE
argument_list|(
name|parms
argument_list|)
condition|)
name|current_sym_value
operator|+=
operator|(
name|GET_MODE_SIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|DECL_ARG_TYPE
argument_list|(
name|parms
argument_list|)
argument_list|)
argument_list|)
operator|-
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|)
operator|&&
operator|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|current_sym_value
operator|)
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|parms
argument_list|)
expr_stmt|;
else|else
block|{
name|current_sym_value
operator|=
name|original_sym_value
expr_stmt|;
name|type
operator|=
name|DECL_ARG_TYPE
argument_list|(
name|parms
argument_list|)
expr_stmt|;
block|}
block|}
name|PUT_SDB_DEF
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|PUT_SDB_INT_VAL
argument_list|(
name|DEBUGGER_ARG_OFFSET
argument_list|(
name|current_sym_value
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|PUT_SDB_SCL
argument_list|(
name|C_ARG
argument_list|)
expr_stmt|;
name|PUT_SDB_TYPE
argument_list|(
name|plain_type
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|PUT_SDB_ENDEF
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|rtx
name|best_rtl
decl_stmt|;
comment|/* Parm passed in registers and lives in registers or nowhere.  */
comment|/* If parm lives in a register, use that register; 	       pretend the parm was passed there.  It would be more consistent 	       to describe the register where the parm was passed, 	       but in practice that register usually holds something else.  */
if|if
condition|(
name|REGNO
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
name|best_rtl
operator|=
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
expr_stmt|;
comment|/* If the parm lives nowhere, 	       use the register where it was passed.  */
else|else
name|best_rtl
operator|=
name|DECL_INCOMING_RTL
argument_list|(
name|parms
argument_list|)
expr_stmt|;
name|PUT_SDB_DEF
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|PUT_SDB_INT_VAL
argument_list|(
name|DBX_REGISTER_NUMBER
argument_list|(
name|REGNO
argument_list|(
name|best_rtl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|PUT_SDB_SCL
argument_list|(
name|C_REGPARM
argument_list|)
expr_stmt|;
name|PUT_SDB_TYPE
argument_list|(
name|plain_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|parms
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|PUT_SDB_ENDEF
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|!=
name|const0_rtx
condition|)
block|{
comment|/* Parm was passed in registers but lives on the stack.  */
comment|/* DECL_RTL looks like (MEM (PLUS (REG...) (CONST_INT...))), 	       in which case we want the value of that CONST_INT, 	       or (MEM (REG ...)) or (MEM (MEM ...)), 	       in which case we use a value of zero.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
name|current_sym_value
operator|=
literal|0
expr_stmt|;
else|else
name|current_sym_value
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Again, this assumes the offset is based on the arg pointer.  */
name|PUT_SDB_DEF
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|PUT_SDB_INT_VAL
argument_list|(
name|DEBUGGER_ARG_OFFSET
argument_list|(
name|current_sym_value
argument_list|,
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|PUT_SDB_SCL
argument_list|(
name|C_ARG
argument_list|)
expr_stmt|;
name|PUT_SDB_TYPE
argument_list|(
name|plain_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|parms
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|PUT_SDB_ENDEF
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Output definitions for the places where parms live during the function,    when different from where they were passed, when the parms were passed    in memory.     It is not useful to do this for parms passed in registers    that live during the function in different registers, because it is    impossible to look in the passed register for the passed value,    so we use the within-the-function register to begin with.     PARMS is a chain of PARM_DECL nodes.  */
end_comment

begin_function
specifier|static
name|void
name|sdbout_reg_parms
parameter_list|(
name|tree
name|parms
parameter_list|)
block|{
for|for
control|(
init|;
name|parms
condition|;
name|parms
operator|=
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
control|)
if|if
condition|(
name|DECL_NAME
argument_list|(
name|parms
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|parms
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Report parms that live in registers during the function 	   but were passed in memory.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|PARM_PASSED_IN_MEMORY
argument_list|(
name|parms
argument_list|)
condition|)
block|{
if|if
condition|(
name|name
operator|==
literal|0
operator|||
operator|*
name|name
operator|==
literal|0
condition|)
name|name
operator|=
name|gen_fake_label
argument_list|()
expr_stmt|;
name|PUT_SDB_DEF
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|PUT_SDB_INT_VAL
argument_list|(
name|DBX_REGISTER_NUMBER
argument_list|(
name|REGNO
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|PUT_SDB_SCL
argument_list|(
name|C_REG
argument_list|)
expr_stmt|;
name|PUT_SDB_TYPE
argument_list|(
name|plain_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|parms
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|PUT_SDB_ENDEF
expr_stmt|;
block|}
comment|/* Report parms that live in memory but not where they were passed.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|PARM_PASSED_IN_MEMORY
argument_list|(
name|parms
argument_list|)
operator|&&
operator|!
name|rtx_equal_p
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|,
name|DECL_INCOMING_RTL
argument_list|(
name|parms
argument_list|)
argument_list|)
condition|)
block|{
if|#
directive|if
literal|0
comment|/* ??? It is not clear yet what should replace this.  */
block|int offset = DECL_OFFSET (parms) / BITS_PER_UNIT;
comment|/* A parm declared char is really passed as an int, 	       so it occupies the least significant bytes. 	       On a big-endian machine those are not the low-numbered ones.  */
block|if (BYTES_BIG_ENDIAN&& offset != -1&& TREE_TYPE (parms) != DECL_ARG_TYPE (parms)) 	      offset += (GET_MODE_SIZE (TYPE_MODE (DECL_ARG_TYPE (parms))) 			 - GET_MODE_SIZE (GET_MODE (DECL_RTL (parms)))); 	    if (INTVAL (XEXP (XEXP (DECL_RTL (parms), 0), 1)) != offset) {...}
endif|#
directive|endif
block|{
if|if
condition|(
name|name
operator|==
literal|0
operator|||
operator|*
name|name
operator|==
literal|0
condition|)
name|name
operator|=
name|gen_fake_label
argument_list|()
expr_stmt|;
name|PUT_SDB_DEF
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|PUT_SDB_INT_VAL
argument_list|(
name|DEBUGGER_AUTO_OFFSET
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|PUT_SDB_SCL
argument_list|(
name|C_AUTO
argument_list|)
expr_stmt|;
name|PUT_SDB_TYPE
argument_list|(
name|plain_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|parms
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|PUT_SDB_ENDEF
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Output debug information for a global DECL.  Called from toplev.c    after compilation proper has finished.  */
end_comment

begin_function
specifier|static
name|void
name|sdbout_global_decl
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_RTL_SET_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* The COFF linker can move initialized global vars to the end. 	 And that can screw up the symbol ordering.  Defer those for 	 sdbout_finish ().  */
if|if
condition|(
operator|!
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|||
operator|!
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
name|sdbout_symbol
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Output COFF information for non-global file-scope initialized 	 variables.  */
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
name|sdbout_toplevel_data
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Output initialized global vars at the end, in the order of    definition.  See comment in sdbout_global_decl.  */
end_comment

begin_function
specifier|static
name|void
name|sdbout_finish
parameter_list|(
specifier|const
name|char
modifier|*
name|main_filename
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|tree
name|decl
init|=
call|(
modifier|*
name|lang_hooks
operator|.
name|decls
operator|.
name|getdecls
call|)
argument_list|()
decl_stmt|;
name|unsigned
name|int
name|len
init|=
name|list_length
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|tree
modifier|*
name|vec
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
operator|*
name|len
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
comment|/* Process the decls in reverse order--earliest first.  Put them      into VEC from back to front, then take out from front.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
operator|,
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
control|)
name|vec
index|[
name|len
operator|-
name|i
operator|-
literal|1
index|]
operator|=
name|decl
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|decl
operator|=
name|vec
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|&&
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_RTL_SET_P
argument_list|(
name|decl
argument_list|)
condition|)
name|sdbout_symbol
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|vec
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Describe the beginning of an internal block within a function.    Also output descriptions of variables defined in this block.     N is the number of the block, by order of beginning, counting from 1,    and not counting the outermost (function top-level) block.    The blocks match the BLOCKs in DECL_INITIAL (current_function_decl),    if the count starts at 0 for the outermost one.  */
end_comment

begin_function
specifier|static
name|void
name|sdbout_begin_block
parameter_list|(
name|unsigned
name|int
name|line
parameter_list|,
name|unsigned
name|int
name|n
parameter_list|)
block|{
name|tree
name|decl
init|=
name|current_function_decl
decl_stmt|;
name|MAKE_LINE_SAFE
argument_list|(
name|line
argument_list|)
expr_stmt|;
comment|/* The SCO compiler does not emit a separate block for the function level      scope, so we avoid it here also.  However, mips ECOFF compilers do emit      a separate block, so we retain it when MIPS_DEBUGGING_INFO is defined.  */
ifndef|#
directive|ifndef
name|MIPS_DEBUGGING_INFO
if|if
condition|(
name|n
operator|!=
literal|1
condition|)
endif|#
directive|endif
name|PUT_SDB_BLOCK_START
argument_list|(
name|line
operator|-
name|sdb_begin_function_line
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|1
condition|)
block|{
comment|/* Include the outermost BLOCK's variables in block 1.  */
name|do_block
operator|=
name|BLOCK_NUMBER
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|sdbout_block
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If -g1, suppress all the internal symbols of functions      except for arguments.  */
if|if
condition|(
name|debug_info_level
operator|!=
name|DINFO_LEVEL_TERSE
condition|)
block|{
name|do_block
operator|=
name|n
expr_stmt|;
name|sdbout_block
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SDB_ALLOW_FORWARD_REFERENCES
name|sdbout_dequeue_anonymous_types
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Describe the end line-number of an internal block within a function.  */
end_comment

begin_function
specifier|static
name|void
name|sdbout_end_block
parameter_list|(
name|unsigned
name|int
name|line
parameter_list|,
name|unsigned
name|int
name|n
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|MAKE_LINE_SAFE
argument_list|(
name|line
argument_list|)
expr_stmt|;
comment|/* The SCO compiler does not emit a separate block for the function level      scope, so we avoid it here also.  However, mips ECOFF compilers do emit      a separate block, so we retain it when MIPS_DEBUGGING_INFO is defined.  */
ifndef|#
directive|ifndef
name|MIPS_DEBUGGING_INFO
if|if
condition|(
name|n
operator|!=
literal|1
condition|)
endif|#
directive|endif
name|PUT_SDB_BLOCK_END
argument_list|(
name|line
operator|-
name|sdb_begin_function_line
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output a line number symbol entry for source file FILENAME and line    number LINE.  */
end_comment

begin_function
specifier|static
name|void
name|sdbout_source_line
parameter_list|(
name|unsigned
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
comment|/* COFF relative line numbers must be positive.  */
if|if
condition|(
operator|(
name|int
operator|)
name|line
operator|>
name|sdb_begin_function_line
condition|)
block|{
ifdef|#
directive|ifdef
name|ASM_OUTPUT_SOURCE_LINE
name|sdbout_source_line_counter
operator|+=
literal|1
expr_stmt|;
name|ASM_OUTPUT_SOURCE_LINE
argument_list|(
name|asm_out_file
argument_list|,
name|line
argument_list|,
name|sdbout_source_line_counter
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.ln\t%d\n"
argument_list|,
operator|(
operator|(
name|sdb_begin_function_line
operator|>
operator|-
literal|1
operator|)
condition|?
name|line
operator|-
name|sdb_begin_function_line
else|:
literal|1
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_comment
comment|/* Output sdb info for the current function name.    Called from assemble_start_function.  */
end_comment

begin_function
specifier|static
name|void
name|sdbout_begin_function
parameter_list|(
name|tree
name|decl
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|sdbout_symbol
argument_list|(
name|current_function_decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called at beginning of function body (before or after prologue,    depending on MIPS_DEBUGGING_INFO).  Record the function's starting    line number, so we can output relative line numbers for the other    lines.  Describe beginning of outermost block.  Also describe the    parameter list.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MIPS_DEBUGGING_INFO
end_ifndef

begin_function
specifier|static
name|void
name|sdbout_begin_prologue
parameter_list|(
name|unsigned
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|file
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|sdbout_end_prologue
argument_list|(
name|line
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|sdbout_end_prologue
parameter_list|(
name|unsigned
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|file
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|sdb_begin_function_line
operator|=
name|line
operator|-
literal|1
expr_stmt|;
name|PUT_SDB_FUNCTION_START
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|sdbout_parms
argument_list|(
name|DECL_ARGUMENTS
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
expr_stmt|;
name|sdbout_reg_parms
argument_list|(
name|DECL_ARGUMENTS
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called at end of function (before epilogue).    Describe end of outermost block.  */
end_comment

begin_function
specifier|static
name|void
name|sdbout_end_function
parameter_list|(
name|unsigned
name|int
name|line
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|SDB_ALLOW_FORWARD_REFERENCES
name|sdbout_dequeue_anonymous_types
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|MAKE_LINE_SAFE
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|PUT_SDB_FUNCTION_END
argument_list|(
name|line
operator|-
name|sdb_begin_function_line
argument_list|)
expr_stmt|;
comment|/* Indicate we are between functions, for line-number output.  */
name|sdb_begin_function_line
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output sdb info for the absolute end of a function.    Called after the epilogue is output.  */
end_comment

begin_function
specifier|static
name|void
name|sdbout_end_epilogue
parameter_list|(
name|unsigned
name|int
name|line
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
name|file
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
specifier|const
name|char
modifier|*
specifier|const
name|name
name|ATTRIBUTE_UNUSED
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|PUT_SDB_EPILOGUE_END
name|PUT_SDB_EPILOGUE_END
argument_list|(
name|name
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.def\t"
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"%s\t.val\t.%s\t.scl\t-1%s\t.endef\n"
argument_list|,
name|SDB_DELIM
argument_list|,
name|SDB_DELIM
argument_list|,
name|SDB_DELIM
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Output sdb info for the given label.  Called only if LABEL_NAME (insn)    is present.  */
end_comment

begin_function
specifier|static
name|void
name|sdbout_label
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|PUT_SDB_DEF
argument_list|(
name|LABEL_NAME
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|PUT_SDB_VAL
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|PUT_SDB_SCL
argument_list|(
name|C_LABEL
argument_list|)
expr_stmt|;
name|PUT_SDB_TYPE
argument_list|(
name|T_NULL
argument_list|)
expr_stmt|;
name|PUT_SDB_ENDEF
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Change to reading from a new source file.  */
end_comment

begin_function
specifier|static
name|void
name|sdbout_start_source_file
parameter_list|(
name|unsigned
name|int
name|line
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|MIPS_DEBUGGING_INFO
name|struct
name|sdb_file
modifier|*
name|n
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|n
argument_list|)
decl_stmt|;
name|n
operator|->
name|next
operator|=
name|current_file
expr_stmt|;
name|n
operator|->
name|name
operator|=
name|filename
expr_stmt|;
name|current_file
operator|=
name|n
expr_stmt|;
name|PUT_SDB_SRC_FILE
argument_list|(
name|filename
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Revert to reading a previous source file.  */
end_comment

begin_function
specifier|static
name|void
name|sdbout_end_source_file
parameter_list|(
name|unsigned
name|int
name|line
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|MIPS_DEBUGGING_INFO
name|struct
name|sdb_file
modifier|*
name|next
decl_stmt|;
name|next
operator|=
name|current_file
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|current_file
argument_list|)
expr_stmt|;
name|current_file
operator|=
name|next
expr_stmt|;
name|PUT_SDB_SRC_FILE
argument_list|(
name|current_file
operator|->
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Set up for SDB output at the start of compilation.  */
end_comment

begin_function
specifier|static
name|void
name|sdbout_init
parameter_list|(
specifier|const
name|char
modifier|*
name|input_file_name
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|MIPS_DEBUGGING_INFO
name|current_file
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|current_file
argument_list|)
expr_stmt|;
name|current_file
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|current_file
operator|->
name|name
operator|=
name|input_file_name
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* SDB_DEBUGGING_INFO */
end_comment

begin_comment
comment|/* This should never be used, but its address is needed for comparisons.  */
end_comment

begin_decl_stmt
specifier|const
name|struct
name|gcc_debug_hooks
name|sdb_debug_hooks
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SDB_DEBUGGING_INFO */
end_comment

begin_include
include|#
directive|include
file|"gt-sdbout.h"
end_include

end_unit

