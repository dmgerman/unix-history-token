begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Induction variable optimizations.    Copyright (C) 2003, 2004, 2005 Free Software Foundation, Inc.     This file is part of GCC.     GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.     GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.     You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* This pass tries to find the optimal set of induction variables for the loop.    It optimizes just the basic linear induction variables (although adding    support for other types should not be too hard).  It includes the    optimizations commonly known as strength reduction, induction variable    coalescing and induction variable elimination.  It does it in the    following steps:     1) The interesting uses of induction variables are found.  This includes        -- uses of induction variables in non-linear expressions       -- addresses of arrays       -- comparisons of induction variables     2) Candidates for the induction variables are found.  This includes        -- old induction variables       -- the variables defined by expressions derived from the "interesting 	 uses" above     3) The optimal (w.r. to a cost function) set of variables is chosen.  The       cost function assigns a cost to sets of induction variables and consists       of three parts:        -- The use costs.  Each of the interesting uses chooses the best induction 	 variable in the set and adds its cost to the sum.  The cost reflects 	 the time spent on modifying the induction variables value to be usable 	 for the given purpose (adding base and offset for arrays, etc.).       -- The variable costs.  Each of the variables has a cost assigned that 	 reflects the costs associated with incrementing the value of the 	 variable.  The original variables are somewhat preferred.       -- The set cost.  Depending on the size of the set, extra cost may be 	 added to reflect register pressure.        All the costs are defined in a machine-specific way, using the target       hooks and machine descriptions to determine them.     4) The trees are transformed to use the new variables, the dead code is       removed.        All of this is done loop by loop.  Doing it globally is theoretically    possible, it might give a better performance and it might enable us    to decide costs more precisely, but getting all the interactions right    would be complicated.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_include
include|#
directive|include
file|"tree-flow.h"
end_include

begin_include
include|#
directive|include
file|"tree-dump.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"cfgloop.h"
end_include

begin_include
include|#
directive|include
file|"varray.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"tree-pass.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"hashtab.h"
end_include

begin_include
include|#
directive|include
file|"tree-chrec.h"
end_include

begin_include
include|#
directive|include
file|"tree-scalar-evolution.h"
end_include

begin_include
include|#
directive|include
file|"cfgloop.h"
end_include

begin_include
include|#
directive|include
file|"params.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_comment
comment|/* The infinite cost.  */
end_comment

begin_define
define|#
directive|define
name|INFTY
value|10000000
end_define

begin_comment
comment|/* The expected number of loop iterations.  TODO -- use profiling instead of    this.  */
end_comment

begin_define
define|#
directive|define
name|AVG_LOOP_NITER
parameter_list|(
name|LOOP
parameter_list|)
value|5
end_define

begin_comment
comment|/* Representation of the induction variable.  */
end_comment

begin_struct
struct|struct
name|iv
block|{
name|tree
name|base
decl_stmt|;
comment|/* Initial value of the iv.  */
name|tree
name|base_object
decl_stmt|;
comment|/* A memory object to that the induction variable points.  */
name|tree
name|step
decl_stmt|;
comment|/* Step of the iv (constant only).  */
name|tree
name|ssa_name
decl_stmt|;
comment|/* The ssa name with the value.  */
name|bool
name|biv_p
decl_stmt|;
comment|/* Is it a biv?  */
name|bool
name|have_use_for
decl_stmt|;
comment|/* Do we already have a use for it?  */
name|unsigned
name|use_id
decl_stmt|;
comment|/* The identifier in the use if it is the case.  */
block|}
struct|;
end_struct

begin_comment
comment|/* Per-ssa version information (induction variable descriptions, etc.).  */
end_comment

begin_struct
struct|struct
name|version_info
block|{
name|tree
name|name
decl_stmt|;
comment|/* The ssa name.  */
name|struct
name|iv
modifier|*
name|iv
decl_stmt|;
comment|/* Induction variable description.  */
name|bool
name|has_nonlin_use
decl_stmt|;
comment|/* For a loop-level invariant, whether it is used in 			   an expression that is not an induction variable.  */
name|unsigned
name|inv_id
decl_stmt|;
comment|/* Id of an invariant.  */
name|bool
name|preserve_biv
decl_stmt|;
comment|/* For the original biv, whether to preserve it.  */
block|}
struct|;
end_struct

begin_comment
comment|/* Types of uses.  */
end_comment

begin_enum
enum|enum
name|use_type
block|{
name|USE_NONLINEAR_EXPR
block|,
comment|/* Use in a nonlinear expression.  */
name|USE_ADDRESS
block|,
comment|/* Use in an address.  */
name|USE_COMPARE
comment|/* Use is a compare.  */
block|}
enum|;
end_enum

begin_comment
comment|/* The candidate - cost pair.  */
end_comment

begin_struct
struct|struct
name|cost_pair
block|{
name|struct
name|iv_cand
modifier|*
name|cand
decl_stmt|;
comment|/* The candidate.  */
name|unsigned
name|cost
decl_stmt|;
comment|/* The cost.  */
name|bitmap
name|depends_on
decl_stmt|;
comment|/* The list of invariants that have to be 			   preserved.  */
name|tree
name|value
decl_stmt|;
comment|/* For final value elimination, the expression for 			   the final value of the iv.  For iv elimination, 			   the new bound to compare with.  */
block|}
struct|;
end_struct

begin_comment
comment|/* Use.  */
end_comment

begin_struct
struct|struct
name|iv_use
block|{
name|unsigned
name|id
decl_stmt|;
comment|/* The id of the use.  */
name|enum
name|use_type
name|type
decl_stmt|;
comment|/* Type of the use.  */
name|struct
name|iv
modifier|*
name|iv
decl_stmt|;
comment|/* The induction variable it is based on.  */
name|tree
name|stmt
decl_stmt|;
comment|/* Statement in that it occurs.  */
name|tree
modifier|*
name|op_p
decl_stmt|;
comment|/* The place where it occurs.  */
name|bitmap
name|related_cands
decl_stmt|;
comment|/* The set of "related" iv candidates, plus the common 			   important ones.  */
name|unsigned
name|n_map_members
decl_stmt|;
comment|/* Number of candidates in the cost_map list.  */
name|struct
name|cost_pair
modifier|*
name|cost_map
decl_stmt|;
comment|/* The costs wrto the iv candidates.  */
name|struct
name|iv_cand
modifier|*
name|selected
decl_stmt|;
comment|/* The selected candidate.  */
block|}
struct|;
end_struct

begin_comment
comment|/* The position where the iv is computed.  */
end_comment

begin_enum
enum|enum
name|iv_position
block|{
name|IP_NORMAL
block|,
comment|/* At the end, just before the exit condition.  */
name|IP_END
block|,
comment|/* At the end of the latch block.  */
name|IP_ORIGINAL
comment|/* The original biv.  */
block|}
enum|;
end_enum

begin_comment
comment|/* The induction variable candidate.  */
end_comment

begin_struct
struct|struct
name|iv_cand
block|{
name|unsigned
name|id
decl_stmt|;
comment|/* The number of the candidate.  */
name|bool
name|important
decl_stmt|;
comment|/* Whether this is an "important" candidate, i.e. such 			   that it should be considered by all uses.  */
name|enum
name|iv_position
name|pos
decl_stmt|;
comment|/* Where it is computed.  */
name|tree
name|incremented_at
decl_stmt|;
comment|/* For original biv, the statement where it is 			   incremented.  */
name|tree
name|var_before
decl_stmt|;
comment|/* The variable used for it before increment.  */
name|tree
name|var_after
decl_stmt|;
comment|/* The variable used for it after increment.  */
name|struct
name|iv
modifier|*
name|iv
decl_stmt|;
comment|/* The value of the candidate.  NULL for 			   "pseudocandidate" used to indicate the possibility 			   to replace the final value of an iv by direct 			   computation of the value.  */
name|unsigned
name|cost
decl_stmt|;
comment|/* Cost of the candidate.  */
name|bitmap
name|depends_on
decl_stmt|;
comment|/* The list of invariants that are used in step of the 			   biv.  */
block|}
struct|;
end_struct

begin_comment
comment|/* The data used by the induction variable optimizations.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|iv_use
modifier|*
name|iv_use_p
typedef|;
end_typedef

begin_expr_stmt
name|DEF_VEC_P
argument_list|(
name|iv_use_p
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DEF_VEC_ALLOC_P
argument_list|(
name|iv_use_p
argument_list|,
name|heap
argument_list|)
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|struct
name|iv_cand
modifier|*
name|iv_cand_p
typedef|;
end_typedef

begin_expr_stmt
name|DEF_VEC_P
argument_list|(
name|iv_cand_p
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DEF_VEC_ALLOC_P
argument_list|(
name|iv_cand_p
argument_list|,
name|heap
argument_list|)
expr_stmt|;
end_expr_stmt

begin_struct
struct|struct
name|ivopts_data
block|{
comment|/* The currently optimized loop.  */
name|struct
name|loop
modifier|*
name|current_loop
decl_stmt|;
comment|/* Number of registers used in it.  */
name|unsigned
name|regs_used
decl_stmt|;
comment|/* Numbers of iterations for all exits of the current loop.  */
name|htab_t
name|niters
decl_stmt|;
comment|/* The size of version_info array allocated.  */
name|unsigned
name|version_info_size
decl_stmt|;
comment|/* The array of information for the ssa names.  */
name|struct
name|version_info
modifier|*
name|version_info
decl_stmt|;
comment|/* The bitmap of indices in version_info whose value was changed.  */
name|bitmap
name|relevant
decl_stmt|;
comment|/* The maximum invariant id.  */
name|unsigned
name|max_inv_id
decl_stmt|;
comment|/* The uses of induction variables.  */
name|VEC
argument_list|(
name|iv_use_p
argument_list|,
name|heap
argument_list|)
operator|*
name|iv_uses
expr_stmt|;
comment|/* The candidates.  */
name|VEC
argument_list|(
name|iv_cand_p
argument_list|,
name|heap
argument_list|)
operator|*
name|iv_candidates
expr_stmt|;
comment|/* A bitmap of important candidates.  */
name|bitmap
name|important_candidates
decl_stmt|;
comment|/* Whether to consider just related and important candidates when replacing a      use.  */
name|bool
name|consider_all_candidates
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* An assignment of iv candidates to uses.  */
end_comment

begin_struct
struct|struct
name|iv_ca
block|{
comment|/* The number of uses covered by the assignment.  */
name|unsigned
name|upto
decl_stmt|;
comment|/* Number of uses that cannot be expressed by the candidates in the set.  */
name|unsigned
name|bad_uses
decl_stmt|;
comment|/* Candidate assigned to a use, together with the related costs.  */
name|struct
name|cost_pair
modifier|*
modifier|*
name|cand_for_use
decl_stmt|;
comment|/* Number of times each candidate is used.  */
name|unsigned
modifier|*
name|n_cand_uses
decl_stmt|;
comment|/* The candidates used.  */
name|bitmap
name|cands
decl_stmt|;
comment|/* The number of candidates in the set.  */
name|unsigned
name|n_cands
decl_stmt|;
comment|/* Total number of registers needed.  */
name|unsigned
name|n_regs
decl_stmt|;
comment|/* Total cost of expressing uses.  */
name|unsigned
name|cand_use_cost
decl_stmt|;
comment|/* Total cost of candidates.  */
name|unsigned
name|cand_cost
decl_stmt|;
comment|/* Number of times each invariant is used.  */
name|unsigned
modifier|*
name|n_invariant_uses
decl_stmt|;
comment|/* Total cost of the assignment.  */
name|unsigned
name|cost
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Difference of two iv candidate assignments.  */
end_comment

begin_struct
struct|struct
name|iv_ca_delta
block|{
comment|/* Changed use.  */
name|struct
name|iv_use
modifier|*
name|use
decl_stmt|;
comment|/* An old assignment (for rollback purposes).  */
name|struct
name|cost_pair
modifier|*
name|old_cp
decl_stmt|;
comment|/* A new assignment.  */
name|struct
name|cost_pair
modifier|*
name|new_cp
decl_stmt|;
comment|/* Next change in the list.  */
name|struct
name|iv_ca_delta
modifier|*
name|next_change
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Bound on number of candidates below that all candidates are considered.  */
end_comment

begin_define
define|#
directive|define
name|CONSIDER_ALL_CANDIDATES_BOUND
define|\
value|((unsigned) PARAM_VALUE (PARAM_IV_CONSIDER_ALL_CANDIDATES_BOUND))
end_define

begin_comment
comment|/* If there are more iv occurrences, we just give up (it is quite unlikely that    optimizing such a loop would help, and it would take ages).  */
end_comment

begin_define
define|#
directive|define
name|MAX_CONSIDERED_USES
define|\
value|((unsigned) PARAM_VALUE (PARAM_IV_MAX_CONSIDERED_USES))
end_define

begin_comment
comment|/* If there are at most this number of ivs in the set, try removing unnecessary    ivs from the set always.  */
end_comment

begin_define
define|#
directive|define
name|ALWAYS_PRUNE_CAND_SET_BOUND
define|\
value|((unsigned) PARAM_VALUE (PARAM_IV_ALWAYS_PRUNE_CAND_SET_BOUND))
end_define

begin_comment
comment|/* The list of trees for that the decl_rtl field must be reset is stored    here.  */
end_comment

begin_expr_stmt
specifier|static
name|VEC
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|)
operator|*
name|decl_rtl_to_reset
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Number of uses recorded in DATA.  */
end_comment

begin_function
specifier|static
specifier|inline
name|unsigned
name|n_iv_uses
parameter_list|(
name|struct
name|ivopts_data
modifier|*
name|data
parameter_list|)
block|{
return|return
name|VEC_length
argument_list|(
name|iv_use_p
argument_list|,
name|data
operator|->
name|iv_uses
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Ith use recorded in DATA.  */
end_comment

begin_function
specifier|static
specifier|inline
name|struct
name|iv_use
modifier|*
name|iv_use
parameter_list|(
name|struct
name|ivopts_data
modifier|*
name|data
parameter_list|,
name|unsigned
name|i
parameter_list|)
block|{
return|return
name|VEC_index
argument_list|(
name|iv_use_p
argument_list|,
name|data
operator|->
name|iv_uses
argument_list|,
name|i
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Number of candidates recorded in DATA.  */
end_comment

begin_function
specifier|static
specifier|inline
name|unsigned
name|n_iv_cands
parameter_list|(
name|struct
name|ivopts_data
modifier|*
name|data
parameter_list|)
block|{
return|return
name|VEC_length
argument_list|(
name|iv_cand_p
argument_list|,
name|data
operator|->
name|iv_candidates
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Ith candidate recorded in DATA.  */
end_comment

begin_function
specifier|static
specifier|inline
name|struct
name|iv_cand
modifier|*
name|iv_cand
parameter_list|(
name|struct
name|ivopts_data
modifier|*
name|data
parameter_list|,
name|unsigned
name|i
parameter_list|)
block|{
return|return
name|VEC_index
argument_list|(
name|iv_cand_p
argument_list|,
name|data
operator|->
name|iv_candidates
argument_list|,
name|i
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* The single loop exit if it dominates the latch, NULL otherwise.  */
end_comment

begin_function
name|edge
name|single_dom_exit
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|)
block|{
name|edge
name|exit
init|=
name|loop
operator|->
name|single_exit
decl_stmt|;
if|if
condition|(
operator|!
name|exit
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|just_once_each_iteration_p
argument_list|(
name|loop
argument_list|,
name|exit
operator|->
name|src
argument_list|)
condition|)
return|return
name|NULL
return|;
return|return
name|exit
return|;
block|}
end_function

begin_comment
comment|/* Dumps information about the induction variable IV to FILE.  */
end_comment

begin_function_decl
specifier|extern
name|void
name|dump_iv
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|struct
name|iv
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|dump_iv
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|struct
name|iv
modifier|*
name|iv
parameter_list|)
block|{
if|if
condition|(
name|iv
operator|->
name|ssa_name
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"ssa name "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|file
argument_list|,
name|iv
operator|->
name|ssa_name
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"  type "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|file
argument_list|,
name|TREE_TYPE
argument_list|(
name|iv
operator|->
name|base
argument_list|)
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|iv
operator|->
name|step
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"  base "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|file
argument_list|,
name|iv
operator|->
name|base
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"  step "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|file
argument_list|,
name|iv
operator|->
name|step
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"  invariant "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|file
argument_list|,
name|iv
operator|->
name|base
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|iv
operator|->
name|base_object
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"  base object "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|file
argument_list|,
name|iv
operator|->
name|base_object
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|iv
operator|->
name|biv_p
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"  is a biv\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dumps information about the USE to FILE.  */
end_comment

begin_function_decl
specifier|extern
name|void
name|dump_use
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|struct
name|iv_use
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|dump_use
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|struct
name|iv_use
modifier|*
name|use
parameter_list|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"use %d\n"
argument_list|,
name|use
operator|->
name|id
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|use
operator|->
name|type
condition|)
block|{
case|case
name|USE_NONLINEAR_EXPR
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"  generic\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|USE_ADDRESS
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"  address\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|USE_COMPARE
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"  compare\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"  in statement "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|file
argument_list|,
name|use
operator|->
name|stmt
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"  at position "
argument_list|)
expr_stmt|;
if|if
condition|(
name|use
operator|->
name|op_p
condition|)
name|print_generic_expr
argument_list|(
name|file
argument_list|,
operator|*
name|use
operator|->
name|op_p
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|dump_iv
argument_list|(
name|file
argument_list|,
name|use
operator|->
name|iv
argument_list|)
expr_stmt|;
if|if
condition|(
name|use
operator|->
name|related_cands
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"  related candidates "
argument_list|)
expr_stmt|;
name|dump_bitmap
argument_list|(
name|file
argument_list|,
name|use
operator|->
name|related_cands
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Dumps information about the uses to FILE.  */
end_comment

begin_function_decl
specifier|extern
name|void
name|dump_uses
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|struct
name|ivopts_data
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|dump_uses
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|struct
name|ivopts_data
modifier|*
name|data
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
name|struct
name|iv_use
modifier|*
name|use
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_iv_uses
argument_list|(
name|data
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|use
operator|=
name|iv_use
argument_list|(
name|data
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|dump_use
argument_list|(
name|file
argument_list|,
name|use
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Dumps information about induction variable candidate CAND to FILE.  */
end_comment

begin_function_decl
specifier|extern
name|void
name|dump_cand
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|struct
name|iv_cand
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|dump_cand
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|struct
name|iv_cand
modifier|*
name|cand
parameter_list|)
block|{
name|struct
name|iv
modifier|*
name|iv
init|=
name|cand
operator|->
name|iv
decl_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"candidate %d%s\n"
argument_list|,
name|cand
operator|->
name|id
argument_list|,
name|cand
operator|->
name|important
condition|?
literal|" (important)"
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|cand
operator|->
name|depends_on
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"  depends on "
argument_list|)
expr_stmt|;
name|dump_bitmap
argument_list|(
name|file
argument_list|,
name|cand
operator|->
name|depends_on
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|iv
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"  final value replacement\n"
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|cand
operator|->
name|pos
condition|)
block|{
case|case
name|IP_NORMAL
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"  incremented before exit test\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|IP_END
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"  incremented at end\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|IP_ORIGINAL
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"  original biv\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|dump_iv
argument_list|(
name|file
argument_list|,
name|iv
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns the info for ssa version VER.  */
end_comment

begin_function
specifier|static
specifier|inline
name|struct
name|version_info
modifier|*
name|ver_info
parameter_list|(
name|struct
name|ivopts_data
modifier|*
name|data
parameter_list|,
name|unsigned
name|ver
parameter_list|)
block|{
return|return
name|data
operator|->
name|version_info
operator|+
name|ver
return|;
block|}
end_function

begin_comment
comment|/* Returns the info for ssa name NAME.  */
end_comment

begin_function
specifier|static
specifier|inline
name|struct
name|version_info
modifier|*
name|name_info
parameter_list|(
name|struct
name|ivopts_data
modifier|*
name|data
parameter_list|,
name|tree
name|name
parameter_list|)
block|{
return|return
name|ver_info
argument_list|(
name|data
argument_list|,
name|SSA_NAME_VERSION
argument_list|(
name|name
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Checks whether there exists number X such that X * B = A, counting modulo    2^BITS.  */
end_comment

begin_function
specifier|static
name|bool
name|divide
parameter_list|(
name|unsigned
name|bits
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|a
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|b
parameter_list|,
name|HOST_WIDE_INT
modifier|*
name|x
parameter_list|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|mask
init|=
operator|~
operator|(
operator|~
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|0
operator|<<
operator|(
name|bits
operator|-
literal|1
operator|)
operator|<<
literal|1
operator|)
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|inv
decl_stmt|,
name|ex
decl_stmt|,
name|val
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|a
operator|&=
name|mask
expr_stmt|;
name|b
operator|&=
name|mask
expr_stmt|;
comment|/* First divide the whole equation by 2 as long as possible.  */
while|while
condition|(
operator|!
operator|(
name|a
operator|&
literal|1
operator|)
operator|&&
operator|!
operator|(
name|b
operator|&
literal|1
operator|)
condition|)
block|{
name|a
operator|>>=
literal|1
expr_stmt|;
name|b
operator|>>=
literal|1
expr_stmt|;
name|bits
operator|--
expr_stmt|;
name|mask
operator|>>=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|b
operator|&
literal|1
operator|)
condition|)
block|{
comment|/* If b is still even, a is odd and there is no such x.  */
return|return
name|false
return|;
block|}
comment|/* Find the inverse of b.  We compute it as      b^(2^(bits - 1) - 1) (mod 2^bits).  */
name|inv
operator|=
literal|1
expr_stmt|;
name|ex
operator|=
name|b
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bits
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|inv
operator|=
operator|(
name|inv
operator|*
name|ex
operator|)
operator|&
name|mask
expr_stmt|;
name|ex
operator|=
operator|(
name|ex
operator|*
name|ex
operator|)
operator|&
name|mask
expr_stmt|;
block|}
name|val
operator|=
operator|(
name|a
operator|*
name|inv
operator|)
operator|&
name|mask
expr_stmt|;
name|gcc_assert
argument_list|(
operator|(
operator|(
name|val
operator|*
name|b
operator|)
operator|&
name|mask
operator|)
operator|==
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|>>
operator|(
name|bits
operator|-
literal|1
operator|)
operator|)
operator|&
literal|1
condition|)
name|val
operator||=
operator|~
name|mask
expr_stmt|;
operator|*
name|x
operator|=
name|val
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Returns true if STMT is after the place where the IP_NORMAL ivs will be    emitted in LOOP.  */
end_comment

begin_function
specifier|static
name|bool
name|stmt_after_ip_normal_pos
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|tree
name|stmt
parameter_list|)
block|{
name|basic_block
name|bb
init|=
name|ip_normal_pos
argument_list|(
name|loop
argument_list|)
decl_stmt|,
name|sbb
init|=
name|bb_for_stmt
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
name|bb
argument_list|)
expr_stmt|;
if|if
condition|(
name|sbb
operator|==
name|loop
operator|->
name|latch
condition|)
return|return
name|true
return|;
if|if
condition|(
name|sbb
operator|!=
name|bb
condition|)
return|return
name|false
return|;
return|return
name|stmt
operator|==
name|last_stmt
argument_list|(
name|bb
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns true if STMT if after the place where the original induction    variable CAND is incremented.  */
end_comment

begin_function
specifier|static
name|bool
name|stmt_after_ip_original_pos
parameter_list|(
name|struct
name|iv_cand
modifier|*
name|cand
parameter_list|,
name|tree
name|stmt
parameter_list|)
block|{
name|basic_block
name|cand_bb
init|=
name|bb_for_stmt
argument_list|(
name|cand
operator|->
name|incremented_at
argument_list|)
decl_stmt|;
name|basic_block
name|stmt_bb
init|=
name|bb_for_stmt
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
name|block_stmt_iterator
name|bsi
decl_stmt|;
if|if
condition|(
operator|!
name|dominated_by_p
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|stmt_bb
argument_list|,
name|cand_bb
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|stmt_bb
operator|!=
name|cand_bb
condition|)
return|return
name|true
return|;
comment|/* Scan the block from the end, since the original ivs are usually      incremented at the end of the loop body.  */
for|for
control|(
name|bsi
operator|=
name|bsi_last
argument_list|(
name|stmt_bb
argument_list|)
init|;
condition|;
name|bsi_prev
argument_list|(
operator|&
name|bsi
argument_list|)
control|)
block|{
if|if
condition|(
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
operator|==
name|cand
operator|->
name|incremented_at
condition|)
return|return
name|false
return|;
if|if
condition|(
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
operator|==
name|stmt
condition|)
return|return
name|true
return|;
block|}
block|}
end_function

begin_comment
comment|/* Returns true if STMT if after the place where the induction variable    CAND is incremented in LOOP.  */
end_comment

begin_function
specifier|static
name|bool
name|stmt_after_increment
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|struct
name|iv_cand
modifier|*
name|cand
parameter_list|,
name|tree
name|stmt
parameter_list|)
block|{
switch|switch
condition|(
name|cand
operator|->
name|pos
condition|)
block|{
case|case
name|IP_END
case|:
return|return
name|false
return|;
case|case
name|IP_NORMAL
case|:
return|return
name|stmt_after_ip_normal_pos
argument_list|(
name|loop
argument_list|,
name|stmt
argument_list|)
return|;
case|case
name|IP_ORIGINAL
case|:
return|return
name|stmt_after_ip_original_pos
argument_list|(
name|cand
argument_list|,
name|stmt
argument_list|)
return|;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Returns true if EXP is a ssa name that occurs in an abnormal phi node.  */
end_comment

begin_function
specifier|static
name|bool
name|abnormal_ssa_name_p
parameter_list|(
name|tree
name|exp
parameter_list|)
block|{
if|if
condition|(
operator|!
name|exp
condition|)
return|return
name|false
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|!=
name|SSA_NAME
condition|)
return|return
name|false
return|;
return|return
name|SSA_NAME_OCCURS_IN_ABNORMAL_PHI
argument_list|(
name|exp
argument_list|)
operator|!=
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Returns false if BASE or INDEX contains a ssa name that occurs in an    abnormal phi node.  Callback for for_each_index.  */
end_comment

begin_function
specifier|static
name|bool
name|idx_contains_abnormal_ssa_name_p
parameter_list|(
name|tree
name|base
parameter_list|,
name|tree
modifier|*
name|index
parameter_list|,
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|ARRAY_REF
condition|)
block|{
if|if
condition|(
name|abnormal_ssa_name_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|base
argument_list|,
literal|2
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|abnormal_ssa_name_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|base
argument_list|,
literal|3
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
block|}
return|return
operator|!
name|abnormal_ssa_name_p
argument_list|(
operator|*
name|index
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns true if EXPR contains a ssa name that occurs in an    abnormal phi node.  */
end_comment

begin_function
name|bool
name|contains_abnormal_ssa_name_p
parameter_list|(
name|tree
name|expr
parameter_list|)
block|{
name|enum
name|tree_code
name|code
decl_stmt|;
name|enum
name|tree_code_class
name|class
decl_stmt|;
if|if
condition|(
operator|!
name|expr
condition|)
return|return
name|false
return|;
name|code
operator|=
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|class
operator|=
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|SSA_NAME
condition|)
return|return
name|SSA_NAME_OCCURS_IN_ABNORMAL_PHI
argument_list|(
name|expr
argument_list|)
operator|!=
literal|0
return|;
if|if
condition|(
name|code
operator|==
name|INTEGER_CST
operator|||
name|is_gimple_min_invariant
argument_list|(
name|expr
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|code
operator|==
name|ADDR_EXPR
condition|)
return|return
operator|!
name|for_each_index
argument_list|(
operator|&
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|idx_contains_abnormal_ssa_name_p
argument_list|,
name|NULL
argument_list|)
return|;
switch|switch
condition|(
name|class
condition|)
block|{
case|case
name|tcc_binary
case|:
case|case
name|tcc_comparison
case|:
if|if
condition|(
name|contains_abnormal_ssa_name_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
comment|/* Fallthru.  */
case|case
name|tcc_unary
case|:
if|if
condition|(
name|contains_abnormal_ssa_name_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Element of the table in that we cache the numbers of iterations obtained    from exits of the loop.  */
end_comment

begin_struct
struct|struct
name|nfe_cache_elt
block|{
comment|/* The edge for that the number of iterations is cached.  */
name|edge
name|exit
decl_stmt|;
comment|/* Number of iterations corresponding to this exit, or NULL if it cannot be      determined.  */
name|tree
name|niter
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Hash function for nfe_cache_elt E.  */
end_comment

begin_function
specifier|static
name|hashval_t
name|nfe_hash
parameter_list|(
specifier|const
name|void
modifier|*
name|e
parameter_list|)
block|{
specifier|const
name|struct
name|nfe_cache_elt
modifier|*
name|elt
init|=
name|e
decl_stmt|;
return|return
name|htab_hash_pointer
argument_list|(
name|elt
operator|->
name|exit
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Equality function for nfe_cache_elt E1 and edge E2.  */
end_comment

begin_function
specifier|static
name|int
name|nfe_eq
parameter_list|(
specifier|const
name|void
modifier|*
name|e1
parameter_list|,
specifier|const
name|void
modifier|*
name|e2
parameter_list|)
block|{
specifier|const
name|struct
name|nfe_cache_elt
modifier|*
name|elt1
init|=
name|e1
decl_stmt|;
return|return
name|elt1
operator|->
name|exit
operator|==
name|e2
return|;
block|}
end_function

begin_comment
comment|/*  Returns tree describing number of iterations determined from     EXIT of DATA->current_loop, or NULL if something goes wrong.  */
end_comment

begin_function
specifier|static
name|tree
name|niter_for_exit
parameter_list|(
name|struct
name|ivopts_data
modifier|*
name|data
parameter_list|,
name|edge
name|exit
parameter_list|)
block|{
name|struct
name|nfe_cache_elt
modifier|*
name|nfe_desc
decl_stmt|;
name|struct
name|tree_niter_desc
name|desc
decl_stmt|;
name|PTR
modifier|*
name|slot
decl_stmt|;
name|slot
operator|=
name|htab_find_slot_with_hash
argument_list|(
name|data
operator|->
name|niters
argument_list|,
name|exit
argument_list|,
name|htab_hash_pointer
argument_list|(
name|exit
argument_list|)
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|slot
condition|)
block|{
name|nfe_desc
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|nfe_cache_elt
argument_list|)
argument_list|)
expr_stmt|;
name|nfe_desc
operator|->
name|exit
operator|=
name|exit
expr_stmt|;
comment|/* Try to determine number of iterations.  We must know it 	 unconditionally (i.e., without possibility of # of iterations 	 being zero).  Also, we cannot safely work with ssa names that 	 appear in phi nodes on abnormal edges, so that we do not create 	 overlapping life ranges for them (PR 27283).  */
if|if
condition|(
name|number_of_iterations_exit
argument_list|(
name|data
operator|->
name|current_loop
argument_list|,
name|exit
argument_list|,
operator|&
name|desc
argument_list|,
name|true
argument_list|)
operator|&&
name|zero_p
argument_list|(
name|desc
operator|.
name|may_be_zero
argument_list|)
operator|&&
operator|!
name|contains_abnormal_ssa_name_p
argument_list|(
name|desc
operator|.
name|niter
argument_list|)
condition|)
name|nfe_desc
operator|->
name|niter
operator|=
name|desc
operator|.
name|niter
expr_stmt|;
else|else
name|nfe_desc
operator|->
name|niter
operator|=
name|NULL_TREE
expr_stmt|;
block|}
else|else
name|nfe_desc
operator|=
operator|*
name|slot
expr_stmt|;
return|return
name|nfe_desc
operator|->
name|niter
return|;
block|}
end_function

begin_comment
comment|/* Returns tree describing number of iterations determined from    single dominating exit of DATA->current_loop, or NULL if something    goes wrong.  */
end_comment

begin_function
specifier|static
name|tree
name|niter_for_single_dom_exit
parameter_list|(
name|struct
name|ivopts_data
modifier|*
name|data
parameter_list|)
block|{
name|edge
name|exit
init|=
name|single_dom_exit
argument_list|(
name|data
operator|->
name|current_loop
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|exit
condition|)
return|return
name|NULL
return|;
return|return
name|niter_for_exit
argument_list|(
name|data
argument_list|,
name|exit
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Initializes data structures used by the iv optimization pass, stored    in DATA.  */
end_comment

begin_function
specifier|static
name|void
name|tree_ssa_iv_optimize_init
parameter_list|(
name|struct
name|ivopts_data
modifier|*
name|data
parameter_list|)
block|{
name|data
operator|->
name|version_info_size
operator|=
literal|2
operator|*
name|num_ssa_names
expr_stmt|;
name|data
operator|->
name|version_info
operator|=
name|XCNEWVEC
argument_list|(
expr|struct
name|version_info
argument_list|,
name|data
operator|->
name|version_info_size
argument_list|)
expr_stmt|;
name|data
operator|->
name|relevant
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|data
operator|->
name|important_candidates
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|data
operator|->
name|max_inv_id
operator|=
literal|0
expr_stmt|;
name|data
operator|->
name|niters
operator|=
name|htab_create
argument_list|(
literal|10
argument_list|,
name|nfe_hash
argument_list|,
name|nfe_eq
argument_list|,
name|free
argument_list|)
expr_stmt|;
name|data
operator|->
name|iv_uses
operator|=
name|VEC_alloc
argument_list|(
name|iv_use_p
argument_list|,
name|heap
argument_list|,
literal|20
argument_list|)
expr_stmt|;
name|data
operator|->
name|iv_candidates
operator|=
name|VEC_alloc
argument_list|(
name|iv_cand_p
argument_list|,
name|heap
argument_list|,
literal|20
argument_list|)
expr_stmt|;
name|decl_rtl_to_reset
operator|=
name|VEC_alloc
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
literal|20
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns a memory object to that EXPR points.  In case we are able to    determine that it does not point to any such object, NULL is returned.  */
end_comment

begin_function
specifier|static
name|tree
name|determine_base_object
parameter_list|(
name|tree
name|expr
parameter_list|)
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
decl_stmt|;
name|tree
name|base
decl_stmt|,
name|obj
decl_stmt|,
name|op0
decl_stmt|,
name|op1
decl_stmt|;
comment|/* If this is a pointer casted to any type, we need to determine      the base object for the pointer; so handle conversions before      throwing away non-pointer expressions.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|CONVERT_EXPR
condition|)
return|return
name|determine_base_object
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
if|if
condition|(
operator|!
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|INTEGER_CST
case|:
return|return
name|NULL_TREE
return|;
case|case
name|ADDR_EXPR
case|:
name|obj
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|base
operator|=
name|get_base_address
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|base
condition|)
return|return
name|expr
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|INDIRECT_REF
condition|)
return|return
name|determine_base_object
argument_list|(
name|TREE_OPERAND
argument_list|(
name|base
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
return|return
name|fold_convert
argument_list|(
name|ptr_type_node
argument_list|,
name|build_fold_addr_expr
argument_list|(
name|base
argument_list|)
argument_list|)
return|;
case|case
name|PLUS_EXPR
case|:
case|case
name|MINUS_EXPR
case|:
name|op0
operator|=
name|determine_base_object
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|op1
operator|=
name|determine_base_object
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|op1
condition|)
return|return
name|op0
return|;
if|if
condition|(
operator|!
name|op0
condition|)
return|return
operator|(
name|code
operator|==
name|PLUS_EXPR
condition|?
name|op1
else|:
name|fold_build1
argument_list|(
name|NEGATE_EXPR
argument_list|,
name|ptr_type_node
argument_list|,
name|op1
argument_list|)
operator|)
return|;
return|return
name|fold_build2
argument_list|(
name|code
argument_list|,
name|ptr_type_node
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
return|;
default|default:
return|return
name|fold_convert
argument_list|(
name|ptr_type_node
argument_list|,
name|expr
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Allocates an induction variable with given initial value BASE and step STEP    for loop LOOP.  */
end_comment

begin_function
specifier|static
name|struct
name|iv
modifier|*
name|alloc_iv
parameter_list|(
name|tree
name|base
parameter_list|,
name|tree
name|step
parameter_list|)
block|{
name|struct
name|iv
modifier|*
name|iv
init|=
name|XCNEW
argument_list|(
expr|struct
name|iv
argument_list|)
decl_stmt|;
if|if
condition|(
name|step
operator|&&
name|integer_zerop
argument_list|(
name|step
argument_list|)
condition|)
name|step
operator|=
name|NULL_TREE
expr_stmt|;
name|iv
operator|->
name|base
operator|=
name|base
expr_stmt|;
name|iv
operator|->
name|base_object
operator|=
name|determine_base_object
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|iv
operator|->
name|step
operator|=
name|step
expr_stmt|;
name|iv
operator|->
name|biv_p
operator|=
name|false
expr_stmt|;
name|iv
operator|->
name|have_use_for
operator|=
name|false
expr_stmt|;
name|iv
operator|->
name|use_id
operator|=
literal|0
expr_stmt|;
name|iv
operator|->
name|ssa_name
operator|=
name|NULL_TREE
expr_stmt|;
return|return
name|iv
return|;
block|}
end_function

begin_comment
comment|/* Sets STEP and BASE for induction variable IV.  */
end_comment

begin_function
specifier|static
name|void
name|set_iv
parameter_list|(
name|struct
name|ivopts_data
modifier|*
name|data
parameter_list|,
name|tree
name|iv
parameter_list|,
name|tree
name|base
parameter_list|,
name|tree
name|step
parameter_list|)
block|{
name|struct
name|version_info
modifier|*
name|info
init|=
name|name_info
argument_list|(
name|data
argument_list|,
name|iv
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|info
operator|->
name|iv
argument_list|)
expr_stmt|;
name|bitmap_set_bit
argument_list|(
name|data
operator|->
name|relevant
argument_list|,
name|SSA_NAME_VERSION
argument_list|(
name|iv
argument_list|)
argument_list|)
expr_stmt|;
name|info
operator|->
name|iv
operator|=
name|alloc_iv
argument_list|(
name|base
argument_list|,
name|step
argument_list|)
expr_stmt|;
name|info
operator|->
name|iv
operator|->
name|ssa_name
operator|=
name|iv
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finds induction variable declaration for VAR.  */
end_comment

begin_function
specifier|static
name|struct
name|iv
modifier|*
name|get_iv
parameter_list|(
name|struct
name|ivopts_data
modifier|*
name|data
parameter_list|,
name|tree
name|var
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
if|if
condition|(
operator|!
name|name_info
argument_list|(
name|data
argument_list|,
name|var
argument_list|)
operator|->
name|iv
condition|)
block|{
name|bb
operator|=
name|bb_for_stmt
argument_list|(
name|SSA_NAME_DEF_STMT
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bb
operator|||
operator|!
name|flow_bb_inside_loop_p
argument_list|(
name|data
operator|->
name|current_loop
argument_list|,
name|bb
argument_list|)
condition|)
name|set_iv
argument_list|(
name|data
argument_list|,
name|var
argument_list|,
name|var
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
return|return
name|name_info
argument_list|(
name|data
argument_list|,
name|var
argument_list|)
operator|->
name|iv
return|;
block|}
end_function

begin_comment
comment|/* Determines the step of a biv defined in PHI.  Returns NULL if PHI does    not define a simple affine biv with nonzero step.  */
end_comment

begin_function
specifier|static
name|tree
name|determine_biv_step
parameter_list|(
name|tree
name|phi
parameter_list|)
block|{
name|struct
name|loop
modifier|*
name|loop
init|=
name|bb_for_stmt
argument_list|(
name|phi
argument_list|)
operator|->
name|loop_father
decl_stmt|;
name|tree
name|name
init|=
name|PHI_RESULT
argument_list|(
name|phi
argument_list|)
decl_stmt|;
name|affine_iv
name|iv
decl_stmt|;
if|if
condition|(
operator|!
name|is_gimple_reg
argument_list|(
name|name
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
operator|!
name|simple_iv
argument_list|(
name|loop
argument_list|,
name|phi
argument_list|,
name|name
argument_list|,
operator|&
name|iv
argument_list|,
name|true
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
return|return
operator|(
name|zero_p
argument_list|(
name|iv
operator|.
name|step
argument_list|)
condition|?
name|NULL_TREE
else|:
name|iv
operator|.
name|step
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Finds basic ivs.  */
end_comment

begin_function
specifier|static
name|bool
name|find_bivs
parameter_list|(
name|struct
name|ivopts_data
modifier|*
name|data
parameter_list|)
block|{
name|tree
name|phi
decl_stmt|,
name|step
decl_stmt|,
name|type
decl_stmt|,
name|base
decl_stmt|;
name|bool
name|found
init|=
name|false
decl_stmt|;
name|struct
name|loop
modifier|*
name|loop
init|=
name|data
operator|->
name|current_loop
decl_stmt|;
for|for
control|(
name|phi
operator|=
name|phi_nodes
argument_list|(
name|loop
operator|->
name|header
argument_list|)
init|;
name|phi
condition|;
name|phi
operator|=
name|PHI_CHAIN
argument_list|(
name|phi
argument_list|)
control|)
block|{
if|if
condition|(
name|SSA_NAME_OCCURS_IN_ABNORMAL_PHI
argument_list|(
name|PHI_RESULT
argument_list|(
name|phi
argument_list|)
argument_list|)
condition|)
continue|continue;
name|step
operator|=
name|determine_biv_step
argument_list|(
name|phi
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|step
condition|)
continue|continue;
name|base
operator|=
name|PHI_ARG_DEF_FROM_EDGE
argument_list|(
name|phi
argument_list|,
name|loop_preheader_edge
argument_list|(
name|loop
argument_list|)
argument_list|)
expr_stmt|;
name|base
operator|=
name|expand_simple_operations
argument_list|(
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|contains_abnormal_ssa_name_p
argument_list|(
name|base
argument_list|)
operator|||
name|contains_abnormal_ssa_name_p
argument_list|(
name|step
argument_list|)
condition|)
continue|continue;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|PHI_RESULT
argument_list|(
name|phi
argument_list|)
argument_list|)
expr_stmt|;
name|base
operator|=
name|fold_convert
argument_list|(
name|type
argument_list|,
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|step
condition|)
name|step
operator|=
name|fold_convert
argument_list|(
name|type
argument_list|,
name|step
argument_list|)
expr_stmt|;
name|set_iv
argument_list|(
name|data
argument_list|,
name|PHI_RESULT
argument_list|(
name|phi
argument_list|)
argument_list|,
name|base
argument_list|,
name|step
argument_list|)
expr_stmt|;
name|found
operator|=
name|true
expr_stmt|;
block|}
return|return
name|found
return|;
block|}
end_function

begin_comment
comment|/* Marks basic ivs.  */
end_comment

begin_function
specifier|static
name|void
name|mark_bivs
parameter_list|(
name|struct
name|ivopts_data
modifier|*
name|data
parameter_list|)
block|{
name|tree
name|phi
decl_stmt|,
name|var
decl_stmt|;
name|struct
name|iv
modifier|*
name|iv
decl_stmt|,
modifier|*
name|incr_iv
decl_stmt|;
name|struct
name|loop
modifier|*
name|loop
init|=
name|data
operator|->
name|current_loop
decl_stmt|;
name|basic_block
name|incr_bb
decl_stmt|;
for|for
control|(
name|phi
operator|=
name|phi_nodes
argument_list|(
name|loop
operator|->
name|header
argument_list|)
init|;
name|phi
condition|;
name|phi
operator|=
name|PHI_CHAIN
argument_list|(
name|phi
argument_list|)
control|)
block|{
name|iv
operator|=
name|get_iv
argument_list|(
name|data
argument_list|,
name|PHI_RESULT
argument_list|(
name|phi
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|iv
condition|)
continue|continue;
name|var
operator|=
name|PHI_ARG_DEF_FROM_EDGE
argument_list|(
name|phi
argument_list|,
name|loop_latch_edge
argument_list|(
name|loop
argument_list|)
argument_list|)
expr_stmt|;
name|incr_iv
operator|=
name|get_iv
argument_list|(
name|data
argument_list|,
name|var
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|incr_iv
condition|)
continue|continue;
comment|/* If the increment is in the subloop, ignore it.  */
name|incr_bb
operator|=
name|bb_for_stmt
argument_list|(
name|SSA_NAME_DEF_STMT
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|incr_bb
operator|->
name|loop_father
operator|!=
name|data
operator|->
name|current_loop
operator|||
operator|(
name|incr_bb
operator|->
name|flags
operator|&
name|BB_IRREDUCIBLE_LOOP
operator|)
condition|)
continue|continue;
name|iv
operator|->
name|biv_p
operator|=
name|true
expr_stmt|;
name|incr_iv
operator|->
name|biv_p
operator|=
name|true
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Checks whether STMT defines a linear induction variable and stores its    parameters to IV.  */
end_comment

begin_function
specifier|static
name|bool
name|find_givs_in_stmt_scev
parameter_list|(
name|struct
name|ivopts_data
modifier|*
name|data
parameter_list|,
name|tree
name|stmt
parameter_list|,
name|affine_iv
modifier|*
name|iv
parameter_list|)
block|{
name|tree
name|lhs
decl_stmt|;
name|struct
name|loop
modifier|*
name|loop
init|=
name|data
operator|->
name|current_loop
decl_stmt|;
name|iv
operator|->
name|base
operator|=
name|NULL_TREE
expr_stmt|;
name|iv
operator|->
name|step
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|!=
name|MODIFY_EXPR
condition|)
return|return
name|false
return|;
name|lhs
operator|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|lhs
argument_list|)
operator|!=
name|SSA_NAME
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|simple_iv
argument_list|(
name|loop
argument_list|,
name|stmt
argument_list|,
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
argument_list|,
name|iv
argument_list|,
name|true
argument_list|)
condition|)
return|return
name|false
return|;
name|iv
operator|->
name|base
operator|=
name|expand_simple_operations
argument_list|(
name|iv
operator|->
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|contains_abnormal_ssa_name_p
argument_list|(
name|iv
operator|->
name|base
argument_list|)
operator|||
name|contains_abnormal_ssa_name_p
argument_list|(
name|iv
operator|->
name|step
argument_list|)
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Finds general ivs in statement STMT.  */
end_comment

begin_function
specifier|static
name|void
name|find_givs_in_stmt
parameter_list|(
name|struct
name|ivopts_data
modifier|*
name|data
parameter_list|,
name|tree
name|stmt
parameter_list|)
block|{
name|affine_iv
name|iv
decl_stmt|;
if|if
condition|(
operator|!
name|find_givs_in_stmt_scev
argument_list|(
name|data
argument_list|,
name|stmt
argument_list|,
operator|&
name|iv
argument_list|)
condition|)
return|return;
name|set_iv
argument_list|(
name|data
argument_list|,
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
argument_list|,
name|iv
operator|.
name|base
argument_list|,
name|iv
operator|.
name|step
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finds general ivs in basic block BB.  */
end_comment

begin_function
specifier|static
name|void
name|find_givs_in_bb
parameter_list|(
name|struct
name|ivopts_data
modifier|*
name|data
parameter_list|,
name|basic_block
name|bb
parameter_list|)
block|{
name|block_stmt_iterator
name|bsi
decl_stmt|;
for|for
control|(
name|bsi
operator|=
name|bsi_start
argument_list|(
name|bb
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|;
name|bsi_next
argument_list|(
operator|&
name|bsi
argument_list|)
control|)
name|find_givs_in_stmt
argument_list|(
name|data
argument_list|,
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finds general ivs.  */
end_comment

begin_function
specifier|static
name|void
name|find_givs
parameter_list|(
name|struct
name|ivopts_data
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|loop
modifier|*
name|loop
init|=
name|data
operator|->
name|current_loop
decl_stmt|;
name|basic_block
modifier|*
name|body
init|=
name|get_loop_body_in_dom_order
argument_list|(
name|loop
argument_list|)
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|loop
operator|->
name|num_nodes
condition|;
name|i
operator|++
control|)
name|find_givs_in_bb
argument_list|(
name|data
argument_list|,
name|body
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|body
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* For each ssa name defined in LOOP determines whether it is an induction    variable and if so, its initial value and step.  */
end_comment

begin_function
specifier|static
name|bool
name|find_induction_variables
parameter_list|(
name|struct
name|ivopts_data
modifier|*
name|data
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
if|if
condition|(
operator|!
name|find_bivs
argument_list|(
name|data
argument_list|)
condition|)
return|return
name|false
return|;
name|find_givs
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|mark_bivs
argument_list|(
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|tree
name|niter
init|=
name|niter_for_single_dom_exit
argument_list|(
name|data
argument_list|)
decl_stmt|;
if|if
condition|(
name|niter
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"  number of iterations "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|niter
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n\n"
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Induction variables:\n\n"
argument_list|)
expr_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|data->relevant
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|bi
argument_list|)
block|{
if|if
condition|(
name|ver_info
argument_list|(
name|data
argument_list|,
name|i
argument_list|)
operator|->
name|iv
condition|)
name|dump_iv
argument_list|(
name|dump_file
argument_list|,
name|ver_info
argument_list|(
name|data
argument_list|,
name|i
argument_list|)
operator|->
name|iv
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Records a use of type USE_TYPE at *USE_P in STMT whose value is IV.  */
end_comment

begin_function
specifier|static
name|struct
name|iv_use
modifier|*
name|record_use
parameter_list|(
name|struct
name|ivopts_data
modifier|*
name|data
parameter_list|,
name|tree
modifier|*
name|use_p
parameter_list|,
name|struct
name|iv
modifier|*
name|iv
parameter_list|,
name|tree
name|stmt
parameter_list|,
name|enum
name|use_type
name|use_type
parameter_list|)
block|{
name|struct
name|iv_use
modifier|*
name|use
init|=
name|XCNEW
argument_list|(
expr|struct
name|iv_use
argument_list|)
decl_stmt|;
name|use
operator|->
name|id
operator|=
name|n_iv_uses
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|use
operator|->
name|type
operator|=
name|use_type
expr_stmt|;
name|use
operator|->
name|iv
operator|=
name|iv
expr_stmt|;
name|use
operator|->
name|stmt
operator|=
name|stmt
expr_stmt|;
name|use
operator|->
name|op_p
operator|=
name|use_p
expr_stmt|;
name|use
operator|->
name|related_cands
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
comment|/* To avoid showing ssa name in the dumps, if it was not reset by the      caller.  */
name|iv
operator|->
name|ssa_name
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|dump_use
argument_list|(
name|dump_file
argument_list|,
name|use
argument_list|)
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|iv_use_p
argument_list|,
name|heap
argument_list|,
name|data
operator|->
name|iv_uses
argument_list|,
name|use
argument_list|)
expr_stmt|;
return|return
name|use
return|;
block|}
end_function

begin_comment
comment|/* Checks whether OP is a loop-level invariant and if so, records it.    NONLINEAR_USE is true if the invariant is used in a way we do not    handle specially.  */
end_comment

begin_function
specifier|static
name|void
name|record_invariant
parameter_list|(
name|struct
name|ivopts_data
modifier|*
name|data
parameter_list|,
name|tree
name|op
parameter_list|,
name|bool
name|nonlinear_use
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|struct
name|version_info
modifier|*
name|info
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|SSA_NAME
operator|||
operator|!
name|is_gimple_reg
argument_list|(
name|op
argument_list|)
condition|)
return|return;
name|bb
operator|=
name|bb_for_stmt
argument_list|(
name|SSA_NAME_DEF_STMT
argument_list|(
name|op
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bb
operator|&&
name|flow_bb_inside_loop_p
argument_list|(
name|data
operator|->
name|current_loop
argument_list|,
name|bb
argument_list|)
condition|)
return|return;
name|info
operator|=
name|name_info
argument_list|(
name|data
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|info
operator|->
name|name
operator|=
name|op
expr_stmt|;
name|info
operator|->
name|has_nonlin_use
operator||=
name|nonlinear_use
expr_stmt|;
if|if
condition|(
operator|!
name|info
operator|->
name|inv_id
condition|)
name|info
operator|->
name|inv_id
operator|=
operator|++
name|data
operator|->
name|max_inv_id
expr_stmt|;
name|bitmap_set_bit
argument_list|(
name|data
operator|->
name|relevant
argument_list|,
name|SSA_NAME_VERSION
argument_list|(
name|op
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Checks whether the use OP is interesting and if so, records it.  */
end_comment

begin_function
specifier|static
name|struct
name|iv_use
modifier|*
name|find_interesting_uses_op
parameter_list|(
name|struct
name|ivopts_data
modifier|*
name|data
parameter_list|,
name|tree
name|op
parameter_list|)
block|{
name|struct
name|iv
modifier|*
name|iv
decl_stmt|;
name|struct
name|iv
modifier|*
name|civ
decl_stmt|;
name|tree
name|stmt
decl_stmt|;
name|struct
name|iv_use
modifier|*
name|use
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|SSA_NAME
condition|)
return|return
name|NULL
return|;
name|iv
operator|=
name|get_iv
argument_list|(
name|data
argument_list|,
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|iv
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|iv
operator|->
name|have_use_for
condition|)
block|{
name|use
operator|=
name|iv_use
argument_list|(
name|data
argument_list|,
name|iv
operator|->
name|use_id
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|use
operator|->
name|type
operator|==
name|USE_NONLINEAR_EXPR
argument_list|)
expr_stmt|;
return|return
name|use
return|;
block|}
if|if
condition|(
name|zero_p
argument_list|(
name|iv
operator|->
name|step
argument_list|)
condition|)
block|{
name|record_invariant
argument_list|(
name|data
argument_list|,
name|op
argument_list|,
name|true
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|iv
operator|->
name|have_use_for
operator|=
name|true
expr_stmt|;
name|civ
operator|=
name|XNEW
argument_list|(
expr|struct
name|iv
argument_list|)
expr_stmt|;
operator|*
name|civ
operator|=
operator|*
name|iv
expr_stmt|;
name|stmt
operator|=
name|SSA_NAME_DEF_STMT
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|PHI_NODE
operator|||
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|MODIFY_EXPR
argument_list|)
expr_stmt|;
name|use
operator|=
name|record_use
argument_list|(
name|data
argument_list|,
name|NULL
argument_list|,
name|civ
argument_list|,
name|stmt
argument_list|,
name|USE_NONLINEAR_EXPR
argument_list|)
expr_stmt|;
name|iv
operator|->
name|use_id
operator|=
name|use
operator|->
name|id
expr_stmt|;
return|return
name|use
return|;
block|}
end_function

begin_comment
comment|/* Checks whether the condition *COND_P in STMT is interesting    and if so, records it.  */
end_comment

begin_function
specifier|static
name|void
name|find_interesting_uses_cond
parameter_list|(
name|struct
name|ivopts_data
modifier|*
name|data
parameter_list|,
name|tree
name|stmt
parameter_list|,
name|tree
modifier|*
name|cond_p
parameter_list|)
block|{
name|tree
modifier|*
name|op0_p
decl_stmt|;
name|tree
modifier|*
name|op1_p
decl_stmt|;
name|struct
name|iv
modifier|*
name|iv0
init|=
name|NULL
decl_stmt|,
modifier|*
name|iv1
init|=
name|NULL
decl_stmt|,
modifier|*
name|civ
decl_stmt|;
name|struct
name|iv
name|const_iv
decl_stmt|;
name|tree
name|zero
init|=
name|integer_zero_node
decl_stmt|;
name|const_iv
operator|.
name|step
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|cond_p
argument_list|)
operator|!=
name|SSA_NAME
operator|&&
operator|!
name|COMPARISON_CLASS_P
argument_list|(
operator|*
name|cond_p
argument_list|)
condition|)
return|return;
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|cond_p
argument_list|)
operator|==
name|SSA_NAME
condition|)
block|{
name|op0_p
operator|=
name|cond_p
expr_stmt|;
name|op1_p
operator|=
operator|&
name|zero
expr_stmt|;
block|}
else|else
block|{
name|op0_p
operator|=
operator|&
name|TREE_OPERAND
argument_list|(
operator|*
name|cond_p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1_p
operator|=
operator|&
name|TREE_OPERAND
argument_list|(
operator|*
name|cond_p
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|op0_p
argument_list|)
operator|==
name|SSA_NAME
condition|)
name|iv0
operator|=
name|get_iv
argument_list|(
name|data
argument_list|,
operator|*
name|op0_p
argument_list|)
expr_stmt|;
else|else
name|iv0
operator|=
operator|&
name|const_iv
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|op1_p
argument_list|)
operator|==
name|SSA_NAME
condition|)
name|iv1
operator|=
name|get_iv
argument_list|(
name|data
argument_list|,
operator|*
name|op1_p
argument_list|)
expr_stmt|;
else|else
name|iv1
operator|=
operator|&
name|const_iv
expr_stmt|;
if|if
condition|(
comment|/* When comparing with non-invariant value, we may not do any senseful 	 induction variable elimination.  */
operator|(
operator|!
name|iv0
operator|||
operator|!
name|iv1
operator|)
comment|/* Eliminating condition based on two ivs would be nontrivial. 	 ??? TODO -- it is not really important to handle this case.  */
operator|||
operator|(
operator|!
name|zero_p
argument_list|(
name|iv0
operator|->
name|step
argument_list|)
operator|&&
operator|!
name|zero_p
argument_list|(
name|iv1
operator|->
name|step
argument_list|)
operator|)
condition|)
block|{
name|find_interesting_uses_op
argument_list|(
name|data
argument_list|,
operator|*
name|op0_p
argument_list|)
expr_stmt|;
name|find_interesting_uses_op
argument_list|(
name|data
argument_list|,
operator|*
name|op1_p
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|zero_p
argument_list|(
name|iv0
operator|->
name|step
argument_list|)
operator|&&
name|zero_p
argument_list|(
name|iv1
operator|->
name|step
argument_list|)
condition|)
block|{
comment|/* If both are invariants, this is a work for unswitching.  */
return|return;
block|}
name|civ
operator|=
name|XNEW
argument_list|(
expr|struct
name|iv
argument_list|)
expr_stmt|;
operator|*
name|civ
operator|=
name|zero_p
argument_list|(
name|iv0
operator|->
name|step
argument_list|)
condition|?
operator|*
name|iv1
else|:
operator|*
name|iv0
expr_stmt|;
name|record_use
argument_list|(
name|data
argument_list|,
name|cond_p
argument_list|,
name|civ
argument_list|,
name|stmt
argument_list|,
name|USE_COMPARE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns true if expression EXPR is obviously invariant in LOOP,    i.e. if all its operands are defined outside of the LOOP.  */
end_comment

begin_function
name|bool
name|expr_invariant_in_loop_p
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|tree
name|expr
parameter_list|)
block|{
name|basic_block
name|def_bb
decl_stmt|;
name|unsigned
name|i
decl_stmt|,
name|len
decl_stmt|;
if|if
condition|(
name|is_gimple_min_invariant
argument_list|(
name|expr
argument_list|)
condition|)
return|return
name|true
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|SSA_NAME
condition|)
block|{
name|def_bb
operator|=
name|bb_for_stmt
argument_list|(
name|SSA_NAME_DEF_STMT
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|def_bb
operator|&&
name|flow_bb_inside_loop_p
argument_list|(
name|loop
argument_list|,
name|def_bb
argument_list|)
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
if|if
condition|(
operator|!
name|EXPR_P
argument_list|(
name|expr
argument_list|)
condition|)
return|return
name|false
return|;
name|len
operator|=
name|TREE_CODE_LENGTH
argument_list|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|expr_invariant_in_loop_p
argument_list|(
name|loop
argument_list|,
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Cumulates the steps of indices into DATA and replaces their values with the    initial ones.  Returns false when the value of the index cannot be determined.    Callback for for_each_index.  */
end_comment

begin_struct
struct|struct
name|ifs_ivopts_data
block|{
name|struct
name|ivopts_data
modifier|*
name|ivopts_data
decl_stmt|;
name|tree
name|stmt
decl_stmt|;
name|tree
modifier|*
name|step_p
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|bool
name|idx_find_step
parameter_list|(
name|tree
name|base
parameter_list|,
name|tree
modifier|*
name|idx
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|ifs_ivopts_data
modifier|*
name|dta
init|=
name|data
decl_stmt|;
name|struct
name|iv
modifier|*
name|iv
decl_stmt|;
name|tree
name|step
decl_stmt|,
name|iv_base
decl_stmt|,
name|iv_step
decl_stmt|,
name|lbound
decl_stmt|,
name|off
decl_stmt|;
name|struct
name|loop
modifier|*
name|loop
init|=
name|dta
operator|->
name|ivopts_data
operator|->
name|current_loop
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|MISALIGNED_INDIRECT_REF
operator|||
name|TREE_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|ALIGN_INDIRECT_REF
condition|)
return|return
name|false
return|;
comment|/* If base is a component ref, require that the offset of the reference      be invariant.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
block|{
name|off
operator|=
name|component_ref_field_offset
argument_list|(
name|base
argument_list|)
expr_stmt|;
return|return
name|expr_invariant_in_loop_p
argument_list|(
name|loop
argument_list|,
name|off
argument_list|)
return|;
block|}
comment|/* If base is array, first check whether we will be able to move the      reference out of the loop (in order to take its address in strength      reduction).  In order for this to work we need both lower bound      and step to be loop invariants.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|ARRAY_REF
condition|)
block|{
name|step
operator|=
name|array_ref_element_size
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|lbound
operator|=
name|array_ref_low_bound
argument_list|(
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|expr_invariant_in_loop_p
argument_list|(
name|loop
argument_list|,
name|step
argument_list|)
operator|||
operator|!
name|expr_invariant_in_loop_p
argument_list|(
name|loop
argument_list|,
name|lbound
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|idx
argument_list|)
operator|!=
name|SSA_NAME
condition|)
return|return
name|true
return|;
name|iv
operator|=
name|get_iv
argument_list|(
name|dta
operator|->
name|ivopts_data
argument_list|,
operator|*
name|idx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|iv
condition|)
return|return
name|false
return|;
comment|/* XXX  We produce for a base of *D42 with iv->base being&x[0] 	  *&x[0], which is not folded and does not trigger the 	  ARRAY_REF path below.  */
operator|*
name|idx
operator|=
name|iv
operator|->
name|base
expr_stmt|;
if|if
condition|(
operator|!
name|iv
operator|->
name|step
condition|)
return|return
name|true
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|ARRAY_REF
condition|)
block|{
name|step
operator|=
name|array_ref_element_size
argument_list|(
name|base
argument_list|)
expr_stmt|;
comment|/* We only handle addresses whose step is an integer constant.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|step
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
return|return
name|false
return|;
block|}
else|else
comment|/* The step for pointer arithmetics already is 1 byte.  */
name|step
operator|=
name|build_int_cst
argument_list|(
name|sizetype
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|iv_base
operator|=
name|iv
operator|->
name|base
expr_stmt|;
name|iv_step
operator|=
name|iv
operator|->
name|step
expr_stmt|;
if|if
condition|(
operator|!
name|convert_affine_scev
argument_list|(
name|dta
operator|->
name|ivopts_data
operator|->
name|current_loop
argument_list|,
name|sizetype
argument_list|,
operator|&
name|iv_base
argument_list|,
operator|&
name|iv_step
argument_list|,
name|dta
operator|->
name|stmt
argument_list|,
name|false
argument_list|)
condition|)
block|{
comment|/* The index might wrap.  */
return|return
name|false
return|;
block|}
name|step
operator|=
name|fold_build2
argument_list|(
name|MULT_EXPR
argument_list|,
name|sizetype
argument_list|,
name|step
argument_list|,
name|iv_step
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|dta
operator|->
name|step_p
condition|)
operator|*
name|dta
operator|->
name|step_p
operator|=
name|step
expr_stmt|;
else|else
operator|*
name|dta
operator|->
name|step_p
operator|=
name|fold_build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|sizetype
argument_list|,
operator|*
name|dta
operator|->
name|step_p
argument_list|,
name|step
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Records use in index IDX.  Callback for for_each_index.  Ivopts data    object is passed to it in DATA.  */
end_comment

begin_function
specifier|static
name|bool
name|idx_record_use
parameter_list|(
name|tree
name|base
parameter_list|,
name|tree
modifier|*
name|idx
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|find_interesting_uses_op
argument_list|(
name|data
argument_list|,
operator|*
name|idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|ARRAY_REF
condition|)
block|{
name|find_interesting_uses_op
argument_list|(
name|data
argument_list|,
name|array_ref_element_size
argument_list|(
name|base
argument_list|)
argument_list|)
expr_stmt|;
name|find_interesting_uses_op
argument_list|(
name|data
argument_list|,
name|array_ref_low_bound
argument_list|(
name|base
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Returns true if memory reference REF may be unaligned.  */
end_comment

begin_function
specifier|static
name|bool
name|may_be_unaligned_p
parameter_list|(
name|tree
name|ref
parameter_list|)
block|{
name|tree
name|base
decl_stmt|;
name|tree
name|base_type
decl_stmt|;
name|HOST_WIDE_INT
name|bitsize
decl_stmt|;
name|HOST_WIDE_INT
name|bitpos
decl_stmt|;
name|tree
name|toffset
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|unsignedp
decl_stmt|,
name|volatilep
decl_stmt|;
name|unsigned
name|base_align
decl_stmt|;
comment|/* TARGET_MEM_REFs are translated directly to valid MEMs on the target,      thus they are not misaligned.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ref
argument_list|)
operator|==
name|TARGET_MEM_REF
condition|)
return|return
name|false
return|;
comment|/* The test below is basically copy of what expr.c:normal_inner_ref      does to check whether the object must be loaded by parts when      STRICT_ALIGNMENT is true.  */
name|base
operator|=
name|get_inner_reference
argument_list|(
name|ref
argument_list|,
operator|&
name|bitsize
argument_list|,
operator|&
name|bitpos
argument_list|,
operator|&
name|toffset
argument_list|,
operator|&
name|mode
argument_list|,
operator|&
name|unsignedp
argument_list|,
operator|&
name|volatilep
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|base_type
operator|=
name|TREE_TYPE
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|base_align
operator|=
name|TYPE_ALIGN
argument_list|(
name|base_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|!=
name|BLKmode
operator|&&
operator|(
name|base_align
operator|<
name|GET_MODE_ALIGNMENT
argument_list|(
name|mode
argument_list|)
operator|||
name|bitpos
operator|%
name|GET_MODE_ALIGNMENT
argument_list|(
name|mode
argument_list|)
operator|!=
literal|0
operator|||
name|bitpos
operator|%
name|BITS_PER_UNIT
operator|!=
literal|0
operator|)
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Return true if EXPR may be non-addressable.   */
end_comment

begin_function
specifier|static
name|bool
name|may_be_nonaddressable_p
parameter_list|(
name|tree
name|expr
parameter_list|)
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
condition|)
block|{
case|case
name|COMPONENT_REF
case|:
return|return
name|DECL_NONADDRESSABLE_P
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|||
name|may_be_nonaddressable_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|ARRAY_REF
case|:
case|case
name|ARRAY_RANGE_REF
case|:
return|return
name|may_be_nonaddressable_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|VIEW_CONVERT_EXPR
case|:
comment|/* This kind of view-conversions may wrap non-addressable objects 	 and make them look addressable.  After some processing the 	 non-addressability may be uncovered again, causing ADDR_EXPRs 	 of inappropriate objects to be built.  */
return|return
name|AGGREGATE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|&&
operator|!
name|AGGREGATE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
default|default:
break|break;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Finds addresses in *OP_P inside STMT.  */
end_comment

begin_function
specifier|static
name|void
name|find_interesting_uses_address
parameter_list|(
name|struct
name|ivopts_data
modifier|*
name|data
parameter_list|,
name|tree
name|stmt
parameter_list|,
name|tree
modifier|*
name|op_p
parameter_list|)
block|{
name|tree
name|base
init|=
operator|*
name|op_p
decl_stmt|,
name|step
init|=
name|NULL
decl_stmt|;
name|struct
name|iv
modifier|*
name|civ
decl_stmt|;
name|struct
name|ifs_ivopts_data
name|ifs_ivopts_data
decl_stmt|;
comment|/* Do not play with volatile memory references.  A bit too conservative,      perhaps, but safe.  */
if|if
condition|(
name|stmt_ann
argument_list|(
name|stmt
argument_list|)
operator|->
name|has_volatile_ops
condition|)
goto|goto
name|fail
goto|;
comment|/* Ignore bitfields for now.  Not really something terribly complicated      to handle.  TODO.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|BIT_FIELD_REF
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
name|may_be_nonaddressable_p
argument_list|(
name|base
argument_list|)
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
name|STRICT_ALIGNMENT
operator|&&
name|may_be_unaligned_p
argument_list|(
name|base
argument_list|)
condition|)
goto|goto
name|fail
goto|;
name|base
operator|=
name|unshare_expr
argument_list|(
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|TARGET_MEM_REF
condition|)
block|{
name|tree
name|type
init|=
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|base
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|astep
decl_stmt|;
if|if
condition|(
name|TMR_BASE
argument_list|(
name|base
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TMR_BASE
argument_list|(
name|base
argument_list|)
argument_list|)
operator|==
name|SSA_NAME
condition|)
block|{
name|civ
operator|=
name|get_iv
argument_list|(
name|data
argument_list|,
name|TMR_BASE
argument_list|(
name|base
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|civ
condition|)
goto|goto
name|fail
goto|;
name|TMR_BASE
argument_list|(
name|base
argument_list|)
operator|=
name|civ
operator|->
name|base
expr_stmt|;
name|step
operator|=
name|civ
operator|->
name|step
expr_stmt|;
block|}
if|if
condition|(
name|TMR_INDEX
argument_list|(
name|base
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TMR_INDEX
argument_list|(
name|base
argument_list|)
argument_list|)
operator|==
name|SSA_NAME
condition|)
block|{
name|civ
operator|=
name|get_iv
argument_list|(
name|data
argument_list|,
name|TMR_INDEX
argument_list|(
name|base
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|civ
condition|)
goto|goto
name|fail
goto|;
name|TMR_INDEX
argument_list|(
name|base
argument_list|)
operator|=
name|civ
operator|->
name|base
expr_stmt|;
name|astep
operator|=
name|civ
operator|->
name|step
expr_stmt|;
if|if
condition|(
name|astep
condition|)
block|{
if|if
condition|(
name|TMR_STEP
argument_list|(
name|base
argument_list|)
condition|)
name|astep
operator|=
name|fold_build2
argument_list|(
name|MULT_EXPR
argument_list|,
name|type
argument_list|,
name|TMR_STEP
argument_list|(
name|base
argument_list|)
argument_list|,
name|astep
argument_list|)
expr_stmt|;
if|if
condition|(
name|step
condition|)
name|step
operator|=
name|fold_build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|type
argument_list|,
name|step
argument_list|,
name|astep
argument_list|)
expr_stmt|;
else|else
name|step
operator|=
name|astep
expr_stmt|;
block|}
block|}
if|if
condition|(
name|zero_p
argument_list|(
name|step
argument_list|)
condition|)
goto|goto
name|fail
goto|;
name|base
operator|=
name|tree_mem_ref_addr
argument_list|(
name|type
argument_list|,
name|base
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ifs_ivopts_data
operator|.
name|ivopts_data
operator|=
name|data
expr_stmt|;
name|ifs_ivopts_data
operator|.
name|stmt
operator|=
name|stmt
expr_stmt|;
name|ifs_ivopts_data
operator|.
name|step_p
operator|=
operator|&
name|step
expr_stmt|;
if|if
condition|(
operator|!
name|for_each_index
argument_list|(
operator|&
name|base
argument_list|,
name|idx_find_step
argument_list|,
operator|&
name|ifs_ivopts_data
argument_list|)
operator|||
name|zero_p
argument_list|(
name|step
argument_list|)
condition|)
goto|goto
name|fail
goto|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|base
argument_list|)
operator|!=
name|ALIGN_INDIRECT_REF
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|base
argument_list|)
operator|!=
name|MISALIGNED_INDIRECT_REF
argument_list|)
expr_stmt|;
name|base
operator|=
name|build_fold_addr_expr
argument_list|(
name|base
argument_list|)
expr_stmt|;
comment|/* Substituting bases of IVs into the base expression might 	 have caused folding opportunities.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
block|{
name|tree
modifier|*
name|ref
init|=
operator|&
name|TREE_OPERAND
argument_list|(
name|base
argument_list|,
literal|0
argument_list|)
decl_stmt|;
while|while
condition|(
name|handled_component_p
argument_list|(
operator|*
name|ref
argument_list|)
condition|)
name|ref
operator|=
operator|&
name|TREE_OPERAND
argument_list|(
operator|*
name|ref
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|ref
argument_list|)
operator|==
name|INDIRECT_REF
condition|)
operator|*
name|ref
operator|=
name|fold_indirect_ref
argument_list|(
operator|*
name|ref
argument_list|)
expr_stmt|;
block|}
block|}
name|civ
operator|=
name|alloc_iv
argument_list|(
name|base
argument_list|,
name|step
argument_list|)
expr_stmt|;
name|record_use
argument_list|(
name|data
argument_list|,
name|op_p
argument_list|,
name|civ
argument_list|,
name|stmt
argument_list|,
name|USE_ADDRESS
argument_list|)
expr_stmt|;
return|return;
name|fail
label|:
name|for_each_index
argument_list|(
name|op_p
argument_list|,
name|idx_record_use
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finds and records invariants used in STMT.  */
end_comment

begin_function
specifier|static
name|void
name|find_invariants_stmt
parameter_list|(
name|struct
name|ivopts_data
modifier|*
name|data
parameter_list|,
name|tree
name|stmt
parameter_list|)
block|{
name|ssa_op_iter
name|iter
decl_stmt|;
name|use_operand_p
name|use_p
decl_stmt|;
name|tree
name|op
decl_stmt|;
name|FOR_EACH_PHI_OR_STMT_USE
argument_list|(
argument|use_p
argument_list|,
argument|stmt
argument_list|,
argument|iter
argument_list|,
argument|SSA_OP_USE
argument_list|)
block|{
name|op
operator|=
name|USE_FROM_PTR
argument_list|(
name|use_p
argument_list|)
expr_stmt|;
name|record_invariant
argument_list|(
name|data
argument_list|,
name|op
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Finds interesting uses of induction variables in the statement STMT.  */
end_comment

begin_function
specifier|static
name|void
name|find_interesting_uses_stmt
parameter_list|(
name|struct
name|ivopts_data
modifier|*
name|data
parameter_list|,
name|tree
name|stmt
parameter_list|)
block|{
name|struct
name|iv
modifier|*
name|iv
decl_stmt|;
name|tree
name|op
decl_stmt|,
name|lhs
decl_stmt|,
name|rhs
decl_stmt|;
name|ssa_op_iter
name|iter
decl_stmt|;
name|use_operand_p
name|use_p
decl_stmt|;
name|find_invariants_stmt
argument_list|(
name|data
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|COND_EXPR
condition|)
block|{
name|find_interesting_uses_cond
argument_list|(
name|data
argument_list|,
name|stmt
argument_list|,
operator|&
name|COND_EXPR_COND
argument_list|(
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|MODIFY_EXPR
condition|)
block|{
name|lhs
operator|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rhs
operator|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|lhs
argument_list|)
operator|==
name|SSA_NAME
condition|)
block|{
comment|/* If the statement defines an induction variable, the uses are not 	     interesting by themselves.  */
name|iv
operator|=
name|get_iv
argument_list|(
name|data
argument_list|,
name|lhs
argument_list|)
expr_stmt|;
if|if
condition|(
name|iv
operator|&&
operator|!
name|zero_p
argument_list|(
name|iv
operator|->
name|step
argument_list|)
condition|)
return|return;
block|}
switch|switch
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|tcc_comparison
case|:
name|find_interesting_uses_cond
argument_list|(
name|data
argument_list|,
name|stmt
argument_list|,
operator|&
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|tcc_reference
case|:
name|find_interesting_uses_address
argument_list|(
name|data
argument_list|,
name|stmt
argument_list|,
operator|&
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|REFERENCE_CLASS_P
argument_list|(
name|lhs
argument_list|)
condition|)
name|find_interesting_uses_address
argument_list|(
name|data
argument_list|,
name|stmt
argument_list|,
operator|&
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return;
default|default:
empty_stmt|;
block|}
if|if
condition|(
name|REFERENCE_CLASS_P
argument_list|(
name|lhs
argument_list|)
operator|&&
name|is_gimple_val
argument_list|(
name|rhs
argument_list|)
condition|)
block|{
name|find_interesting_uses_address
argument_list|(
name|data
argument_list|,
name|stmt
argument_list|,
operator|&
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|find_interesting_uses_op
argument_list|(
name|data
argument_list|,
name|rhs
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* TODO -- we should also handle address uses of type  	 memory = call (whatever);  	 and  	 call (memory).  */
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|PHI_NODE
operator|&&
name|bb_for_stmt
argument_list|(
name|stmt
argument_list|)
operator|==
name|data
operator|->
name|current_loop
operator|->
name|header
condition|)
block|{
name|lhs
operator|=
name|PHI_RESULT
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|iv
operator|=
name|get_iv
argument_list|(
name|data
argument_list|,
name|lhs
argument_list|)
expr_stmt|;
if|if
condition|(
name|iv
operator|&&
operator|!
name|zero_p
argument_list|(
name|iv
operator|->
name|step
argument_list|)
condition|)
return|return;
block|}
name|FOR_EACH_PHI_OR_STMT_USE
argument_list|(
argument|use_p
argument_list|,
argument|stmt
argument_list|,
argument|iter
argument_list|,
argument|SSA_OP_USE
argument_list|)
block|{
name|op
operator|=
name|USE_FROM_PTR
argument_list|(
name|use_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|SSA_NAME
condition|)
continue|continue;
name|iv
operator|=
name|get_iv
argument_list|(
name|data
argument_list|,
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|iv
condition|)
continue|continue;
name|find_interesting_uses_op
argument_list|(
name|data
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Finds interesting uses of induction variables outside of loops    on loop exit edge EXIT.  */
end_comment

begin_function
specifier|static
name|void
name|find_interesting_uses_outside
parameter_list|(
name|struct
name|ivopts_data
modifier|*
name|data
parameter_list|,
name|edge
name|exit
parameter_list|)
block|{
name|tree
name|phi
decl_stmt|,
name|def
decl_stmt|;
for|for
control|(
name|phi
operator|=
name|phi_nodes
argument_list|(
name|exit
operator|->
name|dest
argument_list|)
init|;
name|phi
condition|;
name|phi
operator|=
name|PHI_CHAIN
argument_list|(
name|phi
argument_list|)
control|)
block|{
name|def
operator|=
name|PHI_ARG_DEF_FROM_EDGE
argument_list|(
name|phi
argument_list|,
name|exit
argument_list|)
expr_stmt|;
name|find_interesting_uses_op
argument_list|(
name|data
argument_list|,
name|def
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Finds uses of the induction variables that are interesting.  */
end_comment

begin_function
specifier|static
name|void
name|find_interesting_uses
parameter_list|(
name|struct
name|ivopts_data
modifier|*
name|data
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|block_stmt_iterator
name|bsi
decl_stmt|;
name|tree
name|phi
decl_stmt|;
name|basic_block
modifier|*
name|body
init|=
name|get_loop_body
argument_list|(
name|data
operator|->
name|current_loop
argument_list|)
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|struct
name|version_info
modifier|*
name|info
decl_stmt|;
name|edge
name|e
decl_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Uses:\n\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|data
operator|->
name|current_loop
operator|->
name|num_nodes
condition|;
name|i
operator|++
control|)
block|{
name|edge_iterator
name|ei
decl_stmt|;
name|bb
operator|=
name|body
index|[
name|i
index|]
expr_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
if|if
condition|(
name|e
operator|->
name|dest
operator|!=
name|EXIT_BLOCK_PTR
operator|&&
operator|!
name|flow_bb_inside_loop_p
argument_list|(
name|data
operator|->
name|current_loop
argument_list|,
name|e
operator|->
name|dest
argument_list|)
condition|)
name|find_interesting_uses_outside
argument_list|(
name|data
argument_list|,
name|e
argument_list|)
expr_stmt|;
for|for
control|(
name|phi
operator|=
name|phi_nodes
argument_list|(
name|bb
argument_list|)
init|;
name|phi
condition|;
name|phi
operator|=
name|PHI_CHAIN
argument_list|(
name|phi
argument_list|)
control|)
name|find_interesting_uses_stmt
argument_list|(
name|data
argument_list|,
name|phi
argument_list|)
expr_stmt|;
for|for
control|(
name|bsi
operator|=
name|bsi_start
argument_list|(
name|bb
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|;
name|bsi_next
argument_list|(
operator|&
name|bsi
argument_list|)
control|)
name|find_interesting_uses_stmt
argument_list|(
name|data
argument_list|,
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|bitmap_iterator
name|bi
decl_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|data->relevant
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|bi
argument_list|)
block|{
name|info
operator|=
name|ver_info
argument_list|(
name|data
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|inv_id
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"  "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|info
operator|->
name|name
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|" is invariant (%d)%s\n"
argument_list|,
name|info
operator|->
name|inv_id
argument_list|,
name|info
operator|->
name|has_nonlin_use
condition|?
literal|""
else|:
literal|", eliminable"
argument_list|)
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|body
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Strips constant offsets from EXPR and stores them to OFFSET.  If INSIDE_ADDR    is true, assume we are inside an address.  If TOP_COMPREF is true, assume    we are at the top-level of the processed address.  */
end_comment

begin_function
specifier|static
name|tree
name|strip_offset_1
parameter_list|(
name|tree
name|expr
parameter_list|,
name|bool
name|inside_addr
parameter_list|,
name|bool
name|top_compref
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
modifier|*
name|offset
parameter_list|)
block|{
name|tree
name|op0
init|=
name|NULL_TREE
decl_stmt|,
name|op1
init|=
name|NULL_TREE
decl_stmt|,
name|tmp
decl_stmt|,
name|step
decl_stmt|;
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|type
decl_stmt|,
name|orig_type
init|=
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|off0
decl_stmt|,
name|off1
decl_stmt|,
name|st
decl_stmt|;
name|tree
name|orig_expr
init|=
name|expr
decl_stmt|;
name|STRIP_NOPS
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|code
operator|=
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
expr_stmt|;
operator|*
name|offset
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|INTEGER_CST
case|:
if|if
condition|(
operator|!
name|cst_and_fits_in_hwi
argument_list|(
name|expr
argument_list|)
operator|||
name|zero_p
argument_list|(
name|expr
argument_list|)
condition|)
return|return
name|orig_expr
return|;
operator|*
name|offset
operator|=
name|int_cst_value
argument_list|(
name|expr
argument_list|)
expr_stmt|;
return|return
name|build_int_cst
argument_list|(
name|orig_type
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|PLUS_EXPR
case|:
case|case
name|MINUS_EXPR
case|:
name|op0
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|op0
operator|=
name|strip_offset_1
argument_list|(
name|op0
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
operator|&
name|off0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|strip_offset_1
argument_list|(
name|op1
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
operator|&
name|off1
argument_list|)
expr_stmt|;
operator|*
name|offset
operator|=
operator|(
name|code
operator|==
name|PLUS_EXPR
condition|?
name|off0
operator|+
name|off1
else|:
name|off0
operator|-
name|off1
operator|)
expr_stmt|;
if|if
condition|(
name|op0
operator|==
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
operator|&&
name|op1
operator|==
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|orig_expr
return|;
if|if
condition|(
name|zero_p
argument_list|(
name|op1
argument_list|)
condition|)
name|expr
operator|=
name|op0
expr_stmt|;
elseif|else
if|if
condition|(
name|zero_p
argument_list|(
name|op0
argument_list|)
condition|)
block|{
if|if
condition|(
name|code
operator|==
name|PLUS_EXPR
condition|)
name|expr
operator|=
name|op1
expr_stmt|;
else|else
name|expr
operator|=
name|fold_build1
argument_list|(
name|NEGATE_EXPR
argument_list|,
name|type
argument_list|,
name|op1
argument_list|)
expr_stmt|;
block|}
else|else
name|expr
operator|=
name|fold_build2
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
return|return
name|fold_convert
argument_list|(
name|orig_type
argument_list|,
name|expr
argument_list|)
return|;
case|case
name|ARRAY_REF
case|:
if|if
condition|(
operator|!
name|inside_addr
condition|)
return|return
name|orig_expr
return|;
name|step
operator|=
name|array_ref_element_size
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cst_and_fits_in_hwi
argument_list|(
name|step
argument_list|)
condition|)
break|break;
name|st
operator|=
name|int_cst_value
argument_list|(
name|step
argument_list|)
expr_stmt|;
name|op1
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|op1
operator|=
name|strip_offset_1
argument_list|(
name|op1
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
operator|&
name|off1
argument_list|)
expr_stmt|;
operator|*
name|offset
operator|=
name|off1
operator|*
name|st
expr_stmt|;
if|if
condition|(
name|top_compref
operator|&&
name|zero_p
argument_list|(
name|op1
argument_list|)
condition|)
block|{
comment|/* Strip the component reference completely.  */
name|op0
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op0
operator|=
name|strip_offset_1
argument_list|(
name|op0
argument_list|,
name|inside_addr
argument_list|,
name|top_compref
argument_list|,
operator|&
name|off0
argument_list|)
expr_stmt|;
operator|*
name|offset
operator|+=
name|off0
expr_stmt|;
return|return
name|op0
return|;
block|}
break|break;
case|case
name|COMPONENT_REF
case|:
if|if
condition|(
operator|!
name|inside_addr
condition|)
return|return
name|orig_expr
return|;
name|tmp
operator|=
name|component_ref_field_offset
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|top_compref
operator|&&
name|cst_and_fits_in_hwi
argument_list|(
name|tmp
argument_list|)
condition|)
block|{
comment|/* Strip the component reference completely.  */
name|op0
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op0
operator|=
name|strip_offset_1
argument_list|(
name|op0
argument_list|,
name|inside_addr
argument_list|,
name|top_compref
argument_list|,
operator|&
name|off0
argument_list|)
expr_stmt|;
operator|*
name|offset
operator|=
name|off0
operator|+
name|int_cst_value
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
return|return
name|op0
return|;
block|}
break|break;
case|case
name|ADDR_EXPR
case|:
name|op0
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op0
operator|=
name|strip_offset_1
argument_list|(
name|op0
argument_list|,
name|true
argument_list|,
name|true
argument_list|,
operator|&
name|off0
argument_list|)
expr_stmt|;
operator|*
name|offset
operator|+=
name|off0
expr_stmt|;
if|if
condition|(
name|op0
operator|==
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|orig_expr
return|;
name|expr
operator|=
name|build_fold_addr_expr
argument_list|(
name|op0
argument_list|)
expr_stmt|;
return|return
name|fold_convert
argument_list|(
name|orig_type
argument_list|,
name|expr
argument_list|)
return|;
case|case
name|INDIRECT_REF
case|:
name|inside_addr
operator|=
name|false
expr_stmt|;
break|break;
default|default:
return|return
name|orig_expr
return|;
block|}
comment|/* Default handling of expressions for that we want to recurse into      the first operand.  */
name|op0
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op0
operator|=
name|strip_offset_1
argument_list|(
name|op0
argument_list|,
name|inside_addr
argument_list|,
name|false
argument_list|,
operator|&
name|off0
argument_list|)
expr_stmt|;
operator|*
name|offset
operator|+=
name|off0
expr_stmt|;
if|if
condition|(
name|op0
operator|==
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
operator|&&
operator|(
operator|!
name|op1
operator|||
name|op1
operator|==
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
return|return
name|orig_expr
return|;
name|expr
operator|=
name|copy_node
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
operator|=
name|op0
expr_stmt|;
if|if
condition|(
name|op1
condition|)
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
operator|=
name|op1
expr_stmt|;
comment|/* Inside address, we might strip the top level component references,      thus changing type of the expression.  Handling of ADDR_EXPR      will fix that.  */
name|expr
operator|=
name|fold_convert
argument_list|(
name|orig_type
argument_list|,
name|expr
argument_list|)
expr_stmt|;
return|return
name|expr
return|;
block|}
end_function

begin_comment
comment|/* Strips constant offsets from EXPR and stores them to OFFSET.  */
end_comment

begin_function
specifier|static
name|tree
name|strip_offset
parameter_list|(
name|tree
name|expr
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
modifier|*
name|offset
parameter_list|)
block|{
return|return
name|strip_offset_1
argument_list|(
name|expr
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|offset
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns variant of TYPE that can be used as base for different uses.    We return unsigned type with the same precision, which avoids problems    with overflows.  */
end_comment

begin_function
specifier|static
name|tree
name|generic_type_for
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
if|if
condition|(
name|POINTER_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|unsigned_type_for
argument_list|(
name|type
argument_list|)
return|;
if|if
condition|(
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|type
return|;
return|return
name|unsigned_type_for
argument_list|(
name|type
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Records invariants in *EXPR_P.  Callback for walk_tree.  DATA contains    the bitmap to that we should store it.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|ivopts_data
modifier|*
name|fd_ivopts_data
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|tree
name|find_depends
parameter_list|(
name|tree
modifier|*
name|expr_p
parameter_list|,
name|int
modifier|*
name|ws
name|ATTRIBUTE_UNUSED
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|bitmap
modifier|*
name|depends_on
init|=
name|data
decl_stmt|;
name|struct
name|version_info
modifier|*
name|info
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|expr_p
argument_list|)
operator|!=
name|SSA_NAME
condition|)
return|return
name|NULL_TREE
return|;
name|info
operator|=
name|name_info
argument_list|(
name|fd_ivopts_data
argument_list|,
operator|*
name|expr_p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|info
operator|->
name|inv_id
operator|||
name|info
operator|->
name|has_nonlin_use
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
operator|!
operator|*
name|depends_on
condition|)
operator|*
name|depends_on
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|bitmap_set_bit
argument_list|(
operator|*
name|depends_on
argument_list|,
name|info
operator|->
name|inv_id
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Adds a candidate BASE + STEP * i.  Important field is set to IMPORTANT and    position to POS.  If USE is not NULL, the candidate is set as related to    it.  If both BASE and STEP are NULL, we add a pseudocandidate for the    replacement of the final value of the iv by a direct computation.  */
end_comment

begin_function
specifier|static
name|struct
name|iv_cand
modifier|*
name|add_candidate_1
parameter_list|(
name|struct
name|ivopts_data
modifier|*
name|data
parameter_list|,
name|tree
name|base
parameter_list|,
name|tree
name|step
parameter_list|,
name|bool
name|important
parameter_list|,
name|enum
name|iv_position
name|pos
parameter_list|,
name|struct
name|iv_use
modifier|*
name|use
parameter_list|,
name|tree
name|incremented_at
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
name|struct
name|iv_cand
modifier|*
name|cand
init|=
name|NULL
decl_stmt|;
name|tree
name|type
decl_stmt|,
name|orig_type
decl_stmt|;
if|if
condition|(
name|base
condition|)
block|{
name|orig_type
operator|=
name|TREE_TYPE
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|type
operator|=
name|generic_type_for
argument_list|(
name|orig_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|orig_type
condition|)
block|{
name|base
operator|=
name|fold_convert
argument_list|(
name|type
argument_list|,
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|step
condition|)
name|step
operator|=
name|fold_convert
argument_list|(
name|type
argument_list|,
name|step
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_iv_cands
argument_list|(
name|data
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|cand
operator|=
name|iv_cand
argument_list|(
name|data
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|cand
operator|->
name|pos
operator|!=
name|pos
condition|)
continue|continue;
if|if
condition|(
name|cand
operator|->
name|incremented_at
operator|!=
name|incremented_at
condition|)
continue|continue;
if|if
condition|(
operator|!
name|cand
operator|->
name|iv
condition|)
block|{
if|if
condition|(
operator|!
name|base
operator|&&
operator|!
name|step
condition|)
break|break;
continue|continue;
block|}
if|if
condition|(
operator|!
name|base
operator|&&
operator|!
name|step
condition|)
continue|continue;
if|if
condition|(
operator|!
name|operand_equal_p
argument_list|(
name|base
argument_list|,
name|cand
operator|->
name|iv
operator|->
name|base
argument_list|,
literal|0
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|zero_p
argument_list|(
name|cand
operator|->
name|iv
operator|->
name|step
argument_list|)
condition|)
block|{
if|if
condition|(
name|zero_p
argument_list|(
name|step
argument_list|)
condition|)
break|break;
block|}
else|else
block|{
if|if
condition|(
name|step
operator|&&
name|operand_equal_p
argument_list|(
name|step
argument_list|,
name|cand
operator|->
name|iv
operator|->
name|step
argument_list|,
literal|0
argument_list|)
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
name|n_iv_cands
argument_list|(
name|data
argument_list|)
condition|)
block|{
name|cand
operator|=
name|XCNEW
argument_list|(
expr|struct
name|iv_cand
argument_list|)
expr_stmt|;
name|cand
operator|->
name|id
operator|=
name|i
expr_stmt|;
if|if
condition|(
operator|!
name|base
operator|&&
operator|!
name|step
condition|)
name|cand
operator|->
name|iv
operator|=
name|NULL
expr_stmt|;
else|else
name|cand
operator|->
name|iv
operator|=
name|alloc_iv
argument_list|(
name|base
argument_list|,
name|step
argument_list|)
expr_stmt|;
name|cand
operator|->
name|pos
operator|=
name|pos
expr_stmt|;
if|if
condition|(
name|pos
operator|!=
name|IP_ORIGINAL
operator|&&
name|cand
operator|->
name|iv
condition|)
block|{
name|cand
operator|->
name|var_before
operator|=
name|create_tmp_var_raw
argument_list|(
name|TREE_TYPE
argument_list|(
name|base
argument_list|)
argument_list|,
literal|"ivtmp"
argument_list|)
expr_stmt|;
name|cand
operator|->
name|var_after
operator|=
name|cand
operator|->
name|var_before
expr_stmt|;
block|}
name|cand
operator|->
name|important
operator|=
name|important
expr_stmt|;
name|cand
operator|->
name|incremented_at
operator|=
name|incremented_at
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|iv_cand_p
argument_list|,
name|heap
argument_list|,
name|data
operator|->
name|iv_candidates
argument_list|,
name|cand
argument_list|)
expr_stmt|;
if|if
condition|(
name|step
operator|&&
name|TREE_CODE
argument_list|(
name|step
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
block|{
name|fd_ivopts_data
operator|=
name|data
expr_stmt|;
name|walk_tree
argument_list|(
operator|&
name|step
argument_list|,
name|find_depends
argument_list|,
operator|&
name|cand
operator|->
name|depends_on
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|dump_cand
argument_list|(
name|dump_file
argument_list|,
name|cand
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|important
operator|&&
operator|!
name|cand
operator|->
name|important
condition|)
block|{
name|cand
operator|->
name|important
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Candidate %d is important\n"
argument_list|,
name|cand
operator|->
name|id
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|use
condition|)
block|{
name|bitmap_set_bit
argument_list|(
name|use
operator|->
name|related_cands
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Candidate %d is related to use %d\n"
argument_list|,
name|cand
operator|->
name|id
argument_list|,
name|use
operator|->
name|id
argument_list|)
expr_stmt|;
block|}
return|return
name|cand
return|;
block|}
end_function

begin_comment
comment|/* Returns true if incrementing the induction variable at the end of the LOOP    is allowed.     The purpose is to avoid splitting latch edge with a biv increment, thus    creating a jump, possibly confusing other optimization passes and leaving    less freedom to scheduler.  So we allow IP_END_POS only if IP_NORMAL_POS    is not available (so we do not have a better alternative), or if the latch    edge is already nonempty.  */
end_comment

begin_function
specifier|static
name|bool
name|allow_ip_end_pos_p
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ip_normal_pos
argument_list|(
name|loop
argument_list|)
condition|)
return|return
name|true
return|;
if|if
condition|(
operator|!
name|empty_block_p
argument_list|(
name|ip_end_pos
argument_list|(
name|loop
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Adds a candidate BASE + STEP * i.  Important field is set to IMPORTANT and    position to POS.  If USE is not NULL, the candidate is set as related to    it.  The candidate computation is scheduled on all available positions.  */
end_comment

begin_function
specifier|static
name|void
name|add_candidate
parameter_list|(
name|struct
name|ivopts_data
modifier|*
name|data
parameter_list|,
name|tree
name|base
parameter_list|,
name|tree
name|step
parameter_list|,
name|bool
name|important
parameter_list|,
name|struct
name|iv_use
modifier|*
name|use
parameter_list|)
block|{
if|if
condition|(
name|ip_normal_pos
argument_list|(
name|data
operator|->
name|current_loop
argument_list|)
condition|)
name|add_candidate_1
argument_list|(
name|data
argument_list|,
name|base
argument_list|,
name|step
argument_list|,
name|important
argument_list|,
name|IP_NORMAL
argument_list|,
name|use
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip_end_pos
argument_list|(
name|data
operator|->
name|current_loop
argument_list|)
operator|&&
name|allow_ip_end_pos_p
argument_list|(
name|data
operator|->
name|current_loop
argument_list|)
condition|)
name|add_candidate_1
argument_list|(
name|data
argument_list|,
name|base
argument_list|,
name|step
argument_list|,
name|important
argument_list|,
name|IP_END
argument_list|,
name|use
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add a standard "0 + 1 * iteration" iv candidate for a    type with SIZE bits.  */
end_comment

begin_function
specifier|static
name|void
name|add_standard_iv_candidates_for_size
parameter_list|(
name|struct
name|ivopts_data
modifier|*
name|data
parameter_list|,
name|unsigned
name|int
name|size
parameter_list|)
block|{
name|tree
name|type
init|=
name|lang_hooks
operator|.
name|types
operator|.
name|type_for_size
argument_list|(
name|size
argument_list|,
name|true
argument_list|)
decl_stmt|;
name|add_candidate
argument_list|(
name|data
argument_list|,
name|build_int_cst
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
argument_list|,
name|build_int_cst
argument_list|(
name|type
argument_list|,
literal|1
argument_list|)
argument_list|,
name|true
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Adds standard iv candidates.  */
end_comment

begin_function
specifier|static
name|void
name|add_standard_iv_candidates
parameter_list|(
name|struct
name|ivopts_data
modifier|*
name|data
parameter_list|)
block|{
name|add_standard_iv_candidates_for_size
argument_list|(
name|data
argument_list|,
name|INT_TYPE_SIZE
argument_list|)
expr_stmt|;
comment|/* The same for a double-integer type if it is still fast enough.  */
if|if
condition|(
name|BITS_PER_WORD
operator|>=
name|INT_TYPE_SIZE
operator|*
literal|2
condition|)
name|add_standard_iv_candidates_for_size
argument_list|(
name|data
argument_list|,
name|INT_TYPE_SIZE
operator|*
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Adds candidates bases on the old induction variable IV.  */
end_comment

begin_function
specifier|static
name|void
name|add_old_iv_candidates
parameter_list|(
name|struct
name|ivopts_data
modifier|*
name|data
parameter_list|,
name|struct
name|iv
modifier|*
name|iv
parameter_list|)
block|{
name|tree
name|phi
decl_stmt|,
name|def
decl_stmt|;
name|struct
name|iv_cand
modifier|*
name|cand
decl_stmt|;
name|add_candidate
argument_list|(
name|data
argument_list|,
name|iv
operator|->
name|base
argument_list|,
name|iv
operator|->
name|step
argument_list|,
name|true
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* The same, but with initial value zero.  */
name|add_candidate
argument_list|(
name|data
argument_list|,
name|build_int_cst
argument_list|(
name|TREE_TYPE
argument_list|(
name|iv
operator|->
name|base
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|iv
operator|->
name|step
argument_list|,
name|true
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|phi
operator|=
name|SSA_NAME_DEF_STMT
argument_list|(
name|iv
operator|->
name|ssa_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|phi
argument_list|)
operator|==
name|PHI_NODE
condition|)
block|{
comment|/* Additionally record the possibility of leaving the original iv 	 untouched.  */
name|def
operator|=
name|PHI_ARG_DEF_FROM_EDGE
argument_list|(
name|phi
argument_list|,
name|loop_latch_edge
argument_list|(
name|data
operator|->
name|current_loop
argument_list|)
argument_list|)
expr_stmt|;
name|cand
operator|=
name|add_candidate_1
argument_list|(
name|data
argument_list|,
name|iv
operator|->
name|base
argument_list|,
name|iv
operator|->
name|step
argument_list|,
name|true
argument_list|,
name|IP_ORIGINAL
argument_list|,
name|NULL
argument_list|,
name|SSA_NAME_DEF_STMT
argument_list|(
name|def
argument_list|)
argument_list|)
expr_stmt|;
name|cand
operator|->
name|var_before
operator|=
name|iv
operator|->
name|ssa_name
expr_stmt|;
name|cand
operator|->
name|var_after
operator|=
name|def
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Adds candidates based on the old induction variables.  */
end_comment

begin_function
specifier|static
name|void
name|add_old_ivs_candidates
parameter_list|(
name|struct
name|ivopts_data
modifier|*
name|data
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
name|struct
name|iv
modifier|*
name|iv
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|data->relevant
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|bi
argument_list|)
block|{
name|iv
operator|=
name|ver_info
argument_list|(
name|data
argument_list|,
name|i
argument_list|)
operator|->
name|iv
expr_stmt|;
if|if
condition|(
name|iv
operator|&&
name|iv
operator|->
name|biv_p
operator|&&
operator|!
name|zero_p
argument_list|(
name|iv
operator|->
name|step
argument_list|)
condition|)
name|add_old_iv_candidates
argument_list|(
name|data
argument_list|,
name|iv
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Adds candidates based on the value of the induction variable IV and USE.  */
end_comment

begin_function
specifier|static
name|void
name|add_iv_value_candidates
parameter_list|(
name|struct
name|ivopts_data
modifier|*
name|data
parameter_list|,
name|struct
name|iv
modifier|*
name|iv
parameter_list|,
name|struct
name|iv_use
modifier|*
name|use
parameter_list|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|offset
decl_stmt|;
name|tree
name|base
decl_stmt|;
name|add_candidate
argument_list|(
name|data
argument_list|,
name|iv
operator|->
name|base
argument_list|,
name|iv
operator|->
name|step
argument_list|,
name|false
argument_list|,
name|use
argument_list|)
expr_stmt|;
comment|/* The same, but with initial value zero.  Make such variable important,      since it is generic enough so that possibly many uses may be based      on it.  */
name|add_candidate
argument_list|(
name|data
argument_list|,
name|build_int_cst
argument_list|(
name|TREE_TYPE
argument_list|(
name|iv
operator|->
name|base
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|iv
operator|->
name|step
argument_list|,
name|true
argument_list|,
name|use
argument_list|)
expr_stmt|;
comment|/* Third, try removing the constant offset.  */
name|base
operator|=
name|strip_offset
argument_list|(
name|iv
operator|->
name|base
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
condition|)
name|add_candidate
argument_list|(
name|data
argument_list|,
name|base
argument_list|,
name|iv
operator|->
name|step
argument_list|,
name|false
argument_list|,
name|use
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Adds candidates based on the uses.  */
end_comment

begin_function
specifier|static
name|void
name|add_derived_ivs_candidates
parameter_list|(
name|struct
name|ivopts_data
modifier|*
name|data
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_iv_uses
argument_list|(
name|data
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|iv_use
modifier|*
name|use
init|=
name|iv_use
argument_list|(
name|data
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|use
condition|)
continue|continue;
switch|switch
condition|(
name|use
operator|->
name|type
condition|)
block|{
case|case
name|USE_NONLINEAR_EXPR
case|:
case|case
name|USE_COMPARE
case|:
case|case
name|USE_ADDRESS
case|:
comment|/* Just add the ivs based on the value of the iv used here.  */
name|add_iv_value_candidates
argument_list|(
name|data
argument_list|,
name|use
operator|->
name|iv
argument_list|,
name|use
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Record important candidates and add them to related_cands bitmaps    if needed.  */
end_comment

begin_function
specifier|static
name|void
name|record_important_candidates
parameter_list|(
name|struct
name|ivopts_data
modifier|*
name|data
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
name|struct
name|iv_use
modifier|*
name|use
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_iv_cands
argument_list|(
name|data
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|iv_cand
modifier|*
name|cand
init|=
name|iv_cand
argument_list|(
name|data
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|cand
operator|->
name|important
condition|)
name|bitmap_set_bit
argument_list|(
name|data
operator|->
name|important_candidates
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|data
operator|->
name|consider_all_candidates
operator|=
operator|(
name|n_iv_cands
argument_list|(
name|data
argument_list|)
operator|<=
name|CONSIDER_ALL_CANDIDATES_BOUND
operator|)
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|consider_all_candidates
condition|)
block|{
comment|/* We will not need "related_cands" bitmaps in this case, 	 so release them to decrease peak memory consumption.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_iv_uses
argument_list|(
name|data
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|use
operator|=
name|iv_use
argument_list|(
name|data
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|use
operator|->
name|related_cands
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Add important candidates to the related_cands bitmaps.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_iv_uses
argument_list|(
name|data
argument_list|)
condition|;
name|i
operator|++
control|)
name|bitmap_ior_into
argument_list|(
name|iv_use
argument_list|(
name|data
argument_list|,
name|i
argument_list|)
operator|->
name|related_cands
argument_list|,
name|data
operator|->
name|important_candidates
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Finds the candidates for the induction variables.  */
end_comment

begin_function
specifier|static
name|void
name|find_iv_candidates
parameter_list|(
name|struct
name|ivopts_data
modifier|*
name|data
parameter_list|)
block|{
comment|/* Add commonly used ivs.  */
name|add_standard_iv_candidates
argument_list|(
name|data
argument_list|)
expr_stmt|;
comment|/* Add old induction variables.  */
name|add_old_ivs_candidates
argument_list|(
name|data
argument_list|)
expr_stmt|;
comment|/* Add induction variables derived from uses.  */
name|add_derived_ivs_candidates
argument_list|(
name|data
argument_list|)
expr_stmt|;
comment|/* Record the important candidates.  */
name|record_important_candidates
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Allocates the data structure mapping the (use, candidate) pairs to costs.    If consider_all_candidates is true, we use a two-dimensional array, otherwise    we allocate a simple list to every use.  */
end_comment

begin_function
specifier|static
name|void
name|alloc_use_cost_map
parameter_list|(
name|struct
name|ivopts_data
modifier|*
name|data
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|,
name|size
decl_stmt|,
name|s
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_iv_uses
argument_list|(
name|data
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|iv_use
modifier|*
name|use
init|=
name|iv_use
argument_list|(
name|data
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
if|if
condition|(
name|data
operator|->
name|consider_all_candidates
condition|)
name|size
operator|=
name|n_iv_cands
argument_list|(
name|data
argument_list|)
expr_stmt|;
else|else
block|{
name|s
operator|=
literal|0
expr_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|use->related_cands
argument_list|,
literal|0
argument_list|,
argument|j
argument_list|,
argument|bi
argument_list|)
block|{
name|s
operator|++
expr_stmt|;
block|}
comment|/* Round up to the power of two, so that moduling by it is fast.  */
for|for
control|(
name|size
operator|=
literal|1
init|;
name|size
operator|<
name|s
condition|;
name|size
operator|<<=
literal|1
control|)
continue|continue;
block|}
name|use
operator|->
name|n_map_members
operator|=
name|size
expr_stmt|;
name|use
operator|->
name|cost_map
operator|=
name|XCNEWVEC
argument_list|(
expr|struct
name|cost_pair
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Sets cost of (USE, CANDIDATE) pair to COST and record that it depends    on invariants DEPENDS_ON and that the value used in expressing it    is VALUE.*/
end_comment

begin_function
specifier|static
name|void
name|set_use_iv_cost
parameter_list|(
name|struct
name|ivopts_data
modifier|*
name|data
parameter_list|,
name|struct
name|iv_use
modifier|*
name|use
parameter_list|,
name|struct
name|iv_cand
modifier|*
name|cand
parameter_list|,
name|unsigned
name|cost
parameter_list|,
name|bitmap
name|depends_on
parameter_list|,
name|tree
name|value
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|,
name|s
decl_stmt|;
if|if
condition|(
name|cost
operator|==
name|INFTY
condition|)
block|{
name|BITMAP_FREE
argument_list|(
name|depends_on
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|data
operator|->
name|consider_all_candidates
condition|)
block|{
name|use
operator|->
name|cost_map
index|[
name|cand
operator|->
name|id
index|]
operator|.
name|cand
operator|=
name|cand
expr_stmt|;
name|use
operator|->
name|cost_map
index|[
name|cand
operator|->
name|id
index|]
operator|.
name|cost
operator|=
name|cost
expr_stmt|;
name|use
operator|->
name|cost_map
index|[
name|cand
operator|->
name|id
index|]
operator|.
name|depends_on
operator|=
name|depends_on
expr_stmt|;
name|use
operator|->
name|cost_map
index|[
name|cand
operator|->
name|id
index|]
operator|.
name|value
operator|=
name|value
expr_stmt|;
return|return;
block|}
comment|/* n_map_members is a power of two, so this computes modulo.  */
name|s
operator|=
name|cand
operator|->
name|id
operator|&
operator|(
name|use
operator|->
name|n_map_members
operator|-
literal|1
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|s
init|;
name|i
operator|<
name|use
operator|->
name|n_map_members
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|use
operator|->
name|cost_map
index|[
name|i
index|]
operator|.
name|cand
condition|)
goto|goto
name|found
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|s
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|use
operator|->
name|cost_map
index|[
name|i
index|]
operator|.
name|cand
condition|)
goto|goto
name|found
goto|;
name|gcc_unreachable
argument_list|()
expr_stmt|;
name|found
label|:
name|use
operator|->
name|cost_map
index|[
name|i
index|]
operator|.
name|cand
operator|=
name|cand
expr_stmt|;
name|use
operator|->
name|cost_map
index|[
name|i
index|]
operator|.
name|cost
operator|=
name|cost
expr_stmt|;
name|use
operator|->
name|cost_map
index|[
name|i
index|]
operator|.
name|depends_on
operator|=
name|depends_on
expr_stmt|;
name|use
operator|->
name|cost_map
index|[
name|i
index|]
operator|.
name|value
operator|=
name|value
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Gets cost of (USE, CANDIDATE) pair.  */
end_comment

begin_function
specifier|static
name|struct
name|cost_pair
modifier|*
name|get_use_iv_cost
parameter_list|(
name|struct
name|ivopts_data
modifier|*
name|data
parameter_list|,
name|struct
name|iv_use
modifier|*
name|use
parameter_list|,
name|struct
name|iv_cand
modifier|*
name|cand
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|,
name|s
decl_stmt|;
name|struct
name|cost_pair
modifier|*
name|ret
decl_stmt|;
if|if
condition|(
operator|!
name|cand
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|data
operator|->
name|consider_all_candidates
condition|)
block|{
name|ret
operator|=
name|use
operator|->
name|cost_map
operator|+
name|cand
operator|->
name|id
expr_stmt|;
if|if
condition|(
operator|!
name|ret
operator|->
name|cand
condition|)
return|return
name|NULL
return|;
return|return
name|ret
return|;
block|}
comment|/* n_map_members is a power of two, so this computes modulo.  */
name|s
operator|=
name|cand
operator|->
name|id
operator|&
operator|(
name|use
operator|->
name|n_map_members
operator|-
literal|1
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|s
init|;
name|i
operator|<
name|use
operator|->
name|n_map_members
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|use
operator|->
name|cost_map
index|[
name|i
index|]
operator|.
name|cand
operator|==
name|cand
condition|)
return|return
name|use
operator|->
name|cost_map
operator|+
name|i
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|s
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|use
operator|->
name|cost_map
index|[
name|i
index|]
operator|.
name|cand
operator|==
name|cand
condition|)
return|return
name|use
operator|->
name|cost_map
operator|+
name|i
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Returns estimate on cost of computing SEQ.  */
end_comment

begin_function
specifier|static
name|unsigned
name|seq_cost
parameter_list|(
name|rtx
name|seq
parameter_list|)
block|{
name|unsigned
name|cost
init|=
literal|0
decl_stmt|;
name|rtx
name|set
decl_stmt|;
for|for
control|(
init|;
name|seq
condition|;
name|seq
operator|=
name|NEXT_INSN
argument_list|(
name|seq
argument_list|)
control|)
block|{
name|set
operator|=
name|single_set
argument_list|(
name|seq
argument_list|)
expr_stmt|;
if|if
condition|(
name|set
condition|)
name|cost
operator|+=
name|rtx_cost
argument_list|(
name|set
argument_list|,
name|SET
argument_list|)
expr_stmt|;
else|else
name|cost
operator|++
expr_stmt|;
block|}
return|return
name|cost
return|;
block|}
end_function

begin_comment
comment|/* Produce DECL_RTL for object obj so it looks like it is stored in memory.  */
end_comment

begin_function
specifier|static
name|rtx
name|produce_memory_decl_rtl
parameter_list|(
name|tree
name|obj
parameter_list|,
name|int
modifier|*
name|regno
parameter_list|)
block|{
name|rtx
name|x
decl_stmt|;
name|gcc_assert
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|obj
argument_list|)
operator|||
name|DECL_EXTERNAL
argument_list|(
name|obj
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|obj
argument_list|)
argument_list|)
decl_stmt|;
name|x
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
name|x
operator|=
name|gen_raw_REG
argument_list|(
name|Pmode
argument_list|,
operator|(
operator|*
name|regno
operator|)
operator|++
argument_list|)
expr_stmt|;
return|return
name|gen_rtx_MEM
argument_list|(
name|DECL_MODE
argument_list|(
name|obj
argument_list|)
argument_list|,
name|x
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Prepares decl_rtl for variables referred in *EXPR_P.  Callback for    walk_tree.  DATA contains the actual fake register number.  */
end_comment

begin_function
specifier|static
name|tree
name|prepare_decl_rtl
parameter_list|(
name|tree
modifier|*
name|expr_p
parameter_list|,
name|int
modifier|*
name|ws
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|tree
name|obj
init|=
name|NULL_TREE
decl_stmt|;
name|rtx
name|x
init|=
name|NULL_RTX
decl_stmt|;
name|int
modifier|*
name|regno
init|=
name|data
decl_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|expr_p
argument_list|)
condition|)
block|{
case|case
name|ADDR_EXPR
case|:
for|for
control|(
name|expr_p
operator|=
operator|&
name|TREE_OPERAND
argument_list|(
operator|*
name|expr_p
argument_list|,
literal|0
argument_list|)
init|;
name|handled_component_p
argument_list|(
operator|*
name|expr_p
argument_list|)
condition|;
name|expr_p
operator|=
operator|&
name|TREE_OPERAND
argument_list|(
operator|*
name|expr_p
argument_list|,
literal|0
argument_list|)
control|)
continue|continue;
name|obj
operator|=
operator|*
name|expr_p
expr_stmt|;
if|if
condition|(
name|DECL_P
argument_list|(
name|obj
argument_list|)
operator|&&
operator|!
name|DECL_RTL_SET_P
argument_list|(
name|obj
argument_list|)
condition|)
name|x
operator|=
name|produce_memory_decl_rtl
argument_list|(
name|obj
argument_list|,
name|regno
argument_list|)
expr_stmt|;
break|break;
case|case
name|SSA_NAME
case|:
operator|*
name|ws
operator|=
literal|0
expr_stmt|;
name|obj
operator|=
name|SSA_NAME_VAR
argument_list|(
operator|*
name|expr_p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DECL_RTL_SET_P
argument_list|(
name|obj
argument_list|)
condition|)
name|x
operator|=
name|gen_raw_REG
argument_list|(
name|DECL_MODE
argument_list|(
name|obj
argument_list|)
argument_list|,
operator|(
operator|*
name|regno
operator|)
operator|++
argument_list|)
expr_stmt|;
break|break;
case|case
name|VAR_DECL
case|:
case|case
name|PARM_DECL
case|:
case|case
name|RESULT_DECL
case|:
operator|*
name|ws
operator|=
literal|0
expr_stmt|;
name|obj
operator|=
operator|*
name|expr_p
expr_stmt|;
if|if
condition|(
name|DECL_RTL_SET_P
argument_list|(
name|obj
argument_list|)
condition|)
break|break;
if|if
condition|(
name|DECL_MODE
argument_list|(
name|obj
argument_list|)
operator|==
name|BLKmode
condition|)
name|x
operator|=
name|produce_memory_decl_rtl
argument_list|(
name|obj
argument_list|,
name|regno
argument_list|)
expr_stmt|;
else|else
name|x
operator|=
name|gen_raw_REG
argument_list|(
name|DECL_MODE
argument_list|(
name|obj
argument_list|)
argument_list|,
operator|(
operator|*
name|regno
operator|)
operator|++
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|x
condition|)
block|{
name|VEC_safe_push
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
name|decl_rtl_to_reset
argument_list|,
name|obj
argument_list|)
expr_stmt|;
name|SET_DECL_RTL
argument_list|(
name|obj
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Determines cost of the computation of EXPR.  */
end_comment

begin_function
specifier|static
name|unsigned
name|computation_cost
parameter_list|(
name|tree
name|expr
parameter_list|)
block|{
name|rtx
name|seq
decl_stmt|,
name|rslt
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
decl_stmt|;
name|unsigned
name|cost
decl_stmt|;
comment|/* Avoid using hard regs in ways which may be unsupported.  */
name|int
name|regno
init|=
name|LAST_VIRTUAL_REGISTER
operator|+
literal|1
decl_stmt|;
name|walk_tree
argument_list|(
operator|&
name|expr
argument_list|,
name|prepare_decl_rtl
argument_list|,
operator|&
name|regno
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|rslt
operator|=
name|expand_expr
argument_list|(
name|expr
argument_list|,
name|NULL_RTX
argument_list|,
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|cost
operator|=
name|seq_cost
argument_list|(
name|seq
argument_list|)
expr_stmt|;
if|if
condition|(
name|MEM_P
argument_list|(
name|rslt
argument_list|)
condition|)
name|cost
operator|+=
name|address_cost
argument_list|(
name|XEXP
argument_list|(
name|rslt
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|cost
return|;
block|}
end_function

begin_comment
comment|/* Returns variable containing the value of candidate CAND at statement AT.  */
end_comment

begin_function
specifier|static
name|tree
name|var_at_stmt
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|struct
name|iv_cand
modifier|*
name|cand
parameter_list|,
name|tree
name|stmt
parameter_list|)
block|{
if|if
condition|(
name|stmt_after_increment
argument_list|(
name|loop
argument_list|,
name|cand
argument_list|,
name|stmt
argument_list|)
condition|)
return|return
name|cand
operator|->
name|var_after
return|;
else|else
return|return
name|cand
operator|->
name|var_before
return|;
block|}
end_function

begin_comment
comment|/* Return the most significant (sign) bit of T.  Similar to tree_int_cst_msb,    but the bit is determined from TYPE_PRECISION, not MODE_BITSIZE.  */
end_comment

begin_function
name|int
name|tree_int_cst_sign_bit
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|unsigned
name|bitno
init|=
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|-
literal|1
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|w
decl_stmt|;
if|if
condition|(
name|bitno
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|)
name|w
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|t
argument_list|)
expr_stmt|;
else|else
block|{
name|w
operator|=
name|TREE_INT_CST_HIGH
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|bitno
operator|-=
name|HOST_BITS_PER_WIDE_INT
expr_stmt|;
block|}
return|return
operator|(
name|w
operator|>>
name|bitno
operator|)
operator|&
literal|1
return|;
block|}
end_function

begin_comment
comment|/* If we can prove that TOP = cst * BOT for some constant cst,    store cst to MUL and return true.  Otherwise return false.    The returned value is always sign-extended, regardless of the    signedness of TOP and BOT.  */
end_comment

begin_function
specifier|static
name|bool
name|constant_multiple_of
parameter_list|(
name|tree
name|top
parameter_list|,
name|tree
name|bot
parameter_list|,
name|double_int
modifier|*
name|mul
parameter_list|)
block|{
name|tree
name|mby
decl_stmt|;
name|enum
name|tree_code
name|code
decl_stmt|;
name|double_int
name|res
decl_stmt|,
name|p0
decl_stmt|,
name|p1
decl_stmt|;
name|unsigned
name|precision
init|=
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|top
argument_list|)
argument_list|)
decl_stmt|;
name|STRIP_NOPS
argument_list|(
name|top
argument_list|)
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|bot
argument_list|)
expr_stmt|;
if|if
condition|(
name|operand_equal_p
argument_list|(
name|top
argument_list|,
name|bot
argument_list|,
literal|0
argument_list|)
condition|)
block|{
operator|*
name|mul
operator|=
name|double_int_one
expr_stmt|;
return|return
name|true
return|;
block|}
name|code
operator|=
name|TREE_CODE
argument_list|(
name|top
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|MULT_EXPR
case|:
name|mby
operator|=
name|TREE_OPERAND
argument_list|(
name|top
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|mby
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|constant_multiple_of
argument_list|(
name|TREE_OPERAND
argument_list|(
name|top
argument_list|,
literal|0
argument_list|)
argument_list|,
name|bot
argument_list|,
operator|&
name|res
argument_list|)
condition|)
return|return
name|false
return|;
operator|*
name|mul
operator|=
name|double_int_sext
argument_list|(
name|double_int_mul
argument_list|(
name|res
argument_list|,
name|tree_to_double_int
argument_list|(
name|mby
argument_list|)
argument_list|)
argument_list|,
name|precision
argument_list|)
expr_stmt|;
return|return
name|true
return|;
case|case
name|PLUS_EXPR
case|:
case|case
name|MINUS_EXPR
case|:
if|if
condition|(
operator|!
name|constant_multiple_of
argument_list|(
name|TREE_OPERAND
argument_list|(
name|top
argument_list|,
literal|0
argument_list|)
argument_list|,
name|bot
argument_list|,
operator|&
name|p0
argument_list|)
operator|||
operator|!
name|constant_multiple_of
argument_list|(
name|TREE_OPERAND
argument_list|(
name|top
argument_list|,
literal|1
argument_list|)
argument_list|,
name|bot
argument_list|,
operator|&
name|p1
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|code
operator|==
name|MINUS_EXPR
condition|)
name|p1
operator|=
name|double_int_neg
argument_list|(
name|p1
argument_list|)
expr_stmt|;
operator|*
name|mul
operator|=
name|double_int_sext
argument_list|(
name|double_int_add
argument_list|(
name|p0
argument_list|,
name|p1
argument_list|)
argument_list|,
name|precision
argument_list|)
expr_stmt|;
return|return
name|true
return|;
case|case
name|INTEGER_CST
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|bot
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
return|return
name|false
return|;
name|p0
operator|=
name|double_int_sext
argument_list|(
name|tree_to_double_int
argument_list|(
name|bot
argument_list|)
argument_list|,
name|precision
argument_list|)
expr_stmt|;
name|p1
operator|=
name|double_int_sext
argument_list|(
name|tree_to_double_int
argument_list|(
name|top
argument_list|)
argument_list|,
name|precision
argument_list|)
expr_stmt|;
if|if
condition|(
name|double_int_zero_p
argument_list|(
name|p1
argument_list|)
condition|)
return|return
name|false
return|;
operator|*
name|mul
operator|=
name|double_int_sext
argument_list|(
name|double_int_sdivmod
argument_list|(
name|p0
argument_list|,
name|p1
argument_list|,
name|FLOOR_DIV_EXPR
argument_list|,
operator|&
name|res
argument_list|)
argument_list|,
name|precision
argument_list|)
expr_stmt|;
return|return
name|double_int_zero_p
argument_list|(
name|res
argument_list|)
return|;
default|default:
return|return
name|false
return|;
block|}
block|}
end_function

begin_comment
comment|/* Sets COMB to CST.  */
end_comment

begin_function
specifier|static
name|void
name|aff_combination_const
parameter_list|(
name|struct
name|affine_tree_combination
modifier|*
name|comb
parameter_list|,
name|tree
name|type
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|cst
parameter_list|)
block|{
name|unsigned
name|prec
init|=
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|comb
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|comb
operator|->
name|mask
operator|=
operator|(
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|2
operator|<<
operator|(
name|prec
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
name|comb
operator|->
name|n
operator|=
literal|0
expr_stmt|;
name|comb
operator|->
name|rest
operator|=
name|NULL_TREE
expr_stmt|;
name|comb
operator|->
name|offset
operator|=
name|cst
operator|&
name|comb
operator|->
name|mask
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Sets COMB to single element ELT.  */
end_comment

begin_function
specifier|static
name|void
name|aff_combination_elt
parameter_list|(
name|struct
name|affine_tree_combination
modifier|*
name|comb
parameter_list|,
name|tree
name|type
parameter_list|,
name|tree
name|elt
parameter_list|)
block|{
name|unsigned
name|prec
init|=
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|comb
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|comb
operator|->
name|mask
operator|=
operator|(
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|2
operator|<<
operator|(
name|prec
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
name|comb
operator|->
name|n
operator|=
literal|1
expr_stmt|;
name|comb
operator|->
name|elts
index|[
literal|0
index|]
operator|=
name|elt
expr_stmt|;
name|comb
operator|->
name|coefs
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
name|comb
operator|->
name|rest
operator|=
name|NULL_TREE
expr_stmt|;
name|comb
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Scales COMB by SCALE.  */
end_comment

begin_function
specifier|static
name|void
name|aff_combination_scale
parameter_list|(
name|struct
name|affine_tree_combination
modifier|*
name|comb
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|scale
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|scale
operator|==
literal|1
condition|)
return|return;
if|if
condition|(
name|scale
operator|==
literal|0
condition|)
block|{
name|aff_combination_const
argument_list|(
name|comb
argument_list|,
name|comb
operator|->
name|type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|comb
operator|->
name|offset
operator|=
operator|(
name|scale
operator|*
name|comb
operator|->
name|offset
operator|)
operator|&
name|comb
operator|->
name|mask
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|comb
operator|->
name|n
condition|;
name|i
operator|++
control|)
block|{
name|comb
operator|->
name|coefs
index|[
name|j
index|]
operator|=
operator|(
name|scale
operator|*
name|comb
operator|->
name|coefs
index|[
name|i
index|]
operator|)
operator|&
name|comb
operator|->
name|mask
expr_stmt|;
name|comb
operator|->
name|elts
index|[
name|j
index|]
operator|=
name|comb
operator|->
name|elts
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|comb
operator|->
name|coefs
index|[
name|j
index|]
operator|!=
literal|0
condition|)
name|j
operator|++
expr_stmt|;
block|}
name|comb
operator|->
name|n
operator|=
name|j
expr_stmt|;
if|if
condition|(
name|comb
operator|->
name|rest
condition|)
block|{
if|if
condition|(
name|comb
operator|->
name|n
operator|<
name|MAX_AFF_ELTS
condition|)
block|{
name|comb
operator|->
name|coefs
index|[
name|comb
operator|->
name|n
index|]
operator|=
name|scale
expr_stmt|;
name|comb
operator|->
name|elts
index|[
name|comb
operator|->
name|n
index|]
operator|=
name|comb
operator|->
name|rest
expr_stmt|;
name|comb
operator|->
name|rest
operator|=
name|NULL_TREE
expr_stmt|;
name|comb
operator|->
name|n
operator|++
expr_stmt|;
block|}
else|else
name|comb
operator|->
name|rest
operator|=
name|fold_build2
argument_list|(
name|MULT_EXPR
argument_list|,
name|comb
operator|->
name|type
argument_list|,
name|comb
operator|->
name|rest
argument_list|,
name|build_int_cst_type
argument_list|(
name|comb
operator|->
name|type
argument_list|,
name|scale
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Adds ELT * SCALE to COMB.  */
end_comment

begin_function
specifier|static
name|void
name|aff_combination_add_elt
parameter_list|(
name|struct
name|affine_tree_combination
modifier|*
name|comb
parameter_list|,
name|tree
name|elt
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|scale
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
if|if
condition|(
name|scale
operator|==
literal|0
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|comb
operator|->
name|n
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|operand_equal_p
argument_list|(
name|comb
operator|->
name|elts
index|[
name|i
index|]
argument_list|,
name|elt
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|comb
operator|->
name|coefs
index|[
name|i
index|]
operator|=
operator|(
name|comb
operator|->
name|coefs
index|[
name|i
index|]
operator|+
name|scale
operator|)
operator|&
name|comb
operator|->
name|mask
expr_stmt|;
if|if
condition|(
name|comb
operator|->
name|coefs
index|[
name|i
index|]
condition|)
return|return;
name|comb
operator|->
name|n
operator|--
expr_stmt|;
name|comb
operator|->
name|coefs
index|[
name|i
index|]
operator|=
name|comb
operator|->
name|coefs
index|[
name|comb
operator|->
name|n
index|]
expr_stmt|;
name|comb
operator|->
name|elts
index|[
name|i
index|]
operator|=
name|comb
operator|->
name|elts
index|[
name|comb
operator|->
name|n
index|]
expr_stmt|;
if|if
condition|(
name|comb
operator|->
name|rest
condition|)
block|{
name|gcc_assert
argument_list|(
name|comb
operator|->
name|n
operator|==
name|MAX_AFF_ELTS
operator|-
literal|1
argument_list|)
expr_stmt|;
name|comb
operator|->
name|coefs
index|[
name|comb
operator|->
name|n
index|]
operator|=
literal|1
expr_stmt|;
name|comb
operator|->
name|elts
index|[
name|comb
operator|->
name|n
index|]
operator|=
name|comb
operator|->
name|rest
expr_stmt|;
name|comb
operator|->
name|rest
operator|=
name|NULL_TREE
expr_stmt|;
name|comb
operator|->
name|n
operator|++
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|comb
operator|->
name|n
operator|<
name|MAX_AFF_ELTS
condition|)
block|{
name|comb
operator|->
name|coefs
index|[
name|comb
operator|->
name|n
index|]
operator|=
name|scale
expr_stmt|;
name|comb
operator|->
name|elts
index|[
name|comb
operator|->
name|n
index|]
operator|=
name|elt
expr_stmt|;
name|comb
operator|->
name|n
operator|++
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|scale
operator|==
literal|1
condition|)
name|elt
operator|=
name|fold_convert
argument_list|(
name|comb
operator|->
name|type
argument_list|,
name|elt
argument_list|)
expr_stmt|;
else|else
name|elt
operator|=
name|fold_build2
argument_list|(
name|MULT_EXPR
argument_list|,
name|comb
operator|->
name|type
argument_list|,
name|fold_convert
argument_list|(
name|comb
operator|->
name|type
argument_list|,
name|elt
argument_list|)
argument_list|,
name|build_int_cst_type
argument_list|(
name|comb
operator|->
name|type
argument_list|,
name|scale
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|comb
operator|->
name|rest
condition|)
name|comb
operator|->
name|rest
operator|=
name|fold_build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|comb
operator|->
name|type
argument_list|,
name|comb
operator|->
name|rest
argument_list|,
name|elt
argument_list|)
expr_stmt|;
else|else
name|comb
operator|->
name|rest
operator|=
name|elt
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Adds COMB2 to COMB1.  */
end_comment

begin_function
specifier|static
name|void
name|aff_combination_add
parameter_list|(
name|struct
name|affine_tree_combination
modifier|*
name|comb1
parameter_list|,
name|struct
name|affine_tree_combination
modifier|*
name|comb2
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
name|comb1
operator|->
name|offset
operator|=
operator|(
name|comb1
operator|->
name|offset
operator|+
name|comb2
operator|->
name|offset
operator|)
operator|&
name|comb1
operator|->
name|mask
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|comb2
operator|->
name|n
condition|;
name|i
operator|++
control|)
name|aff_combination_add_elt
argument_list|(
name|comb1
argument_list|,
name|comb2
operator|->
name|elts
index|[
name|i
index|]
argument_list|,
name|comb2
operator|->
name|coefs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|comb2
operator|->
name|rest
condition|)
name|aff_combination_add_elt
argument_list|(
name|comb1
argument_list|,
name|comb2
operator|->
name|rest
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Convert COMB to TYPE.  */
end_comment

begin_function
specifier|static
name|void
name|aff_combination_convert
parameter_list|(
name|tree
name|type
parameter_list|,
name|struct
name|affine_tree_combination
modifier|*
name|comb
parameter_list|)
block|{
name|unsigned
name|prec
init|=
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
comment|/* If the precision of both types is the same, it suffices to change the type      of the whole combination -- the elements are allowed to have another type      equivalent wrto STRIP_NOPS.  */
if|if
condition|(
name|prec
operator|==
name|TYPE_PRECISION
argument_list|(
name|comb
operator|->
name|type
argument_list|)
condition|)
block|{
name|comb
operator|->
name|type
operator|=
name|type
expr_stmt|;
return|return;
block|}
name|comb
operator|->
name|mask
operator|=
operator|(
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|2
operator|<<
operator|(
name|prec
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
name|comb
operator|->
name|offset
operator|=
name|comb
operator|->
name|offset
operator|&
name|comb
operator|->
name|mask
expr_stmt|;
comment|/* The type of the elements can be different from comb->type only as      much as what STRIP_NOPS would remove.  We can just directly cast      to TYPE.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|comb
operator|->
name|n
condition|;
name|i
operator|++
control|)
name|comb
operator|->
name|elts
index|[
name|i
index|]
operator|=
name|fold_convert
argument_list|(
name|type
argument_list|,
name|comb
operator|->
name|elts
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|comb
operator|->
name|rest
condition|)
name|comb
operator|->
name|rest
operator|=
name|fold_convert
argument_list|(
name|type
argument_list|,
name|comb
operator|->
name|rest
argument_list|)
expr_stmt|;
name|comb
operator|->
name|type
operator|=
name|type
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Splits EXPR into an affine combination of parts.  */
end_comment

begin_function
specifier|static
name|void
name|tree_to_aff_combination
parameter_list|(
name|tree
name|expr
parameter_list|,
name|tree
name|type
parameter_list|,
name|struct
name|affine_tree_combination
modifier|*
name|comb
parameter_list|)
block|{
name|struct
name|affine_tree_combination
name|tmp
decl_stmt|;
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|cst
decl_stmt|,
name|core
decl_stmt|,
name|toffset
decl_stmt|;
name|HOST_WIDE_INT
name|bitpos
decl_stmt|,
name|bitsize
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|unsignedp
decl_stmt|,
name|volatilep
decl_stmt|;
name|STRIP_NOPS
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|code
operator|=
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|INTEGER_CST
case|:
name|aff_combination_const
argument_list|(
name|comb
argument_list|,
name|type
argument_list|,
name|int_cst_value
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|PLUS_EXPR
case|:
case|case
name|MINUS_EXPR
case|:
name|tree_to_aff_combination
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|type
argument_list|,
name|comb
argument_list|)
expr_stmt|;
name|tree_to_aff_combination
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|,
name|type
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|MINUS_EXPR
condition|)
name|aff_combination_scale
argument_list|(
operator|&
name|tmp
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|aff_combination_add
argument_list|(
name|comb
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
return|return;
case|case
name|MULT_EXPR
case|:
name|cst
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|cst
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
break|break;
name|tree_to_aff_combination
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|type
argument_list|,
name|comb
argument_list|)
expr_stmt|;
name|aff_combination_scale
argument_list|(
name|comb
argument_list|,
name|int_cst_value
argument_list|(
name|cst
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|NEGATE_EXPR
case|:
name|tree_to_aff_combination
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|type
argument_list|,
name|comb
argument_list|)
expr_stmt|;
name|aff_combination_scale
argument_list|(
name|comb
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return;
case|case
name|ADDR_EXPR
case|:
name|core
operator|=
name|get_inner_reference
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|bitsize
argument_list|,
operator|&
name|bitpos
argument_list|,
operator|&
name|toffset
argument_list|,
operator|&
name|mode
argument_list|,
operator|&
name|unsignedp
argument_list|,
operator|&
name|volatilep
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitpos
operator|%
name|BITS_PER_UNIT
operator|!=
literal|0
condition|)
break|break;
name|aff_combination_const
argument_list|(
name|comb
argument_list|,
name|type
argument_list|,
name|bitpos
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
name|core
operator|=
name|build_fold_addr_expr
argument_list|(
name|core
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|core
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
name|aff_combination_add_elt
argument_list|(
name|comb
argument_list|,
name|core
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
block|{
name|tree_to_aff_combination
argument_list|(
name|core
argument_list|,
name|type
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|aff_combination_add
argument_list|(
name|comb
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|toffset
condition|)
block|{
name|tree_to_aff_combination
argument_list|(
name|toffset
argument_list|,
name|type
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|aff_combination_add
argument_list|(
name|comb
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
block|}
return|return;
default|default:
break|break;
block|}
name|aff_combination_elt
argument_list|(
name|comb
argument_list|,
name|type
argument_list|,
name|expr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Creates EXPR + ELT * SCALE in TYPE.  MASK is the mask for width of TYPE.  */
end_comment

begin_function
specifier|static
name|tree
name|add_elt_to_tree
parameter_list|(
name|tree
name|expr
parameter_list|,
name|tree
name|type
parameter_list|,
name|tree
name|elt
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|scale
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|mask
parameter_list|)
block|{
name|enum
name|tree_code
name|code
decl_stmt|;
name|scale
operator|&=
name|mask
expr_stmt|;
name|elt
operator|=
name|fold_convert
argument_list|(
name|type
argument_list|,
name|elt
argument_list|)
expr_stmt|;
if|if
condition|(
name|scale
operator|==
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|expr
condition|)
return|return
name|elt
return|;
return|return
name|fold_build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|type
argument_list|,
name|expr
argument_list|,
name|elt
argument_list|)
return|;
block|}
if|if
condition|(
name|scale
operator|==
name|mask
condition|)
block|{
if|if
condition|(
operator|!
name|expr
condition|)
return|return
name|fold_build1
argument_list|(
name|NEGATE_EXPR
argument_list|,
name|type
argument_list|,
name|elt
argument_list|)
return|;
return|return
name|fold_build2
argument_list|(
name|MINUS_EXPR
argument_list|,
name|type
argument_list|,
name|expr
argument_list|,
name|elt
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|expr
condition|)
return|return
name|fold_build2
argument_list|(
name|MULT_EXPR
argument_list|,
name|type
argument_list|,
name|elt
argument_list|,
name|build_int_cst_type
argument_list|(
name|type
argument_list|,
name|scale
argument_list|)
argument_list|)
return|;
if|if
condition|(
operator|(
name|scale
operator||
operator|(
name|mask
operator|>>
literal|1
operator|)
operator|)
operator|==
name|mask
condition|)
block|{
comment|/* Scale is negative.  */
name|code
operator|=
name|MINUS_EXPR
expr_stmt|;
name|scale
operator|=
operator|(
operator|-
name|scale
operator|)
operator|&
name|mask
expr_stmt|;
block|}
else|else
name|code
operator|=
name|PLUS_EXPR
expr_stmt|;
name|elt
operator|=
name|fold_build2
argument_list|(
name|MULT_EXPR
argument_list|,
name|type
argument_list|,
name|elt
argument_list|,
name|build_int_cst_type
argument_list|(
name|type
argument_list|,
name|scale
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|fold_build2
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|expr
argument_list|,
name|elt
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Copies the tree elements of COMB to ensure that they are not shared.  */
end_comment

begin_function
specifier|static
name|void
name|unshare_aff_combination
parameter_list|(
name|struct
name|affine_tree_combination
modifier|*
name|comb
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|comb
operator|->
name|n
condition|;
name|i
operator|++
control|)
name|comb
operator|->
name|elts
index|[
name|i
index|]
operator|=
name|unshare_expr
argument_list|(
name|comb
operator|->
name|elts
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|comb
operator|->
name|rest
condition|)
name|comb
operator|->
name|rest
operator|=
name|unshare_expr
argument_list|(
name|comb
operator|->
name|rest
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Makes tree from the affine combination COMB.  */
end_comment

begin_function
specifier|static
name|tree
name|aff_combination_to_tree
parameter_list|(
name|struct
name|affine_tree_combination
modifier|*
name|comb
parameter_list|)
block|{
name|tree
name|type
init|=
name|comb
operator|->
name|type
decl_stmt|;
name|tree
name|expr
init|=
name|comb
operator|->
name|rest
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|off
decl_stmt|,
name|sgn
decl_stmt|;
if|if
condition|(
name|comb
operator|->
name|n
operator|==
literal|0
operator|&&
name|comb
operator|->
name|offset
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|expr
condition|)
block|{
comment|/* Handle the special case produced by get_computation_aff when 	     the type does not fit in HOST_WIDE_INT.  */
return|return
name|fold_convert
argument_list|(
name|type
argument_list|,
name|expr
argument_list|)
return|;
block|}
else|else
return|return
name|build_int_cst
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
return|;
block|}
name|gcc_assert
argument_list|(
name|comb
operator|->
name|n
operator|==
name|MAX_AFF_ELTS
operator|||
name|comb
operator|->
name|rest
operator|==
name|NULL_TREE
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|comb
operator|->
name|n
condition|;
name|i
operator|++
control|)
name|expr
operator|=
name|add_elt_to_tree
argument_list|(
name|expr
argument_list|,
name|type
argument_list|,
name|comb
operator|->
name|elts
index|[
name|i
index|]
argument_list|,
name|comb
operator|->
name|coefs
index|[
name|i
index|]
argument_list|,
name|comb
operator|->
name|mask
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|comb
operator|->
name|offset
operator||
operator|(
name|comb
operator|->
name|mask
operator|>>
literal|1
operator|)
operator|)
operator|==
name|comb
operator|->
name|mask
condition|)
block|{
comment|/* Offset is negative.  */
name|off
operator|=
operator|(
operator|-
name|comb
operator|->
name|offset
operator|)
operator|&
name|comb
operator|->
name|mask
expr_stmt|;
name|sgn
operator|=
name|comb
operator|->
name|mask
expr_stmt|;
block|}
else|else
block|{
name|off
operator|=
name|comb
operator|->
name|offset
expr_stmt|;
name|sgn
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|add_elt_to_tree
argument_list|(
name|expr
argument_list|,
name|type
argument_list|,
name|build_int_cst_type
argument_list|(
name|type
argument_list|,
name|off
argument_list|)
argument_list|,
name|sgn
argument_list|,
name|comb
operator|->
name|mask
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Folds EXPR using the affine expressions framework.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_affine_expr
parameter_list|(
name|tree
name|expr
parameter_list|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
decl_stmt|;
name|struct
name|affine_tree_combination
name|comb
decl_stmt|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|>
name|HOST_BITS_PER_WIDE_INT
condition|)
return|return
name|expr
return|;
name|tree_to_aff_combination
argument_list|(
name|expr
argument_list|,
name|type
argument_list|,
operator|&
name|comb
argument_list|)
expr_stmt|;
return|return
name|aff_combination_to_tree
argument_list|(
operator|&
name|comb
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* If A is (TYPE) BA and B is (TYPE) BB, and the types of BA and BB have the    same precision that is at least as wide as the precision of TYPE, stores    BA to A and BB to B, and returns the type of BA.  Otherwise, returns the    type of A and B.  */
end_comment

begin_function
specifier|static
name|tree
name|determine_common_wider_type
parameter_list|(
name|tree
modifier|*
name|a
parameter_list|,
name|tree
modifier|*
name|b
parameter_list|)
block|{
name|tree
name|wider_type
init|=
name|NULL
decl_stmt|;
name|tree
name|suba
decl_stmt|,
name|subb
decl_stmt|;
name|tree
name|atype
init|=
name|TREE_TYPE
argument_list|(
operator|*
name|a
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
operator|*
name|a
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
operator|*
name|a
argument_list|)
operator|==
name|CONVERT_EXPR
operator|)
condition|)
block|{
name|suba
operator|=
name|TREE_OPERAND
argument_list|(
operator|*
name|a
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|wider_type
operator|=
name|TREE_TYPE
argument_list|(
name|suba
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|wider_type
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|atype
argument_list|)
condition|)
return|return
name|atype
return|;
block|}
else|else
return|return
name|atype
return|;
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
operator|*
name|b
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
operator|*
name|b
argument_list|)
operator|==
name|CONVERT_EXPR
operator|)
condition|)
block|{
name|subb
operator|=
name|TREE_OPERAND
argument_list|(
operator|*
name|b
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|wider_type
argument_list|)
operator|!=
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|subb
argument_list|)
argument_list|)
condition|)
return|return
name|atype
return|;
block|}
else|else
return|return
name|atype
return|;
operator|*
name|a
operator|=
name|suba
expr_stmt|;
operator|*
name|b
operator|=
name|subb
expr_stmt|;
return|return
name|wider_type
return|;
block|}
end_function

begin_comment
comment|/* Determines the expression by that USE is expressed from induction variable    CAND at statement AT in LOOP.  The expression is stored in a decomposed    form into AFF.  Returns false if USE cannot be expressed using CAND.  */
end_comment

begin_function
specifier|static
name|bool
name|get_computation_aff
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|struct
name|iv_use
modifier|*
name|use
parameter_list|,
name|struct
name|iv_cand
modifier|*
name|cand
parameter_list|,
name|tree
name|at
parameter_list|,
name|struct
name|affine_tree_combination
modifier|*
name|aff
parameter_list|)
block|{
name|tree
name|ubase
init|=
name|use
operator|->
name|iv
operator|->
name|base
decl_stmt|;
name|tree
name|ustep
init|=
name|use
operator|->
name|iv
operator|->
name|step
decl_stmt|;
name|tree
name|cbase
init|=
name|cand
operator|->
name|iv
operator|->
name|base
decl_stmt|;
name|tree
name|cstep
init|=
name|cand
operator|->
name|iv
operator|->
name|step
decl_stmt|;
name|tree
name|utype
init|=
name|TREE_TYPE
argument_list|(
name|ubase
argument_list|)
decl_stmt|,
name|ctype
init|=
name|TREE_TYPE
argument_list|(
name|cbase
argument_list|)
decl_stmt|;
name|tree
name|common_type
decl_stmt|;
name|tree
name|uutype
decl_stmt|;
name|tree
name|expr
decl_stmt|,
name|delta
decl_stmt|;
name|tree
name|ratio
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|ustepi
decl_stmt|,
name|cstepi
decl_stmt|;
name|HOST_WIDE_INT
name|ratioi
decl_stmt|;
name|struct
name|affine_tree_combination
name|cbase_aff
decl_stmt|,
name|expr_aff
decl_stmt|;
name|tree
name|cstep_orig
init|=
name|cstep
decl_stmt|,
name|ustep_orig
init|=
name|ustep
decl_stmt|;
name|double_int
name|rat
decl_stmt|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|utype
argument_list|)
operator|>
name|TYPE_PRECISION
argument_list|(
name|ctype
argument_list|)
condition|)
block|{
comment|/* We do not have a precision to express the values of use.  */
return|return
name|false
return|;
block|}
name|expr
operator|=
name|var_at_stmt
argument_list|(
name|loop
argument_list|,
name|cand
argument_list|,
name|at
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
operator|!=
name|ctype
condition|)
block|{
comment|/* This may happen with the original ivs.  */
name|expr
operator|=
name|fold_convert
argument_list|(
name|ctype
argument_list|,
name|expr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_UNSIGNED
argument_list|(
name|utype
argument_list|)
condition|)
name|uutype
operator|=
name|utype
expr_stmt|;
else|else
block|{
name|uutype
operator|=
name|unsigned_type_for
argument_list|(
name|utype
argument_list|)
expr_stmt|;
name|ubase
operator|=
name|fold_convert
argument_list|(
name|uutype
argument_list|,
name|ubase
argument_list|)
expr_stmt|;
name|ustep
operator|=
name|fold_convert
argument_list|(
name|uutype
argument_list|,
name|ustep
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|uutype
operator|!=
name|ctype
condition|)
block|{
name|expr
operator|=
name|fold_convert
argument_list|(
name|uutype
argument_list|,
name|expr
argument_list|)
expr_stmt|;
name|cbase
operator|=
name|fold_convert
argument_list|(
name|uutype
argument_list|,
name|cbase
argument_list|)
expr_stmt|;
name|cstep
operator|=
name|fold_convert
argument_list|(
name|uutype
argument_list|,
name|cstep
argument_list|)
expr_stmt|;
comment|/* If the conversion is not noop, we must take it into account when 	 considering the value of the step.  */
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|utype
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|ctype
argument_list|)
condition|)
name|cstep_orig
operator|=
name|cstep
expr_stmt|;
block|}
if|if
condition|(
name|cst_and_fits_in_hwi
argument_list|(
name|cstep_orig
argument_list|)
operator|&&
name|cst_and_fits_in_hwi
argument_list|(
name|ustep_orig
argument_list|)
condition|)
block|{
name|ustepi
operator|=
name|int_cst_value
argument_list|(
name|ustep_orig
argument_list|)
expr_stmt|;
name|cstepi
operator|=
name|int_cst_value
argument_list|(
name|cstep_orig
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|divide
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|uutype
argument_list|)
argument_list|,
name|ustepi
argument_list|,
name|cstepi
argument_list|,
operator|&
name|ratioi
argument_list|)
condition|)
block|{
comment|/* TODO maybe consider case when ustep divides cstep and the ratio is 	     a power of 2 (so that the division is fast to execute)?  We would 	     need to be much more careful with overflows etc. then.  */
return|return
name|false
return|;
block|}
name|ratio
operator|=
name|build_int_cst_type
argument_list|(
name|uutype
argument_list|,
name|ratioi
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|constant_multiple_of
argument_list|(
name|ustep_orig
argument_list|,
name|cstep_orig
argument_list|,
operator|&
name|rat
argument_list|)
condition|)
return|return
name|false
return|;
name|ratio
operator|=
name|double_int_to_tree
argument_list|(
name|uutype
argument_list|,
name|rat
argument_list|)
expr_stmt|;
comment|/* Ratioi is only used to detect special cases when the multiplicative 	 factor is 1 or -1, so if rat does not fit to HOST_WIDE_INT, we may 	 set it to 0.  */
if|if
condition|(
name|double_int_fits_in_shwi_p
argument_list|(
name|rat
argument_list|)
condition|)
name|ratioi
operator|=
name|double_int_to_shwi
argument_list|(
name|rat
argument_list|)
expr_stmt|;
else|else
name|ratioi
operator|=
literal|0
expr_stmt|;
block|}
comment|/* In case both UBASE and CBASE are shortened to UUTYPE from some common      type, we achieve better folding by computing their difference in this      wider type, and cast the result to UUTYPE.  We do not need to worry about      overflows, as all the arithmetics will in the end be performed in UUTYPE      anyway.  */
name|common_type
operator|=
name|determine_common_wider_type
argument_list|(
operator|&
name|ubase
argument_list|,
operator|&
name|cbase
argument_list|)
expr_stmt|;
comment|/* We may need to shift the value if we are after the increment.  */
if|if
condition|(
name|stmt_after_increment
argument_list|(
name|loop
argument_list|,
name|cand
argument_list|,
name|at
argument_list|)
condition|)
block|{
if|if
condition|(
name|uutype
operator|!=
name|common_type
condition|)
name|cstep
operator|=
name|fold_convert
argument_list|(
name|common_type
argument_list|,
name|cstep
argument_list|)
expr_stmt|;
name|cbase
operator|=
name|fold_build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|common_type
argument_list|,
name|cbase
argument_list|,
name|cstep
argument_list|)
expr_stmt|;
block|}
comment|/* use = ubase - ratio * cbase + ratio * var.       In general case ubase + ratio * (var - cbase) could be better (one less      multiplication), but often it is possible to eliminate redundant parts      of computations from (ubase - ratio * cbase) term, and if it does not      happen, fold is able to apply the distributive law to obtain this form      anyway.  */
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|common_type
argument_list|)
operator|>
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
comment|/* Let's compute in trees and just return the result in AFF.  This case 	 should not be very common, and fold itself is not that bad either, 	 so making the aff. functions more complicated to handle this case 	 is not that urgent.  */
if|if
condition|(
name|ratioi
operator|==
literal|1
condition|)
block|{
name|delta
operator|=
name|fold_build2
argument_list|(
name|MINUS_EXPR
argument_list|,
name|common_type
argument_list|,
name|ubase
argument_list|,
name|cbase
argument_list|)
expr_stmt|;
if|if
condition|(
name|uutype
operator|!=
name|common_type
condition|)
name|delta
operator|=
name|fold_convert
argument_list|(
name|uutype
argument_list|,
name|delta
argument_list|)
expr_stmt|;
name|expr
operator|=
name|fold_build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|uutype
argument_list|,
name|expr
argument_list|,
name|delta
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ratioi
operator|==
operator|-
literal|1
condition|)
block|{
name|delta
operator|=
name|fold_build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|common_type
argument_list|,
name|ubase
argument_list|,
name|cbase
argument_list|)
expr_stmt|;
if|if
condition|(
name|uutype
operator|!=
name|common_type
condition|)
name|delta
operator|=
name|fold_convert
argument_list|(
name|uutype
argument_list|,
name|delta
argument_list|)
expr_stmt|;
name|expr
operator|=
name|fold_build2
argument_list|(
name|MINUS_EXPR
argument_list|,
name|uutype
argument_list|,
name|delta
argument_list|,
name|expr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|delta
operator|=
name|fold_build2
argument_list|(
name|MULT_EXPR
argument_list|,
name|common_type
argument_list|,
name|cbase
argument_list|,
name|ratio
argument_list|)
expr_stmt|;
name|delta
operator|=
name|fold_build2
argument_list|(
name|MINUS_EXPR
argument_list|,
name|common_type
argument_list|,
name|ubase
argument_list|,
name|delta
argument_list|)
expr_stmt|;
if|if
condition|(
name|uutype
operator|!=
name|common_type
condition|)
name|delta
operator|=
name|fold_convert
argument_list|(
name|uutype
argument_list|,
name|delta
argument_list|)
expr_stmt|;
name|expr
operator|=
name|fold_build2
argument_list|(
name|MULT_EXPR
argument_list|,
name|uutype
argument_list|,
name|ratio
argument_list|,
name|expr
argument_list|)
expr_stmt|;
name|expr
operator|=
name|fold_build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|uutype
argument_list|,
name|delta
argument_list|,
name|expr
argument_list|)
expr_stmt|;
block|}
name|aff
operator|->
name|type
operator|=
name|uutype
expr_stmt|;
name|aff
operator|->
name|n
operator|=
literal|0
expr_stmt|;
name|aff
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
name|aff
operator|->
name|mask
operator|=
literal|0
expr_stmt|;
name|aff
operator|->
name|rest
operator|=
name|expr
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* If we got here, the types fits in HOST_WIDE_INT, thus it must be      possible to compute ratioi.  */
name|gcc_assert
argument_list|(
name|ratioi
argument_list|)
expr_stmt|;
name|tree_to_aff_combination
argument_list|(
name|ubase
argument_list|,
name|common_type
argument_list|,
name|aff
argument_list|)
expr_stmt|;
name|tree_to_aff_combination
argument_list|(
name|cbase
argument_list|,
name|common_type
argument_list|,
operator|&
name|cbase_aff
argument_list|)
expr_stmt|;
name|tree_to_aff_combination
argument_list|(
name|expr
argument_list|,
name|uutype
argument_list|,
operator|&
name|expr_aff
argument_list|)
expr_stmt|;
name|aff_combination_scale
argument_list|(
operator|&
name|cbase_aff
argument_list|,
operator|-
name|ratioi
argument_list|)
expr_stmt|;
name|aff_combination_scale
argument_list|(
operator|&
name|expr_aff
argument_list|,
name|ratioi
argument_list|)
expr_stmt|;
name|aff_combination_add
argument_list|(
name|aff
argument_list|,
operator|&
name|cbase_aff
argument_list|)
expr_stmt|;
if|if
condition|(
name|common_type
operator|!=
name|uutype
condition|)
name|aff_combination_convert
argument_list|(
name|uutype
argument_list|,
name|aff
argument_list|)
expr_stmt|;
name|aff_combination_add
argument_list|(
name|aff
argument_list|,
operator|&
name|expr_aff
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Determines the expression by that USE is expressed from induction variable    CAND at statement AT in LOOP.  The computation is unshared.  */
end_comment

begin_function
specifier|static
name|tree
name|get_computation_at
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|struct
name|iv_use
modifier|*
name|use
parameter_list|,
name|struct
name|iv_cand
modifier|*
name|cand
parameter_list|,
name|tree
name|at
parameter_list|)
block|{
name|struct
name|affine_tree_combination
name|aff
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|use
operator|->
name|iv
operator|->
name|base
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|get_computation_aff
argument_list|(
name|loop
argument_list|,
name|use
argument_list|,
name|cand
argument_list|,
name|at
argument_list|,
operator|&
name|aff
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
name|unshare_aff_combination
argument_list|(
operator|&
name|aff
argument_list|)
expr_stmt|;
return|return
name|fold_convert
argument_list|(
name|type
argument_list|,
name|aff_combination_to_tree
argument_list|(
operator|&
name|aff
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Determines the expression by that USE is expressed from induction variable    CAND in LOOP.  The computation is unshared.  */
end_comment

begin_function
specifier|static
name|tree
name|get_computation
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|struct
name|iv_use
modifier|*
name|use
parameter_list|,
name|struct
name|iv_cand
modifier|*
name|cand
parameter_list|)
block|{
return|return
name|get_computation_at
argument_list|(
name|loop
argument_list|,
name|use
argument_list|,
name|cand
argument_list|,
name|use
operator|->
name|stmt
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns cost of addition in MODE.  */
end_comment

begin_function
specifier|static
name|unsigned
name|add_cost
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
specifier|static
name|unsigned
name|costs
index|[
name|NUM_MACHINE_MODES
index|]
decl_stmt|;
name|rtx
name|seq
decl_stmt|;
name|unsigned
name|cost
decl_stmt|;
if|if
condition|(
name|costs
index|[
name|mode
index|]
condition|)
return|return
name|costs
index|[
name|mode
index|]
return|;
name|start_sequence
argument_list|()
expr_stmt|;
name|force_operand
argument_list|(
name|gen_rtx_fmt_ee
argument_list|(
name|PLUS
argument_list|,
name|mode
argument_list|,
name|gen_raw_REG
argument_list|(
name|mode
argument_list|,
name|LAST_VIRTUAL_REGISTER
operator|+
literal|1
argument_list|)
argument_list|,
name|gen_raw_REG
argument_list|(
name|mode
argument_list|,
name|LAST_VIRTUAL_REGISTER
operator|+
literal|2
argument_list|)
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|cost
operator|=
name|seq_cost
argument_list|(
name|seq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cost
condition|)
name|cost
operator|=
literal|1
expr_stmt|;
name|costs
index|[
name|mode
index|]
operator|=
name|cost
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Addition in %s costs %d\n"
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|mode
argument_list|)
argument_list|,
name|cost
argument_list|)
expr_stmt|;
return|return
name|cost
return|;
block|}
end_function

begin_comment
comment|/* Entry in a hashtable of already known costs for multiplication.  */
end_comment

begin_struct
struct|struct
name|mbc_entry
block|{
name|HOST_WIDE_INT
name|cst
decl_stmt|;
comment|/* The constant to multiply by.  */
name|enum
name|machine_mode
name|mode
decl_stmt|;
comment|/* In mode.  */
name|unsigned
name|cost
decl_stmt|;
comment|/* The cost.  */
block|}
struct|;
end_struct

begin_comment
comment|/* Counts hash value for the ENTRY.  */
end_comment

begin_function
specifier|static
name|hashval_t
name|mbc_entry_hash
parameter_list|(
specifier|const
name|void
modifier|*
name|entry
parameter_list|)
block|{
specifier|const
name|struct
name|mbc_entry
modifier|*
name|e
init|=
name|entry
decl_stmt|;
return|return
literal|57
operator|*
operator|(
name|hashval_t
operator|)
name|e
operator|->
name|mode
operator|+
call|(
name|hashval_t
call|)
argument_list|(
name|e
operator|->
name|cst
operator|%
literal|877
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Compares the hash table entries ENTRY1 and ENTRY2.  */
end_comment

begin_function
specifier|static
name|int
name|mbc_entry_eq
parameter_list|(
specifier|const
name|void
modifier|*
name|entry1
parameter_list|,
specifier|const
name|void
modifier|*
name|entry2
parameter_list|)
block|{
specifier|const
name|struct
name|mbc_entry
modifier|*
name|e1
init|=
name|entry1
decl_stmt|;
specifier|const
name|struct
name|mbc_entry
modifier|*
name|e2
init|=
name|entry2
decl_stmt|;
return|return
operator|(
name|e1
operator|->
name|mode
operator|==
name|e2
operator|->
name|mode
operator|&&
name|e1
operator|->
name|cst
operator|==
name|e2
operator|->
name|cst
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Returns cost of multiplication by constant CST in MODE.  */
end_comment

begin_function
name|unsigned
name|multiply_by_cost
parameter_list|(
name|HOST_WIDE_INT
name|cst
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
specifier|static
name|htab_t
name|costs
decl_stmt|;
name|struct
name|mbc_entry
modifier|*
modifier|*
name|cached
decl_stmt|,
name|act
decl_stmt|;
name|rtx
name|seq
decl_stmt|;
name|unsigned
name|cost
decl_stmt|;
if|if
condition|(
operator|!
name|costs
condition|)
name|costs
operator|=
name|htab_create
argument_list|(
literal|100
argument_list|,
name|mbc_entry_hash
argument_list|,
name|mbc_entry_eq
argument_list|,
name|free
argument_list|)
expr_stmt|;
name|act
operator|.
name|mode
operator|=
name|mode
expr_stmt|;
name|act
operator|.
name|cst
operator|=
name|cst
expr_stmt|;
name|cached
operator|=
operator|(
expr|struct
name|mbc_entry
operator|*
operator|*
operator|)
name|htab_find_slot
argument_list|(
name|costs
argument_list|,
operator|&
name|act
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cached
condition|)
return|return
operator|(
operator|*
name|cached
operator|)
operator|->
name|cost
return|;
operator|*
name|cached
operator|=
name|XNEW
argument_list|(
expr|struct
name|mbc_entry
argument_list|)
expr_stmt|;
operator|(
operator|*
name|cached
operator|)
operator|->
name|mode
operator|=
name|mode
expr_stmt|;
operator|(
operator|*
name|cached
operator|)
operator|->
name|cst
operator|=
name|cst
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|expand_mult
argument_list|(
name|mode
argument_list|,
name|gen_raw_REG
argument_list|(
name|mode
argument_list|,
name|LAST_VIRTUAL_REGISTER
operator|+
literal|1
argument_list|)
argument_list|,
name|gen_int_mode
argument_list|(
name|cst
argument_list|,
name|mode
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|cost
operator|=
name|seq_cost
argument_list|(
name|seq
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Multiplication by %d in %s costs %d\n"
argument_list|,
operator|(
name|int
operator|)
name|cst
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|mode
argument_list|)
argument_list|,
name|cost
argument_list|)
expr_stmt|;
operator|(
operator|*
name|cached
operator|)
operator|->
name|cost
operator|=
name|cost
expr_stmt|;
return|return
name|cost
return|;
block|}
end_function

begin_comment
comment|/* Returns true if multiplying by RATIO is allowed in address.  */
end_comment

begin_function
name|bool
name|multiplier_allowed_in_address_p
parameter_list|(
name|HOST_WIDE_INT
name|ratio
parameter_list|)
block|{
define|#
directive|define
name|MAX_RATIO
value|128
specifier|static
name|sbitmap
name|valid_mult
decl_stmt|;
if|if
condition|(
operator|!
name|valid_mult
condition|)
block|{
name|rtx
name|reg1
init|=
name|gen_raw_REG
argument_list|(
name|Pmode
argument_list|,
name|LAST_VIRTUAL_REGISTER
operator|+
literal|1
argument_list|)
decl_stmt|;
name|rtx
name|addr
decl_stmt|;
name|HOST_WIDE_INT
name|i
decl_stmt|;
name|valid_mult
operator|=
name|sbitmap_alloc
argument_list|(
literal|2
operator|*
name|MAX_RATIO
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|valid_mult
argument_list|)
expr_stmt|;
name|addr
operator|=
name|gen_rtx_fmt_ee
argument_list|(
name|MULT
argument_list|,
name|Pmode
argument_list|,
name|reg1
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
operator|-
name|MAX_RATIO
init|;
name|i
operator|<=
name|MAX_RATIO
condition|;
name|i
operator|++
control|)
block|{
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
operator|=
name|gen_int_mode
argument_list|(
name|i
argument_list|,
name|Pmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|memory_address_p
argument_list|(
name|Pmode
argument_list|,
name|addr
argument_list|)
condition|)
name|SET_BIT
argument_list|(
name|valid_mult
argument_list|,
name|i
operator|+
name|MAX_RATIO
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"  allowed multipliers:"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
operator|-
name|MAX_RATIO
init|;
name|i
operator|<=
name|MAX_RATIO
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TEST_BIT
argument_list|(
name|valid_mult
argument_list|,
name|i
operator|+
name|MAX_RATIO
argument_list|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|" %d"
argument_list|,
operator|(
name|int
operator|)
name|i
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ratio
operator|>
name|MAX_RATIO
operator|||
name|ratio
operator|<
operator|-
name|MAX_RATIO
condition|)
return|return
name|false
return|;
return|return
name|TEST_BIT
argument_list|(
name|valid_mult
argument_list|,
name|ratio
operator|+
name|MAX_RATIO
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns cost of address in shape symbol + var + OFFSET + RATIO * index.    If SYMBOL_PRESENT is false, symbol is omitted.  If VAR_PRESENT is false,    variable is omitted.  The created memory accesses MODE.        TODO -- there must be some better way.  This all is quite crude.  */
end_comment

begin_function
specifier|static
name|unsigned
name|get_address_cost
parameter_list|(
name|bool
name|symbol_present
parameter_list|,
name|bool
name|var_present
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|offset
parameter_list|,
name|HOST_WIDE_INT
name|ratio
parameter_list|)
block|{
specifier|static
name|bool
name|initialized
init|=
name|false
decl_stmt|;
specifier|static
name|HOST_WIDE_INT
name|rat
decl_stmt|,
name|off
decl_stmt|;
specifier|static
name|HOST_WIDE_INT
name|min_offset
decl_stmt|,
name|max_offset
decl_stmt|;
specifier|static
name|unsigned
name|costs
index|[
literal|2
index|]
index|[
literal|2
index|]
index|[
literal|2
index|]
index|[
literal|2
index|]
decl_stmt|;
name|unsigned
name|cost
decl_stmt|,
name|acost
decl_stmt|;
name|bool
name|offset_p
decl_stmt|,
name|ratio_p
decl_stmt|;
name|HOST_WIDE_INT
name|s_offset
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|mask
decl_stmt|;
name|unsigned
name|bits
decl_stmt|;
if|if
condition|(
operator|!
name|initialized
condition|)
block|{
name|HOST_WIDE_INT
name|i
decl_stmt|;
name|int
name|old_cse_not_expected
decl_stmt|;
name|unsigned
name|sym_p
decl_stmt|,
name|var_p
decl_stmt|,
name|off_p
decl_stmt|,
name|rat_p
decl_stmt|,
name|add_c
decl_stmt|;
name|rtx
name|seq
decl_stmt|,
name|addr
decl_stmt|,
name|base
decl_stmt|;
name|rtx
name|reg0
decl_stmt|,
name|reg1
decl_stmt|;
name|initialized
operator|=
name|true
expr_stmt|;
name|reg1
operator|=
name|gen_raw_REG
argument_list|(
name|Pmode
argument_list|,
name|LAST_VIRTUAL_REGISTER
operator|+
literal|1
argument_list|)
expr_stmt|;
name|addr
operator|=
name|gen_rtx_fmt_ee
argument_list|(
name|PLUS
argument_list|,
name|Pmode
argument_list|,
name|reg1
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
literal|1
operator|<<
literal|20
condition|;
name|i
operator|<<=
literal|1
control|)
block|{
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
operator|=
name|gen_int_mode
argument_list|(
name|i
argument_list|,
name|Pmode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|memory_address_p
argument_list|(
name|Pmode
argument_list|,
name|addr
argument_list|)
condition|)
break|break;
block|}
name|max_offset
operator|=
name|i
operator|>>
literal|1
expr_stmt|;
name|off
operator|=
name|max_offset
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
literal|1
operator|<<
literal|20
condition|;
name|i
operator|<<=
literal|1
control|)
block|{
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
operator|=
name|gen_int_mode
argument_list|(
operator|-
name|i
argument_list|,
name|Pmode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|memory_address_p
argument_list|(
name|Pmode
argument_list|,
name|addr
argument_list|)
condition|)
break|break;
block|}
name|min_offset
operator|=
operator|-
operator|(
name|i
operator|>>
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"get_address_cost:\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"  min offset %d\n"
argument_list|,
operator|(
name|int
operator|)
name|min_offset
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"  max offset %d\n"
argument_list|,
operator|(
name|int
operator|)
name|max_offset
argument_list|)
expr_stmt|;
block|}
name|rat
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<=
name|MAX_RATIO
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|multiplier_allowed_in_address_p
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|rat
operator|=
name|i
expr_stmt|;
break|break;
block|}
comment|/* Compute the cost of various addressing modes.  */
name|acost
operator|=
literal|0
expr_stmt|;
name|reg0
operator|=
name|gen_raw_REG
argument_list|(
name|Pmode
argument_list|,
name|LAST_VIRTUAL_REGISTER
operator|+
literal|1
argument_list|)
expr_stmt|;
name|reg1
operator|=
name|gen_raw_REG
argument_list|(
name|Pmode
argument_list|,
name|LAST_VIRTUAL_REGISTER
operator|+
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|sym_p
operator|=
name|i
operator|&
literal|1
expr_stmt|;
name|var_p
operator|=
operator|(
name|i
operator|>>
literal|1
operator|)
operator|&
literal|1
expr_stmt|;
name|off_p
operator|=
operator|(
name|i
operator|>>
literal|2
operator|)
operator|&
literal|1
expr_stmt|;
name|rat_p
operator|=
operator|(
name|i
operator|>>
literal|3
operator|)
operator|&
literal|1
expr_stmt|;
name|addr
operator|=
name|reg0
expr_stmt|;
if|if
condition|(
name|rat_p
condition|)
name|addr
operator|=
name|gen_rtx_fmt_ee
argument_list|(
name|MULT
argument_list|,
name|Pmode
argument_list|,
name|addr
argument_list|,
name|gen_int_mode
argument_list|(
name|rat
argument_list|,
name|Pmode
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|var_p
condition|)
name|addr
operator|=
name|gen_rtx_fmt_ee
argument_list|(
name|PLUS
argument_list|,
name|Pmode
argument_list|,
name|addr
argument_list|,
name|reg1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym_p
condition|)
block|{
name|base
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|ggc_strdup
argument_list|(
literal|""
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|off_p
condition|)
name|base
operator|=
name|gen_rtx_fmt_e
argument_list|(
name|CONST
argument_list|,
name|Pmode
argument_list|,
name|gen_rtx_fmt_ee
argument_list|(
name|PLUS
argument_list|,
name|Pmode
argument_list|,
name|base
argument_list|,
name|gen_int_mode
argument_list|(
name|off
argument_list|,
name|Pmode
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|off_p
condition|)
name|base
operator|=
name|gen_int_mode
argument_list|(
name|off
argument_list|,
name|Pmode
argument_list|)
expr_stmt|;
else|else
name|base
operator|=
name|NULL_RTX
expr_stmt|;
if|if
condition|(
name|base
condition|)
name|addr
operator|=
name|gen_rtx_fmt_ee
argument_list|(
name|PLUS
argument_list|,
name|Pmode
argument_list|,
name|addr
argument_list|,
name|base
argument_list|)
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
comment|/* To avoid splitting addressing modes, pretend that no cse will 	     follow.  */
name|old_cse_not_expected
operator|=
name|cse_not_expected
expr_stmt|;
name|cse_not_expected
operator|=
name|true
expr_stmt|;
name|addr
operator|=
name|memory_address
argument_list|(
name|Pmode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|cse_not_expected
operator|=
name|old_cse_not_expected
expr_stmt|;
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|acost
operator|=
name|seq_cost
argument_list|(
name|seq
argument_list|)
expr_stmt|;
name|acost
operator|+=
name|address_cost
argument_list|(
name|addr
argument_list|,
name|Pmode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|acost
condition|)
name|acost
operator|=
literal|1
expr_stmt|;
name|costs
index|[
name|sym_p
index|]
index|[
name|var_p
index|]
index|[
name|off_p
index|]
index|[
name|rat_p
index|]
operator|=
name|acost
expr_stmt|;
block|}
comment|/* On some targets, it is quite expensive to load symbol to a register, 	 which makes addresses that contain symbols look much more expensive. 	 However, the symbol will have to be loaded in any case before the 	 loop (and quite likely we have it in register already), so it does not 	 make much sense to penalize them too heavily.  So make some final          tweaks for the SYMBOL_PRESENT modes:           If VAR_PRESENT is false, and the mode obtained by changing symbol to 	 var is cheaper, use this mode with small penalty. 	 If VAR_PRESENT is true, try whether the mode with 	 SYMBOL_PRESENT = false is cheaper even with cost of addition, and 	 if this is the case, use it.  */
name|add_c
operator|=
name|add_cost
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
name|var_p
operator|=
name|i
operator|&
literal|1
expr_stmt|;
name|off_p
operator|=
operator|(
name|i
operator|>>
literal|1
operator|)
operator|&
literal|1
expr_stmt|;
name|rat_p
operator|=
operator|(
name|i
operator|>>
literal|2
operator|)
operator|&
literal|1
expr_stmt|;
name|acost
operator|=
name|costs
index|[
literal|0
index|]
index|[
literal|1
index|]
index|[
name|off_p
index|]
index|[
name|rat_p
index|]
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|var_p
condition|)
name|acost
operator|+=
name|add_c
expr_stmt|;
if|if
condition|(
name|acost
operator|<
name|costs
index|[
literal|1
index|]
index|[
name|var_p
index|]
index|[
name|off_p
index|]
index|[
name|rat_p
index|]
condition|)
name|costs
index|[
literal|1
index|]
index|[
name|var_p
index|]
index|[
name|off_p
index|]
index|[
name|rat_p
index|]
operator|=
name|acost
expr_stmt|;
block|}
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Address costs:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|sym_p
operator|=
name|i
operator|&
literal|1
expr_stmt|;
name|var_p
operator|=
operator|(
name|i
operator|>>
literal|1
operator|)
operator|&
literal|1
expr_stmt|;
name|off_p
operator|=
operator|(
name|i
operator|>>
literal|2
operator|)
operator|&
literal|1
expr_stmt|;
name|rat_p
operator|=
operator|(
name|i
operator|>>
literal|3
operator|)
operator|&
literal|1
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"  "
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym_p
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"sym + "
argument_list|)
expr_stmt|;
if|if
condition|(
name|var_p
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"var + "
argument_list|)
expr_stmt|;
if|if
condition|(
name|off_p
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"cst + "
argument_list|)
expr_stmt|;
if|if
condition|(
name|rat_p
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"rat * "
argument_list|)
expr_stmt|;
name|acost
operator|=
name|costs
index|[
name|sym_p
index|]
index|[
name|var_p
index|]
index|[
name|off_p
index|]
index|[
name|rat_p
index|]
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"index costs %d\n"
argument_list|,
name|acost
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|bits
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|mask
operator|=
operator|~
operator|(
operator|~
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|0
operator|<<
operator|(
name|bits
operator|-
literal|1
operator|)
operator|<<
literal|1
operator|)
expr_stmt|;
name|offset
operator|&=
name|mask
expr_stmt|;
if|if
condition|(
operator|(
name|offset
operator|>>
operator|(
name|bits
operator|-
literal|1
operator|)
operator|&
literal|1
operator|)
condition|)
name|offset
operator||=
operator|~
name|mask
expr_stmt|;
name|s_offset
operator|=
name|offset
expr_stmt|;
name|cost
operator|=
literal|0
expr_stmt|;
name|offset_p
operator|=
operator|(
name|s_offset
operator|!=
literal|0
operator|&&
name|min_offset
operator|<=
name|s_offset
operator|&&
name|s_offset
operator|<=
name|max_offset
operator|)
expr_stmt|;
name|ratio_p
operator|=
operator|(
name|ratio
operator|!=
literal|1
operator|&&
name|multiplier_allowed_in_address_p
argument_list|(
name|ratio
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|ratio
operator|!=
literal|1
operator|&&
operator|!
name|ratio_p
condition|)
name|cost
operator|+=
name|multiply_by_cost
argument_list|(
name|ratio
argument_list|,
name|Pmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|s_offset
operator|&&
operator|!
name|offset_p
operator|&&
operator|!
name|symbol_present
condition|)
block|{
name|cost
operator|+=
name|add_cost
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|var_present
operator|=
name|true
expr_stmt|;
block|}
name|acost
operator|=
name|costs
index|[
name|symbol_present
index|]
index|[
name|var_present
index|]
index|[
name|offset_p
index|]
index|[
name|ratio_p
index|]
expr_stmt|;
return|return
name|cost
operator|+
name|acost
return|;
block|}
end_function

begin_comment
comment|/* Estimates cost of forcing expression EXPR into a variable.  */
end_comment

begin_function
name|unsigned
name|force_expr_to_var_cost
parameter_list|(
name|tree
name|expr
parameter_list|)
block|{
specifier|static
name|bool
name|costs_initialized
init|=
name|false
decl_stmt|;
specifier|static
name|unsigned
name|integer_cost
decl_stmt|;
specifier|static
name|unsigned
name|symbol_cost
decl_stmt|;
specifier|static
name|unsigned
name|address_cost
decl_stmt|;
name|tree
name|op0
decl_stmt|,
name|op1
decl_stmt|;
name|unsigned
name|cost0
decl_stmt|,
name|cost1
decl_stmt|,
name|cost
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
if|if
condition|(
operator|!
name|costs_initialized
condition|)
block|{
name|tree
name|var
init|=
name|create_tmp_var_raw
argument_list|(
name|integer_type_node
argument_list|,
literal|"test_var"
argument_list|)
decl_stmt|;
name|rtx
name|x
init|=
name|gen_rtx_MEM
argument_list|(
name|DECL_MODE
argument_list|(
name|var
argument_list|)
argument_list|,
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
literal|"test_var"
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|addr
decl_stmt|;
name|tree
name|type
init|=
name|build_pointer_type
argument_list|(
name|integer_type_node
argument_list|)
decl_stmt|;
name|integer_cost
operator|=
name|computation_cost
argument_list|(
name|build_int_cst
argument_list|(
name|integer_type_node
argument_list|,
literal|2000
argument_list|)
argument_list|)
expr_stmt|;
name|SET_DECL_RTL
argument_list|(
name|var
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|var
argument_list|)
operator|=
literal|1
expr_stmt|;
name|addr
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|type
argument_list|,
name|var
argument_list|)
expr_stmt|;
name|symbol_cost
operator|=
name|computation_cost
argument_list|(
name|addr
argument_list|)
operator|+
literal|1
expr_stmt|;
name|address_cost
operator|=
name|computation_cost
argument_list|(
name|build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|type
argument_list|,
name|addr
argument_list|,
name|build_int_cst
argument_list|(
name|type
argument_list|,
literal|2000
argument_list|)
argument_list|)
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"force_expr_to_var_cost:\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"  integer %d\n"
argument_list|,
operator|(
name|int
operator|)
name|integer_cost
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"  symbol %d\n"
argument_list|,
operator|(
name|int
operator|)
name|symbol_cost
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"  address %d\n"
argument_list|,
operator|(
name|int
operator|)
name|address_cost
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"  other %d\n"
argument_list|,
operator|(
name|int
operator|)
name|target_spill_cost
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|costs_initialized
operator|=
name|true
expr_stmt|;
block|}
name|STRIP_NOPS
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|SSA_VAR_P
argument_list|(
name|expr
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TREE_INVARIANT
argument_list|(
name|expr
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|INTEGER_CST
condition|)
return|return
name|integer_cost
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
block|{
name|tree
name|obj
init|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|obj
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|obj
argument_list|)
operator|==
name|PARM_DECL
operator|||
name|TREE_CODE
argument_list|(
name|obj
argument_list|)
operator|==
name|RESULT_DECL
condition|)
return|return
name|symbol_cost
return|;
block|}
return|return
name|address_cost
return|;
block|}
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
condition|)
block|{
case|case
name|PLUS_EXPR
case|:
case|case
name|MINUS_EXPR
case|:
case|case
name|MULT_EXPR
case|:
name|op0
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_gimple_val
argument_list|(
name|op0
argument_list|)
condition|)
name|cost0
operator|=
literal|0
expr_stmt|;
else|else
name|cost0
operator|=
name|force_expr_to_var_cost
argument_list|(
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_gimple_val
argument_list|(
name|op1
argument_list|)
condition|)
name|cost1
operator|=
literal|0
expr_stmt|;
else|else
name|cost1
operator|=
name|force_expr_to_var_cost
argument_list|(
name|op1
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Just an arbitrary value, FIXME.  */
return|return
name|target_spill_cost
return|;
block|}
name|mode
operator|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
condition|)
block|{
case|case
name|PLUS_EXPR
case|:
case|case
name|MINUS_EXPR
case|:
name|cost
operator|=
name|add_cost
argument_list|(
name|mode
argument_list|)
expr_stmt|;
break|break;
case|case
name|MULT_EXPR
case|:
if|if
condition|(
name|cst_and_fits_in_hwi
argument_list|(
name|op0
argument_list|)
condition|)
name|cost
operator|=
name|multiply_by_cost
argument_list|(
name|int_cst_value
argument_list|(
name|op0
argument_list|)
argument_list|,
name|mode
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cst_and_fits_in_hwi
argument_list|(
name|op1
argument_list|)
condition|)
name|cost
operator|=
name|multiply_by_cost
argument_list|(
name|int_cst_value
argument_list|(
name|op1
argument_list|)
argument_list|,
name|mode
argument_list|)
expr_stmt|;
else|else
return|return
name|target_spill_cost
return|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|cost
operator|+=
name|cost0
expr_stmt|;
name|cost
operator|+=
name|cost1
expr_stmt|;
comment|/* Bound the cost by target_spill_cost.  The parts of complicated      computations often are either loop invariant or at least can      be shared between several iv uses, so letting this grow without      limits would not give reasonable results.  */
return|return
name|cost
operator|<
name|target_spill_cost
condition|?
name|cost
else|:
name|target_spill_cost
return|;
block|}
end_function

begin_comment
comment|/* Estimates cost of forcing EXPR into a variable.  DEPENDS_ON is a set of the    invariants the computation depends on.  */
end_comment

begin_function
specifier|static
name|unsigned
name|force_var_cost
parameter_list|(
name|struct
name|ivopts_data
modifier|*
name|data
parameter_list|,
name|tree
name|expr
parameter_list|,
name|bitmap
modifier|*
name|depends_on
parameter_list|)
block|{
if|if
condition|(
name|depends_on
condition|)
block|{
name|fd_ivopts_data
operator|=
name|data
expr_stmt|;
name|walk_tree
argument_list|(
operator|&
name|expr
argument_list|,
name|find_depends
argument_list|,
name|depends_on
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
name|force_expr_to_var_cost
argument_list|(
name|expr
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Estimates cost of expressing address ADDR  as var + symbol + offset.  The    value of offset is added to OFFSET, SYMBOL_PRESENT and VAR_PRESENT are set    to false if the corresponding part is missing.  DEPENDS_ON is a set of the    invariants the computation depends on.  */
end_comment

begin_function
specifier|static
name|unsigned
name|split_address_cost
parameter_list|(
name|struct
name|ivopts_data
modifier|*
name|data
parameter_list|,
name|tree
name|addr
parameter_list|,
name|bool
modifier|*
name|symbol_present
parameter_list|,
name|bool
modifier|*
name|var_present
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
modifier|*
name|offset
parameter_list|,
name|bitmap
modifier|*
name|depends_on
parameter_list|)
block|{
name|tree
name|core
decl_stmt|;
name|HOST_WIDE_INT
name|bitsize
decl_stmt|;
name|HOST_WIDE_INT
name|bitpos
decl_stmt|;
name|tree
name|toffset
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|unsignedp
decl_stmt|,
name|volatilep
decl_stmt|;
name|core
operator|=
name|get_inner_reference
argument_list|(
name|addr
argument_list|,
operator|&
name|bitsize
argument_list|,
operator|&
name|bitpos
argument_list|,
operator|&
name|toffset
argument_list|,
operator|&
name|mode
argument_list|,
operator|&
name|unsignedp
argument_list|,
operator|&
name|volatilep
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|toffset
operator|!=
literal|0
operator|||
name|bitpos
operator|%
name|BITS_PER_UNIT
operator|!=
literal|0
operator|||
name|TREE_CODE
argument_list|(
name|core
argument_list|)
operator|!=
name|VAR_DECL
condition|)
block|{
operator|*
name|symbol_present
operator|=
name|false
expr_stmt|;
operator|*
name|var_present
operator|=
name|true
expr_stmt|;
name|fd_ivopts_data
operator|=
name|data
expr_stmt|;
name|walk_tree
argument_list|(
operator|&
name|addr
argument_list|,
name|find_depends
argument_list|,
name|depends_on
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|target_spill_cost
return|;
block|}
operator|*
name|offset
operator|+=
name|bitpos
operator|/
name|BITS_PER_UNIT
expr_stmt|;
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|core
argument_list|)
operator|||
name|DECL_EXTERNAL
argument_list|(
name|core
argument_list|)
condition|)
block|{
operator|*
name|symbol_present
operator|=
name|true
expr_stmt|;
operator|*
name|var_present
operator|=
name|false
expr_stmt|;
return|return
literal|0
return|;
block|}
operator|*
name|symbol_present
operator|=
name|false
expr_stmt|;
operator|*
name|var_present
operator|=
name|true
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Estimates cost of expressing difference of addresses E1 - E2 as    var + symbol + offset.  The value of offset is added to OFFSET,    SYMBOL_PRESENT and VAR_PRESENT are set to false if the corresponding    part is missing.  DEPENDS_ON is a set of the invariants the computation    depends on.  */
end_comment

begin_function
specifier|static
name|unsigned
name|ptr_difference_cost
parameter_list|(
name|struct
name|ivopts_data
modifier|*
name|data
parameter_list|,
name|tree
name|e1
parameter_list|,
name|tree
name|e2
parameter_list|,
name|bool
modifier|*
name|symbol_present
parameter_list|,
name|bool
modifier|*
name|var_present
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
modifier|*
name|offset
parameter_list|,
name|bitmap
modifier|*
name|depends_on
parameter_list|)
block|{
name|HOST_WIDE_INT
name|diff
init|=
literal|0
decl_stmt|;
name|unsigned
name|cost
decl_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|e1
argument_list|)
operator|==
name|ADDR_EXPR
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr_difference_const
argument_list|(
name|e1
argument_list|,
name|e2
argument_list|,
operator|&
name|diff
argument_list|)
condition|)
block|{
operator|*
name|offset
operator|+=
name|diff
expr_stmt|;
operator|*
name|symbol_present
operator|=
name|false
expr_stmt|;
operator|*
name|var_present
operator|=
name|false
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|e2
operator|==
name|integer_zero_node
condition|)
return|return
name|split_address_cost
argument_list|(
name|data
argument_list|,
name|TREE_OPERAND
argument_list|(
name|e1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|symbol_present
argument_list|,
name|var_present
argument_list|,
name|offset
argument_list|,
name|depends_on
argument_list|)
return|;
operator|*
name|symbol_present
operator|=
name|false
expr_stmt|;
operator|*
name|var_present
operator|=
name|true
expr_stmt|;
name|cost
operator|=
name|force_var_cost
argument_list|(
name|data
argument_list|,
name|e1
argument_list|,
name|depends_on
argument_list|)
expr_stmt|;
name|cost
operator|+=
name|force_var_cost
argument_list|(
name|data
argument_list|,
name|e2
argument_list|,
name|depends_on
argument_list|)
expr_stmt|;
name|cost
operator|+=
name|add_cost
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
return|return
name|cost
return|;
block|}
end_function

begin_comment
comment|/* Estimates cost of expressing difference E1 - E2 as    var + symbol + offset.  The value of offset is added to OFFSET,    SYMBOL_PRESENT and VAR_PRESENT are set to false if the corresponding    part is missing.  DEPENDS_ON is a set of the invariants the computation    depends on.  */
end_comment

begin_function
specifier|static
name|unsigned
name|difference_cost
parameter_list|(
name|struct
name|ivopts_data
modifier|*
name|data
parameter_list|,
name|tree
name|e1
parameter_list|,
name|tree
name|e2
parameter_list|,
name|bool
modifier|*
name|symbol_present
parameter_list|,
name|bool
modifier|*
name|var_present
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
modifier|*
name|offset
parameter_list|,
name|bitmap
modifier|*
name|depends_on
parameter_list|)
block|{
name|unsigned
name|cost
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|e1
argument_list|)
argument_list|)
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|off1
decl_stmt|,
name|off2
decl_stmt|;
name|e1
operator|=
name|strip_offset
argument_list|(
name|e1
argument_list|,
operator|&
name|off1
argument_list|)
expr_stmt|;
name|e2
operator|=
name|strip_offset
argument_list|(
name|e2
argument_list|,
operator|&
name|off2
argument_list|)
expr_stmt|;
operator|*
name|offset
operator|+=
name|off1
operator|-
name|off2
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|e1
argument_list|)
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|e2
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|e1
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
return|return
name|ptr_difference_cost
argument_list|(
name|data
argument_list|,
name|e1
argument_list|,
name|e2
argument_list|,
name|symbol_present
argument_list|,
name|var_present
argument_list|,
name|offset
argument_list|,
name|depends_on
argument_list|)
return|;
operator|*
name|symbol_present
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|operand_equal_p
argument_list|(
name|e1
argument_list|,
name|e2
argument_list|,
literal|0
argument_list|)
condition|)
block|{
operator|*
name|var_present
operator|=
name|false
expr_stmt|;
return|return
literal|0
return|;
block|}
operator|*
name|var_present
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|zero_p
argument_list|(
name|e2
argument_list|)
condition|)
return|return
name|force_var_cost
argument_list|(
name|data
argument_list|,
name|e1
argument_list|,
name|depends_on
argument_list|)
return|;
if|if
condition|(
name|zero_p
argument_list|(
name|e1
argument_list|)
condition|)
block|{
name|cost
operator|=
name|force_var_cost
argument_list|(
name|data
argument_list|,
name|e2
argument_list|,
name|depends_on
argument_list|)
expr_stmt|;
name|cost
operator|+=
name|multiply_by_cost
argument_list|(
operator|-
literal|1
argument_list|,
name|mode
argument_list|)
expr_stmt|;
return|return
name|cost
return|;
block|}
name|cost
operator|=
name|force_var_cost
argument_list|(
name|data
argument_list|,
name|e1
argument_list|,
name|depends_on
argument_list|)
expr_stmt|;
name|cost
operator|+=
name|force_var_cost
argument_list|(
name|data
argument_list|,
name|e2
argument_list|,
name|depends_on
argument_list|)
expr_stmt|;
name|cost
operator|+=
name|add_cost
argument_list|(
name|mode
argument_list|)
expr_stmt|;
return|return
name|cost
return|;
block|}
end_function

begin_comment
comment|/* Determines the cost of the computation by that USE is expressed    from induction variable CAND.  If ADDRESS_P is true, we just need    to create an address from it, otherwise we want to get it into    register.  A set of invariants we depend on is stored in    DEPENDS_ON.  AT is the statement at that the value is computed.  */
end_comment

begin_function
specifier|static
name|unsigned
name|get_computation_cost_at
parameter_list|(
name|struct
name|ivopts_data
modifier|*
name|data
parameter_list|,
name|struct
name|iv_use
modifier|*
name|use
parameter_list|,
name|struct
name|iv_cand
modifier|*
name|cand
parameter_list|,
name|bool
name|address_p
parameter_list|,
name|bitmap
modifier|*
name|depends_on
parameter_list|,
name|tree
name|at
parameter_list|)
block|{
name|tree
name|ubase
init|=
name|use
operator|->
name|iv
operator|->
name|base
decl_stmt|,
name|ustep
init|=
name|use
operator|->
name|iv
operator|->
name|step
decl_stmt|;
name|tree
name|cbase
decl_stmt|,
name|cstep
decl_stmt|;
name|tree
name|utype
init|=
name|TREE_TYPE
argument_list|(
name|ubase
argument_list|)
decl_stmt|,
name|ctype
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|ustepi
decl_stmt|,
name|cstepi
decl_stmt|,
name|offset
init|=
literal|0
decl_stmt|;
name|HOST_WIDE_INT
name|ratio
decl_stmt|,
name|aratio
decl_stmt|;
name|bool
name|var_present
decl_stmt|,
name|symbol_present
decl_stmt|;
name|unsigned
name|cost
init|=
literal|0
decl_stmt|,
name|n_sums
decl_stmt|;
operator|*
name|depends_on
operator|=
name|NULL
expr_stmt|;
comment|/* Only consider real candidates.  */
if|if
condition|(
operator|!
name|cand
operator|->
name|iv
condition|)
return|return
name|INFTY
return|;
name|cbase
operator|=
name|cand
operator|->
name|iv
operator|->
name|base
expr_stmt|;
name|cstep
operator|=
name|cand
operator|->
name|iv
operator|->
name|step
expr_stmt|;
name|ctype
operator|=
name|TREE_TYPE
argument_list|(
name|cbase
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|utype
argument_list|)
operator|>
name|TYPE_PRECISION
argument_list|(
name|ctype
argument_list|)
condition|)
block|{
comment|/* We do not have a precision to express the values of use.  */
return|return
name|INFTY
return|;
block|}
if|if
condition|(
name|address_p
condition|)
block|{
comment|/* Do not try to express address of an object with computation based 	 on address of a different object.  This may cause problems in rtl 	 level alias analysis (that does not expect this to be happening, 	 as this is illegal in C), and would be unlikely to be useful 	 anyway.  */
if|if
condition|(
name|use
operator|->
name|iv
operator|->
name|base_object
operator|&&
name|cand
operator|->
name|iv
operator|->
name|base_object
operator|&&
operator|!
name|operand_equal_p
argument_list|(
name|use
operator|->
name|iv
operator|->
name|base_object
argument_list|,
name|cand
operator|->
name|iv
operator|->
name|base_object
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|INFTY
return|;
block|}
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|utype
argument_list|)
operator|!=
name|TYPE_PRECISION
argument_list|(
name|ctype
argument_list|)
condition|)
block|{
comment|/* TODO -- add direct handling of this case.  */
goto|goto
name|fallback
goto|;
block|}
comment|/* CSTEPI is removed from the offset in case statement is after the      increment.  If the step is not constant, we use zero instead.      This is a bit imprecise (there is the extra addition), but      redundancy elimination is likely to transform the code so that      it uses value of the variable before increment anyway,      so it is not that much unrealistic.  */
if|if
condition|(
name|cst_and_fits_in_hwi
argument_list|(
name|cstep
argument_list|)
condition|)
name|cstepi
operator|=
name|int_cst_value
argument_list|(
name|cstep
argument_list|)
expr_stmt|;
else|else
name|cstepi
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cst_and_fits_in_hwi
argument_list|(
name|ustep
argument_list|)
operator|&&
name|cst_and_fits_in_hwi
argument_list|(
name|cstep
argument_list|)
condition|)
block|{
name|ustepi
operator|=
name|int_cst_value
argument_list|(
name|ustep
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|divide
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|utype
argument_list|)
argument_list|,
name|ustepi
argument_list|,
name|cstepi
argument_list|,
operator|&
name|ratio
argument_list|)
condition|)
return|return
name|INFTY
return|;
block|}
else|else
block|{
name|double_int
name|rat
decl_stmt|;
if|if
condition|(
operator|!
name|constant_multiple_of
argument_list|(
name|ustep
argument_list|,
name|cstep
argument_list|,
operator|&
name|rat
argument_list|)
condition|)
return|return
name|INFTY
return|;
if|if
condition|(
name|double_int_fits_in_shwi_p
argument_list|(
name|rat
argument_list|)
condition|)
name|ratio
operator|=
name|double_int_to_shwi
argument_list|(
name|rat
argument_list|)
expr_stmt|;
else|else
return|return
name|INFTY
return|;
block|}
comment|/* use = ubase + ratio * (var - cbase).  If either cbase is a constant      or ratio == 1, it is better to handle this like            ubase - ratio * cbase + ratio * var            (also holds in the case ratio == -1, TODO.  */
if|if
condition|(
name|cst_and_fits_in_hwi
argument_list|(
name|cbase
argument_list|)
condition|)
block|{
name|offset
operator|=
operator|-
name|ratio
operator|*
name|int_cst_value
argument_list|(
name|cbase
argument_list|)
expr_stmt|;
name|cost
operator|+=
name|difference_cost
argument_list|(
name|data
argument_list|,
name|ubase
argument_list|,
name|integer_zero_node
argument_list|,
operator|&
name|symbol_present
argument_list|,
operator|&
name|var_present
argument_list|,
operator|&
name|offset
argument_list|,
name|depends_on
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ratio
operator|==
literal|1
condition|)
block|{
name|cost
operator|+=
name|difference_cost
argument_list|(
name|data
argument_list|,
name|ubase
argument_list|,
name|cbase
argument_list|,
operator|&
name|symbol_present
argument_list|,
operator|&
name|var_present
argument_list|,
operator|&
name|offset
argument_list|,
name|depends_on
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cost
operator|+=
name|force_var_cost
argument_list|(
name|data
argument_list|,
name|cbase
argument_list|,
name|depends_on
argument_list|)
expr_stmt|;
name|cost
operator|+=
name|add_cost
argument_list|(
name|TYPE_MODE
argument_list|(
name|ctype
argument_list|)
argument_list|)
expr_stmt|;
name|cost
operator|+=
name|difference_cost
argument_list|(
name|data
argument_list|,
name|ubase
argument_list|,
name|integer_zero_node
argument_list|,
operator|&
name|symbol_present
argument_list|,
operator|&
name|var_present
argument_list|,
operator|&
name|offset
argument_list|,
name|depends_on
argument_list|)
expr_stmt|;
block|}
comment|/* If we are after the increment, the value of the candidate is higher by      one iteration.  */
if|if
condition|(
name|stmt_after_increment
argument_list|(
name|data
operator|->
name|current_loop
argument_list|,
name|cand
argument_list|,
name|at
argument_list|)
condition|)
name|offset
operator|-=
name|ratio
operator|*
name|cstepi
expr_stmt|;
comment|/* Now the computation is in shape symbol + var1 + const + ratio * var2.      (symbol/var/const parts may be omitted).  If we are looking for an address,      find the cost of addressing this.  */
if|if
condition|(
name|address_p
condition|)
return|return
name|cost
operator|+
name|get_address_cost
argument_list|(
name|symbol_present
argument_list|,
name|var_present
argument_list|,
name|offset
argument_list|,
name|ratio
argument_list|)
return|;
comment|/* Otherwise estimate the costs for computing the expression.  */
name|aratio
operator|=
name|ratio
operator|>
literal|0
condition|?
name|ratio
else|:
operator|-
name|ratio
expr_stmt|;
if|if
condition|(
operator|!
name|symbol_present
operator|&&
operator|!
name|var_present
operator|&&
operator|!
name|offset
condition|)
block|{
if|if
condition|(
name|ratio
operator|!=
literal|1
condition|)
name|cost
operator|+=
name|multiply_by_cost
argument_list|(
name|ratio
argument_list|,
name|TYPE_MODE
argument_list|(
name|ctype
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|cost
return|;
block|}
if|if
condition|(
name|aratio
operator|!=
literal|1
condition|)
name|cost
operator|+=
name|multiply_by_cost
argument_list|(
name|aratio
argument_list|,
name|TYPE_MODE
argument_list|(
name|ctype
argument_list|)
argument_list|)
expr_stmt|;
name|n_sums
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|var_present
comment|/* Symbol + offset should be compile-time computable.  */
operator|&&
operator|(
name|symbol_present
operator|||
name|offset
operator|)
condition|)
name|n_sums
operator|++
expr_stmt|;
return|return
name|cost
operator|+
name|n_sums
operator|*
name|add_cost
argument_list|(
name|TYPE_MODE
argument_list|(
name|ctype
argument_list|)
argument_list|)
return|;
name|fallback
label|:
block|{
comment|/* Just get the expression, expand it and measure the cost.  */
name|tree
name|comp
init|=
name|get_computation_at
argument_list|(
name|data
operator|->
name|current_loop
argument_list|,
name|use
argument_list|,
name|cand
argument_list|,
name|at
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|comp
condition|)
return|return
name|INFTY
return|;
if|if
condition|(
name|address_p
condition|)
name|comp
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|comp
argument_list|)
argument_list|)
argument_list|,
name|comp
argument_list|)
expr_stmt|;
return|return
name|computation_cost
argument_list|(
name|comp
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Determines the cost of the computation by that USE is expressed    from induction variable CAND.  If ADDRESS_P is true, we just need    to create an address from it, otherwise we want to get it into    register.  A set of invariants we depend on is stored in    DEPENDS_ON.  */
end_comment

begin_function
specifier|static
name|unsigned
name|get_computation_cost
parameter_list|(
name|struct
name|ivopts_data
modifier|*
name|data
parameter_list|,
name|struct
name|iv_use
modifier|*
name|use
parameter_list|,
name|struct
name|iv_cand
modifier|*
name|cand
parameter_list|,
name|bool
name|address_p
parameter_list|,
name|bitmap
modifier|*
name|depends_on
parameter_list|)
block|{
return|return
name|get_computation_cost_at
argument_list|(
name|data
argument_list|,
name|use
argument_list|,
name|cand
argument_list|,
name|address_p
argument_list|,
name|depends_on
argument_list|,
name|use
operator|->
name|stmt
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Determines cost of basing replacement of USE on CAND in a generic    expression.  */
end_comment

begin_function
specifier|static
name|bool
name|determine_use_iv_cost_generic
parameter_list|(
name|struct
name|ivopts_data
modifier|*
name|data
parameter_list|,
name|struct
name|iv_use
modifier|*
name|use
parameter_list|,
name|struct
name|iv_cand
modifier|*
name|cand
parameter_list|)
block|{
name|bitmap
name|depends_on
decl_stmt|;
name|unsigned
name|cost
decl_stmt|;
comment|/* The simple case first -- if we need to express value of the preserved      original biv, the cost is 0.  This also prevents us from counting the      cost of increment twice -- once at this use and once in the cost of      the candidate.  */
if|if
condition|(
name|cand
operator|->
name|pos
operator|==
name|IP_ORIGINAL
operator|&&
name|cand
operator|->
name|incremented_at
operator|==
name|use
operator|->
name|stmt
condition|)
block|{
name|set_use_iv_cost
argument_list|(
name|data
argument_list|,
name|use
argument_list|,
name|cand
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
name|cost
operator|=
name|get_computation_cost
argument_list|(
name|data
argument_list|,
name|use
argument_list|,
name|cand
argument_list|,
name|false
argument_list|,
operator|&
name|depends_on
argument_list|)
expr_stmt|;
name|set_use_iv_cost
argument_list|(
name|data
argument_list|,
name|use
argument_list|,
name|cand
argument_list|,
name|cost
argument_list|,
name|depends_on
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
return|return
name|cost
operator|!=
name|INFTY
return|;
block|}
end_function

begin_comment
comment|/* Determines cost of basing replacement of USE on CAND in an address.  */
end_comment

begin_function
specifier|static
name|bool
name|determine_use_iv_cost_address
parameter_list|(
name|struct
name|ivopts_data
modifier|*
name|data
parameter_list|,
name|struct
name|iv_use
modifier|*
name|use
parameter_list|,
name|struct
name|iv_cand
modifier|*
name|cand
parameter_list|)
block|{
name|bitmap
name|depends_on
decl_stmt|;
name|unsigned
name|cost
init|=
name|get_computation_cost
argument_list|(
name|data
argument_list|,
name|use
argument_list|,
name|cand
argument_list|,
name|true
argument_list|,
operator|&
name|depends_on
argument_list|)
decl_stmt|;
name|set_use_iv_cost
argument_list|(
name|data
argument_list|,
name|use
argument_list|,
name|cand
argument_list|,
name|cost
argument_list|,
name|depends_on
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
return|return
name|cost
operator|!=
name|INFTY
return|;
block|}
end_function

begin_comment
comment|/* Computes value of induction variable IV in iteration NITER.  */
end_comment

begin_function
specifier|static
name|tree
name|iv_value
parameter_list|(
name|struct
name|iv
modifier|*
name|iv
parameter_list|,
name|tree
name|niter
parameter_list|)
block|{
name|tree
name|val
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|iv
operator|->
name|base
argument_list|)
decl_stmt|;
name|niter
operator|=
name|fold_convert
argument_list|(
name|type
argument_list|,
name|niter
argument_list|)
expr_stmt|;
name|val
operator|=
name|fold_build2
argument_list|(
name|MULT_EXPR
argument_list|,
name|type
argument_list|,
name|iv
operator|->
name|step
argument_list|,
name|niter
argument_list|)
expr_stmt|;
return|return
name|fold_build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|type
argument_list|,
name|iv
operator|->
name|base
argument_list|,
name|val
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Computes value of candidate CAND at position AT in iteration NITER.  */
end_comment

begin_function
specifier|static
name|tree
name|cand_value_at
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|struct
name|iv_cand
modifier|*
name|cand
parameter_list|,
name|tree
name|at
parameter_list|,
name|tree
name|niter
parameter_list|)
block|{
name|tree
name|val
init|=
name|iv_value
argument_list|(
name|cand
operator|->
name|iv
argument_list|,
name|niter
argument_list|)
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|cand
operator|->
name|iv
operator|->
name|base
argument_list|)
decl_stmt|;
if|if
condition|(
name|stmt_after_increment
argument_list|(
name|loop
argument_list|,
name|cand
argument_list|,
name|at
argument_list|)
condition|)
name|val
operator|=
name|fold_build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|type
argument_list|,
name|val
argument_list|,
name|cand
operator|->
name|iv
operator|->
name|step
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/* Returns period of induction variable iv.  */
end_comment

begin_function
specifier|static
name|tree
name|iv_period
parameter_list|(
name|struct
name|iv
modifier|*
name|iv
parameter_list|)
block|{
name|tree
name|step
init|=
name|iv
operator|->
name|step
decl_stmt|,
name|period
decl_stmt|,
name|type
decl_stmt|;
name|tree
name|pow2div
decl_stmt|;
name|gcc_assert
argument_list|(
name|step
operator|&&
name|TREE_CODE
argument_list|(
name|step
argument_list|)
operator|==
name|INTEGER_CST
argument_list|)
expr_stmt|;
comment|/* Period of the iv is gcd (step, type range).  Since type range is power      of two, it suffices to determine the maximum power of two that divides      step.  */
name|pow2div
operator|=
name|num_ending_zeros
argument_list|(
name|step
argument_list|)
expr_stmt|;
name|type
operator|=
name|unsigned_type_for
argument_list|(
name|TREE_TYPE
argument_list|(
name|step
argument_list|)
argument_list|)
expr_stmt|;
name|period
operator|=
name|build_low_bits_mask
argument_list|(
name|type
argument_list|,
operator|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|-
name|tree_low_cst
argument_list|(
name|pow2div
argument_list|,
literal|1
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
name|period
return|;
block|}
end_function

begin_comment
comment|/* Returns the comparison operator used when eliminating the iv USE.  */
end_comment

begin_function
specifier|static
name|enum
name|tree_code
name|iv_elimination_compare
parameter_list|(
name|struct
name|ivopts_data
modifier|*
name|data
parameter_list|,
name|struct
name|iv_use
modifier|*
name|use
parameter_list|)
block|{
name|struct
name|loop
modifier|*
name|loop
init|=
name|data
operator|->
name|current_loop
decl_stmt|;
name|basic_block
name|ex_bb
decl_stmt|;
name|edge
name|exit
decl_stmt|;
name|ex_bb
operator|=
name|bb_for_stmt
argument_list|(
name|use
operator|->
name|stmt
argument_list|)
expr_stmt|;
name|exit
operator|=
name|EDGE_SUCC
argument_list|(
name|ex_bb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|flow_bb_inside_loop_p
argument_list|(
name|loop
argument_list|,
name|exit
operator|->
name|dest
argument_list|)
condition|)
name|exit
operator|=
name|EDGE_SUCC
argument_list|(
name|ex_bb
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|exit
operator|->
name|flags
operator|&
name|EDGE_TRUE_VALUE
condition|?
name|EQ_EXPR
else|:
name|NE_EXPR
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Check whether it is possible to express the condition in USE by comparison    of candidate CAND.  If so, store the value compared with to BOUND.  */
end_comment

begin_function
specifier|static
name|bool
name|may_eliminate_iv
parameter_list|(
name|struct
name|ivopts_data
modifier|*
name|data
parameter_list|,
name|struct
name|iv_use
modifier|*
name|use
parameter_list|,
name|struct
name|iv_cand
modifier|*
name|cand
parameter_list|,
name|tree
modifier|*
name|bound
parameter_list|)
block|{
name|basic_block
name|ex_bb
decl_stmt|;
name|edge
name|exit
decl_stmt|;
name|tree
name|nit
decl_stmt|,
name|nit_type
decl_stmt|;
name|tree
name|wider_type
decl_stmt|,
name|period
decl_stmt|,
name|per_type
decl_stmt|;
name|struct
name|loop
modifier|*
name|loop
init|=
name|data
operator|->
name|current_loop
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|cand
operator|->
name|iv
operator|->
name|step
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
return|return
name|false
return|;
comment|/* For now works only for exits that dominate the loop latch.  TODO -- extend      for other conditions inside loop body.  */
name|ex_bb
operator|=
name|bb_for_stmt
argument_list|(
name|use
operator|->
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|use
operator|->
name|stmt
operator|!=
name|last_stmt
argument_list|(
name|ex_bb
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|use
operator|->
name|stmt
argument_list|)
operator|!=
name|COND_EXPR
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|dominated_by_p
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|loop
operator|->
name|latch
argument_list|,
name|ex_bb
argument_list|)
condition|)
return|return
name|false
return|;
name|exit
operator|=
name|EDGE_SUCC
argument_list|(
name|ex_bb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|flow_bb_inside_loop_p
argument_list|(
name|loop
argument_list|,
name|exit
operator|->
name|dest
argument_list|)
condition|)
name|exit
operator|=
name|EDGE_SUCC
argument_list|(
name|ex_bb
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|flow_bb_inside_loop_p
argument_list|(
name|loop
argument_list|,
name|exit
operator|->
name|dest
argument_list|)
condition|)
return|return
name|false
return|;
name|nit
operator|=
name|niter_for_exit
argument_list|(
name|data
argument_list|,
name|exit
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nit
condition|)
return|return
name|false
return|;
name|nit_type
operator|=
name|TREE_TYPE
argument_list|(
name|nit
argument_list|)
expr_stmt|;
comment|/* Determine whether we may use the variable to test whether niter iterations      elapsed.  This is the case iff the period of the induction variable is      greater than the number of iterations.  */
name|period
operator|=
name|iv_period
argument_list|(
name|cand
operator|->
name|iv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|period
condition|)
return|return
name|false
return|;
name|per_type
operator|=
name|TREE_TYPE
argument_list|(
name|period
argument_list|)
expr_stmt|;
name|wider_type
operator|=
name|TREE_TYPE
argument_list|(
name|period
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|nit_type
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|per_type
argument_list|)
condition|)
name|wider_type
operator|=
name|per_type
expr_stmt|;
else|else
name|wider_type
operator|=
name|nit_type
expr_stmt|;
if|if
condition|(
operator|!
name|integer_nonzerop
argument_list|(
name|fold_build2
argument_list|(
name|GE_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|fold_convert
argument_list|(
name|wider_type
argument_list|,
name|period
argument_list|)
argument_list|,
name|fold_convert
argument_list|(
name|wider_type
argument_list|,
name|nit
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
operator|*
name|bound
operator|=
name|fold_affine_expr
argument_list|(
name|cand_value_at
argument_list|(
name|loop
argument_list|,
name|cand
argument_list|,
name|use
operator|->
name|stmt
argument_list|,
name|nit
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Determines cost of basing replacement of USE on CAND in a condition.  */
end_comment

begin_function
specifier|static
name|bool
name|determine_use_iv_cost_condition
parameter_list|(
name|struct
name|ivopts_data
modifier|*
name|data
parameter_list|,
name|struct
name|iv_use
modifier|*
name|use
parameter_list|,
name|struct
name|iv_cand
modifier|*
name|cand
parameter_list|)
block|{
name|tree
name|bound
init|=
name|NULL_TREE
decl_stmt|,
name|op
decl_stmt|,
name|cond
decl_stmt|;
name|bitmap
name|depends_on
init|=
name|NULL
decl_stmt|;
name|unsigned
name|cost
decl_stmt|;
comment|/* Only consider real candidates.  */
if|if
condition|(
operator|!
name|cand
operator|->
name|iv
condition|)
block|{
name|set_use_iv_cost
argument_list|(
name|data
argument_list|,
name|use
argument_list|,
name|cand
argument_list|,
name|INFTY
argument_list|,
name|NULL
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|may_eliminate_iv
argument_list|(
name|data
argument_list|,
name|use
argument_list|,
name|cand
argument_list|,
operator|&
name|bound
argument_list|)
condition|)
block|{
name|cost
operator|=
name|force_var_cost
argument_list|(
name|data
argument_list|,
name|bound
argument_list|,
operator|&
name|depends_on
argument_list|)
expr_stmt|;
name|set_use_iv_cost
argument_list|(
name|data
argument_list|,
name|use
argument_list|,
name|cand
argument_list|,
name|cost
argument_list|,
name|depends_on
argument_list|,
name|bound
argument_list|)
expr_stmt|;
return|return
name|cost
operator|!=
name|INFTY
return|;
block|}
comment|/* The induction variable elimination failed; just express the original      giv.  If it is compared with an invariant, note that we cannot get      rid of it.  */
name|cost
operator|=
name|get_computation_cost
argument_list|(
name|data
argument_list|,
name|use
argument_list|,
name|cand
argument_list|,
name|false
argument_list|,
operator|&
name|depends_on
argument_list|)
expr_stmt|;
name|cond
operator|=
operator|*
name|use
operator|->
name|op_p
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|cond
argument_list|)
operator|!=
name|SSA_NAME
condition|)
block|{
name|op
operator|=
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SSA_NAME
operator|&&
operator|!
name|zero_p
argument_list|(
name|get_iv
argument_list|(
name|data
argument_list|,
name|op
argument_list|)
operator|->
name|step
argument_list|)
condition|)
name|op
operator|=
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SSA_NAME
condition|)
block|{
name|op
operator|=
name|get_iv
argument_list|(
name|data
argument_list|,
name|op
argument_list|)
operator|->
name|base
expr_stmt|;
name|fd_ivopts_data
operator|=
name|data
expr_stmt|;
name|walk_tree
argument_list|(
operator|&
name|op
argument_list|,
name|find_depends
argument_list|,
operator|&
name|depends_on
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
name|set_use_iv_cost
argument_list|(
name|data
argument_list|,
name|use
argument_list|,
name|cand
argument_list|,
name|cost
argument_list|,
name|depends_on
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|cost
operator|!=
name|INFTY
return|;
block|}
end_function

begin_comment
comment|/* Determines cost of basing replacement of USE on CAND.  Returns false    if USE cannot be based on CAND.  */
end_comment

begin_function
specifier|static
name|bool
name|determine_use_iv_cost
parameter_list|(
name|struct
name|ivopts_data
modifier|*
name|data
parameter_list|,
name|struct
name|iv_use
modifier|*
name|use
parameter_list|,
name|struct
name|iv_cand
modifier|*
name|cand
parameter_list|)
block|{
switch|switch
condition|(
name|use
operator|->
name|type
condition|)
block|{
case|case
name|USE_NONLINEAR_EXPR
case|:
return|return
name|determine_use_iv_cost_generic
argument_list|(
name|data
argument_list|,
name|use
argument_list|,
name|cand
argument_list|)
return|;
case|case
name|USE_ADDRESS
case|:
return|return
name|determine_use_iv_cost_address
argument_list|(
name|data
argument_list|,
name|use
argument_list|,
name|cand
argument_list|)
return|;
case|case
name|USE_COMPARE
case|:
return|return
name|determine_use_iv_cost_condition
argument_list|(
name|data
argument_list|,
name|use
argument_list|,
name|cand
argument_list|)
return|;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Determines costs of basing the use of the iv on an iv candidate.  */
end_comment

begin_function
specifier|static
name|void
name|determine_use_iv_costs
parameter_list|(
name|struct
name|ivopts_data
modifier|*
name|data
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|,
name|j
decl_stmt|;
name|struct
name|iv_use
modifier|*
name|use
decl_stmt|;
name|struct
name|iv_cand
modifier|*
name|cand
decl_stmt|;
name|bitmap
name|to_clear
init|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
name|alloc_use_cost_map
argument_list|(
name|data
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_iv_uses
argument_list|(
name|data
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|use
operator|=
name|iv_use
argument_list|(
name|data
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|consider_all_candidates
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n_iv_cands
argument_list|(
name|data
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
name|cand
operator|=
name|iv_cand
argument_list|(
name|data
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|determine_use_iv_cost
argument_list|(
name|data
argument_list|,
name|use
argument_list|,
name|cand
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|bitmap_iterator
name|bi
decl_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|use->related_cands
argument_list|,
literal|0
argument_list|,
argument|j
argument_list|,
argument|bi
argument_list|)
block|{
name|cand
operator|=
name|iv_cand
argument_list|(
name|data
argument_list|,
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|determine_use_iv_cost
argument_list|(
name|data
argument_list|,
name|use
argument_list|,
name|cand
argument_list|)
condition|)
name|bitmap_set_bit
argument_list|(
name|to_clear
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
comment|/* Remove the candidates for that the cost is infinite from 	     the list of related candidates.  */
name|bitmap_and_compl_into
argument_list|(
name|use
operator|->
name|related_cands
argument_list|,
name|to_clear
argument_list|)
expr_stmt|;
name|bitmap_clear
argument_list|(
name|to_clear
argument_list|)
expr_stmt|;
block|}
block|}
name|BITMAP_FREE
argument_list|(
name|to_clear
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Use-candidate costs:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_iv_uses
argument_list|(
name|data
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|use
operator|=
name|iv_use
argument_list|(
name|data
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Use %d:\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"  cand\tcost\tdepends on\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|use
operator|->
name|n_map_members
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|use
operator|->
name|cost_map
index|[
name|j
index|]
operator|.
name|cand
operator|||
name|use
operator|->
name|cost_map
index|[
name|j
index|]
operator|.
name|cost
operator|==
name|INFTY
condition|)
continue|continue;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"  %d\t%d\t"
argument_list|,
name|use
operator|->
name|cost_map
index|[
name|j
index|]
operator|.
name|cand
operator|->
name|id
argument_list|,
name|use
operator|->
name|cost_map
index|[
name|j
index|]
operator|.
name|cost
argument_list|)
expr_stmt|;
if|if
condition|(
name|use
operator|->
name|cost_map
index|[
name|j
index|]
operator|.
name|depends_on
condition|)
name|bitmap_print
argument_list|(
name|dump_file
argument_list|,
name|use
operator|->
name|cost_map
index|[
name|j
index|]
operator|.
name|depends_on
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Determines cost of the candidate CAND.  */
end_comment

begin_function
specifier|static
name|void
name|determine_iv_cost
parameter_list|(
name|struct
name|ivopts_data
modifier|*
name|data
parameter_list|,
name|struct
name|iv_cand
modifier|*
name|cand
parameter_list|)
block|{
name|unsigned
name|cost_base
decl_stmt|,
name|cost_step
decl_stmt|;
name|tree
name|base
decl_stmt|;
if|if
condition|(
operator|!
name|cand
operator|->
name|iv
condition|)
block|{
name|cand
operator|->
name|cost
operator|=
literal|0
expr_stmt|;
return|return;
block|}
comment|/* There are two costs associated with the candidate -- its increment      and its initialization.  The second is almost negligible for any loop      that rolls enough, so we take it just very little into account.  */
name|base
operator|=
name|cand
operator|->
name|iv
operator|->
name|base
expr_stmt|;
name|cost_base
operator|=
name|force_var_cost
argument_list|(
name|data
argument_list|,
name|base
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cost_step
operator|=
name|add_cost
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|base
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|cand
operator|->
name|cost
operator|=
name|cost_step
operator|+
name|cost_base
operator|/
name|AVG_LOOP_NITER
argument_list|(
name|current_loop
argument_list|)
expr_stmt|;
comment|/* Prefer the original iv unless we may gain something by replacing it;      this is not really relevant for artificial ivs created by other      passes.  */
if|if
condition|(
name|cand
operator|->
name|pos
operator|==
name|IP_ORIGINAL
operator|&&
operator|!
name|DECL_ARTIFICIAL
argument_list|(
name|SSA_NAME_VAR
argument_list|(
name|cand
operator|->
name|var_before
argument_list|)
argument_list|)
condition|)
name|cand
operator|->
name|cost
operator|--
expr_stmt|;
comment|/* Prefer not to insert statements into latch unless there are some      already (so that we do not create unnecessary jumps).  */
if|if
condition|(
name|cand
operator|->
name|pos
operator|==
name|IP_END
operator|&&
name|empty_block_p
argument_list|(
name|ip_end_pos
argument_list|(
name|data
operator|->
name|current_loop
argument_list|)
argument_list|)
condition|)
name|cand
operator|->
name|cost
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Determines costs of computation of the candidates.  */
end_comment

begin_function
specifier|static
name|void
name|determine_iv_costs
parameter_list|(
name|struct
name|ivopts_data
modifier|*
name|data
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Candidate costs:\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"  cand\tcost\n"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_iv_cands
argument_list|(
name|data
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|iv_cand
modifier|*
name|cand
init|=
name|iv_cand
argument_list|(
name|data
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|determine_iv_cost
argument_list|(
name|data
argument_list|,
name|cand
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"  %d\t%d\n"
argument_list|,
name|i
argument_list|,
name|cand
operator|->
name|cost
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Calculates cost for having SIZE induction variables.  */
end_comment

begin_function
specifier|static
name|unsigned
name|ivopts_global_cost_for_size
parameter_list|(
name|struct
name|ivopts_data
modifier|*
name|data
parameter_list|,
name|unsigned
name|size
parameter_list|)
block|{
return|return
name|global_cost_for_size
argument_list|(
name|size
argument_list|,
name|data
operator|->
name|regs_used
argument_list|,
name|n_iv_uses
argument_list|(
name|data
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* For each size of the induction variable set determine the penalty.  */
end_comment

begin_function
specifier|static
name|void
name|determine_set_costs
parameter_list|(
name|struct
name|ivopts_data
modifier|*
name|data
parameter_list|)
block|{
name|unsigned
name|j
decl_stmt|,
name|n
decl_stmt|;
name|tree
name|phi
decl_stmt|,
name|op
decl_stmt|;
name|struct
name|loop
modifier|*
name|loop
init|=
name|data
operator|->
name|current_loop
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
comment|/* We use the following model (definitely improvable, especially the      cost function -- TODO):       We estimate the number of registers available (using MD data), name it A.       We estimate the number of registers used by the loop, name it U.  This      number is obtained as the number of loop phi nodes (not counting virtual      registers and bivs) + the number of variables from outside of the loop.       We set a reserve R (free regs that are used for temporary computations,      etc.).  For now the reserve is a constant 3.       Let I be the number of induction variables.            -- if U + I + R<= A, the cost is I * SMALL_COST (just not to encourage 	make a lot of ivs without a reason).      -- if A - R< U + I<= A, the cost is I * PRES_COST      -- if U + I> A, the cost is I * PRES_COST and         number of uses * SPILL_COST * (U + I - A) / (U + I) is added.  */
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Global costs:\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"  target_avail_regs %d\n"
argument_list|,
name|target_avail_regs
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"  target_small_cost %d\n"
argument_list|,
name|target_small_cost
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"  target_pres_cost %d\n"
argument_list|,
name|target_pres_cost
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"  target_spill_cost %d\n"
argument_list|,
name|target_spill_cost
argument_list|)
expr_stmt|;
block|}
name|n
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|phi
operator|=
name|phi_nodes
argument_list|(
name|loop
operator|->
name|header
argument_list|)
init|;
name|phi
condition|;
name|phi
operator|=
name|PHI_CHAIN
argument_list|(
name|phi
argument_list|)
control|)
block|{
name|op
operator|=
name|PHI_RESULT
argument_list|(
name|phi
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_gimple_reg
argument_list|(
name|op
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|get_iv
argument_list|(
name|data
argument_list|,
name|op
argument_list|)
condition|)
continue|continue;
name|n
operator|++
expr_stmt|;
block|}
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|data->relevant
argument_list|,
literal|0
argument_list|,
argument|j
argument_list|,
argument|bi
argument_list|)
block|{
name|struct
name|version_info
modifier|*
name|info
init|=
name|ver_info
argument_list|(
name|data
argument_list|,
name|j
argument_list|)
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|inv_id
operator|&&
name|info
operator|->
name|has_nonlin_use
condition|)
name|n
operator|++
expr_stmt|;
block|}
name|data
operator|->
name|regs_used
operator|=
name|n
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"  regs_used %d\n"
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"  cost for size:\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"  ivs\tcost\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
literal|2
operator|*
name|target_avail_regs
condition|;
name|j
operator|++
control|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"  %d\t%d\n"
argument_list|,
name|j
argument_list|,
name|ivopts_global_cost_for_size
argument_list|(
name|data
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Returns true if A is a cheaper cost pair than B.  */
end_comment

begin_function
specifier|static
name|bool
name|cheaper_cost_pair
parameter_list|(
name|struct
name|cost_pair
modifier|*
name|a
parameter_list|,
name|struct
name|cost_pair
modifier|*
name|b
parameter_list|)
block|{
if|if
condition|(
operator|!
name|a
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|b
condition|)
return|return
name|true
return|;
if|if
condition|(
name|a
operator|->
name|cost
operator|<
name|b
operator|->
name|cost
condition|)
return|return
name|true
return|;
if|if
condition|(
name|a
operator|->
name|cost
operator|>
name|b
operator|->
name|cost
condition|)
return|return
name|false
return|;
comment|/* In case the costs are the same, prefer the cheaper candidate.  */
if|if
condition|(
name|a
operator|->
name|cand
operator|->
name|cost
operator|<
name|b
operator|->
name|cand
operator|->
name|cost
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Computes the cost field of IVS structure.  */
end_comment

begin_function
specifier|static
name|void
name|iv_ca_recount_cost
parameter_list|(
name|struct
name|ivopts_data
modifier|*
name|data
parameter_list|,
name|struct
name|iv_ca
modifier|*
name|ivs
parameter_list|)
block|{
name|unsigned
name|cost
init|=
literal|0
decl_stmt|;
name|cost
operator|+=
name|ivs
operator|->
name|cand_use_cost
expr_stmt|;
name|cost
operator|+=
name|ivs
operator|->
name|cand_cost
expr_stmt|;
name|cost
operator|+=
name|ivopts_global_cost_for_size
argument_list|(
name|data
argument_list|,
name|ivs
operator|->
name|n_regs
argument_list|)
expr_stmt|;
name|ivs
operator|->
name|cost
operator|=
name|cost
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Remove invariants in set INVS to set IVS.  */
end_comment

begin_function
specifier|static
name|void
name|iv_ca_set_remove_invariants
parameter_list|(
name|struct
name|iv_ca
modifier|*
name|ivs
parameter_list|,
name|bitmap
name|invs
parameter_list|)
block|{
name|bitmap_iterator
name|bi
decl_stmt|;
name|unsigned
name|iid
decl_stmt|;
if|if
condition|(
operator|!
name|invs
condition|)
return|return;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|invs
argument_list|,
literal|0
argument_list|,
argument|iid
argument_list|,
argument|bi
argument_list|)
block|{
name|ivs
operator|->
name|n_invariant_uses
index|[
name|iid
index|]
operator|--
expr_stmt|;
if|if
condition|(
name|ivs
operator|->
name|n_invariant_uses
index|[
name|iid
index|]
operator|==
literal|0
condition|)
name|ivs
operator|->
name|n_regs
operator|--
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Set USE not to be expressed by any candidate in IVS.  */
end_comment

begin_function
specifier|static
name|void
name|iv_ca_set_no_cp
parameter_list|(
name|struct
name|ivopts_data
modifier|*
name|data
parameter_list|,
name|struct
name|iv_ca
modifier|*
name|ivs
parameter_list|,
name|struct
name|iv_use
modifier|*
name|use
parameter_list|)
block|{
name|unsigned
name|uid
init|=
name|use
operator|->
name|id
decl_stmt|,
name|cid
decl_stmt|;
name|struct
name|cost_pair
modifier|*
name|cp
decl_stmt|;
name|cp
operator|=
name|ivs
operator|->
name|cand_for_use
index|[
name|uid
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|cp
condition|)
return|return;
name|cid
operator|=
name|cp
operator|->
name|cand
operator|->
name|id
expr_stmt|;
name|ivs
operator|->
name|bad_uses
operator|++
expr_stmt|;
name|ivs
operator|->
name|cand_for_use
index|[
name|uid
index|]
operator|=
name|NULL
expr_stmt|;
name|ivs
operator|->
name|n_cand_uses
index|[
name|cid
index|]
operator|--
expr_stmt|;
if|if
condition|(
name|ivs
operator|->
name|n_cand_uses
index|[
name|cid
index|]
operator|==
literal|0
condition|)
block|{
name|bitmap_clear_bit
argument_list|(
name|ivs
operator|->
name|cands
argument_list|,
name|cid
argument_list|)
expr_stmt|;
comment|/* Do not count the pseudocandidates.  */
if|if
condition|(
name|cp
operator|->
name|cand
operator|->
name|iv
condition|)
name|ivs
operator|->
name|n_regs
operator|--
expr_stmt|;
name|ivs
operator|->
name|n_cands
operator|--
expr_stmt|;
name|ivs
operator|->
name|cand_cost
operator|-=
name|cp
operator|->
name|cand
operator|->
name|cost
expr_stmt|;
name|iv_ca_set_remove_invariants
argument_list|(
name|ivs
argument_list|,
name|cp
operator|->
name|cand
operator|->
name|depends_on
argument_list|)
expr_stmt|;
block|}
name|ivs
operator|->
name|cand_use_cost
operator|-=
name|cp
operator|->
name|cost
expr_stmt|;
name|iv_ca_set_remove_invariants
argument_list|(
name|ivs
argument_list|,
name|cp
operator|->
name|depends_on
argument_list|)
expr_stmt|;
name|iv_ca_recount_cost
argument_list|(
name|data
argument_list|,
name|ivs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add invariants in set INVS to set IVS.  */
end_comment

begin_function
specifier|static
name|void
name|iv_ca_set_add_invariants
parameter_list|(
name|struct
name|iv_ca
modifier|*
name|ivs
parameter_list|,
name|bitmap
name|invs
parameter_list|)
block|{
name|bitmap_iterator
name|bi
decl_stmt|;
name|unsigned
name|iid
decl_stmt|;
if|if
condition|(
operator|!
name|invs
condition|)
return|return;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|invs
argument_list|,
literal|0
argument_list|,
argument|iid
argument_list|,
argument|bi
argument_list|)
block|{
name|ivs
operator|->
name|n_invariant_uses
index|[
name|iid
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|ivs
operator|->
name|n_invariant_uses
index|[
name|iid
index|]
operator|==
literal|1
condition|)
name|ivs
operator|->
name|n_regs
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Set cost pair for USE in set IVS to CP.  */
end_comment

begin_function
specifier|static
name|void
name|iv_ca_set_cp
parameter_list|(
name|struct
name|ivopts_data
modifier|*
name|data
parameter_list|,
name|struct
name|iv_ca
modifier|*
name|ivs
parameter_list|,
name|struct
name|iv_use
modifier|*
name|use
parameter_list|,
name|struct
name|cost_pair
modifier|*
name|cp
parameter_list|)
block|{
name|unsigned
name|uid
init|=
name|use
operator|->
name|id
decl_stmt|,
name|cid
decl_stmt|;
if|if
condition|(
name|ivs
operator|->
name|cand_for_use
index|[
name|uid
index|]
operator|==
name|cp
condition|)
return|return;
if|if
condition|(
name|ivs
operator|->
name|cand_for_use
index|[
name|uid
index|]
condition|)
name|iv_ca_set_no_cp
argument_list|(
name|data
argument_list|,
name|ivs
argument_list|,
name|use
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
condition|)
block|{
name|cid
operator|=
name|cp
operator|->
name|cand
operator|->
name|id
expr_stmt|;
name|ivs
operator|->
name|bad_uses
operator|--
expr_stmt|;
name|ivs
operator|->
name|cand_for_use
index|[
name|uid
index|]
operator|=
name|cp
expr_stmt|;
name|ivs
operator|->
name|n_cand_uses
index|[
name|cid
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|ivs
operator|->
name|n_cand_uses
index|[
name|cid
index|]
operator|==
literal|1
condition|)
block|{
name|bitmap_set_bit
argument_list|(
name|ivs
operator|->
name|cands
argument_list|,
name|cid
argument_list|)
expr_stmt|;
comment|/* Do not count the pseudocandidates.  */
if|if
condition|(
name|cp
operator|->
name|cand
operator|->
name|iv
condition|)
name|ivs
operator|->
name|n_regs
operator|++
expr_stmt|;
name|ivs
operator|->
name|n_cands
operator|++
expr_stmt|;
name|ivs
operator|->
name|cand_cost
operator|+=
name|cp
operator|->
name|cand
operator|->
name|cost
expr_stmt|;
name|iv_ca_set_add_invariants
argument_list|(
name|ivs
argument_list|,
name|cp
operator|->
name|cand
operator|->
name|depends_on
argument_list|)
expr_stmt|;
block|}
name|ivs
operator|->
name|cand_use_cost
operator|+=
name|cp
operator|->
name|cost
expr_stmt|;
name|iv_ca_set_add_invariants
argument_list|(
name|ivs
argument_list|,
name|cp
operator|->
name|depends_on
argument_list|)
expr_stmt|;
name|iv_ca_recount_cost
argument_list|(
name|data
argument_list|,
name|ivs
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Extend set IVS by expressing USE by some of the candidates in it    if possible.  */
end_comment

begin_function
specifier|static
name|void
name|iv_ca_add_use
parameter_list|(
name|struct
name|ivopts_data
modifier|*
name|data
parameter_list|,
name|struct
name|iv_ca
modifier|*
name|ivs
parameter_list|,
name|struct
name|iv_use
modifier|*
name|use
parameter_list|)
block|{
name|struct
name|cost_pair
modifier|*
name|best_cp
init|=
name|NULL
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|gcc_assert
argument_list|(
name|ivs
operator|->
name|upto
operator|>=
name|use
operator|->
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|ivs
operator|->
name|upto
operator|==
name|use
operator|->
name|id
condition|)
block|{
name|ivs
operator|->
name|upto
operator|++
expr_stmt|;
name|ivs
operator|->
name|bad_uses
operator|++
expr_stmt|;
block|}
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|ivs->cands
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|bi
argument_list|)
block|{
name|cp
operator|=
name|get_use_iv_cost
argument_list|(
name|data
argument_list|,
name|use
argument_list|,
name|iv_cand
argument_list|(
name|data
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cheaper_cost_pair
argument_list|(
name|cp
argument_list|,
name|best_cp
argument_list|)
condition|)
name|best_cp
operator|=
name|cp
expr_stmt|;
block|}
name|iv_ca_set_cp
argument_list|(
name|data
argument_list|,
name|ivs
argument_list|,
name|use
argument_list|,
name|best_cp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get cost for assignment IVS.  */
end_comment

begin_function
specifier|static
name|unsigned
name|iv_ca_cost
parameter_list|(
name|struct
name|iv_ca
modifier|*
name|ivs
parameter_list|)
block|{
return|return
operator|(
name|ivs
operator|->
name|bad_uses
condition|?
name|INFTY
else|:
name|ivs
operator|->
name|cost
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Returns true if all dependences of CP are among invariants in IVS.  */
end_comment

begin_function
specifier|static
name|bool
name|iv_ca_has_deps
parameter_list|(
name|struct
name|iv_ca
modifier|*
name|ivs
parameter_list|,
name|struct
name|cost_pair
modifier|*
name|cp
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
if|if
condition|(
operator|!
name|cp
operator|->
name|depends_on
condition|)
return|return
name|true
return|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|cp->depends_on
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|bi
argument_list|)
block|{
if|if
condition|(
name|ivs
operator|->
name|n_invariant_uses
index|[
name|i
index|]
operator|==
literal|0
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Creates change of expressing USE by NEW_CP instead of OLD_CP and chains    it before NEXT_CHANGE.  */
end_comment

begin_function
specifier|static
name|struct
name|iv_ca_delta
modifier|*
name|iv_ca_delta_add
parameter_list|(
name|struct
name|iv_use
modifier|*
name|use
parameter_list|,
name|struct
name|cost_pair
modifier|*
name|old_cp
parameter_list|,
name|struct
name|cost_pair
modifier|*
name|new_cp
parameter_list|,
name|struct
name|iv_ca_delta
modifier|*
name|next_change
parameter_list|)
block|{
name|struct
name|iv_ca_delta
modifier|*
name|change
init|=
name|XNEW
argument_list|(
expr|struct
name|iv_ca_delta
argument_list|)
decl_stmt|;
name|change
operator|->
name|use
operator|=
name|use
expr_stmt|;
name|change
operator|->
name|old_cp
operator|=
name|old_cp
expr_stmt|;
name|change
operator|->
name|new_cp
operator|=
name|new_cp
expr_stmt|;
name|change
operator|->
name|next_change
operator|=
name|next_change
expr_stmt|;
return|return
name|change
return|;
block|}
end_function

begin_comment
comment|/* Joins two lists of changes L1 and L2.  Destructive -- old lists    are rewritten.  */
end_comment

begin_function
specifier|static
name|struct
name|iv_ca_delta
modifier|*
name|iv_ca_delta_join
parameter_list|(
name|struct
name|iv_ca_delta
modifier|*
name|l1
parameter_list|,
name|struct
name|iv_ca_delta
modifier|*
name|l2
parameter_list|)
block|{
name|struct
name|iv_ca_delta
modifier|*
name|last
decl_stmt|;
if|if
condition|(
operator|!
name|l2
condition|)
return|return
name|l1
return|;
if|if
condition|(
operator|!
name|l1
condition|)
return|return
name|l2
return|;
for|for
control|(
name|last
operator|=
name|l1
init|;
name|last
operator|->
name|next_change
condition|;
name|last
operator|=
name|last
operator|->
name|next_change
control|)
continue|continue;
name|last
operator|->
name|next_change
operator|=
name|l2
expr_stmt|;
return|return
name|l1
return|;
block|}
end_function

begin_comment
comment|/* Returns candidate by that USE is expressed in IVS.  */
end_comment

begin_function
specifier|static
name|struct
name|cost_pair
modifier|*
name|iv_ca_cand_for_use
parameter_list|(
name|struct
name|iv_ca
modifier|*
name|ivs
parameter_list|,
name|struct
name|iv_use
modifier|*
name|use
parameter_list|)
block|{
return|return
name|ivs
operator|->
name|cand_for_use
index|[
name|use
operator|->
name|id
index|]
return|;
block|}
end_function

begin_comment
comment|/* Reverse the list of changes DELTA, forming the inverse to it.  */
end_comment

begin_function
specifier|static
name|struct
name|iv_ca_delta
modifier|*
name|iv_ca_delta_reverse
parameter_list|(
name|struct
name|iv_ca_delta
modifier|*
name|delta
parameter_list|)
block|{
name|struct
name|iv_ca_delta
modifier|*
name|act
decl_stmt|,
modifier|*
name|next
decl_stmt|,
modifier|*
name|prev
init|=
name|NULL
decl_stmt|;
name|struct
name|cost_pair
modifier|*
name|tmp
decl_stmt|;
for|for
control|(
name|act
operator|=
name|delta
init|;
name|act
condition|;
name|act
operator|=
name|next
control|)
block|{
name|next
operator|=
name|act
operator|->
name|next_change
expr_stmt|;
name|act
operator|->
name|next_change
operator|=
name|prev
expr_stmt|;
name|prev
operator|=
name|act
expr_stmt|;
name|tmp
operator|=
name|act
operator|->
name|old_cp
expr_stmt|;
name|act
operator|->
name|old_cp
operator|=
name|act
operator|->
name|new_cp
expr_stmt|;
name|act
operator|->
name|new_cp
operator|=
name|tmp
expr_stmt|;
block|}
return|return
name|prev
return|;
block|}
end_function

begin_comment
comment|/* Commit changes in DELTA to IVS.  If FORWARD is false, the changes are    reverted instead.  */
end_comment

begin_function
specifier|static
name|void
name|iv_ca_delta_commit
parameter_list|(
name|struct
name|ivopts_data
modifier|*
name|data
parameter_list|,
name|struct
name|iv_ca
modifier|*
name|ivs
parameter_list|,
name|struct
name|iv_ca_delta
modifier|*
name|delta
parameter_list|,
name|bool
name|forward
parameter_list|)
block|{
name|struct
name|cost_pair
modifier|*
name|from
decl_stmt|,
modifier|*
name|to
decl_stmt|;
name|struct
name|iv_ca_delta
modifier|*
name|act
decl_stmt|;
if|if
condition|(
operator|!
name|forward
condition|)
name|delta
operator|=
name|iv_ca_delta_reverse
argument_list|(
name|delta
argument_list|)
expr_stmt|;
for|for
control|(
name|act
operator|=
name|delta
init|;
name|act
condition|;
name|act
operator|=
name|act
operator|->
name|next_change
control|)
block|{
name|from
operator|=
name|act
operator|->
name|old_cp
expr_stmt|;
name|to
operator|=
name|act
operator|->
name|new_cp
expr_stmt|;
name|gcc_assert
argument_list|(
name|iv_ca_cand_for_use
argument_list|(
name|ivs
argument_list|,
name|act
operator|->
name|use
argument_list|)
operator|==
name|from
argument_list|)
expr_stmt|;
name|iv_ca_set_cp
argument_list|(
name|data
argument_list|,
name|ivs
argument_list|,
name|act
operator|->
name|use
argument_list|,
name|to
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|forward
condition|)
name|iv_ca_delta_reverse
argument_list|(
name|delta
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns true if CAND is used in IVS.  */
end_comment

begin_function
specifier|static
name|bool
name|iv_ca_cand_used_p
parameter_list|(
name|struct
name|iv_ca
modifier|*
name|ivs
parameter_list|,
name|struct
name|iv_cand
modifier|*
name|cand
parameter_list|)
block|{
return|return
name|ivs
operator|->
name|n_cand_uses
index|[
name|cand
operator|->
name|id
index|]
operator|>
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Returns number of induction variable candidates in the set IVS.  */
end_comment

begin_function
specifier|static
name|unsigned
name|iv_ca_n_cands
parameter_list|(
name|struct
name|iv_ca
modifier|*
name|ivs
parameter_list|)
block|{
return|return
name|ivs
operator|->
name|n_cands
return|;
block|}
end_function

begin_comment
comment|/* Free the list of changes DELTA.  */
end_comment

begin_function
specifier|static
name|void
name|iv_ca_delta_free
parameter_list|(
name|struct
name|iv_ca_delta
modifier|*
modifier|*
name|delta
parameter_list|)
block|{
name|struct
name|iv_ca_delta
modifier|*
name|act
decl_stmt|,
modifier|*
name|next
decl_stmt|;
for|for
control|(
name|act
operator|=
operator|*
name|delta
init|;
name|act
condition|;
name|act
operator|=
name|next
control|)
block|{
name|next
operator|=
name|act
operator|->
name|next_change
expr_stmt|;
name|free
argument_list|(
name|act
argument_list|)
expr_stmt|;
block|}
operator|*
name|delta
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Allocates new iv candidates assignment.  */
end_comment

begin_function
specifier|static
name|struct
name|iv_ca
modifier|*
name|iv_ca_new
parameter_list|(
name|struct
name|ivopts_data
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|iv_ca
modifier|*
name|nw
init|=
name|XNEW
argument_list|(
expr|struct
name|iv_ca
argument_list|)
decl_stmt|;
name|nw
operator|->
name|upto
operator|=
literal|0
expr_stmt|;
name|nw
operator|->
name|bad_uses
operator|=
literal|0
expr_stmt|;
name|nw
operator|->
name|cand_for_use
operator|=
name|XCNEWVEC
argument_list|(
expr|struct
name|cost_pair
operator|*
argument_list|,
name|n_iv_uses
argument_list|(
name|data
argument_list|)
argument_list|)
expr_stmt|;
name|nw
operator|->
name|n_cand_uses
operator|=
name|XCNEWVEC
argument_list|(
name|unsigned
argument_list|,
name|n_iv_cands
argument_list|(
name|data
argument_list|)
argument_list|)
expr_stmt|;
name|nw
operator|->
name|cands
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|nw
operator|->
name|n_cands
operator|=
literal|0
expr_stmt|;
name|nw
operator|->
name|n_regs
operator|=
literal|0
expr_stmt|;
name|nw
operator|->
name|cand_use_cost
operator|=
literal|0
expr_stmt|;
name|nw
operator|->
name|cand_cost
operator|=
literal|0
expr_stmt|;
name|nw
operator|->
name|n_invariant_uses
operator|=
name|XCNEWVEC
argument_list|(
name|unsigned
argument_list|,
name|data
operator|->
name|max_inv_id
operator|+
literal|1
argument_list|)
expr_stmt|;
name|nw
operator|->
name|cost
operator|=
literal|0
expr_stmt|;
return|return
name|nw
return|;
block|}
end_function

begin_comment
comment|/* Free memory occupied by the set IVS.  */
end_comment

begin_function
specifier|static
name|void
name|iv_ca_free
parameter_list|(
name|struct
name|iv_ca
modifier|*
modifier|*
name|ivs
parameter_list|)
block|{
name|free
argument_list|(
operator|(
operator|*
name|ivs
operator|)
operator|->
name|cand_for_use
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
operator|*
name|ivs
operator|)
operator|->
name|n_cand_uses
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
operator|(
operator|*
name|ivs
operator|)
operator|->
name|cands
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
operator|*
name|ivs
operator|)
operator|->
name|n_invariant_uses
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|*
name|ivs
argument_list|)
expr_stmt|;
operator|*
name|ivs
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dumps IVS to FILE.  */
end_comment

begin_function
specifier|static
name|void
name|iv_ca_dump
parameter_list|(
name|struct
name|ivopts_data
modifier|*
name|data
parameter_list|,
name|FILE
modifier|*
name|file
parameter_list|,
name|struct
name|iv_ca
modifier|*
name|ivs
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|pref
init|=
literal|"  invariants "
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"  cost %d\n"
argument_list|,
name|iv_ca_cost
argument_list|(
name|ivs
argument_list|)
argument_list|)
expr_stmt|;
name|bitmap_print
argument_list|(
name|file
argument_list|,
name|ivs
operator|->
name|cands
argument_list|,
literal|"  candidates "
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|data
operator|->
name|max_inv_id
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|ivs
operator|->
name|n_invariant_uses
index|[
name|i
index|]
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s%d"
argument_list|,
name|pref
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|pref
operator|=
literal|", "
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Try changing candidate in IVS to CAND for each use.  Return cost of the    new set, and store differences in DELTA.  Number of induction variables    in the new set is stored to N_IVS.  */
end_comment

begin_function
specifier|static
name|unsigned
name|iv_ca_extend
parameter_list|(
name|struct
name|ivopts_data
modifier|*
name|data
parameter_list|,
name|struct
name|iv_ca
modifier|*
name|ivs
parameter_list|,
name|struct
name|iv_cand
modifier|*
name|cand
parameter_list|,
name|struct
name|iv_ca_delta
modifier|*
modifier|*
name|delta
parameter_list|,
name|unsigned
modifier|*
name|n_ivs
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|,
name|cost
decl_stmt|;
name|struct
name|iv_use
modifier|*
name|use
decl_stmt|;
name|struct
name|cost_pair
modifier|*
name|old_cp
decl_stmt|,
modifier|*
name|new_cp
decl_stmt|;
operator|*
name|delta
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ivs
operator|->
name|upto
condition|;
name|i
operator|++
control|)
block|{
name|use
operator|=
name|iv_use
argument_list|(
name|data
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|old_cp
operator|=
name|iv_ca_cand_for_use
argument_list|(
name|ivs
argument_list|,
name|use
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_cp
operator|&&
name|old_cp
operator|->
name|cand
operator|==
name|cand
condition|)
continue|continue;
name|new_cp
operator|=
name|get_use_iv_cost
argument_list|(
name|data
argument_list|,
name|use
argument_list|,
name|cand
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|new_cp
condition|)
continue|continue;
if|if
condition|(
operator|!
name|iv_ca_has_deps
argument_list|(
name|ivs
argument_list|,
name|new_cp
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|cheaper_cost_pair
argument_list|(
name|new_cp
argument_list|,
name|old_cp
argument_list|)
condition|)
continue|continue;
operator|*
name|delta
operator|=
name|iv_ca_delta_add
argument_list|(
name|use
argument_list|,
name|old_cp
argument_list|,
name|new_cp
argument_list|,
operator|*
name|delta
argument_list|)
expr_stmt|;
block|}
name|iv_ca_delta_commit
argument_list|(
name|data
argument_list|,
name|ivs
argument_list|,
operator|*
name|delta
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|cost
operator|=
name|iv_ca_cost
argument_list|(
name|ivs
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_ivs
condition|)
operator|*
name|n_ivs
operator|=
name|iv_ca_n_cands
argument_list|(
name|ivs
argument_list|)
expr_stmt|;
name|iv_ca_delta_commit
argument_list|(
name|data
argument_list|,
name|ivs
argument_list|,
operator|*
name|delta
argument_list|,
name|false
argument_list|)
expr_stmt|;
return|return
name|cost
return|;
block|}
end_function

begin_comment
comment|/* Try narrowing set IVS by removing CAND.  Return the cost of    the new set and store the differences in DELTA.  */
end_comment

begin_function
specifier|static
name|unsigned
name|iv_ca_narrow
parameter_list|(
name|struct
name|ivopts_data
modifier|*
name|data
parameter_list|,
name|struct
name|iv_ca
modifier|*
name|ivs
parameter_list|,
name|struct
name|iv_cand
modifier|*
name|cand
parameter_list|,
name|struct
name|iv_ca_delta
modifier|*
modifier|*
name|delta
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|,
name|ci
decl_stmt|;
name|struct
name|iv_use
modifier|*
name|use
decl_stmt|;
name|struct
name|cost_pair
modifier|*
name|old_cp
decl_stmt|,
modifier|*
name|new_cp
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
name|struct
name|iv_cand
modifier|*
name|cnd
decl_stmt|;
name|unsigned
name|cost
decl_stmt|;
operator|*
name|delta
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_iv_uses
argument_list|(
name|data
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|use
operator|=
name|iv_use
argument_list|(
name|data
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|old_cp
operator|=
name|iv_ca_cand_for_use
argument_list|(
name|ivs
argument_list|,
name|use
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_cp
operator|->
name|cand
operator|!=
name|cand
condition|)
continue|continue;
name|new_cp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|consider_all_candidates
condition|)
block|{
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|ivs->cands
argument_list|,
literal|0
argument_list|,
argument|ci
argument_list|,
argument|bi
argument_list|)
block|{
if|if
condition|(
name|ci
operator|==
name|cand
operator|->
name|id
condition|)
continue|continue;
name|cnd
operator|=
name|iv_cand
argument_list|(
name|data
argument_list|,
name|ci
argument_list|)
expr_stmt|;
name|cp
operator|=
name|get_use_iv_cost
argument_list|(
name|data
argument_list|,
name|use
argument_list|,
name|cnd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cp
condition|)
continue|continue;
if|if
condition|(
operator|!
name|iv_ca_has_deps
argument_list|(
name|ivs
argument_list|,
name|cp
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|cheaper_cost_pair
argument_list|(
name|cp
argument_list|,
name|new_cp
argument_list|)
condition|)
continue|continue;
name|new_cp
operator|=
name|cp
expr_stmt|;
block|}
block|}
else|else
block|{
name|EXECUTE_IF_AND_IN_BITMAP
argument_list|(
argument|use->related_cands
argument_list|,
argument|ivs->cands
argument_list|,
literal|0
argument_list|,
argument|ci
argument_list|,
argument|bi
argument_list|)
block|{
if|if
condition|(
name|ci
operator|==
name|cand
operator|->
name|id
condition|)
continue|continue;
name|cnd
operator|=
name|iv_cand
argument_list|(
name|data
argument_list|,
name|ci
argument_list|)
expr_stmt|;
name|cp
operator|=
name|get_use_iv_cost
argument_list|(
name|data
argument_list|,
name|use
argument_list|,
name|cnd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cp
condition|)
continue|continue;
if|if
condition|(
operator|!
name|iv_ca_has_deps
argument_list|(
name|ivs
argument_list|,
name|cp
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|cheaper_cost_pair
argument_list|(
name|cp
argument_list|,
name|new_cp
argument_list|)
condition|)
continue|continue;
name|new_cp
operator|=
name|cp
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|new_cp
condition|)
block|{
name|iv_ca_delta_free
argument_list|(
name|delta
argument_list|)
expr_stmt|;
return|return
name|INFTY
return|;
block|}
operator|*
name|delta
operator|=
name|iv_ca_delta_add
argument_list|(
name|use
argument_list|,
name|old_cp
argument_list|,
name|new_cp
argument_list|,
operator|*
name|delta
argument_list|)
expr_stmt|;
block|}
name|iv_ca_delta_commit
argument_list|(
name|data
argument_list|,
name|ivs
argument_list|,
operator|*
name|delta
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|cost
operator|=
name|iv_ca_cost
argument_list|(
name|ivs
argument_list|)
expr_stmt|;
name|iv_ca_delta_commit
argument_list|(
name|data
argument_list|,
name|ivs
argument_list|,
operator|*
name|delta
argument_list|,
name|false
argument_list|)
expr_stmt|;
return|return
name|cost
return|;
block|}
end_function

begin_comment
comment|/* Try optimizing the set of candidates IVS by removing candidates different    from to EXCEPT_CAND from it.  Return cost of the new set, and store    differences in DELTA.  */
end_comment

begin_function
specifier|static
name|unsigned
name|iv_ca_prune
parameter_list|(
name|struct
name|ivopts_data
modifier|*
name|data
parameter_list|,
name|struct
name|iv_ca
modifier|*
name|ivs
parameter_list|,
name|struct
name|iv_cand
modifier|*
name|except_cand
parameter_list|,
name|struct
name|iv_ca_delta
modifier|*
modifier|*
name|delta
parameter_list|)
block|{
name|bitmap_iterator
name|bi
decl_stmt|;
name|struct
name|iv_ca_delta
modifier|*
name|act_delta
decl_stmt|,
modifier|*
name|best_delta
decl_stmt|;
name|unsigned
name|i
decl_stmt|,
name|best_cost
decl_stmt|,
name|acost
decl_stmt|;
name|struct
name|iv_cand
modifier|*
name|cand
decl_stmt|;
name|best_delta
operator|=
name|NULL
expr_stmt|;
name|best_cost
operator|=
name|iv_ca_cost
argument_list|(
name|ivs
argument_list|)
expr_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|ivs->cands
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|bi
argument_list|)
block|{
name|cand
operator|=
name|iv_cand
argument_list|(
name|data
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|cand
operator|==
name|except_cand
condition|)
continue|continue;
name|acost
operator|=
name|iv_ca_narrow
argument_list|(
name|data
argument_list|,
name|ivs
argument_list|,
name|cand
argument_list|,
operator|&
name|act_delta
argument_list|)
expr_stmt|;
if|if
condition|(
name|acost
operator|<
name|best_cost
condition|)
block|{
name|best_cost
operator|=
name|acost
expr_stmt|;
name|iv_ca_delta_free
argument_list|(
operator|&
name|best_delta
argument_list|)
expr_stmt|;
name|best_delta
operator|=
name|act_delta
expr_stmt|;
block|}
else|else
name|iv_ca_delta_free
argument_list|(
operator|&
name|act_delta
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|best_delta
condition|)
block|{
operator|*
name|delta
operator|=
name|NULL
expr_stmt|;
return|return
name|best_cost
return|;
block|}
comment|/* Recurse to possibly remove other unnecessary ivs.  */
name|iv_ca_delta_commit
argument_list|(
name|data
argument_list|,
name|ivs
argument_list|,
name|best_delta
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|best_cost
operator|=
name|iv_ca_prune
argument_list|(
name|data
argument_list|,
name|ivs
argument_list|,
name|except_cand
argument_list|,
name|delta
argument_list|)
expr_stmt|;
name|iv_ca_delta_commit
argument_list|(
name|data
argument_list|,
name|ivs
argument_list|,
name|best_delta
argument_list|,
name|false
argument_list|)
expr_stmt|;
operator|*
name|delta
operator|=
name|iv_ca_delta_join
argument_list|(
name|best_delta
argument_list|,
operator|*
name|delta
argument_list|)
expr_stmt|;
return|return
name|best_cost
return|;
block|}
end_function

begin_comment
comment|/* Tries to extend the sets IVS in the best possible way in order    to express the USE.  */
end_comment

begin_function
specifier|static
name|bool
name|try_add_cand_for
parameter_list|(
name|struct
name|ivopts_data
modifier|*
name|data
parameter_list|,
name|struct
name|iv_ca
modifier|*
name|ivs
parameter_list|,
name|struct
name|iv_use
modifier|*
name|use
parameter_list|)
block|{
name|unsigned
name|best_cost
decl_stmt|,
name|act_cost
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
name|struct
name|iv_cand
modifier|*
name|cand
decl_stmt|;
name|struct
name|iv_ca_delta
modifier|*
name|best_delta
init|=
name|NULL
decl_stmt|,
modifier|*
name|act_delta
decl_stmt|;
name|struct
name|cost_pair
modifier|*
name|cp
decl_stmt|;
name|iv_ca_add_use
argument_list|(
name|data
argument_list|,
name|ivs
argument_list|,
name|use
argument_list|)
expr_stmt|;
name|best_cost
operator|=
name|iv_ca_cost
argument_list|(
name|ivs
argument_list|)
expr_stmt|;
name|cp
operator|=
name|iv_ca_cand_for_use
argument_list|(
name|ivs
argument_list|,
name|use
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
condition|)
block|{
name|best_delta
operator|=
name|iv_ca_delta_add
argument_list|(
name|use
argument_list|,
name|NULL
argument_list|,
name|cp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|iv_ca_set_no_cp
argument_list|(
name|data
argument_list|,
name|ivs
argument_list|,
name|use
argument_list|)
expr_stmt|;
block|}
comment|/* First try important candidates.  Only if it fails, try the specific ones.      Rationale -- in loops with many variables the best choice often is to use      just one generic biv.  If we added here many ivs specific to the uses,      the optimization algorithm later would be likely to get stuck in a local      minimum, thus causing us to create too many ivs.  The approach from      few ivs to more seems more likely to be successful -- starting from few      ivs, replacing an expensive use by a specific iv should always be a      win.  */
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|data->important_candidates
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|bi
argument_list|)
block|{
name|cand
operator|=
name|iv_cand
argument_list|(
name|data
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|iv_ca_cand_used_p
argument_list|(
name|ivs
argument_list|,
name|cand
argument_list|)
condition|)
continue|continue;
name|cp
operator|=
name|get_use_iv_cost
argument_list|(
name|data
argument_list|,
name|use
argument_list|,
name|cand
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cp
condition|)
continue|continue;
name|iv_ca_set_cp
argument_list|(
name|data
argument_list|,
name|ivs
argument_list|,
name|use
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|act_cost
operator|=
name|iv_ca_extend
argument_list|(
name|data
argument_list|,
name|ivs
argument_list|,
name|cand
argument_list|,
operator|&
name|act_delta
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|iv_ca_set_no_cp
argument_list|(
name|data
argument_list|,
name|ivs
argument_list|,
name|use
argument_list|)
expr_stmt|;
name|act_delta
operator|=
name|iv_ca_delta_add
argument_list|(
name|use
argument_list|,
name|NULL
argument_list|,
name|cp
argument_list|,
name|act_delta
argument_list|)
expr_stmt|;
if|if
condition|(
name|act_cost
operator|<
name|best_cost
condition|)
block|{
name|best_cost
operator|=
name|act_cost
expr_stmt|;
name|iv_ca_delta_free
argument_list|(
operator|&
name|best_delta
argument_list|)
expr_stmt|;
name|best_delta
operator|=
name|act_delta
expr_stmt|;
block|}
else|else
name|iv_ca_delta_free
argument_list|(
operator|&
name|act_delta
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|best_cost
operator|==
name|INFTY
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|use
operator|->
name|n_map_members
condition|;
name|i
operator|++
control|)
block|{
name|cp
operator|=
name|use
operator|->
name|cost_map
operator|+
name|i
expr_stmt|;
name|cand
operator|=
name|cp
operator|->
name|cand
expr_stmt|;
if|if
condition|(
operator|!
name|cand
condition|)
continue|continue;
comment|/* Already tried this.  */
if|if
condition|(
name|cand
operator|->
name|important
condition|)
continue|continue;
if|if
condition|(
name|iv_ca_cand_used_p
argument_list|(
name|ivs
argument_list|,
name|cand
argument_list|)
condition|)
continue|continue;
name|act_delta
operator|=
name|NULL
expr_stmt|;
name|iv_ca_set_cp
argument_list|(
name|data
argument_list|,
name|ivs
argument_list|,
name|use
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|act_cost
operator|=
name|iv_ca_extend
argument_list|(
name|data
argument_list|,
name|ivs
argument_list|,
name|cand
argument_list|,
operator|&
name|act_delta
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|iv_ca_set_no_cp
argument_list|(
name|data
argument_list|,
name|ivs
argument_list|,
name|use
argument_list|)
expr_stmt|;
name|act_delta
operator|=
name|iv_ca_delta_add
argument_list|(
name|use
argument_list|,
name|iv_ca_cand_for_use
argument_list|(
name|ivs
argument_list|,
name|use
argument_list|)
argument_list|,
name|cp
argument_list|,
name|act_delta
argument_list|)
expr_stmt|;
if|if
condition|(
name|act_cost
operator|<
name|best_cost
condition|)
block|{
name|best_cost
operator|=
name|act_cost
expr_stmt|;
if|if
condition|(
name|best_delta
condition|)
name|iv_ca_delta_free
argument_list|(
operator|&
name|best_delta
argument_list|)
expr_stmt|;
name|best_delta
operator|=
name|act_delta
expr_stmt|;
block|}
else|else
name|iv_ca_delta_free
argument_list|(
operator|&
name|act_delta
argument_list|)
expr_stmt|;
block|}
block|}
name|iv_ca_delta_commit
argument_list|(
name|data
argument_list|,
name|ivs
argument_list|,
name|best_delta
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|iv_ca_delta_free
argument_list|(
operator|&
name|best_delta
argument_list|)
expr_stmt|;
return|return
operator|(
name|best_cost
operator|!=
name|INFTY
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Finds an initial assignment of candidates to uses.  */
end_comment

begin_function
specifier|static
name|struct
name|iv_ca
modifier|*
name|get_initial_solution
parameter_list|(
name|struct
name|ivopts_data
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|iv_ca
modifier|*
name|ivs
init|=
name|iv_ca_new
argument_list|(
name|data
argument_list|)
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_iv_uses
argument_list|(
name|data
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|try_add_cand_for
argument_list|(
name|data
argument_list|,
name|ivs
argument_list|,
name|iv_use
argument_list|(
name|data
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
block|{
name|iv_ca_free
argument_list|(
operator|&
name|ivs
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|ivs
return|;
block|}
end_function

begin_comment
comment|/* Tries to improve set of induction variables IVS.  */
end_comment

begin_function
specifier|static
name|bool
name|try_improve_iv_set
parameter_list|(
name|struct
name|ivopts_data
modifier|*
name|data
parameter_list|,
name|struct
name|iv_ca
modifier|*
name|ivs
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|,
name|acost
decl_stmt|,
name|best_cost
init|=
name|iv_ca_cost
argument_list|(
name|ivs
argument_list|)
decl_stmt|,
name|n_ivs
decl_stmt|;
name|struct
name|iv_ca_delta
modifier|*
name|best_delta
init|=
name|NULL
decl_stmt|,
modifier|*
name|act_delta
decl_stmt|,
modifier|*
name|tmp_delta
decl_stmt|;
name|struct
name|iv_cand
modifier|*
name|cand
decl_stmt|;
comment|/* Try extending the set of induction variables by one.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_iv_cands
argument_list|(
name|data
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|cand
operator|=
name|iv_cand
argument_list|(
name|data
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|iv_ca_cand_used_p
argument_list|(
name|ivs
argument_list|,
name|cand
argument_list|)
condition|)
continue|continue;
name|acost
operator|=
name|iv_ca_extend
argument_list|(
name|data
argument_list|,
name|ivs
argument_list|,
name|cand
argument_list|,
operator|&
name|act_delta
argument_list|,
operator|&
name|n_ivs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|act_delta
condition|)
continue|continue;
comment|/* If we successfully added the candidate and the set is small enough, 	 try optimizing it by removing other candidates.  */
if|if
condition|(
name|n_ivs
operator|<=
name|ALWAYS_PRUNE_CAND_SET_BOUND
condition|)
block|{
name|iv_ca_delta_commit
argument_list|(
name|data
argument_list|,
name|ivs
argument_list|,
name|act_delta
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|acost
operator|=
name|iv_ca_prune
argument_list|(
name|data
argument_list|,
name|ivs
argument_list|,
name|cand
argument_list|,
operator|&
name|tmp_delta
argument_list|)
expr_stmt|;
name|iv_ca_delta_commit
argument_list|(
name|data
argument_list|,
name|ivs
argument_list|,
name|act_delta
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|act_delta
operator|=
name|iv_ca_delta_join
argument_list|(
name|act_delta
argument_list|,
name|tmp_delta
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|acost
operator|<
name|best_cost
condition|)
block|{
name|best_cost
operator|=
name|acost
expr_stmt|;
name|iv_ca_delta_free
argument_list|(
operator|&
name|best_delta
argument_list|)
expr_stmt|;
name|best_delta
operator|=
name|act_delta
expr_stmt|;
block|}
else|else
name|iv_ca_delta_free
argument_list|(
operator|&
name|act_delta
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|best_delta
condition|)
block|{
comment|/* Try removing the candidates from the set instead.  */
name|best_cost
operator|=
name|iv_ca_prune
argument_list|(
name|data
argument_list|,
name|ivs
argument_list|,
name|NULL
argument_list|,
operator|&
name|best_delta
argument_list|)
expr_stmt|;
comment|/* Nothing more we can do.  */
if|if
condition|(
operator|!
name|best_delta
condition|)
return|return
name|false
return|;
block|}
name|iv_ca_delta_commit
argument_list|(
name|data
argument_list|,
name|ivs
argument_list|,
name|best_delta
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|best_cost
operator|==
name|iv_ca_cost
argument_list|(
name|ivs
argument_list|)
argument_list|)
expr_stmt|;
name|iv_ca_delta_free
argument_list|(
operator|&
name|best_delta
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Attempts to find the optimal set of induction variables.  We do simple    greedy heuristic -- we try to replace at most one candidate in the selected    solution and remove the unused ivs while this improves the cost.  */
end_comment

begin_function
specifier|static
name|struct
name|iv_ca
modifier|*
name|find_optimal_iv_set
parameter_list|(
name|struct
name|ivopts_data
modifier|*
name|data
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
name|struct
name|iv_ca
modifier|*
name|set
decl_stmt|;
name|struct
name|iv_use
modifier|*
name|use
decl_stmt|;
comment|/* Get the initial solution.  */
name|set
operator|=
name|get_initial_solution
argument_list|(
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|set
condition|)
block|{
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Unable to substitute for ivs, failed.\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Initial set of candidates:\n"
argument_list|)
expr_stmt|;
name|iv_ca_dump
argument_list|(
name|data
argument_list|,
name|dump_file
argument_list|,
name|set
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|try_improve_iv_set
argument_list|(
name|data
argument_list|,
name|set
argument_list|)
condition|)
block|{
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Improved to:\n"
argument_list|)
expr_stmt|;
name|iv_ca_dump
argument_list|(
name|data
argument_list|,
name|dump_file
argument_list|,
name|set
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Final cost %d\n\n"
argument_list|,
name|iv_ca_cost
argument_list|(
name|set
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_iv_uses
argument_list|(
name|data
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|use
operator|=
name|iv_use
argument_list|(
name|data
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|use
operator|->
name|selected
operator|=
name|iv_ca_cand_for_use
argument_list|(
name|set
argument_list|,
name|use
argument_list|)
operator|->
name|cand
expr_stmt|;
block|}
return|return
name|set
return|;
block|}
end_function

begin_comment
comment|/* Creates a new induction variable corresponding to CAND.  */
end_comment

begin_function
specifier|static
name|void
name|create_new_iv
parameter_list|(
name|struct
name|ivopts_data
modifier|*
name|data
parameter_list|,
name|struct
name|iv_cand
modifier|*
name|cand
parameter_list|)
block|{
name|block_stmt_iterator
name|incr_pos
decl_stmt|;
name|tree
name|base
decl_stmt|;
name|bool
name|after
init|=
name|false
decl_stmt|;
if|if
condition|(
operator|!
name|cand
operator|->
name|iv
condition|)
return|return;
switch|switch
condition|(
name|cand
operator|->
name|pos
condition|)
block|{
case|case
name|IP_NORMAL
case|:
name|incr_pos
operator|=
name|bsi_last
argument_list|(
name|ip_normal_pos
argument_list|(
name|data
operator|->
name|current_loop
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|IP_END
case|:
name|incr_pos
operator|=
name|bsi_last
argument_list|(
name|ip_end_pos
argument_list|(
name|data
operator|->
name|current_loop
argument_list|)
argument_list|)
expr_stmt|;
name|after
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|IP_ORIGINAL
case|:
comment|/* Mark that the iv is preserved.  */
name|name_info
argument_list|(
name|data
argument_list|,
name|cand
operator|->
name|var_before
argument_list|)
operator|->
name|preserve_biv
operator|=
name|true
expr_stmt|;
name|name_info
argument_list|(
name|data
argument_list|,
name|cand
operator|->
name|var_after
argument_list|)
operator|->
name|preserve_biv
operator|=
name|true
expr_stmt|;
comment|/* Rewrite the increment so that it uses var_before directly.  */
name|find_interesting_uses_op
argument_list|(
name|data
argument_list|,
name|cand
operator|->
name|var_after
argument_list|)
operator|->
name|selected
operator|=
name|cand
expr_stmt|;
return|return;
block|}
name|gimple_add_tmp_var
argument_list|(
name|cand
operator|->
name|var_before
argument_list|)
expr_stmt|;
name|add_referenced_var
argument_list|(
name|cand
operator|->
name|var_before
argument_list|)
expr_stmt|;
name|base
operator|=
name|unshare_expr
argument_list|(
name|cand
operator|->
name|iv
operator|->
name|base
argument_list|)
expr_stmt|;
name|create_iv
argument_list|(
name|base
argument_list|,
name|unshare_expr
argument_list|(
name|cand
operator|->
name|iv
operator|->
name|step
argument_list|)
argument_list|,
name|cand
operator|->
name|var_before
argument_list|,
name|data
operator|->
name|current_loop
argument_list|,
operator|&
name|incr_pos
argument_list|,
name|after
argument_list|,
operator|&
name|cand
operator|->
name|var_before
argument_list|,
operator|&
name|cand
operator|->
name|var_after
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Creates new induction variables described in SET.  */
end_comment

begin_function
specifier|static
name|void
name|create_new_ivs
parameter_list|(
name|struct
name|ivopts_data
modifier|*
name|data
parameter_list|,
name|struct
name|iv_ca
modifier|*
name|set
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
name|struct
name|iv_cand
modifier|*
name|cand
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|set->cands
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|bi
argument_list|)
block|{
name|cand
operator|=
name|iv_cand
argument_list|(
name|data
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|create_new_iv
argument_list|(
name|data
argument_list|,
name|cand
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Removes statement STMT (real or a phi node).  If INCLUDING_DEFINED_NAME    is true, remove also the ssa name defined by the statement.  */
end_comment

begin_function
specifier|static
name|void
name|remove_statement
parameter_list|(
name|tree
name|stmt
parameter_list|,
name|bool
name|including_defined_name
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|PHI_NODE
condition|)
block|{
if|if
condition|(
operator|!
name|including_defined_name
condition|)
block|{
comment|/* Prevent the ssa name defined by the statement from being removed.  */
name|SET_PHI_RESULT
argument_list|(
name|stmt
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|remove_phi_node
argument_list|(
name|stmt
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|block_stmt_iterator
name|bsi
init|=
name|bsi_for_stmt
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
name|bsi_remove
argument_list|(
operator|&
name|bsi
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Rewrites USE (definition of iv used in a nonlinear expression)    using candidate CAND.  */
end_comment

begin_function
specifier|static
name|void
name|rewrite_use_nonlinear_expr
parameter_list|(
name|struct
name|ivopts_data
modifier|*
name|data
parameter_list|,
name|struct
name|iv_use
modifier|*
name|use
parameter_list|,
name|struct
name|iv_cand
modifier|*
name|cand
parameter_list|)
block|{
name|tree
name|comp
decl_stmt|;
name|tree
name|op
decl_stmt|,
name|stmts
decl_stmt|,
name|tgt
decl_stmt|,
name|ass
decl_stmt|;
name|block_stmt_iterator
name|bsi
decl_stmt|,
name|pbsi
decl_stmt|;
comment|/* An important special case -- if we are asked to express value of      the original iv by itself, just exit; there is no need to      introduce a new computation (that might also need casting the      variable to unsigned and back).  */
if|if
condition|(
name|cand
operator|->
name|pos
operator|==
name|IP_ORIGINAL
operator|&&
name|cand
operator|->
name|incremented_at
operator|==
name|use
operator|->
name|stmt
condition|)
block|{
name|tree
name|step
decl_stmt|,
name|ctype
decl_stmt|,
name|utype
decl_stmt|;
name|enum
name|tree_code
name|incr_code
init|=
name|PLUS_EXPR
decl_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|use
operator|->
name|stmt
argument_list|)
operator|==
name|MODIFY_EXPR
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|TREE_OPERAND
argument_list|(
name|use
operator|->
name|stmt
argument_list|,
literal|0
argument_list|)
operator|==
name|cand
operator|->
name|var_after
argument_list|)
expr_stmt|;
name|step
operator|=
name|cand
operator|->
name|iv
operator|->
name|step
expr_stmt|;
name|ctype
operator|=
name|TREE_TYPE
argument_list|(
name|step
argument_list|)
expr_stmt|;
name|utype
operator|=
name|TREE_TYPE
argument_list|(
name|cand
operator|->
name|var_after
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|step
argument_list|)
operator|==
name|NEGATE_EXPR
condition|)
block|{
name|incr_code
operator|=
name|MINUS_EXPR
expr_stmt|;
name|step
operator|=
name|TREE_OPERAND
argument_list|(
name|step
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Check whether we may leave the computation unchanged. 	 This is the case only if it does not rely on other 	 computations in the loop -- otherwise, the computation 	 we rely upon may be removed in remove_unused_ivs, 	 thus leading to ICE.  */
name|op
operator|=
name|TREE_OPERAND
argument_list|(
name|use
operator|->
name|stmt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|PLUS_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MINUS_EXPR
condition|)
block|{
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
operator|==
name|cand
operator|->
name|var_before
condition|)
name|op
operator|=
name|TREE_OPERAND
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|PLUS_EXPR
operator|&&
name|TREE_OPERAND
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
operator|==
name|cand
operator|->
name|var_before
condition|)
name|op
operator|=
name|TREE_OPERAND
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|op
operator|=
name|NULL_TREE
expr_stmt|;
block|}
else|else
name|op
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|op
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|INTEGER_CST
operator|||
name|operand_equal_p
argument_list|(
name|op
argument_list|,
name|step
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
return|return;
comment|/* Otherwise, add the necessary computations to express 	 the iv.  */
name|op
operator|=
name|fold_convert
argument_list|(
name|ctype
argument_list|,
name|cand
operator|->
name|var_before
argument_list|)
expr_stmt|;
name|comp
operator|=
name|fold_convert
argument_list|(
name|utype
argument_list|,
name|build2
argument_list|(
name|incr_code
argument_list|,
name|ctype
argument_list|,
name|op
argument_list|,
name|unshare_expr
argument_list|(
name|step
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|comp
operator|=
name|get_computation
argument_list|(
name|data
operator|->
name|current_loop
argument_list|,
name|use
argument_list|,
name|cand
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|use
operator|->
name|stmt
argument_list|)
condition|)
block|{
case|case
name|PHI_NODE
case|:
name|tgt
operator|=
name|PHI_RESULT
argument_list|(
name|use
operator|->
name|stmt
argument_list|)
expr_stmt|;
comment|/* If we should keep the biv, do not replace it.  */
if|if
condition|(
name|name_info
argument_list|(
name|data
argument_list|,
name|tgt
argument_list|)
operator|->
name|preserve_biv
condition|)
return|return;
name|pbsi
operator|=
name|bsi
operator|=
name|bsi_start
argument_list|(
name|bb_for_stmt
argument_list|(
name|use
operator|->
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|bsi_end_p
argument_list|(
name|pbsi
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|bsi_stmt
argument_list|(
name|pbsi
argument_list|)
argument_list|)
operator|==
name|LABEL_EXPR
condition|)
block|{
name|bsi
operator|=
name|pbsi
expr_stmt|;
name|bsi_next
argument_list|(
operator|&
name|pbsi
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|MODIFY_EXPR
case|:
name|tgt
operator|=
name|TREE_OPERAND
argument_list|(
name|use
operator|->
name|stmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bsi
operator|=
name|bsi_for_stmt
argument_list|(
name|use
operator|->
name|stmt
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|op
operator|=
name|force_gimple_operand
argument_list|(
name|comp
argument_list|,
operator|&
name|stmts
argument_list|,
name|false
argument_list|,
name|SSA_NAME_VAR
argument_list|(
name|tgt
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|use
operator|->
name|stmt
argument_list|)
operator|==
name|PHI_NODE
condition|)
block|{
if|if
condition|(
name|stmts
condition|)
name|bsi_insert_after
argument_list|(
operator|&
name|bsi
argument_list|,
name|stmts
argument_list|,
name|BSI_CONTINUE_LINKING
argument_list|)
expr_stmt|;
name|ass
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|tgt
argument_list|)
argument_list|,
name|tgt
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|bsi_insert_after
argument_list|(
operator|&
name|bsi
argument_list|,
name|ass
argument_list|,
name|BSI_NEW_STMT
argument_list|)
expr_stmt|;
name|remove_statement
argument_list|(
name|use
operator|->
name|stmt
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|SSA_NAME_DEF_STMT
argument_list|(
name|tgt
argument_list|)
operator|=
name|ass
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|stmts
condition|)
name|bsi_insert_before
argument_list|(
operator|&
name|bsi
argument_list|,
name|stmts
argument_list|,
name|BSI_SAME_STMT
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|use
operator|->
name|stmt
argument_list|,
literal|1
argument_list|)
operator|=
name|op
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Replaces ssa name in index IDX by its basic variable.  Callback for    for_each_index.  */
end_comment

begin_function
specifier|static
name|bool
name|idx_remove_ssa_names
parameter_list|(
name|tree
name|base
parameter_list|,
name|tree
modifier|*
name|idx
parameter_list|,
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|tree
modifier|*
name|op
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|idx
argument_list|)
operator|==
name|SSA_NAME
condition|)
operator|*
name|idx
operator|=
name|SSA_NAME_VAR
argument_list|(
operator|*
name|idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|ARRAY_REF
condition|)
block|{
name|op
operator|=
operator|&
name|TREE_OPERAND
argument_list|(
name|base
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|op
operator|&&
name|TREE_CODE
argument_list|(
operator|*
name|op
argument_list|)
operator|==
name|SSA_NAME
condition|)
operator|*
name|op
operator|=
name|SSA_NAME_VAR
argument_list|(
operator|*
name|op
argument_list|)
expr_stmt|;
name|op
operator|=
operator|&
name|TREE_OPERAND
argument_list|(
name|base
argument_list|,
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|op
operator|&&
name|TREE_CODE
argument_list|(
operator|*
name|op
argument_list|)
operator|==
name|SSA_NAME
condition|)
operator|*
name|op
operator|=
name|SSA_NAME_VAR
argument_list|(
operator|*
name|op
argument_list|)
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Unshares REF and replaces ssa names inside it by their basic variables.  */
end_comment

begin_function
specifier|static
name|tree
name|unshare_and_remove_ssa_names
parameter_list|(
name|tree
name|ref
parameter_list|)
block|{
name|ref
operator|=
name|unshare_expr
argument_list|(
name|ref
argument_list|)
expr_stmt|;
name|for_each_index
argument_list|(
operator|&
name|ref
argument_list|,
name|idx_remove_ssa_names
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|ref
return|;
block|}
end_function

begin_comment
comment|/* Extract the alias analysis info for the memory reference REF.  There are    several ways how this information may be stored and what precisely is    its semantics depending on the type of the reference, but there always is    somewhere hidden one _DECL node that is used to determine the set of    virtual operands for the reference.  The code below deciphers this jungle    and extracts this single useful piece of information.  */
end_comment

begin_function
specifier|static
name|tree
name|get_ref_tag
parameter_list|(
name|tree
name|ref
parameter_list|,
name|tree
name|orig
parameter_list|)
block|{
name|tree
name|var
init|=
name|get_base_address
argument_list|(
name|ref
argument_list|)
decl_stmt|;
name|tree
name|aref
init|=
name|NULL_TREE
decl_stmt|,
name|tag
decl_stmt|,
name|sv
decl_stmt|;
name|HOST_WIDE_INT
name|offset
decl_stmt|,
name|size
decl_stmt|,
name|maxsize
decl_stmt|;
for|for
control|(
name|sv
operator|=
name|orig
init|;
name|handled_component_p
argument_list|(
name|sv
argument_list|)
condition|;
name|sv
operator|=
name|TREE_OPERAND
argument_list|(
name|sv
argument_list|,
literal|0
argument_list|)
control|)
block|{
name|aref
operator|=
name|get_ref_base_and_extent
argument_list|(
name|sv
argument_list|,
operator|&
name|offset
argument_list|,
operator|&
name|size
argument_list|,
operator|&
name|maxsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|ref
condition|)
break|break;
block|}
if|if
condition|(
name|aref
operator|&&
name|SSA_VAR_P
argument_list|(
name|aref
argument_list|)
operator|&&
name|get_subvars_for_var
argument_list|(
name|aref
argument_list|)
condition|)
return|return
name|unshare_expr
argument_list|(
name|sv
argument_list|)
return|;
if|if
condition|(
operator|!
name|var
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|var
argument_list|)
operator|==
name|INDIRECT_REF
condition|)
block|{
comment|/* If the base is a dereference of a pointer, first check its name memory 	 tag.  If it does not have one, use its symbol memory tag.  */
name|var
operator|=
name|TREE_OPERAND
argument_list|(
name|var
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|var
argument_list|)
operator|!=
name|SSA_NAME
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|SSA_NAME_PTR_INFO
argument_list|(
name|var
argument_list|)
condition|)
block|{
name|tag
operator|=
name|SSA_NAME_PTR_INFO
argument_list|(
name|var
argument_list|)
operator|->
name|name_mem_tag
expr_stmt|;
if|if
condition|(
name|tag
condition|)
return|return
name|tag
return|;
block|}
name|var
operator|=
name|SSA_NAME_VAR
argument_list|(
name|var
argument_list|)
expr_stmt|;
name|tag
operator|=
name|var_ann
argument_list|(
name|var
argument_list|)
operator|->
name|symbol_mem_tag
expr_stmt|;
name|gcc_assert
argument_list|(
name|tag
operator|!=
name|NULL_TREE
argument_list|)
expr_stmt|;
return|return
name|tag
return|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|DECL_P
argument_list|(
name|var
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
name|tag
operator|=
name|var_ann
argument_list|(
name|var
argument_list|)
operator|->
name|symbol_mem_tag
expr_stmt|;
if|if
condition|(
name|tag
condition|)
return|return
name|tag
return|;
return|return
name|var
return|;
block|}
block|}
end_function

begin_comment
comment|/* Copies the reference information from OLD_REF to NEW_REF.  */
end_comment

begin_function
specifier|static
name|void
name|copy_ref_info
parameter_list|(
name|tree
name|new_ref
parameter_list|,
name|tree
name|old_ref
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|old_ref
argument_list|)
operator|==
name|TARGET_MEM_REF
condition|)
name|copy_mem_ref_info
argument_list|(
name|new_ref
argument_list|,
name|old_ref
argument_list|)
expr_stmt|;
else|else
block|{
name|TMR_ORIGINAL
argument_list|(
name|new_ref
argument_list|)
operator|=
name|unshare_and_remove_ssa_names
argument_list|(
name|old_ref
argument_list|)
expr_stmt|;
name|TMR_TAG
argument_list|(
name|new_ref
argument_list|)
operator|=
name|get_ref_tag
argument_list|(
name|old_ref
argument_list|,
name|TMR_ORIGINAL
argument_list|(
name|new_ref
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Rewrites USE (address that is an iv) using candidate CAND.  */
end_comment

begin_function
specifier|static
name|void
name|rewrite_use_address
parameter_list|(
name|struct
name|ivopts_data
modifier|*
name|data
parameter_list|,
name|struct
name|iv_use
modifier|*
name|use
parameter_list|,
name|struct
name|iv_cand
modifier|*
name|cand
parameter_list|)
block|{
name|struct
name|affine_tree_combination
name|aff
decl_stmt|;
name|block_stmt_iterator
name|bsi
init|=
name|bsi_for_stmt
argument_list|(
name|use
operator|->
name|stmt
argument_list|)
decl_stmt|;
name|tree
name|ref
decl_stmt|;
name|get_computation_aff
argument_list|(
name|data
operator|->
name|current_loop
argument_list|,
name|use
argument_list|,
name|cand
argument_list|,
name|use
operator|->
name|stmt
argument_list|,
operator|&
name|aff
argument_list|)
expr_stmt|;
name|unshare_aff_combination
argument_list|(
operator|&
name|aff
argument_list|)
expr_stmt|;
name|ref
operator|=
name|create_mem_ref
argument_list|(
operator|&
name|bsi
argument_list|,
name|TREE_TYPE
argument_list|(
operator|*
name|use
operator|->
name|op_p
argument_list|)
argument_list|,
operator|&
name|aff
argument_list|)
expr_stmt|;
name|copy_ref_info
argument_list|(
name|ref
argument_list|,
operator|*
name|use
operator|->
name|op_p
argument_list|)
expr_stmt|;
operator|*
name|use
operator|->
name|op_p
operator|=
name|ref
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Rewrites USE (the condition such that one of the arguments is an iv) using    candidate CAND.  */
end_comment

begin_function
specifier|static
name|void
name|rewrite_use_compare
parameter_list|(
name|struct
name|ivopts_data
modifier|*
name|data
parameter_list|,
name|struct
name|iv_use
modifier|*
name|use
parameter_list|,
name|struct
name|iv_cand
modifier|*
name|cand
parameter_list|)
block|{
name|tree
name|comp
decl_stmt|;
name|tree
modifier|*
name|op_p
decl_stmt|,
name|cond
decl_stmt|,
name|op
decl_stmt|,
name|stmts
decl_stmt|,
name|bound
decl_stmt|;
name|block_stmt_iterator
name|bsi
init|=
name|bsi_for_stmt
argument_list|(
name|use
operator|->
name|stmt
argument_list|)
decl_stmt|;
name|enum
name|tree_code
name|compare
decl_stmt|;
name|struct
name|cost_pair
modifier|*
name|cp
init|=
name|get_use_iv_cost
argument_list|(
name|data
argument_list|,
name|use
argument_list|,
name|cand
argument_list|)
decl_stmt|;
name|bound
operator|=
name|cp
operator|->
name|value
expr_stmt|;
if|if
condition|(
name|bound
condition|)
block|{
name|tree
name|var
init|=
name|var_at_stmt
argument_list|(
name|data
operator|->
name|current_loop
argument_list|,
name|cand
argument_list|,
name|use
operator|->
name|stmt
argument_list|)
decl_stmt|;
name|tree
name|var_type
init|=
name|TREE_TYPE
argument_list|(
name|var
argument_list|)
decl_stmt|;
name|compare
operator|=
name|iv_elimination_compare
argument_list|(
name|data
argument_list|,
name|use
argument_list|)
expr_stmt|;
name|bound
operator|=
name|fold_convert
argument_list|(
name|var_type
argument_list|,
name|bound
argument_list|)
expr_stmt|;
name|op
operator|=
name|force_gimple_operand
argument_list|(
name|unshare_expr
argument_list|(
name|bound
argument_list|)
argument_list|,
operator|&
name|stmts
argument_list|,
name|true
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|stmts
condition|)
name|bsi_insert_before
argument_list|(
operator|&
name|bsi
argument_list|,
name|stmts
argument_list|,
name|BSI_SAME_STMT
argument_list|)
expr_stmt|;
operator|*
name|use
operator|->
name|op_p
operator|=
name|build2
argument_list|(
name|compare
argument_list|,
name|boolean_type_node
argument_list|,
name|var
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|update_stmt
argument_list|(
name|use
operator|->
name|stmt
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* The induction variable elimination failed; just express the original      giv.  */
name|comp
operator|=
name|get_computation
argument_list|(
name|data
operator|->
name|current_loop
argument_list|,
name|use
argument_list|,
name|cand
argument_list|)
expr_stmt|;
name|cond
operator|=
operator|*
name|use
operator|->
name|op_p
expr_stmt|;
name|op_p
operator|=
operator|&
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|op_p
argument_list|)
operator|!=
name|SSA_NAME
operator|||
name|zero_p
argument_list|(
name|get_iv
argument_list|(
name|data
argument_list|,
operator|*
name|op_p
argument_list|)
operator|->
name|step
argument_list|)
condition|)
name|op_p
operator|=
operator|&
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|op
operator|=
name|force_gimple_operand
argument_list|(
name|comp
argument_list|,
operator|&
name|stmts
argument_list|,
name|true
argument_list|,
name|SSA_NAME_VAR
argument_list|(
operator|*
name|op_p
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|stmts
condition|)
name|bsi_insert_before
argument_list|(
operator|&
name|bsi
argument_list|,
name|stmts
argument_list|,
name|BSI_SAME_STMT
argument_list|)
expr_stmt|;
operator|*
name|op_p
operator|=
name|op
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Rewrites USE using candidate CAND.  */
end_comment

begin_function
specifier|static
name|void
name|rewrite_use
parameter_list|(
name|struct
name|ivopts_data
modifier|*
name|data
parameter_list|,
name|struct
name|iv_use
modifier|*
name|use
parameter_list|,
name|struct
name|iv_cand
modifier|*
name|cand
parameter_list|)
block|{
switch|switch
condition|(
name|use
operator|->
name|type
condition|)
block|{
case|case
name|USE_NONLINEAR_EXPR
case|:
name|rewrite_use_nonlinear_expr
argument_list|(
name|data
argument_list|,
name|use
argument_list|,
name|cand
argument_list|)
expr_stmt|;
break|break;
case|case
name|USE_ADDRESS
case|:
name|rewrite_use_address
argument_list|(
name|data
argument_list|,
name|use
argument_list|,
name|cand
argument_list|)
expr_stmt|;
break|break;
case|case
name|USE_COMPARE
case|:
name|rewrite_use_compare
argument_list|(
name|data
argument_list|,
name|use
argument_list|,
name|cand
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|mark_new_vars_to_rename
argument_list|(
name|use
operator|->
name|stmt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Rewrite the uses using the selected induction variables.  */
end_comment

begin_function
specifier|static
name|void
name|rewrite_uses
parameter_list|(
name|struct
name|ivopts_data
modifier|*
name|data
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
name|struct
name|iv_cand
modifier|*
name|cand
decl_stmt|;
name|struct
name|iv_use
modifier|*
name|use
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_iv_uses
argument_list|(
name|data
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|use
operator|=
name|iv_use
argument_list|(
name|data
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|cand
operator|=
name|use
operator|->
name|selected
expr_stmt|;
name|gcc_assert
argument_list|(
name|cand
argument_list|)
expr_stmt|;
name|rewrite_use
argument_list|(
name|data
argument_list|,
name|use
argument_list|,
name|cand
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Removes the ivs that are not used after rewriting.  */
end_comment

begin_function
specifier|static
name|void
name|remove_unused_ivs
parameter_list|(
name|struct
name|ivopts_data
modifier|*
name|data
parameter_list|)
block|{
name|unsigned
name|j
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|data->relevant
argument_list|,
literal|0
argument_list|,
argument|j
argument_list|,
argument|bi
argument_list|)
block|{
name|struct
name|version_info
modifier|*
name|info
decl_stmt|;
name|info
operator|=
name|ver_info
argument_list|(
name|data
argument_list|,
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|iv
operator|&&
operator|!
name|zero_p
argument_list|(
name|info
operator|->
name|iv
operator|->
name|step
argument_list|)
operator|&&
operator|!
name|info
operator|->
name|inv_id
operator|&&
operator|!
name|info
operator|->
name|iv
operator|->
name|have_use_for
operator|&&
operator|!
name|info
operator|->
name|preserve_biv
condition|)
name|remove_statement
argument_list|(
name|SSA_NAME_DEF_STMT
argument_list|(
name|info
operator|->
name|iv
operator|->
name|ssa_name
argument_list|)
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Frees data allocated by the optimization of a single loop.  */
end_comment

begin_function
specifier|static
name|void
name|free_loop_data
parameter_list|(
name|struct
name|ivopts_data
modifier|*
name|data
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|,
name|j
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
name|tree
name|obj
decl_stmt|;
name|htab_empty
argument_list|(
name|data
operator|->
name|niters
argument_list|)
expr_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|data->relevant
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|bi
argument_list|)
block|{
name|struct
name|version_info
modifier|*
name|info
decl_stmt|;
name|info
operator|=
name|ver_info
argument_list|(
name|data
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|iv
condition|)
name|free
argument_list|(
name|info
operator|->
name|iv
argument_list|)
expr_stmt|;
name|info
operator|->
name|iv
operator|=
name|NULL
expr_stmt|;
name|info
operator|->
name|has_nonlin_use
operator|=
name|false
expr_stmt|;
name|info
operator|->
name|preserve_biv
operator|=
name|false
expr_stmt|;
name|info
operator|->
name|inv_id
operator|=
literal|0
expr_stmt|;
block|}
name|bitmap_clear
argument_list|(
name|data
operator|->
name|relevant
argument_list|)
expr_stmt|;
name|bitmap_clear
argument_list|(
name|data
operator|->
name|important_candidates
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_iv_uses
argument_list|(
name|data
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|iv_use
modifier|*
name|use
init|=
name|iv_use
argument_list|(
name|data
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|free
argument_list|(
name|use
operator|->
name|iv
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|use
operator|->
name|related_cands
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|use
operator|->
name|n_map_members
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|use
operator|->
name|cost_map
index|[
name|j
index|]
operator|.
name|depends_on
condition|)
name|BITMAP_FREE
argument_list|(
name|use
operator|->
name|cost_map
index|[
name|j
index|]
operator|.
name|depends_on
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|use
operator|->
name|cost_map
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|use
argument_list|)
expr_stmt|;
block|}
name|VEC_truncate
argument_list|(
name|iv_use_p
argument_list|,
name|data
operator|->
name|iv_uses
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_iv_cands
argument_list|(
name|data
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|iv_cand
modifier|*
name|cand
init|=
name|iv_cand
argument_list|(
name|data
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|cand
operator|->
name|iv
condition|)
name|free
argument_list|(
name|cand
operator|->
name|iv
argument_list|)
expr_stmt|;
if|if
condition|(
name|cand
operator|->
name|depends_on
condition|)
name|BITMAP_FREE
argument_list|(
name|cand
operator|->
name|depends_on
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cand
argument_list|)
expr_stmt|;
block|}
name|VEC_truncate
argument_list|(
name|iv_cand_p
argument_list|,
name|data
operator|->
name|iv_candidates
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|version_info_size
operator|<
name|num_ssa_names
condition|)
block|{
name|data
operator|->
name|version_info_size
operator|=
literal|2
operator|*
name|num_ssa_names
expr_stmt|;
name|free
argument_list|(
name|data
operator|->
name|version_info
argument_list|)
expr_stmt|;
name|data
operator|->
name|version_info
operator|=
name|XCNEWVEC
argument_list|(
expr|struct
name|version_info
argument_list|,
name|data
operator|->
name|version_info_size
argument_list|)
expr_stmt|;
block|}
name|data
operator|->
name|max_inv_id
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|tree
argument_list|,
name|decl_rtl_to_reset
argument_list|,
name|i
argument_list|,
name|obj
argument_list|)
condition|;
name|i
operator|++
control|)
name|SET_DECL_RTL
argument_list|(
name|obj
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|VEC_truncate
argument_list|(
name|tree
argument_list|,
name|decl_rtl_to_reset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finalizes data structures used by the iv optimization pass.  LOOPS is the    loop tree.  */
end_comment

begin_function
specifier|static
name|void
name|tree_ssa_iv_optimize_finalize
parameter_list|(
name|struct
name|ivopts_data
modifier|*
name|data
parameter_list|)
block|{
name|free_loop_data
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|data
operator|->
name|version_info
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|data
operator|->
name|relevant
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|data
operator|->
name|important_candidates
argument_list|)
expr_stmt|;
name|htab_delete
argument_list|(
name|data
operator|->
name|niters
argument_list|)
expr_stmt|;
name|VEC_free
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
name|decl_rtl_to_reset
argument_list|)
expr_stmt|;
name|VEC_free
argument_list|(
name|iv_use_p
argument_list|,
name|heap
argument_list|,
name|data
operator|->
name|iv_uses
argument_list|)
expr_stmt|;
name|VEC_free
argument_list|(
name|iv_cand_p
argument_list|,
name|heap
argument_list|,
name|data
operator|->
name|iv_candidates
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Optimizes the LOOP.  Returns true if anything changed.  */
end_comment

begin_function
specifier|static
name|bool
name|tree_ssa_iv_optimize_loop
parameter_list|(
name|struct
name|ivopts_data
modifier|*
name|data
parameter_list|,
name|struct
name|loop
modifier|*
name|loop
parameter_list|)
block|{
name|bool
name|changed
init|=
name|false
decl_stmt|;
name|struct
name|iv_ca
modifier|*
name|iv_ca
decl_stmt|;
name|edge
name|exit
decl_stmt|;
name|data
operator|->
name|current_loop
operator|=
name|loop
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Processing loop %d\n"
argument_list|,
name|loop
operator|->
name|num
argument_list|)
expr_stmt|;
name|exit
operator|=
name|single_dom_exit
argument_list|(
name|loop
argument_list|)
expr_stmt|;
if|if
condition|(
name|exit
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"  single exit %d -> %d, exit condition "
argument_list|,
name|exit
operator|->
name|src
operator|->
name|index
argument_list|,
name|exit
operator|->
name|dest
operator|->
name|index
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|last_stmt
argument_list|(
name|exit
operator|->
name|src
argument_list|)
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
comment|/* For each ssa name determines whether it behaves as an induction variable      in some loop.  */
if|if
condition|(
operator|!
name|find_induction_variables
argument_list|(
name|data
argument_list|)
condition|)
goto|goto
name|finish
goto|;
comment|/* Finds interesting uses (item 1).  */
name|find_interesting_uses
argument_list|(
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_iv_uses
argument_list|(
name|data
argument_list|)
operator|>
name|MAX_CONSIDERED_USES
condition|)
goto|goto
name|finish
goto|;
comment|/* Finds candidates for the induction variables (item 2).  */
name|find_iv_candidates
argument_list|(
name|data
argument_list|)
expr_stmt|;
comment|/* Calculates the costs (item 3, part 1).  */
name|determine_use_iv_costs
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|determine_iv_costs
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|determine_set_costs
argument_list|(
name|data
argument_list|)
expr_stmt|;
comment|/* Find the optimal set of induction variables (item 3, part 2).  */
name|iv_ca
operator|=
name|find_optimal_iv_set
argument_list|(
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|iv_ca
condition|)
goto|goto
name|finish
goto|;
name|changed
operator|=
name|true
expr_stmt|;
comment|/* Create the new induction variables (item 4, part 1).  */
name|create_new_ivs
argument_list|(
name|data
argument_list|,
name|iv_ca
argument_list|)
expr_stmt|;
name|iv_ca_free
argument_list|(
operator|&
name|iv_ca
argument_list|)
expr_stmt|;
comment|/* Rewrite the uses (item 4, part 2).  */
name|rewrite_uses
argument_list|(
name|data
argument_list|)
expr_stmt|;
comment|/* Remove the ivs that are unused after rewriting.  */
name|remove_unused_ivs
argument_list|(
name|data
argument_list|)
expr_stmt|;
comment|/* We have changed the structure of induction variables; it might happen      that definitions in the scev database refer to some of them that were      eliminated.  */
name|scev_reset
argument_list|()
expr_stmt|;
name|finish
label|:
name|free_loop_data
argument_list|(
name|data
argument_list|)
expr_stmt|;
return|return
name|changed
return|;
block|}
end_function

begin_comment
comment|/* Main entry point.  Optimizes induction variables in LOOPS.  */
end_comment

begin_function
name|void
name|tree_ssa_iv_optimize
parameter_list|(
name|struct
name|loops
modifier|*
name|loops
parameter_list|)
block|{
name|struct
name|loop
modifier|*
name|loop
decl_stmt|;
name|struct
name|ivopts_data
name|data
decl_stmt|;
name|tree_ssa_iv_optimize_init
argument_list|(
operator|&
name|data
argument_list|)
expr_stmt|;
comment|/* Optimize the loops starting with the innermost ones.  */
name|loop
operator|=
name|loops
operator|->
name|tree_root
expr_stmt|;
while|while
condition|(
name|loop
operator|->
name|inner
condition|)
name|loop
operator|=
name|loop
operator|->
name|inner
expr_stmt|;
comment|/* Scan the loops, inner ones first.  */
while|while
condition|(
name|loop
operator|!=
name|loops
operator|->
name|tree_root
condition|)
block|{
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|flow_loop_dump
argument_list|(
name|loop
argument_list|,
name|dump_file
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tree_ssa_iv_optimize_loop
argument_list|(
operator|&
name|data
argument_list|,
name|loop
argument_list|)
expr_stmt|;
if|if
condition|(
name|loop
operator|->
name|next
condition|)
block|{
name|loop
operator|=
name|loop
operator|->
name|next
expr_stmt|;
while|while
condition|(
name|loop
operator|->
name|inner
condition|)
name|loop
operator|=
name|loop
operator|->
name|inner
expr_stmt|;
block|}
else|else
name|loop
operator|=
name|loop
operator|->
name|outer
expr_stmt|;
block|}
name|tree_ssa_iv_optimize_finalize
argument_list|(
operator|&
name|data
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

