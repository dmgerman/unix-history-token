begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* "Bag-of-pages" zone garbage collector for the GNU compiler.    Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005    Free Software Foundation, Inc.     Contributed by Richard Henderson (rth@redhat.com) and Daniel Berlin    (dberlin@dberlin.org).  Rewritten by Daniel Jacobowitz<dan@codesourcery.com>.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"varray.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"params.h"
end_include

begin_include
include|#
directive|include
file|"bitmap.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|ENABLE_VALGRIND_CHECKING
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_VALGRIND_MEMCHECK_H
end_ifdef

begin_include
include|#
directive|include
file|<valgrind/memcheck.h>
end_include

begin_elif
elif|#
directive|elif
name|defined
name|HAVE_MEMCHECK_H
end_elif

begin_include
include|#
directive|include
file|<memcheck.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<valgrind.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* Avoid #ifdef:s when we can help it.  */
end_comment

begin_define
define|#
directive|define
name|VALGRIND_DISCARD
parameter_list|(
name|x
parameter_list|)
end_define

begin_define
define|#
directive|define
name|VALGRIND_MALLOCLIKE_BLOCK
parameter_list|(
name|w
parameter_list|,
name|x
parameter_list|,
name|y
parameter_list|,
name|z
parameter_list|)
end_define

begin_define
define|#
directive|define
name|VALGRIND_FREELIKE_BLOCK
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Prefer MAP_ANON(YMOUS) to /dev/zero, since we don't need to keep a    file open.  Prefer either to valloc.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_MMAP_ANON
end_ifdef

begin_undef
undef|#
directive|undef
name|HAVE_MMAP_DEV_ZERO
end_undef

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|MAP_FAILED
end_ifndef

begin_define
define|#
directive|define
name|MAP_FAILED
value|-1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|MAP_ANONYMOUS
argument_list|)
operator|&&
name|defined
argument_list|(
name|MAP_ANON
argument_list|)
end_if

begin_define
define|#
directive|define
name|MAP_ANONYMOUS
value|MAP_ANON
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|USING_MMAP
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_MMAP_DEV_ZERO
end_ifdef

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|MAP_FAILED
end_ifndef

begin_define
define|#
directive|define
name|MAP_FAILED
value|-1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|USING_MMAP
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|USING_MMAP
end_ifndef

begin_error
error|#
directive|error
error|Zone collector requires mmap
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|(
name|GCC_VERSION
operator|<
literal|3001
operator|)
end_if

begin_define
define|#
directive|define
name|prefetch
parameter_list|(
name|X
parameter_list|)
value|((void) X)
end_define

begin_define
define|#
directive|define
name|prefetchw
parameter_list|(
name|X
parameter_list|)
value|((void) X)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|prefetch
parameter_list|(
name|X
parameter_list|)
value|__builtin_prefetch (X)
end_define

begin_define
define|#
directive|define
name|prefetchw
parameter_list|(
name|X
parameter_list|)
value|__builtin_prefetch (X, 1, 3)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FUTURE NOTES:     If we track inter-zone pointers, we can mark single zones at a    time.     If we have a zone where we guarantee no inter-zone pointers, we    could mark that zone separately.     The garbage zone should not be marked, and we should return 1 in    ggc_set_mark for any object in the garbage zone, which cuts off    marking quickly.  */
end_comment

begin_comment
comment|/* Strategy:     This garbage-collecting allocator segregates objects into zones.    It also segregates objects into "large" and "small" bins.  Large    objects are greater than page size.     Pages for small objects are broken up into chunks.  The page has    a bitmap which marks the start position of each chunk (whether    allocated or free).  Free chunks are on one of the zone's free    lists and contain a pointer to the next free chunk.  Chunks in    most of the free lists have a fixed size determined by the    free list.  Chunks in the "other" sized free list have their size    stored right after their chain pointer.     Empty pages (of all sizes) are kept on a single page cache list,    and are considered first when new pages are required; they are    deallocated at the start of the next collection if they haven't    been recycled by then.  The free page list is currently per-zone.  */
end_comment

begin_comment
comment|/* Define GGC_DEBUG_LEVEL to print debugging information.      0: No debugging output.      1: GC statistics only.      2: Page-entry allocations/deallocations as well.      3: Object allocations as well.      4: Object marks as well.  */
end_comment

begin_define
define|#
directive|define
name|GGC_DEBUG_LEVEL
value|(0)
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|HOST_BITS_PER_PTR
end_ifndef

begin_define
define|#
directive|define
name|HOST_BITS_PER_PTR
value|HOST_BITS_PER_LONG
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This structure manages small free chunks.  The SIZE field is only    initialized if the chunk is in the "other" sized free list.  Large    chunks are allocated one at a time to their own page, and so don't    come in here.  */
end_comment

begin_struct
struct|struct
name|alloc_chunk
block|{
name|struct
name|alloc_chunk
modifier|*
name|next_free
decl_stmt|;
name|unsigned
name|int
name|size
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The size of the fixed-size portion of a small page descriptor.  */
end_comment

begin_define
define|#
directive|define
name|PAGE_OVERHEAD
value|(offsetof (struct small_page_entry, alloc_bits))
end_define

begin_comment
comment|/* The collector's idea of the page size.  This must be a power of two    no larger than the system page size, because pages must be aligned    to this amount and are tracked at this granularity in the page    table.  We choose a size at compile time for efficiency.     We could make a better guess at compile time if PAGE_SIZE is a    constant in system headers, and PAGE_SHIFT is defined...  */
end_comment

begin_define
define|#
directive|define
name|GGC_PAGE_SIZE
value|4096
end_define

begin_define
define|#
directive|define
name|GGC_PAGE_MASK
value|(GGC_PAGE_SIZE - 1)
end_define

begin_define
define|#
directive|define
name|GGC_PAGE_SHIFT
value|12
end_define

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Alternative definitions which use the runtime page size.  */
end_comment

begin_define
define|#
directive|define
name|GGC_PAGE_SIZE
value|G.pagesize
end_define

begin_define
define|#
directive|define
name|GGC_PAGE_MASK
value|G.page_mask
end_define

begin_define
define|#
directive|define
name|GGC_PAGE_SHIFT
value|G.lg_pagesize
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The size of a small page managed by the garbage collector.  This    must currently be GGC_PAGE_SIZE, but with a few changes could    be any multiple of it to reduce certain kinds of overhead.  */
end_comment

begin_define
define|#
directive|define
name|SMALL_PAGE_SIZE
value|GGC_PAGE_SIZE
end_define

begin_comment
comment|/* Free bin information.  These numbers may be in need of re-tuning.    In general, decreasing the number of free bins would seem to    increase the time it takes to allocate... */
end_comment

begin_comment
comment|/* FIXME: We can't use anything but MAX_ALIGNMENT for the bin size    today.  */
end_comment

begin_define
define|#
directive|define
name|NUM_FREE_BINS
value|64
end_define

begin_define
define|#
directive|define
name|FREE_BIN_DELTA
value|MAX_ALIGNMENT
end_define

begin_define
define|#
directive|define
name|SIZE_BIN_DOWN
parameter_list|(
name|SIZE
parameter_list|)
value|((SIZE) / FREE_BIN_DELTA)
end_define

begin_comment
comment|/* Allocation and marking parameters.  */
end_comment

begin_comment
comment|/* The smallest allocatable unit to keep track of.  */
end_comment

begin_define
define|#
directive|define
name|BYTES_PER_ALLOC_BIT
value|MAX_ALIGNMENT
end_define

begin_comment
comment|/* The smallest markable unit.  If we require each allocated object    to contain at least two allocatable units, we can use half as many    bits for the mark bitmap.  But this adds considerable complexity    to sweeping.  */
end_comment

begin_define
define|#
directive|define
name|BYTES_PER_MARK_BIT
value|BYTES_PER_ALLOC_BIT
end_define

begin_define
define|#
directive|define
name|BYTES_PER_MARK_WORD
value|(8 * BYTES_PER_MARK_BIT * sizeof (mark_type))
end_define

begin_comment
comment|/* We use this structure to determine the alignment required for    allocations.     There are several things wrong with this estimation of alignment.     The maximum alignment for a structure is often less than the    maximum alignment for a basic data type; for instance, on some    targets long long must be aligned to sizeof (int) in a structure    and sizeof (long long) in a variable.  i386-linux is one example;    Darwin is another (sometimes, depending on the compiler in use).     Also, long double is not included.  Nothing in GCC uses long    double, so we assume that this is OK.  On powerpc-darwin, adding    long double would bring the maximum alignment up to 16 bytes,    and until we need long double (or to vectorize compiler operations)    that's painfully wasteful.  This will need to change, some day.  */
end_comment

begin_struct
struct|struct
name|max_alignment
block|{
name|char
name|c
decl_stmt|;
union|union
block|{
name|HOST_WIDEST_INT
name|i
decl_stmt|;
name|double
name|d
decl_stmt|;
block|}
name|u
union|;
block|}
struct|;
end_struct

begin_comment
comment|/* The biggest alignment required.  */
end_comment

begin_define
define|#
directive|define
name|MAX_ALIGNMENT
value|(offsetof (struct max_alignment, u))
end_define

begin_comment
comment|/* Compute the smallest multiple of F that is>= X.  */
end_comment

begin_define
define|#
directive|define
name|ROUND_UP
parameter_list|(
name|x
parameter_list|,
name|f
parameter_list|)
value|(CEIL (x, f) * (f))
end_define

begin_comment
comment|/* Types to use for the allocation and mark bitmaps.  It might be    a good idea to add ffsl to libiberty and use unsigned long    instead; that could speed us up where long is wider than int.  */
end_comment

begin_typedef
typedef|typedef
name|unsigned
name|int
name|alloc_type
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|unsigned
name|int
name|mark_type
typedef|;
end_typedef

begin_define
define|#
directive|define
name|alloc_ffs
parameter_list|(
name|x
parameter_list|)
value|ffs(x)
end_define

begin_comment
comment|/* A page_entry records the status of an allocation page.  This is the    common data between all three kinds of pages - small, large, and    PCH.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|page_entry
block|{
comment|/* The address at which the memory is allocated.  */
name|char
modifier|*
name|page
decl_stmt|;
comment|/* The zone that this page entry belongs to.  */
name|struct
name|alloc_zone
modifier|*
name|zone
decl_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
comment|/* How many collections we've survived.  */
name|size_t
name|survived
decl_stmt|;
endif|#
directive|endif
comment|/* Does this page contain small objects, or one large object?  */
name|bool
name|large_p
decl_stmt|;
comment|/* Is this page part of the loaded PCH?  */
name|bool
name|pch_p
decl_stmt|;
block|}
name|page_entry
typedef|;
end_typedef

begin_comment
comment|/* Additional data needed for small pages.  */
end_comment

begin_struct
struct|struct
name|small_page_entry
block|{
name|struct
name|page_entry
name|common
decl_stmt|;
comment|/* The next small page entry, or NULL if this is the last.  */
name|struct
name|small_page_entry
modifier|*
name|next
decl_stmt|;
comment|/* If currently marking this zone, a pointer to the mark bits      for this page.  If we aren't currently marking this zone,      this pointer may be stale (pointing to freed memory).  */
name|mark_type
modifier|*
name|mark_bits
decl_stmt|;
comment|/* The allocation bitmap.  This array extends far enough to have      one bit for every BYTES_PER_ALLOC_BIT bytes in the page.  */
name|alloc_type
name|alloc_bits
index|[
literal|1
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Additional data needed for large pages.  */
end_comment

begin_struct
struct|struct
name|large_page_entry
block|{
name|struct
name|page_entry
name|common
decl_stmt|;
comment|/* The next large page entry, or NULL if this is the last.  */
name|struct
name|large_page_entry
modifier|*
name|next
decl_stmt|;
comment|/* The number of bytes allocated, not including the page entry.  */
name|size_t
name|bytes
decl_stmt|;
comment|/* The previous page in the list, so that we can unlink this one.  */
name|struct
name|large_page_entry
modifier|*
name|prev
decl_stmt|;
comment|/* During marking, is this object marked?  */
name|bool
name|mark_p
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* A two-level tree is used to look up the page-entry for a given    pointer.  Two chunks of the pointer's bits are extracted to index    the first and second levels of the tree, as follows:  				   HOST_PAGE_SIZE_BITS 			   32		|      |        msb +----------------+----+------+------+ lsb 			    |    |      | 			 PAGE_L1_BITS   | 				 |      | 			       PAGE_L2_BITS     The bottommost HOST_PAGE_SIZE_BITS are ignored, since page-entry    pages are aligned on system page boundaries.  The next most    significant PAGE_L2_BITS and PAGE_L1_BITS are the second and first    index values in the lookup table, respectively.     For 32-bit architectures and the settings below, there are no    leftover bits.  For architectures with wider pointers, the lookup    tree points to a list of pages, which must be scanned to find the    correct one.  */
end_comment

begin_define
define|#
directive|define
name|PAGE_L1_BITS
value|(8)
end_define

begin_define
define|#
directive|define
name|PAGE_L2_BITS
value|(32 - PAGE_L1_BITS - GGC_PAGE_SHIFT)
end_define

begin_define
define|#
directive|define
name|PAGE_L1_SIZE
value|((size_t) 1<< PAGE_L1_BITS)
end_define

begin_define
define|#
directive|define
name|PAGE_L2_SIZE
value|((size_t) 1<< PAGE_L2_BITS)
end_define

begin_define
define|#
directive|define
name|LOOKUP_L1
parameter_list|(
name|p
parameter_list|)
define|\
value|(((size_t) (p)>> (32 - PAGE_L1_BITS))& ((1<< PAGE_L1_BITS) - 1))
end_define

begin_define
define|#
directive|define
name|LOOKUP_L2
parameter_list|(
name|p
parameter_list|)
define|\
value|(((size_t) (p)>> GGC_PAGE_SHIFT)& ((1<< PAGE_L2_BITS) - 1))
end_define

begin_if
if|#
directive|if
name|HOST_BITS_PER_PTR
operator|<=
literal|32
end_if

begin_comment
comment|/* On 32-bit hosts, we use a two level page table, as pictured above.  */
end_comment

begin_typedef
typedef|typedef
name|page_entry
modifier|*
modifier|*
name|page_table
index|[
name|PAGE_L1_SIZE
index|]
typedef|;
end_typedef

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* On 64-bit hosts, we use the same two level page tables plus a linked    list that disambiguates the top 32-bits.  There will almost always be    exactly one entry in the list.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|page_table_chain
block|{
name|struct
name|page_table_chain
modifier|*
name|next
decl_stmt|;
name|size_t
name|high_bits
decl_stmt|;
name|page_entry
modifier|*
modifier|*
name|table
index|[
name|PAGE_L1_SIZE
index|]
decl_stmt|;
block|}
typedef|*
name|page_table
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The global variables.  */
end_comment

begin_struct
specifier|static
struct|struct
name|globals
block|{
comment|/* The linked list of zones.  */
name|struct
name|alloc_zone
modifier|*
name|zones
decl_stmt|;
comment|/* Lookup table for associating allocation pages with object addresses.  */
name|page_table
name|lookup
decl_stmt|;
comment|/* The system's page size, and related constants.  */
name|size_t
name|pagesize
decl_stmt|;
name|size_t
name|lg_pagesize
decl_stmt|;
name|size_t
name|page_mask
decl_stmt|;
comment|/* The size to allocate for a small page entry.  This includes      the size of the structure and the size of the allocation      bitmap.  */
name|size_t
name|small_page_overhead
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_MMAP_DEV_ZERO
argument_list|)
comment|/* A file descriptor open to /dev/zero for reading.  */
name|int
name|dev_zero_fd
decl_stmt|;
endif|#
directive|endif
comment|/* Allocate pages in chunks of this size, to throttle calls to memory      allocation routines.  The first page is used, the rest go onto the      free list.  */
name|size_t
name|quire_size
decl_stmt|;
comment|/* The file descriptor for debugging output.  */
name|FILE
modifier|*
name|debug_file
decl_stmt|;
block|}
name|G
struct|;
end_struct

begin_comment
comment|/* A zone allocation structure.  There is one of these for every    distinct allocation zone.  */
end_comment

begin_struct
struct|struct
name|alloc_zone
block|{
comment|/* The most recent free chunk is saved here, instead of in the linked      free list, to decrease list manipulation.  It is most likely that we      will want this one.  */
name|char
modifier|*
name|cached_free
decl_stmt|;
name|size_t
name|cached_free_size
decl_stmt|;
comment|/* Linked lists of free storage.  Slots 1 ... NUM_FREE_BINS have chunks of size      FREE_BIN_DELTA.  All other chunks are in slot 0.  */
name|struct
name|alloc_chunk
modifier|*
name|free_chunks
index|[
name|NUM_FREE_BINS
operator|+
literal|1
index|]
decl_stmt|;
comment|/* The highest bin index which might be non-empty.  It may turn out      to be empty, in which case we have to search downwards.  */
name|size_t
name|high_free_bin
decl_stmt|;
comment|/* Bytes currently allocated in this zone.  */
name|size_t
name|allocated
decl_stmt|;
comment|/* Linked list of the small pages in this zone.  */
name|struct
name|small_page_entry
modifier|*
name|pages
decl_stmt|;
comment|/* Doubly linked list of large pages in this zone.  */
name|struct
name|large_page_entry
modifier|*
name|large_pages
decl_stmt|;
comment|/* If we are currently marking this zone, a pointer to the mark bits.  */
name|mark_type
modifier|*
name|mark_bits
decl_stmt|;
comment|/* Name of the zone.  */
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* The number of small pages currently allocated in this zone.  */
name|size_t
name|n_small_pages
decl_stmt|;
comment|/* Bytes allocated at the end of the last collection.  */
name|size_t
name|allocated_last_gc
decl_stmt|;
comment|/* Total amount of memory mapped.  */
name|size_t
name|bytes_mapped
decl_stmt|;
comment|/* A cache of free system pages.  */
name|struct
name|small_page_entry
modifier|*
name|free_pages
decl_stmt|;
comment|/* Next zone in the linked list of zones.  */
name|struct
name|alloc_zone
modifier|*
name|next_zone
decl_stmt|;
comment|/* True if this zone was collected during this collection.  */
name|bool
name|was_collected
decl_stmt|;
comment|/* True if this zone should be destroyed after the next collection.  */
name|bool
name|dead
decl_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
struct|struct
block|{
comment|/* Total memory allocated with ggc_alloc.  */
name|unsigned
name|long
name|long
name|total_allocated
decl_stmt|;
comment|/* Total overhead for memory to be allocated with ggc_alloc.  */
name|unsigned
name|long
name|long
name|total_overhead
decl_stmt|;
comment|/* Total allocations and overhead for sizes less than 32, 64 and 128.        These sizes are interesting because they are typical cache line        sizes.  */
name|unsigned
name|long
name|long
name|total_allocated_under32
decl_stmt|;
name|unsigned
name|long
name|long
name|total_overhead_under32
decl_stmt|;
name|unsigned
name|long
name|long
name|total_allocated_under64
decl_stmt|;
name|unsigned
name|long
name|long
name|total_overhead_under64
decl_stmt|;
name|unsigned
name|long
name|long
name|total_allocated_under128
decl_stmt|;
name|unsigned
name|long
name|long
name|total_overhead_under128
decl_stmt|;
block|}
name|stats
struct|;
endif|#
directive|endif
block|}
name|main_zone
struct|;
end_struct

begin_comment
comment|/* Some default zones.  */
end_comment

begin_decl_stmt
name|struct
name|alloc_zone
name|rtl_zone
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|alloc_zone
name|tree_zone
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|alloc_zone
name|tree_id_zone
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The PCH zone does not need a normal zone structure, and it does    not live on the linked list of zones.  */
end_comment

begin_struct
struct|struct
name|pch_zone
block|{
comment|/* The start of the PCH zone.  NULL if there is none.  */
name|char
modifier|*
name|page
decl_stmt|;
comment|/* The end of the PCH zone.  NULL if there is none.  */
name|char
modifier|*
name|end
decl_stmt|;
comment|/* The size of the PCH zone.  0 if there is none.  */
name|size_t
name|bytes
decl_stmt|;
comment|/* The allocation bitmap for the PCH zone.  */
name|alloc_type
modifier|*
name|alloc_bits
decl_stmt|;
comment|/* If we are currently marking, the mark bitmap for the PCH zone.      When it is first read in, we could avoid marking the PCH,      because it will not contain any pointers to GC memory outside      of the PCH; however, the PCH is currently mapped as writable,      so we must mark it in case new pointers are added.  */
name|mark_type
modifier|*
name|mark_bits
decl_stmt|;
block|}
name|pch_zone
struct|;
end_struct

begin_ifdef
ifdef|#
directive|ifdef
name|USING_MMAP
end_ifdef

begin_function_decl
specifier|static
name|char
modifier|*
name|alloc_anon
parameter_list|(
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|struct
name|alloc_zone
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|struct
name|small_page_entry
modifier|*
name|alloc_small_page
parameter_list|(
name|struct
name|alloc_zone
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|large_page_entry
modifier|*
name|alloc_large_page
parameter_list|(
name|size_t
parameter_list|,
name|struct
name|alloc_zone
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_chunk
parameter_list|(
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|struct
name|alloc_zone
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_small_page
parameter_list|(
name|struct
name|small_page_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_large_page
parameter_list|(
name|struct
name|large_page_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|release_pages
parameter_list|(
name|struct
name|alloc_zone
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sweep_pages
parameter_list|(
name|struct
name|alloc_zone
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|ggc_collect_1
parameter_list|(
name|struct
name|alloc_zone
modifier|*
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|new_ggc_zone_1
parameter_list|(
name|struct
name|alloc_zone
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Traverse the page table and find the entry for a page.    Die (probably) if the object wasn't allocated via GC.  */
end_comment

begin_function
specifier|static
specifier|inline
name|page_entry
modifier|*
name|lookup_page_table_entry
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|)
block|{
name|page_entry
modifier|*
modifier|*
modifier|*
name|base
decl_stmt|;
name|size_t
name|L1
decl_stmt|,
name|L2
decl_stmt|;
if|#
directive|if
name|HOST_BITS_PER_PTR
operator|<=
literal|32
name|base
operator|=
operator|&
name|G
operator|.
name|lookup
index|[
literal|0
index|]
expr_stmt|;
else|#
directive|else
name|page_table
name|table
init|=
name|G
operator|.
name|lookup
decl_stmt|;
name|size_t
name|high_bits
init|=
operator|(
name|size_t
operator|)
name|p
operator|&
operator|~
operator|(
name|size_t
operator|)
literal|0xffffffff
decl_stmt|;
while|while
condition|(
name|table
operator|->
name|high_bits
operator|!=
name|high_bits
condition|)
name|table
operator|=
name|table
operator|->
name|next
expr_stmt|;
name|base
operator|=
operator|&
name|table
operator|->
name|table
index|[
literal|0
index|]
expr_stmt|;
endif|#
directive|endif
comment|/* Extract the level 1 and 2 indices.  */
name|L1
operator|=
name|LOOKUP_L1
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|L2
operator|=
name|LOOKUP_L2
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|base
index|[
name|L1
index|]
index|[
name|L2
index|]
return|;
block|}
end_function

begin_comment
comment|/* Set the page table entry for the page that starts at P.  If ENTRY    is NULL, clear the entry.  */
end_comment

begin_function
specifier|static
name|void
name|set_page_table_entry
parameter_list|(
name|void
modifier|*
name|p
parameter_list|,
name|page_entry
modifier|*
name|entry
parameter_list|)
block|{
name|page_entry
modifier|*
modifier|*
modifier|*
name|base
decl_stmt|;
name|size_t
name|L1
decl_stmt|,
name|L2
decl_stmt|;
if|#
directive|if
name|HOST_BITS_PER_PTR
operator|<=
literal|32
name|base
operator|=
operator|&
name|G
operator|.
name|lookup
index|[
literal|0
index|]
expr_stmt|;
else|#
directive|else
name|page_table
name|table
decl_stmt|;
name|size_t
name|high_bits
init|=
operator|(
name|size_t
operator|)
name|p
operator|&
operator|~
operator|(
name|size_t
operator|)
literal|0xffffffff
decl_stmt|;
for|for
control|(
name|table
operator|=
name|G
operator|.
name|lookup
init|;
name|table
condition|;
name|table
operator|=
name|table
operator|->
name|next
control|)
if|if
condition|(
name|table
operator|->
name|high_bits
operator|==
name|high_bits
condition|)
goto|goto
name|found
goto|;
comment|/* Not found -- allocate a new table.  */
name|table
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|table
argument_list|)
argument_list|)
expr_stmt|;
name|table
operator|->
name|next
operator|=
name|G
operator|.
name|lookup
expr_stmt|;
name|table
operator|->
name|high_bits
operator|=
name|high_bits
expr_stmt|;
name|G
operator|.
name|lookup
operator|=
name|table
expr_stmt|;
name|found
label|:
name|base
operator|=
operator|&
name|table
operator|->
name|table
index|[
literal|0
index|]
expr_stmt|;
endif|#
directive|endif
comment|/* Extract the level 1 and 2 indices.  */
name|L1
operator|=
name|LOOKUP_L1
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|L2
operator|=
name|LOOKUP_L2
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|base
index|[
name|L1
index|]
operator|==
name|NULL
condition|)
name|base
index|[
name|L1
index|]
operator|=
name|xcalloc
argument_list|(
name|PAGE_L2_SIZE
argument_list|,
sizeof|sizeof
argument_list|(
name|page_entry
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|base
index|[
name|L1
index|]
index|[
name|L2
index|]
operator|=
name|entry
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Find the page table entry associated with OBJECT.  */
end_comment

begin_function
specifier|static
specifier|inline
name|struct
name|page_entry
modifier|*
name|zone_get_object_page
parameter_list|(
specifier|const
name|void
modifier|*
name|object
parameter_list|)
block|{
return|return
name|lookup_page_table_entry
argument_list|(
name|object
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Find which element of the alloc_bits array OBJECT should be    recorded in.  */
end_comment

begin_function
specifier|static
specifier|inline
name|unsigned
name|int
name|zone_get_object_alloc_word
parameter_list|(
specifier|const
name|void
modifier|*
name|object
parameter_list|)
block|{
return|return
operator|(
operator|(
operator|(
name|size_t
operator|)
name|object
operator|&
operator|(
name|GGC_PAGE_SIZE
operator|-
literal|1
operator|)
operator|)
operator|/
operator|(
literal|8
operator|*
sizeof|sizeof
argument_list|(
name|alloc_type
argument_list|)
operator|*
name|BYTES_PER_ALLOC_BIT
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Find which bit of the appropriate word in the alloc_bits array    OBJECT should be recorded in.  */
end_comment

begin_function
specifier|static
specifier|inline
name|unsigned
name|int
name|zone_get_object_alloc_bit
parameter_list|(
specifier|const
name|void
modifier|*
name|object
parameter_list|)
block|{
return|return
operator|(
operator|(
operator|(
name|size_t
operator|)
name|object
operator|/
name|BYTES_PER_ALLOC_BIT
operator|)
operator|%
operator|(
literal|8
operator|*
sizeof|sizeof
argument_list|(
name|alloc_type
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Find which element of the mark_bits array OBJECT should be recorded    in.  */
end_comment

begin_function
specifier|static
specifier|inline
name|unsigned
name|int
name|zone_get_object_mark_word
parameter_list|(
specifier|const
name|void
modifier|*
name|object
parameter_list|)
block|{
return|return
operator|(
operator|(
operator|(
name|size_t
operator|)
name|object
operator|&
operator|(
name|GGC_PAGE_SIZE
operator|-
literal|1
operator|)
operator|)
operator|/
operator|(
literal|8
operator|*
sizeof|sizeof
argument_list|(
name|mark_type
argument_list|)
operator|*
name|BYTES_PER_MARK_BIT
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Find which bit of the appropriate word in the mark_bits array    OBJECT should be recorded in.  */
end_comment

begin_function
specifier|static
specifier|inline
name|unsigned
name|int
name|zone_get_object_mark_bit
parameter_list|(
specifier|const
name|void
modifier|*
name|object
parameter_list|)
block|{
return|return
operator|(
operator|(
operator|(
name|size_t
operator|)
name|object
operator|/
name|BYTES_PER_MARK_BIT
operator|)
operator|%
operator|(
literal|8
operator|*
sizeof|sizeof
argument_list|(
name|mark_type
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Set the allocation bit corresponding to OBJECT in its page's    bitmap.  Used to split this object from the preceding one.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|zone_set_object_alloc_bit
parameter_list|(
specifier|const
name|void
modifier|*
name|object
parameter_list|)
block|{
name|struct
name|small_page_entry
modifier|*
name|page
init|=
operator|(
expr|struct
name|small_page_entry
operator|*
operator|)
name|zone_get_object_page
argument_list|(
name|object
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|start_word
init|=
name|zone_get_object_alloc_word
argument_list|(
name|object
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|start_bit
init|=
name|zone_get_object_alloc_bit
argument_list|(
name|object
argument_list|)
decl_stmt|;
name|page
operator|->
name|alloc_bits
index|[
name|start_word
index|]
operator||=
literal|1L
operator|<<
name|start_bit
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Clear the allocation bit corresponding to OBJECT in PAGE's    bitmap.  Used to coalesce this object with the preceding    one.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|zone_clear_object_alloc_bit
parameter_list|(
name|struct
name|small_page_entry
modifier|*
name|page
parameter_list|,
specifier|const
name|void
modifier|*
name|object
parameter_list|)
block|{
name|unsigned
name|int
name|start_word
init|=
name|zone_get_object_alloc_word
argument_list|(
name|object
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|start_bit
init|=
name|zone_get_object_alloc_bit
argument_list|(
name|object
argument_list|)
decl_stmt|;
comment|/* Would xor be quicker?  */
name|page
operator|->
name|alloc_bits
index|[
name|start_word
index|]
operator|&=
operator|~
operator|(
literal|1L
operator|<<
name|start_bit
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Find the size of the object which starts at START_WORD and    START_BIT in ALLOC_BITS, which is at most MAX_SIZE bytes.    Helper function for ggc_get_size and zone_find_object_size.  */
end_comment

begin_function
specifier|static
specifier|inline
name|size_t
name|zone_object_size_1
parameter_list|(
name|alloc_type
modifier|*
name|alloc_bits
parameter_list|,
name|size_t
name|start_word
parameter_list|,
name|size_t
name|start_bit
parameter_list|,
name|size_t
name|max_size
parameter_list|)
block|{
name|size_t
name|size
decl_stmt|;
name|alloc_type
name|alloc_word
decl_stmt|;
name|int
name|indx
decl_stmt|;
comment|/* Load the first word.  */
name|alloc_word
operator|=
name|alloc_bits
index|[
name|start_word
operator|++
index|]
expr_stmt|;
comment|/* If that was the last bit in this word, we'll want to continue      with the next word.  Otherwise, handle the rest of this word.  */
if|if
condition|(
name|start_bit
condition|)
block|{
name|indx
operator|=
name|alloc_ffs
argument_list|(
name|alloc_word
operator|>>
name|start_bit
argument_list|)
expr_stmt|;
if|if
condition|(
name|indx
condition|)
comment|/* indx is 1-based.  We started at the bit after the object's 	   start, but we also ended at the bit after the object's end. 	   It cancels out.  */
return|return
name|indx
operator|*
name|BYTES_PER_ALLOC_BIT
return|;
comment|/* The extra 1 accounts for the starting unit, before start_bit.  */
name|size
operator|=
operator|(
sizeof|sizeof
argument_list|(
name|alloc_type
argument_list|)
operator|*
literal|8
operator|-
name|start_bit
operator|+
literal|1
operator|)
operator|*
name|BYTES_PER_ALLOC_BIT
expr_stmt|;
if|if
condition|(
name|size
operator|>=
name|max_size
condition|)
return|return
name|max_size
return|;
name|alloc_word
operator|=
name|alloc_bits
index|[
name|start_word
operator|++
index|]
expr_stmt|;
block|}
else|else
name|size
operator|=
name|BYTES_PER_ALLOC_BIT
expr_stmt|;
while|while
condition|(
name|alloc_word
operator|==
literal|0
condition|)
block|{
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|alloc_type
argument_list|)
operator|*
literal|8
operator|*
name|BYTES_PER_ALLOC_BIT
expr_stmt|;
if|if
condition|(
name|size
operator|>=
name|max_size
condition|)
return|return
name|max_size
return|;
name|alloc_word
operator|=
name|alloc_bits
index|[
name|start_word
operator|++
index|]
expr_stmt|;
block|}
name|indx
operator|=
name|alloc_ffs
argument_list|(
name|alloc_word
argument_list|)
expr_stmt|;
return|return
name|size
operator|+
operator|(
name|indx
operator|-
literal|1
operator|)
operator|*
name|BYTES_PER_ALLOC_BIT
return|;
block|}
end_function

begin_comment
comment|/* Find the size of OBJECT on small page PAGE.  */
end_comment

begin_function
specifier|static
specifier|inline
name|size_t
name|zone_find_object_size
parameter_list|(
name|struct
name|small_page_entry
modifier|*
name|page
parameter_list|,
specifier|const
name|void
modifier|*
name|object
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|object_midptr
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|object
operator|+
name|BYTES_PER_ALLOC_BIT
decl_stmt|;
name|unsigned
name|int
name|start_word
init|=
name|zone_get_object_alloc_word
argument_list|(
name|object_midptr
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|start_bit
init|=
name|zone_get_object_alloc_bit
argument_list|(
name|object_midptr
argument_list|)
decl_stmt|;
name|size_t
name|max_size
init|=
operator|(
name|page
operator|->
name|common
operator|.
name|page
operator|+
name|SMALL_PAGE_SIZE
operator|-
operator|(
name|char
operator|*
operator|)
name|object
operator|)
decl_stmt|;
return|return
name|zone_object_size_1
argument_list|(
name|page
operator|->
name|alloc_bits
argument_list|,
name|start_word
argument_list|,
name|start_bit
argument_list|,
name|max_size
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Allocate the mark bits for every zone, and set the pointers on each    page.  */
end_comment

begin_function
specifier|static
name|void
name|zone_allocate_marks
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|alloc_zone
modifier|*
name|zone
decl_stmt|;
for|for
control|(
name|zone
operator|=
name|G
operator|.
name|zones
init|;
name|zone
condition|;
name|zone
operator|=
name|zone
operator|->
name|next_zone
control|)
block|{
name|struct
name|small_page_entry
modifier|*
name|page
decl_stmt|;
name|mark_type
modifier|*
name|cur_marks
decl_stmt|;
name|size_t
name|mark_words
decl_stmt|,
name|mark_words_per_page
decl_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
name|size_t
name|n
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
name|mark_words_per_page
operator|=
operator|(
name|GGC_PAGE_SIZE
operator|+
name|BYTES_PER_MARK_WORD
operator|-
literal|1
operator|)
operator|/
name|BYTES_PER_MARK_WORD
expr_stmt|;
name|mark_words
operator|=
name|zone
operator|->
name|n_small_pages
operator|*
name|mark_words_per_page
expr_stmt|;
name|zone
operator|->
name|mark_bits
operator|=
operator|(
name|mark_type
operator|*
operator|)
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|mark_type
argument_list|)
argument_list|,
name|mark_words
argument_list|)
expr_stmt|;
name|cur_marks
operator|=
name|zone
operator|->
name|mark_bits
expr_stmt|;
for|for
control|(
name|page
operator|=
name|zone
operator|->
name|pages
init|;
name|page
condition|;
name|page
operator|=
name|page
operator|->
name|next
control|)
block|{
name|page
operator|->
name|mark_bits
operator|=
name|cur_marks
expr_stmt|;
name|cur_marks
operator|+=
name|mark_words_per_page
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
name|n
operator|++
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
name|gcc_assert
argument_list|(
name|n
operator|==
name|zone
operator|->
name|n_small_pages
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* We don't collect the PCH zone, but we do have to mark it      (for now).  */
if|if
condition|(
name|pch_zone
operator|.
name|bytes
condition|)
name|pch_zone
operator|.
name|mark_bits
operator|=
operator|(
name|mark_type
operator|*
operator|)
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|mark_type
argument_list|)
argument_list|,
name|CEIL
argument_list|(
name|pch_zone
operator|.
name|bytes
argument_list|,
name|BYTES_PER_MARK_WORD
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* After marking and sweeping, release the memory used for mark bits.  */
end_comment

begin_function
specifier|static
name|void
name|zone_free_marks
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|alloc_zone
modifier|*
name|zone
decl_stmt|;
for|for
control|(
name|zone
operator|=
name|G
operator|.
name|zones
init|;
name|zone
condition|;
name|zone
operator|=
name|zone
operator|->
name|next_zone
control|)
if|if
condition|(
name|zone
operator|->
name|mark_bits
condition|)
block|{
name|free
argument_list|(
name|zone
operator|->
name|mark_bits
argument_list|)
expr_stmt|;
name|zone
operator|->
name|mark_bits
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|pch_zone
operator|.
name|bytes
condition|)
block|{
name|free
argument_list|(
name|pch_zone
operator|.
name|mark_bits
argument_list|)
expr_stmt|;
name|pch_zone
operator|.
name|mark_bits
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|USING_MMAP
end_ifdef

begin_comment
comment|/* Allocate SIZE bytes of anonymous memory, preferably near PREF,    (if non-null).  The ifdef structure here is intended to cause a    compile error unless exactly one of the HAVE_* is defined.  */
end_comment

begin_function
specifier|static
specifier|inline
name|char
modifier|*
name|alloc_anon
parameter_list|(
name|char
modifier|*
name|pref
name|ATTRIBUTE_UNUSED
parameter_list|,
name|size_t
name|size
parameter_list|,
name|struct
name|alloc_zone
modifier|*
name|zone
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|HAVE_MMAP_ANON
name|char
modifier|*
name|page
init|=
operator|(
name|char
operator|*
operator|)
name|mmap
argument_list|(
name|pref
argument_list|,
name|size
argument_list|,
name|PROT_READ
operator||
name|PROT_WRITE
argument_list|,
name|MAP_PRIVATE
operator||
name|MAP_ANONYMOUS
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_MMAP_DEV_ZERO
name|char
modifier|*
name|page
init|=
operator|(
name|char
operator|*
operator|)
name|mmap
argument_list|(
name|pref
argument_list|,
name|size
argument_list|,
name|PROT_READ
operator||
name|PROT_WRITE
argument_list|,
name|MAP_PRIVATE
argument_list|,
name|G
operator|.
name|dev_zero_fd
argument_list|,
literal|0
argument_list|)
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|page
operator|==
operator|(
name|char
operator|*
operator|)
name|MAP_FAILED
condition|)
block|{
name|perror
argument_list|(
literal|"virtual memory exhausted"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|FATAL_EXIT_CODE
argument_list|)
expr_stmt|;
block|}
comment|/* Remember that we allocated this memory.  */
name|zone
operator|->
name|bytes_mapped
operator|+=
name|size
expr_stmt|;
comment|/* Pretend we don't have access to the allocated pages.  We'll enable      access to smaller pieces of the area in ggc_alloc.  Discard the      handle to avoid handle leak.  */
name|VALGRIND_DISCARD
argument_list|(
name|VALGRIND_MAKE_NOACCESS
argument_list|(
name|page
argument_list|,
name|size
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|page
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Allocate a new page for allocating small objects in ZONE, and    return an entry for it.  */
end_comment

begin_function
specifier|static
name|struct
name|small_page_entry
modifier|*
name|alloc_small_page
parameter_list|(
name|struct
name|alloc_zone
modifier|*
name|zone
parameter_list|)
block|{
name|struct
name|small_page_entry
modifier|*
name|entry
decl_stmt|;
comment|/* Check the list of free pages for one we can use.  */
name|entry
operator|=
name|zone
operator|->
name|free_pages
expr_stmt|;
if|if
condition|(
name|entry
operator|!=
name|NULL
condition|)
block|{
comment|/* Recycle the allocated memory from this page ...  */
name|zone
operator|->
name|free_pages
operator|=
name|entry
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
comment|/* We want just one page.  Allocate a bunch of them and put the 	 extras on the freelist.  (Can only do this optimization with 	 mmap for backing store.)  */
name|struct
name|small_page_entry
modifier|*
name|e
decl_stmt|,
modifier|*
name|f
init|=
name|zone
operator|->
name|free_pages
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|page
decl_stmt|;
name|page
operator|=
name|alloc_anon
argument_list|(
name|NULL
argument_list|,
name|GGC_PAGE_SIZE
operator|*
name|G
operator|.
name|quire_size
argument_list|,
name|zone
argument_list|)
expr_stmt|;
comment|/* This loop counts down so that the chain will be in ascending 	 memory order.  */
for|for
control|(
name|i
operator|=
name|G
operator|.
name|quire_size
operator|-
literal|1
init|;
name|i
operator|>=
literal|1
condition|;
name|i
operator|--
control|)
block|{
name|e
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
name|G
operator|.
name|small_page_overhead
argument_list|)
expr_stmt|;
name|e
operator|->
name|common
operator|.
name|page
operator|=
name|page
operator|+
operator|(
name|i
operator|<<
name|GGC_PAGE_SHIFT
operator|)
expr_stmt|;
name|e
operator|->
name|common
operator|.
name|zone
operator|=
name|zone
expr_stmt|;
name|e
operator|->
name|next
operator|=
name|f
expr_stmt|;
name|f
operator|=
name|e
expr_stmt|;
name|set_page_table_entry
argument_list|(
name|e
operator|->
name|common
operator|.
name|page
argument_list|,
operator|&
name|e
operator|->
name|common
argument_list|)
expr_stmt|;
block|}
name|zone
operator|->
name|free_pages
operator|=
name|f
expr_stmt|;
name|entry
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
name|G
operator|.
name|small_page_overhead
argument_list|)
expr_stmt|;
name|entry
operator|->
name|common
operator|.
name|page
operator|=
name|page
expr_stmt|;
name|entry
operator|->
name|common
operator|.
name|zone
operator|=
name|zone
expr_stmt|;
name|set_page_table_entry
argument_list|(
name|page
argument_list|,
operator|&
name|entry
operator|->
name|common
argument_list|)
expr_stmt|;
block|}
name|zone
operator|->
name|n_small_pages
operator|++
expr_stmt|;
if|if
condition|(
name|GGC_DEBUG_LEVEL
operator|>=
literal|2
condition|)
name|fprintf
argument_list|(
name|G
operator|.
name|debug_file
argument_list|,
literal|"Allocating %s page at %p, data %p-%p\n"
argument_list|,
name|entry
operator|->
name|common
operator|.
name|zone
operator|->
name|name
argument_list|,
operator|(
name|PTR
operator|)
name|entry
argument_list|,
name|entry
operator|->
name|common
operator|.
name|page
argument_list|,
name|entry
operator|->
name|common
operator|.
name|page
operator|+
name|SMALL_PAGE_SIZE
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|entry
return|;
block|}
end_function

begin_comment
comment|/* Allocate a large page of size SIZE in ZONE.  */
end_comment

begin_function
specifier|static
name|struct
name|large_page_entry
modifier|*
name|alloc_large_page
parameter_list|(
name|size_t
name|size
parameter_list|,
name|struct
name|alloc_zone
modifier|*
name|zone
parameter_list|)
block|{
name|struct
name|large_page_entry
modifier|*
name|entry
decl_stmt|;
name|char
modifier|*
name|page
decl_stmt|;
name|size_t
name|needed_size
decl_stmt|;
name|needed_size
operator|=
name|size
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|large_page_entry
argument_list|)
expr_stmt|;
name|page
operator|=
name|xmalloc
argument_list|(
name|needed_size
argument_list|)
expr_stmt|;
name|entry
operator|=
operator|(
expr|struct
name|large_page_entry
operator|*
operator|)
name|page
expr_stmt|;
name|entry
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|entry
operator|->
name|common
operator|.
name|page
operator|=
name|page
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|large_page_entry
argument_list|)
expr_stmt|;
name|entry
operator|->
name|common
operator|.
name|large_p
operator|=
name|true
expr_stmt|;
name|entry
operator|->
name|common
operator|.
name|pch_p
operator|=
name|false
expr_stmt|;
name|entry
operator|->
name|common
operator|.
name|zone
operator|=
name|zone
expr_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|entry
operator|->
name|common
operator|.
name|survived
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|entry
operator|->
name|mark_p
operator|=
name|false
expr_stmt|;
name|entry
operator|->
name|bytes
operator|=
name|size
expr_stmt|;
name|entry
operator|->
name|prev
operator|=
name|NULL
expr_stmt|;
name|set_page_table_entry
argument_list|(
name|entry
operator|->
name|common
operator|.
name|page
argument_list|,
operator|&
name|entry
operator|->
name|common
argument_list|)
expr_stmt|;
if|if
condition|(
name|GGC_DEBUG_LEVEL
operator|>=
literal|2
condition|)
name|fprintf
argument_list|(
name|G
operator|.
name|debug_file
argument_list|,
literal|"Allocating %s large page at %p, data %p-%p\n"
argument_list|,
name|entry
operator|->
name|common
operator|.
name|zone
operator|->
name|name
argument_list|,
operator|(
name|PTR
operator|)
name|entry
argument_list|,
name|entry
operator|->
name|common
operator|.
name|page
argument_list|,
name|entry
operator|->
name|common
operator|.
name|page
operator|+
name|SMALL_PAGE_SIZE
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|entry
return|;
block|}
end_function

begin_comment
comment|/* For a page that is no longer needed, put it on the free page list.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|free_small_page
parameter_list|(
name|struct
name|small_page_entry
modifier|*
name|entry
parameter_list|)
block|{
if|if
condition|(
name|GGC_DEBUG_LEVEL
operator|>=
literal|2
condition|)
name|fprintf
argument_list|(
name|G
operator|.
name|debug_file
argument_list|,
literal|"Deallocating %s page at %p, data %p-%p\n"
argument_list|,
name|entry
operator|->
name|common
operator|.
name|zone
operator|->
name|name
argument_list|,
operator|(
name|PTR
operator|)
name|entry
argument_list|,
name|entry
operator|->
name|common
operator|.
name|page
argument_list|,
name|entry
operator|->
name|common
operator|.
name|page
operator|+
name|SMALL_PAGE_SIZE
operator|-
literal|1
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|entry
operator|->
name|common
operator|.
name|large_p
argument_list|)
expr_stmt|;
comment|/* Mark the page as inaccessible.  Discard the handle to      avoid handle leak.  */
name|VALGRIND_DISCARD
argument_list|(
name|VALGRIND_MAKE_NOACCESS
argument_list|(
name|entry
operator|->
name|common
operator|.
name|page
argument_list|,
name|SMALL_PAGE_SIZE
argument_list|)
argument_list|)
expr_stmt|;
name|entry
operator|->
name|next
operator|=
name|entry
operator|->
name|common
operator|.
name|zone
operator|->
name|free_pages
expr_stmt|;
name|entry
operator|->
name|common
operator|.
name|zone
operator|->
name|free_pages
operator|=
name|entry
expr_stmt|;
name|entry
operator|->
name|common
operator|.
name|zone
operator|->
name|n_small_pages
operator|--
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Release a large page that is no longer needed.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|free_large_page
parameter_list|(
name|struct
name|large_page_entry
modifier|*
name|entry
parameter_list|)
block|{
if|if
condition|(
name|GGC_DEBUG_LEVEL
operator|>=
literal|2
condition|)
name|fprintf
argument_list|(
name|G
operator|.
name|debug_file
argument_list|,
literal|"Deallocating %s page at %p, data %p-%p\n"
argument_list|,
name|entry
operator|->
name|common
operator|.
name|zone
operator|->
name|name
argument_list|,
operator|(
name|PTR
operator|)
name|entry
argument_list|,
name|entry
operator|->
name|common
operator|.
name|page
argument_list|,
name|entry
operator|->
name|common
operator|.
name|page
operator|+
name|SMALL_PAGE_SIZE
operator|-
literal|1
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|entry
operator|->
name|common
operator|.
name|large_p
argument_list|)
expr_stmt|;
name|set_page_table_entry
argument_list|(
name|entry
operator|->
name|common
operator|.
name|page
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Release the free page cache to the system.  */
end_comment

begin_function
specifier|static
name|void
name|release_pages
parameter_list|(
name|struct
name|alloc_zone
modifier|*
name|zone
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|USING_MMAP
name|struct
name|small_page_entry
modifier|*
name|p
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|char
modifier|*
name|start
decl_stmt|;
name|size_t
name|len
decl_stmt|;
comment|/* Gather up adjacent pages so they are unmapped together.  */
name|p
operator|=
name|zone
operator|->
name|free_pages
expr_stmt|;
while|while
condition|(
name|p
condition|)
block|{
name|start
operator|=
name|p
operator|->
name|common
operator|.
name|page
expr_stmt|;
name|next
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|len
operator|=
name|SMALL_PAGE_SIZE
expr_stmt|;
name|set_page_table_entry
argument_list|(
name|p
operator|->
name|common
operator|.
name|page
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|p
operator|=
name|next
expr_stmt|;
while|while
condition|(
name|p
operator|&&
name|p
operator|->
name|common
operator|.
name|page
operator|==
name|start
operator|+
name|len
condition|)
block|{
name|next
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|len
operator|+=
name|SMALL_PAGE_SIZE
expr_stmt|;
name|set_page_table_entry
argument_list|(
name|p
operator|->
name|common
operator|.
name|page
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|p
operator|=
name|next
expr_stmt|;
block|}
name|munmap
argument_list|(
name|start
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|zone
operator|->
name|bytes_mapped
operator|-=
name|len
expr_stmt|;
block|}
name|zone
operator|->
name|free_pages
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Place the block at PTR of size SIZE on the free list for ZONE.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|free_chunk
parameter_list|(
name|char
modifier|*
name|ptr
parameter_list|,
name|size_t
name|size
parameter_list|,
name|struct
name|alloc_zone
modifier|*
name|zone
parameter_list|)
block|{
name|struct
name|alloc_chunk
modifier|*
name|chunk
init|=
operator|(
expr|struct
name|alloc_chunk
operator|*
operator|)
name|ptr
decl_stmt|;
name|size_t
name|bin
init|=
literal|0
decl_stmt|;
name|bin
operator|=
name|SIZE_BIN_DOWN
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|bin
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|bin
operator|>
name|NUM_FREE_BINS
condition|)
block|{
name|bin
operator|=
literal|0
expr_stmt|;
name|VALGRIND_DISCARD
argument_list|(
name|VALGRIND_MAKE_WRITABLE
argument_list|(
name|chunk
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|alloc_chunk
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|chunk
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|chunk
operator|->
name|next_free
operator|=
name|zone
operator|->
name|free_chunks
index|[
name|bin
index|]
expr_stmt|;
name|VALGRIND_DISCARD
argument_list|(
name|VALGRIND_MAKE_NOACCESS
argument_list|(
name|ptr
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|alloc_chunk
argument_list|)
argument_list|,
name|size
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|alloc_chunk
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|VALGRIND_DISCARD
argument_list|(
name|VALGRIND_MAKE_WRITABLE
argument_list|(
name|chunk
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|alloc_chunk
operator|*
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|chunk
operator|->
name|next_free
operator|=
name|zone
operator|->
name|free_chunks
index|[
name|bin
index|]
expr_stmt|;
name|VALGRIND_DISCARD
argument_list|(
name|VALGRIND_MAKE_NOACCESS
argument_list|(
name|ptr
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|alloc_chunk
operator|*
argument_list|)
argument_list|,
name|size
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|alloc_chunk
operator|*
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|zone
operator|->
name|free_chunks
index|[
name|bin
index|]
operator|=
name|chunk
expr_stmt|;
if|if
condition|(
name|bin
operator|>
name|zone
operator|->
name|high_free_bin
condition|)
name|zone
operator|->
name|high_free_bin
operator|=
name|bin
expr_stmt|;
if|if
condition|(
name|GGC_DEBUG_LEVEL
operator|>=
literal|3
condition|)
name|fprintf
argument_list|(
name|G
operator|.
name|debug_file
argument_list|,
literal|"Deallocating object, chunk=%p\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|chunk
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Allocate a chunk of memory of at least ORIG_SIZE bytes, in ZONE.  */
end_comment

begin_function
name|void
modifier|*
name|ggc_alloc_zone_stat
parameter_list|(
name|size_t
name|orig_size
parameter_list|,
name|struct
name|alloc_zone
modifier|*
name|zone
name|MEM_STAT_DECL
parameter_list|)
block|{
name|size_t
name|bin
decl_stmt|;
name|size_t
name|csize
decl_stmt|;
name|struct
name|small_page_entry
modifier|*
name|entry
decl_stmt|;
name|struct
name|alloc_chunk
modifier|*
name|chunk
decl_stmt|,
modifier|*
modifier|*
name|pp
decl_stmt|;
name|void
modifier|*
name|result
decl_stmt|;
name|size_t
name|size
init|=
name|orig_size
decl_stmt|;
comment|/* Make sure that zero-sized allocations get a unique and freeable      pointer.  */
if|if
condition|(
name|size
operator|==
literal|0
condition|)
name|size
operator|=
name|MAX_ALIGNMENT
expr_stmt|;
else|else
name|size
operator|=
operator|(
name|size
operator|+
name|MAX_ALIGNMENT
operator|-
literal|1
operator|)
operator|&
operator|-
name|MAX_ALIGNMENT
expr_stmt|;
comment|/* Try to allocate the object from several different sources.  Each      of these cases is responsible for setting RESULT and SIZE to      describe the allocated block, before jumping to FOUND.  If a      chunk is split, the allocate bit for the new chunk should also be      set.       Large objects are handled specially.  However, they'll just fail      the next couple of conditions, so we can wait to check for them      below.  The large object case is relatively rare (< 1%), so this      is a win.  */
comment|/* First try to split the last chunk we allocated.  For best      fragmentation behavior it would be better to look for a      free bin of the appropriate size for a small object.  However,      we're unlikely (1% - 7%) to find one, and this gives better      locality behavior anyway.  This case handles the lion's share      of all calls to this function.  */
if|if
condition|(
name|size
operator|<=
name|zone
operator|->
name|cached_free_size
condition|)
block|{
name|result
operator|=
name|zone
operator|->
name|cached_free
expr_stmt|;
name|zone
operator|->
name|cached_free_size
operator|-=
name|size
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|cached_free_size
condition|)
block|{
name|zone
operator|->
name|cached_free
operator|+=
name|size
expr_stmt|;
name|zone_set_object_alloc_bit
argument_list|(
name|zone
operator|->
name|cached_free
argument_list|)
expr_stmt|;
block|}
goto|goto
name|found
goto|;
block|}
comment|/* Next, try to find a free bin of the exactly correct size.  */
comment|/* We want to round SIZE up, rather than down, but we know it's      already aligned to at least FREE_BIN_DELTA, so we can just      shift.  */
name|bin
operator|=
name|SIZE_BIN_DOWN
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|bin
operator|<=
name|NUM_FREE_BINS
operator|&&
operator|(
name|chunk
operator|=
name|zone
operator|->
name|free_chunks
index|[
name|bin
index|]
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* We have a chunk of the right size.  Pull it off the free list 	 and use it.  */
name|zone
operator|->
name|free_chunks
index|[
name|bin
index|]
operator|=
name|chunk
operator|->
name|next_free
expr_stmt|;
comment|/* NOTE: SIZE is only guaranteed to be right if MAX_ALIGNMENT 	 == FREE_BIN_DELTA.  */
name|result
operator|=
name|chunk
expr_stmt|;
comment|/* The allocation bits are already set correctly.  HIGH_FREE_BIN 	 may now be wrong, if this was the last chunk in the high bin. 	 Rather than fixing it up now, wait until we need to search 	 the free bins.  */
goto|goto
name|found
goto|;
block|}
comment|/* Next, if there wasn't a chunk of the ideal size, look for a chunk      to split.  We can find one in the too-big bin, or in the largest      sized bin with a chunk in it.  Try the largest normal-sized bin      first.  */
if|if
condition|(
name|zone
operator|->
name|high_free_bin
operator|>
name|bin
condition|)
block|{
comment|/* Find the highest numbered free bin.  It will be at or below 	 the watermark.  */
while|while
condition|(
name|zone
operator|->
name|high_free_bin
operator|>
name|bin
operator|&&
name|zone
operator|->
name|free_chunks
index|[
name|zone
operator|->
name|high_free_bin
index|]
operator|==
name|NULL
condition|)
name|zone
operator|->
name|high_free_bin
operator|--
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|high_free_bin
operator|>
name|bin
condition|)
block|{
name|size_t
name|tbin
init|=
name|zone
operator|->
name|high_free_bin
decl_stmt|;
name|chunk
operator|=
name|zone
operator|->
name|free_chunks
index|[
name|tbin
index|]
expr_stmt|;
comment|/* Remove the chunk from its previous bin.  */
name|zone
operator|->
name|free_chunks
index|[
name|tbin
index|]
operator|=
name|chunk
operator|->
name|next_free
expr_stmt|;
name|result
operator|=
operator|(
name|char
operator|*
operator|)
name|chunk
expr_stmt|;
comment|/* Save the rest of the chunk for future allocation.  */
if|if
condition|(
name|zone
operator|->
name|cached_free_size
condition|)
name|free_chunk
argument_list|(
name|zone
operator|->
name|cached_free
argument_list|,
name|zone
operator|->
name|cached_free_size
argument_list|,
name|zone
argument_list|)
expr_stmt|;
name|chunk
operator|=
operator|(
expr|struct
name|alloc_chunk
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|result
operator|+
name|size
operator|)
expr_stmt|;
name|zone
operator|->
name|cached_free
operator|=
operator|(
name|char
operator|*
operator|)
name|chunk
expr_stmt|;
name|zone
operator|->
name|cached_free_size
operator|=
operator|(
name|tbin
operator|-
name|bin
operator|)
operator|*
name|FREE_BIN_DELTA
expr_stmt|;
comment|/* Mark the new free chunk as an object, so that we can 	     find the size of the newly allocated object.  */
name|zone_set_object_alloc_bit
argument_list|(
name|chunk
argument_list|)
expr_stmt|;
comment|/* HIGH_FREE_BIN may now be wrong, if this was the last 	     chunk in the high bin.  Rather than fixing it up now, 	     wait until we need to search the free bins.  */
goto|goto
name|found
goto|;
block|}
block|}
comment|/* Failing that, look through the "other" bucket for a chunk      that is large enough.  */
name|pp
operator|=
operator|&
operator|(
name|zone
operator|->
name|free_chunks
index|[
literal|0
index|]
operator|)
expr_stmt|;
name|chunk
operator|=
operator|*
name|pp
expr_stmt|;
while|while
condition|(
name|chunk
operator|&&
name|chunk
operator|->
name|size
operator|<
name|size
condition|)
block|{
name|pp
operator|=
operator|&
name|chunk
operator|->
name|next_free
expr_stmt|;
name|chunk
operator|=
operator|*
name|pp
expr_stmt|;
block|}
if|if
condition|(
name|chunk
condition|)
block|{
comment|/* Remove the chunk from its previous bin.  */
operator|*
name|pp
operator|=
name|chunk
operator|->
name|next_free
expr_stmt|;
name|result
operator|=
operator|(
name|char
operator|*
operator|)
name|chunk
expr_stmt|;
comment|/* Save the rest of the chunk for future allocation, if there's any 	 left over.  */
name|csize
operator|=
name|chunk
operator|->
name|size
expr_stmt|;
if|if
condition|(
name|csize
operator|>
name|size
condition|)
block|{
if|if
condition|(
name|zone
operator|->
name|cached_free_size
condition|)
name|free_chunk
argument_list|(
name|zone
operator|->
name|cached_free
argument_list|,
name|zone
operator|->
name|cached_free_size
argument_list|,
name|zone
argument_list|)
expr_stmt|;
name|chunk
operator|=
operator|(
expr|struct
name|alloc_chunk
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|result
operator|+
name|size
operator|)
expr_stmt|;
name|zone
operator|->
name|cached_free
operator|=
operator|(
name|char
operator|*
operator|)
name|chunk
expr_stmt|;
name|zone
operator|->
name|cached_free_size
operator|=
name|csize
operator|-
name|size
expr_stmt|;
comment|/* Mark the new free chunk as an object.  */
name|zone_set_object_alloc_bit
argument_list|(
name|chunk
argument_list|)
expr_stmt|;
block|}
goto|goto
name|found
goto|;
block|}
comment|/* Handle large allocations.  We could choose any threshold between      GGC_PAGE_SIZE - sizeof (struct large_page_entry) and      GGC_PAGE_SIZE.  It can't be smaller, because then it wouldn't      be guaranteed to have a unique entry in the lookup table.  Large      allocations will always fall through to here.  */
if|if
condition|(
name|size
operator|>
name|GGC_PAGE_SIZE
condition|)
block|{
name|struct
name|large_page_entry
modifier|*
name|entry
init|=
name|alloc_large_page
argument_list|(
name|size
argument_list|,
name|zone
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|entry
operator|->
name|common
operator|.
name|survived
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|entry
operator|->
name|next
operator|=
name|zone
operator|->
name|large_pages
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|large_pages
condition|)
name|zone
operator|->
name|large_pages
operator|->
name|prev
operator|=
name|entry
expr_stmt|;
name|zone
operator|->
name|large_pages
operator|=
name|entry
expr_stmt|;
name|result
operator|=
name|entry
operator|->
name|common
operator|.
name|page
expr_stmt|;
goto|goto
name|found
goto|;
block|}
comment|/* Failing everything above, allocate a new small page.  */
name|entry
operator|=
name|alloc_small_page
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|entry
operator|->
name|next
operator|=
name|zone
operator|->
name|pages
expr_stmt|;
name|zone
operator|->
name|pages
operator|=
name|entry
expr_stmt|;
comment|/* Mark the first chunk in the new page.  */
name|entry
operator|->
name|alloc_bits
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
name|result
operator|=
name|entry
operator|->
name|common
operator|.
name|page
expr_stmt|;
if|if
condition|(
name|size
operator|<
name|SMALL_PAGE_SIZE
condition|)
block|{
if|if
condition|(
name|zone
operator|->
name|cached_free_size
condition|)
name|free_chunk
argument_list|(
name|zone
operator|->
name|cached_free
argument_list|,
name|zone
operator|->
name|cached_free_size
argument_list|,
name|zone
argument_list|)
expr_stmt|;
name|zone
operator|->
name|cached_free
operator|=
operator|(
name|char
operator|*
operator|)
name|result
operator|+
name|size
expr_stmt|;
name|zone
operator|->
name|cached_free_size
operator|=
name|SMALL_PAGE_SIZE
operator|-
name|size
expr_stmt|;
comment|/* Mark the new free chunk as an object.  */
name|zone_set_object_alloc_bit
argument_list|(
name|zone
operator|->
name|cached_free
argument_list|)
expr_stmt|;
block|}
name|found
label|:
comment|/* We could save TYPE in the chunk, but we don't use that for      anything yet.  If we wanted to, we could do it by adding it      either before the beginning of the chunk or after its end,      and adjusting the size and pointer appropriately.  */
comment|/* We'll probably write to this after we return.  */
name|prefetchw
argument_list|(
name|result
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_GC_CHECKING
comment|/* `Poison' the entire allocated object.  */
name|VALGRIND_DISCARD
argument_list|(
name|VALGRIND_MAKE_WRITABLE
argument_list|(
name|result
argument_list|,
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|result
argument_list|,
literal|0xaf
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|VALGRIND_DISCARD
argument_list|(
name|VALGRIND_MAKE_NOACCESS
argument_list|(
name|result
operator|+
name|orig_size
argument_list|,
name|size
operator|-
name|orig_size
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Tell Valgrind that the memory is there, but its content isn't      defined.  The bytes at the end of the object are still marked      unaccessible.  */
name|VALGRIND_DISCARD
argument_list|(
name|VALGRIND_MAKE_WRITABLE
argument_list|(
name|result
argument_list|,
name|orig_size
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Keep track of how many bytes are being allocated.  This      information is used in deciding when to collect.  */
name|zone
operator|->
name|allocated
operator|+=
name|size
expr_stmt|;
name|timevar_ggc_mem_total
operator|+=
name|size
expr_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|ggc_record_overhead
argument_list|(
argument|orig_size
argument_list|,
argument|size - orig_size
argument_list|,
argument|result PASS_MEM_STAT
argument_list|)
empty_stmt|;
block|{
name|size_t
name|object_size
init|=
name|size
decl_stmt|;
name|size_t
name|overhead
init|=
name|object_size
operator|-
name|orig_size
decl_stmt|;
name|zone
operator|->
name|stats
operator|.
name|total_overhead
operator|+=
name|overhead
expr_stmt|;
name|zone
operator|->
name|stats
operator|.
name|total_allocated
operator|+=
name|object_size
expr_stmt|;
if|if
condition|(
name|orig_size
operator|<=
literal|32
condition|)
block|{
name|zone
operator|->
name|stats
operator|.
name|total_overhead_under32
operator|+=
name|overhead
expr_stmt|;
name|zone
operator|->
name|stats
operator|.
name|total_allocated_under32
operator|+=
name|object_size
expr_stmt|;
block|}
if|if
condition|(
name|orig_size
operator|<=
literal|64
condition|)
block|{
name|zone
operator|->
name|stats
operator|.
name|total_overhead_under64
operator|+=
name|overhead
expr_stmt|;
name|zone
operator|->
name|stats
operator|.
name|total_allocated_under64
operator|+=
name|object_size
expr_stmt|;
block|}
if|if
condition|(
name|orig_size
operator|<=
literal|128
condition|)
block|{
name|zone
operator|->
name|stats
operator|.
name|total_overhead_under128
operator|+=
name|overhead
expr_stmt|;
name|zone
operator|->
name|stats
operator|.
name|total_allocated_under128
operator|+=
name|object_size
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|GGC_DEBUG_LEVEL
operator|>=
literal|3
condition|)
name|fprintf
argument_list|(
name|G
operator|.
name|debug_file
argument_list|,
literal|"Allocating object, size=%lu at %p\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|size
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Allocate a SIZE of chunk memory of GTE type, into an appropriate zone    for that type.  */
end_comment

begin_function
name|void
modifier|*
name|ggc_alloc_typed_stat
parameter_list|(
name|enum
name|gt_types_enum
name|gte
parameter_list|,
name|size_t
name|size
name|MEM_STAT_DECL
parameter_list|)
block|{
switch|switch
condition|(
name|gte
condition|)
block|{
case|case
name|gt_ggc_e_14lang_tree_node
case|:
return|return
name|ggc_alloc_zone_pass_stat
argument_list|(
name|size
argument_list|,
operator|&
name|tree_zone
argument_list|)
return|;
case|case
name|gt_ggc_e_7rtx_def
case|:
return|return
name|ggc_alloc_zone_pass_stat
argument_list|(
name|size
argument_list|,
operator|&
name|rtl_zone
argument_list|)
return|;
case|case
name|gt_ggc_e_9rtvec_def
case|:
return|return
name|ggc_alloc_zone_pass_stat
argument_list|(
name|size
argument_list|,
operator|&
name|rtl_zone
argument_list|)
return|;
default|default:
return|return
name|ggc_alloc_zone_pass_stat
argument_list|(
name|size
argument_list|,
operator|&
name|main_zone
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Normal ggc_alloc simply allocates into the main zone.  */
end_comment

begin_function
name|void
modifier|*
name|ggc_alloc_stat
parameter_list|(
name|size_t
name|size
name|MEM_STAT_DECL
parameter_list|)
block|{
return|return
name|ggc_alloc_zone_pass_stat
argument_list|(
name|size
argument_list|,
operator|&
name|main_zone
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Poison the chunk.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|ENABLE_GC_CHECKING
end_ifdef

begin_define
define|#
directive|define
name|poison_region
parameter_list|(
name|PTR
parameter_list|,
name|SIZE
parameter_list|)
define|\
value|memset ((PTR), 0xa5, (SIZE))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|poison_region
parameter_list|(
name|PTR
parameter_list|,
name|SIZE
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Free the object at P.  */
end_comment

begin_function
name|void
name|ggc_free
parameter_list|(
name|void
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|page_entry
modifier|*
name|page
decl_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|ggc_free_overhead
argument_list|(
name|p
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|poison_region
argument_list|(
name|p
argument_list|,
name|ggc_get_size
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|page
operator|=
name|zone_get_object_page
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|page
operator|->
name|large_p
condition|)
block|{
name|struct
name|large_page_entry
modifier|*
name|large_page
init|=
operator|(
expr|struct
name|large_page_entry
operator|*
operator|)
name|page
decl_stmt|;
comment|/* Remove the page from the linked list.  */
if|if
condition|(
name|large_page
operator|->
name|prev
condition|)
name|large_page
operator|->
name|prev
operator|->
name|next
operator|=
name|large_page
operator|->
name|next
expr_stmt|;
else|else
block|{
name|gcc_assert
argument_list|(
name|large_page
operator|->
name|common
operator|.
name|zone
operator|->
name|large_pages
operator|==
name|large_page
argument_list|)
expr_stmt|;
name|large_page
operator|->
name|common
operator|.
name|zone
operator|->
name|large_pages
operator|=
name|large_page
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|large_page
operator|->
name|next
condition|)
name|large_page
operator|->
name|next
operator|->
name|prev
operator|=
name|large_page
operator|->
name|prev
expr_stmt|;
name|large_page
operator|->
name|common
operator|.
name|zone
operator|->
name|allocated
operator|-=
name|large_page
operator|->
name|bytes
expr_stmt|;
comment|/* Release the memory associated with this object.  */
name|free_large_page
argument_list|(
name|large_page
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|page
operator|->
name|pch_p
condition|)
comment|/* Don't do anything.  We won't allocate a new object from the        PCH zone so there's no point in releasing anything.  */
empty_stmt|;
else|else
block|{
name|size_t
name|size
init|=
name|ggc_get_size
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|page
operator|->
name|zone
operator|->
name|allocated
operator|-=
name|size
expr_stmt|;
comment|/* Add the chunk to the free list.  We don't bother with coalescing, 	 since we are likely to want a chunk of this size again.  */
name|free_chunk
argument_list|(
name|p
argument_list|,
name|size
argument_list|,
name|page
operator|->
name|zone
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* If P is not marked, mark it and return false.  Otherwise return true.    P must have been allocated by the GC allocator; it mustn't point to    static objects, stack variables, or memory allocated with malloc.  */
end_comment

begin_function
name|int
name|ggc_set_mark
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|page_entry
modifier|*
name|page
decl_stmt|;
specifier|const
name|char
modifier|*
name|ptr
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|p
decl_stmt|;
name|page
operator|=
name|zone_get_object_page
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|page
operator|->
name|pch_p
condition|)
block|{
name|size_t
name|mark_word
decl_stmt|,
name|mark_bit
decl_stmt|,
name|offset
decl_stmt|;
name|offset
operator|=
operator|(
name|ptr
operator|-
name|pch_zone
operator|.
name|page
operator|)
operator|/
name|BYTES_PER_MARK_BIT
expr_stmt|;
name|mark_word
operator|=
name|offset
operator|/
operator|(
literal|8
operator|*
sizeof|sizeof
argument_list|(
name|mark_type
argument_list|)
operator|)
expr_stmt|;
name|mark_bit
operator|=
name|offset
operator|%
operator|(
literal|8
operator|*
sizeof|sizeof
argument_list|(
name|mark_type
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|pch_zone
operator|.
name|mark_bits
index|[
name|mark_word
index|]
operator|&
operator|(
literal|1
operator|<<
name|mark_bit
operator|)
condition|)
return|return
literal|1
return|;
name|pch_zone
operator|.
name|mark_bits
index|[
name|mark_word
index|]
operator||=
operator|(
literal|1
operator|<<
name|mark_bit
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|page
operator|->
name|large_p
condition|)
block|{
name|struct
name|large_page_entry
modifier|*
name|large_page
init|=
operator|(
expr|struct
name|large_page_entry
operator|*
operator|)
name|page
decl_stmt|;
if|if
condition|(
name|large_page
operator|->
name|mark_p
condition|)
return|return
literal|1
return|;
name|large_page
operator|->
name|mark_p
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
name|struct
name|small_page_entry
modifier|*
name|small_page
init|=
operator|(
expr|struct
name|small_page_entry
operator|*
operator|)
name|page
decl_stmt|;
if|if
condition|(
name|small_page
operator|->
name|mark_bits
index|[
name|zone_get_object_mark_word
argument_list|(
name|p
argument_list|)
index|]
operator|&
operator|(
literal|1
operator|<<
name|zone_get_object_mark_bit
argument_list|(
name|p
argument_list|)
operator|)
condition|)
return|return
literal|1
return|;
name|small_page
operator|->
name|mark_bits
index|[
name|zone_get_object_mark_word
argument_list|(
name|p
argument_list|)
index|]
operator||=
operator|(
literal|1
operator|<<
name|zone_get_object_mark_bit
argument_list|(
name|p
argument_list|)
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|GGC_DEBUG_LEVEL
operator|>=
literal|4
condition|)
name|fprintf
argument_list|(
name|G
operator|.
name|debug_file
argument_list|,
literal|"Marking %p\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if P has been marked, zero otherwise.    P must have been allocated by the GC allocator; it mustn't point to    static objects, stack variables, or memory allocated with malloc.  */
end_comment

begin_function
name|int
name|ggc_marked_p
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|page_entry
modifier|*
name|page
decl_stmt|;
specifier|const
name|char
modifier|*
name|ptr
init|=
name|p
decl_stmt|;
name|page
operator|=
name|zone_get_object_page
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|page
operator|->
name|pch_p
condition|)
block|{
name|size_t
name|mark_word
decl_stmt|,
name|mark_bit
decl_stmt|,
name|offset
decl_stmt|;
name|offset
operator|=
operator|(
name|ptr
operator|-
name|pch_zone
operator|.
name|page
operator|)
operator|/
name|BYTES_PER_MARK_BIT
expr_stmt|;
name|mark_word
operator|=
name|offset
operator|/
operator|(
literal|8
operator|*
sizeof|sizeof
argument_list|(
name|mark_type
argument_list|)
operator|)
expr_stmt|;
name|mark_bit
operator|=
name|offset
operator|%
operator|(
literal|8
operator|*
sizeof|sizeof
argument_list|(
name|mark_type
argument_list|)
operator|)
expr_stmt|;
return|return
operator|(
name|pch_zone
operator|.
name|mark_bits
index|[
name|mark_word
index|]
operator|&
operator|(
literal|1
operator|<<
name|mark_bit
operator|)
operator|)
operator|!=
literal|0
return|;
block|}
if|if
condition|(
name|page
operator|->
name|large_p
condition|)
block|{
name|struct
name|large_page_entry
modifier|*
name|large_page
init|=
operator|(
expr|struct
name|large_page_entry
operator|*
operator|)
name|page
decl_stmt|;
return|return
name|large_page
operator|->
name|mark_p
return|;
block|}
else|else
block|{
name|struct
name|small_page_entry
modifier|*
name|small_page
init|=
operator|(
expr|struct
name|small_page_entry
operator|*
operator|)
name|page
decl_stmt|;
return|return
literal|0
operator|!=
operator|(
name|small_page
operator|->
name|mark_bits
index|[
name|zone_get_object_mark_word
argument_list|(
name|p
argument_list|)
index|]
operator|&
operator|(
literal|1
operator|<<
name|zone_get_object_mark_bit
argument_list|(
name|p
argument_list|)
operator|)
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return the size of the gc-able object P.  */
end_comment

begin_function
name|size_t
name|ggc_get_size
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|page_entry
modifier|*
name|page
decl_stmt|;
specifier|const
name|char
modifier|*
name|ptr
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|p
decl_stmt|;
name|page
operator|=
name|zone_get_object_page
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|page
operator|->
name|pch_p
condition|)
block|{
name|size_t
name|alloc_word
decl_stmt|,
name|alloc_bit
decl_stmt|,
name|offset
decl_stmt|,
name|max_size
decl_stmt|;
name|offset
operator|=
operator|(
name|ptr
operator|-
name|pch_zone
operator|.
name|page
operator|)
operator|/
name|BYTES_PER_ALLOC_BIT
operator|+
literal|1
expr_stmt|;
name|alloc_word
operator|=
name|offset
operator|/
operator|(
literal|8
operator|*
sizeof|sizeof
argument_list|(
name|alloc_type
argument_list|)
operator|)
expr_stmt|;
name|alloc_bit
operator|=
name|offset
operator|%
operator|(
literal|8
operator|*
sizeof|sizeof
argument_list|(
name|alloc_type
argument_list|)
operator|)
expr_stmt|;
name|max_size
operator|=
name|pch_zone
operator|.
name|bytes
operator|-
operator|(
name|ptr
operator|-
name|pch_zone
operator|.
name|page
operator|)
expr_stmt|;
return|return
name|zone_object_size_1
argument_list|(
name|pch_zone
operator|.
name|alloc_bits
argument_list|,
name|alloc_word
argument_list|,
name|alloc_bit
argument_list|,
name|max_size
argument_list|)
return|;
block|}
if|if
condition|(
name|page
operator|->
name|large_p
condition|)
return|return
operator|(
operator|(
expr|struct
name|large_page_entry
operator|*
operator|)
name|page
operator|)
operator|->
name|bytes
return|;
else|else
return|return
name|zone_find_object_size
argument_list|(
operator|(
expr|struct
name|small_page_entry
operator|*
operator|)
name|page
argument_list|,
name|p
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Initialize the ggc-zone-mmap allocator.  */
end_comment

begin_function
name|void
name|init_ggc
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* The allocation size must be greater than BYTES_PER_MARK_BIT, and      a multiple of both BYTES_PER_ALLOC_BIT and FREE_BIN_DELTA, for      the current assumptions to hold.  */
name|gcc_assert
argument_list|(
name|FREE_BIN_DELTA
operator|==
name|MAX_ALIGNMENT
argument_list|)
expr_stmt|;
comment|/* Set up the main zone by hand.  */
name|main_zone
operator|.
name|name
operator|=
literal|"Main zone"
expr_stmt|;
name|G
operator|.
name|zones
operator|=
operator|&
name|main_zone
expr_stmt|;
comment|/* Allocate the default zones.  */
name|new_ggc_zone_1
argument_list|(
operator|&
name|rtl_zone
argument_list|,
literal|"RTL zone"
argument_list|)
expr_stmt|;
name|new_ggc_zone_1
argument_list|(
operator|&
name|tree_zone
argument_list|,
literal|"Tree zone"
argument_list|)
expr_stmt|;
name|new_ggc_zone_1
argument_list|(
operator|&
name|tree_id_zone
argument_list|,
literal|"Tree identifier zone"
argument_list|)
expr_stmt|;
name|G
operator|.
name|pagesize
operator|=
name|getpagesize
argument_list|()
expr_stmt|;
name|G
operator|.
name|lg_pagesize
operator|=
name|exact_log2
argument_list|(
name|G
operator|.
name|pagesize
argument_list|)
expr_stmt|;
name|G
operator|.
name|page_mask
operator|=
operator|~
operator|(
name|G
operator|.
name|pagesize
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* Require the system page size to be a multiple of GGC_PAGE_SIZE.  */
name|gcc_assert
argument_list|(
operator|(
name|G
operator|.
name|pagesize
operator|&
operator|(
name|GGC_PAGE_SIZE
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* Allocate 16 system pages at a time.  */
name|G
operator|.
name|quire_size
operator|=
literal|16
operator|*
name|G
operator|.
name|pagesize
operator|/
name|GGC_PAGE_SIZE
expr_stmt|;
comment|/* Calculate the size of the allocation bitmap and other overhead.  */
comment|/* Right now we allocate bits for the page header and bitmap.  These      are wasted, but a little tricky to eliminate.  */
name|G
operator|.
name|small_page_overhead
operator|=
name|PAGE_OVERHEAD
operator|+
operator|(
name|GGC_PAGE_SIZE
operator|/
name|BYTES_PER_ALLOC_BIT
operator|/
literal|8
operator|)
expr_stmt|;
comment|/* G.small_page_overhead = ROUND_UP (G.small_page_overhead, MAX_ALIGNMENT); */
ifdef|#
directive|ifdef
name|HAVE_MMAP_DEV_ZERO
name|G
operator|.
name|dev_zero_fd
operator|=
name|open
argument_list|(
literal|"/dev/zero"
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|G
operator|.
name|dev_zero_fd
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
literal|0
block|G.debug_file = fopen ("ggc-mmap.debug", "w");   setlinebuf (G.debug_file);
else|#
directive|else
name|G
operator|.
name|debug_file
operator|=
name|stdout
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USING_MMAP
comment|/* StunOS has an amazing off-by-one error for the first mmap allocation      after fiddling with RLIMIT_STACK.  The result, as hard as it is to      believe, is an unaligned page allocation, which would cause us to      hork badly if we tried to use it.  */
block|{
name|char
modifier|*
name|p
init|=
name|alloc_anon
argument_list|(
name|NULL
argument_list|,
name|G
operator|.
name|pagesize
argument_list|,
operator|&
name|main_zone
argument_list|)
decl_stmt|;
name|struct
name|small_page_entry
modifier|*
name|e
decl_stmt|;
if|if
condition|(
operator|(
name|size_t
operator|)
name|p
operator|&
operator|(
name|G
operator|.
name|pagesize
operator|-
literal|1
operator|)
condition|)
block|{
comment|/* How losing.  Discard this one and try another.  If we still 	   can't get something useful, give up.  */
name|p
operator|=
name|alloc_anon
argument_list|(
name|NULL
argument_list|,
name|G
operator|.
name|pagesize
argument_list|,
operator|&
name|main_zone
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
operator|(
operator|(
name|size_t
operator|)
name|p
operator|&
operator|(
name|G
operator|.
name|pagesize
operator|-
literal|1
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GGC_PAGE_SIZE
operator|==
name|G
operator|.
name|pagesize
condition|)
block|{
comment|/* We have a good page, might as well hold onto it...  */
name|e
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
name|G
operator|.
name|small_page_overhead
argument_list|)
expr_stmt|;
name|e
operator|->
name|common
operator|.
name|page
operator|=
name|p
expr_stmt|;
name|e
operator|->
name|common
operator|.
name|zone
operator|=
operator|&
name|main_zone
expr_stmt|;
name|e
operator|->
name|next
operator|=
name|main_zone
operator|.
name|free_pages
expr_stmt|;
name|set_page_table_entry
argument_list|(
name|e
operator|->
name|common
operator|.
name|page
argument_list|,
operator|&
name|e
operator|->
name|common
argument_list|)
expr_stmt|;
name|main_zone
operator|.
name|free_pages
operator|=
name|e
expr_stmt|;
block|}
else|else
block|{
name|munmap
argument_list|(
name|p
argument_list|,
name|G
operator|.
name|pagesize
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Start a new GGC zone.  */
end_comment

begin_function
specifier|static
name|void
name|new_ggc_zone_1
parameter_list|(
name|struct
name|alloc_zone
modifier|*
name|new_zone
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|new_zone
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|new_zone
operator|->
name|next_zone
operator|=
name|G
operator|.
name|zones
operator|->
name|next_zone
expr_stmt|;
name|G
operator|.
name|zones
operator|->
name|next_zone
operator|=
name|new_zone
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|alloc_zone
modifier|*
name|new_ggc_zone
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|alloc_zone
modifier|*
name|new_zone
init|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|alloc_zone
argument_list|)
argument_list|)
decl_stmt|;
name|new_ggc_zone_1
argument_list|(
name|new_zone
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|new_zone
return|;
block|}
end_function

begin_comment
comment|/* Destroy a GGC zone.  */
end_comment

begin_function
name|void
name|destroy_ggc_zone
parameter_list|(
name|struct
name|alloc_zone
modifier|*
name|dead_zone
parameter_list|)
block|{
name|struct
name|alloc_zone
modifier|*
name|z
decl_stmt|;
for|for
control|(
name|z
operator|=
name|G
operator|.
name|zones
init|;
name|z
operator|&&
name|z
operator|->
name|next_zone
operator|!=
name|dead_zone
condition|;
name|z
operator|=
name|z
operator|->
name|next_zone
control|)
comment|/* Just find that zone.  */
continue|continue;
comment|/* We should have found the zone in the list.  Anything else is fatal.  */
name|gcc_assert
argument_list|(
name|z
argument_list|)
expr_stmt|;
comment|/* z is dead, baby. z is dead.  */
name|z
operator|->
name|dead
operator|=
name|true
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Free all empty pages and objects within a page for a given zone  */
end_comment

begin_function
specifier|static
name|void
name|sweep_pages
parameter_list|(
name|struct
name|alloc_zone
modifier|*
name|zone
parameter_list|)
block|{
name|struct
name|large_page_entry
modifier|*
modifier|*
name|lpp
decl_stmt|,
modifier|*
name|lp
decl_stmt|,
modifier|*
name|lnext
decl_stmt|;
name|struct
name|small_page_entry
modifier|*
modifier|*
name|spp
decl_stmt|,
modifier|*
name|sp
decl_stmt|,
modifier|*
name|snext
decl_stmt|;
name|char
modifier|*
name|last_free
decl_stmt|;
name|size_t
name|allocated
init|=
literal|0
decl_stmt|;
name|bool
name|nomarksinpage
decl_stmt|;
comment|/* First, reset the free_chunks lists, since we are going to      re-free free chunks in hopes of coalescing them into large chunks.  */
name|memset
argument_list|(
name|zone
operator|->
name|free_chunks
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|zone
operator|->
name|free_chunks
argument_list|)
argument_list|)
expr_stmt|;
name|zone
operator|->
name|high_free_bin
operator|=
literal|0
expr_stmt|;
name|zone
operator|->
name|cached_free
operator|=
name|NULL
expr_stmt|;
name|zone
operator|->
name|cached_free_size
operator|=
literal|0
expr_stmt|;
comment|/* Large pages are all or none affairs. Either they are completely      empty, or they are completely full.  */
name|lpp
operator|=
operator|&
name|zone
operator|->
name|large_pages
expr_stmt|;
for|for
control|(
name|lp
operator|=
name|zone
operator|->
name|large_pages
init|;
name|lp
operator|!=
name|NULL
condition|;
name|lp
operator|=
name|lnext
control|)
block|{
name|gcc_assert
argument_list|(
name|lp
operator|->
name|common
operator|.
name|large_p
argument_list|)
expr_stmt|;
name|lnext
operator|=
name|lp
operator|->
name|next
expr_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
comment|/* This page has now survived another collection.  */
name|lp
operator|->
name|common
operator|.
name|survived
operator|++
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|lp
operator|->
name|mark_p
condition|)
block|{
name|lp
operator|->
name|mark_p
operator|=
name|false
expr_stmt|;
name|allocated
operator|+=
name|lp
operator|->
name|bytes
expr_stmt|;
name|lpp
operator|=
operator|&
name|lp
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
operator|*
name|lpp
operator|=
name|lnext
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_GC_CHECKING
comment|/* Poison the page.  */
name|memset
argument_list|(
name|lp
operator|->
name|common
operator|.
name|page
argument_list|,
literal|0xb5
argument_list|,
name|SMALL_PAGE_SIZE
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|lp
operator|->
name|prev
condition|)
name|lp
operator|->
name|prev
operator|->
name|next
operator|=
name|lp
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|lp
operator|->
name|next
condition|)
name|lp
operator|->
name|next
operator|->
name|prev
operator|=
name|lp
operator|->
name|prev
expr_stmt|;
name|free_large_page
argument_list|(
name|lp
argument_list|)
expr_stmt|;
block|}
block|}
name|spp
operator|=
operator|&
name|zone
operator|->
name|pages
expr_stmt|;
for|for
control|(
name|sp
operator|=
name|zone
operator|->
name|pages
init|;
name|sp
operator|!=
name|NULL
condition|;
name|sp
operator|=
name|snext
control|)
block|{
name|char
modifier|*
name|object
decl_stmt|,
modifier|*
name|last_object
decl_stmt|;
name|char
modifier|*
name|end
decl_stmt|;
name|alloc_type
modifier|*
name|alloc_word_p
decl_stmt|;
name|mark_type
modifier|*
name|mark_word_p
decl_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|sp
operator|->
name|common
operator|.
name|large_p
argument_list|)
expr_stmt|;
name|snext
operator|=
name|sp
operator|->
name|next
expr_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
comment|/* This page has now survived another collection.  */
name|sp
operator|->
name|common
operator|.
name|survived
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* Step through all chunks, consolidate those that are free and 	 insert them into the free lists.  Note that consolidation 	 slows down collection slightly.  */
name|last_object
operator|=
name|object
operator|=
name|sp
operator|->
name|common
operator|.
name|page
expr_stmt|;
name|end
operator|=
name|sp
operator|->
name|common
operator|.
name|page
operator|+
name|SMALL_PAGE_SIZE
expr_stmt|;
name|last_free
operator|=
name|NULL
expr_stmt|;
name|nomarksinpage
operator|=
name|true
expr_stmt|;
name|mark_word_p
operator|=
name|sp
operator|->
name|mark_bits
expr_stmt|;
name|alloc_word_p
operator|=
name|sp
operator|->
name|alloc_bits
expr_stmt|;
name|gcc_assert
argument_list|(
name|BYTES_PER_ALLOC_BIT
operator|==
name|BYTES_PER_MARK_BIT
argument_list|)
expr_stmt|;
name|object
operator|=
name|sp
operator|->
name|common
operator|.
name|page
expr_stmt|;
do|do
block|{
name|unsigned
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
name|alloc_type
name|alloc_word
decl_stmt|;
name|mark_type
name|mark_word
decl_stmt|;
name|alloc_word
operator|=
operator|*
name|alloc_word_p
operator|++
expr_stmt|;
name|mark_word
operator|=
operator|*
name|mark_word_p
operator|++
expr_stmt|;
if|if
condition|(
name|mark_word
condition|)
name|nomarksinpage
operator|=
name|false
expr_stmt|;
comment|/* There ought to be some way to do this without looping...  */
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|n
operator|=
name|alloc_ffs
argument_list|(
name|alloc_word
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Extend the current state for n - 1 bits.  We can't 		 shift alloc_word by n, even though it isn't used in the 		 loop, in case only the highest bit was set.  */
name|alloc_word
operator|>>=
name|n
operator|-
literal|1
expr_stmt|;
name|mark_word
operator|>>=
name|n
operator|-
literal|1
expr_stmt|;
name|object
operator|+=
name|BYTES_PER_MARK_BIT
operator|*
operator|(
name|n
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|mark_word
operator|&
literal|1
condition|)
block|{
if|if
condition|(
name|last_free
condition|)
block|{
name|VALGRIND_DISCARD
argument_list|(
name|VALGRIND_MAKE_WRITABLE
argument_list|(
name|last_free
argument_list|,
name|object
operator|-
name|last_free
argument_list|)
argument_list|)
expr_stmt|;
name|poison_region
argument_list|(
name|last_free
argument_list|,
name|object
operator|-
name|last_free
argument_list|)
expr_stmt|;
name|free_chunk
argument_list|(
name|last_free
argument_list|,
name|object
operator|-
name|last_free
argument_list|,
name|zone
argument_list|)
expr_stmt|;
name|last_free
operator|=
name|NULL
expr_stmt|;
block|}
else|else
name|allocated
operator|+=
name|object
operator|-
name|last_object
expr_stmt|;
name|last_object
operator|=
name|object
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|last_free
operator|==
name|NULL
condition|)
block|{
name|last_free
operator|=
name|object
expr_stmt|;
name|allocated
operator|+=
name|object
operator|-
name|last_object
expr_stmt|;
block|}
else|else
name|zone_clear_object_alloc_bit
argument_list|(
name|sp
argument_list|,
name|object
argument_list|)
expr_stmt|;
block|}
comment|/* Shift to just after the alloc bit we handled.  */
name|alloc_word
operator|>>=
literal|1
expr_stmt|;
name|mark_word
operator|>>=
literal|1
expr_stmt|;
name|object
operator|+=
name|BYTES_PER_MARK_BIT
expr_stmt|;
name|i
operator|+=
name|n
expr_stmt|;
block|}
name|object
operator|+=
name|BYTES_PER_MARK_BIT
operator|*
operator|(
literal|8
operator|*
sizeof|sizeof
argument_list|(
name|alloc_type
argument_list|)
operator|-
name|i
operator|)
expr_stmt|;
block|}
do|while
condition|(
name|object
operator|<
name|end
condition|)
do|;
if|if
condition|(
name|nomarksinpage
condition|)
block|{
operator|*
name|spp
operator|=
name|snext
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_GC_CHECKING
name|VALGRIND_DISCARD
argument_list|(
name|VALGRIND_MAKE_WRITABLE
argument_list|(
name|sp
operator|->
name|common
operator|.
name|page
argument_list|,
name|SMALL_PAGE_SIZE
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Poison the page.  */
name|memset
argument_list|(
name|sp
operator|->
name|common
operator|.
name|page
argument_list|,
literal|0xb5
argument_list|,
name|SMALL_PAGE_SIZE
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|free_small_page
argument_list|(
name|sp
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|last_free
condition|)
block|{
name|VALGRIND_DISCARD
argument_list|(
name|VALGRIND_MAKE_WRITABLE
argument_list|(
name|last_free
argument_list|,
name|object
operator|-
name|last_free
argument_list|)
argument_list|)
expr_stmt|;
name|poison_region
argument_list|(
name|last_free
argument_list|,
name|object
operator|-
name|last_free
argument_list|)
expr_stmt|;
name|free_chunk
argument_list|(
name|last_free
argument_list|,
name|object
operator|-
name|last_free
argument_list|,
name|zone
argument_list|)
expr_stmt|;
block|}
else|else
name|allocated
operator|+=
name|object
operator|-
name|last_object
expr_stmt|;
name|spp
operator|=
operator|&
name|sp
operator|->
name|next
expr_stmt|;
block|}
name|zone
operator|->
name|allocated
operator|=
name|allocated
expr_stmt|;
block|}
end_function

begin_comment
comment|/* mark-and-sweep routine for collecting a single zone.  NEED_MARKING    is true if we need to mark before sweeping, false if some other    zone collection has already performed marking for us.  Returns true    if we collected, false otherwise.  */
end_comment

begin_function
specifier|static
name|bool
name|ggc_collect_1
parameter_list|(
name|struct
name|alloc_zone
modifier|*
name|zone
parameter_list|,
name|bool
name|need_marking
parameter_list|)
block|{
if|#
directive|if
literal|0
comment|/* */
block|{     int i;     for (i = 0; i< NUM_FREE_BINS + 1; i++)       { 	struct alloc_chunk *chunk; 	int n, tot;  	n = 0; 	tot = 0; 	chunk = zone->free_chunks[i]; 	while (chunk) 	  { 	    n++; 	    tot += chunk->size; 	    chunk = chunk->next_free; 	  } 	fprintf (stderr, "Bin %d: %d free chunks (%d bytes)\n", 		 i, n, tot);       }   }
comment|/* */
endif|#
directive|endif
if|if
condition|(
operator|!
name|quiet_flag
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" {%s GC %luk -> "
argument_list|,
name|zone
operator|->
name|name
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|zone
operator|->
name|allocated
operator|/
literal|1024
argument_list|)
expr_stmt|;
comment|/* Zero the total allocated bytes.  This will be recalculated in the      sweep phase.  */
name|zone
operator|->
name|allocated
operator|=
literal|0
expr_stmt|;
comment|/* Release the pages we freed the last time we collected, but didn't      reuse in the interim.  */
name|release_pages
argument_list|(
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|need_marking
condition|)
block|{
name|zone_allocate_marks
argument_list|()
expr_stmt|;
name|ggc_mark_roots
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|ggc_prune_overhead_list
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
name|sweep_pages
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|zone
operator|->
name|was_collected
operator|=
name|true
expr_stmt|;
name|zone
operator|->
name|allocated_last_gc
operator|=
name|zone
operator|->
name|allocated
expr_stmt|;
if|if
condition|(
operator|!
name|quiet_flag
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%luk}"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|zone
operator|->
name|allocated
operator|/
literal|1024
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
end_ifdef

begin_comment
comment|/* Calculate the average page survival rate in terms of number of    collections.  */
end_comment

begin_function
specifier|static
name|float
name|calculate_average_page_survival
parameter_list|(
name|struct
name|alloc_zone
modifier|*
name|zone
parameter_list|)
block|{
name|float
name|count
init|=
literal|0.0
decl_stmt|;
name|float
name|survival
init|=
literal|0.0
decl_stmt|;
name|struct
name|small_page_entry
modifier|*
name|p
decl_stmt|;
name|struct
name|large_page_entry
modifier|*
name|lp
decl_stmt|;
for|for
control|(
name|p
operator|=
name|zone
operator|->
name|pages
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|count
operator|+=
literal|1.0
expr_stmt|;
name|survival
operator|+=
name|p
operator|->
name|common
operator|.
name|survived
expr_stmt|;
block|}
for|for
control|(
name|lp
operator|=
name|zone
operator|->
name|large_pages
init|;
name|lp
condition|;
name|lp
operator|=
name|lp
operator|->
name|next
control|)
block|{
name|count
operator|+=
literal|1.0
expr_stmt|;
name|survival
operator|+=
name|lp
operator|->
name|common
operator|.
name|survived
expr_stmt|;
block|}
return|return
name|survival
operator|/
name|count
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Top level collection routine.  */
end_comment

begin_function
name|void
name|ggc_collect
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|alloc_zone
modifier|*
name|zone
decl_stmt|;
name|bool
name|marked
init|=
name|false
decl_stmt|;
name|timevar_push
argument_list|(
name|TV_GC
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ggc_force_collect
condition|)
block|{
name|float
name|allocated_last_gc
init|=
literal|0
decl_stmt|,
name|allocated
init|=
literal|0
decl_stmt|,
name|min_expand
decl_stmt|;
for|for
control|(
name|zone
operator|=
name|G
operator|.
name|zones
init|;
name|zone
condition|;
name|zone
operator|=
name|zone
operator|->
name|next_zone
control|)
block|{
name|allocated_last_gc
operator|+=
name|zone
operator|->
name|allocated_last_gc
expr_stmt|;
name|allocated
operator|+=
name|zone
operator|->
name|allocated
expr_stmt|;
block|}
name|allocated_last_gc
operator|=
name|MAX
argument_list|(
name|allocated_last_gc
argument_list|,
operator|(
name|size_t
operator|)
name|PARAM_VALUE
argument_list|(
name|GGC_MIN_HEAPSIZE
argument_list|)
operator|*
literal|1024
argument_list|)
expr_stmt|;
name|min_expand
operator|=
name|allocated_last_gc
operator|*
name|PARAM_VALUE
argument_list|(
name|GGC_MIN_EXPAND
argument_list|)
operator|/
literal|100
expr_stmt|;
if|if
condition|(
name|allocated
operator|<
name|allocated_last_gc
operator|+
name|min_expand
condition|)
block|{
name|timevar_pop
argument_list|(
name|TV_GC
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* Start by possibly collecting the main zone.  */
name|main_zone
operator|.
name|was_collected
operator|=
name|false
expr_stmt|;
name|marked
operator||=
name|ggc_collect_1
argument_list|(
operator|&
name|main_zone
argument_list|,
name|true
argument_list|)
expr_stmt|;
comment|/* In order to keep the number of collections down, we don't      collect other zones unless we are collecting the main zone.  This      gives us roughly the same number of collections as we used to      have with the old gc.  The number of collection is important      because our main slowdown (according to profiling) is now in      marking.  So if we mark twice as often as we used to, we'll be      twice as slow.  Hopefully we'll avoid this cost when we mark      zone-at-a-time.  */
comment|/* NOTE drow/2004-07-28: We now always collect the main zone, but      keep this code in case the heuristics are further refined.  */
if|if
condition|(
name|main_zone
operator|.
name|was_collected
condition|)
block|{
name|struct
name|alloc_zone
modifier|*
name|zone
decl_stmt|;
for|for
control|(
name|zone
operator|=
name|main_zone
operator|.
name|next_zone
init|;
name|zone
condition|;
name|zone
operator|=
name|zone
operator|->
name|next_zone
control|)
block|{
name|zone
operator|->
name|was_collected
operator|=
name|false
expr_stmt|;
name|marked
operator||=
name|ggc_collect_1
argument_list|(
name|zone
argument_list|,
operator|!
name|marked
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
comment|/* Print page survival stats, if someone wants them.  */
if|if
condition|(
name|GGC_DEBUG_LEVEL
operator|>=
literal|2
condition|)
block|{
for|for
control|(
name|zone
operator|=
name|G
operator|.
name|zones
init|;
name|zone
condition|;
name|zone
operator|=
name|zone
operator|->
name|next_zone
control|)
block|{
if|if
condition|(
name|zone
operator|->
name|was_collected
condition|)
block|{
name|float
name|f
init|=
name|calculate_average_page_survival
argument_list|(
name|zone
argument_list|)
decl_stmt|;
name|printf
argument_list|(
literal|"Average page survival in zone `%s' is %f\n"
argument_list|,
name|zone
operator|->
name|name
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|marked
condition|)
name|zone_free_marks
argument_list|()
expr_stmt|;
comment|/* Free dead zones.  */
for|for
control|(
name|zone
operator|=
name|G
operator|.
name|zones
init|;
name|zone
operator|&&
name|zone
operator|->
name|next_zone
condition|;
name|zone
operator|=
name|zone
operator|->
name|next_zone
control|)
block|{
if|if
condition|(
name|zone
operator|->
name|next_zone
operator|->
name|dead
condition|)
block|{
name|struct
name|alloc_zone
modifier|*
name|dead_zone
init|=
name|zone
operator|->
name|next_zone
decl_stmt|;
name|printf
argument_list|(
literal|"Zone `%s' is dead and will be freed.\n"
argument_list|,
name|dead_zone
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* The zone must be empty.  */
name|gcc_assert
argument_list|(
operator|!
name|dead_zone
operator|->
name|allocated
argument_list|)
expr_stmt|;
comment|/* Unchain the dead zone, release all its pages and free it.  */
name|zone
operator|->
name|next_zone
operator|=
name|zone
operator|->
name|next_zone
operator|->
name|next_zone
expr_stmt|;
name|release_pages
argument_list|(
name|dead_zone
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dead_zone
argument_list|)
expr_stmt|;
block|}
block|}
name|timevar_pop
argument_list|(
name|TV_GC
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print allocation statistics.  */
end_comment

begin_define
define|#
directive|define
name|SCALE
parameter_list|(
name|x
parameter_list|)
value|((unsigned long) ((x)< 1024*10 \ 		  ? (x) \ 		  : ((x)< 1024*1024*10 \ 		     ? (x) / 1024 \ 		     : (x) / (1024*1024))))
end_define

begin_define
define|#
directive|define
name|LABEL
parameter_list|(
name|x
parameter_list|)
value|((x)< 1024*10 ? ' ' : ((x)< 1024*1024*10 ? 'k' : 'M'))
end_define

begin_function
name|void
name|ggc_print_statistics
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|alloc_zone
modifier|*
name|zone
decl_stmt|;
name|struct
name|ggc_statistics
name|stats
decl_stmt|;
name|size_t
name|total_overhead
init|=
literal|0
decl_stmt|,
name|total_allocated
init|=
literal|0
decl_stmt|,
name|total_bytes_mapped
init|=
literal|0
decl_stmt|;
name|size_t
name|pte_overhead
decl_stmt|,
name|i
decl_stmt|;
comment|/* Clear the statistics.  */
name|memset
argument_list|(
operator|&
name|stats
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|stats
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make sure collection will really occur.  */
name|ggc_force_collect
operator|=
name|true
expr_stmt|;
comment|/* Collect and print the statistics common across collectors.  */
name|ggc_print_common_statistics
argument_list|(
name|stderr
argument_list|,
operator|&
name|stats
argument_list|)
expr_stmt|;
name|ggc_force_collect
operator|=
name|false
expr_stmt|;
comment|/* Release free pages so that we will not count the bytes allocated      there as part of the total allocated memory.  */
for|for
control|(
name|zone
operator|=
name|G
operator|.
name|zones
init|;
name|zone
condition|;
name|zone
operator|=
name|zone
operator|->
name|next_zone
control|)
name|release_pages
argument_list|(
name|zone
argument_list|)
expr_stmt|;
comment|/* Collect some information about the various sizes of      allocation.  */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Memory still allocated at the end of the compilation process\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%20s %10s  %10s  %10s\n"
argument_list|,
literal|"Zone"
argument_list|,
literal|"Allocated"
argument_list|,
literal|"Used"
argument_list|,
literal|"Overhead"
argument_list|)
expr_stmt|;
for|for
control|(
name|zone
operator|=
name|G
operator|.
name|zones
init|;
name|zone
condition|;
name|zone
operator|=
name|zone
operator|->
name|next_zone
control|)
block|{
name|struct
name|large_page_entry
modifier|*
name|large_page
decl_stmt|;
name|size_t
name|overhead
decl_stmt|,
name|allocated
decl_stmt|,
name|in_use
decl_stmt|;
comment|/* Skip empty zones.  */
if|if
condition|(
operator|!
name|zone
operator|->
name|pages
operator|&&
operator|!
name|zone
operator|->
name|large_pages
condition|)
continue|continue;
name|allocated
operator|=
name|in_use
operator|=
literal|0
expr_stmt|;
name|overhead
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|alloc_zone
argument_list|)
expr_stmt|;
for|for
control|(
name|large_page
operator|=
name|zone
operator|->
name|large_pages
init|;
name|large_page
operator|!=
name|NULL
condition|;
name|large_page
operator|=
name|large_page
operator|->
name|next
control|)
block|{
name|allocated
operator|+=
name|large_page
operator|->
name|bytes
expr_stmt|;
name|in_use
operator|+=
name|large_page
operator|->
name|bytes
expr_stmt|;
name|overhead
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|large_page_entry
argument_list|)
expr_stmt|;
block|}
comment|/* There's no easy way to walk through the small pages finding 	 used and unused objects.  Instead, add all the pages, and 	 subtract out the free list.  */
name|allocated
operator|+=
name|GGC_PAGE_SIZE
operator|*
name|zone
operator|->
name|n_small_pages
expr_stmt|;
name|in_use
operator|+=
name|GGC_PAGE_SIZE
operator|*
name|zone
operator|->
name|n_small_pages
expr_stmt|;
name|overhead
operator|+=
name|G
operator|.
name|small_page_overhead
operator|*
name|zone
operator|->
name|n_small_pages
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|NUM_FREE_BINS
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|alloc_chunk
modifier|*
name|chunk
init|=
name|zone
operator|->
name|free_chunks
index|[
name|i
index|]
decl_stmt|;
while|while
condition|(
name|chunk
condition|)
block|{
name|in_use
operator|-=
name|ggc_get_size
argument_list|(
name|chunk
argument_list|)
expr_stmt|;
name|chunk
operator|=
name|chunk
operator|->
name|next_free
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%20s %10lu%c %10lu%c %10lu%c\n"
argument_list|,
name|zone
operator|->
name|name
argument_list|,
name|SCALE
argument_list|(
name|allocated
argument_list|)
argument_list|,
name|LABEL
argument_list|(
name|allocated
argument_list|)
argument_list|,
name|SCALE
argument_list|(
name|in_use
argument_list|)
argument_list|,
name|LABEL
argument_list|(
name|in_use
argument_list|)
argument_list|,
name|SCALE
argument_list|(
name|overhead
argument_list|)
argument_list|,
name|LABEL
argument_list|(
name|overhead
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|in_use
operator|==
name|zone
operator|->
name|allocated
argument_list|)
expr_stmt|;
name|total_overhead
operator|+=
name|overhead
expr_stmt|;
name|total_allocated
operator|+=
name|zone
operator|->
name|allocated
expr_stmt|;
name|total_bytes_mapped
operator|+=
name|zone
operator|->
name|bytes_mapped
expr_stmt|;
block|}
comment|/* Count the size of the page table as best we can.  */
if|#
directive|if
name|HOST_BITS_PER_PTR
operator|<=
literal|32
name|pte_overhead
operator|=
sizeof|sizeof
argument_list|(
name|G
operator|.
name|lookup
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PAGE_L1_SIZE
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|G
operator|.
name|lookup
index|[
name|i
index|]
condition|)
name|pte_overhead
operator|+=
name|PAGE_L2_SIZE
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|page_entry
operator|*
argument_list|)
expr_stmt|;
else|#
directive|else
block|{
name|page_table
name|table
init|=
name|G
operator|.
name|lookup
decl_stmt|;
name|pte_overhead
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|table
condition|)
block|{
name|pte_overhead
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|table
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PAGE_L1_SIZE
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|table
operator|->
name|table
index|[
name|i
index|]
condition|)
name|pte_overhead
operator|+=
name|PAGE_L2_SIZE
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|page_entry
operator|*
argument_list|)
expr_stmt|;
name|table
operator|=
name|table
operator|->
name|next
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%20s %11s %11s %10lu%c\n"
argument_list|,
literal|"Page Table"
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
name|SCALE
argument_list|(
name|pte_overhead
argument_list|)
argument_list|,
name|LABEL
argument_list|(
name|pte_overhead
argument_list|)
argument_list|)
expr_stmt|;
name|total_overhead
operator|+=
name|pte_overhead
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%20s %10lu%c %10lu%c %10lu%c\n"
argument_list|,
literal|"Total"
argument_list|,
name|SCALE
argument_list|(
name|total_bytes_mapped
argument_list|)
argument_list|,
name|LABEL
argument_list|(
name|total_bytes_mapped
argument_list|)
argument_list|,
name|SCALE
argument_list|(
name|total_allocated
argument_list|)
argument_list|,
name|LABEL
argument_list|(
name|total_allocated
argument_list|)
argument_list|,
name|SCALE
argument_list|(
name|total_overhead
argument_list|)
argument_list|,
name|LABEL
argument_list|(
name|total_overhead
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
block|{
name|unsigned
name|long
name|long
name|all_overhead
init|=
literal|0
decl_stmt|,
name|all_allocated
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
name|long
name|all_overhead_under32
init|=
literal|0
decl_stmt|,
name|all_allocated_under32
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
name|long
name|all_overhead_under64
init|=
literal|0
decl_stmt|,
name|all_allocated_under64
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
name|long
name|all_overhead_under128
init|=
literal|0
decl_stmt|,
name|all_allocated_under128
init|=
literal|0
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nTotal allocations and overheads during the compilation process\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|zone
operator|=
name|G
operator|.
name|zones
init|;
name|zone
condition|;
name|zone
operator|=
name|zone
operator|->
name|next_zone
control|)
block|{
name|all_overhead
operator|+=
name|zone
operator|->
name|stats
operator|.
name|total_overhead
expr_stmt|;
name|all_allocated
operator|+=
name|zone
operator|->
name|stats
operator|.
name|total_allocated
expr_stmt|;
name|all_allocated_under32
operator|+=
name|zone
operator|->
name|stats
operator|.
name|total_allocated_under32
expr_stmt|;
name|all_overhead_under32
operator|+=
name|zone
operator|->
name|stats
operator|.
name|total_overhead_under32
expr_stmt|;
name|all_allocated_under64
operator|+=
name|zone
operator|->
name|stats
operator|.
name|total_allocated_under64
expr_stmt|;
name|all_overhead_under64
operator|+=
name|zone
operator|->
name|stats
operator|.
name|total_overhead_under64
expr_stmt|;
name|all_allocated_under128
operator|+=
name|zone
operator|->
name|stats
operator|.
name|total_allocated_under128
expr_stmt|;
name|all_overhead_under128
operator|+=
name|zone
operator|->
name|stats
operator|.
name|total_overhead_under128
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%20s:                  %10lld\n"
argument_list|,
name|zone
operator|->
name|name
argument_list|,
name|zone
operator|->
name|stats
operator|.
name|total_allocated
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Total Overhead:                        %10lld\n"
argument_list|,
name|all_overhead
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Total Allocated:                       %10lld\n"
argument_list|,
name|all_allocated
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Total Overhead  under  32B:            %10lld\n"
argument_list|,
name|all_overhead_under32
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Total Allocated under  32B:            %10lld\n"
argument_list|,
name|all_allocated_under32
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Total Overhead  under  64B:            %10lld\n"
argument_list|,
name|all_overhead_under64
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Total Allocated under  64B:            %10lld\n"
argument_list|,
name|all_allocated_under64
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Total Overhead  under 128B:            %10lld\n"
argument_list|,
name|all_overhead_under128
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Total Allocated under 128B:            %10lld\n"
argument_list|,
name|all_allocated_under128
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Precompiled header support.  */
end_comment

begin_comment
comment|/* For precompiled headers, we sort objects based on their type.  We    also sort various objects into their own buckets; currently this    covers strings and IDENTIFIER_NODE trees.  The choices of how    to sort buckets have not yet been tuned.  */
end_comment

begin_define
define|#
directive|define
name|NUM_PCH_BUCKETS
value|(gt_types_enum_last + 3)
end_define

begin_define
define|#
directive|define
name|OTHER_BUCKET
value|(gt_types_enum_last + 0)
end_define

begin_define
define|#
directive|define
name|IDENTIFIER_BUCKET
value|(gt_types_enum_last + 1)
end_define

begin_define
define|#
directive|define
name|STRING_BUCKET
value|(gt_types_enum_last + 2)
end_define

begin_struct
struct|struct
name|ggc_pch_ondisk
block|{
name|size_t
name|total
decl_stmt|;
name|size_t
name|type_totals
index|[
name|NUM_PCH_BUCKETS
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ggc_pch_data
block|{
name|struct
name|ggc_pch_ondisk
name|d
decl_stmt|;
name|size_t
name|base
decl_stmt|;
name|size_t
name|orig_base
decl_stmt|;
name|size_t
name|alloc_size
decl_stmt|;
name|alloc_type
modifier|*
name|alloc_bits
decl_stmt|;
name|size_t
name|type_bases
index|[
name|NUM_PCH_BUCKETS
index|]
decl_stmt|;
name|size_t
name|start_offset
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Initialize the PCH data structure.  */
end_comment

begin_function
name|struct
name|ggc_pch_data
modifier|*
name|init_ggc_pch
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ggc_pch_data
argument_list|)
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return which of the page-aligned buckets the object at X, with type    TYPE, should be sorted into in the PCH.  Strings will have    IS_STRING set and TYPE will be gt_types_enum_last.  Other objects    of unknown type will also have TYPE equal to gt_types_enum_last.  */
end_comment

begin_function
specifier|static
name|int
name|pch_bucket
parameter_list|(
name|void
modifier|*
name|x
parameter_list|,
name|enum
name|gt_types_enum
name|type
parameter_list|,
name|bool
name|is_string
parameter_list|)
block|{
comment|/* Sort identifiers into their own bucket, to improve locality      when searching the identifier hash table.  */
if|if
condition|(
name|type
operator|==
name|gt_ggc_e_14lang_tree_node
operator|&&
name|TREE_CODE
argument_list|(
operator|(
name|tree
operator|)
name|x
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
return|return
name|IDENTIFIER_BUCKET
return|;
elseif|else
if|if
condition|(
name|type
operator|==
name|gt_types_enum_last
condition|)
block|{
if|if
condition|(
name|is_string
condition|)
return|return
name|STRING_BUCKET
return|;
return|return
name|OTHER_BUCKET
return|;
block|}
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Add the size of object X to the size of the PCH data.  */
end_comment

begin_function
name|void
name|ggc_pch_count_object
parameter_list|(
name|struct
name|ggc_pch_data
modifier|*
name|d
parameter_list|,
name|void
modifier|*
name|x
name|ATTRIBUTE_UNUSED
parameter_list|,
name|size_t
name|size
parameter_list|,
name|bool
name|is_string
parameter_list|,
name|enum
name|gt_types_enum
name|type
parameter_list|)
block|{
comment|/* NOTE: Right now we don't need to align up the size of any objects.      Strings can be unaligned, and everything else is allocated to a      MAX_ALIGNMENT boundary already.  */
name|d
operator|->
name|d
operator|.
name|type_totals
index|[
name|pch_bucket
argument_list|(
name|x
argument_list|,
name|type
argument_list|,
name|is_string
argument_list|)
index|]
operator|+=
name|size
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the total size of the PCH data.  */
end_comment

begin_function
name|size_t
name|ggc_pch_total_size
parameter_list|(
name|struct
name|ggc_pch_data
modifier|*
name|d
parameter_list|)
block|{
name|enum
name|gt_types_enum
name|i
decl_stmt|;
name|size_t
name|alloc_size
decl_stmt|,
name|total_size
decl_stmt|;
name|total_size
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_PCH_BUCKETS
condition|;
name|i
operator|++
control|)
block|{
name|d
operator|->
name|d
operator|.
name|type_totals
index|[
name|i
index|]
operator|=
name|ROUND_UP
argument_list|(
name|d
operator|->
name|d
operator|.
name|type_totals
index|[
name|i
index|]
argument_list|,
name|GGC_PAGE_SIZE
argument_list|)
expr_stmt|;
name|total_size
operator|+=
name|d
operator|->
name|d
operator|.
name|type_totals
index|[
name|i
index|]
expr_stmt|;
block|}
name|d
operator|->
name|d
operator|.
name|total
operator|=
name|total_size
expr_stmt|;
comment|/* Include the size of the allocation bitmap.  */
name|alloc_size
operator|=
name|CEIL
argument_list|(
name|d
operator|->
name|d
operator|.
name|total
argument_list|,
name|BYTES_PER_ALLOC_BIT
operator|*
literal|8
argument_list|)
expr_stmt|;
name|alloc_size
operator|=
name|ROUND_UP
argument_list|(
name|alloc_size
argument_list|,
name|MAX_ALIGNMENT
argument_list|)
expr_stmt|;
name|d
operator|->
name|alloc_size
operator|=
name|alloc_size
expr_stmt|;
return|return
name|d
operator|->
name|d
operator|.
name|total
operator|+
name|alloc_size
return|;
block|}
end_function

begin_comment
comment|/* Set the base address for the objects in the PCH file.  */
end_comment

begin_function
name|void
name|ggc_pch_this_base
parameter_list|(
name|struct
name|ggc_pch_data
modifier|*
name|d
parameter_list|,
name|void
modifier|*
name|base_
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|size_t
name|base
init|=
operator|(
name|size_t
operator|)
name|base_
decl_stmt|;
name|d
operator|->
name|base
operator|=
name|d
operator|->
name|orig_base
operator|=
name|base
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_PCH_BUCKETS
condition|;
name|i
operator|++
control|)
block|{
name|d
operator|->
name|type_bases
index|[
name|i
index|]
operator|=
name|base
expr_stmt|;
name|base
operator|+=
name|d
operator|->
name|d
operator|.
name|type_totals
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
name|d
operator|->
name|alloc_bits
operator|==
name|NULL
condition|)
name|d
operator|->
name|alloc_bits
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
name|d
operator|->
name|alloc_size
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Allocate a place for object X of size SIZE in the PCH file.  */
end_comment

begin_function
name|char
modifier|*
name|ggc_pch_alloc_object
parameter_list|(
name|struct
name|ggc_pch_data
modifier|*
name|d
parameter_list|,
name|void
modifier|*
name|x
parameter_list|,
name|size_t
name|size
parameter_list|,
name|bool
name|is_string
parameter_list|,
name|enum
name|gt_types_enum
name|type
parameter_list|)
block|{
name|size_t
name|alloc_word
decl_stmt|,
name|alloc_bit
decl_stmt|;
name|char
modifier|*
name|result
decl_stmt|;
name|int
name|bucket
init|=
name|pch_bucket
argument_list|(
name|x
argument_list|,
name|type
argument_list|,
name|is_string
argument_list|)
decl_stmt|;
comment|/* Record the start of the object in the allocation bitmap.  We      can't assert that the allocation bit is previously clear, because      strings may violate the invariant that they are at least      BYTES_PER_ALLOC_BIT long.  This is harmless - ggc_get_size      should not be called for strings.  */
name|alloc_word
operator|=
operator|(
operator|(
name|d
operator|->
name|type_bases
index|[
name|bucket
index|]
operator|-
name|d
operator|->
name|orig_base
operator|)
operator|/
operator|(
literal|8
operator|*
sizeof|sizeof
argument_list|(
name|alloc_type
argument_list|)
operator|*
name|BYTES_PER_ALLOC_BIT
operator|)
operator|)
expr_stmt|;
name|alloc_bit
operator|=
operator|(
operator|(
name|d
operator|->
name|type_bases
index|[
name|bucket
index|]
operator|-
name|d
operator|->
name|orig_base
operator|)
operator|/
name|BYTES_PER_ALLOC_BIT
operator|)
operator|%
operator|(
literal|8
operator|*
sizeof|sizeof
argument_list|(
name|alloc_type
argument_list|)
operator|)
expr_stmt|;
name|d
operator|->
name|alloc_bits
index|[
name|alloc_word
index|]
operator||=
literal|1L
operator|<<
name|alloc_bit
expr_stmt|;
comment|/* Place the object at the current pointer for this bucket.  */
name|result
operator|=
operator|(
name|char
operator|*
operator|)
name|d
operator|->
name|type_bases
index|[
name|bucket
index|]
expr_stmt|;
name|d
operator|->
name|type_bases
index|[
name|bucket
index|]
operator|+=
name|size
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Prepare to write out the PCH data to file F.  */
end_comment

begin_function
name|void
name|ggc_pch_prepare_write
parameter_list|(
name|struct
name|ggc_pch_data
modifier|*
name|d
parameter_list|,
name|FILE
modifier|*
name|f
parameter_list|)
block|{
comment|/* We seek around a lot while writing.  Record where the end      of the padding in the PCH file is, so that we can      locate each object's offset.  */
name|d
operator|->
name|start_offset
operator|=
name|ftell
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write out object X of SIZE to file F.  */
end_comment

begin_function
name|void
name|ggc_pch_write_object
parameter_list|(
name|struct
name|ggc_pch_data
modifier|*
name|d
parameter_list|,
name|FILE
modifier|*
name|f
parameter_list|,
name|void
modifier|*
name|x
parameter_list|,
name|void
modifier|*
name|newx
parameter_list|,
name|size_t
name|size
parameter_list|,
name|bool
name|is_string
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|fseek
argument_list|(
name|f
argument_list|,
operator|(
name|size_t
operator|)
name|newx
operator|-
name|d
operator|->
name|orig_base
operator|+
name|d
operator|->
name|start_offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
name|fatal_error
argument_list|(
literal|"can't seek PCH file: %m"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fwrite
argument_list|(
name|x
argument_list|,
name|size
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|!=
literal|1
condition|)
name|fatal_error
argument_list|(
literal|"can't write PCH file: %m"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ggc_pch_finish
parameter_list|(
name|struct
name|ggc_pch_data
modifier|*
name|d
parameter_list|,
name|FILE
modifier|*
name|f
parameter_list|)
block|{
comment|/* Write out the allocation bitmap.  */
if|if
condition|(
name|fseek
argument_list|(
name|f
argument_list|,
name|d
operator|->
name|start_offset
operator|+
name|d
operator|->
name|d
operator|.
name|total
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
name|fatal_error
argument_list|(
literal|"can't seek PCH file: %m"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fwrite
argument_list|(
name|d
operator|->
name|alloc_bits
argument_list|,
name|d
operator|->
name|alloc_size
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|!=
literal|1
condition|)
name|fatal_error
argument_list|(
literal|"can't write PCH fle: %m"
argument_list|)
expr_stmt|;
comment|/* Done with the PCH, so write out our footer.  */
if|if
condition|(
name|fwrite
argument_list|(
operator|&
name|d
operator|->
name|d
argument_list|,
sizeof|sizeof
argument_list|(
name|d
operator|->
name|d
argument_list|)
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|!=
literal|1
condition|)
name|fatal_error
argument_list|(
literal|"can't write PCH file: %m"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|d
operator|->
name|alloc_bits
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The PCH file from F has been mapped at ADDR.  Read in any    additional data from the file and set up the GC state.  */
end_comment

begin_function
name|void
name|ggc_pch_read
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|,
name|void
modifier|*
name|addr
parameter_list|)
block|{
name|struct
name|ggc_pch_ondisk
name|d
decl_stmt|;
name|size_t
name|alloc_size
decl_stmt|;
name|struct
name|alloc_zone
modifier|*
name|zone
decl_stmt|;
name|struct
name|page_entry
modifier|*
name|pch_page
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|fread
argument_list|(
operator|&
name|d
argument_list|,
sizeof|sizeof
argument_list|(
name|d
argument_list|)
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|!=
literal|1
condition|)
name|fatal_error
argument_list|(
literal|"can't read PCH file: %m"
argument_list|)
expr_stmt|;
name|alloc_size
operator|=
name|CEIL
argument_list|(
name|d
operator|.
name|total
argument_list|,
name|BYTES_PER_ALLOC_BIT
operator|*
literal|8
argument_list|)
expr_stmt|;
name|alloc_size
operator|=
name|ROUND_UP
argument_list|(
name|alloc_size
argument_list|,
name|MAX_ALIGNMENT
argument_list|)
expr_stmt|;
name|pch_zone
operator|.
name|bytes
operator|=
name|d
operator|.
name|total
expr_stmt|;
name|pch_zone
operator|.
name|alloc_bits
operator|=
operator|(
name|alloc_type
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|addr
operator|+
name|pch_zone
operator|.
name|bytes
operator|)
expr_stmt|;
name|pch_zone
operator|.
name|page
operator|=
operator|(
name|char
operator|*
operator|)
name|addr
expr_stmt|;
name|pch_zone
operator|.
name|end
operator|=
operator|(
name|char
operator|*
operator|)
name|pch_zone
operator|.
name|alloc_bits
expr_stmt|;
comment|/* We've just read in a PCH file.  So, every object that used to be      allocated is now free.  */
for|for
control|(
name|zone
operator|=
name|G
operator|.
name|zones
init|;
name|zone
condition|;
name|zone
operator|=
name|zone
operator|->
name|next_zone
control|)
block|{
name|struct
name|small_page_entry
modifier|*
name|page
decl_stmt|,
modifier|*
name|next_page
decl_stmt|;
name|struct
name|large_page_entry
modifier|*
name|large_page
decl_stmt|,
modifier|*
name|next_large_page
decl_stmt|;
name|zone
operator|->
name|allocated
operator|=
literal|0
expr_stmt|;
comment|/* Clear the zone's free chunk list.  */
name|memset
argument_list|(
name|zone
operator|->
name|free_chunks
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|zone
operator|->
name|free_chunks
argument_list|)
argument_list|)
expr_stmt|;
name|zone
operator|->
name|high_free_bin
operator|=
literal|0
expr_stmt|;
name|zone
operator|->
name|cached_free
operator|=
name|NULL
expr_stmt|;
name|zone
operator|->
name|cached_free_size
operator|=
literal|0
expr_stmt|;
comment|/* Move all the small pages onto the free list.  */
for|for
control|(
name|page
operator|=
name|zone
operator|->
name|pages
init|;
name|page
operator|!=
name|NULL
condition|;
name|page
operator|=
name|next_page
control|)
block|{
name|next_page
operator|=
name|page
operator|->
name|next
expr_stmt|;
name|memset
argument_list|(
name|page
operator|->
name|alloc_bits
argument_list|,
literal|0
argument_list|,
name|G
operator|.
name|small_page_overhead
operator|-
name|PAGE_OVERHEAD
argument_list|)
expr_stmt|;
name|free_small_page
argument_list|(
name|page
argument_list|)
expr_stmt|;
block|}
comment|/* Discard all the large pages.  */
for|for
control|(
name|large_page
operator|=
name|zone
operator|->
name|large_pages
init|;
name|large_page
operator|!=
name|NULL
condition|;
name|large_page
operator|=
name|next_large_page
control|)
block|{
name|next_large_page
operator|=
name|large_page
operator|->
name|next
expr_stmt|;
name|free_large_page
argument_list|(
name|large_page
argument_list|)
expr_stmt|;
block|}
name|zone
operator|->
name|pages
operator|=
name|NULL
expr_stmt|;
name|zone
operator|->
name|large_pages
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Allocate the dummy page entry for the PCH, and set all pages      mapped into the PCH to reference it.  */
name|pch_page
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|page_entry
argument_list|)
argument_list|)
expr_stmt|;
name|pch_page
operator|->
name|page
operator|=
name|pch_zone
operator|.
name|page
expr_stmt|;
name|pch_page
operator|->
name|pch_p
operator|=
name|true
expr_stmt|;
for|for
control|(
name|p
operator|=
name|pch_zone
operator|.
name|page
init|;
name|p
operator|<
name|pch_zone
operator|.
name|end
condition|;
name|p
operator|+=
name|GGC_PAGE_SIZE
control|)
name|set_page_table_entry
argument_list|(
name|p
argument_list|,
name|pch_page
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

