begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Tree lowering pass.  Lowers GIMPLE into unstructured form.     Copyright (C) 2003, 2005 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"varray.h"
end_include

begin_include
include|#
directive|include
file|"tree-gimple.h"
end_include

begin_include
include|#
directive|include
file|"tree-inline.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_include
include|#
directive|include
file|"langhooks-def.h"
end_include

begin_include
include|#
directive|include
file|"tree-flow.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"hashtab.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"tree-pass.h"
end_include

begin_struct
struct|struct
name|lower_data
block|{
comment|/* Block the current statement belongs to.  */
name|tree
name|block
decl_stmt|;
comment|/* A TREE_LIST of label and return statements to be moved to the end      of the function.  */
name|tree
name|return_statements
decl_stmt|;
comment|/* True if the function calls __builtin_setjmp.  */
name|bool
name|calls_builtin_setjmp
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|void
name|lower_stmt
parameter_list|(
name|tree_stmt_iterator
modifier|*
parameter_list|,
name|struct
name|lower_data
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lower_bind_expr
parameter_list|(
name|tree_stmt_iterator
modifier|*
parameter_list|,
name|struct
name|lower_data
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lower_cond_expr
parameter_list|(
name|tree_stmt_iterator
modifier|*
parameter_list|,
name|struct
name|lower_data
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lower_return_expr
parameter_list|(
name|tree_stmt_iterator
modifier|*
parameter_list|,
name|struct
name|lower_data
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lower_builtin_setjmp
parameter_list|(
name|tree_stmt_iterator
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Lower the body of current_function_decl.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|lower_function_body
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|lower_data
name|data
decl_stmt|;
name|tree
modifier|*
name|body_p
init|=
operator|&
name|DECL_SAVED_TREE
argument_list|(
name|current_function_decl
argument_list|)
decl_stmt|;
name|tree
name|bind
init|=
operator|*
name|body_p
decl_stmt|;
name|tree_stmt_iterator
name|i
decl_stmt|;
name|tree
name|t
decl_stmt|,
name|x
decl_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|bind
argument_list|)
operator|==
name|BIND_EXPR
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|data
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|data
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|.
name|block
operator|=
name|DECL_INITIAL
argument_list|(
name|current_function_decl
argument_list|)
expr_stmt|;
name|BLOCK_SUBBLOCKS
argument_list|(
name|data
operator|.
name|block
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|BLOCK_CHAIN
argument_list|(
name|data
operator|.
name|block
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|TREE_ASM_WRITTEN
argument_list|(
name|data
operator|.
name|block
argument_list|)
operator|=
literal|1
expr_stmt|;
operator|*
name|body_p
operator|=
name|alloc_stmt_list
argument_list|()
expr_stmt|;
name|i
operator|=
name|tsi_start
argument_list|(
operator|*
name|body_p
argument_list|)
expr_stmt|;
name|tsi_link_after
argument_list|(
operator|&
name|i
argument_list|,
name|bind
argument_list|,
name|TSI_NEW_STMT
argument_list|)
expr_stmt|;
name|lower_bind_expr
argument_list|(
operator|&
name|i
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
name|i
operator|=
name|tsi_last
argument_list|(
operator|*
name|body_p
argument_list|)
expr_stmt|;
comment|/* If the function falls off the end, we need a null return statement.      If we've already got one in the return_statements list, we don't      need to do anything special.  Otherwise build one by hand.  */
if|if
condition|(
name|block_may_fallthru
argument_list|(
operator|*
name|body_p
argument_list|)
operator|&&
operator|(
name|data
operator|.
name|return_statements
operator|==
name|NULL
operator|||
name|TREE_OPERAND
argument_list|(
name|TREE_VALUE
argument_list|(
name|data
operator|.
name|return_statements
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|!=
name|NULL
operator|)
condition|)
block|{
name|x
operator|=
name|build1
argument_list|(
name|RETURN_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|SET_EXPR_LOCATION
argument_list|(
name|x
argument_list|,
name|cfun
operator|->
name|function_end_locus
argument_list|)
expr_stmt|;
name|tsi_link_after
argument_list|(
operator|&
name|i
argument_list|,
name|x
argument_list|,
name|TSI_CONTINUE_LINKING
argument_list|)
expr_stmt|;
block|}
comment|/* If we lowered any return statements, emit the representative      at the end of the function.  */
for|for
control|(
name|t
operator|=
name|data
operator|.
name|return_statements
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|x
operator|=
name|build1
argument_list|(
name|LABEL_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|tsi_link_after
argument_list|(
operator|&
name|i
argument_list|,
name|x
argument_list|,
name|TSI_CONTINUE_LINKING
argument_list|)
expr_stmt|;
comment|/* Remove the line number from the representative return statement. 	 It now fills in for many such returns.  Failure to remove this 	 will result in incorrect results for coverage analysis.  */
name|x
operator|=
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_MAPPED_LOCATION
name|SET_EXPR_LOCATION
argument_list|(
name|x
argument_list|,
name|UNKNOWN_LOCATION
argument_list|)
expr_stmt|;
else|#
directive|else
name|SET_EXPR_LOCUS
argument_list|(
name|x
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tsi_link_after
argument_list|(
operator|&
name|i
argument_list|,
name|x
argument_list|,
name|TSI_CONTINUE_LINKING
argument_list|)
expr_stmt|;
block|}
comment|/* If the function calls __builtin_setjmp, we need to emit the computed      goto that will serve as the unique dispatcher for all the receivers.  */
if|if
condition|(
name|data
operator|.
name|calls_builtin_setjmp
condition|)
block|{
name|tree
name|disp_label
decl_stmt|,
name|disp_var
decl_stmt|,
name|arg
decl_stmt|;
comment|/* Build 'DISP_LABEL:' and insert.  */
name|disp_label
operator|=
name|create_artificial_label
argument_list|()
expr_stmt|;
comment|/* This mark will create forward edges from every call site.  */
name|DECL_NONLOCAL
argument_list|(
name|disp_label
argument_list|)
operator|=
literal|1
expr_stmt|;
name|current_function_has_nonlocal_label
operator|=
literal|1
expr_stmt|;
name|x
operator|=
name|build1
argument_list|(
name|LABEL_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|disp_label
argument_list|)
expr_stmt|;
name|tsi_link_after
argument_list|(
operator|&
name|i
argument_list|,
name|x
argument_list|,
name|TSI_CONTINUE_LINKING
argument_list|)
expr_stmt|;
comment|/* Build 'DISP_VAR = __builtin_setjmp_dispatcher (DISP_LABEL);' 	 and insert.  */
name|disp_var
operator|=
name|create_tmp_var
argument_list|(
name|ptr_type_node
argument_list|,
literal|"setjmpvar"
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_addr
argument_list|(
name|disp_label
argument_list|,
name|current_function_decl
argument_list|)
expr_stmt|;
name|arg
operator|=
name|tree_cons
argument_list|(
name|NULL
argument_list|,
name|t
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|t
operator|=
name|implicit_built_in_decls
index|[
name|BUILT_IN_SETJMP_DISPATCHER
index|]
expr_stmt|;
name|t
operator|=
name|build_function_call_expr
argument_list|(
name|t
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|x
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|disp_var
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|/* Build 'goto DISP_VAR;' and insert.  */
name|tsi_link_after
argument_list|(
operator|&
name|i
argument_list|,
name|x
argument_list|,
name|TSI_CONTINUE_LINKING
argument_list|)
expr_stmt|;
name|x
operator|=
name|build1
argument_list|(
name|GOTO_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|disp_var
argument_list|)
expr_stmt|;
name|tsi_link_after
argument_list|(
operator|&
name|i
argument_list|,
name|x
argument_list|,
name|TSI_CONTINUE_LINKING
argument_list|)
expr_stmt|;
block|}
name|gcc_assert
argument_list|(
name|data
operator|.
name|block
operator|==
name|DECL_INITIAL
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
expr_stmt|;
name|BLOCK_SUBBLOCKS
argument_list|(
name|data
operator|.
name|block
argument_list|)
operator|=
name|blocks_nreverse
argument_list|(
name|BLOCK_SUBBLOCKS
argument_list|(
name|data
operator|.
name|block
argument_list|)
argument_list|)
expr_stmt|;
name|clear_block_marks
argument_list|(
name|data
operator|.
name|block
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|tree_opt_pass
name|pass_lower_cf
init|=
block|{
literal|"lower"
block|,
comment|/* name */
name|NULL
block|,
comment|/* gate */
name|lower_function_body
block|,
comment|/* execute */
name|NULL
block|,
comment|/* sub */
name|NULL
block|,
comment|/* next */
literal|0
block|,
comment|/* static_pass_number */
literal|0
block|,
comment|/* tv_id */
name|PROP_gimple_any
block|,
comment|/* properties_required */
name|PROP_gimple_lcf
block|,
comment|/* properties_provided */
literal|0
block|,
comment|/* properties_destroyed */
literal|0
block|,
comment|/* todo_flags_start */
name|TODO_dump_func
block|,
comment|/* todo_flags_finish */
literal|0
comment|/* letter */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Lower the EXPR.  Unlike gimplification the statements are not relowered    when they are changed -- if this has to be done, the lowering routine must    do it explicitly.  DATA is passed through the recursion.  */
end_comment

begin_function
specifier|static
name|void
name|lower_stmt_body
parameter_list|(
name|tree
name|expr
parameter_list|,
name|struct
name|lower_data
modifier|*
name|data
parameter_list|)
block|{
name|tree_stmt_iterator
name|tsi
decl_stmt|;
for|for
control|(
name|tsi
operator|=
name|tsi_start
argument_list|(
name|expr
argument_list|)
init|;
operator|!
name|tsi_end_p
argument_list|(
name|tsi
argument_list|)
condition|;
control|)
name|lower_stmt
argument_list|(
operator|&
name|tsi
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Lower the OpenMP directive statement pointed by TSI.  DATA is    passed through the recursion.  */
end_comment

begin_function
specifier|static
name|void
name|lower_omp_directive
parameter_list|(
name|tree_stmt_iterator
modifier|*
name|tsi
parameter_list|,
name|struct
name|lower_data
modifier|*
name|data
parameter_list|)
block|{
name|tree
name|stmt
decl_stmt|;
name|stmt
operator|=
name|tsi_stmt
argument_list|(
operator|*
name|tsi
argument_list|)
expr_stmt|;
name|lower_stmt_body
argument_list|(
name|OMP_BODY
argument_list|(
name|stmt
argument_list|)
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|tsi_link_before
argument_list|(
name|tsi
argument_list|,
name|stmt
argument_list|,
name|TSI_SAME_STMT
argument_list|)
expr_stmt|;
name|tsi_link_before
argument_list|(
name|tsi
argument_list|,
name|OMP_BODY
argument_list|(
name|stmt
argument_list|)
argument_list|,
name|TSI_SAME_STMT
argument_list|)
expr_stmt|;
name|OMP_BODY
argument_list|(
name|stmt
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|tsi_delink
argument_list|(
name|tsi
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Lower statement TSI.  DATA is passed through the recursion.  */
end_comment

begin_function
specifier|static
name|void
name|lower_stmt
parameter_list|(
name|tree_stmt_iterator
modifier|*
name|tsi
parameter_list|,
name|struct
name|lower_data
modifier|*
name|data
parameter_list|)
block|{
name|tree
name|stmt
init|=
name|tsi_stmt
argument_list|(
operator|*
name|tsi
argument_list|)
decl_stmt|;
if|if
condition|(
name|EXPR_HAS_LOCATION
argument_list|(
name|stmt
argument_list|)
operator|&&
name|data
condition|)
name|TREE_BLOCK
argument_list|(
name|stmt
argument_list|)
operator|=
name|data
operator|->
name|block
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
condition|)
block|{
case|case
name|BIND_EXPR
case|:
name|lower_bind_expr
argument_list|(
name|tsi
argument_list|,
name|data
argument_list|)
expr_stmt|;
return|return;
case|case
name|COND_EXPR
case|:
name|lower_cond_expr
argument_list|(
name|tsi
argument_list|,
name|data
argument_list|)
expr_stmt|;
return|return;
case|case
name|RETURN_EXPR
case|:
name|lower_return_expr
argument_list|(
name|tsi
argument_list|,
name|data
argument_list|)
expr_stmt|;
return|return;
case|case
name|TRY_FINALLY_EXPR
case|:
case|case
name|TRY_CATCH_EXPR
case|:
name|lower_stmt_body
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|lower_stmt_body
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|CATCH_EXPR
case|:
name|lower_stmt_body
argument_list|(
name|CATCH_BODY
argument_list|(
name|stmt
argument_list|)
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|EH_FILTER_EXPR
case|:
name|lower_stmt_body
argument_list|(
name|EH_FILTER_FAILURE
argument_list|(
name|stmt
argument_list|)
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|NOP_EXPR
case|:
case|case
name|ASM_EXPR
case|:
case|case
name|GOTO_EXPR
case|:
case|case
name|LABEL_EXPR
case|:
case|case
name|SWITCH_EXPR
case|:
case|case
name|OMP_FOR
case|:
case|case
name|OMP_SECTIONS
case|:
case|case
name|OMP_SECTION
case|:
case|case
name|OMP_SINGLE
case|:
case|case
name|OMP_MASTER
case|:
case|case
name|OMP_ORDERED
case|:
case|case
name|OMP_CRITICAL
case|:
case|case
name|OMP_RETURN
case|:
case|case
name|OMP_CONTINUE
case|:
break|break;
case|case
name|MODIFY_EXPR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CALL_EXPR
condition|)
name|stmt
operator|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
break|break;
comment|/* FALLTHRU */
case|case
name|CALL_EXPR
case|:
block|{
name|tree
name|decl
init|=
name|get_callee_fndecl
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
if|if
condition|(
name|decl
operator|&&
name|DECL_BUILT_IN_CLASS
argument_list|(
name|decl
argument_list|)
operator|==
name|BUILT_IN_NORMAL
operator|&&
name|DECL_FUNCTION_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|BUILT_IN_SETJMP
condition|)
block|{
name|data
operator|->
name|calls_builtin_setjmp
operator|=
name|true
expr_stmt|;
name|lower_builtin_setjmp
argument_list|(
name|tsi
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
break|break;
case|case
name|OMP_PARALLEL
case|:
name|lower_omp_directive
argument_list|(
name|tsi
argument_list|,
name|data
argument_list|)
expr_stmt|;
return|return;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|tsi_next
argument_list|(
name|tsi
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Lower a bind_expr TSI.  DATA is passed through the recursion.  */
end_comment

begin_function
specifier|static
name|void
name|lower_bind_expr
parameter_list|(
name|tree_stmt_iterator
modifier|*
name|tsi
parameter_list|,
name|struct
name|lower_data
modifier|*
name|data
parameter_list|)
block|{
name|tree
name|old_block
init|=
name|data
operator|->
name|block
decl_stmt|;
name|tree
name|stmt
init|=
name|tsi_stmt
argument_list|(
operator|*
name|tsi
argument_list|)
decl_stmt|;
name|tree
name|new_block
init|=
name|BIND_EXPR_BLOCK
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
if|if
condition|(
name|new_block
condition|)
block|{
if|if
condition|(
name|new_block
operator|==
name|old_block
condition|)
block|{
comment|/* The outermost block of the original function may not be the 	     outermost statement chain of the gimplified function.  So we 	     may see the outermost block just inside the function.  */
name|gcc_assert
argument_list|(
name|new_block
operator|==
name|DECL_INITIAL
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
expr_stmt|;
name|new_block
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
comment|/* We do not expect to handle duplicate blocks.  */
name|gcc_assert
argument_list|(
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|new_block
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_ASM_WRITTEN
argument_list|(
name|new_block
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Block tree may get clobbered by inlining.  Normally this would 	     be fixed in rest_of_decl_compilation using block notes, but 	     since we are not going to emit them, it is up to us.  */
name|BLOCK_CHAIN
argument_list|(
name|new_block
argument_list|)
operator|=
name|BLOCK_SUBBLOCKS
argument_list|(
name|old_block
argument_list|)
expr_stmt|;
name|BLOCK_SUBBLOCKS
argument_list|(
name|old_block
argument_list|)
operator|=
name|new_block
expr_stmt|;
name|BLOCK_SUBBLOCKS
argument_list|(
name|new_block
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|BLOCK_SUPERCONTEXT
argument_list|(
name|new_block
argument_list|)
operator|=
name|old_block
expr_stmt|;
name|data
operator|->
name|block
operator|=
name|new_block
expr_stmt|;
block|}
block|}
name|record_vars
argument_list|(
name|BIND_EXPR_VARS
argument_list|(
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
name|lower_stmt_body
argument_list|(
name|BIND_EXPR_BODY
argument_list|(
name|stmt
argument_list|)
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_block
condition|)
block|{
name|gcc_assert
argument_list|(
name|data
operator|->
name|block
operator|==
name|new_block
argument_list|)
expr_stmt|;
name|BLOCK_SUBBLOCKS
argument_list|(
name|new_block
argument_list|)
operator|=
name|blocks_nreverse
argument_list|(
name|BLOCK_SUBBLOCKS
argument_list|(
name|new_block
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|->
name|block
operator|=
name|old_block
expr_stmt|;
block|}
comment|/* The BIND_EXPR no longer carries any useful information -- kill it.  */
name|tsi_link_before
argument_list|(
name|tsi
argument_list|,
name|BIND_EXPR_BODY
argument_list|(
name|stmt
argument_list|)
argument_list|,
name|TSI_SAME_STMT
argument_list|)
expr_stmt|;
name|tsi_delink
argument_list|(
name|tsi
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Try to determine whether a TRY_CATCH expression can fall through.    This is a subroutine of block_may_fallthru.  */
end_comment

begin_function
specifier|static
name|bool
name|try_catch_may_fallthru
parameter_list|(
name|tree
name|stmt
parameter_list|)
block|{
name|tree_stmt_iterator
name|i
decl_stmt|;
comment|/* If the TRY block can fall through, the whole TRY_CATCH can      fall through.  */
if|if
condition|(
name|block_may_fallthru
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
name|i
operator|=
name|tsi_start
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|tsi_stmt
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|CATCH_EXPR
case|:
comment|/* We expect to see a sequence of CATCH_EXPR trees, each with a 	 catch expression and a body.  The whole TRY_CATCH may fall 	 through iff any of the catch bodies falls through.  */
for|for
control|(
init|;
operator|!
name|tsi_end_p
argument_list|(
name|i
argument_list|)
condition|;
name|tsi_next
argument_list|(
operator|&
name|i
argument_list|)
control|)
block|{
if|if
condition|(
name|block_may_fallthru
argument_list|(
name|CATCH_BODY
argument_list|(
name|tsi_stmt
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
block|}
return|return
name|false
return|;
case|case
name|EH_FILTER_EXPR
case|:
comment|/* The exception filter expression only matters if there is an 	 exception.  If the exception does not match EH_FILTER_TYPES, 	 we will execute EH_FILTER_FAILURE, and we will fall through 	 if that falls through.  If the exception does match 	 EH_FILTER_TYPES, the stack unwinder will continue up the 	 stack, so we will not fall through.  We don't know whether we 	 will throw an exception which matches EH_FILTER_TYPES or not, 	 so we just ignore EH_FILTER_TYPES and assume that we might 	 throw an exception which doesn't match.  */
return|return
name|block_may_fallthru
argument_list|(
name|EH_FILTER_FAILURE
argument_list|(
name|tsi_stmt
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
return|;
default|default:
comment|/* This case represents statements to be executed when an 	 exception occurs.  Those statements are implicitly followed 	 by a RESX_EXPR to resume execution after the exception.  So 	 in this case the TRY_CATCH never falls through.  */
return|return
name|false
return|;
block|}
block|}
end_function

begin_comment
comment|/* Try to determine if we can fall out of the bottom of BLOCK.  This guess    need not be 100% accurate; simply be conservative and return true if we    don't know.  This is used only to avoid stupidly generating extra code.    If we're wrong, we'll just delete the extra code later.  */
end_comment

begin_function
name|bool
name|block_may_fallthru
parameter_list|(
name|tree
name|block
parameter_list|)
block|{
name|tree
name|stmt
init|=
name|expr_last
argument_list|(
name|block
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|stmt
condition|?
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
else|:
name|ERROR_MARK
condition|)
block|{
case|case
name|GOTO_EXPR
case|:
case|case
name|RETURN_EXPR
case|:
case|case
name|RESX_EXPR
case|:
comment|/* Easy cases.  If the last statement of the block implies  	 control transfer, then we can't fall through.  */
return|return
name|false
return|;
case|case
name|SWITCH_EXPR
case|:
comment|/* If SWITCH_LABELS is set, this is lowered, and represents a 	 branch to a selected label and hence can not fall through. 	 Otherwise SWITCH_BODY is set, and the switch can fall 	 through.  */
return|return
name|SWITCH_LABELS
argument_list|(
name|stmt
argument_list|)
operator|==
name|NULL_TREE
return|;
case|case
name|COND_EXPR
case|:
if|if
condition|(
name|block_may_fallthru
argument_list|(
name|COND_EXPR_THEN
argument_list|(
name|stmt
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
return|return
name|block_may_fallthru
argument_list|(
name|COND_EXPR_ELSE
argument_list|(
name|stmt
argument_list|)
argument_list|)
return|;
case|case
name|BIND_EXPR
case|:
return|return
name|block_may_fallthru
argument_list|(
name|BIND_EXPR_BODY
argument_list|(
name|stmt
argument_list|)
argument_list|)
return|;
case|case
name|TRY_CATCH_EXPR
case|:
return|return
name|try_catch_may_fallthru
argument_list|(
name|stmt
argument_list|)
return|;
case|case
name|TRY_FINALLY_EXPR
case|:
comment|/* The finally clause is always executed after the try clause, 	 so if it does not fall through, then the try-finally will not 	 fall through.  Otherwise, if the try clause does not fall 	 through, then when the finally clause falls through it will 	 resume execution wherever the try clause was going.  So the 	 whole try-finally will only fall through if both the try 	 clause and the finally clause fall through.  */
return|return
operator|(
name|block_may_fallthru
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|block_may_fallthru
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|MODIFY_EXPR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CALL_EXPR
condition|)
name|stmt
operator|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
return|return
name|true
return|;
comment|/* FALLTHRU */
case|case
name|CALL_EXPR
case|:
comment|/* Functions that do not return do not fall through.  */
return|return
operator|(
name|call_expr_flags
argument_list|(
name|stmt
argument_list|)
operator|&
name|ECF_NORETURN
operator|)
operator|==
literal|0
return|;
case|case
name|CLEANUP_POINT_EXPR
case|:
return|return
name|block_may_fallthru
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
default|default:
return|return
name|true
return|;
block|}
block|}
end_function

begin_comment
comment|/* Lower a cond_expr TSI.  DATA is passed through the recursion.  */
end_comment

begin_function
specifier|static
name|void
name|lower_cond_expr
parameter_list|(
name|tree_stmt_iterator
modifier|*
name|tsi
parameter_list|,
name|struct
name|lower_data
modifier|*
name|data
parameter_list|)
block|{
name|tree
name|stmt
init|=
name|tsi_stmt
argument_list|(
operator|*
name|tsi
argument_list|)
decl_stmt|;
name|bool
name|then_is_goto
decl_stmt|,
name|else_is_goto
decl_stmt|;
name|tree
name|then_branch
decl_stmt|,
name|else_branch
decl_stmt|;
name|tree
name|then_goto
decl_stmt|,
name|else_goto
decl_stmt|;
name|then_branch
operator|=
name|COND_EXPR_THEN
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|else_branch
operator|=
name|COND_EXPR_ELSE
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|lower_stmt_body
argument_list|(
name|then_branch
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|lower_stmt_body
argument_list|(
name|else_branch
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|then_goto
operator|=
name|expr_only
argument_list|(
name|then_branch
argument_list|)
expr_stmt|;
name|then_is_goto
operator|=
name|then_goto
operator|&&
name|simple_goto_p
argument_list|(
name|then_goto
argument_list|)
expr_stmt|;
name|else_goto
operator|=
name|expr_only
argument_list|(
name|else_branch
argument_list|)
expr_stmt|;
name|else_is_goto
operator|=
name|else_goto
operator|&&
name|simple_goto_p
argument_list|(
name|else_goto
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|then_is_goto
operator|||
operator|!
name|else_is_goto
condition|)
block|{
name|tree
name|then_label
decl_stmt|,
name|else_label
decl_stmt|,
name|end_label
decl_stmt|,
name|t
decl_stmt|;
name|then_label
operator|=
name|NULL_TREE
expr_stmt|;
name|else_label
operator|=
name|NULL_TREE
expr_stmt|;
name|end_label
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Replace the cond_expr with explicit gotos.  */
if|if
condition|(
operator|!
name|then_is_goto
condition|)
block|{
name|t
operator|=
name|build1
argument_list|(
name|LABEL_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|then_branch
argument_list|)
condition|)
name|then_label
operator|=
name|t
expr_stmt|;
else|else
name|end_label
operator|=
name|t
expr_stmt|;
name|then_goto
operator|=
name|build_and_jump
argument_list|(
operator|&
name|LABEL_EXPR_LABEL
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|else_is_goto
condition|)
block|{
name|t
operator|=
name|build1
argument_list|(
name|LABEL_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|else_branch
argument_list|)
condition|)
name|else_label
operator|=
name|t
expr_stmt|;
else|else
block|{
comment|/* Both THEN and ELSE can be no-ops if one or both contained an 	         empty BIND_EXPR that was associated with the toplevel block 	         of an inlined function.  In that case remove_useless_stmts 	         can't have cleaned things up for us; kill the whole  	         conditional now.  */
if|if
condition|(
name|end_label
condition|)
block|{
name|tsi_delink
argument_list|(
name|tsi
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
name|end_label
operator|=
name|t
expr_stmt|;
block|}
name|else_goto
operator|=
name|build_and_jump
argument_list|(
operator|&
name|LABEL_EXPR_LABEL
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|then_label
condition|)
block|{
name|bool
name|may_fallthru
init|=
name|block_may_fallthru
argument_list|(
name|then_branch
argument_list|)
decl_stmt|;
name|tsi_link_after
argument_list|(
name|tsi
argument_list|,
name|then_label
argument_list|,
name|TSI_CONTINUE_LINKING
argument_list|)
expr_stmt|;
name|tsi_link_after
argument_list|(
name|tsi
argument_list|,
name|then_branch
argument_list|,
name|TSI_CONTINUE_LINKING
argument_list|)
expr_stmt|;
if|if
condition|(
name|else_label
operator|&&
name|may_fallthru
condition|)
block|{
name|end_label
operator|=
name|build1
argument_list|(
name|LABEL_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_and_jump
argument_list|(
operator|&
name|LABEL_EXPR_LABEL
argument_list|(
name|end_label
argument_list|)
argument_list|)
expr_stmt|;
name|tsi_link_after
argument_list|(
name|tsi
argument_list|,
name|t
argument_list|,
name|TSI_CONTINUE_LINKING
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|else_label
condition|)
block|{
name|tsi_link_after
argument_list|(
name|tsi
argument_list|,
name|else_label
argument_list|,
name|TSI_CONTINUE_LINKING
argument_list|)
expr_stmt|;
name|tsi_link_after
argument_list|(
name|tsi
argument_list|,
name|else_branch
argument_list|,
name|TSI_CONTINUE_LINKING
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|end_label
condition|)
name|tsi_link_after
argument_list|(
name|tsi
argument_list|,
name|end_label
argument_list|,
name|TSI_CONTINUE_LINKING
argument_list|)
expr_stmt|;
block|}
name|COND_EXPR_THEN
argument_list|(
name|stmt
argument_list|)
operator|=
name|then_goto
expr_stmt|;
name|COND_EXPR_ELSE
argument_list|(
name|stmt
argument_list|)
operator|=
name|else_goto
expr_stmt|;
name|tsi_next
argument_list|(
name|tsi
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Lower a return_expr TSI.  DATA is passed through the recursion.  */
end_comment

begin_function
specifier|static
name|void
name|lower_return_expr
parameter_list|(
name|tree_stmt_iterator
modifier|*
name|tsi
parameter_list|,
name|struct
name|lower_data
modifier|*
name|data
parameter_list|)
block|{
name|tree
name|stmt
init|=
name|tsi_stmt
argument_list|(
operator|*
name|tsi
argument_list|)
decl_stmt|;
name|tree
name|value
decl_stmt|,
name|t
decl_stmt|,
name|label
decl_stmt|;
comment|/* Extract the value being returned.  */
name|value
operator|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|&&
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|MODIFY_EXPR
condition|)
name|value
operator|=
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Match this up with an existing return statement that's been created.  */
for|for
control|(
name|t
operator|=
name|data
operator|->
name|return_statements
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|tree
name|tvalue
init|=
name|TREE_OPERAND
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|tvalue
operator|&&
name|TREE_CODE
argument_list|(
name|tvalue
argument_list|)
operator|==
name|MODIFY_EXPR
condition|)
name|tvalue
operator|=
name|TREE_OPERAND
argument_list|(
name|tvalue
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
name|tvalue
condition|)
block|{
name|label
operator|=
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
expr_stmt|;
goto|goto
name|found
goto|;
block|}
block|}
comment|/* Not found.  Create a new label and record the return statement.  */
name|label
operator|=
name|create_artificial_label
argument_list|()
expr_stmt|;
name|data
operator|->
name|return_statements
operator|=
name|tree_cons
argument_list|(
name|label
argument_list|,
name|stmt
argument_list|,
name|data
operator|->
name|return_statements
argument_list|)
expr_stmt|;
comment|/* Generate a goto statement and remove the return statement.  */
name|found
label|:
name|t
operator|=
name|build1
argument_list|(
name|GOTO_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|SET_EXPR_LOCUS
argument_list|(
name|t
argument_list|,
name|EXPR_LOCUS
argument_list|(
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
name|tsi_link_before
argument_list|(
name|tsi
argument_list|,
name|t
argument_list|,
name|TSI_SAME_STMT
argument_list|)
expr_stmt|;
name|tsi_delink
argument_list|(
name|tsi
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Lower a __builtin_setjmp TSI.     __builtin_setjmp is passed a pointer to an array of five words (not    all will be used on all machines).  It operates similarly to the C    library function of the same name, but is more efficient.     It is lowered into 3 other builtins, namely __builtin_setjmp_setup,    __builtin_setjmp_dispatcher and __builtin_setjmp_receiver, but with    __builtin_setjmp_dispatcher shared among all the instances; that's    why it is only emitted at the end by lower_function_body.     After full lowering, the body of the function should look like:      {       void * setjmpvar.0;       int D.1844;       int D.2844;        [...]        __builtin_setjmp_setup (&buf,&<D1847>);       D.1844 = 0;       goto<D1846>;<D1847>:;       __builtin_setjmp_receiver (&<D1847>);       D.1844 = 1;<D1846>:;       if (D.1844 == 0) goto<D1848>; else goto<D1849>;        [...]        __builtin_setjmp_setup (&buf,&<D2847>);       D.2844 = 0;       goto<D2846>;<D2847>:;       __builtin_setjmp_receiver (&<D2847>);       D.2844 = 1;<D2846>:;       if (D.2844 == 0) goto<D2848>; else goto<D2849>;        [...]<D3850>:;       return;<D3853>: [non-local];       setjmpvar.0 = __builtin_setjmp_dispatcher (&<D3853>);       goto setjmpvar.0;     }     The dispatcher block will be both the unique destination of all the    abnormal call edges and the unique source of all the abnormal edges    to the receivers, thus keeping the complexity explosion localized.  */
end_comment

begin_function
specifier|static
name|void
name|lower_builtin_setjmp
parameter_list|(
name|tree_stmt_iterator
modifier|*
name|tsi
parameter_list|)
block|{
name|tree
name|stmt
init|=
name|tsi_stmt
argument_list|(
operator|*
name|tsi
argument_list|)
decl_stmt|;
name|tree
name|cont_label
init|=
name|create_artificial_label
argument_list|()
decl_stmt|;
name|tree
name|next_label
init|=
name|create_artificial_label
argument_list|()
decl_stmt|;
name|tree
name|dest
decl_stmt|,
name|t
decl_stmt|,
name|arg
decl_stmt|;
comment|/* NEXT_LABEL is the label __builtin_longjmp will jump to.  Its address is      passed to both __builtin_setjmp_setup and __builtin_setjmp_receiver.  */
name|FORCED_LABEL
argument_list|(
name|next_label
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|MODIFY_EXPR
condition|)
block|{
name|dest
operator|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|dest
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Build '__builtin_setjmp_setup (BUF, NEXT_LABEL)' and insert.  */
name|t
operator|=
name|build_addr
argument_list|(
name|next_label
argument_list|,
name|current_function_decl
argument_list|)
expr_stmt|;
name|arg
operator|=
name|tree_cons
argument_list|(
name|NULL
argument_list|,
name|t
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|t
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|arg
operator|=
name|tree_cons
argument_list|(
name|NULL
argument_list|,
name|t
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|t
operator|=
name|implicit_built_in_decls
index|[
name|BUILT_IN_SETJMP_SETUP
index|]
expr_stmt|;
name|t
operator|=
name|build_function_call_expr
argument_list|(
name|t
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|SET_EXPR_LOCUS
argument_list|(
name|t
argument_list|,
name|EXPR_LOCUS
argument_list|(
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
name|tsi_link_before
argument_list|(
name|tsi
argument_list|,
name|t
argument_list|,
name|TSI_SAME_STMT
argument_list|)
expr_stmt|;
comment|/* Build 'DEST = 0' and insert.  */
if|if
condition|(
name|dest
condition|)
block|{
name|t
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|dest
argument_list|,
name|integer_zero_node
argument_list|)
expr_stmt|;
name|SET_EXPR_LOCUS
argument_list|(
name|t
argument_list|,
name|EXPR_LOCUS
argument_list|(
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
name|tsi_link_before
argument_list|(
name|tsi
argument_list|,
name|t
argument_list|,
name|TSI_SAME_STMT
argument_list|)
expr_stmt|;
block|}
comment|/* Build 'goto CONT_LABEL' and insert.  */
name|t
operator|=
name|build1
argument_list|(
name|GOTO_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|cont_label
argument_list|)
expr_stmt|;
name|tsi_link_before
argument_list|(
name|tsi
argument_list|,
name|t
argument_list|,
name|TSI_SAME_STMT
argument_list|)
expr_stmt|;
comment|/* Build 'NEXT_LABEL:' and insert.  */
name|t
operator|=
name|build1
argument_list|(
name|LABEL_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|next_label
argument_list|)
expr_stmt|;
name|tsi_link_before
argument_list|(
name|tsi
argument_list|,
name|t
argument_list|,
name|TSI_SAME_STMT
argument_list|)
expr_stmt|;
comment|/* Build '__builtin_setjmp_receiver (NEXT_LABEL)' and insert.  */
name|t
operator|=
name|build_addr
argument_list|(
name|next_label
argument_list|,
name|current_function_decl
argument_list|)
expr_stmt|;
name|arg
operator|=
name|tree_cons
argument_list|(
name|NULL
argument_list|,
name|t
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|t
operator|=
name|implicit_built_in_decls
index|[
name|BUILT_IN_SETJMP_RECEIVER
index|]
expr_stmt|;
name|t
operator|=
name|build_function_call_expr
argument_list|(
name|t
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|SET_EXPR_LOCUS
argument_list|(
name|t
argument_list|,
name|EXPR_LOCUS
argument_list|(
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
name|tsi_link_before
argument_list|(
name|tsi
argument_list|,
name|t
argument_list|,
name|TSI_SAME_STMT
argument_list|)
expr_stmt|;
comment|/* Build 'DEST = 1' and insert.  */
if|if
condition|(
name|dest
condition|)
block|{
name|t
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|dest
argument_list|,
name|integer_one_node
argument_list|)
expr_stmt|;
name|SET_EXPR_LOCUS
argument_list|(
name|t
argument_list|,
name|EXPR_LOCUS
argument_list|(
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
name|tsi_link_before
argument_list|(
name|tsi
argument_list|,
name|t
argument_list|,
name|TSI_SAME_STMT
argument_list|)
expr_stmt|;
block|}
comment|/* Build 'CONT_LABEL:' and insert.  */
name|t
operator|=
name|build1
argument_list|(
name|LABEL_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|cont_label
argument_list|)
expr_stmt|;
name|tsi_link_before
argument_list|(
name|tsi
argument_list|,
name|t
argument_list|,
name|TSI_SAME_STMT
argument_list|)
expr_stmt|;
comment|/* Remove the call to __builtin_setjmp.  */
name|tsi_delink
argument_list|(
name|tsi
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Record the variables in VARS into function FN.  */
end_comment

begin_function
name|void
name|record_vars_into
parameter_list|(
name|tree
name|vars
parameter_list|,
name|tree
name|fn
parameter_list|)
block|{
name|struct
name|function
modifier|*
name|saved_cfun
init|=
name|cfun
decl_stmt|;
if|if
condition|(
name|fn
operator|!=
name|current_function_decl
condition|)
name|cfun
operator|=
name|DECL_STRUCT_FUNCTION
argument_list|(
name|fn
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|vars
condition|;
name|vars
operator|=
name|TREE_CHAIN
argument_list|(
name|vars
argument_list|)
control|)
block|{
name|tree
name|var
init|=
name|vars
decl_stmt|;
comment|/* BIND_EXPRs contains also function/type/constant declarations          we don't need to care about.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|var
argument_list|)
operator|!=
name|VAR_DECL
condition|)
continue|continue;
comment|/* Nothing to do in this case.  */
if|if
condition|(
name|DECL_EXTERNAL
argument_list|(
name|var
argument_list|)
condition|)
continue|continue;
comment|/* Record the variable.  */
name|cfun
operator|->
name|unexpanded_var_list
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|var
argument_list|,
name|cfun
operator|->
name|unexpanded_var_list
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fn
operator|!=
name|current_function_decl
condition|)
name|cfun
operator|=
name|saved_cfun
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Record the variables in VARS into current_function_decl.  */
end_comment

begin_function
name|void
name|record_vars
parameter_list|(
name|tree
name|vars
parameter_list|)
block|{
name|record_vars_into
argument_list|(
name|vars
argument_list|,
name|current_function_decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Mark BLOCK used if it has a used variable in it, then recurse over its    subblocks.  */
end_comment

begin_function
specifier|static
name|void
name|mark_blocks_with_used_vars
parameter_list|(
name|tree
name|block
parameter_list|)
block|{
name|tree
name|var
decl_stmt|;
name|tree
name|subblock
decl_stmt|;
if|if
condition|(
operator|!
name|TREE_USED
argument_list|(
name|block
argument_list|)
condition|)
block|{
for|for
control|(
name|var
operator|=
name|BLOCK_VARS
argument_list|(
name|block
argument_list|)
init|;
name|var
condition|;
name|var
operator|=
name|TREE_CHAIN
argument_list|(
name|var
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_USED
argument_list|(
name|var
argument_list|)
condition|)
block|{
name|TREE_USED
argument_list|(
name|block
argument_list|)
operator|=
name|true
expr_stmt|;
break|break;
block|}
block|}
block|}
for|for
control|(
name|subblock
operator|=
name|BLOCK_SUBBLOCKS
argument_list|(
name|block
argument_list|)
init|;
name|subblock
condition|;
name|subblock
operator|=
name|BLOCK_CHAIN
argument_list|(
name|subblock
argument_list|)
control|)
name|mark_blocks_with_used_vars
argument_list|(
name|subblock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Mark the used attribute on blocks correctly.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|mark_used_blocks
parameter_list|(
name|void
parameter_list|)
block|{
name|mark_blocks_with_used_vars
argument_list|(
name|DECL_INITIAL
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|tree_opt_pass
name|pass_mark_used_blocks
init|=
block|{
literal|"blocks"
block|,
comment|/* name */
name|NULL
block|,
comment|/* gate */
name|mark_used_blocks
block|,
comment|/* execute */
name|NULL
block|,
comment|/* sub */
name|NULL
block|,
comment|/* next */
literal|0
block|,
comment|/* static_pass_number */
literal|0
block|,
comment|/* tv_id */
literal|0
block|,
comment|/* properties_required */
literal|0
block|,
comment|/* properties_provided */
literal|0
block|,
comment|/* properties_destroyed */
literal|0
block|,
comment|/* todo_flags_start */
name|TODO_dump_func
block|,
comment|/* todo_flags_finish */
literal|0
comment|/* letter */
block|}
decl_stmt|;
end_decl_stmt

end_unit

