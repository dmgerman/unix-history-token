begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Reassociation for trees.    Copyright (C) 2005 Free Software Foundation, Inc.    Contributed by Daniel Berlin<dan@dberlin.org>  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"errors.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_include
include|#
directive|include
file|"tree-inline.h"
end_include

begin_include
include|#
directive|include
file|"tree-flow.h"
end_include

begin_include
include|#
directive|include
file|"tree-gimple.h"
end_include

begin_include
include|#
directive|include
file|"tree-dump.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"tree-iterator.h"
end_include

begin_include
include|#
directive|include
file|"tree-pass.h"
end_include

begin_include
include|#
directive|include
file|"alloc-pool.h"
end_include

begin_include
include|#
directive|include
file|"vec.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_comment
comment|/*  This is a simple global reassociation pass.  It is, in part, based     on the LLVM pass of the same name (They do some things more/less     than we do, in different orders, etc).      It consists of five steps:      1. Breaking up subtract operations into addition + negate, where     it would promote the reassociation of adds.      2. Left linearization of the expression trees, so that (A+B)+(C+D)     becomes (((A+B)+C)+D), which is easier for us to rewrite later.     During linearization, we place the operands of the binary     expressions into a vector of operand_entry_t      3. Optimization of the operand lists, eliminating things like a +     -a, a& a, etc.      4. Rewrite the expression trees we linearized and optimized so     they are in proper rank order.      5. Repropagate negates, as nothing else will clean it up ATM.      A bit of theory on #4, since nobody seems to write anything down     about why it makes sense to do it the way they do it:      We could do this much nicer theoretically, but don't (for reasons     explained after how to do it theoretically nice :P).      In order to promote the most redundancy elimination, you want     binary expressions whose operands are the same rank (or     preferably, the same value) exposed to the redundancy eliminator,     for possible elimination.      So the way to do this if we really cared, is to build the new op     tree from the leaves to the roots, merging as you go, and putting the     new op on the end of the worklist, until you are left with one     thing on the worklist.      IE if you have to rewrite the following set of operands (listed with     rank in parentheses), with opcode PLUS_EXPR:      a (1),  b (1),  c (1),  d (2), e (2)       We start with our merge worklist empty, and the ops list with all of     those on it.      You want to first merge all leaves of the same rank, as much as     possible.      So first build a binary op of      mergetmp = a + b, and put "mergetmp" on the merge worklist.      Because there is no three operand form of PLUS_EXPR, c is not going to     be exposed to redundancy elimination as a rank 1 operand.      So you might as well throw it on the merge worklist (you could also     consider it to now be a rank two operand, and merge it with d and e,     but in this case, you then have evicted e from a binary op. So at     least in this situation, you can't win.)      Then build a binary op of d + e     mergetmp2 = d + e      and put mergetmp2 on the merge worklist.          so merge worklist = {mergetmp, c, mergetmp2}          Continue building binary ops of these operations until you have only     one operation left on the worklist.          So we have          build binary op     mergetmp3 = mergetmp + c          worklist = {mergetmp2, mergetmp3}          mergetmp4 = mergetmp2 + mergetmp3          worklist = {mergetmp4}          because we have one operation left, we can now just set the original     statement equal to the result of that operation.          This will at least expose a + b  and d + e to redundancy elimination     as binary operations.          For extra points, you can reuse the old statements to build the     mergetmps, since you shouldn't run out.      So why don't we do this?          Because it's expensive, and rarely will help.  Most trees we are     reassociating have 3 or less ops.  If they have 2 ops, they already     will be written into a nice single binary op.  If you have 3 ops, a     single simple check suffices to tell you whether the first two are of the     same rank.  If so, you know to order it      mergetmp = op1 + op2     newstmt = mergetmp + op3          instead of     mergetmp = op2 + op3     newstmt = mergetmp + op1          If all three are of the same rank, you can't expose them all in a     single binary operator anyway, so the above is *still* the best you     can do.          Thus, this is what we do.  When we have three ops left, we check to see     what order to put them in, and call it a day.  As a nod to vector sum     reduction, we check if any of ops are a really a phi node that is a     destructive update for the associating op, and keep the destructive     update together for vector sum reduction recognition.  */
end_comment

begin_comment
comment|/* Statistics */
end_comment

begin_struct
specifier|static
struct|struct
block|{
name|int
name|linearized
decl_stmt|;
name|int
name|constants_eliminated
decl_stmt|;
name|int
name|ops_eliminated
decl_stmt|;
name|int
name|rewritten
decl_stmt|;
block|}
name|reassociate_stats
struct|;
end_struct

begin_comment
comment|/* Operator, rank pair.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|operand_entry
block|{
name|unsigned
name|int
name|rank
decl_stmt|;
name|tree
name|op
decl_stmt|;
block|}
typedef|*
name|operand_entry_t
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|alloc_pool
name|operand_entry_pool
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Starting rank number for a given basic block, so that we can rank    operations using unmovable instructions in that BB based on the bb    depth.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
modifier|*
name|bb_rank
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Operand->rank hashtable.  */
end_comment

begin_decl_stmt
specifier|static
name|htab_t
name|operand_rank
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Look up the operand rank structure for expression E.  */
end_comment

begin_function
specifier|static
name|operand_entry_t
name|find_operand_rank
parameter_list|(
name|tree
name|e
parameter_list|)
block|{
name|void
modifier|*
modifier|*
name|slot
decl_stmt|;
name|struct
name|operand_entry
name|vrd
decl_stmt|;
name|vrd
operator|.
name|op
operator|=
name|e
expr_stmt|;
name|slot
operator|=
name|htab_find_slot
argument_list|(
name|operand_rank
argument_list|,
operator|&
name|vrd
argument_list|,
name|NO_INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|slot
condition|)
return|return
name|NULL
return|;
return|return
operator|(
operator|(
name|operand_entry_t
operator|)
operator|*
name|slot
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Insert {E,RANK} into the operand rank hashtable.  */
end_comment

begin_function
specifier|static
name|void
name|insert_operand_rank
parameter_list|(
name|tree
name|e
parameter_list|,
name|unsigned
name|int
name|rank
parameter_list|)
block|{
name|void
modifier|*
modifier|*
name|slot
decl_stmt|;
name|operand_entry_t
name|new_pair
init|=
name|pool_alloc
argument_list|(
name|operand_entry_pool
argument_list|)
decl_stmt|;
name|new_pair
operator|->
name|op
operator|=
name|e
expr_stmt|;
name|new_pair
operator|->
name|rank
operator|=
name|rank
expr_stmt|;
name|slot
operator|=
name|htab_find_slot
argument_list|(
name|operand_rank
argument_list|,
name|new_pair
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|*
name|slot
operator|==
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|slot
operator|=
name|new_pair
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the hash value for a operand rank structure  */
end_comment

begin_function
specifier|static
name|hashval_t
name|operand_entry_hash
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|)
block|{
specifier|const
name|operand_entry_t
name|vr
init|=
operator|(
name|operand_entry_t
operator|)
name|p
decl_stmt|;
return|return
name|iterative_hash_expr
argument_list|(
name|vr
operator|->
name|op
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if two operand rank structures are equal.  */
end_comment

begin_function
specifier|static
name|int
name|operand_entry_eq
parameter_list|(
specifier|const
name|void
modifier|*
name|p1
parameter_list|,
specifier|const
name|void
modifier|*
name|p2
parameter_list|)
block|{
specifier|const
name|operand_entry_t
name|vr1
init|=
operator|(
name|operand_entry_t
operator|)
name|p1
decl_stmt|;
specifier|const
name|operand_entry_t
name|vr2
init|=
operator|(
name|operand_entry_t
operator|)
name|p2
decl_stmt|;
return|return
name|vr1
operator|->
name|op
operator|==
name|vr2
operator|->
name|op
return|;
block|}
end_function

begin_comment
comment|/* Given an expression E, return the rank of the expression.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|get_rank
parameter_list|(
name|tree
name|e
parameter_list|)
block|{
name|operand_entry_t
name|vr
decl_stmt|;
comment|/* Constants have rank 0.  */
if|if
condition|(
name|is_gimple_min_invariant
argument_list|(
name|e
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* SSA_NAME's have the rank of the expression they are the result      of.      For globals and uninitialized values, the rank is 0.      For function arguments, use the pre-setup rank.      For PHI nodes, stores, asm statements, etc, we use the rank of      the BB.      For simple operations, the rank is the maximum rank of any of      its operands, or the bb_rank, whichever is less.      I make no claims that this is optimal, however, it gives good      results.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|e
argument_list|)
operator|==
name|SSA_NAME
condition|)
block|{
name|tree
name|stmt
decl_stmt|;
name|tree
name|rhs
decl_stmt|;
name|unsigned
name|int
name|rank
decl_stmt|,
name|maxrank
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|SSA_NAME_VAR
argument_list|(
name|e
argument_list|)
argument_list|)
operator|==
name|PARM_DECL
operator|&&
name|e
operator|==
name|default_def
argument_list|(
name|SSA_NAME_VAR
argument_list|(
name|e
argument_list|)
argument_list|)
condition|)
return|return
name|find_operand_rank
argument_list|(
name|e
argument_list|)
operator|->
name|rank
return|;
name|stmt
operator|=
name|SSA_NAME_DEF_STMT
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|bb_for_stmt
argument_list|(
name|stmt
argument_list|)
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|!=
name|MODIFY_EXPR
operator|||
operator|!
name|ZERO_SSA_OPERANDS
argument_list|(
name|stmt
argument_list|,
name|SSA_OP_VIRTUAL_DEFS
argument_list|)
condition|)
return|return
name|bb_rank
index|[
name|bb_for_stmt
argument_list|(
name|stmt
argument_list|)
operator|->
name|index
index|]
return|;
comment|/* If we already have a rank for this expression, use that.  */
name|vr
operator|=
name|find_operand_rank
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|vr
condition|)
return|return
name|vr
operator|->
name|rank
return|;
comment|/* Otherwise, find the maximum rank for the operands, or the bb 	 rank, whichever is less.   */
name|rank
operator|=
literal|0
expr_stmt|;
name|maxrank
operator|=
name|bb_rank
index|[
name|bb_for_stmt
argument_list|(
name|stmt
argument_list|)
operator|->
name|index
index|]
expr_stmt|;
name|rhs
operator|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE_LENGTH
argument_list|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|rank
operator|=
name|MAX
argument_list|(
name|rank
argument_list|,
name|get_rank
argument_list|(
name|rhs
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TREE_CODE_LENGTH
argument_list|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
argument_list|)
operator|&&
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
name|i
argument_list|)
operator|&&
name|rank
operator|!=
name|maxrank
condition|;
name|i
operator|++
control|)
name|rank
operator|=
name|MAX
argument_list|(
name|rank
argument_list|,
name|get_rank
argument_list|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Rank for "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|e
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|" is %d\n"
argument_list|,
operator|(
name|rank
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* Note the rank in the hashtable so we don't recompute it.  */
name|insert_operand_rank
argument_list|(
name|e
argument_list|,
operator|(
name|rank
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|rank
operator|+
literal|1
operator|)
return|;
block|}
comment|/* Globals, etc,  are rank 0 */
return|return
literal|0
return|;
block|}
end_function

begin_expr_stmt
name|DEF_VEC_P
argument_list|(
name|operand_entry_t
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DEF_VEC_ALLOC_P
argument_list|(
name|operand_entry_t
argument_list|,
name|heap
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* We want integer ones to end up last no matter what, since they are    the ones we can do the most with.  */
end_comment

begin_define
define|#
directive|define
name|INTEGER_CONST_TYPE
value|1<< 3
end_define

begin_define
define|#
directive|define
name|FLOAT_CONST_TYPE
value|1<< 2
end_define

begin_define
define|#
directive|define
name|OTHER_CONST_TYPE
value|1<< 1
end_define

begin_comment
comment|/* Classify an invariant tree into integer, float, or other, so that    we can sort them to be near other constants of the same type.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|constant_type
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
return|return
name|INTEGER_CONST_TYPE
return|;
elseif|else
if|if
condition|(
name|SCALAR_FLOAT_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
return|return
name|FLOAT_CONST_TYPE
return|;
else|else
return|return
name|OTHER_CONST_TYPE
return|;
block|}
end_function

begin_comment
comment|/* qsort comparison function to sort operand entries PA and PB by rank    so that the sorted array is ordered by rank in decreasing order.  */
end_comment

begin_function
specifier|static
name|int
name|sort_by_operand_rank
parameter_list|(
specifier|const
name|void
modifier|*
name|pa
parameter_list|,
specifier|const
name|void
modifier|*
name|pb
parameter_list|)
block|{
specifier|const
name|operand_entry_t
name|oea
init|=
operator|*
operator|(
specifier|const
name|operand_entry_t
operator|*
operator|)
name|pa
decl_stmt|;
specifier|const
name|operand_entry_t
name|oeb
init|=
operator|*
operator|(
specifier|const
name|operand_entry_t
operator|*
operator|)
name|pb
decl_stmt|;
comment|/* It's nicer for optimize_expression if constants that are likely      to fold when added/multiplied//whatever are put next to each      other.  Since all constants have rank 0, order them by type.  */
if|if
condition|(
name|oeb
operator|->
name|rank
operator|==
literal|0
operator|&&
name|oea
operator|->
name|rank
operator|==
literal|0
condition|)
return|return
name|constant_type
argument_list|(
name|oeb
operator|->
name|op
argument_list|)
operator|-
name|constant_type
argument_list|(
name|oea
operator|->
name|op
argument_list|)
return|;
comment|/* Lastly, make sure the versions that are the same go next to each      other.  We use SSA_NAME_VERSION because it's stable.  */
if|if
condition|(
operator|(
name|oeb
operator|->
name|rank
operator|-
name|oea
operator|->
name|rank
operator|==
literal|0
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|oea
operator|->
name|op
argument_list|)
operator|==
name|SSA_NAME
operator|&&
name|TREE_CODE
argument_list|(
name|oeb
operator|->
name|op
argument_list|)
operator|==
name|SSA_NAME
condition|)
return|return
name|SSA_NAME_VERSION
argument_list|(
name|oeb
operator|->
name|op
argument_list|)
operator|-
name|SSA_NAME_VERSION
argument_list|(
name|oea
operator|->
name|op
argument_list|)
return|;
return|return
name|oeb
operator|->
name|rank
operator|-
name|oea
operator|->
name|rank
return|;
block|}
end_function

begin_comment
comment|/* Add an operand entry to *OPS for the tree operand OP.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|add_to_ops_vec
argument_list|(
name|VEC
argument_list|(
name|operand_entry_t
argument_list|,
name|heap
argument_list|)
operator|*
operator|*
name|ops
argument_list|,
name|tree
name|op
argument_list|)
block|{
name|operand_entry_t
name|oe
init|=
name|pool_alloc
argument_list|(
name|operand_entry_pool
argument_list|)
decl_stmt|;
name|oe
operator|->
name|op
operator|=
name|op
expr_stmt|;
name|oe
operator|->
name|rank
operator|=
name|get_rank
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|operand_entry_t
argument_list|,
name|heap
argument_list|,
operator|*
name|ops
argument_list|,
name|oe
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* Return true if STMT is reassociable operation containing a binary    operation with tree code CODE.  */
end_comment

begin_function
specifier|static
name|bool
name|is_reassociable_op
parameter_list|(
name|tree
name|stmt
parameter_list|,
name|enum
name|tree_code
name|code
parameter_list|)
block|{
if|if
condition|(
operator|!
name|IS_EMPTY_STMT
argument_list|(
name|stmt
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|MODIFY_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|code
operator|&&
name|has_single_use
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Given NAME, if NAME is defined by a unary operation OPCODE, return the    operand of the negate operation.  Otherwise, return NULL.  */
end_comment

begin_function
specifier|static
name|tree
name|get_unary_op
parameter_list|(
name|tree
name|name
parameter_list|,
name|enum
name|tree_code
name|opcode
parameter_list|)
block|{
name|tree
name|stmt
init|=
name|SSA_NAME_DEF_STMT
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|tree
name|rhs
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|!=
name|MODIFY_EXPR
condition|)
return|return
name|NULL_TREE
return|;
name|rhs
operator|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|opcode
condition|)
return|return
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
return|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* If CURR and LAST are a pair of ops that OPCODE allows us to    eliminate through equivalences, do so, remove them from OPS, and    return true.  Otherwise, return false.  */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|eliminate_duplicate_pair
argument_list|(
expr|enum
name|tree_code
name|opcode
argument_list|,
name|VEC
argument_list|(
name|operand_entry_t
argument_list|,
name|heap
argument_list|)
operator|*
operator|*
name|ops
argument_list|,
name|bool
operator|*
name|all_done
argument_list|,
name|unsigned
name|int
name|i
argument_list|,
name|operand_entry_t
name|curr
argument_list|,
name|operand_entry_t
name|last
argument_list|)
block|{
comment|/* If we have two of the same op, and the opcode is& |, min, or max,      we can eliminate one of them.      If we have two of the same op, and the opcode is ^, we can      eliminate both of them.  */
if|if
condition|(
name|last
operator|&&
name|last
operator|->
name|op
operator|==
name|curr
operator|->
name|op
condition|)
block|{
switch|switch
condition|(
name|opcode
condition|)
block|{
case|case
name|MAX_EXPR
case|:
case|case
name|MIN_EXPR
case|:
case|case
name|BIT_IOR_EXPR
case|:
case|case
name|BIT_AND_EXPR
case|:
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Equivalence: "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|curr
operator|->
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|" [&|minmax] "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|last
operator|->
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|" -> "
argument_list|)
expr_stmt|;
name|print_generic_stmt
argument_list|(
name|dump_file
argument_list|,
name|last
operator|->
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|VEC_ordered_remove
argument_list|(
name|operand_entry_t
argument_list|,
operator|*
name|ops
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|reassociate_stats
operator|.
name|ops_eliminated
operator|++
expr_stmt|;
return|return
name|true
return|;
case|case
name|BIT_XOR_EXPR
case|:
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Equivalence: "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|curr
operator|->
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|" ^ "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|last
operator|->
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|" -> nothing\n"
argument_list|)
expr_stmt|;
block|}
name|reassociate_stats
operator|.
name|ops_eliminated
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|VEC_length
argument_list|(
name|operand_entry_t
argument_list|,
operator|*
name|ops
argument_list|)
operator|==
literal|2
condition|)
block|{
name|VEC_free
argument_list|(
name|operand_entry_t
argument_list|,
name|heap
argument_list|,
operator|*
name|ops
argument_list|)
expr_stmt|;
operator|*
name|ops
operator|=
name|NULL
expr_stmt|;
name|add_to_ops_vec
argument_list|(
name|ops
argument_list|,
name|fold_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|last
operator|->
name|op
argument_list|)
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|all_done
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
name|VEC_ordered_remove
argument_list|(
name|operand_entry_t
argument_list|,
operator|*
name|ops
argument_list|,
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
name|VEC_ordered_remove
argument_list|(
name|operand_entry_t
argument_list|,
operator|*
name|ops
argument_list|,
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|true
return|;
default|default:
break|break;
block|}
block|}
return|return
name|false
return|;
block|}
end_decl_stmt

begin_comment
comment|/* If OPCODE is PLUS_EXPR, CURR->OP is really a negate expression,    look in OPS for a corresponding positive operation to cancel it    out.  If we find one, remove the other from OPS, replace    OPS[CURRINDEX] with 0, and return true.  Otherwise, return    false. */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|eliminate_plus_minus_pair
argument_list|(
expr|enum
name|tree_code
name|opcode
argument_list|,
name|VEC
argument_list|(
name|operand_entry_t
argument_list|,
name|heap
argument_list|)
operator|*
operator|*
name|ops
argument_list|,
name|unsigned
name|int
name|currindex
argument_list|,
name|operand_entry_t
name|curr
argument_list|)
block|{
name|tree
name|negateop
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|operand_entry_t
name|oe
decl_stmt|;
if|if
condition|(
name|opcode
operator|!=
name|PLUS_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|curr
operator|->
name|op
argument_list|)
operator|!=
name|SSA_NAME
condition|)
return|return
name|false
return|;
name|negateop
operator|=
name|get_unary_op
argument_list|(
name|curr
operator|->
name|op
argument_list|,
name|NEGATE_EXPR
argument_list|)
expr_stmt|;
if|if
condition|(
name|negateop
operator|==
name|NULL_TREE
condition|)
return|return
name|false
return|;
comment|/* Any non-negated version will have a rank that is one less than      the current rank.  So once we hit those ranks, if we don't find      one, we can stop.  */
for|for
control|(
name|i
operator|=
name|currindex
operator|+
literal|1
init|;
name|VEC_iterate
argument_list|(
name|operand_entry_t
argument_list|,
operator|*
name|ops
argument_list|,
name|i
argument_list|,
name|oe
argument_list|)
operator|&&
name|oe
operator|->
name|rank
operator|>=
name|curr
operator|->
name|rank
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|oe
operator|->
name|op
operator|==
name|negateop
condition|)
block|{
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Equivalence: "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|negateop
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|" + -"
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|oe
operator|->
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|" -> 0\n"
argument_list|)
expr_stmt|;
block|}
name|VEC_ordered_remove
argument_list|(
name|operand_entry_t
argument_list|,
operator|*
name|ops
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|add_to_ops_vec
argument_list|(
name|ops
argument_list|,
name|fold_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|oe
operator|->
name|op
argument_list|)
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|)
expr_stmt|;
name|VEC_ordered_remove
argument_list|(
name|operand_entry_t
argument_list|,
operator|*
name|ops
argument_list|,
name|currindex
argument_list|)
expr_stmt|;
name|reassociate_stats
operator|.
name|ops_eliminated
operator|++
expr_stmt|;
return|return
name|true
return|;
block|}
block|}
return|return
name|false
return|;
block|}
end_decl_stmt

begin_comment
comment|/* If OPCODE is BIT_IOR_EXPR, BIT_AND_EXPR, and, CURR->OP is really a    bitwise not expression, look in OPS for a corresponding operand to    cancel it out.  If we find one, remove the other from OPS, replace    OPS[CURRINDEX] with 0, and return true.  Otherwise, return    false. */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|eliminate_not_pairs
argument_list|(
expr|enum
name|tree_code
name|opcode
argument_list|,
name|VEC
argument_list|(
name|operand_entry_t
argument_list|,
name|heap
argument_list|)
operator|*
operator|*
name|ops
argument_list|,
name|unsigned
name|int
name|currindex
argument_list|,
name|operand_entry_t
name|curr
argument_list|)
block|{
name|tree
name|notop
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|operand_entry_t
name|oe
decl_stmt|;
if|if
condition|(
operator|(
name|opcode
operator|!=
name|BIT_IOR_EXPR
operator|&&
name|opcode
operator|!=
name|BIT_AND_EXPR
operator|)
operator|||
name|TREE_CODE
argument_list|(
name|curr
operator|->
name|op
argument_list|)
operator|!=
name|SSA_NAME
condition|)
return|return
name|false
return|;
name|notop
operator|=
name|get_unary_op
argument_list|(
name|curr
operator|->
name|op
argument_list|,
name|BIT_NOT_EXPR
argument_list|)
expr_stmt|;
if|if
condition|(
name|notop
operator|==
name|NULL_TREE
condition|)
return|return
name|false
return|;
comment|/* Any non-not version will have a rank that is one less than      the current rank.  So once we hit those ranks, if we don't find      one, we can stop.  */
for|for
control|(
name|i
operator|=
name|currindex
operator|+
literal|1
init|;
name|VEC_iterate
argument_list|(
name|operand_entry_t
argument_list|,
operator|*
name|ops
argument_list|,
name|i
argument_list|,
name|oe
argument_list|)
operator|&&
name|oe
operator|->
name|rank
operator|>=
name|curr
operator|->
name|rank
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|oe
operator|->
name|op
operator|==
name|notop
condition|)
block|{
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Equivalence: "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|notop
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode
operator|==
name|BIT_AND_EXPR
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"& ~"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|opcode
operator|==
name|BIT_IOR_EXPR
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|" | ~"
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|oe
operator|->
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode
operator|==
name|BIT_AND_EXPR
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|" -> 0\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|opcode
operator|==
name|BIT_IOR_EXPR
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|" -> -1\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|opcode
operator|==
name|BIT_AND_EXPR
condition|)
name|oe
operator|->
name|op
operator|=
name|fold_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|oe
operator|->
name|op
argument_list|)
argument_list|,
name|integer_zero_node
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|opcode
operator|==
name|BIT_IOR_EXPR
condition|)
name|oe
operator|->
name|op
operator|=
name|build_low_bits_mask
argument_list|(
name|TREE_TYPE
argument_list|(
name|oe
operator|->
name|op
argument_list|)
argument_list|,
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|oe
operator|->
name|op
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|reassociate_stats
operator|.
name|ops_eliminated
operator|+=
name|VEC_length
argument_list|(
name|operand_entry_t
argument_list|,
operator|*
name|ops
argument_list|)
operator|-
literal|1
expr_stmt|;
name|VEC_free
argument_list|(
name|operand_entry_t
argument_list|,
name|heap
argument_list|,
operator|*
name|ops
argument_list|)
expr_stmt|;
operator|*
name|ops
operator|=
name|NULL
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|operand_entry_t
argument_list|,
name|heap
argument_list|,
operator|*
name|ops
argument_list|,
name|oe
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
block|}
return|return
name|false
return|;
block|}
end_decl_stmt

begin_comment
comment|/* Use constant value that may be present in OPS to try to eliminate    operands.  Note that this function is only really used when we've    eliminated ops for other reasons, or merged constants.  Across    single statements, fold already does all of this, plus more.  There    is little point in duplicating logic, so I've only included the    identities that I could ever construct testcases to trigger.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|eliminate_using_constants
argument_list|(
expr|enum
name|tree_code
name|opcode
argument_list|,
name|VEC
argument_list|(
name|operand_entry_t
argument_list|,
name|heap
argument_list|)
operator|*
operator|*
name|ops
argument_list|)
block|{
name|operand_entry_t
name|oelast
init|=
name|VEC_last
argument_list|(
name|operand_entry_t
argument_list|,
operator|*
name|ops
argument_list|)
decl_stmt|;
if|if
condition|(
name|oelast
operator|->
name|rank
operator|==
literal|0
operator|&&
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|oelast
operator|->
name|op
argument_list|)
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|opcode
condition|)
block|{
case|case
name|BIT_AND_EXPR
case|:
if|if
condition|(
name|integer_zerop
argument_list|(
name|oelast
operator|->
name|op
argument_list|)
condition|)
block|{
if|if
condition|(
name|VEC_length
argument_list|(
name|operand_entry_t
argument_list|,
operator|*
name|ops
argument_list|)
operator|!=
literal|1
condition|)
block|{
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Found& 0, removing all other ops\n"
argument_list|)
expr_stmt|;
name|reassociate_stats
operator|.
name|ops_eliminated
operator|+=
name|VEC_length
argument_list|(
name|operand_entry_t
argument_list|,
operator|*
name|ops
argument_list|)
operator|-
literal|1
expr_stmt|;
name|VEC_free
argument_list|(
name|operand_entry_t
argument_list|,
name|heap
argument_list|,
operator|*
name|ops
argument_list|)
expr_stmt|;
operator|*
name|ops
operator|=
name|NULL
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|operand_entry_t
argument_list|,
name|heap
argument_list|,
operator|*
name|ops
argument_list|,
name|oelast
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|integer_all_onesp
argument_list|(
name|oelast
operator|->
name|op
argument_list|)
condition|)
block|{
if|if
condition|(
name|VEC_length
argument_list|(
name|operand_entry_t
argument_list|,
operator|*
name|ops
argument_list|)
operator|!=
literal|1
condition|)
block|{
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Found& -1, removing\n"
argument_list|)
expr_stmt|;
name|VEC_pop
argument_list|(
name|operand_entry_t
argument_list|,
operator|*
name|ops
argument_list|)
expr_stmt|;
name|reassociate_stats
operator|.
name|ops_eliminated
operator|++
expr_stmt|;
block|}
block|}
break|break;
case|case
name|BIT_IOR_EXPR
case|:
if|if
condition|(
name|integer_all_onesp
argument_list|(
name|oelast
operator|->
name|op
argument_list|)
condition|)
block|{
if|if
condition|(
name|VEC_length
argument_list|(
name|operand_entry_t
argument_list|,
operator|*
name|ops
argument_list|)
operator|!=
literal|1
condition|)
block|{
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Found | -1, removing all other ops\n"
argument_list|)
expr_stmt|;
name|reassociate_stats
operator|.
name|ops_eliminated
operator|+=
name|VEC_length
argument_list|(
name|operand_entry_t
argument_list|,
operator|*
name|ops
argument_list|)
operator|-
literal|1
expr_stmt|;
name|VEC_free
argument_list|(
name|operand_entry_t
argument_list|,
name|heap
argument_list|,
operator|*
name|ops
argument_list|)
expr_stmt|;
operator|*
name|ops
operator|=
name|NULL
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|operand_entry_t
argument_list|,
name|heap
argument_list|,
operator|*
name|ops
argument_list|,
name|oelast
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|integer_zerop
argument_list|(
name|oelast
operator|->
name|op
argument_list|)
condition|)
block|{
if|if
condition|(
name|VEC_length
argument_list|(
name|operand_entry_t
argument_list|,
operator|*
name|ops
argument_list|)
operator|!=
literal|1
condition|)
block|{
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Found | 0, removing\n"
argument_list|)
expr_stmt|;
name|VEC_pop
argument_list|(
name|operand_entry_t
argument_list|,
operator|*
name|ops
argument_list|)
expr_stmt|;
name|reassociate_stats
operator|.
name|ops_eliminated
operator|++
expr_stmt|;
block|}
block|}
break|break;
case|case
name|MULT_EXPR
case|:
if|if
condition|(
name|integer_zerop
argument_list|(
name|oelast
operator|->
name|op
argument_list|)
condition|)
block|{
if|if
condition|(
name|VEC_length
argument_list|(
name|operand_entry_t
argument_list|,
operator|*
name|ops
argument_list|)
operator|!=
literal|1
condition|)
block|{
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Found * 0, removing all other ops\n"
argument_list|)
expr_stmt|;
name|reassociate_stats
operator|.
name|ops_eliminated
operator|+=
name|VEC_length
argument_list|(
name|operand_entry_t
argument_list|,
operator|*
name|ops
argument_list|)
operator|-
literal|1
expr_stmt|;
name|VEC_free
argument_list|(
name|operand_entry_t
argument_list|,
name|heap
argument_list|,
operator|*
name|ops
argument_list|)
expr_stmt|;
operator|*
name|ops
operator|=
name|NULL
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|operand_entry_t
argument_list|,
name|heap
argument_list|,
operator|*
name|ops
argument_list|,
name|oelast
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|integer_onep
argument_list|(
name|oelast
operator|->
name|op
argument_list|)
condition|)
block|{
if|if
condition|(
name|VEC_length
argument_list|(
name|operand_entry_t
argument_list|,
operator|*
name|ops
argument_list|)
operator|!=
literal|1
condition|)
block|{
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Found * 1, removing\n"
argument_list|)
expr_stmt|;
name|VEC_pop
argument_list|(
name|operand_entry_t
argument_list|,
operator|*
name|ops
argument_list|)
expr_stmt|;
name|reassociate_stats
operator|.
name|ops_eliminated
operator|++
expr_stmt|;
return|return;
block|}
block|}
break|break;
case|case
name|BIT_XOR_EXPR
case|:
case|case
name|PLUS_EXPR
case|:
case|case
name|MINUS_EXPR
case|:
if|if
condition|(
name|integer_zerop
argument_list|(
name|oelast
operator|->
name|op
argument_list|)
condition|)
block|{
if|if
condition|(
name|VEC_length
argument_list|(
name|operand_entry_t
argument_list|,
operator|*
name|ops
argument_list|)
operator|!=
literal|1
condition|)
block|{
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Found [|^+] 0, removing\n"
argument_list|)
expr_stmt|;
name|VEC_pop
argument_list|(
name|operand_entry_t
argument_list|,
operator|*
name|ops
argument_list|)
expr_stmt|;
name|reassociate_stats
operator|.
name|ops_eliminated
operator|++
expr_stmt|;
return|return;
block|}
block|}
break|break;
default|default:
break|break;
block|}
block|}
block|}
end_decl_stmt

begin_comment
comment|/* Perform various identities and other optimizations on the list of    operand entries, stored in OPS.  The tree code for the binary    operation between all the operands is OPCODE.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|optimize_ops_list
argument_list|(
expr|enum
name|tree_code
name|opcode
argument_list|,
name|VEC
argument_list|(
name|operand_entry_t
argument_list|,
name|heap
argument_list|)
operator|*
operator|*
name|ops
argument_list|)
block|{
name|unsigned
name|int
name|length
init|=
name|VEC_length
argument_list|(
name|operand_entry_t
argument_list|,
operator|*
name|ops
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|operand_entry_t
name|oe
decl_stmt|;
name|operand_entry_t
name|oelast
init|=
name|NULL
decl_stmt|;
name|bool
name|iterate
init|=
name|false
decl_stmt|;
if|if
condition|(
name|length
operator|==
literal|1
condition|)
return|return;
name|oelast
operator|=
name|VEC_last
argument_list|(
name|operand_entry_t
argument_list|,
operator|*
name|ops
argument_list|)
expr_stmt|;
comment|/* If the last two are constants, pop the constants off, merge them      and try the next two.  */
if|if
condition|(
name|oelast
operator|->
name|rank
operator|==
literal|0
operator|&&
name|is_gimple_min_invariant
argument_list|(
name|oelast
operator|->
name|op
argument_list|)
condition|)
block|{
name|operand_entry_t
name|oelm1
init|=
name|VEC_index
argument_list|(
name|operand_entry_t
argument_list|,
operator|*
name|ops
argument_list|,
name|length
operator|-
literal|2
argument_list|)
decl_stmt|;
if|if
condition|(
name|oelm1
operator|->
name|rank
operator|==
literal|0
operator|&&
name|is_gimple_min_invariant
argument_list|(
name|oelm1
operator|->
name|op
argument_list|)
operator|&&
name|lang_hooks
operator|.
name|types_compatible_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|oelm1
operator|->
name|op
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|oelast
operator|->
name|op
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|folded
init|=
name|fold_binary
argument_list|(
name|opcode
argument_list|,
name|TREE_TYPE
argument_list|(
name|oelm1
operator|->
name|op
argument_list|)
argument_list|,
name|oelm1
operator|->
name|op
argument_list|,
name|oelast
operator|->
name|op
argument_list|)
decl_stmt|;
if|if
condition|(
name|folded
operator|&&
name|is_gimple_min_invariant
argument_list|(
name|folded
argument_list|)
condition|)
block|{
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Merging constants\n"
argument_list|)
expr_stmt|;
name|VEC_pop
argument_list|(
name|operand_entry_t
argument_list|,
operator|*
name|ops
argument_list|)
expr_stmt|;
name|VEC_pop
argument_list|(
name|operand_entry_t
argument_list|,
operator|*
name|ops
argument_list|)
expr_stmt|;
name|add_to_ops_vec
argument_list|(
name|ops
argument_list|,
name|folded
argument_list|)
expr_stmt|;
name|reassociate_stats
operator|.
name|constants_eliminated
operator|++
expr_stmt|;
name|optimize_ops_list
argument_list|(
name|opcode
argument_list|,
name|ops
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
name|eliminate_using_constants
argument_list|(
name|opcode
argument_list|,
name|ops
argument_list|)
expr_stmt|;
name|oelast
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|operand_entry_t
argument_list|,
operator|*
name|ops
argument_list|,
name|i
argument_list|,
name|oe
argument_list|)
condition|;
control|)
block|{
name|bool
name|done
init|=
name|false
decl_stmt|;
if|if
condition|(
name|eliminate_not_pairs
argument_list|(
name|opcode
argument_list|,
name|ops
argument_list|,
name|i
argument_list|,
name|oe
argument_list|)
condition|)
return|return;
if|if
condition|(
name|eliminate_duplicate_pair
argument_list|(
name|opcode
argument_list|,
name|ops
argument_list|,
operator|&
name|done
argument_list|,
name|i
argument_list|,
name|oe
argument_list|,
name|oelast
argument_list|)
operator|||
operator|(
operator|!
name|done
operator|&&
name|eliminate_plus_minus_pair
argument_list|(
name|opcode
argument_list|,
name|ops
argument_list|,
name|i
argument_list|,
name|oe
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|done
condition|)
return|return;
name|iterate
operator|=
name|true
expr_stmt|;
name|oelast
operator|=
name|NULL
expr_stmt|;
continue|continue;
block|}
name|oelast
operator|=
name|oe
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
name|length
operator|=
name|VEC_length
argument_list|(
name|operand_entry_t
argument_list|,
operator|*
name|ops
argument_list|)
expr_stmt|;
name|oelast
operator|=
name|VEC_last
argument_list|(
name|operand_entry_t
argument_list|,
operator|*
name|ops
argument_list|)
expr_stmt|;
if|if
condition|(
name|iterate
condition|)
name|optimize_ops_list
argument_list|(
name|opcode
argument_list|,
name|ops
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* Return true if OPERAND is defined by a PHI node which uses the LHS    of STMT in it's operands.  This is also known as a "destructive    update" operation.  */
end_comment

begin_function
specifier|static
name|bool
name|is_phi_for_stmt
parameter_list|(
name|tree
name|stmt
parameter_list|,
name|tree
name|operand
parameter_list|)
block|{
name|tree
name|def_stmt
decl_stmt|;
name|tree
name|lhs
init|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|use_operand_p
name|arg_p
decl_stmt|;
name|ssa_op_iter
name|i
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|operand
argument_list|)
operator|!=
name|SSA_NAME
condition|)
return|return
name|false
return|;
name|def_stmt
operator|=
name|SSA_NAME_DEF_STMT
argument_list|(
name|operand
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|def_stmt
argument_list|)
operator|!=
name|PHI_NODE
condition|)
return|return
name|false
return|;
name|FOR_EACH_PHI_ARG
argument_list|(
argument|arg_p
argument_list|,
argument|def_stmt
argument_list|,
argument|i
argument_list|,
argument|SSA_OP_USE
argument_list|)
if|if
condition|(
name|lhs
operator|==
name|USE_FROM_PTR
argument_list|(
name|arg_p
argument_list|)
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Recursively rewrite our linearized statements so that the operators    match those in OPS[OPINDEX], putting the computation in rank    order.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|rewrite_expr_tree
argument_list|(
name|tree
name|stmt
argument_list|,
name|unsigned
name|int
name|opindex
argument_list|,
name|VEC
argument_list|(
name|operand_entry_t
argument_list|,
name|heap
argument_list|)
operator|*
name|ops
argument_list|)
block|{
name|tree
name|rhs
init|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|operand_entry_t
name|oe
decl_stmt|;
comment|/* If we have three operands left, then we want to make sure the one      that gets the double binary op are the ones with the same rank.       The alternative we try is to see if this is a destructive      update style statement, which is like:      b = phi (a, ...)      a = c + b;      In that case, we want to use the destructive update form to      expose the possible vectorizer sum reduction opportunity.      In that case, the third operand will be the phi node.       We could, of course, try to be better as noted above, and do a      lot of work to try to find these opportunities in>3 operand      cases, but it is unlikely to be worth it.  */
if|if
condition|(
name|opindex
operator|+
literal|3
operator|==
name|VEC_length
argument_list|(
name|operand_entry_t
argument_list|,
name|ops
argument_list|)
condition|)
block|{
name|operand_entry_t
name|oe1
decl_stmt|,
name|oe2
decl_stmt|,
name|oe3
decl_stmt|;
name|oe1
operator|=
name|VEC_index
argument_list|(
name|operand_entry_t
argument_list|,
name|ops
argument_list|,
name|opindex
argument_list|)
expr_stmt|;
name|oe2
operator|=
name|VEC_index
argument_list|(
name|operand_entry_t
argument_list|,
name|ops
argument_list|,
name|opindex
operator|+
literal|1
argument_list|)
expr_stmt|;
name|oe3
operator|=
name|VEC_index
argument_list|(
name|operand_entry_t
argument_list|,
name|ops
argument_list|,
name|opindex
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|oe1
operator|->
name|rank
operator|==
name|oe2
operator|->
name|rank
operator|&&
name|oe2
operator|->
name|rank
operator|!=
name|oe3
operator|->
name|rank
operator|)
operator|||
operator|(
name|is_phi_for_stmt
argument_list|(
name|stmt
argument_list|,
name|oe3
operator|->
name|op
argument_list|)
operator|&&
operator|!
name|is_phi_for_stmt
argument_list|(
name|stmt
argument_list|,
name|oe1
operator|->
name|op
argument_list|)
operator|&&
operator|!
name|is_phi_for_stmt
argument_list|(
name|stmt
argument_list|,
name|oe2
operator|->
name|op
argument_list|)
operator|)
condition|)
block|{
name|struct
name|operand_entry
name|temp
init|=
operator|*
name|oe3
decl_stmt|;
name|oe3
operator|->
name|op
operator|=
name|oe1
operator|->
name|op
expr_stmt|;
name|oe3
operator|->
name|rank
operator|=
name|oe1
operator|->
name|rank
expr_stmt|;
name|oe1
operator|->
name|op
operator|=
name|temp
operator|.
name|op
expr_stmt|;
name|oe1
operator|->
name|rank
operator|=
name|temp
operator|.
name|rank
expr_stmt|;
block|}
block|}
comment|/* The final recursion case for this function is that you have      exactly two operations left.      If we had one exactly one op in the entire list to start with, we      would have never called this function, and the tail recursion      rewrites them one at a time.  */
if|if
condition|(
name|opindex
operator|+
literal|2
operator|==
name|VEC_length
argument_list|(
name|operand_entry_t
argument_list|,
name|ops
argument_list|)
condition|)
block|{
name|operand_entry_t
name|oe1
decl_stmt|,
name|oe2
decl_stmt|;
name|oe1
operator|=
name|VEC_index
argument_list|(
name|operand_entry_t
argument_list|,
name|ops
argument_list|,
name|opindex
argument_list|)
expr_stmt|;
name|oe2
operator|=
name|VEC_index
argument_list|(
name|operand_entry_t
argument_list|,
name|ops
argument_list|,
name|opindex
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
operator|!=
name|oe1
operator|->
name|op
operator|||
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
operator|!=
name|oe2
operator|->
name|op
condition|)
block|{
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Transforming "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|rhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
operator|=
name|oe1
operator|->
name|op
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
operator|=
name|oe2
operator|->
name|op
expr_stmt|;
name|update_stmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|" into "
argument_list|)
expr_stmt|;
name|print_generic_stmt
argument_list|(
name|dump_file
argument_list|,
name|rhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
comment|/* If we hit here, we should have 3 or more ops left.  */
name|gcc_assert
argument_list|(
name|opindex
operator|+
literal|2
operator|<
name|VEC_length
argument_list|(
name|operand_entry_t
argument_list|,
name|ops
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Rewrite the next operator.  */
name|oe
operator|=
name|VEC_index
argument_list|(
name|operand_entry_t
argument_list|,
name|ops
argument_list|,
name|opindex
argument_list|)
expr_stmt|;
if|if
condition|(
name|oe
operator|->
name|op
operator|!=
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Transforming "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|rhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
operator|=
name|oe
operator|->
name|op
expr_stmt|;
name|update_stmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|" into "
argument_list|)
expr_stmt|;
name|print_generic_stmt
argument_list|(
name|dump_file
argument_list|,
name|rhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Recurse on the LHS of the binary operator, which is guaranteed to      be the non-leaf side.  */
name|rewrite_expr_tree
argument_list|(
name|SSA_NAME_DEF_STMT
argument_list|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|opindex
operator|+
literal|1
argument_list|,
name|ops
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* Transform STMT, which is really (A +B) + (C + D) into the left    linear form, ((A+B)+C)+D.    Recurse on D if necessary.  */
end_comment

begin_function
specifier|static
name|void
name|linearize_expr
parameter_list|(
name|tree
name|stmt
parameter_list|)
block|{
name|block_stmt_iterator
name|bsinow
decl_stmt|,
name|bsirhs
decl_stmt|;
name|tree
name|rhs
init|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|enum
name|tree_code
name|rhscode
init|=
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
decl_stmt|;
name|tree
name|binrhs
init|=
name|SSA_NAME_DEF_STMT
argument_list|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|binlhs
init|=
name|SSA_NAME_DEF_STMT
argument_list|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|newbinrhs
init|=
name|NULL_TREE
decl_stmt|;
name|gcc_assert
argument_list|(
name|is_reassociable_op
argument_list|(
name|binlhs
argument_list|,
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
argument_list|)
operator|&&
name|is_reassociable_op
argument_list|(
name|binrhs
argument_list|,
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|bsinow
operator|=
name|bsi_for_stmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|bsirhs
operator|=
name|bsi_for_stmt
argument_list|(
name|binrhs
argument_list|)
expr_stmt|;
name|bsi_move_before
argument_list|(
operator|&
name|bsirhs
argument_list|,
operator|&
name|bsinow
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
operator|=
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|binrhs
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|SSA_NAME
condition|)
name|newbinrhs
operator|=
name|SSA_NAME_DEF_STMT
argument_list|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|binrhs
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|=
name|TREE_OPERAND
argument_list|(
name|binlhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
operator|=
name|TREE_OPERAND
argument_list|(
name|binrhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Linearized: "
argument_list|)
expr_stmt|;
name|print_generic_stmt
argument_list|(
name|dump_file
argument_list|,
name|rhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|reassociate_stats
operator|.
name|linearized
operator|++
expr_stmt|;
name|update_stmt
argument_list|(
name|binrhs
argument_list|)
expr_stmt|;
name|update_stmt
argument_list|(
name|binlhs
argument_list|)
expr_stmt|;
name|update_stmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|TREE_VISITED
argument_list|(
name|binrhs
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_VISITED
argument_list|(
name|binlhs
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_VISITED
argument_list|(
name|stmt
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Tail recurse on the new rhs if it still needs reassociation.  */
if|if
condition|(
name|newbinrhs
operator|&&
name|is_reassociable_op
argument_list|(
name|newbinrhs
argument_list|,
name|rhscode
argument_list|)
condition|)
name|linearize_expr
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If LHS has a single immediate use that is a MODIFY_EXPR, return    it.  Otherwise, return NULL.  */
end_comment

begin_function
specifier|static
name|tree
name|get_single_immediate_use
parameter_list|(
name|tree
name|lhs
parameter_list|)
block|{
name|use_operand_p
name|immuse
decl_stmt|;
name|tree
name|immusestmt
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|lhs
argument_list|)
operator|==
name|SSA_NAME
operator|&&
name|single_imm_use
argument_list|(
name|lhs
argument_list|,
operator|&
name|immuse
argument_list|,
operator|&
name|immusestmt
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|immusestmt
argument_list|)
operator|==
name|RETURN_EXPR
condition|)
name|immusestmt
operator|=
name|TREE_OPERAND
argument_list|(
name|immusestmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|immusestmt
argument_list|)
operator|==
name|MODIFY_EXPR
condition|)
return|return
name|immusestmt
return|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|VEC
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|)
operator|*
name|broken_up_subtracts
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Recursively negate the value of TONEGATE, and return the SSA_NAME    representing the negated value.  Insertions of any necessary    instructions go before BSI.    This function is recursive in that, if you hand it "a_5" as the    value to negate, and a_5 is defined by "a_5 = b_3 + b_4", it will    transform b_3 + b_4 into a_5 = -b_3 + -b_4.  */
end_comment

begin_function
specifier|static
name|tree
name|negate_value
parameter_list|(
name|tree
name|tonegate
parameter_list|,
name|block_stmt_iterator
modifier|*
name|bsi
parameter_list|)
block|{
name|tree
name|negatedef
init|=
name|tonegate
decl_stmt|;
name|tree
name|resultofnegate
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|tonegate
argument_list|)
operator|==
name|SSA_NAME
condition|)
name|negatedef
operator|=
name|SSA_NAME_DEF_STMT
argument_list|(
name|tonegate
argument_list|)
expr_stmt|;
comment|/* If we are trying to negate a name, defined by an add, negate the      add operands instead.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|tonegate
argument_list|)
operator|==
name|SSA_NAME
operator|&&
name|TREE_CODE
argument_list|(
name|negatedef
argument_list|)
operator|==
name|MODIFY_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|negatedef
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SSA_NAME
operator|&&
name|has_single_use
argument_list|(
name|TREE_OPERAND
argument_list|(
name|negatedef
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|negatedef
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|PLUS_EXPR
condition|)
block|{
name|block_stmt_iterator
name|bsi
decl_stmt|;
name|tree
name|binop
init|=
name|TREE_OPERAND
argument_list|(
name|negatedef
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|bsi
operator|=
name|bsi_for_stmt
argument_list|(
name|negatedef
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|binop
argument_list|,
literal|0
argument_list|)
operator|=
name|negate_value
argument_list|(
name|TREE_OPERAND
argument_list|(
name|binop
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|bsi
argument_list|)
expr_stmt|;
name|bsi
operator|=
name|bsi_for_stmt
argument_list|(
name|negatedef
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|binop
argument_list|,
literal|1
argument_list|)
operator|=
name|negate_value
argument_list|(
name|TREE_OPERAND
argument_list|(
name|binop
argument_list|,
literal|1
argument_list|)
argument_list|,
operator|&
name|bsi
argument_list|)
expr_stmt|;
name|update_stmt
argument_list|(
name|negatedef
argument_list|)
expr_stmt|;
return|return
name|TREE_OPERAND
argument_list|(
name|negatedef
argument_list|,
literal|0
argument_list|)
return|;
block|}
name|tonegate
operator|=
name|fold_build1
argument_list|(
name|NEGATE_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|tonegate
argument_list|)
argument_list|,
name|tonegate
argument_list|)
expr_stmt|;
name|resultofnegate
operator|=
name|force_gimple_operand_bsi
argument_list|(
name|bsi
argument_list|,
name|tonegate
argument_list|,
name|true
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
name|broken_up_subtracts
argument_list|,
name|resultofnegate
argument_list|)
expr_stmt|;
return|return
name|resultofnegate
return|;
block|}
end_function

begin_comment
comment|/* Return true if we should break up the subtract in STMT into an add    with negate.  This is true when we the subtract operands are really    adds, or the subtract itself is used in an add expression.  In    either case, breaking up the subtract into an add with negate    exposes the adds to reassociation.  */
end_comment

begin_function
specifier|static
name|bool
name|should_break_up_subtract
parameter_list|(
name|tree
name|stmt
parameter_list|)
block|{
name|tree
name|lhs
init|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|rhs
init|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|binlhs
init|=
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|binrhs
init|=
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|immusestmt
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|binlhs
argument_list|)
operator|==
name|SSA_NAME
operator|&&
name|is_reassociable_op
argument_list|(
name|SSA_NAME_DEF_STMT
argument_list|(
name|binlhs
argument_list|)
argument_list|,
name|PLUS_EXPR
argument_list|)
condition|)
return|return
name|true
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|binrhs
argument_list|)
operator|==
name|SSA_NAME
operator|&&
name|is_reassociable_op
argument_list|(
name|SSA_NAME_DEF_STMT
argument_list|(
name|binrhs
argument_list|)
argument_list|,
name|PLUS_EXPR
argument_list|)
condition|)
return|return
name|true
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|lhs
argument_list|)
operator|==
name|SSA_NAME
operator|&&
operator|(
name|immusestmt
operator|=
name|get_single_immediate_use
argument_list|(
name|lhs
argument_list|)
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|immusestmt
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|PLUS_EXPR
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Transform STMT from A - B into A + -B.  */
end_comment

begin_function
specifier|static
name|void
name|break_up_subtract
parameter_list|(
name|tree
name|stmt
parameter_list|,
name|block_stmt_iterator
modifier|*
name|bsi
parameter_list|)
block|{
name|tree
name|rhs
init|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Breaking up subtract "
argument_list|)
expr_stmt|;
name|print_generic_stmt
argument_list|(
name|dump_file
argument_list|,
name|stmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|TREE_SET_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
argument_list|,
name|PLUS_EXPR
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
operator|=
name|negate_value
argument_list|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
argument_list|,
name|bsi
argument_list|)
expr_stmt|;
name|update_stmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Recursively linearize a binary expression that is the RHS of STMT.    Place the operands of the expression tree in the vector named OPS.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|linearize_expr_tree
argument_list|(
name|VEC
argument_list|(
name|operand_entry_t
argument_list|,
name|heap
argument_list|)
operator|*
operator|*
name|ops
argument_list|,
name|tree
name|stmt
argument_list|)
block|{
name|block_stmt_iterator
name|bsinow
decl_stmt|,
name|bsilhs
decl_stmt|;
name|tree
name|rhs
init|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|binrhs
init|=
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|binlhs
init|=
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|binlhsdef
decl_stmt|,
name|binrhsdef
decl_stmt|;
name|bool
name|binlhsisreassoc
init|=
name|false
decl_stmt|;
name|bool
name|binrhsisreassoc
init|=
name|false
decl_stmt|;
name|enum
name|tree_code
name|rhscode
init|=
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
decl_stmt|;
name|TREE_VISITED
argument_list|(
name|stmt
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|binlhs
argument_list|)
operator|==
name|SSA_NAME
condition|)
block|{
name|binlhsdef
operator|=
name|SSA_NAME_DEF_STMT
argument_list|(
name|binlhs
argument_list|)
expr_stmt|;
name|binlhsisreassoc
operator|=
name|is_reassociable_op
argument_list|(
name|binlhsdef
argument_list|,
name|rhscode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|binrhs
argument_list|)
operator|==
name|SSA_NAME
condition|)
block|{
name|binrhsdef
operator|=
name|SSA_NAME_DEF_STMT
argument_list|(
name|binrhs
argument_list|)
expr_stmt|;
name|binrhsisreassoc
operator|=
name|is_reassociable_op
argument_list|(
name|binrhsdef
argument_list|,
name|rhscode
argument_list|)
expr_stmt|;
block|}
comment|/* If the LHS is not reassociable, but the RHS is, we need to swap      them.  If neither is reassociable, there is nothing we can do, so      just put them in the ops vector.  If the LHS is reassociable,      linearize it.  If both are reassociable, then linearize the RHS      and the LHS.  */
if|if
condition|(
operator|!
name|binlhsisreassoc
condition|)
block|{
name|tree
name|temp
decl_stmt|;
if|if
condition|(
operator|!
name|binrhsisreassoc
condition|)
block|{
name|add_to_ops_vec
argument_list|(
name|ops
argument_list|,
name|binrhs
argument_list|)
expr_stmt|;
name|add_to_ops_vec
argument_list|(
name|ops
argument_list|,
name|binlhs
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"swapping operands of "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|stmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|swap_tree_operands
argument_list|(
name|stmt
argument_list|,
operator|&
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|update_stmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|" is now "
argument_list|)
expr_stmt|;
name|print_generic_stmt
argument_list|(
name|dump_file
argument_list|,
name|stmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* We want to make it so the lhs is always the reassociative op, 	 so swap.  */
name|temp
operator|=
name|binlhs
expr_stmt|;
name|binlhs
operator|=
name|binrhs
expr_stmt|;
name|binrhs
operator|=
name|temp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|binrhsisreassoc
condition|)
block|{
name|linearize_expr
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|rhs
operator|==
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|binlhs
operator|=
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|binrhs
operator|=
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|binrhs
argument_list|)
operator|!=
name|SSA_NAME
operator|||
operator|!
name|is_reassociable_op
argument_list|(
name|SSA_NAME_DEF_STMT
argument_list|(
name|binrhs
argument_list|)
argument_list|,
name|rhscode
argument_list|)
argument_list|)
expr_stmt|;
name|bsinow
operator|=
name|bsi_for_stmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|bsilhs
operator|=
name|bsi_for_stmt
argument_list|(
name|SSA_NAME_DEF_STMT
argument_list|(
name|binlhs
argument_list|)
argument_list|)
expr_stmt|;
name|bsi_move_before
argument_list|(
operator|&
name|bsilhs
argument_list|,
operator|&
name|bsinow
argument_list|)
expr_stmt|;
name|linearize_expr_tree
argument_list|(
name|ops
argument_list|,
name|SSA_NAME_DEF_STMT
argument_list|(
name|binlhs
argument_list|)
argument_list|)
expr_stmt|;
name|add_to_ops_vec
argument_list|(
name|ops
argument_list|,
name|binrhs
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* Repropagate the negates back into subtracts, since no other pass    currently does it.  */
end_comment

begin_function
specifier|static
name|void
name|repropagate_negates
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|int
name|i
init|=
literal|0
decl_stmt|;
name|tree
name|negate
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|tree
argument_list|,
name|broken_up_subtracts
argument_list|,
name|i
argument_list|,
name|negate
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|user
init|=
name|get_single_immediate_use
argument_list|(
name|negate
argument_list|)
decl_stmt|;
comment|/* The negate operand can be either operand of a PLUS_EXPR 	 (it can be the LHS if the RHS is a constant for example).  	 Force the negate operand to the RHS of the PLUS_EXPR, then 	 transform the PLUS_EXPR into a MINUS_EXPR.  */
if|if
condition|(
name|user
operator|&&
name|TREE_CODE
argument_list|(
name|user
argument_list|)
operator|==
name|MODIFY_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|user
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|PLUS_EXPR
condition|)
block|{
name|tree
name|rhs
init|=
name|TREE_OPERAND
argument_list|(
name|user
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|/* If the negated operand appears on the LHS of the 	     PLUS_EXPR, exchange the operands of the PLUS_EXPR 	     to force the negated operand to the RHS of the PLUS_EXPR.  */
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|user
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|negate
condition|)
block|{
name|tree
name|temp
init|=
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
operator|=
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
operator|=
name|temp
expr_stmt|;
block|}
comment|/* Now transform the PLUS_EXPR into a MINUS_EXPR and replace 	     the RHS of the PLUS_EXPR with the operand of the NEGATE_EXPR.  */
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|user
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
name|negate
condition|)
block|{
name|TREE_SET_CODE
argument_list|(
name|rhs
argument_list|,
name|MINUS_EXPR
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
operator|=
name|get_unary_op
argument_list|(
name|negate
argument_list|,
name|NEGATE_EXPR
argument_list|)
expr_stmt|;
name|update_stmt
argument_list|(
name|user
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Break up subtract operations in block BB.     We do this top down because we don't know whether the subtract is    part of a possible chain of reassociation except at the top.      IE given    d = f + g    c = a + e    b = c - d    q = b - r    k = t - q        we want to break up k = t - q, but we won't until we've transformed q    = b - r, which won't be broken up until we transform b = c - d.  */
end_comment

begin_function
specifier|static
name|void
name|break_up_subtract_bb
parameter_list|(
name|basic_block
name|bb
parameter_list|)
block|{
name|block_stmt_iterator
name|bsi
decl_stmt|;
name|basic_block
name|son
decl_stmt|;
for|for
control|(
name|bsi
operator|=
name|bsi_start
argument_list|(
name|bb
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|;
name|bsi_next
argument_list|(
operator|&
name|bsi
argument_list|)
control|)
block|{
name|tree
name|stmt
init|=
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|MODIFY_EXPR
condition|)
block|{
name|tree
name|lhs
init|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|rhs
init|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|TREE_VISITED
argument_list|(
name|stmt
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* If unsafe math optimizations we can do reassociation for 	     non-integral types.  */
if|if
condition|(
operator|(
operator|!
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
argument_list|)
operator|||
operator|!
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
operator|!
name|SCALAR_FLOAT_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|)
operator|||
operator|!
name|SCALAR_FLOAT_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
argument_list|)
operator|||
operator|!
name|flag_unsafe_math_optimizations
operator|)
condition|)
continue|continue;
comment|/* Check for a subtract used only in an addition.  If this 	     is the case, transform it into add of a negate for better 	     reassociation.  IE transform C = A-B into C = A + -B if C 	     is only used in an addition.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|MINUS_EXPR
condition|)
if|if
condition|(
name|should_break_up_subtract
argument_list|(
name|stmt
argument_list|)
condition|)
name|break_up_subtract
argument_list|(
name|stmt
argument_list|,
operator|&
name|bsi
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|son
operator|=
name|first_dom_son
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|bb
argument_list|)
init|;
name|son
condition|;
name|son
operator|=
name|next_dom_son
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|son
argument_list|)
control|)
name|break_up_subtract_bb
argument_list|(
name|son
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Reassociate expressions in basic block BB and its post-dominator as    children.  */
end_comment

begin_function
specifier|static
name|void
name|reassociate_bb
parameter_list|(
name|basic_block
name|bb
parameter_list|)
block|{
name|block_stmt_iterator
name|bsi
decl_stmt|;
name|basic_block
name|son
decl_stmt|;
for|for
control|(
name|bsi
operator|=
name|bsi_last
argument_list|(
name|bb
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|;
name|bsi_prev
argument_list|(
operator|&
name|bsi
argument_list|)
control|)
block|{
name|tree
name|stmt
init|=
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|MODIFY_EXPR
condition|)
block|{
name|tree
name|lhs
init|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|rhs
init|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|/* If this was part of an already processed tree, we don't 	     need to touch it again. */
if|if
condition|(
name|TREE_VISITED
argument_list|(
name|stmt
argument_list|)
condition|)
continue|continue;
comment|/* If unsafe math optimizations we can do reassociation for 	     non-integral types.  */
if|if
condition|(
operator|(
operator|!
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
argument_list|)
operator|||
operator|!
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
operator|!
name|SCALAR_FLOAT_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|)
operator|||
operator|!
name|SCALAR_FLOAT_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
argument_list|)
operator|||
operator|!
name|flag_unsafe_math_optimizations
operator|)
condition|)
continue|continue;
if|if
condition|(
name|associative_tree_code
argument_list|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
argument_list|)
condition|)
block|{
name|VEC
argument_list|(
name|operand_entry_t
argument_list|,
name|heap
argument_list|)
operator|*
name|ops
operator|=
name|NULL
expr_stmt|;
comment|/* There may be no immediate uses left by the time we 		 get here because we may have eliminated them all.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|lhs
argument_list|)
operator|==
name|SSA_NAME
operator|&&
name|has_zero_uses
argument_list|(
name|lhs
argument_list|)
condition|)
continue|continue;
name|TREE_VISITED
argument_list|(
name|stmt
argument_list|)
operator|=
literal|1
expr_stmt|;
name|linearize_expr_tree
argument_list|(
operator|&
name|ops
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
name|qsort
argument_list|(
name|VEC_address
argument_list|(
name|operand_entry_t
argument_list|,
name|ops
argument_list|)
argument_list|,
name|VEC_length
argument_list|(
name|operand_entry_t
argument_list|,
name|ops
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|operand_entry_t
argument_list|)
argument_list|,
name|sort_by_operand_rank
argument_list|)
expr_stmt|;
name|optimize_ops_list
argument_list|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
argument_list|,
operator|&
name|ops
argument_list|)
expr_stmt|;
if|if
condition|(
name|VEC_length
argument_list|(
name|operand_entry_t
argument_list|,
name|ops
argument_list|)
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Transforming "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|rhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
operator|=
name|VEC_last
argument_list|(
name|operand_entry_t
argument_list|,
name|ops
argument_list|)
operator|->
name|op
expr_stmt|;
name|update_stmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|" into "
argument_list|)
expr_stmt|;
name|print_generic_stmt
argument_list|(
name|dump_file
argument_list|,
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|rewrite_expr_tree
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|,
name|ops
argument_list|)
expr_stmt|;
block|}
name|VEC_free
argument_list|(
name|operand_entry_t
argument_list|,
name|heap
argument_list|,
name|ops
argument_list|)
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|son
operator|=
name|first_dom_son
argument_list|(
name|CDI_POST_DOMINATORS
argument_list|,
name|bb
argument_list|)
init|;
name|son
condition|;
name|son
operator|=
name|next_dom_son
argument_list|(
name|CDI_POST_DOMINATORS
argument_list|,
name|son
argument_list|)
control|)
name|reassociate_bb
argument_list|(
name|son
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|void
name|dump_ops_vector
argument_list|(
name|FILE
operator|*
name|file
argument_list|,
name|VEC
argument_list|(
name|operand_entry_t
argument_list|,
name|heap
argument_list|)
operator|*
name|ops
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|debug_ops_vector
argument_list|(
name|VEC
argument_list|(
name|operand_entry_t
argument_list|,
name|heap
argument_list|)
operator|*
name|ops
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Dump the operand entry vector OPS to FILE.  */
end_comment

begin_decl_stmt
name|void
name|dump_ops_vector
argument_list|(
name|FILE
operator|*
name|file
argument_list|,
name|VEC
argument_list|(
name|operand_entry_t
argument_list|,
name|heap
argument_list|)
operator|*
name|ops
argument_list|)
block|{
name|operand_entry_t
name|oe
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|operand_entry_t
argument_list|,
name|ops
argument_list|,
name|i
argument_list|,
name|oe
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"Op %d -> rank: %d, tree: "
argument_list|,
name|i
argument_list|,
name|oe
operator|->
name|rank
argument_list|)
expr_stmt|;
name|print_generic_stmt
argument_list|(
name|file
argument_list|,
name|oe
operator|->
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_decl_stmt

begin_comment
comment|/* Dump the operand entry vector OPS to STDERR.  */
end_comment

begin_decl_stmt
name|void
name|debug_ops_vector
argument_list|(
name|VEC
argument_list|(
name|operand_entry_t
argument_list|,
name|heap
argument_list|)
operator|*
name|ops
argument_list|)
block|{
name|dump_ops_vector
argument_list|(
name|stderr
argument_list|,
name|ops
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_function
specifier|static
name|void
name|do_reassoc
parameter_list|(
name|void
parameter_list|)
block|{
name|break_up_subtract_bb
argument_list|(
name|ENTRY_BLOCK_PTR
argument_list|)
expr_stmt|;
name|reassociate_bb
argument_list|(
name|EXIT_BLOCK_PTR
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize the reassociation pass.  */
end_comment

begin_function
specifier|static
name|void
name|init_reassoc
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|rank
init|=
literal|2
decl_stmt|;
name|tree
name|param
decl_stmt|;
name|int
modifier|*
name|bbs
init|=
name|XNEWVEC
argument_list|(
name|int
argument_list|,
name|last_basic_block
operator|+
literal|1
argument_list|)
decl_stmt|;
name|memset
argument_list|(
operator|&
name|reassociate_stats
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|reassociate_stats
argument_list|)
argument_list|)
expr_stmt|;
name|operand_entry_pool
operator|=
name|create_alloc_pool
argument_list|(
literal|"operand entry pool"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|operand_entry
argument_list|)
argument_list|,
literal|30
argument_list|)
expr_stmt|;
comment|/* Reverse RPO (Reverse Post Order) will give us something where      deeper loops come later.  */
name|pre_and_rev_post_order_compute
argument_list|(
name|NULL
argument_list|,
name|bbs
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|bb_rank
operator|=
name|XCNEWVEC
argument_list|(
argument|unsigned int
argument_list|,
argument|last_basic_block +
literal|1
argument_list|)
expr_stmt|;
name|operand_rank
operator|=
name|htab_create
argument_list|(
literal|511
argument_list|,
name|operand_entry_hash
argument_list|,
name|operand_entry_eq
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Give each argument a distinct rank.   */
for|for
control|(
name|param
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|current_function_decl
argument_list|)
init|;
name|param
condition|;
name|param
operator|=
name|TREE_CHAIN
argument_list|(
name|param
argument_list|)
control|)
block|{
if|if
condition|(
name|default_def
argument_list|(
name|param
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|tree
name|def
init|=
name|default_def
argument_list|(
name|param
argument_list|)
decl_stmt|;
name|insert_operand_rank
argument_list|(
name|def
argument_list|,
operator|++
name|rank
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Give the chain decl a distinct rank. */
if|if
condition|(
name|cfun
operator|->
name|static_chain_decl
operator|!=
name|NULL
condition|)
block|{
name|tree
name|def
init|=
name|default_def
argument_list|(
name|cfun
operator|->
name|static_chain_decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|def
operator|!=
name|NULL
condition|)
name|insert_operand_rank
argument_list|(
name|def
argument_list|,
operator|++
name|rank
argument_list|)
expr_stmt|;
block|}
comment|/* Set up rank for each BB  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_basic_blocks
operator|-
name|NUM_FIXED_BLOCKS
condition|;
name|i
operator|++
control|)
name|bb_rank
index|[
name|bbs
index|[
name|i
index|]
index|]
operator|=
operator|++
name|rank
operator|<<
literal|16
expr_stmt|;
name|free
argument_list|(
name|bbs
argument_list|)
expr_stmt|;
name|calculate_dominance_info
argument_list|(
name|CDI_DOMINATORS
argument_list|)
expr_stmt|;
name|calculate_dominance_info
argument_list|(
name|CDI_POST_DOMINATORS
argument_list|)
expr_stmt|;
name|broken_up_subtracts
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Cleanup after the reassociation pass, and print stats if    requested.  */
end_comment

begin_function
specifier|static
name|void
name|fini_reassoc
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_STATS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Reassociation stats:\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Linearized: %d\n"
argument_list|,
name|reassociate_stats
operator|.
name|linearized
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Constants eliminated: %d\n"
argument_list|,
name|reassociate_stats
operator|.
name|constants_eliminated
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Ops eliminated: %d\n"
argument_list|,
name|reassociate_stats
operator|.
name|ops_eliminated
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Statements rewritten: %d\n"
argument_list|,
name|reassociate_stats
operator|.
name|rewritten
argument_list|)
expr_stmt|;
block|}
name|htab_delete
argument_list|(
name|operand_rank
argument_list|)
expr_stmt|;
name|free_alloc_pool
argument_list|(
name|operand_entry_pool
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|bb_rank
argument_list|)
expr_stmt|;
name|VEC_free
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
name|broken_up_subtracts
argument_list|)
expr_stmt|;
name|free_dominance_info
argument_list|(
name|CDI_POST_DOMINATORS
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Gate and execute functions for Reassociation.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|execute_reassoc
parameter_list|(
name|void
parameter_list|)
block|{
name|init_reassoc
argument_list|()
expr_stmt|;
name|do_reassoc
argument_list|()
expr_stmt|;
name|repropagate_negates
argument_list|()
expr_stmt|;
name|fini_reassoc
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|tree_opt_pass
name|pass_reassoc
init|=
block|{
literal|"reassoc"
block|,
comment|/* name */
name|NULL
block|,
comment|/* gate */
name|execute_reassoc
block|,
comment|/* execute */
name|NULL
block|,
comment|/* sub */
name|NULL
block|,
comment|/* next */
literal|0
block|,
comment|/* static_pass_number */
name|TV_TREE_REASSOC
block|,
comment|/* tv_id */
name|PROP_cfg
operator||
name|PROP_ssa
operator||
name|PROP_alias
block|,
comment|/* properties_required */
literal|0
block|,
comment|/* properties_provided */
literal|0
block|,
comment|/* properties_destroyed */
literal|0
block|,
comment|/* todo_flags_start */
name|TODO_dump_func
operator||
name|TODO_ggc_collect
operator||
name|TODO_verify_ssa
block|,
comment|/* todo_flags_finish */
literal|0
comment|/* letter */
block|}
decl_stmt|;
end_decl_stmt

end_unit

