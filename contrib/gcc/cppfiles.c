begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Part of CPP library.  (include file handling)    Copyright (C) 1986, 87, 89, 92 - 95, 98, 1999 Free Software Foundation, Inc.    Written by Per Bothner, 1994.    Based on CCCP program by Paul Rubin, June 1986    Adapted to ANSI C, Richard Stallman, Jan 1987    Split out of cpplib.c, Zack Weinberg, Oct 1998  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.   In other words, you are welcome to use, share and improve this program.  You are forbidden to forbid anyone else to use, share and improve  what you give them.   Help stamp out software-hoarding!  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"cpplib.h"
end_include

begin_comment
comment|/* The entry points to this file are: find_include_file, finclude,    include_hash, append_include_chain, deps_output, and file_cleanup.    file_cleanup is only called through CPP_BUFFER(pfile)->cleanup,    so it's static anyway. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|include_hash
modifier|*
name|redundant_include_p
name|PROTO
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
expr|struct
name|include_hash
operator|*
operator|,
expr|struct
name|file_name_list
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|file_name_map
modifier|*
name|read_name_map
name|PROTO
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|read_filename_string
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|remap_filename
name|PROTO
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
name|char
operator|*
operator|,
expr|struct
name|file_name_list
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|read_and_prescan
name|PROTO
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
name|cpp_buffer
operator|*
operator|,
name|int
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|file_name_list
modifier|*
name|actual_directory
name|PROTO
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|initialize_input_buffer
name|PROTO
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
name|int
operator|,
expr|struct
name|stat
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static void hack_vms_include_specification PROTO ((char *));
endif|#
directive|endif
end_endif

begin_comment
comment|/* Windows does not natively support inodes, and neither does MSDOS.    VMS has non-numeric inodes. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|VMS
end_ifdef

begin_define
define|#
directive|define
name|INO_T_EQ
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(!bcmp((char *)&(a), (char *)&(b), sizeof (a)))
end_define

begin_elif
elif|#
directive|elif
operator|(
name|defined
name|_WIN32
operator|&&
operator|!
name|defined
name|CYGWIN
operator|&&
operator|!
name|defined
argument_list|(
name|_UWIN
argument_list|)
operator|)
expr|\
operator|||
name|defined
name|__MSDOS__
end_elif

begin_define
define|#
directive|define
name|INO_T_EQ
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|0
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|INO_T_EQ
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a) == (b))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Merge the four include chains together in the order quote, bracket,    system, after.  Remove duplicate dirs (as determined by    INO_T_EQ()).  The system_include and after_include chains are never    referred to again after this function; all access is through the    bracket_include path.     For the future: Check if the directory is empty (but    how?) and possibly preload the include hash. */
end_comment

begin_function
name|void
name|merge_include_chains
parameter_list|(
name|opts
parameter_list|)
name|struct
name|cpp_options
modifier|*
name|opts
decl_stmt|;
block|{
name|struct
name|file_name_list
modifier|*
name|prev
decl_stmt|,
modifier|*
name|cur
decl_stmt|,
modifier|*
name|other
decl_stmt|;
name|struct
name|file_name_list
modifier|*
name|quote
decl_stmt|,
modifier|*
name|brack
decl_stmt|,
modifier|*
name|systm
decl_stmt|,
modifier|*
name|after
decl_stmt|;
name|struct
name|file_name_list
modifier|*
name|qtail
decl_stmt|,
modifier|*
name|btail
decl_stmt|,
modifier|*
name|stail
decl_stmt|,
modifier|*
name|atail
decl_stmt|;
name|qtail
operator|=
name|opts
operator|->
name|pending
operator|->
name|quote_tail
expr_stmt|;
name|btail
operator|=
name|opts
operator|->
name|pending
operator|->
name|brack_tail
expr_stmt|;
name|stail
operator|=
name|opts
operator|->
name|pending
operator|->
name|systm_tail
expr_stmt|;
name|atail
operator|=
name|opts
operator|->
name|pending
operator|->
name|after_tail
expr_stmt|;
name|quote
operator|=
name|opts
operator|->
name|pending
operator|->
name|quote_head
expr_stmt|;
name|brack
operator|=
name|opts
operator|->
name|pending
operator|->
name|brack_head
expr_stmt|;
name|systm
operator|=
name|opts
operator|->
name|pending
operator|->
name|systm_head
expr_stmt|;
name|after
operator|=
name|opts
operator|->
name|pending
operator|->
name|after_head
expr_stmt|;
comment|/* Paste together bracket, system, and after include chains. */
if|if
condition|(
name|stail
condition|)
name|stail
operator|->
name|next
operator|=
name|after
expr_stmt|;
else|else
name|systm
operator|=
name|after
expr_stmt|;
if|if
condition|(
name|btail
condition|)
name|btail
operator|->
name|next
operator|=
name|systm
expr_stmt|;
else|else
name|brack
operator|=
name|systm
expr_stmt|;
comment|/* This is a bit tricky.      First we drop dupes from the quote-include list.      Then we drop dupes from the bracket-include list.      Finally, if qtail and brack are the same directory,      we cut out qtail.       We can't just merge the lists and then uniquify them because      then we may lose directories from the<> search path that should      be there; consider -Ifoo -Ibar -I- -Ifoo -Iquux. It is however      safe to treat -Ibar -Ifoo -I- -Ifoo -Iquux as if written      -Ibar -I- -Ifoo -Iquux.       Note that this algorithm is quadratic in the number of -I switches,      which is acceptable since there aren't usually that many of them.  */
for|for
control|(
name|cur
operator|=
name|quote
operator|,
name|prev
operator|=
name|NULL
init|;
name|cur
condition|;
name|cur
operator|=
name|cur
operator|->
name|next
control|)
block|{
for|for
control|(
name|other
operator|=
name|quote
init|;
name|other
operator|!=
name|cur
condition|;
name|other
operator|=
name|other
operator|->
name|next
control|)
if|if
condition|(
name|INO_T_EQ
argument_list|(
name|cur
operator|->
name|ino
argument_list|,
name|other
operator|->
name|ino
argument_list|)
operator|&&
name|cur
operator|->
name|dev
operator|==
name|other
operator|->
name|dev
condition|)
block|{
if|if
condition|(
name|opts
operator|->
name|verbose
condition|)
name|cpp_notice
argument_list|(
literal|"ignoring duplicate directory `%s'\n"
argument_list|,
name|cur
operator|->
name|name
argument_list|)
expr_stmt|;
name|prev
operator|->
name|next
operator|=
name|cur
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|cur
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cur
argument_list|)
expr_stmt|;
name|cur
operator|=
name|prev
expr_stmt|;
break|break;
block|}
name|prev
operator|=
name|cur
expr_stmt|;
block|}
name|qtail
operator|=
name|prev
expr_stmt|;
for|for
control|(
name|cur
operator|=
name|brack
init|;
name|cur
condition|;
name|cur
operator|=
name|cur
operator|->
name|next
control|)
block|{
for|for
control|(
name|other
operator|=
name|brack
init|;
name|other
operator|!=
name|cur
condition|;
name|other
operator|=
name|other
operator|->
name|next
control|)
if|if
condition|(
name|INO_T_EQ
argument_list|(
name|cur
operator|->
name|ino
argument_list|,
name|other
operator|->
name|ino
argument_list|)
operator|&&
name|cur
operator|->
name|dev
operator|==
name|other
operator|->
name|dev
condition|)
block|{
if|if
condition|(
name|opts
operator|->
name|verbose
condition|)
name|cpp_notice
argument_list|(
literal|"ignoring duplicate directory `%s'\n"
argument_list|,
name|cur
operator|->
name|name
argument_list|)
expr_stmt|;
name|prev
operator|->
name|next
operator|=
name|cur
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|cur
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cur
argument_list|)
expr_stmt|;
name|cur
operator|=
name|prev
expr_stmt|;
break|break;
block|}
name|prev
operator|=
name|cur
expr_stmt|;
block|}
if|if
condition|(
name|quote
condition|)
block|{
if|if
condition|(
name|INO_T_EQ
argument_list|(
name|qtail
operator|->
name|ino
argument_list|,
name|brack
operator|->
name|ino
argument_list|)
operator|&&
name|qtail
operator|->
name|dev
operator|==
name|brack
operator|->
name|dev
condition|)
block|{
if|if
condition|(
name|quote
operator|==
name|qtail
condition|)
block|{
if|if
condition|(
name|opts
operator|->
name|verbose
condition|)
name|cpp_notice
argument_list|(
literal|"ignoring duplicate directory `%s'\n"
argument_list|,
name|quote
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|quote
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|quote
argument_list|)
expr_stmt|;
name|quote
operator|=
name|brack
expr_stmt|;
block|}
else|else
block|{
name|cur
operator|=
name|quote
expr_stmt|;
while|while
condition|(
name|cur
operator|->
name|next
operator|!=
name|qtail
condition|)
name|cur
operator|=
name|cur
operator|->
name|next
expr_stmt|;
name|cur
operator|->
name|next
operator|=
name|brack
expr_stmt|;
if|if
condition|(
name|opts
operator|->
name|verbose
condition|)
name|cpp_notice
argument_list|(
literal|"ignoring duplicate directory `%s'\n"
argument_list|,
name|qtail
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|qtail
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|qtail
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|qtail
operator|->
name|next
operator|=
name|brack
expr_stmt|;
block|}
else|else
name|quote
operator|=
name|brack
expr_stmt|;
name|opts
operator|->
name|quote_include
operator|=
name|quote
expr_stmt|;
name|opts
operator|->
name|bracket_include
operator|=
name|brack
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Look up or add an entry to the table of all includes.  This table  is indexed by the name as it appears in the #include line.  The  ->next_this_file chain stores all different files with the same  #include name (there are at least three ways this can happen).  The  hash function could probably be improved a bit. */
end_comment

begin_function
name|struct
name|include_hash
modifier|*
name|include_hash
parameter_list|(
name|pfile
parameter_list|,
name|fname
parameter_list|,
name|add
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|char
modifier|*
name|fname
decl_stmt|;
name|int
name|add
decl_stmt|;
block|{
name|unsigned
name|int
name|hash
init|=
literal|0
decl_stmt|;
name|struct
name|include_hash
modifier|*
name|l
decl_stmt|,
modifier|*
name|m
decl_stmt|;
name|char
modifier|*
name|f
init|=
name|fname
decl_stmt|;
while|while
condition|(
operator|*
name|f
condition|)
name|hash
operator|+=
operator|*
name|f
operator|++
expr_stmt|;
name|l
operator|=
name|pfile
operator|->
name|all_include_files
index|[
name|hash
operator|%
name|ALL_INCLUDE_HASHSIZE
index|]
expr_stmt|;
name|m
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|l
condition|;
name|m
operator|=
name|l
operator|,
name|l
operator|=
name|l
operator|->
name|next
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|l
operator|->
name|nshort
argument_list|,
name|fname
argument_list|)
condition|)
return|return
name|l
return|;
if|if
condition|(
operator|!
name|add
condition|)
return|return
literal|0
return|;
name|l
operator|=
operator|(
expr|struct
name|include_hash
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|include_hash
argument_list|)
argument_list|)
expr_stmt|;
name|l
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|l
operator|->
name|next_this_file
operator|=
name|NULL
expr_stmt|;
name|l
operator|->
name|foundhere
operator|=
name|NULL
expr_stmt|;
name|l
operator|->
name|buf
operator|=
name|NULL
expr_stmt|;
name|l
operator|->
name|limit
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|m
condition|)
name|m
operator|->
name|next
operator|=
name|l
expr_stmt|;
else|else
name|pfile
operator|->
name|all_include_files
index|[
name|hash
operator|%
name|ALL_INCLUDE_HASHSIZE
index|]
operator|=
name|l
expr_stmt|;
return|return
name|l
return|;
block|}
end_function

begin_comment
comment|/* Return 0 if the file pointed to by IHASH has never been included before,          -1 if it has been included before and need not be again, 	 or a pointer to an IHASH entry which is the file to be reread.    "Never before" is with respect to the position in ILIST.     This will not detect redundancies involving odd uses of the    `current directory' rule for "" includes.  They aren't quite    pathological, but I think they are rare enough not to worry about.    The simplest example is:     top.c:    #include "a/a.h"    #include "b/b.h"     a/a.h:    #include "../b/b.h"     and the problem is that for `current directory' includes,    ihash->foundhere is not on any of the global include chains,    so the test below (i->foundhere == l) may be false even when    the directories are in fact the same.  */
end_comment

begin_function
specifier|static
name|struct
name|include_hash
modifier|*
name|redundant_include_p
parameter_list|(
name|pfile
parameter_list|,
name|ihash
parameter_list|,
name|ilist
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|struct
name|include_hash
modifier|*
name|ihash
decl_stmt|;
name|struct
name|file_name_list
modifier|*
name|ilist
decl_stmt|;
block|{
name|struct
name|file_name_list
modifier|*
name|l
decl_stmt|;
name|struct
name|include_hash
modifier|*
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|ihash
operator|->
name|foundhere
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
name|ihash
init|;
name|i
condition|;
name|i
operator|=
name|i
operator|->
name|next_this_file
control|)
for|for
control|(
name|l
operator|=
name|ilist
init|;
name|l
condition|;
name|l
operator|=
name|l
operator|->
name|next
control|)
if|if
condition|(
name|i
operator|->
name|foundhere
operator|==
name|l
condition|)
comment|/* The control_macro works like this: If it's NULL, the file 	    is to be included again.  If it's "", the file is never to 	    be included again.  If it's a string, the file is not to be 	    included again if the string is the name of a defined macro. */
return|return
operator|(
name|i
operator|->
name|control_macro
operator|&&
operator|(
name|i
operator|->
name|control_macro
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|||
name|cpp_lookup
argument_list|(
name|pfile
argument_list|,
name|i
operator|->
name|control_macro
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
operator|)
operator|)
condition|?
operator|(
expr|struct
name|include_hash
operator|*
operator|)
operator|-
literal|1
else|:
name|i
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|file_cleanup
parameter_list|(
name|pbuf
parameter_list|,
name|pfile
parameter_list|)
name|cpp_buffer
modifier|*
name|pbuf
decl_stmt|;
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
if|if
condition|(
name|pbuf
operator|->
name|buf
condition|)
block|{
name|free
argument_list|(
name|pbuf
operator|->
name|buf
argument_list|)
expr_stmt|;
name|pbuf
operator|->
name|buf
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|pfile
operator|->
name|system_include_depth
condition|)
name|pfile
operator|->
name|system_include_depth
operator|--
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Search for include file FNAME in the include chain starting at    SEARCH_START.  Return -2 if this file doesn't need to be included    (because it was included already and it's marked idempotent),    -1 if an error occurred, or a file descriptor open on the file.    *IHASH is set to point to the include hash entry for this file, and    *BEFORE is 1 if the file was included before (but needs to be read    again). */
end_comment

begin_function
name|int
name|find_include_file
parameter_list|(
name|pfile
parameter_list|,
name|fname
parameter_list|,
name|search_start
parameter_list|,
name|ihash
parameter_list|,
name|before
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|char
modifier|*
name|fname
decl_stmt|;
name|struct
name|file_name_list
modifier|*
name|search_start
decl_stmt|;
name|struct
name|include_hash
modifier|*
modifier|*
name|ihash
decl_stmt|;
name|int
modifier|*
name|before
decl_stmt|;
block|{
name|struct
name|file_name_list
modifier|*
name|l
decl_stmt|;
name|struct
name|include_hash
modifier|*
name|ih
decl_stmt|,
modifier|*
name|jh
decl_stmt|;
name|int
name|f
decl_stmt|,
name|len
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|ih
operator|=
name|include_hash
argument_list|(
name|pfile
argument_list|,
name|fname
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|jh
operator|=
name|redundant_include_p
argument_list|(
name|pfile
argument_list|,
name|ih
argument_list|,
name|fname
index|[
literal|0
index|]
operator|==
literal|'/'
condition|?
name|ABSOLUTE_PATH
else|:
name|search_start
argument_list|)
expr_stmt|;
if|if
condition|(
name|jh
operator|!=
literal|0
condition|)
block|{
operator|*
name|before
operator|=
literal|1
expr_stmt|;
operator|*
name|ihash
operator|=
name|jh
expr_stmt|;
if|if
condition|(
name|jh
operator|==
operator|(
expr|struct
name|include_hash
operator|*
operator|)
operator|-
literal|1
condition|)
return|return
operator|-
literal|2
return|;
else|else
return|return
name|open
argument_list|(
name|jh
operator|->
name|name
argument_list|,
name|O_RDONLY
argument_list|,
literal|0666
argument_list|)
return|;
block|}
if|if
condition|(
name|ih
operator|->
name|foundhere
condition|)
comment|/* A file is already known by this name, but it's not the same file.        Allocate another include_hash block and add it to the next_this_file        chain. */
block|{
name|jh
operator|=
operator|(
expr|struct
name|include_hash
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|include_hash
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|ih
operator|->
name|next_this_file
condition|)
name|ih
operator|=
name|ih
operator|->
name|next_this_file
expr_stmt|;
name|ih
operator|->
name|next_this_file
operator|=
name|jh
expr_stmt|;
name|jh
operator|=
name|ih
expr_stmt|;
name|ih
operator|=
name|ih
operator|->
name|next_this_file
expr_stmt|;
name|ih
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|ih
operator|->
name|next_this_file
operator|=
name|NULL
expr_stmt|;
name|ih
operator|->
name|buf
operator|=
name|NULL
expr_stmt|;
name|ih
operator|->
name|limit
operator|=
name|NULL
expr_stmt|;
block|}
operator|*
name|before
operator|=
literal|0
expr_stmt|;
operator|*
name|ihash
operator|=
name|ih
expr_stmt|;
name|ih
operator|->
name|nshort
operator|=
name|xstrdup
argument_list|(
name|fname
argument_list|)
expr_stmt|;
name|ih
operator|->
name|control_macro
operator|=
name|NULL
expr_stmt|;
comment|/* If the pathname is absolute, just open it. */
if|if
condition|(
name|fname
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
block|{
name|ih
operator|->
name|foundhere
operator|=
name|ABSOLUTE_PATH
expr_stmt|;
name|ih
operator|->
name|name
operator|=
name|ih
operator|->
name|nshort
expr_stmt|;
return|return
name|open
argument_list|(
name|ih
operator|->
name|name
argument_list|,
name|O_RDONLY
argument_list|,
literal|0666
argument_list|)
return|;
block|}
comment|/* Search directory path, trying to open the file. */
name|len
operator|=
name|strlen
argument_list|(
name|fname
argument_list|)
expr_stmt|;
name|name
operator|=
name|xmalloc
argument_list|(
name|len
operator|+
name|pfile
operator|->
name|max_include_len
operator|+
literal|2
operator|+
name|INCLUDE_LEN_FUDGE
argument_list|)
expr_stmt|;
for|for
control|(
name|l
operator|=
name|search_start
init|;
name|l
condition|;
name|l
operator|=
name|l
operator|->
name|next
control|)
block|{
name|bcopy
argument_list|(
name|l
operator|->
name|name
argument_list|,
name|name
argument_list|,
name|l
operator|->
name|nlen
argument_list|)
expr_stmt|;
name|name
index|[
name|l
operator|->
name|nlen
index|]
operator|=
literal|'/'
expr_stmt|;
name|strcpy
argument_list|(
operator|&
name|name
index|[
name|l
operator|->
name|nlen
operator|+
literal|1
index|]
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|simplify_pathname
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|remap
condition|)
name|name
operator|=
name|remap_filename
argument_list|(
name|pfile
argument_list|,
name|name
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|f
operator|=
name|open
argument_list|(
name|name
argument_list|,
name|O_RDONLY
operator||
name|O_NONBLOCK
operator||
name|O_NOCTTY
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EACCES
if|if
condition|(
name|f
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|EACCES
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"included file `%s' exists but is not readable"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
endif|#
directive|endif
if|if
condition|(
name|f
operator|>=
literal|0
condition|)
block|{
name|ih
operator|->
name|foundhere
operator|=
name|l
expr_stmt|;
name|ih
operator|->
name|name
operator|=
name|xrealloc
argument_list|(
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|f
return|;
block|}
block|}
if|if
condition|(
name|jh
condition|)
block|{
name|jh
operator|->
name|next_this_file
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|ih
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
operator|*
name|ihash
operator|=
operator|(
expr|struct
name|include_hash
operator|*
operator|)
operator|-
literal|1
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* The file_name_map structure holds a mapping of file names for a    particular directory.  This mapping is read from the file named    FILE_NAME_MAP_FILE in that directory.  Such a file can be used to    map filenames on a file system with severe filename restrictions,    such as DOS.  The format of the file name map file is just a series    of lines with two tokens on each line.  The first token is the name    to map, and the second token is the actual name to use.  */
end_comment

begin_struct
struct|struct
name|file_name_map
block|{
name|struct
name|file_name_map
modifier|*
name|map_next
decl_stmt|;
name|char
modifier|*
name|map_from
decl_stmt|;
name|char
modifier|*
name|map_to
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|FILE_NAME_MAP_FILE
value|"header.gcc"
end_define

begin_comment
comment|/* Read a space delimited string of unlimited length from a stdio    file.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|read_filename_string
parameter_list|(
name|ch
parameter_list|,
name|f
parameter_list|)
name|int
name|ch
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
block|{
name|char
modifier|*
name|alloc
decl_stmt|,
modifier|*
name|set
decl_stmt|;
name|int
name|len
decl_stmt|;
name|len
operator|=
literal|20
expr_stmt|;
name|set
operator|=
name|alloc
operator|=
name|xmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_space
index|[
name|ch
index|]
condition|)
block|{
operator|*
name|set
operator|++
operator|=
name|ch
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|getc
argument_list|(
name|f
argument_list|)
operator|)
operator|!=
name|EOF
operator|&&
operator|!
name|is_space
index|[
name|ch
index|]
condition|)
block|{
if|if
condition|(
name|set
operator|-
name|alloc
operator|==
name|len
condition|)
block|{
name|len
operator|*=
literal|2
expr_stmt|;
name|alloc
operator|=
name|xrealloc
argument_list|(
name|alloc
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|set
operator|=
name|alloc
operator|+
name|len
operator|/
literal|2
expr_stmt|;
block|}
operator|*
name|set
operator|++
operator|=
name|ch
expr_stmt|;
block|}
block|}
operator|*
name|set
operator|=
literal|'\0'
expr_stmt|;
name|ungetc
argument_list|(
name|ch
argument_list|,
name|f
argument_list|)
expr_stmt|;
return|return
name|alloc
return|;
block|}
end_function

begin_comment
comment|/* This structure holds a linked list of file name maps, one per directory.  */
end_comment

begin_struct
struct|struct
name|file_name_map_list
block|{
name|struct
name|file_name_map_list
modifier|*
name|map_list_next
decl_stmt|;
name|char
modifier|*
name|map_list_name
decl_stmt|;
name|struct
name|file_name_map
modifier|*
name|map_list_map
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Read the file name map file for DIRNAME.  */
end_comment

begin_function
specifier|static
name|struct
name|file_name_map
modifier|*
name|read_name_map
parameter_list|(
name|pfile
parameter_list|,
name|dirname
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
specifier|const
name|char
modifier|*
name|dirname
decl_stmt|;
block|{
specifier|register
name|struct
name|file_name_map_list
modifier|*
name|map_list_ptr
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
for|for
control|(
name|map_list_ptr
operator|=
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|map_list
init|;
name|map_list_ptr
condition|;
name|map_list_ptr
operator|=
name|map_list_ptr
operator|->
name|map_list_next
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|map_list_ptr
operator|->
name|map_list_name
argument_list|,
name|dirname
argument_list|)
condition|)
return|return
name|map_list_ptr
operator|->
name|map_list_map
return|;
name|map_list_ptr
operator|=
operator|(
operator|(
expr|struct
name|file_name_map_list
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|file_name_map_list
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|map_list_ptr
operator|->
name|map_list_name
operator|=
name|xstrdup
argument_list|(
name|dirname
argument_list|)
expr_stmt|;
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|dirname
argument_list|)
operator|+
name|strlen
argument_list|(
name|FILE_NAME_MAP_FILE
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|name
argument_list|,
name|dirname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|dirname
condition|)
name|strcat
argument_list|(
name|name
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|name
argument_list|,
name|FILE_NAME_MAP_FILE
argument_list|)
expr_stmt|;
name|f
operator|=
name|fopen
argument_list|(
name|name
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|f
condition|)
name|map_list_ptr
operator|->
name|map_list_map
operator|=
operator|(
expr|struct
name|file_name_map
operator|*
operator|)
operator|-
literal|1
expr_stmt|;
else|else
block|{
name|int
name|ch
decl_stmt|;
name|int
name|dirlen
init|=
name|strlen
argument_list|(
name|dirname
argument_list|)
decl_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|getc
argument_list|(
name|f
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
name|char
modifier|*
name|from
decl_stmt|,
modifier|*
name|to
decl_stmt|;
name|struct
name|file_name_map
modifier|*
name|ptr
decl_stmt|;
if|if
condition|(
name|is_space
index|[
name|ch
index|]
condition|)
continue|continue;
name|from
operator|=
name|read_filename_string
argument_list|(
name|ch
argument_list|,
name|f
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|getc
argument_list|(
name|f
argument_list|)
operator|)
operator|!=
name|EOF
operator|&&
name|is_hor_space
index|[
name|ch
index|]
condition|)
empty_stmt|;
name|to
operator|=
name|read_filename_string
argument_list|(
name|ch
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|ptr
operator|=
operator|(
operator|(
expr|struct
name|file_name_map
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|file_name_map
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|ptr
operator|->
name|map_from
operator|=
name|from
expr_stmt|;
comment|/* Make the real filename absolute.  */
if|if
condition|(
operator|*
name|to
operator|==
literal|'/'
condition|)
name|ptr
operator|->
name|map_to
operator|=
name|to
expr_stmt|;
else|else
block|{
name|ptr
operator|->
name|map_to
operator|=
name|xmalloc
argument_list|(
name|dirlen
operator|+
name|strlen
argument_list|(
name|to
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|ptr
operator|->
name|map_to
argument_list|,
name|dirname
argument_list|)
expr_stmt|;
name|ptr
operator|->
name|map_to
index|[
name|dirlen
index|]
operator|=
literal|'/'
expr_stmt|;
name|strcpy
argument_list|(
name|ptr
operator|->
name|map_to
operator|+
name|dirlen
operator|+
literal|1
argument_list|,
name|to
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|to
argument_list|)
expr_stmt|;
block|}
name|ptr
operator|->
name|map_next
operator|=
name|map_list_ptr
operator|->
name|map_list_map
expr_stmt|;
name|map_list_ptr
operator|->
name|map_list_map
operator|=
name|ptr
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|getc
argument_list|(
name|f
argument_list|)
operator|)
operator|!=
literal|'\n'
condition|)
if|if
condition|(
name|ch
operator|==
name|EOF
condition|)
break|break;
block|}
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
name|map_list_ptr
operator|->
name|map_list_next
operator|=
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|map_list
expr_stmt|;
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|map_list
operator|=
name|map_list_ptr
expr_stmt|;
return|return
name|map_list_ptr
operator|->
name|map_list_map
return|;
block|}
end_function

begin_comment
comment|/* Remap NAME based on the file_name_map (if any) for LOC. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|remap_filename
parameter_list|(
name|pfile
parameter_list|,
name|name
parameter_list|,
name|loc
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|file_name_list
modifier|*
name|loc
decl_stmt|;
block|{
name|struct
name|file_name_map
modifier|*
name|map
decl_stmt|;
specifier|const
name|char
modifier|*
name|from
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|dir
decl_stmt|;
if|if
condition|(
operator|!
name|loc
operator|->
name|name_map
condition|)
name|loc
operator|->
name|name_map
operator|=
name|read_name_map
argument_list|(
name|pfile
argument_list|,
name|loc
operator|->
name|name
condition|?
name|loc
operator|->
name|name
else|:
literal|"."
argument_list|)
expr_stmt|;
if|if
condition|(
name|loc
operator|->
name|name_map
operator|==
operator|(
expr|struct
name|file_name_map
operator|*
operator|)
operator|-
literal|1
condition|)
return|return
name|name
return|;
name|from
operator|=
name|name
operator|+
name|strlen
argument_list|(
name|loc
operator|->
name|name
argument_list|)
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|map
operator|=
name|loc
operator|->
name|name_map
init|;
name|map
condition|;
name|map
operator|=
name|map
operator|->
name|map_next
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|map
operator|->
name|map_from
argument_list|,
name|from
argument_list|)
condition|)
return|return
name|map
operator|->
name|map_to
return|;
comment|/* Try to find a mapping file for the particular directory we are      looking in.  Thus #include<sys/types.h> will look up sys/types.h      in /usr/include/header.gcc and look up types.h in      /usr/include/sys/header.gcc.  */
name|p
operator|=
name|rindex
argument_list|(
name|name
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
name|p
operator|=
name|name
expr_stmt|;
if|if
condition|(
name|loc
operator|&&
name|loc
operator|->
name|name
operator|&&
name|strlen
argument_list|(
name|loc
operator|->
name|name
argument_list|)
operator|==
call|(
name|size_t
call|)
argument_list|(
name|p
operator|-
name|name
argument_list|)
operator|&&
operator|!
name|strncmp
argument_list|(
name|loc
operator|->
name|name
argument_list|,
name|name
argument_list|,
name|p
operator|-
name|name
argument_list|)
condition|)
comment|/* FILENAME is in SEARCHPTR, which we've already checked.  */
return|return
name|name
return|;
if|if
condition|(
name|p
operator|==
name|name
condition|)
block|{
name|dir
operator|=
literal|"."
expr_stmt|;
name|from
operator|=
name|name
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|newdir
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|p
operator|-
name|name
operator|+
literal|1
argument_list|)
decl_stmt|;
name|bcopy
argument_list|(
name|name
argument_list|,
name|newdir
argument_list|,
name|p
operator|-
name|name
argument_list|)
expr_stmt|;
name|newdir
index|[
name|p
operator|-
name|name
index|]
operator|=
literal|'\0'
expr_stmt|;
name|dir
operator|=
name|newdir
expr_stmt|;
name|from
operator|=
name|p
operator|+
literal|1
expr_stmt|;
block|}
for|for
control|(
name|map
operator|=
name|read_name_map
argument_list|(
name|pfile
argument_list|,
name|dir
argument_list|)
init|;
name|map
condition|;
name|map
operator|=
name|map
operator|->
name|map_next
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|map
operator|->
name|map_from
argument_list|,
name|name
argument_list|)
condition|)
return|return
name|map
operator|->
name|map_to
return|;
return|return
name|name
return|;
block|}
end_function

begin_comment
comment|/* Read the contents of FD into the buffer on the top of PFILE's stack.    IHASH points to the include hash entry for the file associated with    FD.     The caller is responsible for the cpp_push_buffer.  */
end_comment

begin_function
name|int
name|finclude
parameter_list|(
name|pfile
parameter_list|,
name|fd
parameter_list|,
name|ihash
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|struct
name|include_hash
modifier|*
name|ihash
decl_stmt|;
block|{
name|struct
name|stat
name|st
decl_stmt|;
name|size_t
name|st_size
decl_stmt|;
name|long
name|length
decl_stmt|;
name|cpp_buffer
modifier|*
name|fp
decl_stmt|;
if|if
condition|(
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|perror_fail
goto|;
if|if
condition|(
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_SETFL
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
comment|/* turn off nonblocking mode */
goto|goto
name|perror_fail
goto|;
name|fp
operator|=
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
comment|/* If fd points to a plain file, we know how big it is, so we can      allocate the buffer all at once.  If fd is a pipe or terminal, we      can't.  Most C source files are 4k or less, so we guess that.  If      fd is something weird, like a block device or a directory, we      don't want to read it at all.       Unfortunately, different systems use different st.st_mode values      for pipes: some have S_ISFIFO, some S_ISSOCK, some are buggy and      zero the entire struct stat except a couple fields.  Hence the      mess below.       In all cases, read_and_prescan will resize the buffer if it      turns out there's more data than we thought.  */
if|if
condition|(
name|S_ISREG
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
block|{
comment|/* off_t might have a wider range than size_t - in other words, 	 the max size of a file might be bigger than the address 	 space.  We can't handle a file that large.  (Anyone with          a single source file bigger than 4GB needs to rethink 	 their coding style.)  */
name|st_size
operator|=
operator|(
name|size_t
operator|)
name|st
operator|.
name|st_size
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
name|HOST_WIDEST_INT
operator|)
name|st_size
operator|!=
operator|(
name|unsigned
name|HOST_WIDEST_INT
operator|)
name|st
operator|.
name|st_size
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"file `%s' is too large"
argument_list|,
name|ihash
operator|->
name|name
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|S_ISFIFO
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
operator|||
name|S_ISSOCK
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
comment|/* Permit any kind of character device: the sensible ones are 	      ttys and /dev/null, but weeding out the others is too hard.  */
operator|||
name|S_ISCHR
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
comment|/* Some 4.x (x<4) derivatives have a bug that makes fstat() of a 	      socket or pipe return a stat struct with most fields zeroed.  */
operator|||
operator|(
name|st
operator|.
name|st_mode
operator|==
literal|0
operator|&&
name|st
operator|.
name|st_nlink
operator|==
literal|0
operator|&&
name|st
operator|.
name|st_size
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* Cannot get its file size before reading.  4k is a decent          first guess. */
name|st_size
operator|=
literal|4096
expr_stmt|;
block|}
else|else
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"`%s' is not a file, pipe, or tty"
argument_list|,
name|ihash
operator|->
name|name
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|pfile
operator|->
name|input_buffer
operator|==
name|NULL
condition|)
name|initialize_input_buffer
argument_list|(
name|pfile
argument_list|,
name|fd
argument_list|,
operator|&
name|st
argument_list|)
expr_stmt|;
comment|/* Read the file, converting end-of-line characters and trigraphs      (if enabled). */
name|fp
operator|->
name|ihash
operator|=
name|ihash
expr_stmt|;
name|fp
operator|->
name|nominal_fname
operator|=
name|fp
operator|->
name|fname
operator|=
name|ihash
operator|->
name|name
expr_stmt|;
name|length
operator|=
name|read_and_prescan
argument_list|(
name|pfile
argument_list|,
name|fp
argument_list|,
name|fd
argument_list|,
name|st_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|<
literal|0
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
name|length
operator|==
literal|0
condition|)
name|ihash
operator|->
name|control_macro
operator|=
literal|""
expr_stmt|;
comment|/* never re-include */
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|fp
operator|->
name|rlimit
operator|=
name|fp
operator|->
name|alimit
operator|=
name|fp
operator|->
name|buf
operator|+
name|length
expr_stmt|;
name|fp
operator|->
name|cur
operator|=
name|fp
operator|->
name|buf
expr_stmt|;
if|if
condition|(
name|ihash
operator|->
name|foundhere
operator|!=
name|ABSOLUTE_PATH
condition|)
name|fp
operator|->
name|system_header_p
operator|=
name|ihash
operator|->
name|foundhere
operator|->
name|sysp
expr_stmt|;
name|fp
operator|->
name|lineno
operator|=
literal|1
expr_stmt|;
name|fp
operator|->
name|colno
operator|=
literal|1
expr_stmt|;
name|fp
operator|->
name|line_base
operator|=
name|fp
operator|->
name|buf
expr_stmt|;
name|fp
operator|->
name|cleanup
operator|=
name|file_cleanup
expr_stmt|;
comment|/* The ->actual_dir field is only used when ignore_srcdir is not in effect;      see do_include */
if|if
condition|(
operator|!
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|ignore_srcdir
condition|)
name|fp
operator|->
name|actual_dir
operator|=
name|actual_directory
argument_list|(
name|pfile
argument_list|,
name|fp
operator|->
name|fname
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|input_stack_listing_current
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
name|perror_fail
label|:
name|cpp_error_from_errno
argument_list|(
name|pfile
argument_list|,
name|ihash
operator|->
name|name
argument_list|)
expr_stmt|;
name|fail
label|:
name|cpp_pop_buffer
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Given a path FNAME, extract the directory component and place it    onto the actual_dirs list.  Return a pointer to the allocated    file_name_list structure.  These structures are used to implement    current-directory "" include searching. */
end_comment

begin_function
specifier|static
name|struct
name|file_name_list
modifier|*
name|actual_directory
parameter_list|(
name|pfile
parameter_list|,
name|fname
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|char
modifier|*
name|fname
decl_stmt|;
block|{
name|char
modifier|*
name|last_slash
decl_stmt|,
modifier|*
name|dir
decl_stmt|;
name|size_t
name|dlen
decl_stmt|;
name|struct
name|file_name_list
modifier|*
name|x
decl_stmt|;
name|dir
operator|=
name|xstrdup
argument_list|(
name|fname
argument_list|)
expr_stmt|;
name|last_slash
operator|=
name|rindex
argument_list|(
name|dir
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_slash
condition|)
block|{
if|if
condition|(
name|last_slash
operator|==
name|dir
condition|)
block|{
name|dlen
operator|=
literal|1
expr_stmt|;
name|last_slash
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
name|dlen
operator|=
name|last_slash
operator|-
name|dir
expr_stmt|;
operator|*
name|last_slash
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
else|else
block|{
name|dir
index|[
literal|0
index|]
operator|=
literal|'.'
expr_stmt|;
name|dir
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|dlen
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|dlen
operator|>
name|pfile
operator|->
name|max_include_len
condition|)
name|pfile
operator|->
name|max_include_len
operator|=
name|dlen
expr_stmt|;
for|for
control|(
name|x
operator|=
name|pfile
operator|->
name|actual_dirs
init|;
name|x
condition|;
name|x
operator|=
name|x
operator|->
name|alloc
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|x
operator|->
name|name
argument_list|,
name|dir
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|dir
argument_list|)
expr_stmt|;
return|return
name|x
return|;
block|}
comment|/* Not found, make a new one. */
name|x
operator|=
operator|(
expr|struct
name|file_name_list
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|file_name_list
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|->
name|name
operator|=
name|dir
expr_stmt|;
name|x
operator|->
name|nlen
operator|=
name|dlen
expr_stmt|;
name|x
operator|->
name|next
operator|=
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|quote_include
expr_stmt|;
name|x
operator|->
name|alloc
operator|=
name|pfile
operator|->
name|actual_dirs
expr_stmt|;
name|x
operator|->
name|sysp
operator|=
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
operator|->
name|system_header_p
expr_stmt|;
name|x
operator|->
name|name_map
operator|=
name|NULL
expr_stmt|;
name|pfile
operator|->
name|actual_dirs
operator|=
name|x
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/* Determine the current line and column.  Used only by read_and_prescan. */
end_comment

begin_function
specifier|static
name|void
name|find_position
parameter_list|(
name|start
parameter_list|,
name|limit
parameter_list|,
name|linep
parameter_list|,
name|colp
parameter_list|)
name|U_CHAR
modifier|*
name|start
decl_stmt|;
name|U_CHAR
modifier|*
name|limit
decl_stmt|;
name|unsigned
name|long
modifier|*
name|linep
decl_stmt|;
name|unsigned
name|long
modifier|*
name|colp
decl_stmt|;
block|{
name|unsigned
name|long
name|line
init|=
operator|*
name|linep
decl_stmt|,
name|col
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|start
operator|<
name|limit
condition|)
block|{
name|U_CHAR
name|ch
init|=
operator|*
name|start
operator|++
decl_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'\n'
operator|||
name|ch
operator|==
literal|'\r'
condition|)
name|line
operator|++
operator|,
name|col
operator|=
literal|1
expr_stmt|;
else|else
name|col
operator|++
expr_stmt|;
block|}
operator|*
name|linep
operator|=
name|line
operator|,
operator|*
name|colp
operator|=
name|col
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read the entire contents of file DESC into buffer BUF.  LEN is how    much memory to allocate initially; more will be allocated if    necessary.  Convert end-of-line markers (\n, \r, \r\n, \n\r) to    canonical form (\n).  If enabled, convert and/or warn about    trigraphs.  Convert backslash-newline to a one-character escape    (\r) and remove it from "embarrassing" places (i.e. the middle of a    token).  If there is no newline at the end of the file, add one and    warn.  Returns -1 on failure, or the actual length of the data to    be scanned.     This function does a lot of work, and can be a serious performance    bottleneck.  It has been tuned heavily; make sure you understand it    before hacking.  The common case - no trigraphs, Unix style line    breaks, backslash-newline set off by whitespace, newline at EOF -    has been optimized at the expense of the others.  The performance    penalty for DOS style line breaks (\r\n) is about 15%.        Warnings lose particularly heavily since we have to determine the    line number, which involves scanning from the beginning of the file    or from the last warning.  The penalty for the absence of a newline    at the end of reload1.c is about 60%.  (reload1.c is 329k.)     If your file has more than one kind of end-of-line marker, you    will get messed-up line numbering.  */
end_comment

begin_comment
comment|/* Table of characters that can't be handled in the inner loop.    Keep these contiguous to optimize the performance of the code generated    for the switch that uses them.  */
end_comment

begin_define
define|#
directive|define
name|SPECCASE_EMPTY
value|0
end_define

begin_define
define|#
directive|define
name|SPECCASE_NUL
value|1
end_define

begin_define
define|#
directive|define
name|SPECCASE_CR
value|2
end_define

begin_define
define|#
directive|define
name|SPECCASE_BACKSLASH
value|3
end_define

begin_define
define|#
directive|define
name|SPECCASE_QUESTION
value|4
end_define

begin_function
specifier|static
name|long
name|read_and_prescan
parameter_list|(
name|pfile
parameter_list|,
name|fp
parameter_list|,
name|desc
parameter_list|,
name|len
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|cpp_buffer
modifier|*
name|fp
decl_stmt|;
name|int
name|desc
decl_stmt|;
name|size_t
name|len
decl_stmt|;
block|{
name|U_CHAR
modifier|*
name|buf
init|=
operator|(
name|U_CHAR
operator|*
operator|)
name|xmalloc
argument_list|(
name|len
argument_list|)
decl_stmt|;
name|U_CHAR
modifier|*
name|ip
decl_stmt|,
modifier|*
name|op
decl_stmt|,
modifier|*
name|line_base
decl_stmt|;
name|U_CHAR
modifier|*
name|ibase
decl_stmt|;
name|U_CHAR
modifier|*
name|speccase
init|=
name|pfile
operator|->
name|input_speccase
decl_stmt|;
name|unsigned
name|long
name|line
decl_stmt|;
name|unsigned
name|int
name|deferred_newlines
decl_stmt|;
name|int
name|count
decl_stmt|;
name|size_t
name|offset
decl_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
name|op
operator|=
name|buf
expr_stmt|;
name|line_base
operator|=
name|buf
expr_stmt|;
name|line
operator|=
literal|1
expr_stmt|;
name|ibase
operator|=
name|pfile
operator|->
name|input_buffer
operator|+
literal|2
expr_stmt|;
name|deferred_newlines
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|read_next
label|:
name|count
operator|=
name|read
argument_list|(
name|desc
argument_list|,
name|pfile
operator|->
name|input_buffer
operator|+
literal|2
argument_list|,
name|pfile
operator|->
name|input_buffer_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|<
literal|0
condition|)
goto|goto
name|error
goto|;
elseif|else
if|if
condition|(
name|count
operator|==
literal|0
condition|)
break|break;
name|offset
operator|+=
name|count
expr_stmt|;
name|ip
operator|=
name|ibase
expr_stmt|;
name|ibase
operator|=
name|pfile
operator|->
name|input_buffer
operator|+
literal|2
expr_stmt|;
name|ibase
index|[
name|count
index|]
operator|=
name|ibase
index|[
name|count
operator|+
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|offset
operator|>
name|len
condition|)
block|{
name|size_t
name|delta_op
decl_stmt|;
name|size_t
name|delta_line_base
decl_stmt|;
name|len
operator|*=
literal|2
expr_stmt|;
if|if
condition|(
name|offset
operator|>
name|len
condition|)
comment|/* len overflowed. 	       This could happen if the file is larger than half the 	       maximum address space of the machine. */
goto|goto
name|too_big
goto|;
name|delta_op
operator|=
name|op
operator|-
name|buf
expr_stmt|;
name|delta_line_base
operator|=
name|line_base
operator|-
name|buf
expr_stmt|;
name|buf
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|xrealloc
argument_list|(
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|op
operator|=
name|buf
operator|+
name|delta_op
expr_stmt|;
name|line_base
operator|=
name|buf
operator|+
name|delta_line_base
expr_stmt|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
name|unsigned
name|int
name|span
init|=
literal|0
decl_stmt|;
comment|/* Deal with \-newline in the middle of a token. */
if|if
condition|(
name|deferred_newlines
condition|)
block|{
while|while
condition|(
name|speccase
index|[
name|ip
index|[
name|span
index|]
index|]
operator|==
name|SPECCASE_EMPTY
operator|&&
name|ip
index|[
name|span
index|]
operator|!=
literal|'\n'
operator|&&
name|ip
index|[
name|span
index|]
operator|!=
literal|'\t'
operator|&&
name|ip
index|[
name|span
index|]
operator|!=
literal|' '
condition|)
name|span
operator|++
expr_stmt|;
name|memcpy
argument_list|(
name|op
argument_list|,
name|ip
argument_list|,
name|span
argument_list|)
expr_stmt|;
name|op
operator|+=
name|span
expr_stmt|;
name|ip
operator|+=
name|span
expr_stmt|;
if|if
condition|(
operator|*
name|ip
operator|==
literal|'\n'
operator|||
operator|*
name|ip
operator|==
literal|'\t'
operator|||
operator|*
name|ip
operator|==
literal|' '
operator|||
operator|*
name|ip
operator|==
literal|' '
condition|)
while|while
condition|(
name|deferred_newlines
condition|)
name|deferred_newlines
operator|--
operator|,
operator|*
name|op
operator|++
operator|=
literal|'\r'
expr_stmt|;
name|span
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Copy as much as we can without special treatment. */
while|while
condition|(
name|speccase
index|[
name|ip
index|[
name|span
index|]
index|]
operator|==
name|SPECCASE_EMPTY
condition|)
name|span
operator|++
expr_stmt|;
name|memcpy
argument_list|(
name|op
argument_list|,
name|ip
argument_list|,
name|span
argument_list|)
expr_stmt|;
name|op
operator|+=
name|span
expr_stmt|;
name|ip
operator|+=
name|span
expr_stmt|;
switch|switch
condition|(
name|speccase
index|[
operator|*
name|ip
operator|++
index|]
condition|)
block|{
case|case
name|SPECCASE_NUL
case|:
comment|/* \0 */
name|ibase
index|[
operator|-
literal|1
index|]
operator|=
name|op
index|[
operator|-
literal|1
index|]
expr_stmt|;
goto|goto
name|read_next
goto|;
case|case
name|SPECCASE_CR
case|:
comment|/* \r */
if|if
condition|(
operator|*
name|ip
operator|==
literal|'\n'
condition|)
name|ip
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|ip
operator|==
literal|'\0'
condition|)
block|{
operator|*
operator|--
name|ibase
operator|=
literal|'\r'
expr_stmt|;
goto|goto
name|read_next
goto|;
block|}
elseif|else
if|if
condition|(
name|ip
index|[
operator|-
literal|2
index|]
operator|==
literal|'\n'
condition|)
continue|continue;
operator|*
name|op
operator|++
operator|=
literal|'\n'
expr_stmt|;
break|break;
case|case
name|SPECCASE_BACKSLASH
case|:
comment|/* \ */
name|backslash
label|:
block|{
comment|/* If we're at the end of the intermediate buffer, 		 we have to shift the backslash down to the start 		 and come back next pass. */
if|if
condition|(
operator|*
name|ip
operator|==
literal|'\0'
condition|)
block|{
operator|*
operator|--
name|ibase
operator|=
literal|'\\'
expr_stmt|;
goto|goto
name|read_next
goto|;
block|}
elseif|else
if|if
condition|(
operator|*
name|ip
operator|==
literal|'\n'
condition|)
block|{
name|ip
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|ip
operator|==
literal|'\r'
condition|)
name|ip
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|ip
operator|==
literal|'\n'
operator|||
operator|*
name|ip
operator|==
literal|'\t'
operator|||
operator|*
name|ip
operator|==
literal|' '
condition|)
operator|*
name|op
operator|++
operator|=
literal|'\r'
expr_stmt|;
elseif|else
if|if
condition|(
name|op
index|[
operator|-
literal|1
index|]
operator|==
literal|'\t'
operator|||
name|op
index|[
operator|-
literal|1
index|]
operator|==
literal|' '
operator|||
name|op
index|[
operator|-
literal|1
index|]
operator|==
literal|'\r'
operator|||
name|op
index|[
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
operator|*
name|op
operator|++
operator|=
literal|'\r'
expr_stmt|;
else|else
name|deferred_newlines
operator|++
expr_stmt|;
name|line
operator|++
expr_stmt|;
name|line_base
operator|=
name|op
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|ip
operator|==
literal|'\r'
condition|)
block|{
name|ip
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|ip
operator|==
literal|'\n'
condition|)
name|ip
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|ip
operator|==
literal|'\0'
condition|)
block|{
operator|*
operator|--
name|ibase
operator|=
literal|'\r'
expr_stmt|;
operator|*
operator|--
name|ibase
operator|=
literal|'\\'
expr_stmt|;
goto|goto
name|read_next
goto|;
block|}
elseif|else
if|if
condition|(
operator|*
name|ip
operator|==
literal|'\r'
operator|||
operator|*
name|ip
operator|==
literal|'\t'
operator|||
operator|*
name|ip
operator|==
literal|' '
condition|)
operator|*
name|op
operator|++
operator|=
literal|'\r'
expr_stmt|;
else|else
name|deferred_newlines
operator|++
expr_stmt|;
name|line
operator|++
expr_stmt|;
name|line_base
operator|=
name|op
expr_stmt|;
block|}
else|else
operator|*
name|op
operator|++
operator|=
literal|'\\'
expr_stmt|;
block|}
break|break;
case|case
name|SPECCASE_QUESTION
case|:
comment|/* ? */
block|{
name|unsigned
name|int
name|d
decl_stmt|;
comment|/* If we're at the end of the intermediate buffer, 		   we have to shift the ?'s down to the start and 		   come back next pass. */
name|d
operator|=
name|ip
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|d
operator|==
literal|'\0'
condition|)
block|{
operator|*
operator|--
name|ibase
operator|=
literal|'?'
expr_stmt|;
goto|goto
name|read_next
goto|;
block|}
if|if
condition|(
name|d
operator|!=
literal|'?'
condition|)
block|{
operator|*
name|op
operator|++
operator|=
literal|'?'
expr_stmt|;
break|break;
block|}
name|d
operator|=
name|ip
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|d
operator|==
literal|'\0'
condition|)
block|{
operator|*
operator|--
name|ibase
operator|=
literal|'?'
expr_stmt|;
operator|*
operator|--
name|ibase
operator|=
literal|'?'
expr_stmt|;
goto|goto
name|read_next
goto|;
block|}
if|if
condition|(
operator|!
name|trigraph_table
index|[
name|d
index|]
condition|)
block|{
operator|*
name|op
operator|++
operator|=
literal|'?'
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|warn_trigraphs
condition|)
block|{
name|unsigned
name|long
name|col
decl_stmt|;
name|find_position
argument_list|(
name|line_base
argument_list|,
name|op
argument_list|,
operator|&
name|line
argument_list|,
operator|&
name|col
argument_list|)
expr_stmt|;
name|line_base
operator|=
name|op
operator|-
name|col
expr_stmt|;
name|cpp_warning_with_line
argument_list|(
name|pfile
argument_list|,
name|line
argument_list|,
name|col
argument_list|,
literal|"trigraph ??%c encountered"
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|trigraphs
condition|)
block|{
if|if
condition|(
name|trigraph_table
index|[
name|d
index|]
operator|==
literal|'\\'
condition|)
goto|goto
name|backslash
goto|;
else|else
operator|*
name|op
operator|++
operator|=
name|trigraph_table
index|[
name|d
index|]
expr_stmt|;
block|}
else|else
block|{
operator|*
name|op
operator|++
operator|=
literal|'?'
expr_stmt|;
operator|*
name|op
operator|++
operator|=
literal|'?'
expr_stmt|;
operator|*
name|op
operator|++
operator|=
name|d
expr_stmt|;
block|}
name|ip
operator|+=
literal|2
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|offset
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Deal with pushed-back chars at true EOF.      This may be any of:  ?? ? \ \r \n \\r \\n.      \r must become \n, \\r or \\n must become \r.      We know we have space already. */
if|if
condition|(
name|ibase
operator|==
name|pfile
operator|->
name|input_buffer
condition|)
block|{
if|if
condition|(
operator|*
name|ibase
operator|==
literal|'?'
condition|)
block|{
operator|*
name|op
operator|++
operator|=
literal|'?'
expr_stmt|;
operator|*
name|op
operator|++
operator|=
literal|'?'
expr_stmt|;
block|}
else|else
operator|*
name|op
operator|++
operator|=
literal|'\r'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ibase
operator|==
name|pfile
operator|->
name|input_buffer
operator|+
literal|1
condition|)
block|{
if|if
condition|(
operator|*
name|ibase
operator|==
literal|'\r'
condition|)
operator|*
name|op
operator|++
operator|=
literal|'\n'
expr_stmt|;
else|else
operator|*
name|op
operator|++
operator|=
operator|*
name|ibase
expr_stmt|;
block|}
if|if
condition|(
name|op
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
block|{
name|unsigned
name|long
name|col
decl_stmt|;
name|find_position
argument_list|(
name|line_base
argument_list|,
name|op
argument_list|,
operator|&
name|line
argument_list|,
operator|&
name|col
argument_list|)
expr_stmt|;
name|cpp_warning_with_line
argument_list|(
name|pfile
argument_list|,
name|line
argument_list|,
name|col
argument_list|,
literal|"no newline at end of file\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|+
literal|1
operator|>
name|len
condition|)
block|{
name|len
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|offset
operator|+
literal|1
operator|>
name|len
condition|)
goto|goto
name|too_big
goto|;
name|buf
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|xrealloc
argument_list|(
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|op
operator|=
name|buf
operator|+
name|offset
expr_stmt|;
block|}
operator|*
name|op
operator|++
operator|=
literal|'\n'
expr_stmt|;
block|}
name|fp
operator|->
name|buf
operator|=
operator|(
operator|(
name|len
operator|-
name|offset
operator|<
literal|20
operator|)
condition|?
name|buf
else|:
operator|(
name|U_CHAR
operator|*
operator|)
name|xrealloc
argument_list|(
name|buf
argument_list|,
name|op
operator|-
name|buf
argument_list|)
operator|)
expr_stmt|;
return|return
name|op
operator|-
name|buf
return|;
name|too_big
label|:
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"file is too large (>%lu bytes)\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|offset
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
name|error
label|:
name|cpp_error_from_errno
argument_list|(
name|pfile
argument_list|,
name|fp
operator|->
name|fname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Initialize the `input_buffer' and `input_speccase' tables.    These are only used by read_and_prescan, but they're large and    somewhat expensive to set up, so we want them allocated once for    the duration of the cpp run.  */
end_comment

begin_function
specifier|static
name|void
name|initialize_input_buffer
parameter_list|(
name|pfile
parameter_list|,
name|fd
parameter_list|,
name|st
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|struct
name|stat
modifier|*
name|st
decl_stmt|;
block|{
name|long
name|pipe_buf
decl_stmt|;
name|U_CHAR
modifier|*
name|tmp
decl_stmt|;
comment|/* Table of characters that cannot be handled by the      read_and_prescan inner loop.  The number of non-EMPTY entries      should be as small as humanly possible.  */
name|tmp
operator|=
name|xmalloc
argument_list|(
literal|1
operator|<<
name|CHAR_BIT
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|tmp
argument_list|,
name|SPECCASE_EMPTY
argument_list|,
literal|1
operator|<<
name|CHAR_BIT
argument_list|)
expr_stmt|;
name|tmp
index|[
literal|'\0'
index|]
operator|=
name|SPECCASE_NUL
expr_stmt|;
name|tmp
index|[
literal|'\r'
index|]
operator|=
name|SPECCASE_CR
expr_stmt|;
name|tmp
index|[
literal|'\\'
index|]
operator|=
name|SPECCASE_BACKSLASH
expr_stmt|;
if|if
condition|(
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|trigraphs
operator|||
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|warn_trigraphs
condition|)
name|tmp
index|[
literal|'?'
index|]
operator|=
name|SPECCASE_QUESTION
expr_stmt|;
name|pfile
operator|->
name|input_speccase
operator|=
name|tmp
expr_stmt|;
comment|/* Determine the appropriate size for the input buffer.  Normal C      source files are smaller than eight K.  If we are reading a pipe,      we want to make sure the input buffer is bigger than the kernel's      pipe buffer.  */
name|pipe_buf
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|S_ISREG
argument_list|(
name|st
operator|->
name|st_mode
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|_PC_PIPE_BUF
name|pipe_buf
operator|=
name|fpathconf
argument_list|(
name|fd
argument_list|,
name|_PC_PIPE_BUF
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pipe_buf
operator|==
operator|-
literal|1
condition|)
block|{
ifdef|#
directive|ifdef
name|PIPE_BUF
name|pipe_buf
operator|=
name|PIPE_BUF
expr_stmt|;
else|#
directive|else
name|pipe_buf
operator|=
literal|8192
expr_stmt|;
endif|#
directive|endif
block|}
block|}
if|if
condition|(
name|pipe_buf
operator|<
literal|8192
condition|)
name|pipe_buf
operator|=
literal|8192
expr_stmt|;
comment|/* PIPE_BUF bytes of buffer proper, 2 to detect running off the end      without address arithmetic all the time, and 2 for pushback in      the case there's a potential trigraph or end-of-line digraph at      the end of a block. */
name|tmp
operator|=
name|xmalloc
argument_list|(
name|pipe_buf
operator|+
literal|2
operator|+
literal|2
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|input_buffer
operator|=
name|tmp
expr_stmt|;
name|pfile
operator|->
name|input_buffer_len
operator|=
name|pipe_buf
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add output to `deps_buffer' for the -M switch.    STRING points to the text to be output.    SPACER is ':' for targets, ' ' for dependencies, zero for text    to be inserted literally.  */
end_comment

begin_function
name|void
name|deps_output
parameter_list|(
name|pfile
parameter_list|,
name|string
parameter_list|,
name|spacer
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|spacer
decl_stmt|;
block|{
name|int
name|size
decl_stmt|;
name|int
name|cr
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
operator|*
name|string
condition|)
return|return;
name|size
operator|=
name|strlen
argument_list|(
name|string
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|MAX_OUTPUT_COLUMNS
define|#
directive|define
name|MAX_OUTPUT_COLUMNS
value|72
endif|#
directive|endif
if|if
condition|(
name|pfile
operator|->
name|deps_column
operator|>
literal|0
operator|&&
operator|(
name|pfile
operator|->
name|deps_column
operator|+
name|size
operator|)
operator|>
name|MAX_OUTPUT_COLUMNS
condition|)
block|{
name|cr
operator|=
literal|5
expr_stmt|;
name|pfile
operator|->
name|deps_column
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|pfile
operator|->
name|deps_size
operator|+
name|size
operator|+
name|cr
operator|+
literal|8
operator|>
name|pfile
operator|->
name|deps_allocated_size
condition|)
block|{
name|pfile
operator|->
name|deps_allocated_size
operator|=
operator|(
name|pfile
operator|->
name|deps_size
operator|+
name|size
operator|+
literal|50
operator|)
operator|*
literal|2
expr_stmt|;
name|pfile
operator|->
name|deps_buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|pfile
operator|->
name|deps_buffer
argument_list|,
name|pfile
operator|->
name|deps_allocated_size
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cr
condition|)
block|{
name|bcopy
argument_list|(
literal|" \\\n  "
argument_list|,
operator|&
name|pfile
operator|->
name|deps_buffer
index|[
name|pfile
operator|->
name|deps_size
index|]
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|deps_size
operator|+=
literal|5
expr_stmt|;
block|}
if|if
condition|(
name|spacer
operator|==
literal|' '
operator|&&
name|pfile
operator|->
name|deps_column
operator|>
literal|0
condition|)
name|pfile
operator|->
name|deps_buffer
index|[
name|pfile
operator|->
name|deps_size
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
name|bcopy
argument_list|(
name|string
argument_list|,
operator|&
name|pfile
operator|->
name|deps_buffer
index|[
name|pfile
operator|->
name|deps_size
index|]
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|deps_size
operator|+=
name|size
expr_stmt|;
name|pfile
operator|->
name|deps_column
operator|+=
name|size
expr_stmt|;
if|if
condition|(
name|spacer
operator|==
literal|':'
condition|)
name|pfile
operator|->
name|deps_buffer
index|[
name|pfile
operator|->
name|deps_size
operator|++
index|]
operator|=
literal|':'
expr_stmt|;
name|pfile
operator|->
name|deps_buffer
index|[
name|pfile
operator|->
name|deps_size
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Simplify a path name in place, deleting redundant components.  This    reduces OS overhead and guarantees that equivalent paths compare    the same (modulo symlinks).     Transforms made:    foo/bar/../quux	foo/quux    foo/./bar		foo/bar    foo//bar		foo/bar    /../quux		/quux    //quux		//quux  (POSIX allows leading // as a namespace escape)     Guarantees no trailing slashes. All transforms reduce the length    of the string.  */
end_comment

begin_function
name|void
name|simplify_pathname
parameter_list|(
name|path
parameter_list|)
name|char
modifier|*
name|path
decl_stmt|;
block|{
name|char
modifier|*
name|from
decl_stmt|,
modifier|*
name|to
decl_stmt|;
name|char
modifier|*
name|base
decl_stmt|;
name|int
name|absolute
init|=
literal|0
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_DOS_BASED_FILE_SYSTEM
argument_list|)
comment|/* Convert all backslashes to slashes. */
for|for
control|(
name|from
operator|=
name|path
init|;
operator|*
name|from
condition|;
name|from
operator|++
control|)
if|if
condition|(
operator|*
name|from
operator|==
literal|'\\'
condition|)
operator|*
name|from
operator|=
literal|'/'
expr_stmt|;
comment|/* Skip over leading drive letter if present. */
if|if
condition|(
name|ISALPHA
argument_list|(
name|path
index|[
literal|0
index|]
argument_list|)
operator|&&
name|path
index|[
literal|1
index|]
operator|==
literal|':'
condition|)
name|from
operator|=
name|to
operator|=
operator|&
name|path
index|[
literal|2
index|]
expr_stmt|;
else|else
name|from
operator|=
name|to
operator|=
name|path
expr_stmt|;
else|#
directive|else
name|from
operator|=
name|to
operator|=
name|path
expr_stmt|;
endif|#
directive|endif
comment|/* Remove redundant initial /s.  */
if|if
condition|(
operator|*
name|from
operator|==
literal|'/'
condition|)
block|{
name|absolute
operator|=
literal|1
expr_stmt|;
name|to
operator|++
expr_stmt|;
name|from
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|from
operator|==
literal|'/'
condition|)
block|{
if|if
condition|(
operator|*
operator|++
name|from
operator|==
literal|'/'
condition|)
comment|/* 3 or more initial /s are equivalent to 1 /.  */
while|while
condition|(
operator|*
operator|++
name|from
operator|==
literal|'/'
condition|)
empty_stmt|;
else|else
comment|/* On some hosts // differs from /; Posix allows this.  */
name|to
operator|++
expr_stmt|;
block|}
block|}
name|base
operator|=
name|to
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
while|while
condition|(
operator|*
name|from
operator|==
literal|'/'
condition|)
name|from
operator|++
expr_stmt|;
if|if
condition|(
name|from
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|from
index|[
literal|1
index|]
operator|==
literal|'/'
condition|)
name|from
operator|+=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|from
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|from
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
goto|goto
name|done
goto|;
elseif|else
if|if
condition|(
name|from
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|from
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
name|from
index|[
literal|2
index|]
operator|==
literal|'/'
condition|)
block|{
if|if
condition|(
name|base
operator|==
name|to
condition|)
block|{
if|if
condition|(
name|absolute
condition|)
name|from
operator|+=
literal|3
expr_stmt|;
else|else
block|{
operator|*
name|to
operator|++
operator|=
operator|*
name|from
operator|++
expr_stmt|;
operator|*
name|to
operator|++
operator|=
operator|*
name|from
operator|++
expr_stmt|;
operator|*
name|to
operator|++
operator|=
operator|*
name|from
operator|++
expr_stmt|;
name|base
operator|=
name|to
expr_stmt|;
block|}
block|}
else|else
block|{
name|to
operator|-=
literal|2
expr_stmt|;
while|while
condition|(
name|to
operator|>
name|base
operator|&&
operator|*
name|to
operator|!=
literal|'/'
condition|)
name|to
operator|--
expr_stmt|;
if|if
condition|(
operator|*
name|to
operator|==
literal|'/'
condition|)
name|to
operator|++
expr_stmt|;
name|from
operator|+=
literal|3
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|from
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|from
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
name|from
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|base
operator|==
name|to
condition|)
block|{
if|if
condition|(
operator|!
name|absolute
condition|)
block|{
operator|*
name|to
operator|++
operator|=
operator|*
name|from
operator|++
expr_stmt|;
operator|*
name|to
operator|++
operator|=
operator|*
name|from
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
name|to
operator|-=
literal|2
expr_stmt|;
while|while
condition|(
name|to
operator|>
name|base
operator|&&
operator|*
name|to
operator|!=
literal|'/'
condition|)
name|to
operator|--
expr_stmt|;
if|if
condition|(
operator|*
name|to
operator|==
literal|'/'
condition|)
name|to
operator|++
expr_stmt|;
block|}
goto|goto
name|done
goto|;
block|}
else|else
comment|/* Copy this component and trailing /, if any.  */
while|while
condition|(
operator|(
operator|*
name|to
operator|++
operator|=
operator|*
name|from
operator|++
operator|)
operator|!=
literal|'/'
condition|)
block|{
if|if
condition|(
operator|!
name|to
index|[
operator|-
literal|1
index|]
condition|)
block|{
name|to
operator|--
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
block|}
name|done
label|:
comment|/* Trim trailing slash */
if|if
condition|(
name|to
index|[
literal|0
index|]
operator|==
literal|'/'
operator|&&
operator|(
operator|!
name|absolute
operator|||
name|to
operator|>
name|path
operator|+
literal|1
operator|)
condition|)
name|to
operator|--
expr_stmt|;
comment|/* Change the empty string to "." so that stat() on the result        will always work. */
if|if
condition|(
name|to
operator|==
name|path
condition|)
operator|*
name|to
operator|++
operator|=
literal|'.'
expr_stmt|;
operator|*
name|to
operator|=
literal|'\0'
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* It is not clear when this should be used if at all, so I've    disabled it until someone who understands VMS can look at it. */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Under VMS we need to fix up the "include" specification filename.     Rules for possible conversions  	fullname		tried paths  	name			name 	./dir/name		[.dir]name 	/dir/name		dir:name 	/name			[000000]name, name 	dir/name		dir:[000000]name, dir:name, dir/name 	dir1/dir2/name		dir1:[dir2]name, dir1:[000000.dir2]name 	path:/name		path:[000000]name, path:name 	path:/dir/name		path:[000000.dir]name, path:[dir]name 	path:dir/name		path:[dir]name 	[path]:[dir]name	[path.dir]name 	path/[dir]name		[path.dir]name     The path:/name input is constructed when expanding<> includes. */
end_comment

begin_comment
unit|static void hack_vms_include_specification (fullname)      char *fullname; {   register char *basename, *unixname, *local_ptr, *first_slash;   int f, check_filename_before_returning, must_revert;   char Local[512];    check_filename_before_returning = 0;   must_revert = 0;
comment|/* See if we can find a 1st slash. If not, there's no path information.  */
end_comment

begin_comment
unit|first_slash = index (fullname, '/');   if (first_slash == 0)     return 0;
comment|/* Nothing to do!!! */
end_comment

begin_comment
comment|/* construct device spec if none given.  */
end_comment

begin_comment
unit|if (index (fullname, ':') == 0)     {
comment|/* If fullname has a slash, take it as device spec.  */
end_comment

begin_comment
unit|if (first_slash == fullname) 	{ 	  first_slash = index (fullname+1, '/');
comment|/* 2nd slash ? */
end_comment

begin_comment
unit|if (first_slash) 	    *first_slash = ':';
comment|/* make device spec  */
end_comment

begin_comment
unit|for (basename = fullname; *basename != 0; basename++) 	    *basename = *(basename+1);
comment|/* remove leading slash  */
end_comment

begin_comment
unit|}       else if ((first_slash[-1] != '.')
comment|/* keep ':/', './' */
end_comment

begin_comment
unit|&& (first_slash[-1] != ':')&& (first_slash[-1] != ']'))
comment|/* or a vms path  */
end_comment

begin_comment
unit|{ 	  *first_slash = ':'; 	}       else if ((first_slash[1] == '[')
comment|/* skip './' in './[dir'  */
end_comment

begin_comment
unit|&& (first_slash[-1] == '.')) 	fullname += 2;     }
comment|/* Get part after first ':' (basename[-1] == ':')      or last '/' (basename[-1] == '/').  */
end_comment

begin_comment
unit|basename = base_name (fullname);    local_ptr = Local;
comment|/* initialize */
end_comment

begin_comment
comment|/* We are trying to do a number of things here.  First of all, we are      trying to hammer the filenames into a standard format, such that later      processing can handle them.            If the file name contains something like [dir.], then it recognizes this      as a root, and strips the ".]".  Later processing will add whatever is      needed to get things working properly.            If no device is specified, then the first directory name is taken to be      a device name (or a rooted logical).  */
end_comment

begin_comment
comment|/* Point to the UNIX filename part (which needs to be fixed!)      but skip vms path information.      [basename != fullname since first_slash != 0].  */
end_comment

begin_comment
unit|if ((basename[-1] == ':')
comment|/* vms path spec.  */
end_comment

begin_comment
unit||| (basename[-1] == ']')       || (basename[-1] == '>'))     unixname = basename;   else     unixname = fullname;    if (*unixname == '/')     unixname++;
comment|/* If the directory spec is not rooted, we can just copy      the UNIX filename part and we are done.  */
end_comment

begin_comment
unit|if (((basename - fullname)> 1)&& (  (basename[-1] == ']')         || (basename[-1] == '>')))     {       if (basename[-2] != '.') 	{
comment|/* The VMS part ends in a `]', and the preceding character is not a `.'. 	   -> PATH]:/name (basename = '/name', unixname = 'name') 	   We strip the `]', and then splice the two parts of the name in the 	   usual way.  Given the default locations for include files in cccp.c, 	   we will only use this code if the user specifies alternate locations 	   with the /include (-I) switch on the command line.  */
end_comment

begin_comment
unit|basename -= 1;
comment|/* Strip "]" */
end_comment

begin_comment
unit|unixname--;
comment|/* backspace */
end_comment

begin_comment
unit|}       else 	{
comment|/* The VMS part has a ".]" at the end, and this will not do.  Later 	   processing will add a second directory spec, and this would be a syntax 	   error.  Thus we strip the ".]", and thus merge the directory specs. 	   We also backspace unixname, so that it points to a '/'.  This inhibits the 	   generation of the 000000 root directory spec (which does not belong here 	   in this case).  */
end_comment

begin_comment
unit|basename -= 2;
comment|/* Strip ".]" */
end_comment

begin_comment
unit|unixname--;
comment|/* backspace */
end_comment

begin_comment
unit|}     }    else      {
comment|/* We drop in here if there is no VMS style directory specification yet.          If there is no device specification either, we make the first dir a          device and try that.  If we do not do this, then we will be essentially          searching the users default directory (as if they did a #include "asdf.h").                   Then all we need to do is to push a '[' into the output string. Later          processing will fill this in, and close the bracket.  */
end_comment

begin_comment
unit|if ((unixname != fullname)
comment|/* vms path spec found.  */
end_comment

begin_comment
unit|&& (basename[-1] != ':')) 	*local_ptr++ = ':';
comment|/* dev not in spec.  take first dir */
end_comment

begin_comment
unit|*local_ptr++ = '[';
comment|/* Open the directory specification */
end_comment

begin_comment
unit|}      if (unixname == fullname)
comment|/* no vms dir spec.  */
end_comment

begin_comment
unit|{ 	must_revert = 1; 	if ((first_slash != 0)
comment|/* unix dir spec.  */
end_comment

begin_comment
unit|&& (*unixname != '/')
comment|/* not beginning with '/'  */
end_comment

begin_comment
unit|&& (*unixname != '.'))
comment|/* or './' or '../'  */
end_comment

begin_comment
unit|*local_ptr++ = '.';
comment|/* dir is local !  */
end_comment

begin_comment
unit|}
comment|/* at this point we assume that we have the device spec, and (at least      the opening "[" for a directory specification.  We may have directories      specified already.       If there are no other slashes then the filename will be      in the "root" directory.  Otherwise, we need to add      directory specifications.  */
end_comment

begin_comment
unit|if (index (unixname, '/') == 0)     {
comment|/* if no directories specified yet and none are following.  */
end_comment

begin_comment
unit|if (local_ptr[-1] == '[') 	{
comment|/* Just add "000000]" as the directory string */
end_comment

begin_comment
unit|strcpy (local_ptr, "000000]"); 	  local_ptr += strlen (local_ptr); 	  check_filename_before_returning = 1;
comment|/* we might need to fool with this later */
end_comment

begin_comment
unit|}     }   else     {
comment|/* As long as there are still subdirectories to add, do them.  */
end_comment

begin_comment
unit|while (index (unixname, '/') != 0) 	{
comment|/* If this token is "." we can ignore it 	       if it's not at the beginning of a path.  */
end_comment

begin_comment
unit|if ((unixname[0] == '.')&& (unixname[1] == '/')) 	    {
comment|/* remove it at beginning of path.  */
end_comment

begin_comment
unit|if (  ((unixname == fullname)
comment|/* no device spec  */
end_comment

begin_comment
unit|&& (fullname+2 != basename))
comment|/* starts with ./ */
end_comment

begin_comment
comment|/* or  */
end_comment

begin_comment
unit||| ((basename[-1] == ':')
comment|/* device spec  */
end_comment

begin_comment
unit|&& (unixname-1 == basename)))
comment|/* and ./ afterwards  */
end_comment

begin_comment
unit|*local_ptr++ = '.';
comment|/* make '[.' start of path.  */
end_comment

begin_comment
unit|unixname += 2; 	      continue; 	    }
comment|/* Add a subdirectory spec. Do not duplicate "." */
end_comment

begin_comment
unit|if (  local_ptr[-1] != '.'&& local_ptr[-1] != '['&& local_ptr[-1] != '<') 	    *local_ptr++ = '.';
comment|/* If this is ".." then the spec becomes "-" */
end_comment

begin_comment
unit|if (  (unixname[0] == '.')&& (unixname[1] == '.')&& (unixname[2] == '/')) 	    {
comment|/* Add "-" and skip the ".." */
end_comment

begin_comment
unit|if ((local_ptr[-1] == '.')&& (local_ptr[-2] == '[')) 		local_ptr--;
comment|/* prevent [.-  */
end_comment

begin_comment
unit|*local_ptr++ = '-'; 	      unixname += 3; 	      continue; 	    }
comment|/* Copy the subdirectory */
end_comment

begin_comment
unit|while (*unixname != '/') 	    *local_ptr++= *unixname++;  	  unixname++;
comment|/* Skip the "/" */
end_comment

begin_comment
unit|}
comment|/* Close the directory specification */
end_comment

begin_comment
unit|if (local_ptr[-1] == '.')
comment|/* no trailing periods */
end_comment

begin_comment
unit|local_ptr--;        if (local_ptr[-1] == '[')
comment|/* no dir needed */
end_comment

begin_comment
unit|local_ptr--;       else 	*local_ptr++ = ']';     }
comment|/* Now add the filename.  */
end_comment

begin_comment
unit|while (*unixname)     *local_ptr++ = *unixname++;   *local_ptr = 0;
comment|/* Now append it to the original VMS spec.  */
end_comment

begin_comment
unit|strcpy ((must_revert==1)?fullname:basename, Local);
comment|/* If we put a [000000] in the filename, try to open it first. If this fails,      remove the [000000], and return that name.  This provides flexibility      to the user in that they can use both rooted and non-rooted logical names      to point to the location of the file.  */
end_comment

begin_comment
unit|if (check_filename_before_returning)     {       f = open (fullname, O_RDONLY, 0666);       if (f>= 0) 	{
comment|/* The file name is OK as it is, so return it as is.  */
end_comment

begin_comment
unit|close (f); 	  return 1; 	}
comment|/* The filename did not work.  Try to remove the [000000] from the name, 	 and return it.  */
end_comment

begin_comment
unit|basename = index (fullname, '[');       local_ptr = index (fullname, ']') + 1;       strcpy (basename, local_ptr);
comment|/* this gets rid of it */
end_comment

begin_endif
unit|}    return 1; }
endif|#
directive|endif
end_endif

begin_comment
comment|/* VMS */
end_comment

end_unit

