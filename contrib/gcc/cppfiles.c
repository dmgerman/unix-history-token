begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Part of CPP library.  (include file handling)    Copyright (C) 1986, 1987, 1989, 1992, 1993, 1994, 1995, 1998,    1999, 2000, 2001, 2002 Free Software Foundation, Inc.    Written by Per Bothner, 1994.    Based on CCCP program by Paul Rubin, June 1986    Adapted to ANSI C, Richard Stallman, Jan 1987    Split out of cpplib.c, Zack Weinberg, Oct 1998  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"cpplib.h"
end_include

begin_include
include|#
directive|include
file|"cpphash.h"
end_include

begin_include
include|#
directive|include
file|"intl.h"
end_include

begin_include
include|#
directive|include
file|"mkdeps.h"
end_include

begin_include
include|#
directive|include
file|"splay-tree.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_MMAP_FILE
end_ifdef

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|MMAP_THRESHOLD
end_ifndef

begin_define
define|#
directive|define
name|MMAP_THRESHOLD
value|3
end_define

begin_comment
comment|/* Minimum page count to mmap the file.  */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|MMAP_THRESHOLD
end_if

begin_define
define|#
directive|define
name|TEST_THRESHOLD
parameter_list|(
name|size
parameter_list|,
name|pagesize
parameter_list|)
define|\
value|(size / pagesize>= MMAP_THRESHOLD&& (size % pagesize) != 0)
end_define

begin_comment
comment|/* Use mmap if the file is big enough to be worth it (controlled       by MMAP_THRESHOLD) and if we can safely count on there being       at least one readable NUL byte after the end of the file's       contents.  This is true for all tested operating systems when       the file size is not an exact multiple of the page size.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__CYGWIN__
end_ifndef

begin_define
define|#
directive|define
name|SHOULD_MMAP
parameter_list|(
name|size
parameter_list|,
name|pagesize
parameter_list|)
value|TEST_THRESHOLD (size, pagesize)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|WIN32_LEAN_AND_MEAN
end_define

begin_include
include|#
directive|include
file|<windows.h>
end_include

begin_comment
comment|/* Cygwin can't correctly emulate mmap under Windows 9x style systems so        disallow use of mmap on those systems.  Windows 9x does not zero fill        memory at EOF and beyond, as required.  */
end_comment

begin_define
define|#
directive|define
name|SHOULD_MMAP
parameter_list|(
name|size
parameter_list|,
name|pagesize
parameter_list|)
value|((GetVersion()& 0x80000000) \     					? 0 : TEST_THRESHOLD (size, pagesize))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* No MMAP_FILE */
end_comment

begin_undef
undef|#
directive|undef
name|MMAP_THRESHOLD
end_undef

begin_define
define|#
directive|define
name|MMAP_THRESHOLD
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|O_BINARY
end_ifndef

begin_define
define|#
directive|define
name|O_BINARY
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* If errno is inspected immediately after a system call fails, it will be    nonzero, and no error number will ever be zero.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ENOENT
end_ifndef

begin_define
define|#
directive|define
name|ENOENT
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ENOTDIR
end_ifndef

begin_define
define|#
directive|define
name|ENOTDIR
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Suppress warning about function macros used w/o arguments in traditional    C.  It is unlikely that glibc's strcmp macro helps this file at all.  */
end_comment

begin_undef
undef|#
directive|undef
name|strcmp
end_undef

begin_comment
comment|/* This structure is used for the table of all includes.  */
end_comment

begin_struct
struct|struct
name|include_file
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* actual path name of file */
specifier|const
name|cpp_hashnode
modifier|*
name|cmacro
decl_stmt|;
comment|/* macro, if any, preventing reinclusion.  */
specifier|const
name|struct
name|search_path
modifier|*
name|foundhere
decl_stmt|;
comment|/* location in search path where file was 				   found, for #include_next and sysp.  */
specifier|const
name|unsigned
name|char
modifier|*
name|buffer
decl_stmt|;
comment|/* pointer to cached file contents */
name|struct
name|stat
name|st
decl_stmt|;
comment|/* copy of stat(2) data for file */
name|int
name|fd
decl_stmt|;
comment|/* fd open on file (short term storage only) */
name|int
name|err_no
decl_stmt|;
comment|/* errno obtained if opening a file failed */
name|unsigned
name|short
name|include_count
decl_stmt|;
comment|/* number of times file has been read */
name|unsigned
name|short
name|refcnt
decl_stmt|;
comment|/* number of stacked buffers using this file */
name|unsigned
name|char
name|mapped
decl_stmt|;
comment|/* file buffer is mmapped */
block|}
struct|;
end_struct

begin_comment
comment|/* Variable length record files on VMS will have a stat size that includes    record control characters that won't be included in the read size.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|VMS
end_ifdef

begin_define
define|#
directive|define
name|FAB_C_VAR
value|2
end_define

begin_comment
comment|/* variable length records (see Starlet fabdef.h) */
end_comment

begin_define
define|#
directive|define
name|STAT_SIZE_TOO_BIG
parameter_list|(
name|ST
parameter_list|)
value|((ST).st_fab_rfm == FAB_C_VAR)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|STAT_SIZE_TOO_BIG
parameter_list|(
name|ST
parameter_list|)
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The cmacro works like this: If it's NULL, the file is to be    included again.  If it's NEVER_REREAD, the file is never to be    included again.  Otherwise it is a macro hashnode, and the file is    to be included again if the macro is defined.  */
end_comment

begin_define
define|#
directive|define
name|NEVER_REREAD
value|((const cpp_hashnode *)-1)
end_define

begin_define
define|#
directive|define
name|DO_NOT_REREAD
parameter_list|(
name|inc
parameter_list|)
define|\
value|((inc)->cmacro&& ((inc)->cmacro == NEVER_REREAD \ 		   || (inc)->cmacro->type == NT_MACRO))
end_define

begin_define
define|#
directive|define
name|NO_INCLUDE_PATH
value|((struct include_file *) -1)
end_define

begin_decl_stmt
specifier|static
name|struct
name|file_name_map
modifier|*
name|read_name_map
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|read_filename_string
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|remap_filename
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
name|char
operator|*
operator|,
expr|struct
name|search_path
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|search_path
modifier|*
name|search_from
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
expr|enum
name|include_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|include_file
modifier|*
name|find_include_file
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
specifier|const
name|cpp_token
operator|*
operator|,
expr|enum
name|include_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|include_file
modifier|*
name|open_file
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|read_include_file
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
expr|struct
name|include_file
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|stack_include_file
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
expr|struct
name|include_file
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|purge_cache
name|PARAMS
argument_list|(
operator|(
expr|struct
name|include_file
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|destroy_node
name|PARAMS
argument_list|(
operator|(
name|splay_tree_value
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|report_missing_guard
name|PARAMS
argument_list|(
operator|(
name|splay_tree_node
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|splay_tree_node
name|find_or_create_entry
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|handle_missing_header
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|remove_component_p
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set up the splay tree we use to store information about all the    file names seen in this compilation.  We also have entries for each    file we tried to open but failed; this saves system calls since we    don't try to open it again in future.     The key of each node is the file name, after processing by    _cpp_simplify_pathname.  The path name may or may not be absolute.    The path string has been malloced, as is automatically freed by    registering free () as the splay tree key deletion function.     A node's value is a pointer to a struct include_file, and is never    NULL.  */
end_comment

begin_function
name|void
name|_cpp_init_includes
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
name|pfile
operator|->
name|all_include_files
operator|=
name|splay_tree_new
argument_list|(
operator|(
name|splay_tree_compare_fn
operator|)
name|strcmp
argument_list|,
operator|(
name|splay_tree_delete_key_fn
operator|)
name|free
argument_list|,
name|destroy_node
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Tear down the splay tree.  */
end_comment

begin_function
name|void
name|_cpp_cleanup_includes
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
name|splay_tree_delete
argument_list|(
name|pfile
operator|->
name|all_include_files
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Free a node.  The path string is automatically freed.  */
end_comment

begin_function
specifier|static
name|void
name|destroy_node
parameter_list|(
name|v
parameter_list|)
name|splay_tree_value
name|v
decl_stmt|;
block|{
name|struct
name|include_file
modifier|*
name|f
init|=
operator|(
expr|struct
name|include_file
operator|*
operator|)
name|v
decl_stmt|;
if|if
condition|(
name|f
condition|)
block|{
name|purge_cache
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Mark a file to not be reread (e.g. #import, read failure).  */
end_comment

begin_function
name|void
name|_cpp_never_reread
parameter_list|(
name|file
parameter_list|)
name|struct
name|include_file
modifier|*
name|file
decl_stmt|;
block|{
name|file
operator|->
name|cmacro
operator|=
name|NEVER_REREAD
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Lookup a filename, which is simplified after making a copy, and    create an entry if none exists.  errno is nonzero iff a (reported)    stat() error occurred during simplification.  */
end_comment

begin_function
specifier|static
name|splay_tree_node
name|find_or_create_entry
parameter_list|(
name|pfile
parameter_list|,
name|fname
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
specifier|const
name|char
modifier|*
name|fname
decl_stmt|;
block|{
name|splay_tree_node
name|node
decl_stmt|;
name|struct
name|include_file
modifier|*
name|file
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|xstrdup
argument_list|(
name|fname
argument_list|)
decl_stmt|;
name|_cpp_simplify_pathname
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|node
operator|=
name|splay_tree_lookup
argument_list|(
name|pfile
operator|->
name|all_include_files
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
condition|)
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
else|else
block|{
name|file
operator|=
name|xcnew
argument_list|(
expr|struct
name|include_file
argument_list|)
expr_stmt|;
name|file
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|file
operator|->
name|err_no
operator|=
name|errno
expr_stmt|;
name|node
operator|=
name|splay_tree_insert
argument_list|(
name|pfile
operator|->
name|all_include_files
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|file
operator|->
name|name
argument_list|,
operator|(
name|splay_tree_value
operator|)
name|file
argument_list|)
expr_stmt|;
block|}
return|return
name|node
return|;
block|}
end_function

begin_comment
comment|/* Enter a file name in the splay tree, for the sake of cpp_included.  */
end_comment

begin_function
name|void
name|_cpp_fake_include
parameter_list|(
name|pfile
parameter_list|,
name|fname
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
specifier|const
name|char
modifier|*
name|fname
decl_stmt|;
block|{
name|find_or_create_entry
argument_list|(
name|pfile
argument_list|,
name|fname
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given a file name, look it up in the cache; if there is no entry,    create one with a non-NULL value (regardless of success in opening    the file).  If the file doesn't exist or is inaccessible, this    entry is flagged so we don't attempt to open it again in the    future.  If the file isn't open, open it.  The empty string is    interpreted as stdin.     Returns an include_file structure with an open file descriptor on    success, or NULL on failure.  */
end_comment

begin_function
specifier|static
name|struct
name|include_file
modifier|*
name|open_file
parameter_list|(
name|pfile
parameter_list|,
name|filename
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|splay_tree_node
name|nd
init|=
name|find_or_create_entry
argument_list|(
name|pfile
argument_list|,
name|filename
argument_list|)
decl_stmt|;
name|struct
name|include_file
modifier|*
name|file
init|=
operator|(
expr|struct
name|include_file
operator|*
operator|)
name|nd
operator|->
name|value
decl_stmt|;
if|if
condition|(
name|file
operator|->
name|err_no
condition|)
block|{
comment|/* Ugh.  handle_missing_header () needs errno to be set.  */
name|errno
operator|=
name|file
operator|->
name|err_no
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Don't reopen an idempotent file.  */
if|if
condition|(
name|DO_NOT_REREAD
argument_list|(
name|file
argument_list|)
condition|)
return|return
name|file
return|;
comment|/* Don't reopen one which is already loaded.  */
if|if
condition|(
name|file
operator|->
name|buffer
operator|!=
name|NULL
condition|)
return|return
name|file
return|;
comment|/* We used to open files in nonblocking mode, but that caused more      problems than it solved.  Do take care not to acquire a      controlling terminal by mistake (this can't happen on sane      systems, but paranoia is a virtue).       Use the three-argument form of open even though we aren't      specifying O_CREAT, to defend against broken system headers.       O_BINARY tells some runtime libraries (notably DJGPP) not to do      newline translation; we can handle DOS line breaks just fine      ourselves.       Special case: the empty string is translated to stdin.  */
if|if
condition|(
name|filename
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|file
operator|->
name|fd
operator|=
literal|0
expr_stmt|;
else|else
name|file
operator|->
name|fd
operator|=
name|open
argument_list|(
name|file
operator|->
name|name
argument_list|,
name|O_RDONLY
operator||
name|O_NOCTTY
operator||
name|O_BINARY
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|->
name|fd
operator|!=
operator|-
literal|1
operator|&&
name|fstat
argument_list|(
name|file
operator|->
name|fd
argument_list|,
operator|&
name|file
operator|->
name|st
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|S_ISDIR
argument_list|(
name|file
operator|->
name|st
operator|.
name|st_mode
argument_list|)
condition|)
return|return
name|file
return|;
comment|/* If it's a directory, we return null and continue the search 	 as the file we're looking for may appear elsewhere in the 	 search path.  */
name|errno
operator|=
name|ENOENT
expr_stmt|;
name|close
argument_list|(
name|file
operator|->
name|fd
argument_list|)
expr_stmt|;
name|file
operator|->
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|file
operator|->
name|err_no
operator|=
name|errno
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Place the file referenced by INC into a new buffer on the buffer    stack, unless there are errors, or the file is not re-included    because of e.g. multiple-include guards.  Returns true if a buffer    is stacked.  */
end_comment

begin_function
specifier|static
name|bool
name|stack_include_file
parameter_list|(
name|pfile
parameter_list|,
name|inc
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|struct
name|include_file
modifier|*
name|inc
decl_stmt|;
block|{
name|cpp_buffer
modifier|*
name|fp
decl_stmt|;
name|int
name|sysp
decl_stmt|;
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
if|if
condition|(
name|DO_NOT_REREAD
argument_list|(
name|inc
argument_list|)
condition|)
return|return
name|false
return|;
name|sysp
operator|=
name|MAX
argument_list|(
operator|(
name|pfile
operator|->
name|map
condition|?
name|pfile
operator|->
name|map
operator|->
name|sysp
else|:
literal|0
operator|)
argument_list|,
operator|(
name|inc
operator|->
name|foundhere
condition|?
name|inc
operator|->
name|foundhere
operator|->
name|sysp
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
comment|/* For -M, add the file to the dependencies on its first inclusion.  */
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|print_deps
argument_list|)
operator|>
name|sysp
operator|&&
operator|!
name|inc
operator|->
name|include_count
condition|)
name|deps_add_dep
argument_list|(
name|pfile
operator|->
name|deps
argument_list|,
name|inc
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* Not in cache?  */
if|if
condition|(
operator|!
name|inc
operator|->
name|buffer
condition|)
block|{
if|if
condition|(
name|read_include_file
argument_list|(
name|pfile
argument_list|,
name|inc
argument_list|)
condition|)
block|{
comment|/* If an error occurs, do not try to read this file again.  */
name|_cpp_never_reread
argument_list|(
name|inc
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* Mark a regular, zero-length file never-reread.  We read it, 	 NUL-terminate it, and stack it once, so preprocessing a main 	 file of zero length does not raise an error.  */
if|if
condition|(
name|S_ISREG
argument_list|(
name|inc
operator|->
name|st
operator|.
name|st_mode
argument_list|)
operator|&&
name|inc
operator|->
name|st
operator|.
name|st_size
operator|==
literal|0
condition|)
name|_cpp_never_reread
argument_list|(
name|inc
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|inc
operator|->
name|fd
argument_list|)
expr_stmt|;
name|inc
operator|->
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|pfile
operator|->
name|buffer
condition|)
comment|/* We don't want MI guard advice for the main file.  */
name|inc
operator|->
name|include_count
operator|++
expr_stmt|;
comment|/* Push a buffer.  */
name|fp
operator|=
name|cpp_push_buffer
argument_list|(
name|pfile
argument_list|,
name|inc
operator|->
name|buffer
argument_list|,
name|inc
operator|->
name|st
operator|.
name|st_size
argument_list|,
comment|/* from_stage3 */
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|preprocessed
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fp
operator|->
name|inc
operator|=
name|inc
expr_stmt|;
name|fp
operator|->
name|inc
operator|->
name|refcnt
operator|++
expr_stmt|;
comment|/* Initialise controlling macro state.  */
name|pfile
operator|->
name|mi_valid
operator|=
name|true
expr_stmt|;
name|pfile
operator|->
name|mi_cmacro
operator|=
literal|0
expr_stmt|;
comment|/* Generate the call back.  */
name|filename
operator|=
name|inc
operator|->
name|name
expr_stmt|;
if|if
condition|(
operator|*
name|filename
operator|==
literal|'\0'
condition|)
name|filename
operator|=
literal|"<stdin>"
expr_stmt|;
name|_cpp_do_file_change
argument_list|(
name|pfile
argument_list|,
name|LC_ENTER
argument_list|,
name|filename
argument_list|,
literal|1
argument_list|,
name|sysp
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Read the file referenced by INC into the file cache.     If fd points to a plain file, we might be able to mmap it; we can    definitely allocate the buffer all at once.  If fd is a pipe or    terminal, we can't do either.  If fd is something weird, like a    block device, we don't want to read it at all.     Unfortunately, different systems use different st.st_mode values    for pipes: some have S_ISFIFO, some S_ISSOCK, some are buggy and    zero the entire struct stat except a couple fields.  Hence we don't    even try to figure out what something is, except for plain files    and block devices.     FIXME: Flush file cache and try again if we run out of memory.  */
end_comment

begin_function
specifier|static
name|int
name|read_include_file
parameter_list|(
name|pfile
parameter_list|,
name|inc
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|struct
name|include_file
modifier|*
name|inc
decl_stmt|;
block|{
name|ssize_t
name|size
decl_stmt|,
name|offset
decl_stmt|,
name|count
decl_stmt|;
name|U_CHAR
modifier|*
name|buf
decl_stmt|;
if|#
directive|if
name|MMAP_THRESHOLD
specifier|static
name|int
name|pagesize
init|=
operator|-
literal|1
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|S_ISREG
argument_list|(
name|inc
operator|->
name|st
operator|.
name|st_mode
argument_list|)
condition|)
block|{
comment|/* off_t might have a wider range than ssize_t - in other words, 	 the max size of a file might be bigger than the address 	 space.  We can't handle a file that large.  (Anyone with 	 a single source file bigger than 2GB needs to rethink 	 their coding style.)  Some systems (e.g. AIX 4.1) define 	 SSIZE_MAX to be much smaller than the actual range of the 	 type.  Use INTTYPE_MAXIMUM unconditionally to ensure this 	 does not bite us.  */
if|if
condition|(
name|inc
operator|->
name|st
operator|.
name|st_size
operator|>
name|INTTYPE_MAXIMUM
argument_list|(
name|ssize_t
argument_list|)
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"%s is too large"
argument_list|,
name|inc
operator|->
name|name
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|size
operator|=
name|inc
operator|->
name|st
operator|.
name|st_size
expr_stmt|;
name|inc
operator|->
name|mapped
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|MMAP_THRESHOLD
if|if
condition|(
name|pagesize
operator|==
operator|-
literal|1
condition|)
name|pagesize
operator|=
name|getpagesize
argument_list|()
expr_stmt|;
if|if
condition|(
name|SHOULD_MMAP
argument_list|(
name|size
argument_list|,
name|pagesize
argument_list|)
condition|)
block|{
name|buf
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|mmap
argument_list|(
literal|0
argument_list|,
name|size
argument_list|,
name|PROT_READ
argument_list|,
name|MAP_PRIVATE
argument_list|,
name|inc
operator|->
name|fd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
operator|(
name|U_CHAR
operator|*
operator|)
operator|-
literal|1
condition|)
goto|goto
name|perror_fail
goto|;
name|inc
operator|->
name|mapped
operator|=
literal|1
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|buf
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|xmalloc
argument_list|(
name|size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|offset
operator|<
name|size
condition|)
block|{
name|count
operator|=
name|read
argument_list|(
name|inc
operator|->
name|fd
argument_list|,
name|buf
operator|+
name|offset
argument_list|,
name|size
operator|-
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|<
literal|0
condition|)
goto|goto
name|perror_fail
goto|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|STAT_SIZE_TOO_BIG
argument_list|(
name|inc
operator|->
name|st
argument_list|)
condition|)
name|cpp_warning
argument_list|(
name|pfile
argument_list|,
literal|"%s is shorter than expected"
argument_list|,
name|inc
operator|->
name|name
argument_list|)
expr_stmt|;
name|size
operator|=
name|offset
expr_stmt|;
name|buf
operator|=
name|xrealloc
argument_list|(
name|buf
argument_list|,
name|size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|inc
operator|->
name|st
operator|.
name|st_size
operator|=
name|size
expr_stmt|;
break|break;
block|}
name|offset
operator|+=
name|count
expr_stmt|;
block|}
comment|/* The lexer requires that the buffer be NUL-terminated.  */
name|buf
index|[
name|size
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|S_ISBLK
argument_list|(
name|inc
operator|->
name|st
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"%s is a block device"
argument_list|,
name|inc
operator|->
name|name
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
else|else
block|{
comment|/* 8 kilobytes is a sensible starting size.  It ought to be 	 bigger than the kernel pipe buffer, and it's definitely 	 bigger than the majority of C source files.  */
name|size
operator|=
literal|8
operator|*
literal|1024
expr_stmt|;
name|buf
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|xmalloc
argument_list|(
name|size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|count
operator|=
name|read
argument_list|(
name|inc
operator|->
name|fd
argument_list|,
name|buf
operator|+
name|offset
argument_list|,
name|size
operator|-
name|offset
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|offset
operator|+=
name|count
expr_stmt|;
if|if
condition|(
name|offset
operator|==
name|size
condition|)
block|{
name|size
operator|*=
literal|2
expr_stmt|;
name|buf
operator|=
name|xrealloc
argument_list|(
name|buf
argument_list|,
name|size
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|count
operator|<
literal|0
condition|)
goto|goto
name|perror_fail
goto|;
if|if
condition|(
name|offset
operator|+
literal|1
operator|<
name|size
condition|)
name|buf
operator|=
name|xrealloc
argument_list|(
name|buf
argument_list|,
name|offset
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* The lexer requires that the buffer be NUL-terminated.  */
name|buf
index|[
name|offset
index|]
operator|=
literal|'\0'
expr_stmt|;
name|inc
operator|->
name|st
operator|.
name|st_size
operator|=
name|offset
expr_stmt|;
block|}
name|inc
operator|->
name|buffer
operator|=
name|buf
expr_stmt|;
return|return
literal|0
return|;
name|perror_fail
label|:
name|cpp_error_from_errno
argument_list|(
name|pfile
argument_list|,
name|inc
operator|->
name|name
argument_list|)
expr_stmt|;
name|fail
label|:
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Drop INC's buffer from memory, if we are unlikely to need it again.  */
end_comment

begin_function
specifier|static
name|void
name|purge_cache
parameter_list|(
name|inc
parameter_list|)
name|struct
name|include_file
modifier|*
name|inc
decl_stmt|;
block|{
if|if
condition|(
name|inc
operator|->
name|buffer
condition|)
block|{
if|#
directive|if
name|MMAP_THRESHOLD
if|if
condition|(
name|inc
operator|->
name|mapped
condition|)
name|munmap
argument_list|(
operator|(
name|PTR
operator|)
name|inc
operator|->
name|buffer
argument_list|,
name|inc
operator|->
name|st
operator|.
name|st_size
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|inc
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|inc
operator|->
name|buffer
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return 1 if the file named by FNAME has been included before in    any context, 0 otherwise.  */
end_comment

begin_function
name|int
name|cpp_included
parameter_list|(
name|pfile
parameter_list|,
name|fname
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
specifier|const
name|char
modifier|*
name|fname
decl_stmt|;
block|{
name|struct
name|search_path
modifier|*
name|path
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|n
decl_stmt|;
name|splay_tree_node
name|nd
decl_stmt|;
if|if
condition|(
name|IS_ABSOLUTE_PATHNAME
argument_list|(
name|fname
argument_list|)
condition|)
block|{
comment|/* Just look it up.  */
name|nd
operator|=
name|splay_tree_lookup
argument_list|(
name|pfile
operator|->
name|all_include_files
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|fname
argument_list|)
expr_stmt|;
return|return
operator|(
name|nd
operator|&&
name|nd
operator|->
name|value
operator|)
return|;
block|}
comment|/* Search directory path for the file.  */
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|fname
argument_list|)
operator|+
name|pfile
operator|->
name|max_include_len
operator|+
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
name|path
operator|=
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|quote_include
argument_list|)
init|;
name|path
condition|;
name|path
operator|=
name|path
operator|->
name|next
control|)
block|{
name|memcpy
argument_list|(
name|name
argument_list|,
name|path
operator|->
name|name
argument_list|,
name|path
operator|->
name|len
argument_list|)
expr_stmt|;
name|name
index|[
name|path
operator|->
name|len
index|]
operator|=
literal|'/'
expr_stmt|;
name|strcpy
argument_list|(
operator|&
name|name
index|[
name|path
operator|->
name|len
operator|+
literal|1
index|]
argument_list|,
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|remap
argument_list|)
condition|)
name|n
operator|=
name|remap_filename
argument_list|(
name|pfile
argument_list|,
name|name
argument_list|,
name|path
argument_list|)
expr_stmt|;
else|else
name|n
operator|=
name|name
expr_stmt|;
name|nd
operator|=
name|splay_tree_lookup
argument_list|(
name|pfile
operator|->
name|all_include_files
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|&&
name|nd
operator|->
name|value
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Search for HEADER.  Return 0 if there is no such file (or it's    un-openable), in which case an error code will be in errno.  If    there is no include path to use it returns NO_INCLUDE_PATH,    otherwise an include_file structure.  If this request originates    from a directive of TYPE #include_next, set INCLUDE_NEXT to true.  */
end_comment

begin_function
specifier|static
name|struct
name|include_file
modifier|*
name|find_include_file
parameter_list|(
name|pfile
parameter_list|,
name|header
parameter_list|,
name|type
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
specifier|const
name|cpp_token
modifier|*
name|header
decl_stmt|;
name|enum
name|include_type
name|type
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|fname
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|header
operator|->
name|val
operator|.
name|str
operator|.
name|text
decl_stmt|;
name|struct
name|search_path
modifier|*
name|path
decl_stmt|;
name|struct
name|include_file
modifier|*
name|file
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|n
decl_stmt|;
if|if
condition|(
name|IS_ABSOLUTE_PATHNAME
argument_list|(
name|fname
argument_list|)
condition|)
return|return
name|open_file
argument_list|(
name|pfile
argument_list|,
name|fname
argument_list|)
return|;
comment|/* For #include_next, skip in the search path past the dir in which      the current file was found, but if it was found via an absolute      path use the normal search logic.  */
if|if
condition|(
name|type
operator|==
name|IT_INCLUDE_NEXT
operator|&&
name|pfile
operator|->
name|buffer
operator|->
name|inc
operator|->
name|foundhere
condition|)
name|path
operator|=
name|pfile
operator|->
name|buffer
operator|->
name|inc
operator|->
name|foundhere
operator|->
name|next
expr_stmt|;
elseif|else
if|if
condition|(
name|header
operator|->
name|type
operator|==
name|CPP_HEADER_NAME
condition|)
name|path
operator|=
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|bracket_include
argument_list|)
expr_stmt|;
else|else
name|path
operator|=
name|search_from
argument_list|(
name|pfile
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
operator|==
name|NULL
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"no include path in which to find %s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
return|return
name|NO_INCLUDE_PATH
return|;
block|}
comment|/* Search directory path for the file.  */
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|fname
argument_list|)
operator|+
name|pfile
operator|->
name|max_include_len
operator|+
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|path
condition|;
name|path
operator|=
name|path
operator|->
name|next
control|)
block|{
name|int
name|len
init|=
name|path
operator|->
name|len
decl_stmt|;
name|memcpy
argument_list|(
name|name
argument_list|,
name|path
operator|->
name|name
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* Don't turn / into // or // into ///; // may be a namespace 	 escape.  */
if|if
condition|(
name|name
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'/'
condition|)
name|len
operator|--
expr_stmt|;
name|name
index|[
name|len
index|]
operator|=
literal|'/'
expr_stmt|;
name|strcpy
argument_list|(
operator|&
name|name
index|[
name|len
operator|+
literal|1
index|]
argument_list|,
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|remap
argument_list|)
condition|)
name|n
operator|=
name|remap_filename
argument_list|(
name|pfile
argument_list|,
name|name
argument_list|,
name|path
argument_list|)
expr_stmt|;
else|else
name|n
operator|=
name|name
expr_stmt|;
name|file
operator|=
name|open_file
argument_list|(
name|pfile
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
condition|)
block|{
name|file
operator|->
name|foundhere
operator|=
name|path
expr_stmt|;
return|return
name|file
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Not everyone who wants to set system-header-ness on a buffer can    see the details of a buffer.  This is an exported interface because    fix-header needs it.  */
end_comment

begin_function
name|void
name|cpp_make_system_header
parameter_list|(
name|pfile
parameter_list|,
name|syshdr
parameter_list|,
name|externc
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|int
name|syshdr
decl_stmt|,
name|externc
decl_stmt|;
block|{
name|int
name|flags
init|=
literal|0
decl_stmt|;
comment|/* 1 = system header, 2 = system header to be treated as C.  */
if|if
condition|(
name|syshdr
condition|)
name|flags
operator|=
literal|1
operator|+
operator|(
name|externc
operator|!=
literal|0
operator|)
expr_stmt|;
name|_cpp_do_file_change
argument_list|(
name|pfile
argument_list|,
name|LC_RENAME
argument_list|,
name|pfile
operator|->
name|map
operator|->
name|to_file
argument_list|,
name|SOURCE_LINE
argument_list|(
name|pfile
operator|->
name|map
argument_list|,
name|pfile
operator|->
name|line
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Report on all files that might benefit from a multiple include guard.    Triggered by -H.  */
end_comment

begin_function
name|void
name|_cpp_report_missing_guards
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
name|int
name|banner
init|=
literal|0
decl_stmt|;
name|splay_tree_foreach
argument_list|(
name|pfile
operator|->
name|all_include_files
argument_list|,
name|report_missing_guard
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|banner
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Callback function for splay_tree_foreach().  */
end_comment

begin_function
specifier|static
name|int
name|report_missing_guard
parameter_list|(
name|n
parameter_list|,
name|b
parameter_list|)
name|splay_tree_node
name|n
decl_stmt|;
name|void
modifier|*
name|b
decl_stmt|;
block|{
name|struct
name|include_file
modifier|*
name|f
init|=
operator|(
expr|struct
name|include_file
operator|*
operator|)
name|n
operator|->
name|value
decl_stmt|;
name|int
modifier|*
name|bannerp
init|=
operator|(
name|int
operator|*
operator|)
name|b
decl_stmt|;
if|if
condition|(
name|f
operator|&&
name|f
operator|->
name|cmacro
operator|==
literal|0
operator|&&
name|f
operator|->
name|include_count
operator|==
literal|1
condition|)
block|{
if|if
condition|(
operator|*
name|bannerp
operator|==
literal|0
condition|)
block|{
name|fputs
argument_list|(
name|_
argument_list|(
literal|"Multiple include guards may be useful for:\n"
argument_list|)
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
operator|*
name|bannerp
operator|=
literal|1
expr_stmt|;
block|}
name|fputs
argument_list|(
name|f
operator|->
name|name
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Create a dependency for file FNAME, or issue an error message as    appropriate.  ANGLE_BRACKETS is non-zero if the file was bracketed    like<..>.  */
end_comment

begin_function
specifier|static
name|void
name|handle_missing_header
parameter_list|(
name|pfile
parameter_list|,
name|fname
parameter_list|,
name|angle_brackets
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
specifier|const
name|char
modifier|*
name|fname
decl_stmt|;
name|int
name|angle_brackets
decl_stmt|;
block|{
name|int
name|print_dep
init|=
name|CPP_PRINT_DEPS
argument_list|(
name|pfile
argument_list|)
operator|>
operator|(
name|angle_brackets
operator|||
name|pfile
operator|->
name|map
operator|->
name|sysp
operator|)
decl_stmt|;
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|print_deps_missing_files
argument_list|)
operator|&&
name|print_dep
condition|)
block|{
if|if
condition|(
operator|!
name|angle_brackets
operator|||
name|IS_ABSOLUTE_PATHNAME
argument_list|(
name|fname
argument_list|)
condition|)
name|deps_add_dep
argument_list|(
name|pfile
operator|->
name|deps
argument_list|,
name|fname
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* If requested as a system header, assume it belongs in 	     the first system header directory.  */
name|struct
name|search_path
modifier|*
name|ptr
init|=
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|bracket_include
argument_list|)
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|len
init|=
literal|0
decl_stmt|,
name|fname_len
init|=
name|strlen
argument_list|(
name|fname
argument_list|)
decl_stmt|;
if|if
condition|(
name|ptr
condition|)
name|len
operator|=
name|ptr
operator|->
name|len
expr_stmt|;
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|len
operator|+
name|fname_len
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
condition|)
block|{
name|memcpy
argument_list|(
name|p
argument_list|,
name|ptr
operator|->
name|name
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|p
index|[
name|len
operator|++
index|]
operator|=
literal|'/'
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|p
operator|+
name|len
argument_list|,
name|fname
argument_list|,
name|fname_len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|deps_add_dep
argument_list|(
name|pfile
operator|->
name|deps
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If -M was specified, then don't count this as an error, because      we can still produce correct output.  Otherwise, we can't produce      correct output, because there may be dependencies we need inside      the missing file, and we don't know what directory this missing      file exists in.  FIXME: Use a future cpp_diagnostic_with_errno ()      for both of these cases.  */
elseif|else
if|if
condition|(
name|CPP_PRINT_DEPS
argument_list|(
name|pfile
argument_list|)
operator|&&
operator|!
name|print_dep
condition|)
name|cpp_warning
argument_list|(
name|pfile
argument_list|,
literal|"%s: %s"
argument_list|,
name|fname
argument_list|,
name|xstrerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|cpp_error_from_errno
argument_list|(
name|pfile
argument_list|,
name|fname
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handles #include-family directives (distinguished by TYPE),    including HEADER, and the command line -imacros and -include.    Returns true if a buffer was stacked.  */
end_comment

begin_function
name|bool
name|_cpp_execute_include
parameter_list|(
name|pfile
parameter_list|,
name|header
parameter_list|,
name|type
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
specifier|const
name|cpp_token
modifier|*
name|header
decl_stmt|;
name|enum
name|include_type
name|type
decl_stmt|;
block|{
name|bool
name|stacked
init|=
name|false
decl_stmt|;
name|struct
name|include_file
modifier|*
name|inc
init|=
name|find_include_file
argument_list|(
name|pfile
argument_list|,
name|header
argument_list|,
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|inc
operator|==
literal|0
condition|)
name|handle_missing_header
argument_list|(
name|pfile
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|header
operator|->
name|val
operator|.
name|str
operator|.
name|text
argument_list|,
name|header
operator|->
name|type
operator|==
name|CPP_HEADER_NAME
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|inc
operator|!=
name|NO_INCLUDE_PATH
condition|)
block|{
name|stacked
operator|=
name|stack_include_file
argument_list|(
name|pfile
argument_list|,
name|inc
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|IT_IMPORT
condition|)
name|_cpp_never_reread
argument_list|(
name|inc
argument_list|)
expr_stmt|;
block|}
return|return
name|stacked
return|;
block|}
end_function

begin_comment
comment|/* Locate HEADER, and determine whether it is newer than the current    file.  If it cannot be located or dated, return -1, if it is newer    newer, return 1, otherwise 0.  */
end_comment

begin_function
name|int
name|_cpp_compare_file_date
parameter_list|(
name|pfile
parameter_list|,
name|header
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
specifier|const
name|cpp_token
modifier|*
name|header
decl_stmt|;
block|{
name|struct
name|include_file
modifier|*
name|inc
init|=
name|find_include_file
argument_list|(
name|pfile
argument_list|,
name|header
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|inc
operator|==
name|NULL
operator|||
name|inc
operator|==
name|NO_INCLUDE_PATH
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|inc
operator|->
name|fd
operator|>
literal|0
condition|)
block|{
name|close
argument_list|(
name|inc
operator|->
name|fd
argument_list|)
expr_stmt|;
name|inc
operator|->
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
block|}
return|return
name|inc
operator|->
name|st
operator|.
name|st_mtime
operator|>
name|pfile
operator|->
name|buffer
operator|->
name|inc
operator|->
name|st
operator|.
name|st_mtime
return|;
block|}
end_function

begin_comment
comment|/* Push an input buffer and load it up with the contents of FNAME.  If    FNAME is "", read standard input.  Return true if a buffer was    stacked.  */
end_comment

begin_function
name|bool
name|_cpp_read_file
parameter_list|(
name|pfile
parameter_list|,
name|fname
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
specifier|const
name|char
modifier|*
name|fname
decl_stmt|;
block|{
name|struct
name|include_file
modifier|*
name|f
init|=
name|open_file
argument_list|(
name|pfile
argument_list|,
name|fname
argument_list|)
decl_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
name|cpp_error_from_errno
argument_list|(
name|pfile
argument_list|,
name|fname
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
return|return
name|stack_include_file
argument_list|(
name|pfile
argument_list|,
name|f
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Do appropriate cleanup when a file INC's buffer is popped off the    input stack.  Push the next -include file, if any remain.  */
end_comment

begin_function
name|bool
name|_cpp_pop_file_buffer
parameter_list|(
name|pfile
parameter_list|,
name|inc
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|struct
name|include_file
modifier|*
name|inc
decl_stmt|;
block|{
name|bool
name|pushed
init|=
name|false
decl_stmt|;
comment|/* Record the inclusion-preventing macro, which could be NULL      meaning no controlling macro.  */
if|if
condition|(
name|pfile
operator|->
name|mi_valid
operator|&&
name|inc
operator|->
name|cmacro
operator|==
name|NULL
condition|)
name|inc
operator|->
name|cmacro
operator|=
name|pfile
operator|->
name|mi_cmacro
expr_stmt|;
comment|/* Invalidate control macros in the #including file.  */
name|pfile
operator|->
name|mi_valid
operator|=
name|false
expr_stmt|;
name|inc
operator|->
name|refcnt
operator|--
expr_stmt|;
if|if
condition|(
name|inc
operator|->
name|refcnt
operator|==
literal|0
operator|&&
name|DO_NOT_REREAD
argument_list|(
name|inc
argument_list|)
condition|)
name|purge_cache
argument_list|(
name|inc
argument_list|)
expr_stmt|;
comment|/* Don't generate a callback for popping the main file.  */
if|if
condition|(
name|pfile
operator|->
name|buffer
condition|)
block|{
name|_cpp_do_file_change
argument_list|(
name|pfile
argument_list|,
name|LC_LEAVE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Finally, push the next -included file, if any.  */
if|if
condition|(
operator|!
name|pfile
operator|->
name|buffer
operator|->
name|prev
condition|)
name|pushed
operator|=
name|_cpp_push_next_buffer
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
block|}
return|return
name|pushed
return|;
block|}
end_function

begin_comment
comment|/* Returns the first place in the include chain to start searching for    "" includes.  This involves stripping away the basename of the    current file, unless -I- was specified.     If we're handling -include or -imacros, use the "" chain, but with    the preprocessor's cwd prepended.  */
end_comment

begin_function
specifier|static
name|struct
name|search_path
modifier|*
name|search_from
parameter_list|(
name|pfile
parameter_list|,
name|type
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|enum
name|include_type
name|type
decl_stmt|;
block|{
name|cpp_buffer
modifier|*
name|buffer
init|=
name|pfile
operator|->
name|buffer
decl_stmt|;
name|unsigned
name|int
name|dlen
decl_stmt|;
comment|/* Command line uses the cwd, and does not cache the result.  */
if|if
condition|(
name|type
operator|==
name|IT_CMDLINE
condition|)
goto|goto
name|use_cwd
goto|;
comment|/* Ignore the current file's directory if -I- was given.  */
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|ignore_srcdir
argument_list|)
condition|)
return|return
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|quote_include
argument_list|)
return|;
if|if
condition|(
operator|!
name|buffer
operator|->
name|search_cached
condition|)
block|{
name|buffer
operator|->
name|search_cached
operator|=
literal|1
expr_stmt|;
name|dlen
operator|=
name|lbasename
argument_list|(
name|buffer
operator|->
name|inc
operator|->
name|name
argument_list|)
operator|-
name|buffer
operator|->
name|inc
operator|->
name|name
expr_stmt|;
if|if
condition|(
name|dlen
condition|)
block|{
comment|/* We don't guarantee NAME is null-terminated.  This saves 	     allocating and freeing memory.  Drop a trailing '/'.  */
name|buffer
operator|->
name|dir
operator|.
name|name
operator|=
name|buffer
operator|->
name|inc
operator|->
name|name
expr_stmt|;
if|if
condition|(
name|dlen
operator|>
literal|1
condition|)
name|dlen
operator|--
expr_stmt|;
block|}
else|else
block|{
name|use_cwd
label|:
name|buffer
operator|->
name|dir
operator|.
name|name
operator|=
literal|"."
expr_stmt|;
name|dlen
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|dlen
operator|>
name|pfile
operator|->
name|max_include_len
condition|)
name|pfile
operator|->
name|max_include_len
operator|=
name|dlen
expr_stmt|;
name|buffer
operator|->
name|dir
operator|.
name|len
operator|=
name|dlen
expr_stmt|;
name|buffer
operator|->
name|dir
operator|.
name|next
operator|=
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|quote_include
argument_list|)
expr_stmt|;
name|buffer
operator|->
name|dir
operator|.
name|sysp
operator|=
name|pfile
operator|->
name|map
operator|->
name|sysp
expr_stmt|;
block|}
return|return
operator|&
name|buffer
operator|->
name|dir
return|;
block|}
end_function

begin_comment
comment|/* The file_name_map structure holds a mapping of file names for a    particular directory.  This mapping is read from the file named    FILE_NAME_MAP_FILE in that directory.  Such a file can be used to    map filenames on a file system with severe filename restrictions,    such as DOS.  The format of the file name map file is just a series    of lines with two tokens on each line.  The first token is the name    to map, and the second token is the actual name to use.  */
end_comment

begin_struct
struct|struct
name|file_name_map
block|{
name|struct
name|file_name_map
modifier|*
name|map_next
decl_stmt|;
name|char
modifier|*
name|map_from
decl_stmt|;
name|char
modifier|*
name|map_to
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|FILE_NAME_MAP_FILE
value|"header.gcc"
end_define

begin_comment
comment|/* Read a space delimited string of unlimited length from a stdio    file F.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|read_filename_string
parameter_list|(
name|ch
parameter_list|,
name|f
parameter_list|)
name|int
name|ch
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
block|{
name|char
modifier|*
name|alloc
decl_stmt|,
modifier|*
name|set
decl_stmt|;
name|int
name|len
decl_stmt|;
name|len
operator|=
literal|20
expr_stmt|;
name|set
operator|=
name|alloc
operator|=
name|xmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_space
argument_list|(
name|ch
argument_list|)
condition|)
block|{
operator|*
name|set
operator|++
operator|=
name|ch
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|getc
argument_list|(
name|f
argument_list|)
operator|)
operator|!=
name|EOF
operator|&&
operator|!
name|is_space
argument_list|(
name|ch
argument_list|)
condition|)
block|{
if|if
condition|(
name|set
operator|-
name|alloc
operator|==
name|len
condition|)
block|{
name|len
operator|*=
literal|2
expr_stmt|;
name|alloc
operator|=
name|xrealloc
argument_list|(
name|alloc
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|set
operator|=
name|alloc
operator|+
name|len
operator|/
literal|2
expr_stmt|;
block|}
operator|*
name|set
operator|++
operator|=
name|ch
expr_stmt|;
block|}
block|}
operator|*
name|set
operator|=
literal|'\0'
expr_stmt|;
name|ungetc
argument_list|(
name|ch
argument_list|,
name|f
argument_list|)
expr_stmt|;
return|return
name|alloc
return|;
block|}
end_function

begin_comment
comment|/* This structure holds a linked list of file name maps, one per directory.  */
end_comment

begin_struct
struct|struct
name|file_name_map_list
block|{
name|struct
name|file_name_map_list
modifier|*
name|map_list_next
decl_stmt|;
name|char
modifier|*
name|map_list_name
decl_stmt|;
name|struct
name|file_name_map
modifier|*
name|map_list_map
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Read the file name map file for DIRNAME.  */
end_comment

begin_function
specifier|static
name|struct
name|file_name_map
modifier|*
name|read_name_map
parameter_list|(
name|pfile
parameter_list|,
name|dirname
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
specifier|const
name|char
modifier|*
name|dirname
decl_stmt|;
block|{
name|struct
name|file_name_map_list
modifier|*
name|map_list_ptr
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
comment|/* Check the cache of directories, and mappings in their remap file.  */
for|for
control|(
name|map_list_ptr
operator|=
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|map_list
argument_list|)
init|;
name|map_list_ptr
condition|;
name|map_list_ptr
operator|=
name|map_list_ptr
operator|->
name|map_list_next
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|map_list_ptr
operator|->
name|map_list_name
argument_list|,
name|dirname
argument_list|)
condition|)
return|return
name|map_list_ptr
operator|->
name|map_list_map
return|;
name|map_list_ptr
operator|=
operator|(
operator|(
expr|struct
name|file_name_map_list
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|file_name_map_list
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|map_list_ptr
operator|->
name|map_list_name
operator|=
name|xstrdup
argument_list|(
name|dirname
argument_list|)
expr_stmt|;
comment|/* The end of the list ends in NULL.  */
name|map_list_ptr
operator|->
name|map_list_map
operator|=
name|NULL
expr_stmt|;
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|dirname
argument_list|)
operator|+
name|strlen
argument_list|(
name|FILE_NAME_MAP_FILE
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|name
argument_list|,
name|dirname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|dirname
condition|)
name|strcat
argument_list|(
name|name
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|name
argument_list|,
name|FILE_NAME_MAP_FILE
argument_list|)
expr_stmt|;
name|f
operator|=
name|fopen
argument_list|(
name|name
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
comment|/* Silently return NULL if we cannot open.  */
if|if
condition|(
name|f
condition|)
block|{
name|int
name|ch
decl_stmt|;
name|int
name|dirlen
init|=
name|strlen
argument_list|(
name|dirname
argument_list|)
decl_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|getc
argument_list|(
name|f
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
name|char
modifier|*
name|from
decl_stmt|,
modifier|*
name|to
decl_stmt|;
name|struct
name|file_name_map
modifier|*
name|ptr
decl_stmt|;
if|if
condition|(
name|is_space
argument_list|(
name|ch
argument_list|)
condition|)
continue|continue;
name|from
operator|=
name|read_filename_string
argument_list|(
name|ch
argument_list|,
name|f
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|getc
argument_list|(
name|f
argument_list|)
operator|)
operator|!=
name|EOF
operator|&&
name|is_hspace
argument_list|(
name|ch
argument_list|)
condition|)
empty_stmt|;
name|to
operator|=
name|read_filename_string
argument_list|(
name|ch
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|ptr
operator|=
operator|(
operator|(
expr|struct
name|file_name_map
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|file_name_map
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|ptr
operator|->
name|map_from
operator|=
name|from
expr_stmt|;
comment|/* Make the real filename absolute.  */
if|if
condition|(
name|IS_ABSOLUTE_PATHNAME
argument_list|(
name|to
argument_list|)
condition|)
name|ptr
operator|->
name|map_to
operator|=
name|to
expr_stmt|;
else|else
block|{
name|ptr
operator|->
name|map_to
operator|=
name|xmalloc
argument_list|(
name|dirlen
operator|+
name|strlen
argument_list|(
name|to
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|ptr
operator|->
name|map_to
argument_list|,
name|dirname
argument_list|)
expr_stmt|;
name|ptr
operator|->
name|map_to
index|[
name|dirlen
index|]
operator|=
literal|'/'
expr_stmt|;
name|strcpy
argument_list|(
name|ptr
operator|->
name|map_to
operator|+
name|dirlen
operator|+
literal|1
argument_list|,
name|to
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|to
argument_list|)
expr_stmt|;
block|}
name|ptr
operator|->
name|map_next
operator|=
name|map_list_ptr
operator|->
name|map_list_map
expr_stmt|;
name|map_list_ptr
operator|->
name|map_list_map
operator|=
name|ptr
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|getc
argument_list|(
name|f
argument_list|)
operator|)
operator|!=
literal|'\n'
condition|)
if|if
condition|(
name|ch
operator|==
name|EOF
condition|)
break|break;
block|}
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
comment|/* Add this information to the cache.  */
name|map_list_ptr
operator|->
name|map_list_next
operator|=
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|map_list
argument_list|)
expr_stmt|;
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|map_list
argument_list|)
operator|=
name|map_list_ptr
expr_stmt|;
return|return
name|map_list_ptr
operator|->
name|map_list_map
return|;
block|}
end_function

begin_comment
comment|/* Remap an unsimplified path NAME based on the file_name_map (if any)    for LOC.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|remap_filename
parameter_list|(
name|pfile
parameter_list|,
name|name
parameter_list|,
name|loc
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|search_path
modifier|*
name|loc
decl_stmt|;
block|{
name|struct
name|file_name_map
modifier|*
name|map
decl_stmt|;
specifier|const
name|char
modifier|*
name|from
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|dir
decl_stmt|;
if|if
condition|(
operator|!
name|loc
operator|->
name|name_map
condition|)
block|{
comment|/* Get a null-terminated path.  */
name|char
modifier|*
name|dname
init|=
name|alloca
argument_list|(
name|loc
operator|->
name|len
operator|+
literal|1
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|dname
argument_list|,
name|loc
operator|->
name|name
argument_list|,
name|loc
operator|->
name|len
argument_list|)
expr_stmt|;
name|dname
index|[
name|loc
operator|->
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|loc
operator|->
name|name_map
operator|=
name|read_name_map
argument_list|(
name|pfile
argument_list|,
name|dname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|loc
operator|->
name|name_map
condition|)
return|return
name|name
return|;
block|}
comment|/* This works since NAME has not been simplified yet.  */
name|from
operator|=
name|name
operator|+
name|loc
operator|->
name|len
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|map
operator|=
name|loc
operator|->
name|name_map
init|;
name|map
condition|;
name|map
operator|=
name|map
operator|->
name|map_next
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|map
operator|->
name|map_from
argument_list|,
name|from
argument_list|)
condition|)
return|return
name|map
operator|->
name|map_to
return|;
comment|/* Try to find a mapping file for the particular directory we are      looking in.  Thus #include<sys/types.h> will look up sys/types.h      in /usr/include/header.gcc and look up types.h in      /usr/include/sys/header.gcc.  */
name|p
operator|=
name|strrchr
argument_list|(
name|name
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
return|return
name|name
return|;
comment|/* We know p != name as absolute paths don't call remap_filename.  */
if|if
condition|(
name|p
operator|==
name|name
condition|)
name|cpp_ice
argument_list|(
name|pfile
argument_list|,
literal|"absolute file name in remap_filename"
argument_list|)
expr_stmt|;
name|dir
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|p
operator|-
name|name
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|dir
argument_list|,
name|name
argument_list|,
name|p
operator|-
name|name
argument_list|)
expr_stmt|;
name|dir
index|[
name|p
operator|-
name|name
index|]
operator|=
literal|'\0'
expr_stmt|;
name|from
operator|=
name|p
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|map
operator|=
name|read_name_map
argument_list|(
name|pfile
argument_list|,
name|dir
argument_list|)
init|;
name|map
condition|;
name|map
operator|=
name|map
operator|->
name|map_next
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|map
operator|->
name|map_from
argument_list|,
name|from
argument_list|)
condition|)
return|return
name|map
operator|->
name|map_to
return|;
return|return
name|name
return|;
block|}
end_function

begin_comment
comment|/* Returns true if it is safe to remove the final component of path,    when it is followed by a ".." component.  We use lstat to avoid    symlinks if we have it.  If not, we can still catch errors with    stat ().  */
end_comment

begin_function
specifier|static
name|int
name|remove_component_p
parameter_list|(
name|path
parameter_list|)
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
block|{
name|struct
name|stat
name|s
decl_stmt|;
name|int
name|result
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_LSTAT
name|result
operator|=
name|lstat
argument_list|(
name|path
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
else|#
directive|else
name|result
operator|=
name|stat
argument_list|(
name|path
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* There's no guarantee that errno will be unchanged, even on      success.  Cygwin's lstat(), for example, will often set errno to      ENOSYS.  In case of success, reset errno to zero.  */
if|if
condition|(
name|result
operator|==
literal|0
condition|)
name|errno
operator|=
literal|0
expr_stmt|;
return|return
name|result
operator|==
literal|0
operator|&&
name|S_ISDIR
argument_list|(
name|s
operator|.
name|st_mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Simplify a path name in place, deleting redundant components.  This    reduces OS overhead and guarantees that equivalent paths compare    the same (modulo symlinks).     Transforms made:    foo/bar/../quux	foo/quux    foo/./bar		foo/bar    foo//bar		foo/bar    /../quux		/quux    //quux		//quux  (POSIX allows leading // as a namespace escape)     Guarantees no trailing slashes.  All transforms reduce the length    of the string.  Returns PATH.  errno is 0 if no error occurred;    nonzero if an error occurred when using stat () or lstat ().  */
end_comment

begin_function
name|char
modifier|*
name|_cpp_simplify_pathname
parameter_list|(
name|path
parameter_list|)
name|char
modifier|*
name|path
decl_stmt|;
block|{
ifndef|#
directive|ifndef
name|VMS
name|char
modifier|*
name|from
decl_stmt|,
modifier|*
name|to
decl_stmt|;
name|char
modifier|*
name|base
decl_stmt|,
modifier|*
name|orig_base
decl_stmt|;
name|int
name|absolute
init|=
literal|0
decl_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
comment|/* Don't overflow the empty path by putting a '.' in it below.  */
if|if
condition|(
operator|*
name|path
operator|==
literal|'\0'
condition|)
return|return
name|path
return|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_DOS_BASED_FILE_SYSTEM
argument_list|)
comment|/* Convert all backslashes to slashes.  */
for|for
control|(
name|from
operator|=
name|path
init|;
operator|*
name|from
condition|;
name|from
operator|++
control|)
if|if
condition|(
operator|*
name|from
operator|==
literal|'\\'
condition|)
operator|*
name|from
operator|=
literal|'/'
expr_stmt|;
comment|/* Skip over leading drive letter if present.  */
if|if
condition|(
name|ISALPHA
argument_list|(
name|path
index|[
literal|0
index|]
argument_list|)
operator|&&
name|path
index|[
literal|1
index|]
operator|==
literal|':'
condition|)
name|from
operator|=
name|to
operator|=
operator|&
name|path
index|[
literal|2
index|]
expr_stmt|;
else|else
name|from
operator|=
name|to
operator|=
name|path
expr_stmt|;
else|#
directive|else
name|from
operator|=
name|to
operator|=
name|path
expr_stmt|;
endif|#
directive|endif
comment|/* Remove redundant leading /s.  */
if|if
condition|(
operator|*
name|from
operator|==
literal|'/'
condition|)
block|{
name|absolute
operator|=
literal|1
expr_stmt|;
name|to
operator|++
expr_stmt|;
name|from
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|from
operator|==
literal|'/'
condition|)
block|{
if|if
condition|(
operator|*
operator|++
name|from
operator|==
literal|'/'
condition|)
comment|/* 3 or more initial /s are equivalent to 1 /.  */
while|while
condition|(
operator|*
operator|++
name|from
operator|==
literal|'/'
condition|)
empty_stmt|;
else|else
comment|/* On some hosts // differs from /; Posix allows this.  */
name|to
operator|++
expr_stmt|;
block|}
block|}
name|base
operator|=
name|orig_base
operator|=
name|to
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|move_base
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|from
operator|==
literal|'/'
condition|)
name|from
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|from
operator|==
literal|'\0'
condition|)
break|break;
if|if
condition|(
operator|*
name|from
operator|==
literal|'.'
condition|)
block|{
if|if
condition|(
name|from
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
break|break;
if|if
condition|(
name|from
index|[
literal|1
index|]
operator|==
literal|'/'
condition|)
block|{
name|from
operator|+=
literal|2
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|from
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
operator|(
name|from
index|[
literal|2
index|]
operator|==
literal|'/'
operator|||
name|from
index|[
literal|2
index|]
operator|==
literal|'\0'
operator|)
condition|)
block|{
comment|/* Don't simplify if there was no previous component.  */
if|if
condition|(
name|absolute
operator|&&
name|orig_base
operator|==
name|to
condition|)
block|{
name|from
operator|+=
literal|2
expr_stmt|;
continue|continue;
block|}
comment|/* Don't simplify if the previous component was "../", 		 or if an error has already occurred with (l)stat.  */
if|if
condition|(
name|base
operator|!=
name|to
operator|&&
name|errno
operator|==
literal|0
condition|)
block|{
comment|/* We don't back up if it's a symlink.  */
operator|*
name|to
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|remove_component_p
argument_list|(
name|path
argument_list|)
condition|)
block|{
while|while
condition|(
name|to
operator|>
name|base
operator|&&
operator|*
name|to
operator|!=
literal|'/'
condition|)
name|to
operator|--
expr_stmt|;
name|from
operator|+=
literal|2
expr_stmt|;
continue|continue;
block|}
block|}
name|move_base
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* Add the component separator.  */
if|if
condition|(
name|to
operator|>
name|orig_base
condition|)
operator|*
name|to
operator|++
operator|=
literal|'/'
expr_stmt|;
comment|/* Copy this component until the trailing null or '/'.  */
while|while
condition|(
operator|*
name|from
operator|!=
literal|'\0'
operator|&&
operator|*
name|from
operator|!=
literal|'/'
condition|)
operator|*
name|to
operator|++
operator|=
operator|*
name|from
operator|++
expr_stmt|;
if|if
condition|(
name|move_base
condition|)
name|base
operator|=
name|to
expr_stmt|;
block|}
comment|/* Change the empty string to "." so that it is not treated as stdin.      Null terminate.  */
if|if
condition|(
name|to
operator|==
name|path
condition|)
operator|*
name|to
operator|++
operator|=
literal|'.'
expr_stmt|;
operator|*
name|to
operator|=
literal|'\0'
expr_stmt|;
return|return
name|path
return|;
else|#
directive|else
comment|/* VMS  */
name|errno
operator|=
literal|0
expr_stmt|;
return|return
name|path
return|;
endif|#
directive|endif
comment|/* !VMS  */
block|}
end_function

end_unit

