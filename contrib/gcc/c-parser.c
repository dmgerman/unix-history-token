begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Parser for C and Objective-C.    Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.     Parser actions based on the old Bison parser; structure somewhat    influenced by and fragments based on the C++ parser.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* TODO:     Make sure all relevant comments, and all relevant code from all    actions, brought over from old parser.  Verify exact correspondence    of syntax accepted.     Add testcases covering every input symbol in every state in old and    new parsers.     Include full syntax for GNU C, including erroneous cases accepted    with error messages, in syntax productions in comments.     Make more diagnostics in the front end generally take an explicit    location rather than implicitly using input_location.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_include
include|#
directive|include
file|"input.h"
end_include

begin_include
include|#
directive|include
file|"cpplib.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"c-pragma.h"
end_include

begin_include
include|#
directive|include
file|"c-tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"c-common.h"
end_include

begin_include
include|#
directive|include
file|"vec.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"cgraph.h"
end_include

begin_escape
end_escape

begin_comment
comment|/* Miscellaneous data and functions needed for the parser.  */
end_comment

begin_decl_stmt
name|int
name|yydebug
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Objective-C specific parser/lexer information.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|objc_pq_context
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The following flag is needed to contextualize Objective-C lexical    analysis.  In some cases (e.g., 'int NSObject;'), it is undesirable    to bind an identifier to an Objective-C class, even if a class with    that name exists.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|objc_need_raw_identifier
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|OBJC_NEED_RAW_IDENTIFIER
parameter_list|(
name|VAL
parameter_list|)
define|\
value|do {						\     if (c_dialect_objc ())			\       objc_need_raw_identifier = VAL;		\   } while (0)
end_define

begin_comment
comment|/* The reserved keyword table.  */
end_comment

begin_struct
struct|struct
name|resword
block|{
specifier|const
name|char
modifier|*
name|word
decl_stmt|;
name|ENUM_BITFIELD
argument_list|(
argument|rid
argument_list|)
name|rid
label|:
literal|16
expr_stmt|;
name|unsigned
name|int
name|disable
range|:
literal|16
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Disable mask.  Keywords are disabled if (reswords[i].disable&    mask) is _true_.  */
end_comment

begin_define
define|#
directive|define
name|D_C89
value|0x01
end_define

begin_comment
comment|/* not in C89 */
end_comment

begin_define
define|#
directive|define
name|D_EXT
value|0x02
end_define

begin_comment
comment|/* GCC extension */
end_comment

begin_define
define|#
directive|define
name|D_EXT89
value|0x04
end_define

begin_comment
comment|/* GCC extension incorporated in C99 */
end_comment

begin_define
define|#
directive|define
name|D_OBJC
value|0x08
end_define

begin_comment
comment|/* Objective C only */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|resword
name|reswords
index|[]
init|=
block|{
block|{
literal|"_Bool"
block|,
name|RID_BOOL
block|,
literal|0
block|}
block|,
block|{
literal|"_Complex"
block|,
name|RID_COMPLEX
block|,
literal|0
block|}
block|,
block|{
literal|"_Decimal32"
block|,
name|RID_DFLOAT32
block|,
name|D_EXT
block|}
block|,
block|{
literal|"_Decimal64"
block|,
name|RID_DFLOAT64
block|,
name|D_EXT
block|}
block|,
block|{
literal|"_Decimal128"
block|,
name|RID_DFLOAT128
block|,
name|D_EXT
block|}
block|,
block|{
literal|"__FUNCTION__"
block|,
name|RID_FUNCTION_NAME
block|,
literal|0
block|}
block|,
block|{
literal|"__PRETTY_FUNCTION__"
block|,
name|RID_PRETTY_FUNCTION_NAME
block|,
literal|0
block|}
block|,
block|{
literal|"__alignof"
block|,
name|RID_ALIGNOF
block|,
literal|0
block|}
block|,
block|{
literal|"__alignof__"
block|,
name|RID_ALIGNOF
block|,
literal|0
block|}
block|,
block|{
literal|"__asm"
block|,
name|RID_ASM
block|,
literal|0
block|}
block|,
block|{
literal|"__asm__"
block|,
name|RID_ASM
block|,
literal|0
block|}
block|,
block|{
literal|"__attribute"
block|,
name|RID_ATTRIBUTE
block|,
literal|0
block|}
block|,
block|{
literal|"__attribute__"
block|,
name|RID_ATTRIBUTE
block|,
literal|0
block|}
block|,
block|{
literal|"__builtin_choose_expr"
block|,
name|RID_CHOOSE_EXPR
block|,
literal|0
block|}
block|,
block|{
literal|"__builtin_offsetof"
block|,
name|RID_OFFSETOF
block|,
literal|0
block|}
block|,
block|{
literal|"__builtin_types_compatible_p"
block|,
name|RID_TYPES_COMPATIBLE_P
block|,
literal|0
block|}
block|,
block|{
literal|"__builtin_va_arg"
block|,
name|RID_VA_ARG
block|,
literal|0
block|}
block|,
block|{
literal|"__complex"
block|,
name|RID_COMPLEX
block|,
literal|0
block|}
block|,
block|{
literal|"__complex__"
block|,
name|RID_COMPLEX
block|,
literal|0
block|}
block|,
block|{
literal|"__const"
block|,
name|RID_CONST
block|,
literal|0
block|}
block|,
block|{
literal|"__const__"
block|,
name|RID_CONST
block|,
literal|0
block|}
block|,
block|{
literal|"__extension__"
block|,
name|RID_EXTENSION
block|,
literal|0
block|}
block|,
block|{
literal|"__func__"
block|,
name|RID_C99_FUNCTION_NAME
block|,
literal|0
block|}
block|,
block|{
literal|"__imag"
block|,
name|RID_IMAGPART
block|,
literal|0
block|}
block|,
block|{
literal|"__imag__"
block|,
name|RID_IMAGPART
block|,
literal|0
block|}
block|,
block|{
literal|"__inline"
block|,
name|RID_INLINE
block|,
literal|0
block|}
block|,
block|{
literal|"__inline__"
block|,
name|RID_INLINE
block|,
literal|0
block|}
block|,
block|{
literal|"__label__"
block|,
name|RID_LABEL
block|,
literal|0
block|}
block|,
block|{
literal|"__real"
block|,
name|RID_REALPART
block|,
literal|0
block|}
block|,
block|{
literal|"__real__"
block|,
name|RID_REALPART
block|,
literal|0
block|}
block|,
block|{
literal|"__restrict"
block|,
name|RID_RESTRICT
block|,
literal|0
block|}
block|,
block|{
literal|"__restrict__"
block|,
name|RID_RESTRICT
block|,
literal|0
block|}
block|,
block|{
literal|"__signed"
block|,
name|RID_SIGNED
block|,
literal|0
block|}
block|,
block|{
literal|"__signed__"
block|,
name|RID_SIGNED
block|,
literal|0
block|}
block|,
block|{
literal|"__thread"
block|,
name|RID_THREAD
block|,
literal|0
block|}
block|,
block|{
literal|"__typeof"
block|,
name|RID_TYPEOF
block|,
literal|0
block|}
block|,
block|{
literal|"__typeof__"
block|,
name|RID_TYPEOF
block|,
literal|0
block|}
block|,
block|{
literal|"__volatile"
block|,
name|RID_VOLATILE
block|,
literal|0
block|}
block|,
block|{
literal|"__volatile__"
block|,
name|RID_VOLATILE
block|,
literal|0
block|}
block|,
block|{
literal|"asm"
block|,
name|RID_ASM
block|,
name|D_EXT
block|}
block|,
block|{
literal|"auto"
block|,
name|RID_AUTO
block|,
literal|0
block|}
block|,
block|{
literal|"break"
block|,
name|RID_BREAK
block|,
literal|0
block|}
block|,
block|{
literal|"case"
block|,
name|RID_CASE
block|,
literal|0
block|}
block|,
block|{
literal|"char"
block|,
name|RID_CHAR
block|,
literal|0
block|}
block|,
block|{
literal|"const"
block|,
name|RID_CONST
block|,
literal|0
block|}
block|,
block|{
literal|"continue"
block|,
name|RID_CONTINUE
block|,
literal|0
block|}
block|,
block|{
literal|"default"
block|,
name|RID_DEFAULT
block|,
literal|0
block|}
block|,
block|{
literal|"do"
block|,
name|RID_DO
block|,
literal|0
block|}
block|,
block|{
literal|"double"
block|,
name|RID_DOUBLE
block|,
literal|0
block|}
block|,
block|{
literal|"else"
block|,
name|RID_ELSE
block|,
literal|0
block|}
block|,
block|{
literal|"enum"
block|,
name|RID_ENUM
block|,
literal|0
block|}
block|,
block|{
literal|"extern"
block|,
name|RID_EXTERN
block|,
literal|0
block|}
block|,
block|{
literal|"float"
block|,
name|RID_FLOAT
block|,
literal|0
block|}
block|,
block|{
literal|"for"
block|,
name|RID_FOR
block|,
literal|0
block|}
block|,
block|{
literal|"goto"
block|,
name|RID_GOTO
block|,
literal|0
block|}
block|,
block|{
literal|"if"
block|,
name|RID_IF
block|,
literal|0
block|}
block|,
block|{
literal|"inline"
block|,
name|RID_INLINE
block|,
name|D_EXT89
block|}
block|,
block|{
literal|"int"
block|,
name|RID_INT
block|,
literal|0
block|}
block|,
block|{
literal|"long"
block|,
name|RID_LONG
block|,
literal|0
block|}
block|,
block|{
literal|"register"
block|,
name|RID_REGISTER
block|,
literal|0
block|}
block|,
block|{
literal|"restrict"
block|,
name|RID_RESTRICT
block|,
name|D_C89
block|}
block|,
block|{
literal|"return"
block|,
name|RID_RETURN
block|,
literal|0
block|}
block|,
block|{
literal|"short"
block|,
name|RID_SHORT
block|,
literal|0
block|}
block|,
block|{
literal|"signed"
block|,
name|RID_SIGNED
block|,
literal|0
block|}
block|,
block|{
literal|"sizeof"
block|,
name|RID_SIZEOF
block|,
literal|0
block|}
block|,
block|{
literal|"static"
block|,
name|RID_STATIC
block|,
literal|0
block|}
block|,
block|{
literal|"struct"
block|,
name|RID_STRUCT
block|,
literal|0
block|}
block|,
block|{
literal|"switch"
block|,
name|RID_SWITCH
block|,
literal|0
block|}
block|,
block|{
literal|"typedef"
block|,
name|RID_TYPEDEF
block|,
literal|0
block|}
block|,
block|{
literal|"typeof"
block|,
name|RID_TYPEOF
block|,
name|D_EXT
block|}
block|,
block|{
literal|"union"
block|,
name|RID_UNION
block|,
literal|0
block|}
block|,
block|{
literal|"unsigned"
block|,
name|RID_UNSIGNED
block|,
literal|0
block|}
block|,
block|{
literal|"void"
block|,
name|RID_VOID
block|,
literal|0
block|}
block|,
block|{
literal|"volatile"
block|,
name|RID_VOLATILE
block|,
literal|0
block|}
block|,
block|{
literal|"while"
block|,
name|RID_WHILE
block|,
literal|0
block|}
block|,
comment|/* These Objective-C keywords are recognized only immediately after      an '@'.  */
block|{
literal|"class"
block|,
name|RID_AT_CLASS
block|,
name|D_OBJC
block|}
block|,
block|{
literal|"compatibility_alias"
block|,
name|RID_AT_ALIAS
block|,
name|D_OBJC
block|}
block|,
block|{
literal|"defs"
block|,
name|RID_AT_DEFS
block|,
name|D_OBJC
block|}
block|,
block|{
literal|"encode"
block|,
name|RID_AT_ENCODE
block|,
name|D_OBJC
block|}
block|,
block|{
literal|"end"
block|,
name|RID_AT_END
block|,
name|D_OBJC
block|}
block|,
block|{
literal|"implementation"
block|,
name|RID_AT_IMPLEMENTATION
block|,
name|D_OBJC
block|}
block|,
block|{
literal|"interface"
block|,
name|RID_AT_INTERFACE
block|,
name|D_OBJC
block|}
block|,
block|{
literal|"private"
block|,
name|RID_AT_PRIVATE
block|,
name|D_OBJC
block|}
block|,
block|{
literal|"protected"
block|,
name|RID_AT_PROTECTED
block|,
name|D_OBJC
block|}
block|,
block|{
literal|"protocol"
block|,
name|RID_AT_PROTOCOL
block|,
name|D_OBJC
block|}
block|,
block|{
literal|"public"
block|,
name|RID_AT_PUBLIC
block|,
name|D_OBJC
block|}
block|,
block|{
literal|"selector"
block|,
name|RID_AT_SELECTOR
block|,
name|D_OBJC
block|}
block|,
block|{
literal|"throw"
block|,
name|RID_AT_THROW
block|,
name|D_OBJC
block|}
block|,
block|{
literal|"try"
block|,
name|RID_AT_TRY
block|,
name|D_OBJC
block|}
block|,
block|{
literal|"catch"
block|,
name|RID_AT_CATCH
block|,
name|D_OBJC
block|}
block|,
block|{
literal|"finally"
block|,
name|RID_AT_FINALLY
block|,
name|D_OBJC
block|}
block|,
block|{
literal|"synchronized"
block|,
name|RID_AT_SYNCHRONIZED
block|,
name|D_OBJC
block|}
block|,
comment|/* These are recognized only in protocol-qualifier context      (see above) */
block|{
literal|"bycopy"
block|,
name|RID_BYCOPY
block|,
name|D_OBJC
block|}
block|,
block|{
literal|"byref"
block|,
name|RID_BYREF
block|,
name|D_OBJC
block|}
block|,
block|{
literal|"in"
block|,
name|RID_IN
block|,
name|D_OBJC
block|}
block|,
block|{
literal|"inout"
block|,
name|RID_INOUT
block|,
name|D_OBJC
block|}
block|,
block|{
literal|"oneway"
block|,
name|RID_ONEWAY
block|,
name|D_OBJC
block|}
block|,
block|{
literal|"out"
block|,
name|RID_OUT
block|,
name|D_OBJC
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|N_reswords
value|(sizeof reswords / sizeof (struct resword))
end_define

begin_comment
comment|/* All OpenMP clauses.  OpenMP 2.5.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
name|pragma_omp_clause
block|{
name|PRAGMA_OMP_CLAUSE_NONE
init|=
literal|0
block|,
name|PRAGMA_OMP_CLAUSE_COPYIN
block|,
name|PRAGMA_OMP_CLAUSE_COPYPRIVATE
block|,
name|PRAGMA_OMP_CLAUSE_DEFAULT
block|,
name|PRAGMA_OMP_CLAUSE_FIRSTPRIVATE
block|,
name|PRAGMA_OMP_CLAUSE_IF
block|,
name|PRAGMA_OMP_CLAUSE_LASTPRIVATE
block|,
name|PRAGMA_OMP_CLAUSE_NOWAIT
block|,
name|PRAGMA_OMP_CLAUSE_NUM_THREADS
block|,
name|PRAGMA_OMP_CLAUSE_ORDERED
block|,
name|PRAGMA_OMP_CLAUSE_PRIVATE
block|,
name|PRAGMA_OMP_CLAUSE_REDUCTION
block|,
name|PRAGMA_OMP_CLAUSE_SCHEDULE
block|,
name|PRAGMA_OMP_CLAUSE_SHARED
block|}
name|pragma_omp_clause
typedef|;
end_typedef

begin_comment
comment|/* Initialization routine for this file.  */
end_comment

begin_function
name|void
name|c_parse_init
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* The only initialization required is of the reserved word      identifiers.  */
name|unsigned
name|int
name|i
decl_stmt|;
name|tree
name|id
decl_stmt|;
name|int
name|mask
init|=
operator|(
name|flag_isoc99
condition|?
literal|0
else|:
name|D_C89
operator|)
operator||
operator|(
name|flag_no_asm
condition|?
operator|(
name|flag_isoc99
condition|?
name|D_EXT
else|:
name|D_EXT
operator||
name|D_EXT89
operator|)
else|:
literal|0
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|c_dialect_objc
argument_list|()
condition|)
name|mask
operator||=
name|D_OBJC
expr_stmt|;
name|ridpointers
operator|=
name|GGC_CNEWVEC
argument_list|(
name|tree
argument_list|,
operator|(
name|int
operator|)
name|RID_MAX
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N_reswords
condition|;
name|i
operator|++
control|)
block|{
comment|/* If a keyword is disabled, do not enter it into the table 	 and so create a canonical spelling that isn't a keyword.  */
if|if
condition|(
name|reswords
index|[
name|i
index|]
operator|.
name|disable
operator|&
name|mask
condition|)
continue|continue;
name|id
operator|=
name|get_identifier
argument_list|(
name|reswords
index|[
name|i
index|]
operator|.
name|word
argument_list|)
expr_stmt|;
name|C_RID_CODE
argument_list|(
name|id
argument_list|)
operator|=
name|reswords
index|[
name|i
index|]
operator|.
name|rid
expr_stmt|;
name|C_IS_RESERVED_WORD
argument_list|(
name|id
argument_list|)
operator|=
literal|1
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|reswords
index|[
name|i
index|]
operator|.
name|rid
index|]
operator|=
name|id
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The C lexer intermediates between the lexer in cpplib and c-lex.c    and the C parser.  Unlike the C++ lexer, the parser structure    stores the lexer information instead of using a separate structure.    Identifiers are separated into ordinary identifiers, type names,    keywords and some other Objective-C types of identifiers, and some    look-ahead is maintained.     ??? It might be a good idea to lex the whole file up front (as for    C++).  It would then be possible to share more of the C and C++    lexer code, if desired.  */
end_comment

begin_comment
comment|/* The following local token type is used.  */
end_comment

begin_comment
comment|/* A keyword.  */
end_comment

begin_define
define|#
directive|define
name|CPP_KEYWORD
value|((enum cpp_ttype) (N_TTYPES + 1))
end_define

begin_comment
comment|/* More information about the type of a CPP_NAME token.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
name|c_id_kind
block|{
comment|/* An ordinary identifier.  */
name|C_ID_ID
block|,
comment|/* An identifier declared as a typedef name.  */
name|C_ID_TYPENAME
block|,
comment|/* An identifier declared as an Objective-C class name.  */
name|C_ID_CLASSNAME
block|,
comment|/* Not an identifier.  */
name|C_ID_NONE
block|}
name|c_id_kind
typedef|;
end_typedef

begin_comment
comment|/* A single C token after string literal concatenation and conversion    of preprocessing tokens to tokens.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|c_token
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
block|{
comment|/* The kind of token.  */
name|ENUM_BITFIELD
argument_list|(
argument|cpp_ttype
argument_list|)
name|type
label|:
literal|8
expr_stmt|;
comment|/* If this token is a CPP_NAME, this value indicates whether also      declared as some kind of type.  Otherwise, it is C_ID_NONE.  */
name|ENUM_BITFIELD
argument_list|(
argument|c_id_kind
argument_list|)
name|id_kind
label|:
literal|8
expr_stmt|;
comment|/* If this token is a keyword, this value indicates which keyword.      Otherwise, this value is RID_MAX.  */
name|ENUM_BITFIELD
argument_list|(
argument|rid
argument_list|)
name|keyword
label|:
literal|8
expr_stmt|;
comment|/* If this token is a CPP_PRAGMA, this indicates the pragma that      was seen.  Otherwise it is PRAGMA_NONE.  */
name|ENUM_BITFIELD
argument_list|(
argument|pragma_kind
argument_list|)
name|pragma_kind
label|:
literal|7
expr_stmt|;
comment|/* True if this token is from a system header.  */
name|BOOL_BITFIELD
name|in_system_header
range|:
literal|1
block|;
comment|/* The value associated with this token, if any.  */
name|tree
name|value
block|;
comment|/* The location at which this token was found.  */
name|location_t
name|location
block|; }
end_typedef

begin_expr_stmt
name|c_token
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* A parser structure recording information about the state and    context of parsing.  Includes lexer information with up to two    tokens of look-ahead; more are not needed for C.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|c_parser
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
block|{
comment|/* The look-ahead tokens.  */
name|c_token
name|tokens
index|[
literal|2
index|]
block|;
comment|/* How many look-ahead tokens are available (0, 1 or 2).  */
name|short
name|tokens_avail
block|;
comment|/* True if a syntax error is being recovered from; false otherwise.      c_parser_error sets this flag.  It should clear this flag when      enough tokens have been consumed to recover from the error.  */
name|BOOL_BITFIELD
name|error
range|:
literal|1
block|;
comment|/* True if we're processing a pragma, and shouldn't automatically      consume CPP_PRAGMA_EOL.  */
name|BOOL_BITFIELD
name|in_pragma
range|:
literal|1
block|; }
end_typedef

begin_expr_stmt
name|c_parser
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* The actual parser and external interface.  ??? Does this need to be    garbage-collected?  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|c_parser
operator|*
name|the_parser
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Read in and lex a single token, storing it in *TOKEN.  */
end_comment

begin_function
specifier|static
name|void
name|c_lex_one_token
parameter_list|(
name|c_token
modifier|*
name|token
parameter_list|)
block|{
name|timevar_push
argument_list|(
name|TV_LEX
argument_list|)
expr_stmt|;
name|token
operator|->
name|type
operator|=
name|c_lex_with_flags
argument_list|(
operator|&
name|token
operator|->
name|value
argument_list|,
operator|&
name|token
operator|->
name|location
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|token
operator|->
name|id_kind
operator|=
name|C_ID_NONE
expr_stmt|;
name|token
operator|->
name|keyword
operator|=
name|RID_MAX
expr_stmt|;
name|token
operator|->
name|pragma_kind
operator|=
name|PRAGMA_NONE
expr_stmt|;
name|token
operator|->
name|in_system_header
operator|=
name|in_system_header
expr_stmt|;
switch|switch
condition|(
name|token
operator|->
name|type
condition|)
block|{
case|case
name|CPP_NAME
case|:
block|{
name|tree
name|decl
decl_stmt|;
name|int
name|objc_force_identifier
init|=
name|objc_need_raw_identifier
decl_stmt|;
name|OBJC_NEED_RAW_IDENTIFIER
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|C_IS_RESERVED_WORD
argument_list|(
name|token
operator|->
name|value
argument_list|)
condition|)
block|{
name|enum
name|rid
name|rid_code
init|=
name|C_RID_CODE
argument_list|(
name|token
operator|->
name|value
argument_list|)
decl_stmt|;
if|if
condition|(
name|c_dialect_objc
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|OBJC_IS_AT_KEYWORD
argument_list|(
name|rid_code
argument_list|)
operator|&&
operator|(
operator|!
name|OBJC_IS_PQ_KEYWORD
argument_list|(
name|rid_code
argument_list|)
operator|||
name|objc_pq_context
operator|)
condition|)
block|{
comment|/* Return the canonical spelling for this keyword.  */
name|token
operator|->
name|value
operator|=
name|ridpointers
index|[
operator|(
name|int
operator|)
name|rid_code
index|]
expr_stmt|;
name|token
operator|->
name|type
operator|=
name|CPP_KEYWORD
expr_stmt|;
name|token
operator|->
name|keyword
operator|=
name|rid_code
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
comment|/* Return the canonical spelling for this keyword.  */
name|token
operator|->
name|value
operator|=
name|ridpointers
index|[
operator|(
name|int
operator|)
name|rid_code
index|]
expr_stmt|;
name|token
operator|->
name|type
operator|=
name|CPP_KEYWORD
expr_stmt|;
name|token
operator|->
name|keyword
operator|=
name|rid_code
expr_stmt|;
break|break;
block|}
block|}
name|decl
operator|=
name|lookup_name
argument_list|(
name|token
operator|->
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
name|token
operator|->
name|id_kind
operator|=
name|C_ID_TYPENAME
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|c_dialect_objc
argument_list|()
condition|)
block|{
name|tree
name|objc_interface_decl
init|=
name|objc_is_class_name
argument_list|(
name|token
operator|->
name|value
argument_list|)
decl_stmt|;
comment|/* Objective-C class names are in the same namespace as 	       variables and typedefs, and hence are shadowed by local 	       declarations.  */
if|if
condition|(
name|objc_interface_decl
operator|&&
operator|(
name|global_bindings_p
argument_list|()
operator|||
operator|(
operator|!
name|objc_force_identifier
operator|&&
operator|!
name|decl
operator|)
operator|)
condition|)
block|{
name|token
operator|->
name|value
operator|=
name|objc_interface_decl
expr_stmt|;
name|token
operator|->
name|id_kind
operator|=
name|C_ID_CLASSNAME
expr_stmt|;
break|break;
block|}
block|}
name|token
operator|->
name|id_kind
operator|=
name|C_ID_ID
expr_stmt|;
block|}
break|break;
case|case
name|CPP_AT_NAME
case|:
comment|/* This only happens in Objective-C; it must be a keyword.  */
name|token
operator|->
name|type
operator|=
name|CPP_KEYWORD
expr_stmt|;
name|token
operator|->
name|keyword
operator|=
name|C_RID_CODE
argument_list|(
name|token
operator|->
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_COLON
case|:
case|case
name|CPP_COMMA
case|:
case|case
name|CPP_CLOSE_PAREN
case|:
case|case
name|CPP_SEMICOLON
case|:
comment|/* These tokens may affect the interpretation of any identifiers 	 following, if doing Objective-C.  */
name|OBJC_NEED_RAW_IDENTIFIER
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_PRAGMA
case|:
comment|/* We smuggled the cpp_token->u.pragma value in an INTEGER_CST.  */
name|token
operator|->
name|pragma_kind
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|token
operator|->
name|value
argument_list|)
expr_stmt|;
name|token
operator|->
name|value
operator|=
name|NULL
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|timevar_pop
argument_list|(
name|TV_LEX
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return a pointer to the next token from PARSER, reading it in if    necessary.  */
end_comment

begin_function
specifier|static
specifier|inline
name|c_token
modifier|*
name|c_parser_peek_token
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|)
block|{
if|if
condition|(
name|parser
operator|->
name|tokens_avail
operator|==
literal|0
condition|)
block|{
name|c_lex_one_token
argument_list|(
operator|&
name|parser
operator|->
name|tokens
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|parser
operator|->
name|tokens_avail
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|&
name|parser
operator|->
name|tokens
index|[
literal|0
index|]
return|;
block|}
end_function

begin_comment
comment|/* Return true if the next token from PARSER has the indicated    TYPE.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|c_parser_next_token_is
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|,
name|enum
name|cpp_ttype
name|type
parameter_list|)
block|{
return|return
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
operator|->
name|type
operator|==
name|type
return|;
block|}
end_function

begin_comment
comment|/* Return true if the next token from PARSER does not have the    indicated TYPE.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|c_parser_next_token_is_not
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|,
name|enum
name|cpp_ttype
name|type
parameter_list|)
block|{
return|return
operator|!
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|type
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if the next token from PARSER is the indicated    KEYWORD.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|c_parser_next_token_is_keyword
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|,
name|enum
name|rid
name|keyword
parameter_list|)
block|{
name|c_token
modifier|*
name|token
decl_stmt|;
comment|/* Peek at the next token.  */
name|token
operator|=
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Check to see if it is the indicated keyword.  */
return|return
name|token
operator|->
name|keyword
operator|==
name|keyword
return|;
block|}
end_function

begin_comment
comment|/* Return true if TOKEN can start a type name,    false otherwise.  */
end_comment

begin_function
specifier|static
name|bool
name|c_token_starts_typename
parameter_list|(
name|c_token
modifier|*
name|token
parameter_list|)
block|{
switch|switch
condition|(
name|token
operator|->
name|type
condition|)
block|{
case|case
name|CPP_NAME
case|:
switch|switch
condition|(
name|token
operator|->
name|id_kind
condition|)
block|{
case|case
name|C_ID_ID
case|:
return|return
name|false
return|;
case|case
name|C_ID_TYPENAME
case|:
return|return
name|true
return|;
case|case
name|C_ID_CLASSNAME
case|:
name|gcc_assert
argument_list|(
name|c_dialect_objc
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|true
return|;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
case|case
name|CPP_KEYWORD
case|:
switch|switch
condition|(
name|token
operator|->
name|keyword
condition|)
block|{
case|case
name|RID_UNSIGNED
case|:
case|case
name|RID_LONG
case|:
case|case
name|RID_SHORT
case|:
case|case
name|RID_SIGNED
case|:
case|case
name|RID_COMPLEX
case|:
case|case
name|RID_INT
case|:
case|case
name|RID_CHAR
case|:
case|case
name|RID_FLOAT
case|:
case|case
name|RID_DOUBLE
case|:
case|case
name|RID_VOID
case|:
case|case
name|RID_DFLOAT32
case|:
case|case
name|RID_DFLOAT64
case|:
case|case
name|RID_DFLOAT128
case|:
case|case
name|RID_BOOL
case|:
case|case
name|RID_ENUM
case|:
case|case
name|RID_STRUCT
case|:
case|case
name|RID_UNION
case|:
case|case
name|RID_TYPEOF
case|:
case|case
name|RID_CONST
case|:
case|case
name|RID_VOLATILE
case|:
case|case
name|RID_RESTRICT
case|:
case|case
name|RID_ATTRIBUTE
case|:
return|return
name|true
return|;
default|default:
return|return
name|false
return|;
block|}
case|case
name|CPP_LESS
case|:
if|if
condition|(
name|c_dialect_objc
argument_list|()
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
default|default:
return|return
name|false
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return true if the next token from PARSER can start a type name,    false otherwise.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|c_parser_next_token_starts_typename
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|)
block|{
name|c_token
modifier|*
name|token
init|=
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
decl_stmt|;
return|return
name|c_token_starts_typename
argument_list|(
name|token
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if TOKEN can start declaration specifiers, false    otherwise.  */
end_comment

begin_function
specifier|static
name|bool
name|c_token_starts_declspecs
parameter_list|(
name|c_token
modifier|*
name|token
parameter_list|)
block|{
switch|switch
condition|(
name|token
operator|->
name|type
condition|)
block|{
case|case
name|CPP_NAME
case|:
switch|switch
condition|(
name|token
operator|->
name|id_kind
condition|)
block|{
case|case
name|C_ID_ID
case|:
return|return
name|false
return|;
case|case
name|C_ID_TYPENAME
case|:
return|return
name|true
return|;
case|case
name|C_ID_CLASSNAME
case|:
name|gcc_assert
argument_list|(
name|c_dialect_objc
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|true
return|;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
case|case
name|CPP_KEYWORD
case|:
switch|switch
condition|(
name|token
operator|->
name|keyword
condition|)
block|{
case|case
name|RID_STATIC
case|:
case|case
name|RID_EXTERN
case|:
case|case
name|RID_REGISTER
case|:
case|case
name|RID_TYPEDEF
case|:
case|case
name|RID_INLINE
case|:
case|case
name|RID_AUTO
case|:
case|case
name|RID_THREAD
case|:
case|case
name|RID_UNSIGNED
case|:
case|case
name|RID_LONG
case|:
case|case
name|RID_SHORT
case|:
case|case
name|RID_SIGNED
case|:
case|case
name|RID_COMPLEX
case|:
case|case
name|RID_INT
case|:
case|case
name|RID_CHAR
case|:
case|case
name|RID_FLOAT
case|:
case|case
name|RID_DOUBLE
case|:
case|case
name|RID_VOID
case|:
case|case
name|RID_DFLOAT32
case|:
case|case
name|RID_DFLOAT64
case|:
case|case
name|RID_DFLOAT128
case|:
case|case
name|RID_BOOL
case|:
case|case
name|RID_ENUM
case|:
case|case
name|RID_STRUCT
case|:
case|case
name|RID_UNION
case|:
case|case
name|RID_TYPEOF
case|:
case|case
name|RID_CONST
case|:
case|case
name|RID_VOLATILE
case|:
case|case
name|RID_RESTRICT
case|:
case|case
name|RID_ATTRIBUTE
case|:
return|return
name|true
return|;
default|default:
return|return
name|false
return|;
block|}
case|case
name|CPP_LESS
case|:
if|if
condition|(
name|c_dialect_objc
argument_list|()
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
default|default:
return|return
name|false
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return true if the next token from PARSER can start declaration    specifiers, false otherwise.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|c_parser_next_token_starts_declspecs
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|)
block|{
name|c_token
modifier|*
name|token
init|=
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
decl_stmt|;
return|return
name|c_token_starts_declspecs
argument_list|(
name|token
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return a pointer to the next-but-one token from PARSER, reading it    in if necessary.  The next token is already read in.  */
end_comment

begin_function
specifier|static
name|c_token
modifier|*
name|c_parser_peek_2nd_token
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|)
block|{
if|if
condition|(
name|parser
operator|->
name|tokens_avail
operator|>=
literal|2
condition|)
return|return
operator|&
name|parser
operator|->
name|tokens
index|[
literal|1
index|]
return|;
name|gcc_assert
argument_list|(
name|parser
operator|->
name|tokens_avail
operator|==
literal|1
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|parser
operator|->
name|tokens
index|[
literal|0
index|]
operator|.
name|type
operator|!=
name|CPP_EOF
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|parser
operator|->
name|tokens
index|[
literal|0
index|]
operator|.
name|type
operator|!=
name|CPP_PRAGMA_EOL
argument_list|)
expr_stmt|;
name|c_lex_one_token
argument_list|(
operator|&
name|parser
operator|->
name|tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|parser
operator|->
name|tokens_avail
operator|=
literal|2
expr_stmt|;
return|return
operator|&
name|parser
operator|->
name|tokens
index|[
literal|1
index|]
return|;
block|}
end_function

begin_comment
comment|/* Consume the next token from PARSER.  */
end_comment

begin_function
specifier|static
name|void
name|c_parser_consume_token
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|parser
operator|->
name|tokens_avail
operator|>=
literal|1
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|parser
operator|->
name|tokens
index|[
literal|0
index|]
operator|.
name|type
operator|!=
name|CPP_EOF
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|parser
operator|->
name|in_pragma
operator|||
name|parser
operator|->
name|tokens
index|[
literal|0
index|]
operator|.
name|type
operator|!=
name|CPP_PRAGMA_EOL
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|parser
operator|->
name|error
operator|||
name|parser
operator|->
name|tokens
index|[
literal|0
index|]
operator|.
name|type
operator|!=
name|CPP_PRAGMA
argument_list|)
expr_stmt|;
if|if
condition|(
name|parser
operator|->
name|tokens_avail
operator|==
literal|2
condition|)
name|parser
operator|->
name|tokens
index|[
literal|0
index|]
operator|=
name|parser
operator|->
name|tokens
index|[
literal|1
index|]
expr_stmt|;
name|parser
operator|->
name|tokens_avail
operator|--
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Expect the current token to be a #pragma.  Consume it and remember    that we've begun parsing a pragma.  */
end_comment

begin_function
specifier|static
name|void
name|c_parser_consume_pragma
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|)
block|{
name|gcc_assert
argument_list|(
operator|!
name|parser
operator|->
name|in_pragma
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|parser
operator|->
name|tokens_avail
operator|>=
literal|1
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|parser
operator|->
name|tokens
index|[
literal|0
index|]
operator|.
name|type
operator|==
name|CPP_PRAGMA
argument_list|)
expr_stmt|;
if|if
condition|(
name|parser
operator|->
name|tokens_avail
operator|==
literal|2
condition|)
name|parser
operator|->
name|tokens
index|[
literal|0
index|]
operator|=
name|parser
operator|->
name|tokens
index|[
literal|1
index|]
expr_stmt|;
name|parser
operator|->
name|tokens_avail
operator|--
expr_stmt|;
name|parser
operator|->
name|in_pragma
operator|=
name|true
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Update the globals input_location and in_system_header from    TOKEN.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|c_parser_set_source_position_from_token
parameter_list|(
name|c_token
modifier|*
name|token
parameter_list|)
block|{
if|if
condition|(
name|token
operator|->
name|type
operator|!=
name|CPP_EOF
condition|)
block|{
name|input_location
operator|=
name|token
operator|->
name|location
expr_stmt|;
name|in_system_header
operator|=
name|token
operator|->
name|in_system_header
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Issue a diagnostic of the form       FILE:LINE: MESSAGE before TOKEN    where TOKEN is the next token in the input stream of PARSER.    MESSAGE (specified by the caller) is usually of the form "expected    OTHER-TOKEN".     Do not issue a diagnostic if still recovering from an error.     ??? This is taken from the C++ parser, but building up messages in    this way is not i18n-friendly and some other approach should be    used.  */
end_comment

begin_function
specifier|static
name|void
name|c_parser_error
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|,
specifier|const
name|char
modifier|*
name|gmsgid
parameter_list|)
block|{
name|c_token
modifier|*
name|token
init|=
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
decl_stmt|;
if|if
condition|(
name|parser
operator|->
name|error
condition|)
return|return;
name|parser
operator|->
name|error
operator|=
name|true
expr_stmt|;
if|if
condition|(
operator|!
name|gmsgid
condition|)
return|return;
comment|/* This diagnostic makes more sense if it is tagged to the line of      the token we just peeked at.  */
name|c_parser_set_source_position_from_token
argument_list|(
name|token
argument_list|)
expr_stmt|;
name|c_parse_error
argument_list|(
name|gmsgid
argument_list|,
comment|/* Because c_parse_error does not understand 		    CPP_KEYWORD, keywords are treated like 		    identifiers.  */
operator|(
name|token
operator|->
name|type
operator|==
name|CPP_KEYWORD
condition|?
name|CPP_NAME
else|:
name|token
operator|->
name|type
operator|)
argument_list|,
name|token
operator|->
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If the next token is of the indicated TYPE, consume it.  Otherwise,    issue the error MSGID.  If MSGID is NULL then a message has already    been produced and no message will be produced this time.  Returns    true if found, false otherwise.  */
end_comment

begin_function
specifier|static
name|bool
name|c_parser_require
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|,
name|enum
name|cpp_ttype
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|msgid
parameter_list|)
block|{
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|type
argument_list|)
condition|)
block|{
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
else|else
block|{
name|c_parser_error
argument_list|(
name|parser
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
end_function

begin_comment
comment|/* If the next token is the indicated keyword, consume it.  Otherwise,    issue the error MSGID.  Returns true if found, false otherwise.  */
end_comment

begin_function
specifier|static
name|bool
name|c_parser_require_keyword
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|,
name|enum
name|rid
name|keyword
parameter_list|,
specifier|const
name|char
modifier|*
name|msgid
parameter_list|)
block|{
if|if
condition|(
name|c_parser_next_token_is_keyword
argument_list|(
name|parser
argument_list|,
name|keyword
argument_list|)
condition|)
block|{
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
else|else
block|{
name|c_parser_error
argument_list|(
name|parser
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
end_function

begin_comment
comment|/* Like c_parser_require, except that tokens will be skipped until the    desired token is found.  An error message is still produced if the    next token is not as expected.  If MSGID is NULL then a message has    already been produced and no message will be produced this    time.  */
end_comment

begin_function
specifier|static
name|void
name|c_parser_skip_until_found
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|,
name|enum
name|cpp_ttype
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|msgid
parameter_list|)
block|{
name|unsigned
name|nesting_depth
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|c_parser_require
argument_list|(
name|parser
argument_list|,
name|type
argument_list|,
name|msgid
argument_list|)
condition|)
return|return;
comment|/* Skip tokens until the desired token is found.  */
while|while
condition|(
name|true
condition|)
block|{
comment|/* Peek at the next token.  */
name|c_token
modifier|*
name|token
init|=
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
decl_stmt|;
comment|/* If we've reached the token we want, consume it and stop.  */
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|type
operator|&&
operator|!
name|nesting_depth
condition|)
block|{
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* If we've run out of tokens, stop.  */
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_EOF
condition|)
return|return;
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_PRAGMA_EOL
operator|&&
name|parser
operator|->
name|in_pragma
condition|)
return|return;
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_OPEN_BRACE
operator|||
name|token
operator|->
name|type
operator|==
name|CPP_OPEN_PAREN
operator|||
name|token
operator|->
name|type
operator|==
name|CPP_OPEN_SQUARE
condition|)
operator|++
name|nesting_depth
expr_stmt|;
elseif|else
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_CLOSE_BRACE
operator|||
name|token
operator|->
name|type
operator|==
name|CPP_CLOSE_PAREN
operator|||
name|token
operator|->
name|type
operator|==
name|CPP_CLOSE_SQUARE
condition|)
block|{
if|if
condition|(
name|nesting_depth
operator|--
operator|==
literal|0
condition|)
break|break;
block|}
comment|/* Consume this token.  */
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
name|parser
operator|->
name|error
operator|=
name|false
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Skip tokens until the end of a parameter is found, but do not    consume the comma, semicolon or closing delimiter.  */
end_comment

begin_function
specifier|static
name|void
name|c_parser_skip_to_end_of_parameter
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|)
block|{
name|unsigned
name|nesting_depth
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|true
condition|)
block|{
name|c_token
modifier|*
name|token
init|=
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|token
operator|->
name|type
operator|==
name|CPP_COMMA
operator|||
name|token
operator|->
name|type
operator|==
name|CPP_SEMICOLON
operator|)
operator|&&
operator|!
name|nesting_depth
condition|)
break|break;
comment|/* If we've run out of tokens, stop.  */
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_EOF
condition|)
return|return;
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_PRAGMA_EOL
operator|&&
name|parser
operator|->
name|in_pragma
condition|)
return|return;
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_OPEN_BRACE
operator|||
name|token
operator|->
name|type
operator|==
name|CPP_OPEN_PAREN
operator|||
name|token
operator|->
name|type
operator|==
name|CPP_OPEN_SQUARE
condition|)
operator|++
name|nesting_depth
expr_stmt|;
elseif|else
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_CLOSE_BRACE
operator|||
name|token
operator|->
name|type
operator|==
name|CPP_CLOSE_PAREN
operator|||
name|token
operator|->
name|type
operator|==
name|CPP_CLOSE_SQUARE
condition|)
block|{
if|if
condition|(
name|nesting_depth
operator|--
operator|==
literal|0
condition|)
break|break;
block|}
comment|/* Consume this token.  */
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
name|parser
operator|->
name|error
operator|=
name|false
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Expect to be at the end of the pragma directive and consume an    end of line marker.  */
end_comment

begin_function
specifier|static
name|void
name|c_parser_skip_to_pragma_eol
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|parser
operator|->
name|in_pragma
argument_list|)
expr_stmt|;
name|parser
operator|->
name|in_pragma
operator|=
name|false
expr_stmt|;
if|if
condition|(
operator|!
name|c_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_PRAGMA_EOL
argument_list|,
literal|"expected end of line"
argument_list|)
condition|)
while|while
condition|(
name|true
condition|)
block|{
name|c_token
modifier|*
name|token
init|=
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
decl_stmt|;
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_EOF
condition|)
break|break;
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_PRAGMA_EOL
condition|)
block|{
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
break|break;
block|}
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
name|parser
operator|->
name|error
operator|=
name|false
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Skip tokens until we have consumed an entire block, or until we    have consumed a non-nested ';'.  */
end_comment

begin_function
specifier|static
name|void
name|c_parser_skip_to_end_of_block_or_statement
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|)
block|{
name|unsigned
name|nesting_depth
init|=
literal|0
decl_stmt|;
name|bool
name|save_error
init|=
name|parser
operator|->
name|error
decl_stmt|;
while|while
condition|(
name|true
condition|)
block|{
name|c_token
modifier|*
name|token
decl_stmt|;
comment|/* Peek at the next token.  */
name|token
operator|=
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|token
operator|->
name|type
condition|)
block|{
case|case
name|CPP_EOF
case|:
return|return;
case|case
name|CPP_PRAGMA_EOL
case|:
if|if
condition|(
name|parser
operator|->
name|in_pragma
condition|)
return|return;
break|break;
case|case
name|CPP_SEMICOLON
case|:
comment|/* If the next token is a ';', we have reached the 	     end of the statement.  */
if|if
condition|(
operator|!
name|nesting_depth
condition|)
block|{
comment|/* Consume the ';'.  */
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
goto|goto
name|finished
goto|;
block|}
break|break;
case|case
name|CPP_CLOSE_BRACE
case|:
comment|/* If the next token is a non-nested '}', then we have 	     reached the end of the current block.  */
if|if
condition|(
name|nesting_depth
operator|==
literal|0
operator|||
operator|--
name|nesting_depth
operator|==
literal|0
condition|)
block|{
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
goto|goto
name|finished
goto|;
block|}
break|break;
case|case
name|CPP_OPEN_BRACE
case|:
comment|/* If it the next token is a '{', then we are entering a new 	     block.  Consume the entire block.  */
operator|++
name|nesting_depth
expr_stmt|;
break|break;
case|case
name|CPP_PRAGMA
case|:
comment|/* If we see a pragma, consume the whole thing at once.  We 	     have some safeguards against consuming pragmas willy-nilly. 	     Normally, we'd expect to be here with parser->error set, 	     which disables these safeguards.  But it's possible to get 	     here for secondary error recovery, after parser->error has 	     been cleared.  */
name|c_parser_consume_pragma
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|c_parser_skip_to_pragma_eol
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|parser
operator|->
name|error
operator|=
name|save_error
expr_stmt|;
continue|continue;
default|default:
break|break;
block|}
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
name|finished
label|:
name|parser
operator|->
name|error
operator|=
name|false
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Save the warning flags which are controlled by __extension__.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|disable_extension_diagnostics
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|ret
init|=
operator|(
name|pedantic
operator||
operator|(
name|warn_pointer_arith
operator|<<
literal|1
operator|)
operator||
operator|(
name|warn_traditional
operator|<<
literal|2
operator|)
operator||
operator|(
name|flag_iso
operator|<<
literal|3
operator|)
operator|)
decl_stmt|;
name|pedantic
operator|=
literal|0
expr_stmt|;
name|warn_pointer_arith
operator|=
literal|0
expr_stmt|;
name|warn_traditional
operator|=
literal|0
expr_stmt|;
name|flag_iso
operator|=
literal|0
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Restore the warning flags which are controlled by __extension__.    FLAGS is the return value from disable_extension_diagnostics.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|restore_extension_diagnostics
parameter_list|(
name|int
name|flags
parameter_list|)
block|{
name|pedantic
operator|=
name|flags
operator|&
literal|1
expr_stmt|;
name|warn_pointer_arith
operator|=
operator|(
name|flags
operator|>>
literal|1
operator|)
operator|&
literal|1
expr_stmt|;
name|warn_traditional
operator|=
operator|(
name|flags
operator|>>
literal|2
operator|)
operator|&
literal|1
expr_stmt|;
name|flag_iso
operator|=
operator|(
name|flags
operator|>>
literal|3
operator|)
operator|&
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Possibly kinds of declarator to parse.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
name|c_dtr_syn
block|{
comment|/* A normal declarator with an identifier.  */
name|C_DTR_NORMAL
block|,
comment|/* An abstract declarator (maybe empty).  */
name|C_DTR_ABSTRACT
block|,
comment|/* A parameter declarator: may be either, but after a type name does      not redeclare a typedef name as an identifier if it can      alternatively be interpreted as a typedef name; see DR#009,      applied in C90 TC1, omitted from C99 and reapplied in C99 TC2      following DR#249.  For example, given a typedef T, "int T" and      "int *T" are valid parameter declarations redeclaring T, while      "int (T)" and "int * (T)" and "int (T[])" and "int (T (int))" are      abstract declarators rather than involving redundant parentheses;      the same applies with attributes inside the parentheses before      "T".  */
name|C_DTR_PARM
block|}
name|c_dtr_syn
typedef|;
end_typedef

begin_function_decl
specifier|static
name|void
name|c_parser_external_declaration
parameter_list|(
name|c_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|c_parser_asm_definition
parameter_list|(
name|c_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|c_parser_declaration_or_fndef
parameter_list|(
name|c_parser
modifier|*
parameter_list|,
name|bool
parameter_list|,
name|bool
parameter_list|,
name|bool
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|c_parser_declspecs
parameter_list|(
name|c_parser
modifier|*
parameter_list|,
name|struct
name|c_declspecs
modifier|*
parameter_list|,
name|bool
parameter_list|,
name|bool
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|c_typespec
name|c_parser_enum_specifier
parameter_list|(
name|c_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|c_typespec
name|c_parser_struct_or_union_specifier
parameter_list|(
name|c_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|c_parser_struct_declaration
parameter_list|(
name|c_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|c_typespec
name|c_parser_typeof_specifier
parameter_list|(
name|c_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|c_declarator
modifier|*
name|c_parser_declarator
parameter_list|(
name|c_parser
modifier|*
parameter_list|,
name|bool
parameter_list|,
name|c_dtr_syn
parameter_list|,
name|bool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|c_declarator
modifier|*
name|c_parser_direct_declarator
parameter_list|(
name|c_parser
modifier|*
parameter_list|,
name|bool
parameter_list|,
name|c_dtr_syn
parameter_list|,
name|bool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|c_declarator
modifier|*
name|c_parser_direct_declarator_inner
parameter_list|(
name|c_parser
modifier|*
parameter_list|,
name|bool
parameter_list|,
name|struct
name|c_declarator
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|c_arg_info
modifier|*
name|c_parser_parms_declarator
parameter_list|(
name|c_parser
modifier|*
parameter_list|,
name|bool
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|c_arg_info
modifier|*
name|c_parser_parms_list_declarator
parameter_list|(
name|c_parser
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|c_parm
modifier|*
name|c_parser_parameter_declaration
parameter_list|(
name|c_parser
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|c_parser_simple_asm_expr
parameter_list|(
name|c_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|c_parser_attributes
parameter_list|(
name|c_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|c_type_name
modifier|*
name|c_parser_type_name
parameter_list|(
name|c_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|c_expr
name|c_parser_initializer
parameter_list|(
name|c_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|c_expr
name|c_parser_braced_init
parameter_list|(
name|c_parser
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|c_parser_initelt
parameter_list|(
name|c_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|c_parser_initval
parameter_list|(
name|c_parser
modifier|*
parameter_list|,
name|struct
name|c_expr
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|c_parser_compound_statement
parameter_list|(
name|c_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|c_parser_compound_statement_nostart
parameter_list|(
name|c_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|c_parser_label
parameter_list|(
name|c_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|c_parser_statement
parameter_list|(
name|c_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|c_parser_statement_after_labels
parameter_list|(
name|c_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|c_parser_if_statement
parameter_list|(
name|c_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|c_parser_switch_statement
parameter_list|(
name|c_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|c_parser_while_statement
parameter_list|(
name|c_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|c_parser_do_statement
parameter_list|(
name|c_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|c_parser_for_statement
parameter_list|(
name|c_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|c_parser_asm_statement
parameter_list|(
name|c_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|c_parser_asm_operands
parameter_list|(
name|c_parser
modifier|*
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|c_parser_asm_clobbers
parameter_list|(
name|c_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|c_expr
name|c_parser_expr_no_commas
parameter_list|(
name|c_parser
modifier|*
parameter_list|,
name|struct
name|c_expr
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|c_expr
name|c_parser_conditional_expression
parameter_list|(
name|c_parser
modifier|*
parameter_list|,
name|struct
name|c_expr
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|c_expr
name|c_parser_binary_expression
parameter_list|(
name|c_parser
modifier|*
parameter_list|,
name|struct
name|c_expr
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|c_expr
name|c_parser_cast_expression
parameter_list|(
name|c_parser
modifier|*
parameter_list|,
name|struct
name|c_expr
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|c_expr
name|c_parser_unary_expression
parameter_list|(
name|c_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|c_expr
name|c_parser_sizeof_expression
parameter_list|(
name|c_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|c_expr
name|c_parser_alignof_expression
parameter_list|(
name|c_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|c_expr
name|c_parser_postfix_expression
parameter_list|(
name|c_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|c_expr
name|c_parser_postfix_expression_after_paren_type
parameter_list|(
name|c_parser
modifier|*
parameter_list|,
name|struct
name|c_type_name
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|c_expr
name|c_parser_postfix_expression_after_primary
parameter_list|(
name|c_parser
modifier|*
parameter_list|,
name|struct
name|c_expr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|c_expr
name|c_parser_expression
parameter_list|(
name|c_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|c_expr
name|c_parser_expression_conv
parameter_list|(
name|c_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|c_parser_expr_list
parameter_list|(
name|c_parser
modifier|*
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|c_parser_omp_construct
parameter_list|(
name|c_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|c_parser_omp_threadprivate
parameter_list|(
name|c_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|c_parser_omp_barrier
parameter_list|(
name|c_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|c_parser_omp_flush
parameter_list|(
name|c_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_enum
enum|enum
name|pragma_context
block|{
name|pragma_external
block|,
name|pragma_stmt
block|,
name|pragma_compound
block|}
enum|;
end_enum

begin_function_decl
specifier|static
name|bool
name|c_parser_pragma
parameter_list|(
name|c_parser
modifier|*
parameter_list|,
name|enum
name|pragma_context
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* These Objective-C parser functions are only ever called when    compiling Objective-C.  */
end_comment

begin_function_decl
specifier|static
name|void
name|c_parser_objc_class_definition
parameter_list|(
name|c_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|c_parser_objc_class_instance_variables
parameter_list|(
name|c_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|c_parser_objc_class_declaration
parameter_list|(
name|c_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|c_parser_objc_alias_declaration
parameter_list|(
name|c_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|c_parser_objc_protocol_definition
parameter_list|(
name|c_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|tree_code
name|c_parser_objc_method_type
parameter_list|(
name|c_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|c_parser_objc_method_definition
parameter_list|(
name|c_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|c_parser_objc_methodprotolist
parameter_list|(
name|c_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|c_parser_objc_methodproto
parameter_list|(
name|c_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|c_parser_objc_method_decl
parameter_list|(
name|c_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|c_parser_objc_type_name
parameter_list|(
name|c_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|c_parser_objc_protocol_refs
parameter_list|(
name|c_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|c_parser_objc_try_catch_statement
parameter_list|(
name|c_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|c_parser_objc_synchronized_statement
parameter_list|(
name|c_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|c_parser_objc_selector
parameter_list|(
name|c_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|c_parser_objc_selector_arg
parameter_list|(
name|c_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|c_parser_objc_receiver
parameter_list|(
name|c_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|c_parser_objc_message_args
parameter_list|(
name|c_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|c_parser_objc_keywordexpr
parameter_list|(
name|c_parser
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Parse a translation unit (C90 6.7, C99 6.9).     translation-unit:      external-declarations     external-declarations:      external-declaration      external-declarations external-declaration     GNU extensions:     translation-unit:      empty */
end_comment

begin_function
specifier|static
name|void
name|c_parser_translation_unit
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|)
block|{
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_EOF
argument_list|)
condition|)
block|{
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"ISO C forbids an empty source file"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|void
modifier|*
name|obstack_position
init|=
name|obstack_alloc
argument_list|(
operator|&
name|parser_obstack
argument_list|,
literal|0
argument_list|)
decl_stmt|;
do|do
block|{
name|ggc_collect
argument_list|()
expr_stmt|;
name|c_parser_external_declaration
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|obstack_free
argument_list|(
operator|&
name|parser_obstack
argument_list|,
name|obstack_position
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|c_parser_next_token_is_not
argument_list|(
name|parser
argument_list|,
name|CPP_EOF
argument_list|)
condition|)
do|;
block|}
block|}
end_function

begin_comment
comment|/* Parse an external declaration (C90 6.7, C99 6.9).     external-declaration:      function-definition      declaration     GNU extensions:     external-declaration:      asm-definition      ;      __extension__ external-declaration     Objective-C:     external-declaration:      objc-class-definition      objc-class-declaration      objc-alias-declaration      objc-protocol-definition      objc-method-definition      @end */
end_comment

begin_function
specifier|static
name|void
name|c_parser_external_declaration
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|)
block|{
name|int
name|ext
decl_stmt|;
switch|switch
condition|(
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
operator|->
name|type
condition|)
block|{
case|case
name|CPP_KEYWORD
case|:
switch|switch
condition|(
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
operator|->
name|keyword
condition|)
block|{
case|case
name|RID_EXTENSION
case|:
name|ext
operator|=
name|disable_extension_diagnostics
argument_list|()
expr_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|c_parser_external_declaration
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|restore_extension_diagnostics
argument_list|(
name|ext
argument_list|)
expr_stmt|;
break|break;
case|case
name|RID_ASM
case|:
name|c_parser_asm_definition
argument_list|(
name|parser
argument_list|)
expr_stmt|;
break|break;
case|case
name|RID_AT_INTERFACE
case|:
case|case
name|RID_AT_IMPLEMENTATION
case|:
name|gcc_assert
argument_list|(
name|c_dialect_objc
argument_list|()
argument_list|)
expr_stmt|;
name|c_parser_objc_class_definition
argument_list|(
name|parser
argument_list|)
expr_stmt|;
break|break;
case|case
name|RID_AT_CLASS
case|:
name|gcc_assert
argument_list|(
name|c_dialect_objc
argument_list|()
argument_list|)
expr_stmt|;
name|c_parser_objc_class_declaration
argument_list|(
name|parser
argument_list|)
expr_stmt|;
break|break;
case|case
name|RID_AT_ALIAS
case|:
name|gcc_assert
argument_list|(
name|c_dialect_objc
argument_list|()
argument_list|)
expr_stmt|;
name|c_parser_objc_alias_declaration
argument_list|(
name|parser
argument_list|)
expr_stmt|;
break|break;
case|case
name|RID_AT_PROTOCOL
case|:
name|gcc_assert
argument_list|(
name|c_dialect_objc
argument_list|()
argument_list|)
expr_stmt|;
name|c_parser_objc_protocol_definition
argument_list|(
name|parser
argument_list|)
expr_stmt|;
break|break;
case|case
name|RID_AT_END
case|:
name|gcc_assert
argument_list|(
name|c_dialect_objc
argument_list|()
argument_list|)
expr_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|objc_finish_implementation
argument_list|()
expr_stmt|;
break|break;
default|default:
goto|goto
name|decl_or_fndef
goto|;
block|}
break|break;
case|case
name|CPP_SEMICOLON
case|:
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"ISO C does not allow extra %<;%> outside of a function"
argument_list|)
expr_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_PRAGMA
case|:
name|c_parser_pragma
argument_list|(
name|parser
argument_list|,
name|pragma_external
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_PLUS
case|:
case|case
name|CPP_MINUS
case|:
if|if
condition|(
name|c_dialect_objc
argument_list|()
condition|)
block|{
name|c_parser_objc_method_definition
argument_list|(
name|parser
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Else fall through, and yield a syntax error trying to parse 	 as a declaration or function definition.  */
default|default:
name|decl_or_fndef
label|:
comment|/* A declaration or a function definition.  We can only tell 	 which after parsing the declaration specifiers, if any, and 	 the first declarator.  */
name|c_parser_declaration_or_fndef
argument_list|(
name|parser
argument_list|,
name|true
argument_list|,
name|true
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Parse a declaration or function definition (C90 6.5, 6.7.1, C99    6.7, 6.9.1).  If FNDEF_OK is true, a function definition is    accepted; otherwise (old-style parameter declarations) only other    declarations are accepted.  If NESTED is true, we are inside a    function or parsing old-style parameter declarations; any functions    encountered are nested functions and declaration specifiers are    required; otherwise we are at top level and functions are normal    functions and declaration specifiers may be optional.  If EMPTY_OK    is true, empty declarations are OK (subject to all other    constraints); otherwise (old-style parameter declarations) they are    diagnosed.  If START_ATTR_OK is true, the declaration specifiers    may start with attributes; otherwise they may not.     declaration:      declaration-specifiers init-declarator-list[opt] ;     function-definition:      declaration-specifiers[opt] declarator declaration-list[opt]        compound-statement     declaration-list:      declaration      declaration-list declaration     init-declarator-list:      init-declarator      init-declarator-list , init-declarator     init-declarator:      declarator simple-asm-expr[opt] attributes[opt]      declarator simple-asm-expr[opt] attributes[opt] = initializer     GNU extensions:     nested-function-definition:      declaration-specifiers declarator declaration-list[opt]        compound-statement     The simple-asm-expr and attributes are GNU extensions.     This function does not handle __extension__; that is handled in its    callers.  ??? Following the old parser, __extension__ may start    external declarations, declarations in functions and declarations    at the start of "for" loops, but not old-style parameter    declarations.     C99 requires declaration specifiers in a function definition; the    absence is diagnosed through the diagnosis of implicit int.  In GNU    C we also allow but diagnose declarations without declaration    specifiers, but only at top level (elsewhere they conflict with    other syntax).        OpenMP:        declaration:      threadprivate-directive  */
end_comment

begin_function
specifier|static
name|void
name|c_parser_declaration_or_fndef
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|,
name|bool
name|fndef_ok
parameter_list|,
name|bool
name|empty_ok
parameter_list|,
name|bool
name|nested
parameter_list|,
name|bool
name|start_attr_ok
parameter_list|)
block|{
name|struct
name|c_declspecs
modifier|*
name|specs
decl_stmt|;
name|tree
name|prefix_attrs
decl_stmt|;
name|tree
name|all_prefix_attrs
decl_stmt|;
name|bool
name|diagnosed_no_specs
init|=
name|false
decl_stmt|;
name|specs
operator|=
name|build_null_declspecs
argument_list|()
expr_stmt|;
name|c_parser_declspecs
argument_list|(
name|parser
argument_list|,
name|specs
argument_list|,
name|true
argument_list|,
name|true
argument_list|,
name|start_attr_ok
argument_list|)
expr_stmt|;
if|if
condition|(
name|parser
operator|->
name|error
condition|)
block|{
name|c_parser_skip_to_end_of_block_or_statement
argument_list|(
name|parser
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|nested
operator|&&
operator|!
name|specs
operator|->
name|declspecs_seen_p
condition|)
block|{
name|c_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected declaration specifiers"
argument_list|)
expr_stmt|;
name|c_parser_skip_to_end_of_block_or_statement
argument_list|(
name|parser
argument_list|)
expr_stmt|;
return|return;
block|}
name|finish_declspecs
argument_list|(
name|specs
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_SEMICOLON
argument_list|)
condition|)
block|{
if|if
condition|(
name|empty_ok
condition|)
name|shadow_tag
argument_list|(
name|specs
argument_list|)
expr_stmt|;
else|else
block|{
name|shadow_tag_warned
argument_list|(
name|specs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pedwarn
argument_list|(
literal|"empty declaration"
argument_list|)
expr_stmt|;
block|}
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
return|return;
block|}
name|pending_xref_error
argument_list|()
expr_stmt|;
name|prefix_attrs
operator|=
name|specs
operator|->
name|attrs
expr_stmt|;
name|all_prefix_attrs
operator|=
name|prefix_attrs
expr_stmt|;
name|specs
operator|->
name|attrs
operator|=
name|NULL_TREE
expr_stmt|;
while|while
condition|(
name|true
condition|)
block|{
name|struct
name|c_declarator
modifier|*
name|declarator
decl_stmt|;
name|bool
name|dummy
init|=
name|false
decl_stmt|;
name|tree
name|fnbody
decl_stmt|;
comment|/* Declaring either one or more declarators (in which case we 	 should diagnose if there were no declaration specifiers) or a 	 function definition (in which case the diagnostic for 	 implicit int suffices).  */
name|declarator
operator|=
name|c_parser_declarator
argument_list|(
name|parser
argument_list|,
name|specs
operator|->
name|type_seen_p
argument_list|,
name|C_DTR_NORMAL
argument_list|,
operator|&
name|dummy
argument_list|)
expr_stmt|;
if|if
condition|(
name|declarator
operator|==
name|NULL
condition|)
block|{
name|c_parser_skip_to_end_of_block_or_statement
argument_list|(
name|parser
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_EQ
argument_list|)
operator|||
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_COMMA
argument_list|)
operator|||
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_SEMICOLON
argument_list|)
operator|||
name|c_parser_next_token_is_keyword
argument_list|(
name|parser
argument_list|,
name|RID_ASM
argument_list|)
operator|||
name|c_parser_next_token_is_keyword
argument_list|(
name|parser
argument_list|,
name|RID_ATTRIBUTE
argument_list|)
condition|)
block|{
name|tree
name|asm_name
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|postfix_attrs
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
operator|!
name|diagnosed_no_specs
operator|&&
operator|!
name|specs
operator|->
name|declspecs_seen_p
condition|)
block|{
name|diagnosed_no_specs
operator|=
name|true
expr_stmt|;
name|pedwarn
argument_list|(
literal|"data definition has no type or storage class"
argument_list|)
expr_stmt|;
block|}
comment|/* Having seen a data definition, there cannot now be a 	     function definition.  */
name|fndef_ok
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|c_parser_next_token_is_keyword
argument_list|(
name|parser
argument_list|,
name|RID_ASM
argument_list|)
condition|)
name|asm_name
operator|=
name|c_parser_simple_asm_expr
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_parser_next_token_is_keyword
argument_list|(
name|parser
argument_list|,
name|RID_ATTRIBUTE
argument_list|)
condition|)
name|postfix_attrs
operator|=
name|c_parser_attributes
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_EQ
argument_list|)
condition|)
block|{
name|tree
name|d
decl_stmt|;
name|struct
name|c_expr
name|init
decl_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* The declaration of the variable is in effect while 		 its initializer is parsed.  */
name|d
operator|=
name|start_decl
argument_list|(
name|declarator
argument_list|,
name|specs
argument_list|,
name|true
argument_list|,
name|chainon
argument_list|(
name|postfix_attrs
argument_list|,
name|all_prefix_attrs
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
condition|)
name|d
operator|=
name|error_mark_node
expr_stmt|;
name|start_init
argument_list|(
name|d
argument_list|,
name|asm_name
argument_list|,
name|global_bindings_p
argument_list|()
argument_list|)
expr_stmt|;
name|init
operator|=
name|c_parser_initializer
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|finish_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|!=
name|error_mark_node
condition|)
block|{
name|maybe_warn_string_init
argument_list|(
name|TREE_TYPE
argument_list|(
name|d
argument_list|)
argument_list|,
name|init
argument_list|)
expr_stmt|;
name|finish_decl
argument_list|(
name|d
argument_list|,
name|init
operator|.
name|value
argument_list|,
name|asm_name
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|tree
name|d
init|=
name|start_decl
argument_list|(
name|declarator
argument_list|,
name|specs
argument_list|,
name|false
argument_list|,
name|chainon
argument_list|(
name|postfix_attrs
argument_list|,
name|all_prefix_attrs
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|d
condition|)
name|finish_decl
argument_list|(
name|d
argument_list|,
name|NULL_TREE
argument_list|,
name|asm_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_COMMA
argument_list|)
condition|)
block|{
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_parser_next_token_is_keyword
argument_list|(
name|parser
argument_list|,
name|RID_ATTRIBUTE
argument_list|)
condition|)
name|all_prefix_attrs
operator|=
name|chainon
argument_list|(
name|c_parser_attributes
argument_list|(
name|parser
argument_list|)
argument_list|,
name|prefix_attrs
argument_list|)
expr_stmt|;
else|else
name|all_prefix_attrs
operator|=
name|prefix_attrs
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_SEMICOLON
argument_list|)
condition|)
block|{
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|c_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected %<,%> or %<;%>"
argument_list|)
expr_stmt|;
name|c_parser_skip_to_end_of_block_or_statement
argument_list|(
name|parser
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|fndef_ok
condition|)
block|{
name|c_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected %<=%>, %<,%>, %<;%>, "
literal|"%<asm%> or %<__attribute__%>"
argument_list|)
expr_stmt|;
name|c_parser_skip_to_end_of_block_or_statement
argument_list|(
name|parser
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Function definition (nested or otherwise).  */
if|if
condition|(
name|nested
condition|)
block|{
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"ISO C forbids nested functions"
argument_list|)
expr_stmt|;
name|push_function_context
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|start_function
argument_list|(
name|specs
argument_list|,
name|declarator
argument_list|,
name|all_prefix_attrs
argument_list|)
condition|)
block|{
comment|/* This can appear in many cases looking nothing like a 	     function definition, so we don't give a more specific 	     error suggesting there was one.  */
name|c_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected %<=%>, %<,%>, %<;%>, %<asm%> "
literal|"or %<__attribute__%>"
argument_list|)
expr_stmt|;
if|if
condition|(
name|nested
condition|)
name|pop_function_context
argument_list|()
expr_stmt|;
break|break;
block|}
comment|/* Parse old-style parameter declarations.  ??? Attributes are 	 not allowed to start declaration specifiers here because of a 	 syntax conflict between a function declaration with attribute 	 suffix and a function definition with an attribute prefix on 	 first old-style parameter declaration.  Following the old 	 parser, they are not accepted on subsequent old-style 	 parameter declarations either.  However, there is no 	 ambiguity after the first declaration, nor indeed on the 	 first as long as we don't allow postfix attributes after a 	 declarator with a nonempty identifier list in a definition; 	 and postfix attributes have never been accepted here in 	 function definitions either.  */
while|while
condition|(
name|c_parser_next_token_is_not
argument_list|(
name|parser
argument_list|,
name|CPP_EOF
argument_list|)
operator|&&
name|c_parser_next_token_is_not
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_BRACE
argument_list|)
condition|)
name|c_parser_declaration_or_fndef
argument_list|(
name|parser
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|true
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|DECL_SOURCE_LOCATION
argument_list|(
name|current_function_decl
argument_list|)
operator|=
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
operator|->
name|location
expr_stmt|;
name|store_parm_decls
argument_list|()
expr_stmt|;
name|fnbody
operator|=
name|c_parser_compound_statement
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|nested
condition|)
block|{
name|tree
name|decl
init|=
name|current_function_decl
decl_stmt|;
name|add_stmt
argument_list|(
name|fnbody
argument_list|)
expr_stmt|;
name|finish_function
argument_list|()
expr_stmt|;
name|pop_function_context
argument_list|()
expr_stmt|;
name|add_stmt
argument_list|(
name|build_stmt
argument_list|(
name|DECL_EXPR
argument_list|,
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|add_stmt
argument_list|(
name|fnbody
argument_list|)
expr_stmt|;
name|finish_function
argument_list|()
expr_stmt|;
block|}
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Parse an asm-definition (asm() outside a function body).  This is a    GNU extension.     asm-definition:      simple-asm-expr ; */
end_comment

begin_function
specifier|static
name|void
name|c_parser_asm_definition
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|asm_str
init|=
name|c_parser_simple_asm_expr
argument_list|(
name|parser
argument_list|)
decl_stmt|;
if|if
condition|(
name|asm_str
condition|)
name|cgraph_add_asm_node
argument_list|(
name|asm_str
argument_list|)
expr_stmt|;
name|c_parser_skip_until_found
argument_list|(
name|parser
argument_list|,
name|CPP_SEMICOLON
argument_list|,
literal|"expected %<;%>"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse some declaration specifiers (possibly none) (C90 6.5, C99    6.7), adding them to SPECS (which may already include some).    Storage class specifiers are accepted iff SCSPEC_OK; type    specifiers are accepted iff TYPESPEC_OK; attributes are accepted at    the start iff START_ATTR_OK.     declaration-specifiers:      storage-class-specifier declaration-specifiers[opt]      type-specifier declaration-specifiers[opt]      type-qualifier declaration-specifiers[opt]      function-specifier declaration-specifiers[opt]     Function specifiers (inline) are from C99, and are currently    handled as storage class specifiers, as is __thread.     C90 6.5.1, C99 6.7.1:    storage-class-specifier:      typedef      extern      static      auto      register     C99 6.7.4:    function-specifier:      inline     C90 6.5.2, C99 6.7.2:    type-specifier:      void      char      short      int      long      float      double      signed      unsigned      _Bool      _Complex      [_Imaginary removed in C99 TC2]      struct-or-union-specifier      enum-specifier      typedef-name     (_Bool and _Complex are new in C99.)     C90 6.5.3, C99 6.7.3:     type-qualifier:      const      restrict      volatile     (restrict is new in C99.)     GNU extensions:     declaration-specifiers:      attributes declaration-specifiers[opt]     storage-class-specifier:      __thread     type-specifier:      typeof-specifier      _Decimal32      _Decimal64      _Decimal128     Objective-C:     type-specifier:      class-name objc-protocol-refs[opt]      typedef-name objc-protocol-refs      objc-protocol-refs */
end_comment

begin_function
specifier|static
name|void
name|c_parser_declspecs
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|,
name|struct
name|c_declspecs
modifier|*
name|specs
parameter_list|,
name|bool
name|scspec_ok
parameter_list|,
name|bool
name|typespec_ok
parameter_list|,
name|bool
name|start_attr_ok
parameter_list|)
block|{
name|bool
name|attrs_ok
init|=
name|start_attr_ok
decl_stmt|;
name|bool
name|seen_type
init|=
name|specs
operator|->
name|type_seen_p
decl_stmt|;
while|while
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_NAME
argument_list|)
operator|||
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_KEYWORD
argument_list|)
operator|||
operator|(
name|c_dialect_objc
argument_list|()
operator|&&
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_LESS
argument_list|)
operator|)
condition|)
block|{
name|struct
name|c_typespec
name|t
decl_stmt|;
name|tree
name|attrs
decl_stmt|;
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_NAME
argument_list|)
condition|)
block|{
name|tree
name|value
init|=
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
operator|->
name|value
decl_stmt|;
name|c_id_kind
name|kind
init|=
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
operator|->
name|id_kind
decl_stmt|;
comment|/* This finishes the specifiers unless a type name is OK, it 	     is declared as a type name and a type name hasn't yet 	     been seen.  */
if|if
condition|(
operator|!
name|typespec_ok
operator|||
name|seen_type
operator|||
operator|(
name|kind
operator|!=
name|C_ID_TYPENAME
operator|&&
name|kind
operator|!=
name|C_ID_CLASSNAME
operator|)
condition|)
break|break;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|seen_type
operator|=
name|true
expr_stmt|;
name|attrs_ok
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|C_ID_TYPENAME
operator|&&
operator|(
operator|!
name|c_dialect_objc
argument_list|()
operator|||
name|c_parser_next_token_is_not
argument_list|(
name|parser
argument_list|,
name|CPP_LESS
argument_list|)
operator|)
condition|)
block|{
name|t
operator|.
name|kind
operator|=
name|ctsk_typedef
expr_stmt|;
comment|/* For a typedef name, record the meaning, not the name. 		 In case of 'foo foo, bar;'.  */
name|t
operator|.
name|spec
operator|=
name|lookup_name
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tree
name|proto
init|=
name|NULL_TREE
decl_stmt|;
name|gcc_assert
argument_list|(
name|c_dialect_objc
argument_list|()
argument_list|)
expr_stmt|;
name|t
operator|.
name|kind
operator|=
name|ctsk_objc
expr_stmt|;
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_LESS
argument_list|)
condition|)
name|proto
operator|=
name|c_parser_objc_protocol_refs
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|t
operator|.
name|spec
operator|=
name|objc_get_protocol_qualified_type
argument_list|(
name|value
argument_list|,
name|proto
argument_list|)
expr_stmt|;
block|}
name|declspecs_add_type
argument_list|(
name|specs
argument_list|,
name|t
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_LESS
argument_list|)
condition|)
block|{
comment|/* Make "<SomeProtocol>" equivalent to "id<SomeProtocol>" - 	     nisse@lysator.liu.se.  */
name|tree
name|proto
decl_stmt|;
name|gcc_assert
argument_list|(
name|c_dialect_objc
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|typespec_ok
operator|||
name|seen_type
condition|)
break|break;
name|proto
operator|=
name|c_parser_objc_protocol_refs
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|t
operator|.
name|kind
operator|=
name|ctsk_objc
expr_stmt|;
name|t
operator|.
name|spec
operator|=
name|objc_get_protocol_qualified_type
argument_list|(
name|NULL_TREE
argument_list|,
name|proto
argument_list|)
expr_stmt|;
name|declspecs_add_type
argument_list|(
name|specs
argument_list|,
name|t
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|gcc_assert
argument_list|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_KEYWORD
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
operator|->
name|keyword
condition|)
block|{
case|case
name|RID_STATIC
case|:
case|case
name|RID_EXTERN
case|:
case|case
name|RID_REGISTER
case|:
case|case
name|RID_TYPEDEF
case|:
case|case
name|RID_INLINE
case|:
case|case
name|RID_AUTO
case|:
case|case
name|RID_THREAD
case|:
if|if
condition|(
operator|!
name|scspec_ok
condition|)
goto|goto
name|out
goto|;
name|attrs_ok
operator|=
name|true
expr_stmt|;
comment|/* TODO: Distinguish between function specifiers (inline) 	     and storage class specifiers, either here or in 	     declspecs_add_scspec.  */
name|declspecs_add_scspec
argument_list|(
name|specs
argument_list|,
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
operator|->
name|value
argument_list|)
expr_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
break|break;
case|case
name|RID_UNSIGNED
case|:
case|case
name|RID_LONG
case|:
case|case
name|RID_SHORT
case|:
case|case
name|RID_SIGNED
case|:
case|case
name|RID_COMPLEX
case|:
case|case
name|RID_INT
case|:
case|case
name|RID_CHAR
case|:
case|case
name|RID_FLOAT
case|:
case|case
name|RID_DOUBLE
case|:
case|case
name|RID_VOID
case|:
case|case
name|RID_DFLOAT32
case|:
case|case
name|RID_DFLOAT64
case|:
case|case
name|RID_DFLOAT128
case|:
case|case
name|RID_BOOL
case|:
if|if
condition|(
operator|!
name|typespec_ok
condition|)
goto|goto
name|out
goto|;
name|attrs_ok
operator|=
name|true
expr_stmt|;
name|seen_type
operator|=
name|true
expr_stmt|;
name|OBJC_NEED_RAW_IDENTIFIER
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|t
operator|.
name|kind
operator|=
name|ctsk_resword
expr_stmt|;
name|t
operator|.
name|spec
operator|=
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
operator|->
name|value
expr_stmt|;
name|declspecs_add_type
argument_list|(
name|specs
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
break|break;
case|case
name|RID_ENUM
case|:
if|if
condition|(
operator|!
name|typespec_ok
condition|)
goto|goto
name|out
goto|;
name|attrs_ok
operator|=
name|true
expr_stmt|;
name|seen_type
operator|=
name|true
expr_stmt|;
name|t
operator|=
name|c_parser_enum_specifier
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|declspecs_add_type
argument_list|(
name|specs
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|RID_STRUCT
case|:
case|case
name|RID_UNION
case|:
if|if
condition|(
operator|!
name|typespec_ok
condition|)
goto|goto
name|out
goto|;
name|attrs_ok
operator|=
name|true
expr_stmt|;
name|seen_type
operator|=
name|true
expr_stmt|;
name|t
operator|=
name|c_parser_struct_or_union_specifier
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|declspecs_add_type
argument_list|(
name|specs
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|RID_TYPEOF
case|:
comment|/* ??? The old parser rejected typeof after other type 	     specifiers, but is a syntax error the best way of 	     handling this?  */
if|if
condition|(
operator|!
name|typespec_ok
operator|||
name|seen_type
condition|)
goto|goto
name|out
goto|;
name|attrs_ok
operator|=
name|true
expr_stmt|;
name|seen_type
operator|=
name|true
expr_stmt|;
name|t
operator|=
name|c_parser_typeof_specifier
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|declspecs_add_type
argument_list|(
name|specs
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|RID_CONST
case|:
case|case
name|RID_VOLATILE
case|:
case|case
name|RID_RESTRICT
case|:
name|attrs_ok
operator|=
name|true
expr_stmt|;
name|declspecs_add_qual
argument_list|(
name|specs
argument_list|,
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
operator|->
name|value
argument_list|)
expr_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
break|break;
case|case
name|RID_ATTRIBUTE
case|:
if|if
condition|(
operator|!
name|attrs_ok
condition|)
goto|goto
name|out
goto|;
name|attrs
operator|=
name|c_parser_attributes
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|declspecs_add_attrs
argument_list|(
name|specs
argument_list|,
name|attrs
argument_list|)
expr_stmt|;
break|break;
default|default:
goto|goto
name|out
goto|;
block|}
block|}
name|out
label|:
empty_stmt|;
block|}
end_function

begin_comment
comment|/* Parse an enum specifier (C90 6.5.2.2, C99 6.7.2.2).     enum-specifier:      enum attributes[opt] identifier[opt] { enumerator-list } attributes[opt]      enum attributes[opt] identifier[opt] { enumerator-list , } attributes[opt]      enum attributes[opt] identifier     The form with trailing comma is new in C99.  The forms with    attributes are GNU extensions.  In GNU C, we accept any expression    without commas in the syntax (assignment expressions, not just    conditional expressions); assignment expressions will be diagnosed    as non-constant.     enumerator-list:      enumerator      enumerator-list , enumerator     enumerator:      enumeration-constant      enumeration-constant = constant-expression */
end_comment

begin_function
specifier|static
name|struct
name|c_typespec
name|c_parser_enum_specifier
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|)
block|{
name|struct
name|c_typespec
name|ret
decl_stmt|;
name|tree
name|attrs
decl_stmt|;
name|tree
name|ident
init|=
name|NULL_TREE
decl_stmt|;
name|gcc_assert
argument_list|(
name|c_parser_next_token_is_keyword
argument_list|(
name|parser
argument_list|,
name|RID_ENUM
argument_list|)
argument_list|)
expr_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|attrs
operator|=
name|c_parser_attributes
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_NAME
argument_list|)
condition|)
block|{
name|ident
operator|=
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
operator|->
name|value
expr_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_BRACE
argument_list|)
condition|)
block|{
comment|/* Parse an enum definition.  */
name|tree
name|type
init|=
name|start_enum
argument_list|(
name|ident
argument_list|)
decl_stmt|;
name|tree
name|postfix_attrs
decl_stmt|;
comment|/* We chain the enumerators in reverse order, then put them in 	 forward order at the end.  */
name|tree
name|values
init|=
name|NULL_TREE
decl_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
while|while
condition|(
name|true
condition|)
block|{
name|tree
name|enum_id
decl_stmt|;
name|tree
name|enum_value
decl_stmt|;
name|tree
name|enum_decl
decl_stmt|;
name|bool
name|seen_comma
decl_stmt|;
if|if
condition|(
name|c_parser_next_token_is_not
argument_list|(
name|parser
argument_list|,
name|CPP_NAME
argument_list|)
condition|)
block|{
name|c_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected identifier"
argument_list|)
expr_stmt|;
name|c_parser_skip_until_found
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_BRACE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|values
operator|=
name|error_mark_node
expr_stmt|;
break|break;
block|}
name|enum_id
operator|=
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
operator|->
name|value
expr_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_EQ
argument_list|)
condition|)
block|{
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|enum_value
operator|=
name|c_parser_expr_no_commas
argument_list|(
name|parser
argument_list|,
name|NULL
argument_list|)
operator|.
name|value
expr_stmt|;
block|}
else|else
name|enum_value
operator|=
name|NULL_TREE
expr_stmt|;
name|enum_decl
operator|=
name|build_enumerator
argument_list|(
name|enum_id
argument_list|,
name|enum_value
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|enum_decl
argument_list|)
operator|=
name|values
expr_stmt|;
name|values
operator|=
name|enum_decl
expr_stmt|;
name|seen_comma
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_COMMA
argument_list|)
condition|)
block|{
name|seen_comma
operator|=
name|true
expr_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_BRACE
argument_list|)
condition|)
block|{
if|if
condition|(
name|seen_comma
operator|&&
name|pedantic
operator|&&
operator|!
name|flag_isoc99
condition|)
name|pedwarn
argument_list|(
literal|"comma at end of enumerator list"
argument_list|)
expr_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|seen_comma
condition|)
block|{
name|c_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected %<,%> or %<}%>"
argument_list|)
expr_stmt|;
name|c_parser_skip_until_found
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_BRACE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|values
operator|=
name|error_mark_node
expr_stmt|;
break|break;
block|}
block|}
name|postfix_attrs
operator|=
name|c_parser_attributes
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|ret
operator|.
name|spec
operator|=
name|finish_enum
argument_list|(
name|type
argument_list|,
name|nreverse
argument_list|(
name|values
argument_list|)
argument_list|,
name|chainon
argument_list|(
name|attrs
argument_list|,
name|postfix_attrs
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|.
name|kind
operator|=
name|ctsk_tagdef
expr_stmt|;
return|return
name|ret
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|ident
condition|)
block|{
name|c_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected %<{%>"
argument_list|)
expr_stmt|;
name|ret
operator|.
name|spec
operator|=
name|error_mark_node
expr_stmt|;
name|ret
operator|.
name|kind
operator|=
name|ctsk_tagref
expr_stmt|;
return|return
name|ret
return|;
block|}
name|ret
operator|=
name|parser_xref_tag
argument_list|(
name|ENUMERAL_TYPE
argument_list|,
name|ident
argument_list|)
expr_stmt|;
comment|/* In ISO C, enumerated types can be referred to only if already      defined.  */
if|if
condition|(
name|pedantic
operator|&&
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|ret
operator|.
name|spec
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"ISO C forbids forward references to %<enum%> types"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Parse a struct or union specifier (C90 6.5.2.1, C99 6.7.2.1).     struct-or-union-specifier:      struct-or-union attributes[opt] identifier[opt]        { struct-contents } attributes[opt]      struct-or-union attributes[opt] identifier     struct-contents:      struct-declaration-list     struct-declaration-list:      struct-declaration ;      struct-declaration-list struct-declaration ;     GNU extensions:     struct-contents:      empty      struct-declaration      struct-declaration-list struct-declaration     struct-declaration-list:      struct-declaration-list ;      ;     (Note that in the syntax here, unlike that in ISO C, the semicolons    are included here rather than in struct-declaration, in order to    describe the syntax with extra semicolons and missing semicolon at    end.)     Objective-C:     struct-declaration-list:      @defs ( class-name )     (Note this does not include a trailing semicolon, but can be    followed by further declarations, and gets a pedwarn-if-pedantic    when followed by a semicolon.)  */
end_comment

begin_function
specifier|static
name|struct
name|c_typespec
name|c_parser_struct_or_union_specifier
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|)
block|{
name|struct
name|c_typespec
name|ret
decl_stmt|;
name|tree
name|attrs
decl_stmt|;
name|tree
name|ident
init|=
name|NULL_TREE
decl_stmt|;
name|enum
name|tree_code
name|code
decl_stmt|;
switch|switch
condition|(
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
operator|->
name|keyword
condition|)
block|{
case|case
name|RID_STRUCT
case|:
name|code
operator|=
name|RECORD_TYPE
expr_stmt|;
break|break;
case|case
name|RID_UNION
case|:
name|code
operator|=
name|UNION_TYPE
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|attrs
operator|=
name|c_parser_attributes
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_NAME
argument_list|)
condition|)
block|{
name|ident
operator|=
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
operator|->
name|value
expr_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_BRACE
argument_list|)
condition|)
block|{
comment|/* Parse a struct or union definition.  Start the scope of the 	 tag before parsing components.  */
name|tree
name|type
init|=
name|start_struct
argument_list|(
name|code
argument_list|,
name|ident
argument_list|)
decl_stmt|;
name|tree
name|postfix_attrs
decl_stmt|;
comment|/* We chain the components in reverse order, then put them in 	 forward order at the end.  Each struct-declaration may 	 declare multiple components (comma-separated), so we must use 	 chainon to join them, although when parsing each 	 struct-declaration we can use TREE_CHAIN directly.  	 The theory behind all this is that there will be more 	 semicolon separated fields than comma separated fields, and 	 so we'll be minimizing the number of node traversals required 	 by chainon.  */
name|tree
name|contents
init|=
name|NULL_TREE
decl_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Handle the Objective-C @defs construct, 	 e.g. foo(sizeof(struct{ @defs(ClassName) }));.  */
if|if
condition|(
name|c_parser_next_token_is_keyword
argument_list|(
name|parser
argument_list|,
name|RID_AT_DEFS
argument_list|)
condition|)
block|{
name|tree
name|name
decl_stmt|;
name|gcc_assert
argument_list|(
name|c_dialect_objc
argument_list|()
argument_list|)
expr_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|c_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_PAREN
argument_list|,
literal|"expected %<(%>"
argument_list|)
condition|)
goto|goto
name|end_at_defs
goto|;
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_NAME
argument_list|)
operator|&&
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
operator|->
name|id_kind
operator|==
name|C_ID_CLASSNAME
condition|)
block|{
name|name
operator|=
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
operator|->
name|value
expr_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|c_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected class name"
argument_list|)
expr_stmt|;
name|c_parser_skip_until_found
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
goto|goto
name|end_at_defs
goto|;
block|}
name|c_parser_skip_until_found
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
literal|"expected %<)%>"
argument_list|)
expr_stmt|;
name|contents
operator|=
name|nreverse
argument_list|(
name|objc_get_class_ivars
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|end_at_defs
label|:
comment|/* Parse the struct-declarations and semicolons.  Problems with 	 semicolons are diagnosed here; empty structures are diagnosed 	 elsewhere.  */
while|while
condition|(
name|true
condition|)
block|{
name|tree
name|decls
decl_stmt|;
comment|/* Parse any stray semicolon.  */
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_SEMICOLON
argument_list|)
condition|)
block|{
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"extra semicolon in struct or union specified"
argument_list|)
expr_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Stop if at the end of the struct or union contents.  */
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_BRACE
argument_list|)
condition|)
block|{
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Accept #pragmas at struct scope.  */
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_PRAGMA
argument_list|)
condition|)
block|{
name|c_parser_pragma
argument_list|(
name|parser
argument_list|,
name|pragma_external
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Parse some comma-separated declarations, but not the 	     trailing semicolon if any.  */
name|decls
operator|=
name|c_parser_struct_declaration
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|contents
operator|=
name|chainon
argument_list|(
name|decls
argument_list|,
name|contents
argument_list|)
expr_stmt|;
comment|/* If no semicolon follows, either we have a parse error or 	     are at the end of the struct or union and should 	     pedwarn.  */
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_SEMICOLON
argument_list|)
condition|)
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_BRACE
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"no semicolon at end of struct or union"
argument_list|)
expr_stmt|;
else|else
block|{
name|c_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected %<;%>"
argument_list|)
expr_stmt|;
name|c_parser_skip_until_found
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_BRACE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
name|postfix_attrs
operator|=
name|c_parser_attributes
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|ret
operator|.
name|spec
operator|=
name|finish_struct
argument_list|(
name|type
argument_list|,
name|nreverse
argument_list|(
name|contents
argument_list|)
argument_list|,
name|chainon
argument_list|(
name|attrs
argument_list|,
name|postfix_attrs
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|.
name|kind
operator|=
name|ctsk_tagdef
expr_stmt|;
return|return
name|ret
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|ident
condition|)
block|{
name|c_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected %<{%>"
argument_list|)
expr_stmt|;
name|ret
operator|.
name|spec
operator|=
name|error_mark_node
expr_stmt|;
name|ret
operator|.
name|kind
operator|=
name|ctsk_tagref
expr_stmt|;
return|return
name|ret
return|;
block|}
name|ret
operator|=
name|parser_xref_tag
argument_list|(
name|code
argument_list|,
name|ident
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Parse a struct-declaration (C90 6.5.2.1, C99 6.7.2.1), *without*    the trailing semicolon.     struct-declaration:      specifier-qualifier-list struct-declarator-list     specifier-qualifier-list:      type-specifier specifier-qualifier-list[opt]      type-qualifier specifier-qualifier-list[opt]      attributes specifier-qualifier-list[opt]     struct-declarator-list:      struct-declarator      struct-declarator-list , attributes[opt] struct-declarator     struct-declarator:      declarator attributes[opt]      declarator[opt] : constant-expression attributes[opt]     GNU extensions:     struct-declaration:      __extension__ struct-declaration      specifier-qualifier-list     Unlike the ISO C syntax, semicolons are handled elsewhere.  The use    of attributes where shown is a GNU extension.  In GNU C, we accept    any expression without commas in the syntax (assignment    expressions, not just conditional expressions); assignment    expressions will be diagnosed as non-constant.  */
end_comment

begin_function
specifier|static
name|tree
name|c_parser_struct_declaration
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|)
block|{
name|struct
name|c_declspecs
modifier|*
name|specs
decl_stmt|;
name|tree
name|prefix_attrs
decl_stmt|;
name|tree
name|all_prefix_attrs
decl_stmt|;
name|tree
name|decls
decl_stmt|;
if|if
condition|(
name|c_parser_next_token_is_keyword
argument_list|(
name|parser
argument_list|,
name|RID_EXTENSION
argument_list|)
condition|)
block|{
name|int
name|ext
decl_stmt|;
name|tree
name|decl
decl_stmt|;
name|ext
operator|=
name|disable_extension_diagnostics
argument_list|()
expr_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|decl
operator|=
name|c_parser_struct_declaration
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|restore_extension_diagnostics
argument_list|(
name|ext
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
name|specs
operator|=
name|build_null_declspecs
argument_list|()
expr_stmt|;
name|c_parser_declspecs
argument_list|(
name|parser
argument_list|,
name|specs
argument_list|,
name|false
argument_list|,
name|true
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|parser
operator|->
name|error
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
operator|!
name|specs
operator|->
name|declspecs_seen_p
condition|)
block|{
name|c_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected specifier-qualifier-list"
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
name|finish_declspecs
argument_list|(
name|specs
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_SEMICOLON
argument_list|)
condition|)
block|{
name|tree
name|ret
decl_stmt|;
if|if
condition|(
operator|!
name|specs
operator|->
name|type_seen_p
condition|)
block|{
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"ISO C forbids member declarations with no members"
argument_list|)
expr_stmt|;
name|shadow_tag_warned
argument_list|(
name|specs
argument_list|,
name|pedantic
argument_list|)
expr_stmt|;
name|ret
operator|=
name|NULL_TREE
expr_stmt|;
block|}
else|else
block|{
comment|/* Support for unnamed structs or unions as members of 	     structs or unions (which is [a] useful and [b] supports 	     MS P-SDK).  */
name|ret
operator|=
name|grokfield
argument_list|(
name|build_id_declarator
argument_list|(
name|NULL_TREE
argument_list|)
argument_list|,
name|specs
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
name|pending_xref_error
argument_list|()
expr_stmt|;
name|prefix_attrs
operator|=
name|specs
operator|->
name|attrs
expr_stmt|;
name|all_prefix_attrs
operator|=
name|prefix_attrs
expr_stmt|;
name|specs
operator|->
name|attrs
operator|=
name|NULL_TREE
expr_stmt|;
name|decls
operator|=
name|NULL_TREE
expr_stmt|;
while|while
condition|(
name|true
condition|)
block|{
comment|/* Declaring one or more declarators or un-named bit-fields.  */
name|struct
name|c_declarator
modifier|*
name|declarator
decl_stmt|;
name|bool
name|dummy
init|=
name|false
decl_stmt|;
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_COLON
argument_list|)
condition|)
name|declarator
operator|=
name|build_id_declarator
argument_list|(
name|NULL_TREE
argument_list|)
expr_stmt|;
else|else
name|declarator
operator|=
name|c_parser_declarator
argument_list|(
name|parser
argument_list|,
name|specs
operator|->
name|type_seen_p
argument_list|,
name|C_DTR_NORMAL
argument_list|,
operator|&
name|dummy
argument_list|)
expr_stmt|;
if|if
condition|(
name|declarator
operator|==
name|NULL
condition|)
block|{
name|c_parser_skip_to_end_of_block_or_statement
argument_list|(
name|parser
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_COLON
argument_list|)
operator|||
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_COMMA
argument_list|)
operator|||
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_SEMICOLON
argument_list|)
operator|||
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_BRACE
argument_list|)
operator|||
name|c_parser_next_token_is_keyword
argument_list|(
name|parser
argument_list|,
name|RID_ATTRIBUTE
argument_list|)
condition|)
block|{
name|tree
name|postfix_attrs
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|width
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|d
decl_stmt|;
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_COLON
argument_list|)
condition|)
block|{
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|width
operator|=
name|c_parser_expr_no_commas
argument_list|(
name|parser
argument_list|,
name|NULL
argument_list|)
operator|.
name|value
expr_stmt|;
block|}
if|if
condition|(
name|c_parser_next_token_is_keyword
argument_list|(
name|parser
argument_list|,
name|RID_ATTRIBUTE
argument_list|)
condition|)
name|postfix_attrs
operator|=
name|c_parser_attributes
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|d
operator|=
name|grokfield
argument_list|(
name|declarator
argument_list|,
name|specs
argument_list|,
name|width
argument_list|)
expr_stmt|;
name|decl_attributes
argument_list|(
operator|&
name|d
argument_list|,
name|chainon
argument_list|(
name|postfix_attrs
argument_list|,
name|all_prefix_attrs
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|d
argument_list|)
operator|=
name|decls
expr_stmt|;
name|decls
operator|=
name|d
expr_stmt|;
if|if
condition|(
name|c_parser_next_token_is_keyword
argument_list|(
name|parser
argument_list|,
name|RID_ATTRIBUTE
argument_list|)
condition|)
name|all_prefix_attrs
operator|=
name|chainon
argument_list|(
name|c_parser_attributes
argument_list|(
name|parser
argument_list|)
argument_list|,
name|prefix_attrs
argument_list|)
expr_stmt|;
else|else
name|all_prefix_attrs
operator|=
name|prefix_attrs
expr_stmt|;
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_COMMA
argument_list|)
condition|)
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_SEMICOLON
argument_list|)
operator|||
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_BRACE
argument_list|)
condition|)
block|{
comment|/* Semicolon consumed in caller.  */
break|break;
block|}
else|else
block|{
name|c_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected %<,%>, %<;%> or %<}%>"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|c_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected %<:%>, %<,%>, %<;%>, %<}%> or "
literal|"%<__attribute__%>"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
name|decls
return|;
block|}
end_function

begin_comment
comment|/* Parse a typeof specifier (a GNU extension).     typeof-specifier:      typeof ( expression )      typeof ( type-name ) */
end_comment

begin_function
specifier|static
name|struct
name|c_typespec
name|c_parser_typeof_specifier
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|)
block|{
name|struct
name|c_typespec
name|ret
decl_stmt|;
name|ret
operator|.
name|kind
operator|=
name|ctsk_typeof
expr_stmt|;
name|ret
operator|.
name|spec
operator|=
name|error_mark_node
expr_stmt|;
name|gcc_assert
argument_list|(
name|c_parser_next_token_is_keyword
argument_list|(
name|parser
argument_list|,
name|RID_TYPEOF
argument_list|)
argument_list|)
expr_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|skip_evaluation
operator|++
expr_stmt|;
name|in_typeof
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|c_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_PAREN
argument_list|,
literal|"expected %<(%>"
argument_list|)
condition|)
block|{
name|skip_evaluation
operator|--
expr_stmt|;
name|in_typeof
operator|--
expr_stmt|;
return|return
name|ret
return|;
block|}
if|if
condition|(
name|c_parser_next_token_starts_typename
argument_list|(
name|parser
argument_list|)
condition|)
block|{
name|struct
name|c_type_name
modifier|*
name|type
init|=
name|c_parser_type_name
argument_list|(
name|parser
argument_list|)
decl_stmt|;
name|skip_evaluation
operator|--
expr_stmt|;
name|in_typeof
operator|--
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|NULL
condition|)
block|{
name|ret
operator|.
name|spec
operator|=
name|groktypename
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|pop_maybe_used
argument_list|(
name|variably_modified_type_p
argument_list|(
name|ret
operator|.
name|spec
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|bool
name|was_vm
decl_stmt|;
name|struct
name|c_expr
name|expr
init|=
name|c_parser_expression
argument_list|(
name|parser
argument_list|)
decl_stmt|;
name|skip_evaluation
operator|--
expr_stmt|;
name|in_typeof
operator|--
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
operator|.
name|value
argument_list|)
operator|==
name|COMPONENT_REF
operator|&&
name|DECL_C_BIT_FIELD
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
operator|.
name|value
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
name|error
argument_list|(
literal|"%<typeof%> applied to a bit-field"
argument_list|)
expr_stmt|;
name|ret
operator|.
name|spec
operator|=
name|TREE_TYPE
argument_list|(
name|expr
operator|.
name|value
argument_list|)
expr_stmt|;
name|was_vm
operator|=
name|variably_modified_type_p
argument_list|(
name|ret
operator|.
name|spec
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* This should be returned with the type so that when the type 	 is evaluated, this can be evaluated.  For now, we avoid 	 evaluation when the context might.  */
if|if
condition|(
operator|!
name|skip_evaluation
operator|&&
name|was_vm
condition|)
block|{
name|tree
name|e
init|=
name|expr
operator|.
name|value
decl_stmt|;
comment|/* If the expression is not of a type to which we cannot assign a line 	     number, wrap the thing in a no-op NOP_EXPR.  */
if|if
condition|(
name|DECL_P
argument_list|(
name|e
argument_list|)
operator|||
name|CONSTANT_CLASS_P
argument_list|(
name|e
argument_list|)
condition|)
name|e
operator|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|EXPR_P
argument_list|(
name|e
argument_list|)
condition|)
name|SET_EXPR_LOCATION
argument_list|(
name|e
argument_list|,
name|input_location
argument_list|)
expr_stmt|;
name|add_stmt
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
name|pop_maybe_used
argument_list|(
name|was_vm
argument_list|)
expr_stmt|;
block|}
name|c_parser_skip_until_found
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
literal|"expected %<)%>"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Parse a declarator, possibly an abstract declarator (C90 6.5.4,    6.5.5, C99 6.7.5, 6.7.6).  If TYPE_SEEN_P then a typedef name may    be redeclared; otherwise it may not.  KIND indicates which kind of    declarator is wanted.  Returns a valid declarator except in the    case of a syntax error in which case NULL is returned.  *SEEN_ID is    set to true if an identifier being declared is seen; this is used    to diagnose bad forms of abstract array declarators and to    determine whether an identifier list is syntactically permitted.     declarator:      pointer[opt] direct-declarator     direct-declarator:      identifier      ( attributes[opt] declarator )      direct-declarator array-declarator      direct-declarator ( parameter-type-list )      direct-declarator ( identifier-list[opt] )     pointer:      * type-qualifier-list[opt]      * type-qualifier-list[opt] pointer     type-qualifier-list:      type-qualifier      attributes      type-qualifier-list type-qualifier      type-qualifier-list attributes     parameter-type-list:      parameter-list      parameter-list , ...     parameter-list:      parameter-declaration      parameter-list , parameter-declaration     parameter-declaration:      declaration-specifiers declarator attributes[opt]      declaration-specifiers abstract-declarator[opt] attributes[opt]     identifier-list:      identifier      identifier-list , identifier     abstract-declarator:      pointer      pointer[opt] direct-abstract-declarator     direct-abstract-declarator:      ( attributes[opt] abstract-declarator )      direct-abstract-declarator[opt] array-declarator      direct-abstract-declarator[opt] ( parameter-type-list[opt] )     GNU extensions:     direct-declarator:      direct-declarator ( parameter-forward-declarations 			 parameter-type-list[opt] )     direct-abstract-declarator:      direct-abstract-declarator[opt] ( parameter-forward-declarations 				       parameter-type-list[opt] )     parameter-forward-declarations:      parameter-list ;      parameter-forward-declarations parameter-list ;     The uses of attributes shown above are GNU extensions.     Some forms of array declarator are not included in C99 in the    syntax for abstract declarators; these are disallowed elsewhere.    This may be a defect (DR#289).     This function also accepts an omitted abstract declarator as being    an abstract declarator, although not part of the formal syntax.  */
end_comment

begin_function
specifier|static
name|struct
name|c_declarator
modifier|*
name|c_parser_declarator
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|,
name|bool
name|type_seen_p
parameter_list|,
name|c_dtr_syn
name|kind
parameter_list|,
name|bool
modifier|*
name|seen_id
parameter_list|)
block|{
comment|/* Parse any initial pointer part.  */
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_MULT
argument_list|)
condition|)
block|{
name|struct
name|c_declspecs
modifier|*
name|quals_attrs
init|=
name|build_null_declspecs
argument_list|()
decl_stmt|;
name|struct
name|c_declarator
modifier|*
name|inner
decl_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|c_parser_declspecs
argument_list|(
name|parser
argument_list|,
name|quals_attrs
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|inner
operator|=
name|c_parser_declarator
argument_list|(
name|parser
argument_list|,
name|type_seen_p
argument_list|,
name|kind
argument_list|,
name|seen_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|inner
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
else|else
return|return
name|make_pointer_declarator
argument_list|(
name|quals_attrs
argument_list|,
name|inner
argument_list|)
return|;
block|}
comment|/* Now we have a direct declarator, direct abstract declarator or      nothing (which counts as a direct abstract declarator here).  */
return|return
name|c_parser_direct_declarator
argument_list|(
name|parser
argument_list|,
name|type_seen_p
argument_list|,
name|kind
argument_list|,
name|seen_id
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Parse a direct declarator or direct abstract declarator; arguments    as c_parser_declarator.  */
end_comment

begin_function
specifier|static
name|struct
name|c_declarator
modifier|*
name|c_parser_direct_declarator
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|,
name|bool
name|type_seen_p
parameter_list|,
name|c_dtr_syn
name|kind
parameter_list|,
name|bool
modifier|*
name|seen_id
parameter_list|)
block|{
comment|/* The direct declarator must start with an identifier (possibly      omitted) or a parenthesized declarator (possibly abstract).  In      an ordinary declarator, initial parentheses must start a      parenthesized declarator.  In an abstract declarator or parameter      declarator, they could start a parenthesized declarator or a      parameter list.  To tell which, the open parenthesis and any      following attributes must be read.  If a declaration specifier      follows, then it is a parameter list; if the specifier is a      typedef name, there might be an ambiguity about redeclaring it,      which is resolved in the direction of treating it as a typedef      name.  If a close parenthesis follows, it is also an empty      parameter list, as the syntax does not permit empty abstract      declarators.  Otherwise, it is a parenthesized declarator (in      which case the analysis may be repeated inside it, recursively).       ??? There is an ambiguity in a parameter declaration "int      (__attribute__((foo)) x)", where x is not a typedef name: it      could be an abstract declarator for a function, or declare x with      parentheses.  The proper resolution of this ambiguity needs      documenting.  At present we follow an accident of the old      parser's implementation, whereby the first parameter must have      some declaration specifiers other than just attributes.  Thus as      a parameter declaration it is treated as a parenthesized      parameter named x, and as an abstract declarator it is      rejected.       ??? Also following the old parser, attributes inside an empty      parameter list are ignored, making it a list not yielding a      prototype, rather than giving an error or making it have one      parameter with implicit type int.       ??? Also following the old parser, typedef names may be      redeclared in declarators, but not Objective-C class names.  */
if|if
condition|(
name|kind
operator|!=
name|C_DTR_ABSTRACT
operator|&&
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_NAME
argument_list|)
operator|&&
operator|(
operator|(
name|type_seen_p
operator|&&
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
operator|->
name|id_kind
operator|==
name|C_ID_TYPENAME
operator|)
operator|||
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
operator|->
name|id_kind
operator|==
name|C_ID_ID
operator|)
condition|)
block|{
name|struct
name|c_declarator
modifier|*
name|inner
init|=
name|build_id_declarator
argument_list|(
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
operator|->
name|value
argument_list|)
decl_stmt|;
operator|*
name|seen_id
operator|=
name|true
expr_stmt|;
name|inner
operator|->
name|id_loc
operator|=
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
operator|->
name|location
expr_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
return|return
name|c_parser_direct_declarator_inner
argument_list|(
name|parser
argument_list|,
operator|*
name|seen_id
argument_list|,
name|inner
argument_list|)
return|;
block|}
if|if
condition|(
name|kind
operator|!=
name|C_DTR_NORMAL
operator|&&
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_SQUARE
argument_list|)
condition|)
block|{
name|struct
name|c_declarator
modifier|*
name|inner
init|=
name|build_id_declarator
argument_list|(
name|NULL_TREE
argument_list|)
decl_stmt|;
return|return
name|c_parser_direct_declarator_inner
argument_list|(
name|parser
argument_list|,
operator|*
name|seen_id
argument_list|,
name|inner
argument_list|)
return|;
block|}
comment|/* Either we are at the end of an abstract declarator, or we have      parentheses.  */
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_PAREN
argument_list|)
condition|)
block|{
name|tree
name|attrs
decl_stmt|;
name|struct
name|c_declarator
modifier|*
name|inner
decl_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|attrs
operator|=
name|c_parser_attributes
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|!=
name|C_DTR_NORMAL
operator|&&
operator|(
name|c_parser_next_token_starts_declspecs
argument_list|(
name|parser
argument_list|)
operator|||
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|)
operator|)
condition|)
block|{
name|struct
name|c_arg_info
modifier|*
name|args
init|=
name|c_parser_parms_declarator
argument_list|(
name|parser
argument_list|,
name|kind
operator|==
name|C_DTR_NORMAL
argument_list|,
name|attrs
argument_list|)
decl_stmt|;
if|if
condition|(
name|args
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
else|else
block|{
name|inner
operator|=
name|build_function_declarator
argument_list|(
name|args
argument_list|,
name|build_id_declarator
argument_list|(
name|NULL_TREE
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|c_parser_direct_declarator_inner
argument_list|(
name|parser
argument_list|,
operator|*
name|seen_id
argument_list|,
name|inner
argument_list|)
return|;
block|}
block|}
comment|/* A parenthesized declarator.  */
name|inner
operator|=
name|c_parser_declarator
argument_list|(
name|parser
argument_list|,
name|type_seen_p
argument_list|,
name|kind
argument_list|,
name|seen_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|inner
operator|!=
name|NULL
operator|&&
name|attrs
operator|!=
name|NULL
condition|)
name|inner
operator|=
name|build_attrs_declarator
argument_list|(
name|attrs
argument_list|,
name|inner
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|)
condition|)
block|{
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|inner
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
else|else
return|return
name|c_parser_direct_declarator_inner
argument_list|(
name|parser
argument_list|,
operator|*
name|seen_id
argument_list|,
name|inner
argument_list|)
return|;
block|}
else|else
block|{
name|c_parser_skip_until_found
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
literal|"expected %<)%>"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|kind
operator|==
name|C_DTR_NORMAL
condition|)
block|{
name|c_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected identifier or %<(%>"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
else|else
return|return
name|build_id_declarator
argument_list|(
name|NULL_TREE
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Parse part of a direct declarator or direct abstract declarator,    given that some (in INNER) has already been parsed; ID_PRESENT is    true if an identifier is present, false for an abstract    declarator.  */
end_comment

begin_function
specifier|static
name|struct
name|c_declarator
modifier|*
name|c_parser_direct_declarator_inner
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|,
name|bool
name|id_present
parameter_list|,
name|struct
name|c_declarator
modifier|*
name|inner
parameter_list|)
block|{
comment|/* Parse a sequence of array declarators and parameter lists.  */
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_SQUARE
argument_list|)
condition|)
block|{
name|struct
name|c_declarator
modifier|*
name|declarator
decl_stmt|;
name|struct
name|c_declspecs
modifier|*
name|quals_attrs
init|=
name|build_null_declspecs
argument_list|()
decl_stmt|;
name|bool
name|static_seen
decl_stmt|;
name|bool
name|star_seen
decl_stmt|;
name|tree
name|dimen
decl_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|c_parser_declspecs
argument_list|(
name|parser
argument_list|,
name|quals_attrs
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|static_seen
operator|=
name|c_parser_next_token_is_keyword
argument_list|(
name|parser
argument_list|,
name|RID_STATIC
argument_list|)
expr_stmt|;
if|if
condition|(
name|static_seen
condition|)
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|static_seen
operator|&&
operator|!
name|quals_attrs
operator|->
name|declspecs_seen_p
condition|)
name|c_parser_declspecs
argument_list|(
name|parser
argument_list|,
name|quals_attrs
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|quals_attrs
operator|->
name|declspecs_seen_p
condition|)
name|quals_attrs
operator|=
name|NULL
expr_stmt|;
comment|/* If "static" is present, there must be an array dimension. 	 Otherwise, there may be a dimension, "*", or no 	 dimension.  */
if|if
condition|(
name|static_seen
condition|)
block|{
name|star_seen
operator|=
name|false
expr_stmt|;
name|dimen
operator|=
name|c_parser_expr_no_commas
argument_list|(
name|parser
argument_list|,
name|NULL
argument_list|)
operator|.
name|value
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_SQUARE
argument_list|)
condition|)
block|{
name|dimen
operator|=
name|NULL_TREE
expr_stmt|;
name|star_seen
operator|=
name|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_MULT
argument_list|)
condition|)
block|{
if|if
condition|(
name|c_parser_peek_2nd_token
argument_list|(
name|parser
argument_list|)
operator|->
name|type
operator|==
name|CPP_CLOSE_SQUARE
condition|)
block|{
name|dimen
operator|=
name|NULL_TREE
expr_stmt|;
name|star_seen
operator|=
name|true
expr_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|star_seen
operator|=
name|false
expr_stmt|;
name|dimen
operator|=
name|c_parser_expr_no_commas
argument_list|(
name|parser
argument_list|,
name|NULL
argument_list|)
operator|.
name|value
expr_stmt|;
block|}
block|}
else|else
block|{
name|star_seen
operator|=
name|false
expr_stmt|;
name|dimen
operator|=
name|c_parser_expr_no_commas
argument_list|(
name|parser
argument_list|,
name|NULL
argument_list|)
operator|.
name|value
expr_stmt|;
block|}
block|}
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_SQUARE
argument_list|)
condition|)
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
else|else
block|{
name|c_parser_skip_until_found
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_SQUARE
argument_list|,
literal|"expected %<]%>"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|declarator
operator|=
name|build_array_declarator
argument_list|(
name|dimen
argument_list|,
name|quals_attrs
argument_list|,
name|static_seen
argument_list|,
name|star_seen
argument_list|)
expr_stmt|;
if|if
condition|(
name|declarator
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|inner
operator|=
name|set_array_declarator_inner
argument_list|(
name|declarator
argument_list|,
name|inner
argument_list|,
operator|!
name|id_present
argument_list|)
expr_stmt|;
return|return
name|c_parser_direct_declarator_inner
argument_list|(
name|parser
argument_list|,
name|id_present
argument_list|,
name|inner
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_PAREN
argument_list|)
condition|)
block|{
name|tree
name|attrs
decl_stmt|;
name|struct
name|c_arg_info
modifier|*
name|args
decl_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|attrs
operator|=
name|c_parser_attributes
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|args
operator|=
name|c_parser_parms_declarator
argument_list|(
name|parser
argument_list|,
name|id_present
argument_list|,
name|attrs
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
else|else
block|{
name|inner
operator|=
name|build_function_declarator
argument_list|(
name|args
argument_list|,
name|inner
argument_list|)
expr_stmt|;
return|return
name|c_parser_direct_declarator_inner
argument_list|(
name|parser
argument_list|,
name|id_present
argument_list|,
name|inner
argument_list|)
return|;
block|}
block|}
return|return
name|inner
return|;
block|}
end_function

begin_comment
comment|/* Parse a parameter list or identifier list, including the closing    parenthesis but not the opening one.  ATTRS are the attributes at    the start of the list.  ID_LIST_OK is true if an identifier list is    acceptable; such a list must not have attributes at the start.  */
end_comment

begin_function
specifier|static
name|struct
name|c_arg_info
modifier|*
name|c_parser_parms_declarator
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|,
name|bool
name|id_list_ok
parameter_list|,
name|tree
name|attrs
parameter_list|)
block|{
name|push_scope
argument_list|()
expr_stmt|;
name|declare_parm_level
argument_list|()
expr_stmt|;
comment|/* If the list starts with an identifier, it is an identifier list.      Otherwise, it is either a prototype list or an empty list.  */
if|if
condition|(
name|id_list_ok
operator|&&
operator|!
name|attrs
operator|&&
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_NAME
argument_list|)
operator|&&
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
operator|->
name|id_kind
operator|==
name|C_ID_ID
condition|)
block|{
name|tree
name|list
init|=
name|NULL_TREE
decl_stmt|,
modifier|*
name|nextp
init|=
operator|&
name|list
decl_stmt|;
while|while
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_NAME
argument_list|)
operator|&&
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
operator|->
name|id_kind
operator|==
name|C_ID_ID
condition|)
block|{
operator|*
name|nextp
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
operator|->
name|value
argument_list|)
expr_stmt|;
name|nextp
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
operator|*
name|nextp
argument_list|)
expr_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_parser_next_token_is_not
argument_list|(
name|parser
argument_list|,
name|CPP_COMMA
argument_list|)
condition|)
break|break;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|)
condition|)
block|{
name|c_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected identifier"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|)
condition|)
block|{
name|struct
name|c_arg_info
modifier|*
name|ret
init|=
name|XOBNEW
argument_list|(
operator|&
name|parser_obstack
argument_list|,
expr|struct
name|c_arg_info
argument_list|)
decl_stmt|;
name|ret
operator|->
name|parms
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|tags
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|types
operator|=
name|list
expr_stmt|;
name|ret
operator|->
name|others
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|pending_sizes
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|had_vla_unspec
operator|=
literal|0
expr_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|pop_scope
argument_list|()
expr_stmt|;
return|return
name|ret
return|;
block|}
else|else
block|{
name|c_parser_skip_until_found
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
literal|"expected %<)%>"
argument_list|)
expr_stmt|;
name|pop_scope
argument_list|()
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
else|else
block|{
name|struct
name|c_arg_info
modifier|*
name|ret
init|=
name|c_parser_parms_list_declarator
argument_list|(
name|parser
argument_list|,
name|attrs
argument_list|)
decl_stmt|;
name|pop_scope
argument_list|()
expr_stmt|;
return|return
name|ret
return|;
block|}
block|}
end_function

begin_comment
comment|/* Parse a parameter list (possibly empty), including the closing    parenthesis but not the opening one.  ATTRS are the attributes at    the start of the list.  */
end_comment

begin_function
specifier|static
name|struct
name|c_arg_info
modifier|*
name|c_parser_parms_list_declarator
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|,
name|tree
name|attrs
parameter_list|)
block|{
name|bool
name|good_parm
init|=
name|false
decl_stmt|;
comment|/* ??? Following the old parser, forward parameter declarations may      use abstract declarators, and if no real parameter declarations      follow the forward declarations then this is not diagnosed.  Also      note as above that attributes are ignored as the only contents of      the parentheses, or as the only contents after forward      declarations.  */
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|)
condition|)
block|{
name|struct
name|c_arg_info
modifier|*
name|ret
init|=
name|XOBNEW
argument_list|(
operator|&
name|parser_obstack
argument_list|,
expr|struct
name|c_arg_info
argument_list|)
decl_stmt|;
name|ret
operator|->
name|parms
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|tags
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|types
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|others
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|pending_sizes
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|had_vla_unspec
operator|=
literal|0
expr_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_ELLIPSIS
argument_list|)
condition|)
block|{
name|struct
name|c_arg_info
modifier|*
name|ret
init|=
name|XOBNEW
argument_list|(
operator|&
name|parser_obstack
argument_list|,
expr|struct
name|c_arg_info
argument_list|)
decl_stmt|;
name|ret
operator|->
name|parms
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|tags
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|others
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|pending_sizes
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|had_vla_unspec
operator|=
literal|0
expr_stmt|;
comment|/* Suppress -Wold-style-definition for this case.  */
name|ret
operator|->
name|types
operator|=
name|error_mark_node
expr_stmt|;
name|error
argument_list|(
literal|"ISO C requires a named argument before %<...%>"
argument_list|)
expr_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|)
condition|)
block|{
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
else|else
block|{
name|c_parser_skip_until_found
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
literal|"expected %<)%>"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
comment|/* Nonempty list of parameters, either terminated with semicolon      (forward declarations; recurse) or with close parenthesis (normal      function) or with ", ... )" (variadic function).  */
while|while
condition|(
name|true
condition|)
block|{
comment|/* Parse a parameter.  */
name|struct
name|c_parm
modifier|*
name|parm
init|=
name|c_parser_parameter_declaration
argument_list|(
name|parser
argument_list|,
name|attrs
argument_list|)
decl_stmt|;
name|attrs
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|parm
operator|!=
name|NULL
condition|)
block|{
name|good_parm
operator|=
name|true
expr_stmt|;
name|push_parm_decl
argument_list|(
name|parm
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_SEMICOLON
argument_list|)
condition|)
block|{
name|tree
name|new_attrs
decl_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|mark_forward_parm_decls
argument_list|()
expr_stmt|;
name|new_attrs
operator|=
name|c_parser_attributes
argument_list|(
name|parser
argument_list|)
expr_stmt|;
return|return
name|c_parser_parms_list_declarator
argument_list|(
name|parser
argument_list|,
name|new_attrs
argument_list|)
return|;
block|}
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|)
condition|)
block|{
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|good_parm
condition|)
return|return
name|get_parm_info
argument_list|(
name|false
argument_list|)
return|;
else|else
block|{
name|struct
name|c_arg_info
modifier|*
name|ret
init|=
name|XOBNEW
argument_list|(
operator|&
name|parser_obstack
argument_list|,
expr|struct
name|c_arg_info
argument_list|)
decl_stmt|;
name|ret
operator|->
name|parms
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|tags
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|types
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|others
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|pending_sizes
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|had_vla_unspec
operator|=
literal|0
expr_stmt|;
return|return
name|ret
return|;
block|}
block|}
if|if
condition|(
operator|!
name|c_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_COMMA
argument_list|,
literal|"expected %<;%>, %<,%> or %<)%>"
argument_list|)
condition|)
block|{
name|c_parser_skip_until_found
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_ELLIPSIS
argument_list|)
condition|)
block|{
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|)
condition|)
block|{
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|good_parm
condition|)
return|return
name|get_parm_info
argument_list|(
name|true
argument_list|)
return|;
else|else
block|{
name|struct
name|c_arg_info
modifier|*
name|ret
init|=
name|XOBNEW
argument_list|(
operator|&
name|parser_obstack
argument_list|,
expr|struct
name|c_arg_info
argument_list|)
decl_stmt|;
name|ret
operator|->
name|parms
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|tags
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|types
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|others
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|pending_sizes
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|had_vla_unspec
operator|=
literal|0
expr_stmt|;
return|return
name|ret
return|;
block|}
block|}
else|else
block|{
name|c_parser_skip_until_found
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
literal|"expected %<)%>"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Parse a parameter declaration.  ATTRS are the attributes at the    start of the declaration if it is the first parameter.  */
end_comment

begin_function
specifier|static
name|struct
name|c_parm
modifier|*
name|c_parser_parameter_declaration
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|,
name|tree
name|attrs
parameter_list|)
block|{
name|struct
name|c_declspecs
modifier|*
name|specs
decl_stmt|;
name|struct
name|c_declarator
modifier|*
name|declarator
decl_stmt|;
name|tree
name|prefix_attrs
decl_stmt|;
name|tree
name|postfix_attrs
init|=
name|NULL_TREE
decl_stmt|;
name|bool
name|dummy
init|=
name|false
decl_stmt|;
if|if
condition|(
operator|!
name|c_parser_next_token_starts_declspecs
argument_list|(
name|parser
argument_list|)
condition|)
block|{
comment|/* ??? In some Objective-C cases '...' isn't applicable so there 	 should be a different message.  */
name|c_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected declaration specifiers or %<...%>"
argument_list|)
expr_stmt|;
name|c_parser_skip_to_end_of_parameter
argument_list|(
name|parser
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|specs
operator|=
name|build_null_declspecs
argument_list|()
expr_stmt|;
if|if
condition|(
name|attrs
condition|)
block|{
name|declspecs_add_attrs
argument_list|(
name|specs
argument_list|,
name|attrs
argument_list|)
expr_stmt|;
name|attrs
operator|=
name|NULL_TREE
expr_stmt|;
block|}
name|c_parser_declspecs
argument_list|(
name|parser
argument_list|,
name|specs
argument_list|,
name|true
argument_list|,
name|true
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|finish_declspecs
argument_list|(
name|specs
argument_list|)
expr_stmt|;
name|pending_xref_error
argument_list|()
expr_stmt|;
name|prefix_attrs
operator|=
name|specs
operator|->
name|attrs
expr_stmt|;
name|specs
operator|->
name|attrs
operator|=
name|NULL_TREE
expr_stmt|;
name|declarator
operator|=
name|c_parser_declarator
argument_list|(
name|parser
argument_list|,
name|specs
operator|->
name|type_seen_p
argument_list|,
name|C_DTR_PARM
argument_list|,
operator|&
name|dummy
argument_list|)
expr_stmt|;
if|if
condition|(
name|declarator
operator|==
name|NULL
condition|)
block|{
name|c_parser_skip_until_found
argument_list|(
name|parser
argument_list|,
name|CPP_COMMA
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|c_parser_next_token_is_keyword
argument_list|(
name|parser
argument_list|,
name|RID_ATTRIBUTE
argument_list|)
condition|)
name|postfix_attrs
operator|=
name|c_parser_attributes
argument_list|(
name|parser
argument_list|)
expr_stmt|;
return|return
name|build_c_parm
argument_list|(
name|specs
argument_list|,
name|chainon
argument_list|(
name|postfix_attrs
argument_list|,
name|prefix_attrs
argument_list|)
argument_list|,
name|declarator
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Parse a string literal in an asm expression.  It should not be    translated, and wide string literals are an error although    permitted by the syntax.  This is a GNU extension.     asm-string-literal:      string-literal     ??? At present, following the old parser, the caller needs to have    set c_lex_string_translate to 0.  It would be better to follow the    C++ parser rather than using the c_lex_string_translate kludge.  */
end_comment

begin_function
specifier|static
name|tree
name|c_parser_asm_string_literal
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|str
decl_stmt|;
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_STRING
argument_list|)
condition|)
block|{
name|str
operator|=
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
operator|->
name|value
expr_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_WSTRING
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"wide string literal in %<asm%>"
argument_list|)
expr_stmt|;
name|str
operator|=
name|build_string
argument_list|(
literal|1
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|c_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected string literal"
argument_list|)
expr_stmt|;
name|str
operator|=
name|NULL_TREE
expr_stmt|;
block|}
return|return
name|str
return|;
block|}
end_function

begin_comment
comment|/* Parse a simple asm expression.  This is used in restricted    contexts, where a full expression with inputs and outputs does not    make sense.  This is a GNU extension.     simple-asm-expr:      asm ( asm-string-literal ) */
end_comment

begin_function
specifier|static
name|tree
name|c_parser_simple_asm_expr
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|str
decl_stmt|;
name|gcc_assert
argument_list|(
name|c_parser_next_token_is_keyword
argument_list|(
name|parser
argument_list|,
name|RID_ASM
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ??? Follow the C++ parser rather than using the      c_lex_string_translate kludge.  */
name|c_lex_string_translate
operator|=
literal|0
expr_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|c_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_PAREN
argument_list|,
literal|"expected %<(%>"
argument_list|)
condition|)
block|{
name|c_lex_string_translate
operator|=
literal|1
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
name|str
operator|=
name|c_parser_asm_string_literal
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|c_lex_string_translate
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|c_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
literal|"expected %<)%>"
argument_list|)
condition|)
block|{
name|c_parser_skip_until_found
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
return|return
name|str
return|;
block|}
end_function

begin_comment
comment|/* Parse (possibly empty) attributes.  This is a GNU extension.     attributes:      empty      attributes attribute     attribute:      __attribute__ ( ( attribute-list ) )     attribute-list:      attrib      attribute_list , attrib     attrib:      empty      any-word      any-word ( identifier )      any-word ( identifier , nonempty-expr-list )      any-word ( expr-list )     where the "identifier" must not be declared as a type, and    "any-word" may be any identifier (including one declared as a    type), a reserved word storage class specifier, type specifier or    type qualifier.  ??? This still leaves out most reserved keywords    (following the old parser), shouldn't we include them, and why not    allow identifiers declared as types to start the arguments?  */
end_comment

begin_function
specifier|static
name|tree
name|c_parser_attributes
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|attrs
init|=
name|NULL_TREE
decl_stmt|;
while|while
condition|(
name|c_parser_next_token_is_keyword
argument_list|(
name|parser
argument_list|,
name|RID_ATTRIBUTE
argument_list|)
condition|)
block|{
comment|/* ??? Follow the C++ parser rather than using the 	 c_lex_string_translate kludge.  */
name|c_lex_string_translate
operator|=
literal|0
expr_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|c_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_PAREN
argument_list|,
literal|"expected %<(%>"
argument_list|)
condition|)
block|{
name|c_lex_string_translate
operator|=
literal|1
expr_stmt|;
return|return
name|attrs
return|;
block|}
if|if
condition|(
operator|!
name|c_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_PAREN
argument_list|,
literal|"expected %<(%>"
argument_list|)
condition|)
block|{
name|c_lex_string_translate
operator|=
literal|1
expr_stmt|;
name|c_parser_skip_until_found
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|attrs
return|;
block|}
comment|/* Parse the attribute list.  */
while|while
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_COMMA
argument_list|)
operator|||
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_NAME
argument_list|)
operator|||
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_KEYWORD
argument_list|)
condition|)
block|{
name|tree
name|attr
decl_stmt|,
name|attr_name
decl_stmt|,
name|attr_args
decl_stmt|;
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_COMMA
argument_list|)
condition|)
block|{
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_KEYWORD
argument_list|)
condition|)
block|{
comment|/* ??? See comment above about what keywords are 		 accepted here.  */
name|bool
name|ok
decl_stmt|;
switch|switch
condition|(
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
operator|->
name|keyword
condition|)
block|{
case|case
name|RID_STATIC
case|:
case|case
name|RID_UNSIGNED
case|:
case|case
name|RID_LONG
case|:
case|case
name|RID_CONST
case|:
case|case
name|RID_EXTERN
case|:
case|case
name|RID_REGISTER
case|:
case|case
name|RID_TYPEDEF
case|:
case|case
name|RID_SHORT
case|:
case|case
name|RID_INLINE
case|:
case|case
name|RID_VOLATILE
case|:
case|case
name|RID_SIGNED
case|:
case|case
name|RID_AUTO
case|:
case|case
name|RID_RESTRICT
case|:
case|case
name|RID_COMPLEX
case|:
case|case
name|RID_THREAD
case|:
case|case
name|RID_INT
case|:
case|case
name|RID_CHAR
case|:
case|case
name|RID_FLOAT
case|:
case|case
name|RID_DOUBLE
case|:
case|case
name|RID_VOID
case|:
case|case
name|RID_DFLOAT32
case|:
case|case
name|RID_DFLOAT64
case|:
case|case
name|RID_DFLOAT128
case|:
case|case
name|RID_BOOL
case|:
name|ok
operator|=
name|true
expr_stmt|;
break|break;
default|default:
name|ok
operator|=
name|false
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|ok
condition|)
break|break;
block|}
name|attr_name
operator|=
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
operator|->
name|value
expr_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_parser_next_token_is_not
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_PAREN
argument_list|)
condition|)
block|{
name|attr
operator|=
name|build_tree_list
argument_list|(
name|attr_name
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|attrs
operator|=
name|chainon
argument_list|(
name|attrs
argument_list|,
name|attr
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Parse the attribute contents.  If they start with an 	     identifier which is followed by a comma or close 	     parenthesis, then the arguments start with that 	     identifier; otherwise they are an expression list.  */
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_NAME
argument_list|)
operator|&&
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
operator|->
name|id_kind
operator|==
name|C_ID_ID
operator|&&
operator|(
operator|(
name|c_parser_peek_2nd_token
argument_list|(
name|parser
argument_list|)
operator|->
name|type
operator|==
name|CPP_COMMA
operator|)
operator|||
operator|(
name|c_parser_peek_2nd_token
argument_list|(
name|parser
argument_list|)
operator|->
name|type
operator|==
name|CPP_CLOSE_PAREN
operator|)
operator|)
condition|)
block|{
name|tree
name|arg1
init|=
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
operator|->
name|value
decl_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|)
condition|)
name|attr_args
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
else|else
block|{
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|attr_args
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|arg1
argument_list|,
name|c_parser_expr_list
argument_list|(
name|parser
argument_list|,
name|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|)
condition|)
name|attr_args
operator|=
name|NULL_TREE
expr_stmt|;
else|else
name|attr_args
operator|=
name|c_parser_expr_list
argument_list|(
name|parser
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
name|attr
operator|=
name|build_tree_list
argument_list|(
name|attr_name
argument_list|,
name|attr_args
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|)
condition|)
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
else|else
block|{
name|c_lex_string_translate
operator|=
literal|1
expr_stmt|;
name|c_parser_skip_until_found
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
literal|"expected %<)%>"
argument_list|)
expr_stmt|;
return|return
name|attrs
return|;
block|}
name|attrs
operator|=
name|chainon
argument_list|(
name|attrs
argument_list|,
name|attr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|)
condition|)
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
else|else
block|{
name|c_lex_string_translate
operator|=
literal|1
expr_stmt|;
name|c_parser_skip_until_found
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
literal|"expected %<)%>"
argument_list|)
expr_stmt|;
return|return
name|attrs
return|;
block|}
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|)
condition|)
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
else|else
block|{
name|c_lex_string_translate
operator|=
literal|1
expr_stmt|;
name|c_parser_skip_until_found
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
literal|"expected %<)%>"
argument_list|)
expr_stmt|;
return|return
name|attrs
return|;
block|}
name|c_lex_string_translate
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|attrs
return|;
block|}
end_function

begin_comment
comment|/* Parse a type name (C90 6.5.5, C99 6.7.6).     type-name:      specifier-qualifier-list abstract-declarator[opt] */
end_comment

begin_function
specifier|static
name|struct
name|c_type_name
modifier|*
name|c_parser_type_name
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|)
block|{
name|struct
name|c_declspecs
modifier|*
name|specs
init|=
name|build_null_declspecs
argument_list|()
decl_stmt|;
name|struct
name|c_declarator
modifier|*
name|declarator
decl_stmt|;
name|struct
name|c_type_name
modifier|*
name|ret
decl_stmt|;
name|bool
name|dummy
init|=
name|false
decl_stmt|;
name|c_parser_declspecs
argument_list|(
name|parser
argument_list|,
name|specs
argument_list|,
name|false
argument_list|,
name|true
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|specs
operator|->
name|declspecs_seen_p
condition|)
block|{
name|c_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected specifier-qualifier-list"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|pending_xref_error
argument_list|()
expr_stmt|;
name|finish_declspecs
argument_list|(
name|specs
argument_list|)
expr_stmt|;
name|declarator
operator|=
name|c_parser_declarator
argument_list|(
name|parser
argument_list|,
name|specs
operator|->
name|type_seen_p
argument_list|,
name|C_DTR_ABSTRACT
argument_list|,
operator|&
name|dummy
argument_list|)
expr_stmt|;
if|if
condition|(
name|declarator
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|ret
operator|=
name|XOBNEW
argument_list|(
operator|&
name|parser_obstack
argument_list|,
expr|struct
name|c_type_name
argument_list|)
expr_stmt|;
name|ret
operator|->
name|specs
operator|=
name|specs
expr_stmt|;
name|ret
operator|->
name|declarator
operator|=
name|declarator
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Parse an initializer (C90 6.5.7, C99 6.7.8).     initializer:      assignment-expression      { initializer-list }      { initializer-list , }     initializer-list:      designation[opt] initializer      initializer-list , designation[opt] initializer     designation:      designator-list =     designator-list:      designator      designator-list designator     designator:      array-designator      . identifier     array-designator:      [ constant-expression ]     GNU extensions:     initializer:      { }     designation:      array-designator      identifier :     array-designator:      [ constant-expression ... constant-expression ]     Any expression without commas is accepted in the syntax for the    constant-expressions, with non-constant expressions rejected later.     This function is only used for top-level initializers; for nested    ones, see c_parser_initval.  */
end_comment

begin_function
specifier|static
name|struct
name|c_expr
name|c_parser_initializer
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|)
block|{
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_BRACE
argument_list|)
condition|)
return|return
name|c_parser_braced_init
argument_list|(
name|parser
argument_list|,
name|NULL_TREE
argument_list|,
name|false
argument_list|)
return|;
else|else
block|{
name|struct
name|c_expr
name|ret
decl_stmt|;
name|ret
operator|=
name|c_parser_expr_no_commas
argument_list|(
name|parser
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ret
operator|.
name|value
argument_list|)
operator|!=
name|STRING_CST
operator|&&
name|TREE_CODE
argument_list|(
name|ret
operator|.
name|value
argument_list|)
operator|!=
name|COMPOUND_LITERAL_EXPR
condition|)
name|ret
operator|=
name|default_function_array_conversion
argument_list|(
name|ret
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
block|}
end_function

begin_comment
comment|/* Parse a braced initializer list.  TYPE is the type specified for a    compound literal, and NULL_TREE for other initializers and for    nested braced lists.  NESTED_P is true for nested braced lists,    false for the list of a compound literal or the list that is the    top-level initializer in a declaration.  */
end_comment

begin_function
specifier|static
name|struct
name|c_expr
name|c_parser_braced_init
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|,
name|tree
name|type
parameter_list|,
name|bool
name|nested_p
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_BRACE
argument_list|)
argument_list|)
expr_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|nested_p
condition|)
name|push_init_level
argument_list|(
literal|0
argument_list|)
expr_stmt|;
else|else
name|really_start_incremental_init
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_BRACE
argument_list|)
condition|)
block|{
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"ISO C forbids empty initializer braces"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Parse a non-empty initializer list, possibly with a trailing 	 comma.  */
while|while
condition|(
name|true
condition|)
block|{
name|c_parser_initelt
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|parser
operator|->
name|error
condition|)
break|break;
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_COMMA
argument_list|)
condition|)
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
else|else
break|break;
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_BRACE
argument_list|)
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|c_parser_next_token_is_not
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_BRACE
argument_list|)
condition|)
block|{
name|struct
name|c_expr
name|ret
decl_stmt|;
name|ret
operator|.
name|value
operator|=
name|error_mark_node
expr_stmt|;
name|ret
operator|.
name|original_code
operator|=
name|ERROR_MARK
expr_stmt|;
name|c_parser_skip_until_found
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_BRACE
argument_list|,
literal|"expected %<}%>"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
return|return
name|pop_init_level
argument_list|(
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Parse a nested initializer, including designators.  */
end_comment

begin_function
specifier|static
name|void
name|c_parser_initelt
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|)
block|{
comment|/* Parse any designator or designator list.  A single array      designator may have the subsequent "=" omitted in GNU C, but a      longer list or a structure member designator may not.  */
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_NAME
argument_list|)
operator|&&
name|c_parser_peek_2nd_token
argument_list|(
name|parser
argument_list|)
operator|->
name|type
operator|==
name|CPP_COLON
condition|)
block|{
comment|/* Old-style structure member designator.  */
name|set_init_label
argument_list|(
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
operator|->
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"obsolete use of designated initializer with %<:%>"
argument_list|)
expr_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* des_seen is 0 if there have been no designators, 1 if there 	 has been a single array designator and 2 otherwise.  */
name|int
name|des_seen
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_SQUARE
argument_list|)
operator|||
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_DOT
argument_list|)
condition|)
block|{
name|int
name|des_prev
init|=
name|des_seen
decl_stmt|;
if|if
condition|(
name|des_seen
operator|<
literal|2
condition|)
name|des_seen
operator|++
expr_stmt|;
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_DOT
argument_list|)
condition|)
block|{
name|des_seen
operator|=
literal|2
expr_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_NAME
argument_list|)
condition|)
block|{
name|set_init_label
argument_list|(
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
operator|->
name|value
argument_list|)
expr_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|c_expr
name|init
decl_stmt|;
name|init
operator|.
name|value
operator|=
name|error_mark_node
expr_stmt|;
name|init
operator|.
name|original_code
operator|=
name|ERROR_MARK
expr_stmt|;
name|c_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected identifier"
argument_list|)
expr_stmt|;
name|c_parser_skip_until_found
argument_list|(
name|parser
argument_list|,
name|CPP_COMMA
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|process_init_element
argument_list|(
name|init
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
name|tree
name|first
decl_stmt|,
name|second
decl_stmt|;
comment|/* ??? Following the old parser, [ objc-receiver 		 objc-message-args ] is accepted as an initializer, 		 being distinguished from a designator by what follows 		 the first assignment expression inside the square 		 brackets, but after a first array designator a 		 subsequent square bracket is for Objective-C taken to 		 start an expression, using the obsolete form of 		 designated initializer without '=', rather than 		 possibly being a second level of designation: in LALR 		 terms, the '[' is shifted rather than reducing 		 designator to designator-list.  */
if|if
condition|(
name|des_prev
operator|==
literal|1
operator|&&
name|c_dialect_objc
argument_list|()
condition|)
block|{
name|des_seen
operator|=
name|des_prev
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|des_prev
operator|==
literal|0
operator|&&
name|c_dialect_objc
argument_list|()
condition|)
block|{
comment|/* This might be an array designator or an 		     Objective-C message expression.  If the former, 		     continue parsing here; if the latter, parse the 		     remainder of the initializer given the starting 		     primary-expression.  ??? It might make sense to 		     distinguish when des_prev == 1 as well; see 		     previous comment.  */
name|tree
name|rec
decl_stmt|,
name|args
decl_stmt|;
name|struct
name|c_expr
name|mexpr
decl_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
operator|->
name|type
operator|==
name|CPP_NAME
operator|&&
operator|(
operator|(
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
operator|->
name|id_kind
operator|==
name|C_ID_TYPENAME
operator|)
operator|||
operator|(
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
operator|->
name|id_kind
operator|==
name|C_ID_CLASSNAME
operator|)
operator|)
condition|)
block|{
comment|/* Type name receiver.  */
name|tree
name|id
init|=
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
operator|->
name|value
decl_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|rec
operator|=
name|objc_get_class_reference
argument_list|(
name|id
argument_list|)
expr_stmt|;
goto|goto
name|parse_message_args
goto|;
block|}
name|first
operator|=
name|c_parser_expr_no_commas
argument_list|(
name|parser
argument_list|,
name|NULL
argument_list|)
operator|.
name|value
expr_stmt|;
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_ELLIPSIS
argument_list|)
operator|||
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_SQUARE
argument_list|)
condition|)
goto|goto
name|array_desig_after_first
goto|;
comment|/* Expression receiver.  So far only one part 		     without commas has been parsed; there might be 		     more of the expression.  */
name|rec
operator|=
name|first
expr_stmt|;
while|while
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_COMMA
argument_list|)
condition|)
block|{
name|struct
name|c_expr
name|next
decl_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|next
operator|=
name|c_parser_expr_no_commas
argument_list|(
name|parser
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|next
operator|=
name|default_function_array_conversion
argument_list|(
name|next
argument_list|)
expr_stmt|;
name|rec
operator|=
name|build_compound_expr
argument_list|(
name|rec
argument_list|,
name|next
operator|.
name|value
argument_list|)
expr_stmt|;
block|}
name|parse_message_args
label|:
comment|/* Now parse the objc-message-args.  */
name|args
operator|=
name|c_parser_objc_message_args
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|c_parser_skip_until_found
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_SQUARE
argument_list|,
literal|"expected %<]%>"
argument_list|)
expr_stmt|;
name|mexpr
operator|.
name|value
operator|=
name|objc_build_message_expr
argument_list|(
name|build_tree_list
argument_list|(
name|rec
argument_list|,
name|args
argument_list|)
argument_list|)
expr_stmt|;
name|mexpr
operator|.
name|original_code
operator|=
name|ERROR_MARK
expr_stmt|;
comment|/* Now parse and process the remainder of the 		     initializer, starting with this message 		     expression as a primary-expression.  */
name|c_parser_initval
argument_list|(
name|parser
argument_list|,
operator|&
name|mexpr
argument_list|)
expr_stmt|;
return|return;
block|}
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|first
operator|=
name|c_parser_expr_no_commas
argument_list|(
name|parser
argument_list|,
name|NULL
argument_list|)
operator|.
name|value
expr_stmt|;
name|array_desig_after_first
label|:
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_ELLIPSIS
argument_list|)
condition|)
block|{
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|second
operator|=
name|c_parser_expr_no_commas
argument_list|(
name|parser
argument_list|,
name|NULL
argument_list|)
operator|.
name|value
expr_stmt|;
block|}
else|else
name|second
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_SQUARE
argument_list|)
condition|)
block|{
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|set_init_index
argument_list|(
name|first
argument_list|,
name|second
argument_list|)
expr_stmt|;
if|if
condition|(
name|pedantic
operator|&&
name|second
condition|)
name|pedwarn
argument_list|(
literal|"ISO C forbids specifying range of "
literal|"elements to initialize"
argument_list|)
expr_stmt|;
block|}
else|else
name|c_parser_skip_until_found
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_SQUARE
argument_list|,
literal|"expected %<]%>"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|des_seen
operator|>=
literal|1
condition|)
block|{
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_EQ
argument_list|)
condition|)
block|{
if|if
condition|(
name|pedantic
operator|&&
operator|!
name|flag_isoc99
condition|)
name|pedwarn
argument_list|(
literal|"ISO C90 forbids specifying subobject to initialize"
argument_list|)
expr_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|des_seen
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"obsolete use of designated initializer "
literal|"without %<=%>"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|c_expr
name|init
decl_stmt|;
name|init
operator|.
name|value
operator|=
name|error_mark_node
expr_stmt|;
name|init
operator|.
name|original_code
operator|=
name|ERROR_MARK
expr_stmt|;
name|c_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected %<=%>"
argument_list|)
expr_stmt|;
name|c_parser_skip_until_found
argument_list|(
name|parser
argument_list|,
name|CPP_COMMA
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|process_init_element
argument_list|(
name|init
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
block|}
name|c_parser_initval
argument_list|(
name|parser
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse a nested initializer; as c_parser_initializer but parses    initializers within braced lists, after any designators have been    applied.  If AFTER is not NULL then it is an Objective-C message    expression which is the primary-expression starting the    initializer.  */
end_comment

begin_function
specifier|static
name|void
name|c_parser_initval
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|,
name|struct
name|c_expr
modifier|*
name|after
parameter_list|)
block|{
name|struct
name|c_expr
name|init
decl_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|after
operator|||
name|c_dialect_objc
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_BRACE
argument_list|)
operator|&&
operator|!
name|after
condition|)
name|init
operator|=
name|c_parser_braced_init
argument_list|(
name|parser
argument_list|,
name|NULL_TREE
argument_list|,
name|true
argument_list|)
expr_stmt|;
else|else
block|{
name|init
operator|=
name|c_parser_expr_no_commas
argument_list|(
name|parser
argument_list|,
name|after
argument_list|)
expr_stmt|;
if|if
condition|(
name|init
operator|.
name|value
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|init
operator|.
name|value
argument_list|)
operator|!=
name|STRING_CST
operator|&&
name|TREE_CODE
argument_list|(
name|init
operator|.
name|value
argument_list|)
operator|!=
name|COMPOUND_LITERAL_EXPR
condition|)
name|init
operator|=
name|default_function_array_conversion
argument_list|(
name|init
argument_list|)
expr_stmt|;
block|}
name|process_init_element
argument_list|(
name|init
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse a compound statement (possibly a function body) (C90 6.6.2,    C99 6.8.2).     compound-statement:      { block-item-list[opt] }      { label-declarations block-item-list }     block-item-list:      block-item      block-item-list block-item     block-item:      nested-declaration      statement     nested-declaration:      declaration     GNU extensions:     compound-statement:      { label-declarations block-item-list }     nested-declaration:      __extension__ nested-declaration      nested-function-definition     label-declarations:      label-declaration      label-declarations label-declaration     label-declaration:      __label__ identifier-list ;     Allowing the mixing of declarations and code is new in C99.  The    GNU syntax also permits (not shown above) labels at the end of    compound statements, which yield an error.  We don't allow labels    on declarations; this might seem like a natural extension, but    there would be a conflict between attributes on the label and    prefix attributes on the declaration.  ??? The syntax follows the    old parser in requiring something after label declarations.    Although they are erroneous if the labels declared aren't defined,    is it useful for the syntax to be this way?        OpenMP:        block-item:      openmp-directive     openmp-directive:      barrier-directive      flush-directive  */
end_comment

begin_function
specifier|static
name|tree
name|c_parser_compound_statement
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|stmt
decl_stmt|;
if|if
condition|(
operator|!
name|c_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_BRACE
argument_list|,
literal|"expected %<{%>"
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
name|stmt
operator|=
name|c_begin_compound_stmt
argument_list|(
name|true
argument_list|)
expr_stmt|;
name|c_parser_compound_statement_nostart
argument_list|(
name|parser
argument_list|)
expr_stmt|;
return|return
name|c_end_compound_stmt
argument_list|(
name|stmt
argument_list|,
name|true
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Parse a compound statement except for the opening brace.  This is    used for parsing both compound statements and statement expressions    (which follow different paths to handling the opening).  */
end_comment

begin_function
specifier|static
name|void
name|c_parser_compound_statement_nostart
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|)
block|{
name|bool
name|last_stmt
init|=
name|false
decl_stmt|;
name|bool
name|last_label
init|=
name|false
decl_stmt|;
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_BRACE
argument_list|)
condition|)
block|{
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|c_parser_next_token_is_keyword
argument_list|(
name|parser
argument_list|,
name|RID_LABEL
argument_list|)
condition|)
block|{
comment|/* Read zero or more forward-declarations for labels that nested 	 functions can jump to.  */
while|while
condition|(
name|c_parser_next_token_is_keyword
argument_list|(
name|parser
argument_list|,
name|RID_LABEL
argument_list|)
condition|)
block|{
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Any identifiers, including those declared as type names, 	     are OK here.  */
while|while
condition|(
name|true
condition|)
block|{
name|tree
name|label
decl_stmt|;
if|if
condition|(
name|c_parser_next_token_is_not
argument_list|(
name|parser
argument_list|,
name|CPP_NAME
argument_list|)
condition|)
block|{
name|c_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected identifier"
argument_list|)
expr_stmt|;
break|break;
block|}
name|label
operator|=
name|declare_label
argument_list|(
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
operator|->
name|value
argument_list|)
expr_stmt|;
name|C_DECLARED_LABEL_FLAG
argument_list|(
name|label
argument_list|)
operator|=
literal|1
expr_stmt|;
name|add_stmt
argument_list|(
name|build_stmt
argument_list|(
name|DECL_EXPR
argument_list|,
name|label
argument_list|)
argument_list|)
expr_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_COMMA
argument_list|)
condition|)
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
else|else
break|break;
block|}
name|c_parser_skip_until_found
argument_list|(
name|parser
argument_list|,
name|CPP_SEMICOLON
argument_list|,
literal|"expected %<;%>"
argument_list|)
expr_stmt|;
block|}
comment|/* ??? Locating this diagnostic on the token after the 	 declarations end follows the old parser, but it might be 	 better to locate it where the declarations start instead.  */
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"ISO C forbids label declarations"
argument_list|)
expr_stmt|;
block|}
comment|/* We must now have at least one statement, label or declaration.  */
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_BRACE
argument_list|)
condition|)
block|{
name|c_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected declaration or statement"
argument_list|)
expr_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|c_parser_next_token_is_not
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_BRACE
argument_list|)
condition|)
block|{
name|location_t
name|loc
init|=
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
operator|->
name|location
decl_stmt|;
if|if
condition|(
name|c_parser_next_token_is_keyword
argument_list|(
name|parser
argument_list|,
name|RID_CASE
argument_list|)
operator|||
name|c_parser_next_token_is_keyword
argument_list|(
name|parser
argument_list|,
name|RID_DEFAULT
argument_list|)
operator|||
operator|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_NAME
argument_list|)
operator|&&
name|c_parser_peek_2nd_token
argument_list|(
name|parser
argument_list|)
operator|->
name|type
operator|==
name|CPP_COLON
operator|)
condition|)
block|{
name|last_label
operator|=
name|true
expr_stmt|;
name|last_stmt
operator|=
name|false
expr_stmt|;
name|c_parser_label
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|last_label
operator|&&
name|c_parser_next_token_starts_declspecs
argument_list|(
name|parser
argument_list|)
condition|)
block|{
name|last_label
operator|=
name|false
expr_stmt|;
name|c_parser_declaration_or_fndef
argument_list|(
name|parser
argument_list|,
name|true
argument_list|,
name|true
argument_list|,
name|true
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_stmt
operator|&&
operator|(
operator|(
name|pedantic
operator|&&
operator|!
name|flag_isoc99
operator|)
operator|||
name|warn_declaration_after_statement
operator|)
condition|)
name|pedwarn_c90
argument_list|(
literal|"%HISO C90 forbids mixed declarations and code"
argument_list|,
operator|&
name|loc
argument_list|)
expr_stmt|;
name|last_stmt
operator|=
name|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|last_label
operator|&&
name|c_parser_next_token_is_keyword
argument_list|(
name|parser
argument_list|,
name|RID_EXTENSION
argument_list|)
condition|)
block|{
comment|/* __extension__ can start a declaration, but is also an 	     unary operator that can start an expression.  Consume all 	     but the last of a possible series of __extension__ to 	     determine which.  */
while|while
condition|(
name|c_parser_peek_2nd_token
argument_list|(
name|parser
argument_list|)
operator|->
name|type
operator|==
name|CPP_KEYWORD
operator|&&
operator|(
name|c_parser_peek_2nd_token
argument_list|(
name|parser
argument_list|)
operator|->
name|keyword
operator|==
name|RID_EXTENSION
operator|)
condition|)
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_token_starts_declspecs
argument_list|(
name|c_parser_peek_2nd_token
argument_list|(
name|parser
argument_list|)
argument_list|)
condition|)
block|{
name|int
name|ext
decl_stmt|;
name|ext
operator|=
name|disable_extension_diagnostics
argument_list|()
expr_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|last_label
operator|=
name|false
expr_stmt|;
name|c_parser_declaration_or_fndef
argument_list|(
name|parser
argument_list|,
name|true
argument_list|,
name|true
argument_list|,
name|true
argument_list|,
name|true
argument_list|)
expr_stmt|;
comment|/* Following the old parser, __extension__ does not 		 disable this diagnostic.  */
name|restore_extension_diagnostics
argument_list|(
name|ext
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_stmt
operator|&&
operator|(
operator|(
name|pedantic
operator|&&
operator|!
name|flag_isoc99
operator|)
operator|||
name|warn_declaration_after_statement
operator|)
condition|)
name|pedwarn_c90
argument_list|(
literal|"%HISO C90 forbids mixed declarations and code"
argument_list|,
operator|&
name|loc
argument_list|)
expr_stmt|;
name|last_stmt
operator|=
name|false
expr_stmt|;
block|}
else|else
goto|goto
name|statement
goto|;
block|}
elseif|else
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_PRAGMA
argument_list|)
condition|)
block|{
comment|/* External pragmas, and some omp pragmas, are not associated 	     with regular c code, and so are not to be considered statements 	     syntactically.  This ensures that the user doesn't put them 	     places that would turn into syntax errors if the directive 	     were ignored.  */
if|if
condition|(
name|c_parser_pragma
argument_list|(
name|parser
argument_list|,
name|pragma_compound
argument_list|)
condition|)
name|last_label
operator|=
name|false
operator|,
name|last_stmt
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_EOF
argument_list|)
condition|)
block|{
name|c_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected declaration or statement"
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|statement
label|:
name|last_label
operator|=
name|false
expr_stmt|;
name|last_stmt
operator|=
name|true
expr_stmt|;
name|c_parser_statement_after_labels
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
name|parser
operator|->
name|error
operator|=
name|false
expr_stmt|;
block|}
if|if
condition|(
name|last_label
condition|)
name|error
argument_list|(
literal|"label at end of compound statement"
argument_list|)
expr_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse a label (C90 6.6.1, C99 6.8.1).     label:      identifier : attributes[opt]      case constant-expression :      default :     GNU extensions:     label:      case constant-expression ... constant-expression :     The use of attributes on labels is a GNU extension.  The syntax in    GNU C accepts any expressions without commas, non-constant    expressions being rejected later.  */
end_comment

begin_function
specifier|static
name|void
name|c_parser_label
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|)
block|{
name|location_t
name|loc1
init|=
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
operator|->
name|location
decl_stmt|;
name|tree
name|label
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|c_parser_next_token_is_keyword
argument_list|(
name|parser
argument_list|,
name|RID_CASE
argument_list|)
condition|)
block|{
name|tree
name|exp1
decl_stmt|,
name|exp2
decl_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|exp1
operator|=
name|c_parser_expr_no_commas
argument_list|(
name|parser
argument_list|,
name|NULL
argument_list|)
operator|.
name|value
expr_stmt|;
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_COLON
argument_list|)
condition|)
block|{
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|label
operator|=
name|do_case
argument_list|(
name|exp1
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_ELLIPSIS
argument_list|)
condition|)
block|{
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|exp2
operator|=
name|c_parser_expr_no_commas
argument_list|(
name|parser
argument_list|,
name|NULL
argument_list|)
operator|.
name|value
expr_stmt|;
if|if
condition|(
name|c_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_COLON
argument_list|,
literal|"expected %<:%>"
argument_list|)
condition|)
name|label
operator|=
name|do_case
argument_list|(
name|exp1
argument_list|,
name|exp2
argument_list|)
expr_stmt|;
block|}
else|else
name|c_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected %<:%> or %<...%>"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c_parser_next_token_is_keyword
argument_list|(
name|parser
argument_list|,
name|RID_DEFAULT
argument_list|)
condition|)
block|{
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_COLON
argument_list|,
literal|"expected %<:%>"
argument_list|)
condition|)
name|label
operator|=
name|do_case
argument_list|(
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tree
name|name
init|=
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
operator|->
name|value
decl_stmt|;
name|tree
name|tlab
decl_stmt|;
name|location_t
name|loc2
decl_stmt|;
name|tree
name|attrs
decl_stmt|;
name|gcc_assert
argument_list|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_NAME
argument_list|)
argument_list|)
expr_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_COLON
argument_list|)
argument_list|)
expr_stmt|;
name|loc2
operator|=
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
operator|->
name|location
expr_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|attrs
operator|=
name|c_parser_attributes
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|tlab
operator|=
name|define_label
argument_list|(
name|loc2
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|tlab
condition|)
block|{
name|decl_attributes
argument_list|(
operator|&
name|tlab
argument_list|,
name|attrs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|label
operator|=
name|add_stmt
argument_list|(
name|build_stmt
argument_list|(
name|LABEL_EXPR
argument_list|,
name|tlab
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|label
condition|)
name|SET_EXPR_LOCATION
argument_list|(
name|label
argument_list|,
name|loc1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse a statement (C90 6.6, C99 6.8).     statement:      labeled-statement      compound-statement      expression-statement      selection-statement      iteration-statement      jump-statement     labeled-statement:      label statement     expression-statement:      expression[opt] ;     selection-statement:      if-statement      switch-statement     iteration-statement:      while-statement      do-statement      for-statement     jump-statement:      goto identifier ;      continue ;      break ;      return expression[opt] ;     GNU extensions:     statement:      asm-statement     jump-statement:      goto * expression ;     Objective-C:     statement:      objc-throw-statement      objc-try-catch-statement      objc-synchronized-statement     objc-throw-statement:      @throw expression ;      @throw ;     OpenMP:     statement:      openmp-construct     openmp-construct:      parallel-construct      for-construct      sections-construct      single-construct      parallel-for-construct      parallel-sections-construct      master-construct      critical-construct      atomic-construct      ordered-construct     parallel-construct:      parallel-directive structured-block     for-construct:      for-directive iteration-statement     sections-construct:      sections-directive section-scope     single-construct:      single-directive structured-block     parallel-for-construct:      parallel-for-directive iteration-statement     parallel-sections-construct:      parallel-sections-directive section-scope     master-construct:      master-directive structured-block     critical-construct:      critical-directive structured-block     atomic-construct:      atomic-directive expression-statement     ordered-construct:      ordered-directive structured-block  */
end_comment

begin_function
specifier|static
name|void
name|c_parser_statement
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|)
block|{
while|while
condition|(
name|c_parser_next_token_is_keyword
argument_list|(
name|parser
argument_list|,
name|RID_CASE
argument_list|)
operator|||
name|c_parser_next_token_is_keyword
argument_list|(
name|parser
argument_list|,
name|RID_DEFAULT
argument_list|)
operator|||
operator|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_NAME
argument_list|)
operator|&&
name|c_parser_peek_2nd_token
argument_list|(
name|parser
argument_list|)
operator|->
name|type
operator|==
name|CPP_COLON
operator|)
condition|)
name|c_parser_label
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|c_parser_statement_after_labels
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse a statement, other than a labeled statement.  */
end_comment

begin_function
specifier|static
name|void
name|c_parser_statement_after_labels
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|)
block|{
name|location_t
name|loc
init|=
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
operator|->
name|location
decl_stmt|;
name|tree
name|stmt
init|=
name|NULL_TREE
decl_stmt|;
switch|switch
condition|(
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
operator|->
name|type
condition|)
block|{
case|case
name|CPP_OPEN_BRACE
case|:
name|add_stmt
argument_list|(
name|c_parser_compound_statement
argument_list|(
name|parser
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_KEYWORD
case|:
switch|switch
condition|(
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
operator|->
name|keyword
condition|)
block|{
case|case
name|RID_IF
case|:
name|c_parser_if_statement
argument_list|(
name|parser
argument_list|)
expr_stmt|;
break|break;
case|case
name|RID_SWITCH
case|:
name|c_parser_switch_statement
argument_list|(
name|parser
argument_list|)
expr_stmt|;
break|break;
case|case
name|RID_WHILE
case|:
name|c_parser_while_statement
argument_list|(
name|parser
argument_list|)
expr_stmt|;
break|break;
case|case
name|RID_DO
case|:
name|c_parser_do_statement
argument_list|(
name|parser
argument_list|)
expr_stmt|;
break|break;
case|case
name|RID_FOR
case|:
name|c_parser_for_statement
argument_list|(
name|parser
argument_list|)
expr_stmt|;
break|break;
case|case
name|RID_GOTO
case|:
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_NAME
argument_list|)
condition|)
block|{
name|stmt
operator|=
name|c_finish_goto_label
argument_list|(
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
operator|->
name|value
argument_list|)
expr_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_MULT
argument_list|)
condition|)
block|{
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|c_finish_goto_ptr
argument_list|(
name|c_parser_expression
argument_list|(
name|parser
argument_list|)
operator|.
name|value
argument_list|)
expr_stmt|;
block|}
else|else
name|c_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected identifier or %<*%>"
argument_list|)
expr_stmt|;
goto|goto
name|expect_semicolon
goto|;
case|case
name|RID_CONTINUE
case|:
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|c_finish_bc_stmt
argument_list|(
operator|&
name|c_cont_label
argument_list|,
name|false
argument_list|)
expr_stmt|;
goto|goto
name|expect_semicolon
goto|;
case|case
name|RID_BREAK
case|:
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|c_finish_bc_stmt
argument_list|(
operator|&
name|c_break_label
argument_list|,
name|true
argument_list|)
expr_stmt|;
goto|goto
name|expect_semicolon
goto|;
case|case
name|RID_RETURN
case|:
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_SEMICOLON
argument_list|)
condition|)
block|{
name|stmt
operator|=
name|c_finish_return
argument_list|(
name|NULL_TREE
argument_list|)
expr_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|stmt
operator|=
name|c_finish_return
argument_list|(
name|c_parser_expression_conv
argument_list|(
name|parser
argument_list|)
operator|.
name|value
argument_list|)
expr_stmt|;
goto|goto
name|expect_semicolon
goto|;
block|}
break|break;
case|case
name|RID_ASM
case|:
name|stmt
operator|=
name|c_parser_asm_statement
argument_list|(
name|parser
argument_list|)
expr_stmt|;
break|break;
case|case
name|RID_AT_THROW
case|:
name|gcc_assert
argument_list|(
name|c_dialect_objc
argument_list|()
argument_list|)
expr_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_SEMICOLON
argument_list|)
condition|)
block|{
name|stmt
operator|=
name|objc_build_throw_stmt
argument_list|(
name|NULL_TREE
argument_list|)
expr_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|stmt
operator|=
name|objc_build_throw_stmt
argument_list|(
name|c_parser_expression
argument_list|(
name|parser
argument_list|)
operator|.
name|value
argument_list|)
expr_stmt|;
goto|goto
name|expect_semicolon
goto|;
block|}
break|break;
case|case
name|RID_AT_TRY
case|:
name|gcc_assert
argument_list|(
name|c_dialect_objc
argument_list|()
argument_list|)
expr_stmt|;
name|c_parser_objc_try_catch_statement
argument_list|(
name|parser
argument_list|)
expr_stmt|;
break|break;
case|case
name|RID_AT_SYNCHRONIZED
case|:
name|gcc_assert
argument_list|(
name|c_dialect_objc
argument_list|()
argument_list|)
expr_stmt|;
name|c_parser_objc_synchronized_statement
argument_list|(
name|parser
argument_list|)
expr_stmt|;
break|break;
default|default:
goto|goto
name|expr_stmt
goto|;
block|}
break|break;
case|case
name|CPP_SEMICOLON
case|:
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_CLOSE_PAREN
case|:
case|case
name|CPP_CLOSE_SQUARE
case|:
comment|/* Avoid infinite loop in error recovery: 	 c_parser_skip_until_found stops at a closing nesting 	 delimiter without consuming it, but here we need to consume 	 it to proceed further.  */
name|c_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected statement"
argument_list|)
expr_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_PRAGMA
case|:
name|c_parser_pragma
argument_list|(
name|parser
argument_list|,
name|pragma_stmt
argument_list|)
expr_stmt|;
break|break;
default|default:
name|expr_stmt
label|:
name|stmt
operator|=
name|c_finish_expr_stmt
argument_list|(
name|c_parser_expression_conv
argument_list|(
name|parser
argument_list|)
operator|.
name|value
argument_list|)
expr_stmt|;
name|expect_semicolon
label|:
name|c_parser_skip_until_found
argument_list|(
name|parser
argument_list|,
name|CPP_SEMICOLON
argument_list|,
literal|"expected %<;%>"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Two cases cannot and do not have line numbers associated: If stmt      is degenerate, such as "2;", then stmt is an INTEGER_CST, which      cannot hold line numbers.  But that's OK because the statement      will either be changed to a MODIFY_EXPR during gimplification of      the statement expr, or discarded.  If stmt was compound, but      without new variables, we will have skipped the creation of a      BIND and will have a bare STATEMENT_LIST.  But that's OK because      (recursively) all of the component statements should already have      line numbers assigned.  ??? Can we discard no-op statements      earlier?  */
if|if
condition|(
name|stmt
operator|&&
name|EXPR_P
argument_list|(
name|stmt
argument_list|)
condition|)
name|SET_EXPR_LOCATION
argument_list|(
name|stmt
argument_list|,
name|loc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse a parenthesized condition from an if, do or while statement.     condition:      ( expression ) */
end_comment

begin_function
specifier|static
name|tree
name|c_parser_paren_condition
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|)
block|{
name|location_t
name|loc
decl_stmt|;
name|tree
name|cond
decl_stmt|;
if|if
condition|(
operator|!
name|c_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_PAREN
argument_list|,
literal|"expected %<(%>"
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
name|loc
operator|=
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
operator|->
name|location
expr_stmt|;
name|cond
operator|=
name|c_objc_common_truthvalue_conversion
argument_list|(
name|c_parser_expression_conv
argument_list|(
name|parser
argument_list|)
operator|.
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|EXPR_P
argument_list|(
name|cond
argument_list|)
condition|)
name|SET_EXPR_LOCATION
argument_list|(
name|cond
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|c_parser_skip_until_found
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
literal|"expected %<)%>"
argument_list|)
expr_stmt|;
return|return
name|cond
return|;
block|}
end_function

begin_comment
comment|/* Parse a statement which is a block in C99.  */
end_comment

begin_function
specifier|static
name|tree
name|c_parser_c99_block_statement
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|block
init|=
name|c_begin_compound_stmt
argument_list|(
name|flag_isoc99
argument_list|)
decl_stmt|;
name|c_parser_statement
argument_list|(
name|parser
argument_list|)
expr_stmt|;
return|return
name|c_end_compound_stmt
argument_list|(
name|block
argument_list|,
name|flag_isoc99
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Parse the body of an if statement or the else half thereof.  This    is just parsing a statement but (a) it is a block in C99, (b) we    track whether the body is an if statement for the sake of    -Wparentheses warnings, (c) we handle an empty body specially for    the sake of -Wextra warnings.  */
end_comment

begin_function
specifier|static
name|tree
name|c_parser_if_body
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|,
name|bool
modifier|*
name|if_p
parameter_list|)
block|{
name|tree
name|block
init|=
name|c_begin_compound_stmt
argument_list|(
name|flag_isoc99
argument_list|)
decl_stmt|;
while|while
condition|(
name|c_parser_next_token_is_keyword
argument_list|(
name|parser
argument_list|,
name|RID_CASE
argument_list|)
operator|||
name|c_parser_next_token_is_keyword
argument_list|(
name|parser
argument_list|,
name|RID_DEFAULT
argument_list|)
operator|||
operator|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_NAME
argument_list|)
operator|&&
name|c_parser_peek_2nd_token
argument_list|(
name|parser
argument_list|)
operator|->
name|type
operator|==
name|CPP_COLON
operator|)
condition|)
name|c_parser_label
argument_list|(
name|parser
argument_list|)
expr_stmt|;
operator|*
name|if_p
operator|=
name|c_parser_next_token_is_keyword
argument_list|(
name|parser
argument_list|,
name|RID_IF
argument_list|)
expr_stmt|;
if|if
condition|(
name|extra_warnings
operator|&&
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_SEMICOLON
argument_list|)
condition|)
name|add_stmt
argument_list|(
name|build_empty_stmt
argument_list|()
argument_list|)
expr_stmt|;
name|c_parser_statement_after_labels
argument_list|(
name|parser
argument_list|)
expr_stmt|;
return|return
name|c_end_compound_stmt
argument_list|(
name|block
argument_list|,
name|flag_isoc99
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Parse an if statement (C90 6.6.4, C99 6.8.4).     if-statement:      if ( expression ) statement      if ( expression ) statement else statement */
end_comment

begin_function
specifier|static
name|void
name|c_parser_if_statement
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|block
decl_stmt|;
name|location_t
name|loc
decl_stmt|;
name|tree
name|cond
decl_stmt|;
name|bool
name|first_if
init|=
name|false
decl_stmt|,
name|second_if
init|=
name|false
decl_stmt|;
name|tree
name|first_body
decl_stmt|,
name|second_body
decl_stmt|;
name|gcc_assert
argument_list|(
name|c_parser_next_token_is_keyword
argument_list|(
name|parser
argument_list|,
name|RID_IF
argument_list|)
argument_list|)
expr_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|block
operator|=
name|c_begin_compound_stmt
argument_list|(
name|flag_isoc99
argument_list|)
expr_stmt|;
name|loc
operator|=
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
operator|->
name|location
expr_stmt|;
name|cond
operator|=
name|c_parser_paren_condition
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|first_body
operator|=
name|c_parser_if_body
argument_list|(
name|parser
argument_list|,
operator|&
name|first_if
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_parser_next_token_is_keyword
argument_list|(
name|parser
argument_list|,
name|RID_ELSE
argument_list|)
condition|)
block|{
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|second_body
operator|=
name|c_parser_if_body
argument_list|(
name|parser
argument_list|,
operator|&
name|second_if
argument_list|)
expr_stmt|;
block|}
else|else
name|second_body
operator|=
name|NULL_TREE
expr_stmt|;
name|c_finish_if_stmt
argument_list|(
name|loc
argument_list|,
name|cond
argument_list|,
name|first_body
argument_list|,
name|second_body
argument_list|,
name|first_if
argument_list|)
expr_stmt|;
name|add_stmt
argument_list|(
name|c_end_compound_stmt
argument_list|(
name|block
argument_list|,
name|flag_isoc99
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse a switch statement (C90 6.6.4, C99 6.8.4).     switch-statement:      switch (expression) statement */
end_comment

begin_function
specifier|static
name|void
name|c_parser_switch_statement
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|block
decl_stmt|,
name|expr
decl_stmt|,
name|body
decl_stmt|,
name|save_break
decl_stmt|;
name|gcc_assert
argument_list|(
name|c_parser_next_token_is_keyword
argument_list|(
name|parser
argument_list|,
name|RID_SWITCH
argument_list|)
argument_list|)
expr_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|block
operator|=
name|c_begin_compound_stmt
argument_list|(
name|flag_isoc99
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_PAREN
argument_list|,
literal|"expected %<(%>"
argument_list|)
condition|)
block|{
name|expr
operator|=
name|c_parser_expression
argument_list|(
name|parser
argument_list|)
operator|.
name|value
expr_stmt|;
name|c_parser_skip_until_found
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
literal|"expected %<)%>"
argument_list|)
expr_stmt|;
block|}
else|else
name|expr
operator|=
name|error_mark_node
expr_stmt|;
name|c_start_case
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|save_break
operator|=
name|c_break_label
expr_stmt|;
name|c_break_label
operator|=
name|NULL_TREE
expr_stmt|;
name|body
operator|=
name|c_parser_c99_block_statement
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|c_finish_case
argument_list|(
name|body
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_break_label
condition|)
name|add_stmt
argument_list|(
name|build1
argument_list|(
name|LABEL_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|c_break_label
argument_list|)
argument_list|)
expr_stmt|;
name|c_break_label
operator|=
name|save_break
expr_stmt|;
name|add_stmt
argument_list|(
name|c_end_compound_stmt
argument_list|(
name|block
argument_list|,
name|flag_isoc99
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse a while statement (C90 6.6.5, C99 6.8.5).     while-statement:    APPLE LOCAL begin for-fsf-4_4 3274130 5295549       while attributes (expression) statement     The use of attributes is a GNU extension.    APPLE LOCAL end for-fsf-4_4 3274130 5295549 */
end_comment

begin_function
specifier|static
name|void
name|c_parser_while_statement
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|)
block|{
comment|/* APPLE LOCAL begin for-fsf-4_4 3274130 5295549 */
block|\
name|tree
name|block
decl_stmt|,
name|cond
decl_stmt|,
name|body
decl_stmt|,
name|save_break
decl_stmt|,
name|save_cont
decl_stmt|,
name|attrs
decl_stmt|;
comment|/* APPLE LOCAL end for-fsf-4_4 3274130 5295549 */
block|\
name|location_t
name|loc
decl_stmt|;
name|gcc_assert
argument_list|(
name|c_parser_next_token_is_keyword
argument_list|(
name|parser
argument_list|,
name|RID_WHILE
argument_list|)
argument_list|)
expr_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* APPLE LOCAL begin for-fsf-4_4 3274130 5295549 */
block|\
name|attrs
operator|=
name|c_parser_attributes
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* APPLE LOCAL end for-fsf-4_4 3274130 5295549 */
block|\
name|block
operator|=
name|c_begin_compound_stmt
argument_list|(
name|flag_isoc99
argument_list|)
expr_stmt|;
name|loc
operator|=
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
operator|->
name|location
expr_stmt|;
name|cond
operator|=
name|c_parser_paren_condition
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|save_break
operator|=
name|c_break_label
expr_stmt|;
name|c_break_label
operator|=
name|NULL_TREE
expr_stmt|;
name|save_cont
operator|=
name|c_cont_label
expr_stmt|;
name|c_cont_label
operator|=
name|NULL_TREE
expr_stmt|;
name|body
operator|=
name|c_parser_c99_block_statement
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* APPLE LOCAL begin for-fsf-4_4 3274130 5295549 */
block|\
name|c_finish_loop
argument_list|(
name|loc
argument_list|,
name|cond
argument_list|,
name|NULL
argument_list|,
name|body
argument_list|,
name|c_break_label
argument_list|,
name|c_cont_label
argument_list|,
name|attrs
argument_list|,
name|true
argument_list|)
expr_stmt|;
comment|/* APPLE LOCAL end for-fsf-4_4 3274130 5295549 */
block|\
name|add_stmt
argument_list|(
name|c_end_compound_stmt
argument_list|(
name|block
argument_list|,
name|flag_isoc99
argument_list|)
argument_list|)
expr_stmt|;
name|c_break_label
operator|=
name|save_break
expr_stmt|;
name|c_cont_label
operator|=
name|save_cont
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse a do statement (C90 6.6.5, C99 6.8.5).     do-statement:    APPLE LOCAL begin for-fsf-4_4 3274130 5295549      do attributes statement while ( expression ) ;     The use of attributes is a GNU extension.    APPLE LOCAL end for-fsf-4_4 3274130 5295549 */
end_comment

begin_function
specifier|static
name|void
name|c_parser_do_statement
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|)
block|{
comment|/* APPLE LOCAL begin for-fsf-4_4 3274130 5295549 */
block|\
name|tree
name|block
decl_stmt|,
name|cond
decl_stmt|,
name|body
decl_stmt|,
name|save_break
decl_stmt|,
name|save_cont
decl_stmt|,
name|new_break
decl_stmt|,
name|new_cont
decl_stmt|,
name|attrs
decl_stmt|;
comment|/* APPLE LOCAL end for-fsf-4_4 3274130 5295549 */
block|\
name|location_t
name|loc
decl_stmt|;
name|gcc_assert
argument_list|(
name|c_parser_next_token_is_keyword
argument_list|(
name|parser
argument_list|,
name|RID_DO
argument_list|)
argument_list|)
expr_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* APPLE LOCAL begin for-fsf-4_4 3274130 5295549 */
block|\
name|attrs
operator|=
name|c_parser_attributes
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* APPLE LOCAL end for-fsf-4_4 3274130 5295549 */
block|\
name|block
operator|=
name|c_begin_compound_stmt
argument_list|(
name|flag_isoc99
argument_list|)
expr_stmt|;
name|loc
operator|=
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
operator|->
name|location
expr_stmt|;
name|save_break
operator|=
name|c_break_label
expr_stmt|;
name|c_break_label
operator|=
name|NULL_TREE
expr_stmt|;
name|save_cont
operator|=
name|c_cont_label
expr_stmt|;
name|c_cont_label
operator|=
name|NULL_TREE
expr_stmt|;
name|body
operator|=
name|c_parser_c99_block_statement
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|c_parser_require_keyword
argument_list|(
name|parser
argument_list|,
name|RID_WHILE
argument_list|,
literal|"expected %<while%>"
argument_list|)
expr_stmt|;
name|new_break
operator|=
name|c_break_label
expr_stmt|;
name|c_break_label
operator|=
name|save_break
expr_stmt|;
name|new_cont
operator|=
name|c_cont_label
expr_stmt|;
name|c_cont_label
operator|=
name|save_cont
expr_stmt|;
name|cond
operator|=
name|c_parser_paren_condition
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|c_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_SEMICOLON
argument_list|,
literal|"expected %<;%>"
argument_list|)
condition|)
name|c_parser_skip_to_end_of_block_or_statement
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* APPLE LOCAL begin for-fsf-4_4 3274130 5295549 */
block|\
name|c_finish_loop
argument_list|(
name|loc
argument_list|,
name|cond
argument_list|,
name|NULL
argument_list|,
name|body
argument_list|,
name|new_break
argument_list|,
name|new_cont
argument_list|,
name|attrs
argument_list|,
name|false
argument_list|)
expr_stmt|;
comment|/* APPLE LOCAL end for-fsf-4_4 3274130 5295549 */
block|\
name|add_stmt
argument_list|(
name|c_end_compound_stmt
argument_list|(
name|block
argument_list|,
name|flag_isoc99
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse a for statement (C90 6.6.5, C99 6.8.5).     for-statement:    APPLE LOCAL begin for-fsf-4_4 3274130 5295549      for attributes ( expression[opt] ; expression[opt] ; expression[opt] ) \          statement      for attributes ( nested-declaration expression[opt] ; expression[opt] ) \          statement     The form with a declaration is new in C99.     The use of attributes is a GNU extension.     APPLE LOCAL end for-fsf-4_4 3274130 5295549    ??? In accordance with the old parser, the declaration may be a    nested function, which is then rejected in check_for_loop_decls,    but does it make any sense for this to be included in the grammar?    Note in particular that the nested function does not include a    trailing ';', whereas the "declaration" production includes one.    Also, can we reject bad declarations earlier and cheaper than    check_for_loop_decls?  */
end_comment

begin_function
specifier|static
name|void
name|c_parser_for_statement
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|)
block|{
comment|/* APPLE LOCAL begin for-fsf-4_4 3274130 5295549 */
block|\
name|tree
name|block
decl_stmt|,
name|cond
decl_stmt|,
name|incr
decl_stmt|,
name|save_break
decl_stmt|,
name|save_cont
decl_stmt|,
name|body
decl_stmt|,
name|attrs
decl_stmt|;
comment|/* APPLE LOCAL end for-fsf-4_4 3274130 5295549 */
block|\
name|location_t
name|loc
decl_stmt|;
name|gcc_assert
argument_list|(
name|c_parser_next_token_is_keyword
argument_list|(
name|parser
argument_list|,
name|RID_FOR
argument_list|)
argument_list|)
expr_stmt|;
name|loc
operator|=
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
operator|->
name|location
expr_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* APPLE LOCAL begin for-fsf-4_4 3274130 5295549 */
block|\
name|attrs
operator|=
name|c_parser_attributes
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* APPLE LOCAL end for-fsf-4_4 3274130 5295549 */
block|\
name|block
operator|=
name|c_begin_compound_stmt
argument_list|(
name|flag_isoc99
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_PAREN
argument_list|,
literal|"expected %<(%>"
argument_list|)
condition|)
block|{
comment|/* Parse the initialization declaration or expression.  */
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_SEMICOLON
argument_list|)
condition|)
block|{
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|c_finish_expr_stmt
argument_list|(
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c_parser_next_token_starts_declspecs
argument_list|(
name|parser
argument_list|)
condition|)
block|{
name|c_parser_declaration_or_fndef
argument_list|(
name|parser
argument_list|,
name|true
argument_list|,
name|true
argument_list|,
name|true
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|check_for_loop_decls
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c_parser_next_token_is_keyword
argument_list|(
name|parser
argument_list|,
name|RID_EXTENSION
argument_list|)
condition|)
block|{
comment|/* __extension__ can start a declaration, but is also an 	     unary operator that can start an expression.  Consume all 	     but the last of a possible series of __extension__ to 	     determine which.  */
while|while
condition|(
name|c_parser_peek_2nd_token
argument_list|(
name|parser
argument_list|)
operator|->
name|type
operator|==
name|CPP_KEYWORD
operator|&&
operator|(
name|c_parser_peek_2nd_token
argument_list|(
name|parser
argument_list|)
operator|->
name|keyword
operator|==
name|RID_EXTENSION
operator|)
condition|)
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_token_starts_declspecs
argument_list|(
name|c_parser_peek_2nd_token
argument_list|(
name|parser
argument_list|)
argument_list|)
condition|)
block|{
name|int
name|ext
decl_stmt|;
name|ext
operator|=
name|disable_extension_diagnostics
argument_list|()
expr_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|c_parser_declaration_or_fndef
argument_list|(
name|parser
argument_list|,
name|true
argument_list|,
name|true
argument_list|,
name|true
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|restore_extension_diagnostics
argument_list|(
name|ext
argument_list|)
expr_stmt|;
name|check_for_loop_decls
argument_list|()
expr_stmt|;
block|}
else|else
goto|goto
name|init_expr
goto|;
block|}
else|else
block|{
name|init_expr
label|:
name|c_finish_expr_stmt
argument_list|(
name|c_parser_expression
argument_list|(
name|parser
argument_list|)
operator|.
name|value
argument_list|)
expr_stmt|;
name|c_parser_skip_until_found
argument_list|(
name|parser
argument_list|,
name|CPP_SEMICOLON
argument_list|,
literal|"expected %<;%>"
argument_list|)
expr_stmt|;
block|}
comment|/* Parse the loop condition.  */
name|loc
operator|=
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
operator|->
name|location
expr_stmt|;
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_SEMICOLON
argument_list|)
condition|)
block|{
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|cond
operator|=
name|NULL_TREE
expr_stmt|;
block|}
else|else
block|{
name|tree
name|ocond
init|=
name|c_parser_expression_conv
argument_list|(
name|parser
argument_list|)
operator|.
name|value
decl_stmt|;
name|cond
operator|=
name|c_objc_common_truthvalue_conversion
argument_list|(
name|ocond
argument_list|)
expr_stmt|;
if|if
condition|(
name|EXPR_P
argument_list|(
name|cond
argument_list|)
condition|)
name|SET_EXPR_LOCATION
argument_list|(
name|cond
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|c_parser_skip_until_found
argument_list|(
name|parser
argument_list|,
name|CPP_SEMICOLON
argument_list|,
literal|"expected %<;%>"
argument_list|)
expr_stmt|;
block|}
comment|/* Parse the increment expression.  */
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|)
condition|)
name|incr
operator|=
name|c_process_expr_stmt
argument_list|(
name|NULL_TREE
argument_list|)
expr_stmt|;
else|else
name|incr
operator|=
name|c_process_expr_stmt
argument_list|(
name|c_parser_expression
argument_list|(
name|parser
argument_list|)
operator|.
name|value
argument_list|)
expr_stmt|;
name|c_parser_skip_until_found
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
literal|"expected %<)%>"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cond
operator|=
name|error_mark_node
expr_stmt|;
name|incr
operator|=
name|error_mark_node
expr_stmt|;
block|}
name|save_break
operator|=
name|c_break_label
expr_stmt|;
name|c_break_label
operator|=
name|NULL_TREE
expr_stmt|;
name|save_cont
operator|=
name|c_cont_label
expr_stmt|;
name|c_cont_label
operator|=
name|NULL_TREE
expr_stmt|;
name|body
operator|=
name|c_parser_c99_block_statement
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* APPLE LOCAL begin for-fsf-4_4 3274130 5295549 */
block|\
name|c_finish_loop
argument_list|(
name|loc
argument_list|,
name|cond
argument_list|,
name|incr
argument_list|,
name|body
argument_list|,
name|c_break_label
argument_list|,
name|c_cont_label
argument_list|,
name|attrs
argument_list|,
name|true
argument_list|)
expr_stmt|;
comment|/* APPLE LOCAL end for-fsf-4_4 3274130 5295549 */
block|\
name|add_stmt
argument_list|(
name|c_end_compound_stmt
argument_list|(
name|block
argument_list|,
name|flag_isoc99
argument_list|)
argument_list|)
expr_stmt|;
name|c_break_label
operator|=
name|save_break
expr_stmt|;
name|c_cont_label
operator|=
name|save_cont
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse an asm statement, a GNU extension.  This is a full-blown asm    statement with inputs, outputs, clobbers, and volatile tag    allowed.     asm-statement:      asm type-qualifier[opt] ( asm-argument ) ;     asm-argument:      asm-string-literal      asm-string-literal : asm-operands[opt]      asm-string-literal : asm-operands[opt] : asm-operands[opt]      asm-string-literal : asm-operands[opt] : asm-operands[opt] : asm-clobbers     Qualifiers other than volatile are accepted in the syntax but    warned for.  */
end_comment

begin_function
specifier|static
name|tree
name|c_parser_asm_statement
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|quals
decl_stmt|,
name|str
decl_stmt|,
name|outputs
decl_stmt|,
name|inputs
decl_stmt|,
name|clobbers
decl_stmt|,
name|ret
decl_stmt|;
name|bool
name|simple
decl_stmt|;
name|gcc_assert
argument_list|(
name|c_parser_next_token_is_keyword
argument_list|(
name|parser
argument_list|,
name|RID_ASM
argument_list|)
argument_list|)
expr_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_parser_next_token_is_keyword
argument_list|(
name|parser
argument_list|,
name|RID_VOLATILE
argument_list|)
condition|)
block|{
name|quals
operator|=
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
operator|->
name|value
expr_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c_parser_next_token_is_keyword
argument_list|(
name|parser
argument_list|,
name|RID_CONST
argument_list|)
operator|||
name|c_parser_next_token_is_keyword
argument_list|(
name|parser
argument_list|,
name|RID_RESTRICT
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|0
argument_list|,
literal|"%E qualifier ignored on asm"
argument_list|,
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
operator|->
name|value
argument_list|)
expr_stmt|;
name|quals
operator|=
name|NULL_TREE
expr_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
else|else
name|quals
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* ??? Follow the C++ parser rather than using the      c_lex_string_translate kludge.  */
name|c_lex_string_translate
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|c_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_PAREN
argument_list|,
literal|"expected %<(%>"
argument_list|)
condition|)
block|{
name|c_lex_string_translate
operator|=
literal|1
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
name|str
operator|=
name|c_parser_asm_string_literal
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|)
condition|)
block|{
name|simple
operator|=
name|true
expr_stmt|;
name|outputs
operator|=
name|NULL_TREE
expr_stmt|;
name|inputs
operator|=
name|NULL_TREE
expr_stmt|;
name|clobbers
operator|=
name|NULL_TREE
expr_stmt|;
goto|goto
name|done_asm
goto|;
block|}
if|if
condition|(
operator|!
name|c_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_COLON
argument_list|,
literal|"expected %<:%> or %<)%>"
argument_list|)
condition|)
block|{
name|c_lex_string_translate
operator|=
literal|1
expr_stmt|;
name|c_parser_skip_until_found
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
name|simple
operator|=
name|false
expr_stmt|;
comment|/* Parse outputs.  */
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_COLON
argument_list|)
operator|||
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|)
condition|)
name|outputs
operator|=
name|NULL_TREE
expr_stmt|;
else|else
name|outputs
operator|=
name|c_parser_asm_operands
argument_list|(
name|parser
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|)
condition|)
block|{
name|inputs
operator|=
name|NULL_TREE
expr_stmt|;
name|clobbers
operator|=
name|NULL_TREE
expr_stmt|;
goto|goto
name|done_asm
goto|;
block|}
if|if
condition|(
operator|!
name|c_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_COLON
argument_list|,
literal|"expected %<:%> or %<)%>"
argument_list|)
condition|)
block|{
name|c_lex_string_translate
operator|=
literal|1
expr_stmt|;
name|c_parser_skip_until_found
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
comment|/* Parse inputs.  */
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_COLON
argument_list|)
operator|||
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|)
condition|)
name|inputs
operator|=
name|NULL_TREE
expr_stmt|;
else|else
name|inputs
operator|=
name|c_parser_asm_operands
argument_list|(
name|parser
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|)
condition|)
block|{
name|clobbers
operator|=
name|NULL_TREE
expr_stmt|;
goto|goto
name|done_asm
goto|;
block|}
if|if
condition|(
operator|!
name|c_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_COLON
argument_list|,
literal|"expected %<:%> or %<)%>"
argument_list|)
condition|)
block|{
name|c_lex_string_translate
operator|=
literal|1
expr_stmt|;
name|c_parser_skip_until_found
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
comment|/* Parse clobbers.  */
name|clobbers
operator|=
name|c_parser_asm_clobbers
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|done_asm
label|:
name|c_lex_string_translate
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|c_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
literal|"expected %<)%>"
argument_list|)
condition|)
block|{
name|c_parser_skip_until_found
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
if|if
condition|(
operator|!
name|c_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_SEMICOLON
argument_list|,
literal|"expected %<;%>"
argument_list|)
condition|)
name|c_parser_skip_to_end_of_block_or_statement
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|ret
operator|=
name|build_asm_stmt
argument_list|(
name|quals
argument_list|,
name|build_asm_expr
argument_list|(
name|str
argument_list|,
name|outputs
argument_list|,
name|inputs
argument_list|,
name|clobbers
argument_list|,
name|simple
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Parse asm operands, a GNU extension.  If CONVERT_P (for inputs but    not outputs), apply the default conversion of functions and arrays    to pointers.     asm-operands:      asm-operand      asm-operands , asm-operand     asm-operand:      asm-string-literal ( expression )      [ identifier ] asm-string-literal ( expression ) */
end_comment

begin_function
specifier|static
name|tree
name|c_parser_asm_operands
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|,
name|bool
name|convert_p
parameter_list|)
block|{
name|tree
name|list
init|=
name|NULL_TREE
decl_stmt|;
while|while
condition|(
name|true
condition|)
block|{
name|tree
name|name
decl_stmt|,
name|str
decl_stmt|;
name|struct
name|c_expr
name|expr
decl_stmt|;
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_SQUARE
argument_list|)
condition|)
block|{
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_NAME
argument_list|)
condition|)
block|{
name|tree
name|id
init|=
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
operator|->
name|value
decl_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|name
operator|=
name|build_string
argument_list|(
name|IDENTIFIER_LENGTH
argument_list|(
name|id
argument_list|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|c_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected identifier"
argument_list|)
expr_stmt|;
name|c_parser_skip_until_found
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_SQUARE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
name|c_parser_skip_until_found
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_SQUARE
argument_list|,
literal|"expected %<]%>"
argument_list|)
expr_stmt|;
block|}
else|else
name|name
operator|=
name|NULL_TREE
expr_stmt|;
name|str
operator|=
name|c_parser_asm_string_literal
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
operator|==
name|NULL_TREE
condition|)
return|return
name|NULL_TREE
return|;
name|c_lex_string_translate
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|c_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_PAREN
argument_list|,
literal|"expected %<(%>"
argument_list|)
condition|)
block|{
name|c_lex_string_translate
operator|=
literal|0
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
name|expr
operator|=
name|c_parser_expression
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|convert_p
condition|)
name|expr
operator|=
name|default_function_array_conversion
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|c_lex_string_translate
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|c_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
literal|"expected %<)%>"
argument_list|)
condition|)
block|{
name|c_parser_skip_until_found
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
name|list
operator|=
name|chainon
argument_list|(
name|list
argument_list|,
name|build_tree_list
argument_list|(
name|build_tree_list
argument_list|(
name|name
argument_list|,
name|str
argument_list|)
argument_list|,
name|expr
operator|.
name|value
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_COMMA
argument_list|)
condition|)
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
else|else
break|break;
block|}
return|return
name|list
return|;
block|}
end_function

begin_comment
comment|/* Parse asm clobbers, a GNU extension.     asm-clobbers:      asm-string-literal      asm-clobbers , asm-string-literal */
end_comment

begin_function
specifier|static
name|tree
name|c_parser_asm_clobbers
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|list
init|=
name|NULL_TREE
decl_stmt|;
while|while
condition|(
name|true
condition|)
block|{
name|tree
name|str
init|=
name|c_parser_asm_string_literal
argument_list|(
name|parser
argument_list|)
decl_stmt|;
if|if
condition|(
name|str
condition|)
name|list
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|str
argument_list|,
name|list
argument_list|)
expr_stmt|;
else|else
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_COMMA
argument_list|)
condition|)
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
else|else
break|break;
block|}
return|return
name|list
return|;
block|}
end_function

begin_comment
comment|/* Parse an expression other than a compound expression; that is, an    assignment expression (C90 6.3.16, C99 6.5.16).  If AFTER is not    NULL then it is an Objective-C message expression which is the    primary-expression starting the expression as an initializer.     assignment-expression:      conditional-expression      unary-expression assignment-operator assignment-expression     assignment-operator: one of      = *= /= %= += -=<<=>>=&= ^= |=     In GNU C we accept any conditional expression on the LHS and    diagnose the invalid lvalue rather than producing a syntax    error.  */
end_comment

begin_function
specifier|static
name|struct
name|c_expr
name|c_parser_expr_no_commas
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|,
name|struct
name|c_expr
modifier|*
name|after
parameter_list|)
block|{
name|struct
name|c_expr
name|lhs
decl_stmt|,
name|rhs
decl_stmt|,
name|ret
decl_stmt|;
name|enum
name|tree_code
name|code
decl_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|after
operator|||
name|c_dialect_objc
argument_list|()
argument_list|)
expr_stmt|;
name|lhs
operator|=
name|c_parser_conditional_expression
argument_list|(
name|parser
argument_list|,
name|after
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
operator|->
name|type
condition|)
block|{
case|case
name|CPP_EQ
case|:
name|code
operator|=
name|NOP_EXPR
expr_stmt|;
break|break;
case|case
name|CPP_MULT_EQ
case|:
name|code
operator|=
name|MULT_EXPR
expr_stmt|;
break|break;
case|case
name|CPP_DIV_EQ
case|:
name|code
operator|=
name|TRUNC_DIV_EXPR
expr_stmt|;
break|break;
case|case
name|CPP_MOD_EQ
case|:
name|code
operator|=
name|TRUNC_MOD_EXPR
expr_stmt|;
break|break;
case|case
name|CPP_PLUS_EQ
case|:
name|code
operator|=
name|PLUS_EXPR
expr_stmt|;
break|break;
case|case
name|CPP_MINUS_EQ
case|:
name|code
operator|=
name|MINUS_EXPR
expr_stmt|;
break|break;
case|case
name|CPP_LSHIFT_EQ
case|:
name|code
operator|=
name|LSHIFT_EXPR
expr_stmt|;
break|break;
case|case
name|CPP_RSHIFT_EQ
case|:
name|code
operator|=
name|RSHIFT_EXPR
expr_stmt|;
break|break;
case|case
name|CPP_AND_EQ
case|:
name|code
operator|=
name|BIT_AND_EXPR
expr_stmt|;
break|break;
case|case
name|CPP_XOR_EQ
case|:
name|code
operator|=
name|BIT_XOR_EXPR
expr_stmt|;
break|break;
case|case
name|CPP_OR_EQ
case|:
name|code
operator|=
name|BIT_IOR_EXPR
expr_stmt|;
break|break;
default|default:
return|return
name|lhs
return|;
block|}
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|rhs
operator|=
name|c_parser_expr_no_commas
argument_list|(
name|parser
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|rhs
operator|=
name|default_function_array_conversion
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
name|ret
operator|.
name|value
operator|=
name|build_modify_expr
argument_list|(
name|lhs
operator|.
name|value
argument_list|,
name|code
argument_list|,
name|rhs
operator|.
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|NOP_EXPR
condition|)
name|ret
operator|.
name|original_code
operator|=
name|MODIFY_EXPR
expr_stmt|;
else|else
block|{
name|TREE_NO_WARNING
argument_list|(
name|ret
operator|.
name|value
argument_list|)
operator|=
literal|1
expr_stmt|;
name|ret
operator|.
name|original_code
operator|=
name|ERROR_MARK
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Parse a conditional expression (C90 6.3.15, C99 6.5.15).  If AFTER    is not NULL then it is an Objective-C message expression which is    the primary-expression starting the expression as an initializer.     conditional-expression:      logical-OR-expression      logical-OR-expression ? expression : conditional-expression     GNU extensions:     conditional-expression:      logical-OR-expression ? : conditional-expression */
end_comment

begin_function
specifier|static
name|struct
name|c_expr
name|c_parser_conditional_expression
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|,
name|struct
name|c_expr
modifier|*
name|after
parameter_list|)
block|{
name|struct
name|c_expr
name|cond
decl_stmt|,
name|exp1
decl_stmt|,
name|exp2
decl_stmt|,
name|ret
decl_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|after
operator|||
name|c_dialect_objc
argument_list|()
argument_list|)
expr_stmt|;
name|cond
operator|=
name|c_parser_binary_expression
argument_list|(
name|parser
argument_list|,
name|after
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_parser_next_token_is_not
argument_list|(
name|parser
argument_list|,
name|CPP_QUERY
argument_list|)
condition|)
return|return
name|cond
return|;
name|cond
operator|=
name|default_function_array_conversion
argument_list|(
name|cond
argument_list|)
expr_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_COLON
argument_list|)
condition|)
block|{
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"ISO C forbids omitting the middle term of a ?: expression"
argument_list|)
expr_stmt|;
comment|/* Make sure first operand is calculated only once.  */
name|exp1
operator|.
name|value
operator|=
name|save_expr
argument_list|(
name|default_conversion
argument_list|(
name|cond
operator|.
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|cond
operator|.
name|value
operator|=
name|c_objc_common_truthvalue_conversion
argument_list|(
name|exp1
operator|.
name|value
argument_list|)
expr_stmt|;
name|skip_evaluation
operator|+=
name|cond
operator|.
name|value
operator|==
name|truthvalue_true_node
expr_stmt|;
block|}
else|else
block|{
name|cond
operator|.
name|value
operator|=
name|c_objc_common_truthvalue_conversion
argument_list|(
name|default_conversion
argument_list|(
name|cond
operator|.
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|skip_evaluation
operator|+=
name|cond
operator|.
name|value
operator|==
name|truthvalue_false_node
expr_stmt|;
name|exp1
operator|=
name|c_parser_expression_conv
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|skip_evaluation
operator|+=
operator|(
operator|(
name|cond
operator|.
name|value
operator|==
name|truthvalue_true_node
operator|)
operator|-
operator|(
name|cond
operator|.
name|value
operator|==
name|truthvalue_false_node
operator|)
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|c_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_COLON
argument_list|,
literal|"expected %<:%>"
argument_list|)
condition|)
block|{
name|skip_evaluation
operator|-=
name|cond
operator|.
name|value
operator|==
name|truthvalue_true_node
expr_stmt|;
name|ret
operator|.
name|value
operator|=
name|error_mark_node
expr_stmt|;
name|ret
operator|.
name|original_code
operator|=
name|ERROR_MARK
expr_stmt|;
return|return
name|ret
return|;
block|}
name|exp2
operator|=
name|c_parser_conditional_expression
argument_list|(
name|parser
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|exp2
operator|=
name|default_function_array_conversion
argument_list|(
name|exp2
argument_list|)
expr_stmt|;
name|skip_evaluation
operator|-=
name|cond
operator|.
name|value
operator|==
name|truthvalue_true_node
expr_stmt|;
name|ret
operator|.
name|value
operator|=
name|build_conditional_expr
argument_list|(
name|cond
operator|.
name|value
argument_list|,
name|exp1
operator|.
name|value
argument_list|,
name|exp2
operator|.
name|value
argument_list|)
expr_stmt|;
name|ret
operator|.
name|original_code
operator|=
name|ERROR_MARK
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Parse a binary expression; that is, a logical-OR-expression (C90    6.3.5-6.3.14, C99 6.5.5-6.5.14).  If AFTER is not NULL then it is    an Objective-C message expression which is the primary-expression    starting the expression as an initializer.     multiplicative-expression:      cast-expression      multiplicative-expression * cast-expression      multiplicative-expression / cast-expression      multiplicative-expression % cast-expression     additive-expression:      multiplicative-expression      additive-expression + multiplicative-expression      additive-expression - multiplicative-expression     shift-expression:      additive-expression      shift-expression<< additive-expression      shift-expression>> additive-expression     relational-expression:      shift-expression      relational-expression< shift-expression      relational-expression> shift-expression      relational-expression<= shift-expression      relational-expression>= shift-expression     equality-expression:      relational-expression      equality-expression == relational-expression      equality-expression != relational-expression     AND-expression:      equality-expression      AND-expression& equality-expression     exclusive-OR-expression:      AND-expression      exclusive-OR-expression ^ AND-expression     inclusive-OR-expression:      exclusive-OR-expression      inclusive-OR-expression | exclusive-OR-expression     logical-AND-expression:      inclusive-OR-expression      logical-AND-expression&& inclusive-OR-expression     logical-OR-expression:      logical-AND-expression      logical-OR-expression || logical-AND-expression */
end_comment

begin_function
specifier|static
name|struct
name|c_expr
name|c_parser_binary_expression
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|,
name|struct
name|c_expr
modifier|*
name|after
parameter_list|)
block|{
comment|/* A binary expression is parsed using operator-precedence parsing,      with the operands being cast expressions.  All the binary      operators are left-associative.  Thus a binary expression is of      form:       E0 op1 E1 op2 E2 ...       which we represent on a stack.  On the stack, the precedence      levels are strictly increasing.  When a new operator is      encountered of higher precedence than that at the top of the      stack, it is pushed; its LHS is the top expression, and its RHS      is everything parsed until it is popped.  When a new operator is      encountered with precedence less than or equal to that at the top      of the stack, triples E[i-1] op[i] E[i] are popped and replaced      by the result of the operation until the operator at the top of      the stack has lower precedence than the new operator or there is      only one element on the stack; then the top expression is the LHS      of the new operator.  In the case of logical AND and OR      expressions, we also need to adjust skip_evaluation as      appropriate when the operators are pushed and popped.  */
comment|/* The precedence levels, where 0 is a dummy lowest level used for      the bottom of the stack.  */
enum|enum
name|prec
block|{
name|PREC_NONE
block|,
name|PREC_LOGOR
block|,
name|PREC_LOGAND
block|,
name|PREC_BITOR
block|,
name|PREC_BITXOR
block|,
name|PREC_BITAND
block|,
name|PREC_EQ
block|,
name|PREC_REL
block|,
name|PREC_SHIFT
block|,
name|PREC_ADD
block|,
name|PREC_MULT
block|,
name|NUM_PRECS
block|}
enum|;
struct|struct
block|{
comment|/* The expression at this stack level.  */
name|struct
name|c_expr
name|expr
decl_stmt|;
comment|/* The precedence of the operator on its left, PREC_NONE at the        bottom of the stack.  */
name|enum
name|prec
name|prec
decl_stmt|;
comment|/* The operation on its left.  */
name|enum
name|tree_code
name|op
decl_stmt|;
block|}
name|stack
index|[
name|NUM_PRECS
index|]
struct|;
name|int
name|sp
decl_stmt|;
define|#
directive|define
name|POP
define|\
value|do {									      \     switch (stack[sp].op)						      \       {									      \       case TRUTH_ANDIF_EXPR:						      \ 	skip_evaluation -= stack[sp - 1].expr.value == truthvalue_false_node; \ 	break;								      \       case TRUTH_ORIF_EXPR:						      \ 	skip_evaluation -= stack[sp - 1].expr.value == truthvalue_true_node;  \ 	break;								      \       default:								      \ 	break;								      \       }									      \     stack[sp - 1].expr							      \       = default_function_array_conversion (stack[sp - 1].expr);		      \     stack[sp].expr							      \       = default_function_array_conversion (stack[sp].expr);		      \     stack[sp - 1].expr = parser_build_binary_op (stack[sp].op,		      \ 						 stack[sp - 1].expr,	      \ 						 stack[sp].expr);	      \     sp--;								      \   } while (0)
name|gcc_assert
argument_list|(
operator|!
name|after
operator|||
name|c_dialect_objc
argument_list|()
argument_list|)
expr_stmt|;
name|stack
index|[
literal|0
index|]
operator|.
name|expr
operator|=
name|c_parser_cast_expression
argument_list|(
name|parser
argument_list|,
name|after
argument_list|)
expr_stmt|;
name|stack
index|[
literal|0
index|]
operator|.
name|prec
operator|=
name|PREC_NONE
expr_stmt|;
name|sp
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|true
condition|)
block|{
name|enum
name|prec
name|oprec
decl_stmt|;
name|enum
name|tree_code
name|ocode
decl_stmt|;
if|if
condition|(
name|parser
operator|->
name|error
condition|)
goto|goto
name|out
goto|;
switch|switch
condition|(
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
operator|->
name|type
condition|)
block|{
case|case
name|CPP_MULT
case|:
name|oprec
operator|=
name|PREC_MULT
expr_stmt|;
name|ocode
operator|=
name|MULT_EXPR
expr_stmt|;
break|break;
case|case
name|CPP_DIV
case|:
name|oprec
operator|=
name|PREC_MULT
expr_stmt|;
name|ocode
operator|=
name|TRUNC_DIV_EXPR
expr_stmt|;
break|break;
case|case
name|CPP_MOD
case|:
name|oprec
operator|=
name|PREC_MULT
expr_stmt|;
name|ocode
operator|=
name|TRUNC_MOD_EXPR
expr_stmt|;
break|break;
case|case
name|CPP_PLUS
case|:
name|oprec
operator|=
name|PREC_ADD
expr_stmt|;
name|ocode
operator|=
name|PLUS_EXPR
expr_stmt|;
break|break;
case|case
name|CPP_MINUS
case|:
name|oprec
operator|=
name|PREC_ADD
expr_stmt|;
name|ocode
operator|=
name|MINUS_EXPR
expr_stmt|;
break|break;
case|case
name|CPP_LSHIFT
case|:
name|oprec
operator|=
name|PREC_SHIFT
expr_stmt|;
name|ocode
operator|=
name|LSHIFT_EXPR
expr_stmt|;
break|break;
case|case
name|CPP_RSHIFT
case|:
name|oprec
operator|=
name|PREC_SHIFT
expr_stmt|;
name|ocode
operator|=
name|RSHIFT_EXPR
expr_stmt|;
break|break;
case|case
name|CPP_LESS
case|:
name|oprec
operator|=
name|PREC_REL
expr_stmt|;
name|ocode
operator|=
name|LT_EXPR
expr_stmt|;
break|break;
case|case
name|CPP_GREATER
case|:
name|oprec
operator|=
name|PREC_REL
expr_stmt|;
name|ocode
operator|=
name|GT_EXPR
expr_stmt|;
break|break;
case|case
name|CPP_LESS_EQ
case|:
name|oprec
operator|=
name|PREC_REL
expr_stmt|;
name|ocode
operator|=
name|LE_EXPR
expr_stmt|;
break|break;
case|case
name|CPP_GREATER_EQ
case|:
name|oprec
operator|=
name|PREC_REL
expr_stmt|;
name|ocode
operator|=
name|GE_EXPR
expr_stmt|;
break|break;
case|case
name|CPP_EQ_EQ
case|:
name|oprec
operator|=
name|PREC_EQ
expr_stmt|;
name|ocode
operator|=
name|EQ_EXPR
expr_stmt|;
break|break;
case|case
name|CPP_NOT_EQ
case|:
name|oprec
operator|=
name|PREC_EQ
expr_stmt|;
name|ocode
operator|=
name|NE_EXPR
expr_stmt|;
break|break;
case|case
name|CPP_AND
case|:
name|oprec
operator|=
name|PREC_BITAND
expr_stmt|;
name|ocode
operator|=
name|BIT_AND_EXPR
expr_stmt|;
break|break;
case|case
name|CPP_XOR
case|:
name|oprec
operator|=
name|PREC_BITXOR
expr_stmt|;
name|ocode
operator|=
name|BIT_XOR_EXPR
expr_stmt|;
break|break;
case|case
name|CPP_OR
case|:
name|oprec
operator|=
name|PREC_BITOR
expr_stmt|;
name|ocode
operator|=
name|BIT_IOR_EXPR
expr_stmt|;
break|break;
case|case
name|CPP_AND_AND
case|:
name|oprec
operator|=
name|PREC_LOGAND
expr_stmt|;
name|ocode
operator|=
name|TRUTH_ANDIF_EXPR
expr_stmt|;
break|break;
case|case
name|CPP_OR_OR
case|:
name|oprec
operator|=
name|PREC_LOGOR
expr_stmt|;
name|ocode
operator|=
name|TRUTH_ORIF_EXPR
expr_stmt|;
break|break;
default|default:
comment|/* Not a binary operator, so end of the binary 	     expression.  */
goto|goto
name|out
goto|;
block|}
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
while|while
condition|(
name|oprec
operator|<=
name|stack
index|[
name|sp
index|]
operator|.
name|prec
condition|)
name|POP
expr_stmt|;
switch|switch
condition|(
name|ocode
condition|)
block|{
case|case
name|TRUTH_ANDIF_EXPR
case|:
name|stack
index|[
name|sp
index|]
operator|.
name|expr
operator|=
name|default_function_array_conversion
argument_list|(
name|stack
index|[
name|sp
index|]
operator|.
name|expr
argument_list|)
expr_stmt|;
name|stack
index|[
name|sp
index|]
operator|.
name|expr
operator|.
name|value
operator|=
name|c_objc_common_truthvalue_conversion
argument_list|(
name|default_conversion
argument_list|(
name|stack
index|[
name|sp
index|]
operator|.
name|expr
operator|.
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|skip_evaluation
operator|+=
name|stack
index|[
name|sp
index|]
operator|.
name|expr
operator|.
name|value
operator|==
name|truthvalue_false_node
expr_stmt|;
break|break;
case|case
name|TRUTH_ORIF_EXPR
case|:
name|stack
index|[
name|sp
index|]
operator|.
name|expr
operator|=
name|default_function_array_conversion
argument_list|(
name|stack
index|[
name|sp
index|]
operator|.
name|expr
argument_list|)
expr_stmt|;
name|stack
index|[
name|sp
index|]
operator|.
name|expr
operator|.
name|value
operator|=
name|c_objc_common_truthvalue_conversion
argument_list|(
name|default_conversion
argument_list|(
name|stack
index|[
name|sp
index|]
operator|.
name|expr
operator|.
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|skip_evaluation
operator|+=
name|stack
index|[
name|sp
index|]
operator|.
name|expr
operator|.
name|value
operator|==
name|truthvalue_true_node
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|sp
operator|++
expr_stmt|;
name|stack
index|[
name|sp
index|]
operator|.
name|expr
operator|=
name|c_parser_cast_expression
argument_list|(
name|parser
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|stack
index|[
name|sp
index|]
operator|.
name|prec
operator|=
name|oprec
expr_stmt|;
name|stack
index|[
name|sp
index|]
operator|.
name|op
operator|=
name|ocode
expr_stmt|;
block|}
name|out
label|:
while|while
condition|(
name|sp
operator|>
literal|0
condition|)
name|POP
expr_stmt|;
return|return
name|stack
index|[
literal|0
index|]
operator|.
name|expr
return|;
undef|#
directive|undef
name|POP
block|}
end_function

begin_comment
comment|/* Parse a cast expression (C90 6.3.4, C99 6.5.4).  If AFTER is not    NULL then it is an Objective-C message expression which is the    primary-expression starting the expression as an initializer.     cast-expression:      unary-expression      ( type-name ) unary-expression */
end_comment

begin_function
specifier|static
name|struct
name|c_expr
name|c_parser_cast_expression
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|,
name|struct
name|c_expr
modifier|*
name|after
parameter_list|)
block|{
name|gcc_assert
argument_list|(
operator|!
name|after
operator|||
name|c_dialect_objc
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|after
condition|)
return|return
name|c_parser_postfix_expression_after_primary
argument_list|(
name|parser
argument_list|,
operator|*
name|after
argument_list|)
return|;
comment|/* If the expression begins with a parenthesized type name, it may      be either a cast or a compound literal; we need to see whether      the next character is '{' to tell the difference.  If not, it is      an unary expression.  */
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_PAREN
argument_list|)
operator|&&
name|c_token_starts_typename
argument_list|(
name|c_parser_peek_2nd_token
argument_list|(
name|parser
argument_list|)
argument_list|)
condition|)
block|{
name|struct
name|c_type_name
modifier|*
name|type_name
decl_stmt|;
name|struct
name|c_expr
name|ret
decl_stmt|;
name|struct
name|c_expr
name|expr
decl_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|type_name
operator|=
name|c_parser_type_name
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|c_parser_skip_until_found
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
literal|"expected %<)%>"
argument_list|)
expr_stmt|;
if|if
condition|(
name|type_name
operator|==
name|NULL
condition|)
block|{
name|ret
operator|.
name|value
operator|=
name|error_mark_node
expr_stmt|;
name|ret
operator|.
name|original_code
operator|=
name|ERROR_MARK
expr_stmt|;
return|return
name|ret
return|;
block|}
comment|/* Save casted types in the function's used types hash table.  */
name|used_types_insert
argument_list|(
name|type_name
operator|->
name|specs
operator|->
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_BRACE
argument_list|)
condition|)
return|return
name|c_parser_postfix_expression_after_paren_type
argument_list|(
name|parser
argument_list|,
name|type_name
argument_list|)
return|;
name|expr
operator|=
name|c_parser_cast_expression
argument_list|(
name|parser
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|expr
operator|=
name|default_function_array_conversion
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|ret
operator|.
name|value
operator|=
name|c_cast_expr
argument_list|(
name|type_name
argument_list|,
name|expr
operator|.
name|value
argument_list|)
expr_stmt|;
name|ret
operator|.
name|original_code
operator|=
name|ERROR_MARK
expr_stmt|;
return|return
name|ret
return|;
block|}
else|else
return|return
name|c_parser_unary_expression
argument_list|(
name|parser
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Parse an unary expression (C90 6.3.3, C99 6.5.3).     unary-expression:      postfix-expression      ++ unary-expression      -- unary-expression      unary-operator cast-expression      sizeof unary-expression      sizeof ( type-name )     unary-operator: one of& * + - ~ !     GNU extensions:     unary-expression:      __alignof__ unary-expression      __alignof__ ( type-name )&& identifier     unary-operator: one of      __extension__ __real__ __imag__     In addition, the GNU syntax treats ++ and -- as unary operators, so    they may be applied to cast expressions with errors for non-lvalues    given later.  */
end_comment

begin_function
specifier|static
name|struct
name|c_expr
name|c_parser_unary_expression
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|)
block|{
name|int
name|ext
decl_stmt|;
name|struct
name|c_expr
name|ret
decl_stmt|,
name|op
decl_stmt|;
switch|switch
condition|(
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
operator|->
name|type
condition|)
block|{
case|case
name|CPP_PLUS_PLUS
case|:
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|op
operator|=
name|c_parser_cast_expression
argument_list|(
name|parser
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|op
operator|=
name|default_function_array_conversion
argument_list|(
name|op
argument_list|)
expr_stmt|;
return|return
name|parser_build_unary_op
argument_list|(
name|PREINCREMENT_EXPR
argument_list|,
name|op
argument_list|)
return|;
case|case
name|CPP_MINUS_MINUS
case|:
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|op
operator|=
name|c_parser_cast_expression
argument_list|(
name|parser
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|op
operator|=
name|default_function_array_conversion
argument_list|(
name|op
argument_list|)
expr_stmt|;
return|return
name|parser_build_unary_op
argument_list|(
name|PREDECREMENT_EXPR
argument_list|,
name|op
argument_list|)
return|;
case|case
name|CPP_AND
case|:
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
return|return
name|parser_build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|c_parser_cast_expression
argument_list|(
name|parser
argument_list|,
name|NULL
argument_list|)
argument_list|)
return|;
case|case
name|CPP_MULT
case|:
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|op
operator|=
name|c_parser_cast_expression
argument_list|(
name|parser
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|op
operator|=
name|default_function_array_conversion
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|ret
operator|.
name|value
operator|=
name|build_indirect_ref
argument_list|(
name|op
operator|.
name|value
argument_list|,
literal|"unary *"
argument_list|)
expr_stmt|;
name|ret
operator|.
name|original_code
operator|=
name|ERROR_MARK
expr_stmt|;
return|return
name|ret
return|;
case|case
name|CPP_PLUS
case|:
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|c_dialect_objc
argument_list|()
operator|&&
operator|!
name|in_system_header
condition|)
name|warning
argument_list|(
name|OPT_Wtraditional
argument_list|,
literal|"traditional C rejects the unary plus operator"
argument_list|)
expr_stmt|;
name|op
operator|=
name|c_parser_cast_expression
argument_list|(
name|parser
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|op
operator|=
name|default_function_array_conversion
argument_list|(
name|op
argument_list|)
expr_stmt|;
return|return
name|parser_build_unary_op
argument_list|(
name|CONVERT_EXPR
argument_list|,
name|op
argument_list|)
return|;
case|case
name|CPP_MINUS
case|:
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|op
operator|=
name|c_parser_cast_expression
argument_list|(
name|parser
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|op
operator|=
name|default_function_array_conversion
argument_list|(
name|op
argument_list|)
expr_stmt|;
return|return
name|parser_build_unary_op
argument_list|(
name|NEGATE_EXPR
argument_list|,
name|op
argument_list|)
return|;
case|case
name|CPP_COMPL
case|:
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|op
operator|=
name|c_parser_cast_expression
argument_list|(
name|parser
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|op
operator|=
name|default_function_array_conversion
argument_list|(
name|op
argument_list|)
expr_stmt|;
return|return
name|parser_build_unary_op
argument_list|(
name|BIT_NOT_EXPR
argument_list|,
name|op
argument_list|)
return|;
case|case
name|CPP_NOT
case|:
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|op
operator|=
name|c_parser_cast_expression
argument_list|(
name|parser
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|op
operator|=
name|default_function_array_conversion
argument_list|(
name|op
argument_list|)
expr_stmt|;
return|return
name|parser_build_unary_op
argument_list|(
name|TRUTH_NOT_EXPR
argument_list|,
name|op
argument_list|)
return|;
case|case
name|CPP_AND_AND
case|:
comment|/* Refer to the address of a label as a pointer.  */
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_NAME
argument_list|)
condition|)
block|{
name|ret
operator|.
name|value
operator|=
name|finish_label_address_expr
argument_list|(
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
operator|->
name|value
argument_list|)
expr_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|c_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected identifier"
argument_list|)
expr_stmt|;
name|ret
operator|.
name|value
operator|=
name|error_mark_node
expr_stmt|;
block|}
name|ret
operator|.
name|original_code
operator|=
name|ERROR_MARK
expr_stmt|;
return|return
name|ret
return|;
case|case
name|CPP_KEYWORD
case|:
switch|switch
condition|(
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
operator|->
name|keyword
condition|)
block|{
case|case
name|RID_SIZEOF
case|:
return|return
name|c_parser_sizeof_expression
argument_list|(
name|parser
argument_list|)
return|;
case|case
name|RID_ALIGNOF
case|:
return|return
name|c_parser_alignof_expression
argument_list|(
name|parser
argument_list|)
return|;
case|case
name|RID_EXTENSION
case|:
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|ext
operator|=
name|disable_extension_diagnostics
argument_list|()
expr_stmt|;
name|ret
operator|=
name|c_parser_cast_expression
argument_list|(
name|parser
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|restore_extension_diagnostics
argument_list|(
name|ext
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
case|case
name|RID_REALPART
case|:
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|op
operator|=
name|c_parser_cast_expression
argument_list|(
name|parser
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|op
operator|=
name|default_function_array_conversion
argument_list|(
name|op
argument_list|)
expr_stmt|;
return|return
name|parser_build_unary_op
argument_list|(
name|REALPART_EXPR
argument_list|,
name|op
argument_list|)
return|;
case|case
name|RID_IMAGPART
case|:
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|op
operator|=
name|c_parser_cast_expression
argument_list|(
name|parser
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|op
operator|=
name|default_function_array_conversion
argument_list|(
name|op
argument_list|)
expr_stmt|;
return|return
name|parser_build_unary_op
argument_list|(
name|IMAGPART_EXPR
argument_list|,
name|op
argument_list|)
return|;
default|default:
return|return
name|c_parser_postfix_expression
argument_list|(
name|parser
argument_list|)
return|;
block|}
default|default:
return|return
name|c_parser_postfix_expression
argument_list|(
name|parser
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Parse a sizeof expression.  */
end_comment

begin_function
specifier|static
name|struct
name|c_expr
name|c_parser_sizeof_expression
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|)
block|{
name|struct
name|c_expr
name|expr
decl_stmt|;
name|gcc_assert
argument_list|(
name|c_parser_next_token_is_keyword
argument_list|(
name|parser
argument_list|,
name|RID_SIZEOF
argument_list|)
argument_list|)
expr_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|skip_evaluation
operator|++
expr_stmt|;
name|in_sizeof
operator|++
expr_stmt|;
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_PAREN
argument_list|)
operator|&&
name|c_token_starts_typename
argument_list|(
name|c_parser_peek_2nd_token
argument_list|(
name|parser
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Either sizeof ( type-name ) or sizeof unary-expression 	 starting with a compound literal.  */
name|struct
name|c_type_name
modifier|*
name|type_name
decl_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|type_name
operator|=
name|c_parser_type_name
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|c_parser_skip_until_found
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
literal|"expected %<)%>"
argument_list|)
expr_stmt|;
if|if
condition|(
name|type_name
operator|==
name|NULL
condition|)
block|{
name|struct
name|c_expr
name|ret
decl_stmt|;
name|skip_evaluation
operator|--
expr_stmt|;
name|in_sizeof
operator|--
expr_stmt|;
name|ret
operator|.
name|value
operator|=
name|error_mark_node
expr_stmt|;
name|ret
operator|.
name|original_code
operator|=
name|ERROR_MARK
expr_stmt|;
return|return
name|ret
return|;
block|}
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_BRACE
argument_list|)
condition|)
block|{
name|expr
operator|=
name|c_parser_postfix_expression_after_paren_type
argument_list|(
name|parser
argument_list|,
name|type_name
argument_list|)
expr_stmt|;
goto|goto
name|sizeof_expr
goto|;
block|}
comment|/* sizeof ( type-name ).  */
name|skip_evaluation
operator|--
expr_stmt|;
name|in_sizeof
operator|--
expr_stmt|;
if|if
condition|(
name|type_name
operator|->
name|declarator
operator|->
name|kind
operator|==
name|cdk_array
operator|&&
name|type_name
operator|->
name|declarator
operator|->
name|u
operator|.
name|array
operator|.
name|vla_unspec_p
condition|)
block|{
comment|/* C99 6.7.5.2p4 */
name|error
argument_list|(
literal|"%<[*]%> not allowed in other than a declaration"
argument_list|)
expr_stmt|;
block|}
return|return
name|c_expr_sizeof_type
argument_list|(
name|type_name
argument_list|)
return|;
block|}
else|else
block|{
name|expr
operator|=
name|c_parser_unary_expression
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|sizeof_expr
label|:
name|skip_evaluation
operator|--
expr_stmt|;
name|in_sizeof
operator|--
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
operator|.
name|value
argument_list|)
operator|==
name|COMPONENT_REF
operator|&&
name|DECL_C_BIT_FIELD
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
operator|.
name|value
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
name|error
argument_list|(
literal|"%<sizeof%> applied to a bit-field"
argument_list|)
expr_stmt|;
return|return
name|c_expr_sizeof_expr
argument_list|(
name|expr
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Parse an alignof expression.  */
end_comment

begin_function
specifier|static
name|struct
name|c_expr
name|c_parser_alignof_expression
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|)
block|{
name|struct
name|c_expr
name|expr
decl_stmt|;
name|gcc_assert
argument_list|(
name|c_parser_next_token_is_keyword
argument_list|(
name|parser
argument_list|,
name|RID_ALIGNOF
argument_list|)
argument_list|)
expr_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|skip_evaluation
operator|++
expr_stmt|;
name|in_alignof
operator|++
expr_stmt|;
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_PAREN
argument_list|)
operator|&&
name|c_token_starts_typename
argument_list|(
name|c_parser_peek_2nd_token
argument_list|(
name|parser
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Either __alignof__ ( type-name ) or __alignof__ 	 unary-expression starting with a compound literal.  */
name|struct
name|c_type_name
modifier|*
name|type_name
decl_stmt|;
name|struct
name|c_expr
name|ret
decl_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|type_name
operator|=
name|c_parser_type_name
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|c_parser_skip_until_found
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
literal|"expected %<)%>"
argument_list|)
expr_stmt|;
if|if
condition|(
name|type_name
operator|==
name|NULL
condition|)
block|{
name|struct
name|c_expr
name|ret
decl_stmt|;
name|skip_evaluation
operator|--
expr_stmt|;
name|in_alignof
operator|--
expr_stmt|;
name|ret
operator|.
name|value
operator|=
name|error_mark_node
expr_stmt|;
name|ret
operator|.
name|original_code
operator|=
name|ERROR_MARK
expr_stmt|;
return|return
name|ret
return|;
block|}
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_BRACE
argument_list|)
condition|)
block|{
name|expr
operator|=
name|c_parser_postfix_expression_after_paren_type
argument_list|(
name|parser
argument_list|,
name|type_name
argument_list|)
expr_stmt|;
goto|goto
name|alignof_expr
goto|;
block|}
comment|/* alignof ( type-name ).  */
name|skip_evaluation
operator|--
expr_stmt|;
name|in_alignof
operator|--
expr_stmt|;
name|ret
operator|.
name|value
operator|=
name|c_alignof
argument_list|(
name|groktypename
argument_list|(
name|type_name
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|.
name|original_code
operator|=
name|ERROR_MARK
expr_stmt|;
return|return
name|ret
return|;
block|}
else|else
block|{
name|struct
name|c_expr
name|ret
decl_stmt|;
name|expr
operator|=
name|c_parser_unary_expression
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|alignof_expr
label|:
name|skip_evaluation
operator|--
expr_stmt|;
name|in_alignof
operator|--
expr_stmt|;
name|ret
operator|.
name|value
operator|=
name|c_alignof_expr
argument_list|(
name|expr
operator|.
name|value
argument_list|)
expr_stmt|;
name|ret
operator|.
name|original_code
operator|=
name|ERROR_MARK
expr_stmt|;
return|return
name|ret
return|;
block|}
block|}
end_function

begin_comment
comment|/* Parse a postfix expression (C90 6.3.1-6.3.2, C99 6.5.1-6.5.2).     postfix-expression:      primary-expression      postfix-expression [ expression ]      postfix-expression ( argument-expression-list[opt] )      postfix-expression . identifier      postfix-expression -> identifier      postfix-expression ++      postfix-expression --      ( type-name ) { initializer-list }      ( type-name ) { initializer-list , }     argument-expression-list:      argument-expression      argument-expression-list , argument-expression     primary-expression:      identifier      constant      string-literal      ( expression )     GNU extensions:     primary-expression:      __func__        (treated as a keyword in GNU C)      __FUNCTION__      __PRETTY_FUNCTION__      ( compound-statement )      __builtin_va_arg ( assignment-expression , type-name )      __builtin_offsetof ( type-name , offsetof-member-designator )      __builtin_choose_expr ( assignment-expression , 			     assignment-expression , 			     assignment-expression )      __builtin_types_compatible_p ( type-name , type-name )     offsetof-member-designator:      identifier      offsetof-member-designator . identifier      offsetof-member-designator [ expression ]     Objective-C:     primary-expression:      [ objc-receiver objc-message-args ]      @selector ( objc-selector-arg )      @protocol ( identifier )      @encode ( type-name )      objc-string-literal */
end_comment

begin_function
specifier|static
name|struct
name|c_expr
name|c_parser_postfix_expression
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|)
block|{
name|struct
name|c_expr
name|expr
decl_stmt|,
name|e1
decl_stmt|,
name|e2
decl_stmt|,
name|e3
decl_stmt|;
name|struct
name|c_type_name
modifier|*
name|t1
decl_stmt|,
modifier|*
name|t2
decl_stmt|;
switch|switch
condition|(
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
operator|->
name|type
condition|)
block|{
case|case
name|CPP_NUMBER
case|:
case|case
name|CPP_CHAR
case|:
case|case
name|CPP_WCHAR
case|:
name|expr
operator|.
name|value
operator|=
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
operator|->
name|value
expr_stmt|;
name|expr
operator|.
name|original_code
operator|=
name|ERROR_MARK
expr_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_STRING
case|:
case|case
name|CPP_WSTRING
case|:
name|expr
operator|.
name|value
operator|=
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
operator|->
name|value
expr_stmt|;
name|expr
operator|.
name|original_code
operator|=
name|STRING_CST
expr_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_OBJC_STRING
case|:
name|gcc_assert
argument_list|(
name|c_dialect_objc
argument_list|()
argument_list|)
expr_stmt|;
name|expr
operator|.
name|value
operator|=
name|objc_build_string_object
argument_list|(
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
operator|->
name|value
argument_list|)
expr_stmt|;
name|expr
operator|.
name|original_code
operator|=
name|ERROR_MARK
expr_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_NAME
case|:
if|if
condition|(
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
operator|->
name|id_kind
operator|!=
name|C_ID_ID
condition|)
block|{
name|c_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected expression"
argument_list|)
expr_stmt|;
name|expr
operator|.
name|value
operator|=
name|error_mark_node
expr_stmt|;
name|expr
operator|.
name|original_code
operator|=
name|ERROR_MARK
expr_stmt|;
break|break;
block|}
block|{
name|tree
name|id
init|=
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
operator|->
name|value
decl_stmt|;
name|location_t
name|loc
init|=
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
operator|->
name|location
decl_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|expr
operator|.
name|value
operator|=
name|build_external_ref
argument_list|(
name|id
argument_list|,
operator|(
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
operator|->
name|type
operator|==
name|CPP_OPEN_PAREN
operator|)
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|expr
operator|.
name|original_code
operator|=
name|ERROR_MARK
expr_stmt|;
block|}
break|break;
case|case
name|CPP_OPEN_PAREN
case|:
comment|/* A parenthesized expression, statement expression or compound 	 literal.  */
if|if
condition|(
name|c_parser_peek_2nd_token
argument_list|(
name|parser
argument_list|)
operator|->
name|type
operator|==
name|CPP_OPEN_BRACE
condition|)
block|{
comment|/* A statement expression.  */
name|tree
name|stmt
decl_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur_stmt_list
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"braced-group within expression allowed "
literal|"only inside a function"
argument_list|)
expr_stmt|;
name|parser
operator|->
name|error
operator|=
name|true
expr_stmt|;
name|c_parser_skip_until_found
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_BRACE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|c_parser_skip_until_found
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|expr
operator|.
name|value
operator|=
name|error_mark_node
expr_stmt|;
name|expr
operator|.
name|original_code
operator|=
name|ERROR_MARK
expr_stmt|;
break|break;
block|}
name|stmt
operator|=
name|c_begin_stmt_expr
argument_list|()
expr_stmt|;
name|c_parser_compound_statement_nostart
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|c_parser_skip_until_found
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
literal|"expected %<)%>"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"ISO C forbids braced-groups within expressions"
argument_list|)
expr_stmt|;
name|expr
operator|.
name|value
operator|=
name|c_finish_stmt_expr
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|expr
operator|.
name|original_code
operator|=
name|ERROR_MARK
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c_token_starts_typename
argument_list|(
name|c_parser_peek_2nd_token
argument_list|(
name|parser
argument_list|)
argument_list|)
condition|)
block|{
comment|/* A compound literal.  ??? Can we actually get here rather 	     than going directly to 	     c_parser_postfix_expression_after_paren_type from 	     elsewhere?  */
name|struct
name|c_type_name
modifier|*
name|type_name
decl_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|type_name
operator|=
name|c_parser_type_name
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|c_parser_skip_until_found
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
literal|"expected %<)%>"
argument_list|)
expr_stmt|;
if|if
condition|(
name|type_name
operator|==
name|NULL
condition|)
block|{
name|expr
operator|.
name|value
operator|=
name|error_mark_node
expr_stmt|;
name|expr
operator|.
name|original_code
operator|=
name|ERROR_MARK
expr_stmt|;
block|}
else|else
name|expr
operator|=
name|c_parser_postfix_expression_after_paren_type
argument_list|(
name|parser
argument_list|,
name|type_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* A parenthesized expression.  */
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|expr
operator|=
name|c_parser_expression
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
operator|.
name|value
argument_list|)
operator|==
name|MODIFY_EXPR
condition|)
name|TREE_NO_WARNING
argument_list|(
name|expr
operator|.
name|value
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expr
operator|.
name|original_code
operator|=
name|ERROR_MARK
expr_stmt|;
name|c_parser_skip_until_found
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
literal|"expected %<)%>"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CPP_KEYWORD
case|:
switch|switch
condition|(
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
operator|->
name|keyword
condition|)
block|{
case|case
name|RID_FUNCTION_NAME
case|:
case|case
name|RID_PRETTY_FUNCTION_NAME
case|:
case|case
name|RID_C99_FUNCTION_NAME
case|:
name|expr
operator|.
name|value
operator|=
name|fname_decl
argument_list|(
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
operator|->
name|keyword
argument_list|,
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
operator|->
name|value
argument_list|)
expr_stmt|;
name|expr
operator|.
name|original_code
operator|=
name|ERROR_MARK
expr_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
break|break;
case|case
name|RID_VA_ARG
case|:
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|c_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_PAREN
argument_list|,
literal|"expected %<(%>"
argument_list|)
condition|)
block|{
name|expr
operator|.
name|value
operator|=
name|error_mark_node
expr_stmt|;
name|expr
operator|.
name|original_code
operator|=
name|ERROR_MARK
expr_stmt|;
break|break;
block|}
name|e1
operator|=
name|c_parser_expr_no_commas
argument_list|(
name|parser
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|c_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_COMMA
argument_list|,
literal|"expected %<,%>"
argument_list|)
condition|)
block|{
name|c_parser_skip_until_found
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|expr
operator|.
name|value
operator|=
name|error_mark_node
expr_stmt|;
name|expr
operator|.
name|original_code
operator|=
name|ERROR_MARK
expr_stmt|;
break|break;
block|}
name|t1
operator|=
name|c_parser_type_name
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|c_parser_skip_until_found
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
literal|"expected %<)%>"
argument_list|)
expr_stmt|;
if|if
condition|(
name|t1
operator|==
name|NULL
condition|)
block|{
name|expr
operator|.
name|value
operator|=
name|error_mark_node
expr_stmt|;
name|expr
operator|.
name|original_code
operator|=
name|ERROR_MARK
expr_stmt|;
block|}
else|else
block|{
name|expr
operator|.
name|value
operator|=
name|build_va_arg
argument_list|(
name|e1
operator|.
name|value
argument_list|,
name|groktypename
argument_list|(
name|t1
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|.
name|original_code
operator|=
name|ERROR_MARK
expr_stmt|;
block|}
break|break;
case|case
name|RID_OFFSETOF
case|:
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|c_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_PAREN
argument_list|,
literal|"expected %<(%>"
argument_list|)
condition|)
block|{
name|expr
operator|.
name|value
operator|=
name|error_mark_node
expr_stmt|;
name|expr
operator|.
name|original_code
operator|=
name|ERROR_MARK
expr_stmt|;
break|break;
block|}
name|t1
operator|=
name|c_parser_type_name
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|t1
operator|==
name|NULL
condition|)
block|{
name|expr
operator|.
name|value
operator|=
name|error_mark_node
expr_stmt|;
name|expr
operator|.
name|original_code
operator|=
name|ERROR_MARK
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|c_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_COMMA
argument_list|,
literal|"expected %<,%>"
argument_list|)
condition|)
block|{
name|c_parser_skip_until_found
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|expr
operator|.
name|value
operator|=
name|error_mark_node
expr_stmt|;
name|expr
operator|.
name|original_code
operator|=
name|ERROR_MARK
expr_stmt|;
break|break;
block|}
block|{
name|tree
name|type
init|=
name|groktypename
argument_list|(
name|t1
argument_list|)
decl_stmt|;
name|tree
name|offsetof_ref
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
name|offsetof_ref
operator|=
name|error_mark_node
expr_stmt|;
else|else
name|offsetof_ref
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|type
argument_list|,
name|null_pointer_node
argument_list|)
expr_stmt|;
comment|/* Parse the second argument to __builtin_offsetof.  We 	       must have one identifier, and beyond that we want to 	       accept sub structure and sub array references.  */
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_NAME
argument_list|)
condition|)
block|{
name|offsetof_ref
operator|=
name|build_component_ref
argument_list|(
name|offsetof_ref
argument_list|,
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
operator|->
name|value
argument_list|)
expr_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
while|while
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_DOT
argument_list|)
operator|||
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_SQUARE
argument_list|)
condition|)
block|{
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_DOT
argument_list|)
condition|)
block|{
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_parser_next_token_is_not
argument_list|(
name|parser
argument_list|,
name|CPP_NAME
argument_list|)
condition|)
block|{
name|c_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected identifier"
argument_list|)
expr_stmt|;
break|break;
block|}
name|offsetof_ref
operator|=
name|build_component_ref
argument_list|(
name|offsetof_ref
argument_list|,
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
operator|->
name|value
argument_list|)
expr_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tree
name|idx
decl_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|idx
operator|=
name|c_parser_expression
argument_list|(
name|parser
argument_list|)
operator|.
name|value
expr_stmt|;
name|c_parser_skip_until_found
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_SQUARE
argument_list|,
literal|"expected %<]%>"
argument_list|)
expr_stmt|;
name|offsetof_ref
operator|=
name|build_array_ref
argument_list|(
name|offsetof_ref
argument_list|,
name|idx
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
name|c_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected identifier"
argument_list|)
expr_stmt|;
name|c_parser_skip_until_found
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
literal|"expected %<)%>"
argument_list|)
expr_stmt|;
name|expr
operator|.
name|value
operator|=
name|fold_offsetof
argument_list|(
name|offsetof_ref
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|expr
operator|.
name|original_code
operator|=
name|ERROR_MARK
expr_stmt|;
block|}
break|break;
case|case
name|RID_CHOOSE_EXPR
case|:
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|c_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_PAREN
argument_list|,
literal|"expected %<(%>"
argument_list|)
condition|)
block|{
name|expr
operator|.
name|value
operator|=
name|error_mark_node
expr_stmt|;
name|expr
operator|.
name|original_code
operator|=
name|ERROR_MARK
expr_stmt|;
break|break;
block|}
name|e1
operator|=
name|c_parser_expr_no_commas
argument_list|(
name|parser
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|c_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_COMMA
argument_list|,
literal|"expected %<,%>"
argument_list|)
condition|)
block|{
name|c_parser_skip_until_found
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|expr
operator|.
name|value
operator|=
name|error_mark_node
expr_stmt|;
name|expr
operator|.
name|original_code
operator|=
name|ERROR_MARK
expr_stmt|;
break|break;
block|}
name|e2
operator|=
name|c_parser_expr_no_commas
argument_list|(
name|parser
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|c_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_COMMA
argument_list|,
literal|"expected %<,%>"
argument_list|)
condition|)
block|{
name|c_parser_skip_until_found
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|expr
operator|.
name|value
operator|=
name|error_mark_node
expr_stmt|;
name|expr
operator|.
name|original_code
operator|=
name|ERROR_MARK
expr_stmt|;
break|break;
block|}
name|e3
operator|=
name|c_parser_expr_no_commas
argument_list|(
name|parser
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|c_parser_skip_until_found
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
literal|"expected %<)%>"
argument_list|)
expr_stmt|;
block|{
name|tree
name|c
decl_stmt|;
name|c
operator|=
name|fold
argument_list|(
name|e1
operator|.
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|c
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
name|error
argument_list|(
literal|"first argument to %<__builtin_choose_expr%> not"
literal|" a constant"
argument_list|)
expr_stmt|;
name|expr
operator|=
name|integer_zerop
argument_list|(
name|c
argument_list|)
condition|?
name|e3
else|:
name|e2
expr_stmt|;
block|}
break|break;
case|case
name|RID_TYPES_COMPATIBLE_P
case|:
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|c_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_PAREN
argument_list|,
literal|"expected %<(%>"
argument_list|)
condition|)
block|{
name|expr
operator|.
name|value
operator|=
name|error_mark_node
expr_stmt|;
name|expr
operator|.
name|original_code
operator|=
name|ERROR_MARK
expr_stmt|;
break|break;
block|}
name|t1
operator|=
name|c_parser_type_name
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|t1
operator|==
name|NULL
condition|)
block|{
name|expr
operator|.
name|value
operator|=
name|error_mark_node
expr_stmt|;
name|expr
operator|.
name|original_code
operator|=
name|ERROR_MARK
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|c_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_COMMA
argument_list|,
literal|"expected %<,%>"
argument_list|)
condition|)
block|{
name|c_parser_skip_until_found
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|expr
operator|.
name|value
operator|=
name|error_mark_node
expr_stmt|;
name|expr
operator|.
name|original_code
operator|=
name|ERROR_MARK
expr_stmt|;
break|break;
block|}
name|t2
operator|=
name|c_parser_type_name
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|t2
operator|==
name|NULL
condition|)
block|{
name|expr
operator|.
name|value
operator|=
name|error_mark_node
expr_stmt|;
name|expr
operator|.
name|original_code
operator|=
name|ERROR_MARK
expr_stmt|;
break|break;
block|}
name|c_parser_skip_until_found
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
literal|"expected %<)%>"
argument_list|)
expr_stmt|;
block|{
name|tree
name|e1
decl_stmt|,
name|e2
decl_stmt|;
name|e1
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|groktypename
argument_list|(
name|t1
argument_list|)
argument_list|)
expr_stmt|;
name|e2
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|groktypename
argument_list|(
name|t2
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|.
name|value
operator|=
name|comptypes
argument_list|(
name|e1
argument_list|,
name|e2
argument_list|)
condition|?
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
literal|1
argument_list|)
else|:
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|expr
operator|.
name|original_code
operator|=
name|ERROR_MARK
expr_stmt|;
block|}
break|break;
case|case
name|RID_AT_SELECTOR
case|:
name|gcc_assert
argument_list|(
name|c_dialect_objc
argument_list|()
argument_list|)
expr_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|c_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_PAREN
argument_list|,
literal|"expected %<(%>"
argument_list|)
condition|)
block|{
name|expr
operator|.
name|value
operator|=
name|error_mark_node
expr_stmt|;
name|expr
operator|.
name|original_code
operator|=
name|ERROR_MARK
expr_stmt|;
break|break;
block|}
block|{
name|tree
name|sel
init|=
name|c_parser_objc_selector_arg
argument_list|(
name|parser
argument_list|)
decl_stmt|;
name|c_parser_skip_until_found
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
literal|"expected %<)%>"
argument_list|)
expr_stmt|;
name|expr
operator|.
name|value
operator|=
name|objc_build_selector_expr
argument_list|(
name|sel
argument_list|)
expr_stmt|;
name|expr
operator|.
name|original_code
operator|=
name|ERROR_MARK
expr_stmt|;
block|}
break|break;
case|case
name|RID_AT_PROTOCOL
case|:
name|gcc_assert
argument_list|(
name|c_dialect_objc
argument_list|()
argument_list|)
expr_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|c_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_PAREN
argument_list|,
literal|"expected %<(%>"
argument_list|)
condition|)
block|{
name|expr
operator|.
name|value
operator|=
name|error_mark_node
expr_stmt|;
name|expr
operator|.
name|original_code
operator|=
name|ERROR_MARK
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|c_parser_next_token_is_not
argument_list|(
name|parser
argument_list|,
name|CPP_NAME
argument_list|)
condition|)
block|{
name|c_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected identifier"
argument_list|)
expr_stmt|;
name|c_parser_skip_until_found
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|expr
operator|.
name|value
operator|=
name|error_mark_node
expr_stmt|;
name|expr
operator|.
name|original_code
operator|=
name|ERROR_MARK
expr_stmt|;
break|break;
block|}
block|{
name|tree
name|id
init|=
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
operator|->
name|value
decl_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|c_parser_skip_until_found
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
literal|"expected %<)%>"
argument_list|)
expr_stmt|;
name|expr
operator|.
name|value
operator|=
name|objc_build_protocol_expr
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|expr
operator|.
name|original_code
operator|=
name|ERROR_MARK
expr_stmt|;
block|}
break|break;
case|case
name|RID_AT_ENCODE
case|:
comment|/* Extension to support C-structures in the archiver.  */
name|gcc_assert
argument_list|(
name|c_dialect_objc
argument_list|()
argument_list|)
expr_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|c_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_PAREN
argument_list|,
literal|"expected %<(%>"
argument_list|)
condition|)
block|{
name|expr
operator|.
name|value
operator|=
name|error_mark_node
expr_stmt|;
name|expr
operator|.
name|original_code
operator|=
name|ERROR_MARK
expr_stmt|;
break|break;
block|}
name|t1
operator|=
name|c_parser_type_name
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|t1
operator|==
name|NULL
condition|)
block|{
name|expr
operator|.
name|value
operator|=
name|error_mark_node
expr_stmt|;
name|expr
operator|.
name|original_code
operator|=
name|ERROR_MARK
expr_stmt|;
name|c_parser_skip_until_found
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
name|c_parser_skip_until_found
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
literal|"expected %<)%>"
argument_list|)
expr_stmt|;
block|{
name|tree
name|type
init|=
name|groktypename
argument_list|(
name|t1
argument_list|)
decl_stmt|;
name|expr
operator|.
name|value
operator|=
name|objc_build_encode_expr
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|expr
operator|.
name|original_code
operator|=
name|ERROR_MARK
expr_stmt|;
block|}
break|break;
default|default:
name|c_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected expression"
argument_list|)
expr_stmt|;
name|expr
operator|.
name|value
operator|=
name|error_mark_node
expr_stmt|;
name|expr
operator|.
name|original_code
operator|=
name|ERROR_MARK
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|CPP_OPEN_SQUARE
case|:
if|if
condition|(
name|c_dialect_objc
argument_list|()
condition|)
block|{
name|tree
name|receiver
decl_stmt|,
name|args
decl_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|receiver
operator|=
name|c_parser_objc_receiver
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|args
operator|=
name|c_parser_objc_message_args
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|c_parser_skip_until_found
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_SQUARE
argument_list|,
literal|"expected %<]%>"
argument_list|)
expr_stmt|;
name|expr
operator|.
name|value
operator|=
name|objc_build_message_expr
argument_list|(
name|build_tree_list
argument_list|(
name|receiver
argument_list|,
name|args
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|.
name|original_code
operator|=
name|ERROR_MARK
expr_stmt|;
break|break;
block|}
comment|/* Else fall through to report error.  */
default|default:
name|c_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected expression"
argument_list|)
expr_stmt|;
name|expr
operator|.
name|value
operator|=
name|error_mark_node
expr_stmt|;
name|expr
operator|.
name|original_code
operator|=
name|ERROR_MARK
expr_stmt|;
break|break;
block|}
return|return
name|c_parser_postfix_expression_after_primary
argument_list|(
name|parser
argument_list|,
name|expr
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Parse a postfix expression after a parenthesized type name: the    brace-enclosed initializer of a compound literal, possibly followed    by some postfix operators.  This is separate because it is not    possible to tell until after the type name whether a cast    expression has a cast or a compound literal, or whether the operand    of sizeof is a parenthesized type name or starts with a compound    literal.  */
end_comment

begin_function
specifier|static
name|struct
name|c_expr
name|c_parser_postfix_expression_after_paren_type
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|,
name|struct
name|c_type_name
modifier|*
name|type_name
parameter_list|)
block|{
name|tree
name|type
decl_stmt|;
name|struct
name|c_expr
name|init
decl_stmt|;
name|struct
name|c_expr
name|expr
decl_stmt|;
name|start_init
argument_list|(
name|NULL_TREE
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|type
operator|=
name|groktypename
argument_list|(
name|type_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|error_mark_node
operator|&&
name|C_TYPE_VARIABLE_SIZE
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"compound literal has variable size"
argument_list|)
expr_stmt|;
name|type
operator|=
name|error_mark_node
expr_stmt|;
block|}
name|init
operator|=
name|c_parser_braced_init
argument_list|(
name|parser
argument_list|,
name|type
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|finish_init
argument_list|()
expr_stmt|;
name|maybe_warn_string_init
argument_list|(
name|type
argument_list|,
name|init
argument_list|)
expr_stmt|;
if|if
condition|(
name|pedantic
operator|&&
operator|!
name|flag_isoc99
condition|)
name|pedwarn
argument_list|(
literal|"ISO C90 forbids compound literals"
argument_list|)
expr_stmt|;
name|expr
operator|.
name|value
operator|=
name|build_compound_literal
argument_list|(
name|type
argument_list|,
name|init
operator|.
name|value
argument_list|)
expr_stmt|;
name|expr
operator|.
name|original_code
operator|=
name|ERROR_MARK
expr_stmt|;
return|return
name|c_parser_postfix_expression_after_primary
argument_list|(
name|parser
argument_list|,
name|expr
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Parse a postfix expression after the initial primary or compound    literal; that is, parse a series of postfix operators.  */
end_comment

begin_function
specifier|static
name|struct
name|c_expr
name|c_parser_postfix_expression_after_primary
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|,
name|struct
name|c_expr
name|expr
parameter_list|)
block|{
name|tree
name|ident
decl_stmt|,
name|idx
decl_stmt|,
name|exprlist
decl_stmt|;
while|while
condition|(
name|true
condition|)
block|{
switch|switch
condition|(
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
operator|->
name|type
condition|)
block|{
case|case
name|CPP_OPEN_SQUARE
case|:
comment|/* Array reference.  */
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|idx
operator|=
name|c_parser_expression
argument_list|(
name|parser
argument_list|)
operator|.
name|value
expr_stmt|;
name|c_parser_skip_until_found
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_SQUARE
argument_list|,
literal|"expected %<]%>"
argument_list|)
expr_stmt|;
name|expr
operator|.
name|value
operator|=
name|build_array_ref
argument_list|(
name|expr
operator|.
name|value
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|expr
operator|.
name|original_code
operator|=
name|ERROR_MARK
expr_stmt|;
break|break;
case|case
name|CPP_OPEN_PAREN
case|:
comment|/* Function call.  */
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|)
condition|)
name|exprlist
operator|=
name|NULL_TREE
expr_stmt|;
else|else
name|exprlist
operator|=
name|c_parser_expr_list
argument_list|(
name|parser
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|c_parser_skip_until_found
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
literal|"expected %<)%>"
argument_list|)
expr_stmt|;
name|expr
operator|.
name|value
operator|=
name|build_function_call
argument_list|(
name|expr
operator|.
name|value
argument_list|,
name|exprlist
argument_list|)
expr_stmt|;
name|expr
operator|.
name|original_code
operator|=
name|ERROR_MARK
expr_stmt|;
break|break;
case|case
name|CPP_DOT
case|:
comment|/* Structure element reference.  */
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|expr
operator|=
name|default_function_array_conversion
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_NAME
argument_list|)
condition|)
name|ident
operator|=
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
operator|->
name|value
expr_stmt|;
else|else
block|{
name|c_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected identifier"
argument_list|)
expr_stmt|;
name|expr
operator|.
name|value
operator|=
name|error_mark_node
expr_stmt|;
name|expr
operator|.
name|original_code
operator|=
name|ERROR_MARK
expr_stmt|;
return|return
name|expr
return|;
block|}
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|expr
operator|.
name|value
operator|=
name|build_component_ref
argument_list|(
name|expr
operator|.
name|value
argument_list|,
name|ident
argument_list|)
expr_stmt|;
name|expr
operator|.
name|original_code
operator|=
name|ERROR_MARK
expr_stmt|;
break|break;
case|case
name|CPP_DEREF
case|:
comment|/* Structure element reference.  */
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|expr
operator|=
name|default_function_array_conversion
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_NAME
argument_list|)
condition|)
name|ident
operator|=
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
operator|->
name|value
expr_stmt|;
else|else
block|{
name|c_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected identifier"
argument_list|)
expr_stmt|;
name|expr
operator|.
name|value
operator|=
name|error_mark_node
expr_stmt|;
name|expr
operator|.
name|original_code
operator|=
name|ERROR_MARK
expr_stmt|;
return|return
name|expr
return|;
block|}
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|expr
operator|.
name|value
operator|=
name|build_component_ref
argument_list|(
name|build_indirect_ref
argument_list|(
name|expr
operator|.
name|value
argument_list|,
literal|"->"
argument_list|)
argument_list|,
name|ident
argument_list|)
expr_stmt|;
name|expr
operator|.
name|original_code
operator|=
name|ERROR_MARK
expr_stmt|;
break|break;
case|case
name|CPP_PLUS_PLUS
case|:
comment|/* Postincrement.  */
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|expr
operator|=
name|default_function_array_conversion
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|expr
operator|.
name|value
operator|=
name|build_unary_op
argument_list|(
name|POSTINCREMENT_EXPR
argument_list|,
name|expr
operator|.
name|value
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|expr
operator|.
name|original_code
operator|=
name|ERROR_MARK
expr_stmt|;
break|break;
case|case
name|CPP_MINUS_MINUS
case|:
comment|/* Postdecrement.  */
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|expr
operator|=
name|default_function_array_conversion
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|expr
operator|.
name|value
operator|=
name|build_unary_op
argument_list|(
name|POSTDECREMENT_EXPR
argument_list|,
name|expr
operator|.
name|value
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|expr
operator|.
name|original_code
operator|=
name|ERROR_MARK
expr_stmt|;
break|break;
default|default:
return|return
name|expr
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Parse an expression (C90 6.3.17, C99 6.5.17).     expression:      assignment-expression      expression , assignment-expression */
end_comment

begin_function
specifier|static
name|struct
name|c_expr
name|c_parser_expression
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|)
block|{
name|struct
name|c_expr
name|expr
decl_stmt|;
name|expr
operator|=
name|c_parser_expr_no_commas
argument_list|(
name|parser
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
while|while
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_COMMA
argument_list|)
condition|)
block|{
name|struct
name|c_expr
name|next
decl_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|next
operator|=
name|c_parser_expr_no_commas
argument_list|(
name|parser
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|next
operator|=
name|default_function_array_conversion
argument_list|(
name|next
argument_list|)
expr_stmt|;
name|expr
operator|.
name|value
operator|=
name|build_compound_expr
argument_list|(
name|expr
operator|.
name|value
argument_list|,
name|next
operator|.
name|value
argument_list|)
expr_stmt|;
name|expr
operator|.
name|original_code
operator|=
name|COMPOUND_EXPR
expr_stmt|;
block|}
return|return
name|expr
return|;
block|}
end_function

begin_comment
comment|/* Parse an expression and convert functions or arrays to    pointers.  */
end_comment

begin_function
specifier|static
name|struct
name|c_expr
name|c_parser_expression_conv
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|)
block|{
name|struct
name|c_expr
name|expr
decl_stmt|;
name|expr
operator|=
name|c_parser_expression
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|expr
operator|=
name|default_function_array_conversion
argument_list|(
name|expr
argument_list|)
expr_stmt|;
return|return
name|expr
return|;
block|}
end_function

begin_comment
comment|/* Parse a non-empty list of expressions.  If CONVERT_P, convert    functions and arrays to pointers.     nonempty-expr-list:      assignment-expression      nonempty-expr-list , assignment-expression */
end_comment

begin_function
specifier|static
name|tree
name|c_parser_expr_list
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|,
name|bool
name|convert_p
parameter_list|)
block|{
name|struct
name|c_expr
name|expr
decl_stmt|;
name|tree
name|ret
decl_stmt|,
name|cur
decl_stmt|;
name|expr
operator|=
name|c_parser_expr_no_commas
argument_list|(
name|parser
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|convert_p
condition|)
name|expr
operator|=
name|default_function_array_conversion
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|ret
operator|=
name|cur
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|expr
operator|.
name|value
argument_list|)
expr_stmt|;
while|while
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_COMMA
argument_list|)
condition|)
block|{
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|expr
operator|=
name|c_parser_expr_no_commas
argument_list|(
name|parser
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|convert_p
condition|)
name|expr
operator|=
name|default_function_array_conversion
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|cur
operator|=
name|TREE_CHAIN
argument_list|(
name|cur
argument_list|)
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|expr
operator|.
name|value
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Parse Objective-C-specific constructs.  */
end_comment

begin_comment
comment|/* Parse an objc-class-definition.     objc-class-definition:      @interface identifier objc-superclass[opt] objc-protocol-refs[opt]        objc-class-instance-variables[opt] objc-methodprotolist @end      @implementation identifier objc-superclass[opt]        objc-class-instance-variables[opt]      @interface identifier ( identifier ) objc-protocol-refs[opt]        objc-methodprotolist @end      @implementation identifier ( identifier )     objc-superclass:      : identifier     "@interface identifier (" must start "@interface identifier (    identifier ) ...": objc-methodprotolist in the first production may    not start with a parenthesized identifier as a declarator of a data    definition with no declaration specifiers if the objc-superclass,    objc-protocol-refs and objc-class-instance-variables are omitted.  */
end_comment

begin_function
specifier|static
name|void
name|c_parser_objc_class_definition
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|)
block|{
name|bool
name|iface_p
decl_stmt|;
name|tree
name|id1
decl_stmt|;
name|tree
name|superclass
decl_stmt|;
if|if
condition|(
name|c_parser_next_token_is_keyword
argument_list|(
name|parser
argument_list|,
name|RID_AT_INTERFACE
argument_list|)
condition|)
name|iface_p
operator|=
name|true
expr_stmt|;
elseif|else
if|if
condition|(
name|c_parser_next_token_is_keyword
argument_list|(
name|parser
argument_list|,
name|RID_AT_IMPLEMENTATION
argument_list|)
condition|)
name|iface_p
operator|=
name|false
expr_stmt|;
else|else
name|gcc_unreachable
argument_list|()
expr_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_parser_next_token_is_not
argument_list|(
name|parser
argument_list|,
name|CPP_NAME
argument_list|)
condition|)
block|{
name|c_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected identifier"
argument_list|)
expr_stmt|;
return|return;
block|}
name|id1
operator|=
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
operator|->
name|value
expr_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_PAREN
argument_list|)
condition|)
block|{
name|tree
name|id2
decl_stmt|;
name|tree
name|proto
init|=
name|NULL_TREE
decl_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_parser_next_token_is_not
argument_list|(
name|parser
argument_list|,
name|CPP_NAME
argument_list|)
condition|)
block|{
name|c_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected identifier"
argument_list|)
expr_stmt|;
name|c_parser_skip_until_found
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return;
block|}
name|id2
operator|=
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
operator|->
name|value
expr_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|c_parser_skip_until_found
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
literal|"expected %<)%>"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|iface_p
condition|)
block|{
name|objc_start_category_implementation
argument_list|(
name|id1
argument_list|,
name|id2
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_LESS
argument_list|)
condition|)
name|proto
operator|=
name|c_parser_objc_protocol_refs
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|objc_start_category_interface
argument_list|(
name|id1
argument_list|,
name|id2
argument_list|,
name|proto
argument_list|)
expr_stmt|;
name|c_parser_objc_methodprotolist
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|c_parser_require_keyword
argument_list|(
name|parser
argument_list|,
name|RID_AT_END
argument_list|,
literal|"expected %<@end%>"
argument_list|)
expr_stmt|;
name|objc_finish_interface
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_COLON
argument_list|)
condition|)
block|{
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_parser_next_token_is_not
argument_list|(
name|parser
argument_list|,
name|CPP_NAME
argument_list|)
condition|)
block|{
name|c_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected identifier"
argument_list|)
expr_stmt|;
return|return;
block|}
name|superclass
operator|=
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
operator|->
name|value
expr_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
else|else
name|superclass
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|iface_p
condition|)
block|{
name|tree
name|proto
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_LESS
argument_list|)
condition|)
name|proto
operator|=
name|c_parser_objc_protocol_refs
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|objc_start_class_interface
argument_list|(
name|id1
argument_list|,
name|superclass
argument_list|,
name|proto
argument_list|)
expr_stmt|;
block|}
else|else
name|objc_start_class_implementation
argument_list|(
name|id1
argument_list|,
name|superclass
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_BRACE
argument_list|)
condition|)
name|c_parser_objc_class_instance_variables
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|iface_p
condition|)
block|{
name|objc_continue_interface
argument_list|()
expr_stmt|;
name|c_parser_objc_methodprotolist
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|c_parser_require_keyword
argument_list|(
name|parser
argument_list|,
name|RID_AT_END
argument_list|,
literal|"expected %<@end%>"
argument_list|)
expr_stmt|;
name|objc_finish_interface
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|objc_continue_implementation
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_comment
comment|/* Parse objc-class-instance-variables.     objc-class-instance-variables:      { objc-instance-variable-decl-list[opt] }     objc-instance-variable-decl-list:      objc-visibility-spec      objc-instance-variable-decl ;      ;      objc-instance-variable-decl-list objc-visibility-spec      objc-instance-variable-decl-list objc-instance-variable-decl ;      objc-instance-variable-decl-list ;     objc-visibility-spec:      @private      @protected      @public     objc-instance-variable-decl:      struct-declaration */
end_comment

begin_function
specifier|static
name|void
name|c_parser_objc_class_instance_variables
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_BRACE
argument_list|)
argument_list|)
expr_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
while|while
condition|(
name|c_parser_next_token_is_not
argument_list|(
name|parser
argument_list|,
name|CPP_EOF
argument_list|)
condition|)
block|{
name|tree
name|decls
decl_stmt|;
comment|/* Parse any stray semicolon.  */
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_SEMICOLON
argument_list|)
condition|)
block|{
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"extra semicolon in struct or union specified"
argument_list|)
expr_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Stop if at the end of the instance variables.  */
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_BRACE
argument_list|)
condition|)
block|{
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Parse any objc-visibility-spec.  */
if|if
condition|(
name|c_parser_next_token_is_keyword
argument_list|(
name|parser
argument_list|,
name|RID_AT_PRIVATE
argument_list|)
condition|)
block|{
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|objc_set_visibility
argument_list|(
literal|2
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|c_parser_next_token_is_keyword
argument_list|(
name|parser
argument_list|,
name|RID_AT_PROTECTED
argument_list|)
condition|)
block|{
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|objc_set_visibility
argument_list|(
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|c_parser_next_token_is_keyword
argument_list|(
name|parser
argument_list|,
name|RID_AT_PUBLIC
argument_list|)
condition|)
block|{
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|objc_set_visibility
argument_list|(
literal|1
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_PRAGMA
argument_list|)
condition|)
block|{
name|c_parser_pragma
argument_list|(
name|parser
argument_list|,
name|pragma_external
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Parse some comma-separated declarations.  */
name|decls
operator|=
name|c_parser_struct_declaration
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|{
comment|/* Comma-separated instance variables are chained together in 	   reverse order; add them one by one.  */
name|tree
name|ivar
init|=
name|nreverse
argument_list|(
name|decls
argument_list|)
decl_stmt|;
for|for
control|(
init|;
name|ivar
condition|;
name|ivar
operator|=
name|TREE_CHAIN
argument_list|(
name|ivar
argument_list|)
control|)
name|objc_add_instance_variable
argument_list|(
name|copy_node
argument_list|(
name|ivar
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|c_parser_skip_until_found
argument_list|(
name|parser
argument_list|,
name|CPP_SEMICOLON
argument_list|,
literal|"expected %<;%>"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Parse an objc-class-declaration.     objc-class-declaration:      @class identifier-list ; */
end_comment

begin_function
specifier|static
name|void
name|c_parser_objc_class_declaration
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|list
init|=
name|NULL_TREE
decl_stmt|;
name|gcc_assert
argument_list|(
name|c_parser_next_token_is_keyword
argument_list|(
name|parser
argument_list|,
name|RID_AT_CLASS
argument_list|)
argument_list|)
expr_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Any identifiers, including those declared as type names, are OK      here.  */
while|while
condition|(
name|true
condition|)
block|{
name|tree
name|id
decl_stmt|;
if|if
condition|(
name|c_parser_next_token_is_not
argument_list|(
name|parser
argument_list|,
name|CPP_NAME
argument_list|)
condition|)
block|{
name|c_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected identifier"
argument_list|)
expr_stmt|;
break|break;
block|}
name|id
operator|=
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
operator|->
name|value
expr_stmt|;
name|list
operator|=
name|chainon
argument_list|(
name|list
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|id
argument_list|)
argument_list|)
expr_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_COMMA
argument_list|)
condition|)
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
else|else
break|break;
block|}
name|c_parser_skip_until_found
argument_list|(
name|parser
argument_list|,
name|CPP_SEMICOLON
argument_list|,
literal|"expected %<;%>"
argument_list|)
expr_stmt|;
name|objc_declare_class
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse an objc-alias-declaration.     objc-alias-declaration:      @compatibility_alias identifier identifier ; */
end_comment

begin_function
specifier|static
name|void
name|c_parser_objc_alias_declaration
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|id1
decl_stmt|,
name|id2
decl_stmt|;
name|gcc_assert
argument_list|(
name|c_parser_next_token_is_keyword
argument_list|(
name|parser
argument_list|,
name|RID_AT_ALIAS
argument_list|)
argument_list|)
expr_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_parser_next_token_is_not
argument_list|(
name|parser
argument_list|,
name|CPP_NAME
argument_list|)
condition|)
block|{
name|c_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected identifier"
argument_list|)
expr_stmt|;
name|c_parser_skip_until_found
argument_list|(
name|parser
argument_list|,
name|CPP_SEMICOLON
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return;
block|}
name|id1
operator|=
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
operator|->
name|value
expr_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_parser_next_token_is_not
argument_list|(
name|parser
argument_list|,
name|CPP_NAME
argument_list|)
condition|)
block|{
name|c_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected identifier"
argument_list|)
expr_stmt|;
name|c_parser_skip_until_found
argument_list|(
name|parser
argument_list|,
name|CPP_SEMICOLON
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return;
block|}
name|id2
operator|=
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
operator|->
name|value
expr_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|c_parser_skip_until_found
argument_list|(
name|parser
argument_list|,
name|CPP_SEMICOLON
argument_list|,
literal|"expected %<;%>"
argument_list|)
expr_stmt|;
name|objc_declare_alias
argument_list|(
name|id1
argument_list|,
name|id2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse an objc-protocol-definition.     objc-protocol-definition:      @protocol identifier objc-protocol-refs[opt] objc-methodprotolist @end      @protocol identifier-list ;     "@protocol identifier ;" should be resolved as "@protocol    identifier-list ;": objc-methodprotolist may not start with a    semicolon in the first alternative if objc-protocol-refs are    omitted.  */
end_comment

begin_function
specifier|static
name|void
name|c_parser_objc_protocol_definition
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|c_parser_next_token_is_keyword
argument_list|(
name|parser
argument_list|,
name|RID_AT_PROTOCOL
argument_list|)
argument_list|)
expr_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_parser_next_token_is_not
argument_list|(
name|parser
argument_list|,
name|CPP_NAME
argument_list|)
condition|)
block|{
name|c_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected identifier"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|c_parser_peek_2nd_token
argument_list|(
name|parser
argument_list|)
operator|->
name|type
operator|==
name|CPP_COMMA
operator|||
name|c_parser_peek_2nd_token
argument_list|(
name|parser
argument_list|)
operator|->
name|type
operator|==
name|CPP_SEMICOLON
condition|)
block|{
name|tree
name|list
init|=
name|NULL_TREE
decl_stmt|;
comment|/* Any identifiers, including those declared as type names, are 	 OK here.  */
while|while
condition|(
name|true
condition|)
block|{
name|tree
name|id
decl_stmt|;
if|if
condition|(
name|c_parser_next_token_is_not
argument_list|(
name|parser
argument_list|,
name|CPP_NAME
argument_list|)
condition|)
block|{
name|c_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected identifier"
argument_list|)
expr_stmt|;
break|break;
block|}
name|id
operator|=
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
operator|->
name|value
expr_stmt|;
name|list
operator|=
name|chainon
argument_list|(
name|list
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|id
argument_list|)
argument_list|)
expr_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_COMMA
argument_list|)
condition|)
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
else|else
break|break;
block|}
name|c_parser_skip_until_found
argument_list|(
name|parser
argument_list|,
name|CPP_SEMICOLON
argument_list|,
literal|"expected %<;%>"
argument_list|)
expr_stmt|;
name|objc_declare_protocols
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tree
name|id
init|=
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
operator|->
name|value
decl_stmt|;
name|tree
name|proto
init|=
name|NULL_TREE
decl_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_LESS
argument_list|)
condition|)
name|proto
operator|=
name|c_parser_objc_protocol_refs
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|objc_pq_context
operator|=
literal|1
expr_stmt|;
name|objc_start_protocol
argument_list|(
name|id
argument_list|,
name|proto
argument_list|)
expr_stmt|;
name|c_parser_objc_methodprotolist
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|c_parser_require_keyword
argument_list|(
name|parser
argument_list|,
name|RID_AT_END
argument_list|,
literal|"expected %<@end%>"
argument_list|)
expr_stmt|;
name|objc_pq_context
operator|=
literal|0
expr_stmt|;
name|objc_finish_interface
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Parse an objc-method-type.     objc-method-type:      +      - */
end_comment

begin_function
specifier|static
name|enum
name|tree_code
name|c_parser_objc_method_type
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|)
block|{
switch|switch
condition|(
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
operator|->
name|type
condition|)
block|{
case|case
name|CPP_PLUS
case|:
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
return|return
name|PLUS_EXPR
return|;
case|case
name|CPP_MINUS
case|:
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
return|return
name|MINUS_EXPR
return|;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Parse an objc-method-definition.     objc-method-definition:      objc-method-type objc-method-decl ;[opt] compound-statement */
end_comment

begin_function
specifier|static
name|void
name|c_parser_objc_method_definition
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|)
block|{
name|enum
name|tree_code
name|type
init|=
name|c_parser_objc_method_type
argument_list|(
name|parser
argument_list|)
decl_stmt|;
name|tree
name|decl
decl_stmt|;
name|objc_set_method_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|objc_pq_context
operator|=
literal|1
expr_stmt|;
name|decl
operator|=
name|c_parser_objc_method_decl
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_SEMICOLON
argument_list|)
condition|)
block|{
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"extra semicolon in method definition specified"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_BRACE
argument_list|)
condition|)
block|{
name|c_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected %<{%>"
argument_list|)
expr_stmt|;
return|return;
block|}
name|objc_pq_context
operator|=
literal|0
expr_stmt|;
name|objc_start_method_definition
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|add_stmt
argument_list|(
name|c_parser_compound_statement
argument_list|(
name|parser
argument_list|)
argument_list|)
expr_stmt|;
name|objc_finish_method_definition
argument_list|(
name|current_function_decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse an objc-methodprotolist.     objc-methodprotolist:      empty      objc-methodprotolist objc-methodproto      objc-methodprotolist declaration      objc-methodprotolist ;     The declaration is a data definition, which may be missing    declaration specifiers under the same rules and diagnostics as    other data definitions outside functions, and the stray semicolon    is diagnosed the same way as a stray semicolon outside a    function.  */
end_comment

begin_function
specifier|static
name|void
name|c_parser_objc_methodprotolist
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|)
block|{
while|while
condition|(
name|true
condition|)
block|{
comment|/* The list is terminated by @end.  */
switch|switch
condition|(
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
operator|->
name|type
condition|)
block|{
case|case
name|CPP_SEMICOLON
case|:
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"ISO C does not allow extra %<;%> outside of a function"
argument_list|)
expr_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_PLUS
case|:
case|case
name|CPP_MINUS
case|:
name|c_parser_objc_methodproto
argument_list|(
name|parser
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_PRAGMA
case|:
name|c_parser_pragma
argument_list|(
name|parser
argument_list|,
name|pragma_external
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPP_EOF
case|:
return|return;
default|default:
if|if
condition|(
name|c_parser_next_token_is_keyword
argument_list|(
name|parser
argument_list|,
name|RID_AT_END
argument_list|)
condition|)
return|return;
name|c_parser_declaration_or_fndef
argument_list|(
name|parser
argument_list|,
name|false
argument_list|,
name|true
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Parse an objc-methodproto.     objc-methodproto:      objc-method-type objc-method-decl ; */
end_comment

begin_function
specifier|static
name|void
name|c_parser_objc_methodproto
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|)
block|{
name|enum
name|tree_code
name|type
init|=
name|c_parser_objc_method_type
argument_list|(
name|parser
argument_list|)
decl_stmt|;
name|tree
name|decl
decl_stmt|;
name|objc_set_method_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* Remember protocol qualifiers in prototypes.  */
name|objc_pq_context
operator|=
literal|1
expr_stmt|;
name|decl
operator|=
name|c_parser_objc_method_decl
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Forget protocol qualifiers here.  */
name|objc_pq_context
operator|=
literal|0
expr_stmt|;
name|objc_add_method_declaration
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|c_parser_skip_until_found
argument_list|(
name|parser
argument_list|,
name|CPP_SEMICOLON
argument_list|,
literal|"expected %<;%>"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse an objc-method-decl.     objc-method-decl:      ( objc-type-name ) objc-selector      objc-selector      ( objc-type-name ) objc-keyword-selector objc-optparmlist      objc-keyword-selector objc-optparmlist     objc-keyword-selector:      objc-keyword-decl      objc-keyword-selector objc-keyword-decl     objc-keyword-decl:      objc-selector : ( objc-type-name ) identifier      objc-selector : identifier      : ( objc-type-name ) identifier      : identifier     objc-optparmlist:      objc-optparms objc-optellipsis     objc-optparms:      empty      objc-opt-parms , parameter-declaration     objc-optellipsis:      empty      , ... */
end_comment

begin_function
specifier|static
name|tree
name|c_parser_objc_method_decl
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|type
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|sel
decl_stmt|;
name|tree
name|parms
init|=
name|NULL_TREE
decl_stmt|;
name|bool
name|ellipsis
init|=
name|false
decl_stmt|;
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_PAREN
argument_list|)
condition|)
block|{
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|type
operator|=
name|c_parser_objc_type_name
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|c_parser_skip_until_found
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
literal|"expected %<)%>"
argument_list|)
expr_stmt|;
block|}
name|sel
operator|=
name|c_parser_objc_selector
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* If there is no selector, or a colon follows, we have an      objc-keyword-selector.  If there is a selector, and a colon does      not follow, that selector ends the objc-method-decl.  */
if|if
condition|(
operator|!
name|sel
operator|||
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_COLON
argument_list|)
condition|)
block|{
name|tree
name|tsel
init|=
name|sel
decl_stmt|;
name|tree
name|list
init|=
name|NULL_TREE
decl_stmt|;
while|while
condition|(
name|true
condition|)
block|{
name|tree
name|atype
init|=
name|NULL_TREE
decl_stmt|,
name|id
decl_stmt|,
name|keyworddecl
decl_stmt|;
if|if
condition|(
operator|!
name|c_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_COLON
argument_list|,
literal|"expected %<:%>"
argument_list|)
condition|)
break|break;
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_PAREN
argument_list|)
condition|)
block|{
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|atype
operator|=
name|c_parser_objc_type_name
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|c_parser_skip_until_found
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
literal|"expected %<)%>"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c_parser_next_token_is_not
argument_list|(
name|parser
argument_list|,
name|CPP_NAME
argument_list|)
condition|)
block|{
name|c_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected identifier"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|id
operator|=
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
operator|->
name|value
expr_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|keyworddecl
operator|=
name|objc_build_keyword_decl
argument_list|(
name|tsel
argument_list|,
name|atype
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|list
operator|=
name|chainon
argument_list|(
name|list
argument_list|,
name|keyworddecl
argument_list|)
expr_stmt|;
name|tsel
operator|=
name|c_parser_objc_selector
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tsel
operator|&&
name|c_parser_next_token_is_not
argument_list|(
name|parser
argument_list|,
name|CPP_COLON
argument_list|)
condition|)
break|break;
block|}
comment|/* Parse the optional parameter list.  Optional Objective-C 	 method parameters follow the C syntax, and may include '...' 	 to denote a variable number of arguments.  */
name|parms
operator|=
name|make_node
argument_list|(
name|TREE_LIST
argument_list|)
expr_stmt|;
while|while
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_COMMA
argument_list|)
condition|)
block|{
name|struct
name|c_parm
modifier|*
name|parm
decl_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_ELLIPSIS
argument_list|)
condition|)
block|{
name|ellipsis
operator|=
name|true
expr_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
break|break;
block|}
name|parm
operator|=
name|c_parser_parameter_declaration
argument_list|(
name|parser
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|parm
operator|==
name|NULL
condition|)
break|break;
name|parms
operator|=
name|chainon
argument_list|(
name|parms
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|grokparm
argument_list|(
name|parm
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|sel
operator|=
name|list
expr_stmt|;
block|}
return|return
name|objc_build_method_signature
argument_list|(
name|type
argument_list|,
name|sel
argument_list|,
name|parms
argument_list|,
name|ellipsis
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Parse an objc-type-name.     objc-type-name:      objc-type-qualifiers[opt] type-name      objc-type-qualifiers[opt]     objc-type-qualifiers:      objc-type-qualifier      objc-type-qualifiers objc-type-qualifier     objc-type-qualifier: one of      in out inout bycopy byref oneway */
end_comment

begin_function
specifier|static
name|tree
name|c_parser_objc_type_name
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|quals
init|=
name|NULL_TREE
decl_stmt|;
name|struct
name|c_type_name
modifier|*
name|typename
init|=
name|NULL
decl_stmt|;
name|tree
name|type
init|=
name|NULL_TREE
decl_stmt|;
while|while
condition|(
name|true
condition|)
block|{
name|c_token
modifier|*
name|token
init|=
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
decl_stmt|;
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_KEYWORD
operator|&&
operator|(
name|token
operator|->
name|keyword
operator|==
name|RID_IN
operator|||
name|token
operator|->
name|keyword
operator|==
name|RID_OUT
operator|||
name|token
operator|->
name|keyword
operator|==
name|RID_INOUT
operator|||
name|token
operator|->
name|keyword
operator|==
name|RID_BYCOPY
operator|||
name|token
operator|->
name|keyword
operator|==
name|RID_BYREF
operator|||
name|token
operator|->
name|keyword
operator|==
name|RID_ONEWAY
operator|)
condition|)
block|{
name|quals
operator|=
name|chainon
argument_list|(
name|quals
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|token
operator|->
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
else|else
break|break;
block|}
if|if
condition|(
name|c_parser_next_token_starts_typename
argument_list|(
name|parser
argument_list|)
condition|)
name|typename
operator|=
name|c_parser_type_name
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|typename
condition|)
name|type
operator|=
name|groktypename
argument_list|(
name|typename
argument_list|)
expr_stmt|;
return|return
name|build_tree_list
argument_list|(
name|quals
argument_list|,
name|type
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Parse objc-protocol-refs.     objc-protocol-refs:< identifier-list> */
end_comment

begin_function
specifier|static
name|tree
name|c_parser_objc_protocol_refs
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|list
init|=
name|NULL_TREE
decl_stmt|;
name|gcc_assert
argument_list|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_LESS
argument_list|)
argument_list|)
expr_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* Any identifiers, including those declared as type names, are OK      here.  */
while|while
condition|(
name|true
condition|)
block|{
name|tree
name|id
decl_stmt|;
if|if
condition|(
name|c_parser_next_token_is_not
argument_list|(
name|parser
argument_list|,
name|CPP_NAME
argument_list|)
condition|)
block|{
name|c_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected identifier"
argument_list|)
expr_stmt|;
break|break;
block|}
name|id
operator|=
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
operator|->
name|value
expr_stmt|;
name|list
operator|=
name|chainon
argument_list|(
name|list
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|id
argument_list|)
argument_list|)
expr_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_COMMA
argument_list|)
condition|)
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
else|else
break|break;
block|}
name|c_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_GREATER
argument_list|,
literal|"expected %<>%>"
argument_list|)
expr_stmt|;
return|return
name|list
return|;
block|}
end_function

begin_comment
comment|/* Parse an objc-try-catch-statement.     objc-try-catch-statement:      @try compound-statement objc-catch-list[opt]      @try compound-statement objc-catch-list[opt] @finally compound-statement     objc-catch-list:      @catch ( parameter-declaration ) compound-statement      objc-catch-list @catch ( parameter-declaration ) compound-statement */
end_comment

begin_function
specifier|static
name|void
name|c_parser_objc_try_catch_statement
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|)
block|{
name|location_t
name|loc
decl_stmt|;
name|tree
name|stmt
decl_stmt|;
name|gcc_assert
argument_list|(
name|c_parser_next_token_is_keyword
argument_list|(
name|parser
argument_list|,
name|RID_AT_TRY
argument_list|)
argument_list|)
expr_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|loc
operator|=
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
operator|->
name|location
expr_stmt|;
name|stmt
operator|=
name|c_parser_compound_statement
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|objc_begin_try_stmt
argument_list|(
name|loc
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
while|while
condition|(
name|c_parser_next_token_is_keyword
argument_list|(
name|parser
argument_list|,
name|RID_AT_CATCH
argument_list|)
condition|)
block|{
name|struct
name|c_parm
modifier|*
name|parm
decl_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|c_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_PAREN
argument_list|,
literal|"expected %<(%>"
argument_list|)
condition|)
break|break;
name|parm
operator|=
name|c_parser_parameter_declaration
argument_list|(
name|parser
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|parm
operator|==
name|NULL
condition|)
block|{
name|c_parser_skip_until_found
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
name|c_parser_skip_until_found
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
literal|"expected %<)%>"
argument_list|)
expr_stmt|;
name|objc_begin_catch_clause
argument_list|(
name|grokparm
argument_list|(
name|parm
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_BRACE
argument_list|,
literal|"expected %<{%>"
argument_list|)
condition|)
name|c_parser_compound_statement_nostart
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|objc_finish_catch_clause
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|c_parser_next_token_is_keyword
argument_list|(
name|parser
argument_list|,
name|RID_AT_FINALLY
argument_list|)
condition|)
block|{
name|location_t
name|finloc
decl_stmt|;
name|tree
name|finstmt
decl_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|finloc
operator|=
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
operator|->
name|location
expr_stmt|;
name|finstmt
operator|=
name|c_parser_compound_statement
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|objc_build_finally_clause
argument_list|(
name|finloc
argument_list|,
name|finstmt
argument_list|)
expr_stmt|;
block|}
name|objc_finish_try_stmt
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse an objc-synchronized-statement.     objc-synchronized-statement:      @synchronized ( expression ) compound-statement */
end_comment

begin_function
specifier|static
name|void
name|c_parser_objc_synchronized_statement
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|)
block|{
name|location_t
name|loc
decl_stmt|;
name|tree
name|expr
decl_stmt|,
name|stmt
decl_stmt|;
name|gcc_assert
argument_list|(
name|c_parser_next_token_is_keyword
argument_list|(
name|parser
argument_list|,
name|RID_AT_SYNCHRONIZED
argument_list|)
argument_list|)
expr_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|loc
operator|=
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
operator|->
name|location
expr_stmt|;
if|if
condition|(
name|c_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_PAREN
argument_list|,
literal|"expected %<(%>"
argument_list|)
condition|)
block|{
name|expr
operator|=
name|c_parser_expression
argument_list|(
name|parser
argument_list|)
operator|.
name|value
expr_stmt|;
name|c_parser_skip_until_found
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
literal|"expected %<)%>"
argument_list|)
expr_stmt|;
block|}
else|else
name|expr
operator|=
name|error_mark_node
expr_stmt|;
name|stmt
operator|=
name|c_parser_compound_statement
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|objc_build_synchronized
argument_list|(
name|loc
argument_list|,
name|expr
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse an objc-selector; return NULL_TREE without an error if the    next token is not an objc-selector.     objc-selector:      identifier      one of        enum struct union if else while do for switch case default        break continue return goto asm sizeof typeof __alignof        unsigned long const short volatile signed restrict _Complex        in out inout bycopy byref oneway int char float double void _Bool     ??? Why this selection of keywords but not, for example, storage    class specifiers?  */
end_comment

begin_function
specifier|static
name|tree
name|c_parser_objc_selector
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|)
block|{
name|c_token
modifier|*
name|token
init|=
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
decl_stmt|;
name|tree
name|value
init|=
name|token
operator|->
name|value
decl_stmt|;
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_NAME
condition|)
block|{
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
if|if
condition|(
name|token
operator|->
name|type
operator|!=
name|CPP_KEYWORD
condition|)
return|return
name|NULL_TREE
return|;
switch|switch
condition|(
name|token
operator|->
name|keyword
condition|)
block|{
case|case
name|RID_ENUM
case|:
case|case
name|RID_STRUCT
case|:
case|case
name|RID_UNION
case|:
case|case
name|RID_IF
case|:
case|case
name|RID_ELSE
case|:
case|case
name|RID_WHILE
case|:
case|case
name|RID_DO
case|:
case|case
name|RID_FOR
case|:
case|case
name|RID_SWITCH
case|:
case|case
name|RID_CASE
case|:
case|case
name|RID_DEFAULT
case|:
case|case
name|RID_BREAK
case|:
case|case
name|RID_CONTINUE
case|:
case|case
name|RID_RETURN
case|:
case|case
name|RID_GOTO
case|:
case|case
name|RID_ASM
case|:
case|case
name|RID_SIZEOF
case|:
case|case
name|RID_TYPEOF
case|:
case|case
name|RID_ALIGNOF
case|:
case|case
name|RID_UNSIGNED
case|:
case|case
name|RID_LONG
case|:
case|case
name|RID_CONST
case|:
case|case
name|RID_SHORT
case|:
case|case
name|RID_VOLATILE
case|:
case|case
name|RID_SIGNED
case|:
case|case
name|RID_RESTRICT
case|:
case|case
name|RID_COMPLEX
case|:
case|case
name|RID_IN
case|:
case|case
name|RID_OUT
case|:
case|case
name|RID_INOUT
case|:
case|case
name|RID_BYCOPY
case|:
case|case
name|RID_BYREF
case|:
case|case
name|RID_ONEWAY
case|:
case|case
name|RID_INT
case|:
case|case
name|RID_CHAR
case|:
case|case
name|RID_FLOAT
case|:
case|case
name|RID_DOUBLE
case|:
case|case
name|RID_VOID
case|:
case|case
name|RID_BOOL
case|:
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
return|return
name|value
return|;
default|default:
return|return
name|NULL_TREE
return|;
block|}
block|}
end_function

begin_comment
comment|/* Parse an objc-selector-arg.     objc-selector-arg:      objc-selector      objc-keywordname-list     objc-keywordname-list:      objc-keywordname      objc-keywordname-list objc-keywordname     objc-keywordname:      objc-selector :      : */
end_comment

begin_function
specifier|static
name|tree
name|c_parser_objc_selector_arg
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|sel
init|=
name|c_parser_objc_selector
argument_list|(
name|parser
argument_list|)
decl_stmt|;
name|tree
name|list
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|sel
operator|&&
name|c_parser_next_token_is_not
argument_list|(
name|parser
argument_list|,
name|CPP_COLON
argument_list|)
condition|)
return|return
name|sel
return|;
while|while
condition|(
name|true
condition|)
block|{
if|if
condition|(
operator|!
name|c_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_COLON
argument_list|,
literal|"expected %<:%>"
argument_list|)
condition|)
return|return
name|list
return|;
name|list
operator|=
name|chainon
argument_list|(
name|list
argument_list|,
name|build_tree_list
argument_list|(
name|sel
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
expr_stmt|;
name|sel
operator|=
name|c_parser_objc_selector
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sel
operator|&&
name|c_parser_next_token_is_not
argument_list|(
name|parser
argument_list|,
name|CPP_COLON
argument_list|)
condition|)
break|break;
block|}
return|return
name|list
return|;
block|}
end_function

begin_comment
comment|/* Parse an objc-receiver.     objc-receiver:      expression      class-name      type-name */
end_comment

begin_function
specifier|static
name|tree
name|c_parser_objc_receiver
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|)
block|{
if|if
condition|(
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
operator|->
name|type
operator|==
name|CPP_NAME
operator|&&
operator|(
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
operator|->
name|id_kind
operator|==
name|C_ID_TYPENAME
operator|||
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
operator|->
name|id_kind
operator|==
name|C_ID_CLASSNAME
operator|)
condition|)
block|{
name|tree
name|id
init|=
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
operator|->
name|value
decl_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
return|return
name|objc_get_class_reference
argument_list|(
name|id
argument_list|)
return|;
block|}
return|return
name|c_parser_expression
argument_list|(
name|parser
argument_list|)
operator|.
name|value
return|;
block|}
end_function

begin_comment
comment|/* Parse objc-message-args.     objc-message-args:      objc-selector      objc-keywordarg-list     objc-keywordarg-list:      objc-keywordarg      objc-keywordarg-list objc-keywordarg     objc-keywordarg:      objc-selector : objc-keywordexpr      : objc-keywordexpr */
end_comment

begin_function
specifier|static
name|tree
name|c_parser_objc_message_args
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|sel
init|=
name|c_parser_objc_selector
argument_list|(
name|parser
argument_list|)
decl_stmt|;
name|tree
name|list
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|sel
operator|&&
name|c_parser_next_token_is_not
argument_list|(
name|parser
argument_list|,
name|CPP_COLON
argument_list|)
condition|)
return|return
name|sel
return|;
while|while
condition|(
name|true
condition|)
block|{
name|tree
name|keywordexpr
decl_stmt|;
if|if
condition|(
operator|!
name|c_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_COLON
argument_list|,
literal|"expected %<:%>"
argument_list|)
condition|)
return|return
name|list
return|;
name|keywordexpr
operator|=
name|c_parser_objc_keywordexpr
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|list
operator|=
name|chainon
argument_list|(
name|list
argument_list|,
name|build_tree_list
argument_list|(
name|sel
argument_list|,
name|keywordexpr
argument_list|)
argument_list|)
expr_stmt|;
name|sel
operator|=
name|c_parser_objc_selector
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sel
operator|&&
name|c_parser_next_token_is_not
argument_list|(
name|parser
argument_list|,
name|CPP_COLON
argument_list|)
condition|)
break|break;
block|}
return|return
name|list
return|;
block|}
end_function

begin_comment
comment|/* Parse an objc-keywordexpr.     objc-keywordexpr:      nonempty-expr-list */
end_comment

begin_function
specifier|static
name|tree
name|c_parser_objc_keywordexpr
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|list
init|=
name|c_parser_expr_list
argument_list|(
name|parser
argument_list|,
name|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|list
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
comment|/* Just return the expression, remove a level of 	 indirection.  */
return|return
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
return|;
block|}
else|else
block|{
comment|/* We have a comma expression, we will collapse later.  */
return|return
name|list
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Handle pragmas.  Some OpenMP pragmas are associated with, and therefore    should be considered, statements.  ALLOW_STMT is true if we're within    the context of a function and such pragmas are to be allowed.  Returns    true if we actually parsed such a pragma.  */
end_comment

begin_function
specifier|static
name|bool
name|c_parser_pragma
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|,
name|enum
name|pragma_context
name|context
parameter_list|)
block|{
name|unsigned
name|int
name|id
decl_stmt|;
name|id
operator|=
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
operator|->
name|pragma_kind
expr_stmt|;
name|gcc_assert
argument_list|(
name|id
operator|!=
name|PRAGMA_NONE
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|id
condition|)
block|{
case|case
name|PRAGMA_OMP_BARRIER
case|:
if|if
condition|(
name|context
operator|!=
name|pragma_compound
condition|)
block|{
if|if
condition|(
name|context
operator|==
name|pragma_stmt
condition|)
name|c_parser_error
argument_list|(
name|parser
argument_list|,
literal|"%<#pragma omp barrier%> may only be "
literal|"used in compound statements"
argument_list|)
expr_stmt|;
goto|goto
name|bad_stmt
goto|;
block|}
name|c_parser_omp_barrier
argument_list|(
name|parser
argument_list|)
expr_stmt|;
return|return
name|false
return|;
case|case
name|PRAGMA_OMP_FLUSH
case|:
if|if
condition|(
name|context
operator|!=
name|pragma_compound
condition|)
block|{
if|if
condition|(
name|context
operator|==
name|pragma_stmt
condition|)
name|c_parser_error
argument_list|(
name|parser
argument_list|,
literal|"%<#pragma omp flush%> may only be "
literal|"used in compound statements"
argument_list|)
expr_stmt|;
goto|goto
name|bad_stmt
goto|;
block|}
name|c_parser_omp_flush
argument_list|(
name|parser
argument_list|)
expr_stmt|;
return|return
name|false
return|;
case|case
name|PRAGMA_OMP_THREADPRIVATE
case|:
name|c_parser_omp_threadprivate
argument_list|(
name|parser
argument_list|)
expr_stmt|;
return|return
name|false
return|;
case|case
name|PRAGMA_OMP_SECTION
case|:
name|error
argument_list|(
literal|"%<#pragma omp section%> may only be used in "
literal|"%<#pragma omp sections%> construct"
argument_list|)
expr_stmt|;
name|c_parser_skip_until_found
argument_list|(
name|parser
argument_list|,
name|CPP_PRAGMA_EOL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|false
return|;
case|case
name|PRAGMA_GCC_PCH_PREPROCESS
case|:
name|c_parser_error
argument_list|(
name|parser
argument_list|,
literal|"%<#pragma GCC pch_preprocess%> must be first"
argument_list|)
expr_stmt|;
name|c_parser_skip_until_found
argument_list|(
name|parser
argument_list|,
name|CPP_PRAGMA_EOL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|false
return|;
default|default:
if|if
condition|(
name|id
operator|<
name|PRAGMA_FIRST_EXTERNAL
condition|)
block|{
if|if
condition|(
name|context
operator|==
name|pragma_external
condition|)
block|{
name|bad_stmt
label|:
name|c_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected declaration specifiers"
argument_list|)
expr_stmt|;
name|c_parser_skip_until_found
argument_list|(
name|parser
argument_list|,
name|CPP_PRAGMA_EOL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|c_parser_omp_construct
argument_list|(
name|parser
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
break|break;
block|}
name|c_parser_consume_pragma
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|c_invoke_pragma_handler
argument_list|(
name|id
argument_list|)
expr_stmt|;
comment|/* Skip to EOL, but suppress any error message.  Those will have been       generated by the handler routine through calling error, as opposed      to calling c_parser_error.  */
name|parser
operator|->
name|error
operator|=
name|true
expr_stmt|;
name|c_parser_skip_to_pragma_eol
argument_list|(
name|parser
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* The interface the pragma parsers have to the lexer.  */
end_comment

begin_function
name|enum
name|cpp_ttype
name|pragma_lex
parameter_list|(
name|tree
modifier|*
name|value
parameter_list|)
block|{
name|c_token
modifier|*
name|tok
init|=
name|c_parser_peek_token
argument_list|(
name|the_parser
argument_list|)
decl_stmt|;
name|enum
name|cpp_ttype
name|ret
init|=
name|tok
operator|->
name|type
decl_stmt|;
operator|*
name|value
operator|=
name|tok
operator|->
name|value
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|CPP_PRAGMA_EOL
operator|||
name|ret
operator|==
name|CPP_EOF
condition|)
name|ret
operator|=
name|CPP_EOF
expr_stmt|;
else|else
block|{
if|if
condition|(
name|ret
operator|==
name|CPP_KEYWORD
condition|)
name|ret
operator|=
name|CPP_NAME
expr_stmt|;
name|c_parser_consume_token
argument_list|(
name|the_parser
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|c_parser_pragma_pch_preprocess
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|name
init|=
name|NULL
decl_stmt|;
name|c_parser_consume_pragma
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_STRING
argument_list|)
condition|)
block|{
name|name
operator|=
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
operator|->
name|value
expr_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
else|else
name|c_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected string literal"
argument_list|)
expr_stmt|;
name|c_parser_skip_to_pragma_eol
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
condition|)
name|c_common_pch_pragma
argument_list|(
name|parse_in
argument_list|,
name|TREE_STRING_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* OpenMP 2.5 parsing routines.  */
end_comment

begin_comment
comment|/* Returns name of the next clause.    If the clause is not recognized PRAGMA_OMP_CLAUSE_NONE is returned and    the token is not consumed.  Otherwise appropriate pragma_omp_clause is    returned and the token is consumed.  */
end_comment

begin_function
specifier|static
name|pragma_omp_clause
name|c_parser_omp_clause_name
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|)
block|{
name|pragma_omp_clause
name|result
init|=
name|PRAGMA_OMP_CLAUSE_NONE
decl_stmt|;
if|if
condition|(
name|c_parser_next_token_is_keyword
argument_list|(
name|parser
argument_list|,
name|RID_IF
argument_list|)
condition|)
name|result
operator|=
name|PRAGMA_OMP_CLAUSE_IF
expr_stmt|;
elseif|else
if|if
condition|(
name|c_parser_next_token_is_keyword
argument_list|(
name|parser
argument_list|,
name|RID_DEFAULT
argument_list|)
condition|)
name|result
operator|=
name|PRAGMA_OMP_CLAUSE_DEFAULT
expr_stmt|;
elseif|else
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_NAME
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|p
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
operator|->
name|value
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|p
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'c'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"copyin"
argument_list|,
name|p
argument_list|)
condition|)
name|result
operator|=
name|PRAGMA_OMP_CLAUSE_COPYIN
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"copyprivate"
argument_list|,
name|p
argument_list|)
condition|)
name|result
operator|=
name|PRAGMA_OMP_CLAUSE_COPYPRIVATE
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"firstprivate"
argument_list|,
name|p
argument_list|)
condition|)
name|result
operator|=
name|PRAGMA_OMP_CLAUSE_FIRSTPRIVATE
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"lastprivate"
argument_list|,
name|p
argument_list|)
condition|)
name|result
operator|=
name|PRAGMA_OMP_CLAUSE_LASTPRIVATE
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"nowait"
argument_list|,
name|p
argument_list|)
condition|)
name|result
operator|=
name|PRAGMA_OMP_CLAUSE_NOWAIT
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"num_threads"
argument_list|,
name|p
argument_list|)
condition|)
name|result
operator|=
name|PRAGMA_OMP_CLAUSE_NUM_THREADS
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"ordered"
argument_list|,
name|p
argument_list|)
condition|)
name|result
operator|=
name|PRAGMA_OMP_CLAUSE_ORDERED
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"private"
argument_list|,
name|p
argument_list|)
condition|)
name|result
operator|=
name|PRAGMA_OMP_CLAUSE_PRIVATE
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"reduction"
argument_list|,
name|p
argument_list|)
condition|)
name|result
operator|=
name|PRAGMA_OMP_CLAUSE_REDUCTION
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"schedule"
argument_list|,
name|p
argument_list|)
condition|)
name|result
operator|=
name|PRAGMA_OMP_CLAUSE_SCHEDULE
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"shared"
argument_list|,
name|p
argument_list|)
condition|)
name|result
operator|=
name|PRAGMA_OMP_CLAUSE_SHARED
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|result
operator|!=
name|PRAGMA_OMP_CLAUSE_NONE
condition|)
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Validate that a clause of the given type does not already exist.  */
end_comment

begin_function
specifier|static
name|void
name|check_no_duplicate_clause
parameter_list|(
name|tree
name|clauses
parameter_list|,
name|enum
name|tree_code
name|code
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|tree
name|c
decl_stmt|;
for|for
control|(
name|c
operator|=
name|clauses
init|;
name|c
condition|;
name|c
operator|=
name|OMP_CLAUSE_CHAIN
argument_list|(
name|c
argument_list|)
control|)
if|if
condition|(
name|OMP_CLAUSE_CODE
argument_list|(
name|c
argument_list|)
operator|==
name|code
condition|)
block|{
name|error
argument_list|(
literal|"too many %qs clauses"
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* OpenMP 2.5:    variable-list:      identifier      variable-list , identifier     If KIND is nonzero, create the appropriate node and install the decl    in OMP_CLAUSE_DECL and add the node to the head of the list.     If KIND is zero, create a TREE_LIST with the decl in TREE_PURPOSE;    return the list created.  */
end_comment

begin_function
specifier|static
name|tree
name|c_parser_omp_variable_list
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|,
name|enum
name|omp_clause_code
name|kind
parameter_list|,
name|tree
name|list
parameter_list|)
block|{
if|if
condition|(
name|c_parser_next_token_is_not
argument_list|(
name|parser
argument_list|,
name|CPP_NAME
argument_list|)
operator|||
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
operator|->
name|id_kind
operator|!=
name|C_ID_ID
condition|)
name|c_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected identifier"
argument_list|)
expr_stmt|;
while|while
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_NAME
argument_list|)
operator|&&
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
operator|->
name|id_kind
operator|==
name|C_ID_ID
condition|)
block|{
name|tree
name|t
init|=
name|lookup_name
argument_list|(
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
operator|->
name|value
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL_TREE
condition|)
name|undeclared_variable
argument_list|(
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
operator|->
name|value
argument_list|,
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
operator|->
name|location
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|t
operator|==
name|error_mark_node
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|kind
operator|!=
literal|0
condition|)
block|{
name|tree
name|u
init|=
name|build_omp_clause
argument_list|(
name|kind
argument_list|)
decl_stmt|;
name|OMP_CLAUSE_DECL
argument_list|(
name|u
argument_list|)
operator|=
name|t
expr_stmt|;
name|OMP_CLAUSE_CHAIN
argument_list|(
name|u
argument_list|)
operator|=
name|list
expr_stmt|;
name|list
operator|=
name|u
expr_stmt|;
block|}
else|else
name|list
operator|=
name|tree_cons
argument_list|(
name|t
argument_list|,
name|NULL_TREE
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_parser_next_token_is_not
argument_list|(
name|parser
argument_list|,
name|CPP_COMMA
argument_list|)
condition|)
break|break;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
return|return
name|list
return|;
block|}
end_function

begin_comment
comment|/* Similarly, but expect leading and trailing parenthesis.  This is a very    common case for omp clauses.  */
end_comment

begin_function
specifier|static
name|tree
name|c_parser_omp_var_list_parens
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|,
name|enum
name|tree_code
name|kind
parameter_list|,
name|tree
name|list
parameter_list|)
block|{
if|if
condition|(
name|c_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_PAREN
argument_list|,
literal|"expected %<(%>"
argument_list|)
condition|)
block|{
name|list
operator|=
name|c_parser_omp_variable_list
argument_list|(
name|parser
argument_list|,
name|kind
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|c_parser_skip_until_found
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
literal|"expected %<)%>"
argument_list|)
expr_stmt|;
block|}
return|return
name|list
return|;
block|}
end_function

begin_comment
comment|/* OpenMP 2.5:    copyin ( variable-list ) */
end_comment

begin_function
specifier|static
name|tree
name|c_parser_omp_clause_copyin
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|,
name|tree
name|list
parameter_list|)
block|{
return|return
name|c_parser_omp_var_list_parens
argument_list|(
name|parser
argument_list|,
name|OMP_CLAUSE_COPYIN
argument_list|,
name|list
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* OpenMP 2.5:    copyprivate ( variable-list ) */
end_comment

begin_function
specifier|static
name|tree
name|c_parser_omp_clause_copyprivate
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|,
name|tree
name|list
parameter_list|)
block|{
return|return
name|c_parser_omp_var_list_parens
argument_list|(
name|parser
argument_list|,
name|OMP_CLAUSE_COPYPRIVATE
argument_list|,
name|list
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* OpenMP 2.5:    default ( shared | none ) */
end_comment

begin_function
specifier|static
name|tree
name|c_parser_omp_clause_default
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|,
name|tree
name|list
parameter_list|)
block|{
name|enum
name|omp_clause_default_kind
name|kind
init|=
name|OMP_CLAUSE_DEFAULT_UNSPECIFIED
decl_stmt|;
name|tree
name|c
decl_stmt|;
if|if
condition|(
operator|!
name|c_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_PAREN
argument_list|,
literal|"expected %<(%>"
argument_list|)
condition|)
return|return
name|list
return|;
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_NAME
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|p
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
operator|->
name|value
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|p
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'n'
case|:
if|if
condition|(
name|strcmp
argument_list|(
literal|"none"
argument_list|,
name|p
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|invalid_kind
goto|;
name|kind
operator|=
name|OMP_CLAUSE_DEFAULT_NONE
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
if|if
condition|(
name|strcmp
argument_list|(
literal|"shared"
argument_list|,
name|p
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|invalid_kind
goto|;
name|kind
operator|=
name|OMP_CLAUSE_DEFAULT_SHARED
expr_stmt|;
break|break;
default|default:
goto|goto
name|invalid_kind
goto|;
block|}
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|invalid_kind
label|:
name|c_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected %<none%> or %<shared%>"
argument_list|)
expr_stmt|;
block|}
name|c_parser_skip_until_found
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
literal|"expected %<)%>"
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|OMP_CLAUSE_DEFAULT_UNSPECIFIED
condition|)
return|return
name|list
return|;
name|check_no_duplicate_clause
argument_list|(
name|list
argument_list|,
name|OMP_CLAUSE_DEFAULT
argument_list|,
literal|"default"
argument_list|)
expr_stmt|;
name|c
operator|=
name|build_omp_clause
argument_list|(
name|OMP_CLAUSE_DEFAULT
argument_list|)
expr_stmt|;
name|OMP_CLAUSE_CHAIN
argument_list|(
name|c
argument_list|)
operator|=
name|list
expr_stmt|;
name|OMP_CLAUSE_DEFAULT_KIND
argument_list|(
name|c
argument_list|)
operator|=
name|kind
expr_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_comment
comment|/* OpenMP 2.5:    firstprivate ( variable-list ) */
end_comment

begin_function
specifier|static
name|tree
name|c_parser_omp_clause_firstprivate
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|,
name|tree
name|list
parameter_list|)
block|{
return|return
name|c_parser_omp_var_list_parens
argument_list|(
name|parser
argument_list|,
name|OMP_CLAUSE_FIRSTPRIVATE
argument_list|,
name|list
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* OpenMP 2.5:    if ( expression ) */
end_comment

begin_function
specifier|static
name|tree
name|c_parser_omp_clause_if
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|,
name|tree
name|list
parameter_list|)
block|{
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_PAREN
argument_list|)
condition|)
block|{
name|tree
name|t
init|=
name|c_parser_paren_condition
argument_list|(
name|parser
argument_list|)
decl_stmt|;
name|tree
name|c
decl_stmt|;
name|check_no_duplicate_clause
argument_list|(
name|list
argument_list|,
name|OMP_CLAUSE_IF
argument_list|,
literal|"if"
argument_list|)
expr_stmt|;
name|c
operator|=
name|build_omp_clause
argument_list|(
name|OMP_CLAUSE_IF
argument_list|)
expr_stmt|;
name|OMP_CLAUSE_IF_EXPR
argument_list|(
name|c
argument_list|)
operator|=
name|t
expr_stmt|;
name|OMP_CLAUSE_CHAIN
argument_list|(
name|c
argument_list|)
operator|=
name|list
expr_stmt|;
name|list
operator|=
name|c
expr_stmt|;
block|}
else|else
name|c_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected %<(%>"
argument_list|)
expr_stmt|;
return|return
name|list
return|;
block|}
end_function

begin_comment
comment|/* OpenMP 2.5:    lastprivate ( variable-list ) */
end_comment

begin_function
specifier|static
name|tree
name|c_parser_omp_clause_lastprivate
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|,
name|tree
name|list
parameter_list|)
block|{
return|return
name|c_parser_omp_var_list_parens
argument_list|(
name|parser
argument_list|,
name|OMP_CLAUSE_LASTPRIVATE
argument_list|,
name|list
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* OpenMP 2.5:    nowait */
end_comment

begin_function
specifier|static
name|tree
name|c_parser_omp_clause_nowait
parameter_list|(
name|c_parser
modifier|*
name|parser
name|ATTRIBUTE_UNUSED
parameter_list|,
name|tree
name|list
parameter_list|)
block|{
name|tree
name|c
decl_stmt|;
name|check_no_duplicate_clause
argument_list|(
name|list
argument_list|,
name|OMP_CLAUSE_NOWAIT
argument_list|,
literal|"nowait"
argument_list|)
expr_stmt|;
name|c
operator|=
name|build_omp_clause
argument_list|(
name|OMP_CLAUSE_NOWAIT
argument_list|)
expr_stmt|;
name|OMP_CLAUSE_CHAIN
argument_list|(
name|c
argument_list|)
operator|=
name|list
expr_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_comment
comment|/* OpenMP 2.5:    num_threads ( expression ) */
end_comment

begin_function
specifier|static
name|tree
name|c_parser_omp_clause_num_threads
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|,
name|tree
name|list
parameter_list|)
block|{
if|if
condition|(
name|c_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_PAREN
argument_list|,
literal|"expected %<(%>"
argument_list|)
condition|)
block|{
name|tree
name|c
decl_stmt|,
name|t
init|=
name|c_parser_expression
argument_list|(
name|parser
argument_list|)
operator|.
name|value
decl_stmt|;
name|c_parser_skip_until_found
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
literal|"expected %<)%>"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
block|{
name|c_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected integer expression"
argument_list|)
expr_stmt|;
return|return
name|list
return|;
block|}
comment|/* Attempt to statically determine when the number isn't positive.  */
name|c
operator|=
name|fold_build2
argument_list|(
name|LE_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|t
argument_list|,
name|build_int_cst
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|boolean_true_node
condition|)
block|{
name|warning
argument_list|(
literal|0
argument_list|,
literal|"%<num_threads%> value must be positive"
argument_list|)
expr_stmt|;
name|t
operator|=
name|integer_one_node
expr_stmt|;
block|}
name|check_no_duplicate_clause
argument_list|(
name|list
argument_list|,
name|OMP_CLAUSE_NUM_THREADS
argument_list|,
literal|"num_threads"
argument_list|)
expr_stmt|;
name|c
operator|=
name|build_omp_clause
argument_list|(
name|OMP_CLAUSE_NUM_THREADS
argument_list|)
expr_stmt|;
name|OMP_CLAUSE_NUM_THREADS_EXPR
argument_list|(
name|c
argument_list|)
operator|=
name|t
expr_stmt|;
name|OMP_CLAUSE_CHAIN
argument_list|(
name|c
argument_list|)
operator|=
name|list
expr_stmt|;
name|list
operator|=
name|c
expr_stmt|;
block|}
return|return
name|list
return|;
block|}
end_function

begin_comment
comment|/* OpenMP 2.5:    ordered */
end_comment

begin_function
specifier|static
name|tree
name|c_parser_omp_clause_ordered
parameter_list|(
name|c_parser
modifier|*
name|parser
name|ATTRIBUTE_UNUSED
parameter_list|,
name|tree
name|list
parameter_list|)
block|{
name|tree
name|c
decl_stmt|;
name|check_no_duplicate_clause
argument_list|(
name|list
argument_list|,
name|OMP_CLAUSE_ORDERED
argument_list|,
literal|"ordered"
argument_list|)
expr_stmt|;
name|c
operator|=
name|build_omp_clause
argument_list|(
name|OMP_CLAUSE_ORDERED
argument_list|)
expr_stmt|;
name|OMP_CLAUSE_CHAIN
argument_list|(
name|c
argument_list|)
operator|=
name|list
expr_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_comment
comment|/* OpenMP 2.5:    private ( variable-list ) */
end_comment

begin_function
specifier|static
name|tree
name|c_parser_omp_clause_private
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|,
name|tree
name|list
parameter_list|)
block|{
return|return
name|c_parser_omp_var_list_parens
argument_list|(
name|parser
argument_list|,
name|OMP_CLAUSE_PRIVATE
argument_list|,
name|list
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* OpenMP 2.5:    reduction ( reduction-operator : variable-list )     reduction-operator:      One of: + * -& ^ |&& || */
end_comment

begin_function
specifier|static
name|tree
name|c_parser_omp_clause_reduction
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|,
name|tree
name|list
parameter_list|)
block|{
if|if
condition|(
name|c_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_PAREN
argument_list|,
literal|"expected %<(%>"
argument_list|)
condition|)
block|{
name|enum
name|tree_code
name|code
decl_stmt|;
switch|switch
condition|(
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
operator|->
name|type
condition|)
block|{
case|case
name|CPP_PLUS
case|:
name|code
operator|=
name|PLUS_EXPR
expr_stmt|;
break|break;
case|case
name|CPP_MULT
case|:
name|code
operator|=
name|MULT_EXPR
expr_stmt|;
break|break;
case|case
name|CPP_MINUS
case|:
name|code
operator|=
name|MINUS_EXPR
expr_stmt|;
break|break;
case|case
name|CPP_AND
case|:
name|code
operator|=
name|BIT_AND_EXPR
expr_stmt|;
break|break;
case|case
name|CPP_XOR
case|:
name|code
operator|=
name|BIT_XOR_EXPR
expr_stmt|;
break|break;
case|case
name|CPP_OR
case|:
name|code
operator|=
name|BIT_IOR_EXPR
expr_stmt|;
break|break;
case|case
name|CPP_AND_AND
case|:
name|code
operator|=
name|TRUTH_ANDIF_EXPR
expr_stmt|;
break|break;
case|case
name|CPP_OR_OR
case|:
name|code
operator|=
name|TRUTH_ORIF_EXPR
expr_stmt|;
break|break;
default|default:
name|c_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected %<+%>, %<*%>, %<-%>, %<&%>, "
literal|"%<^%>, %<|%>, %<&&%>, or %<||%>"
argument_list|)
expr_stmt|;
name|c_parser_skip_until_found
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|list
return|;
block|}
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_COLON
argument_list|,
literal|"expected %<:%>"
argument_list|)
condition|)
block|{
name|tree
name|nl
decl_stmt|,
name|c
decl_stmt|;
name|nl
operator|=
name|c_parser_omp_variable_list
argument_list|(
name|parser
argument_list|,
name|OMP_CLAUSE_REDUCTION
argument_list|,
name|list
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
name|nl
init|;
name|c
operator|!=
name|list
condition|;
name|c
operator|=
name|OMP_CLAUSE_CHAIN
argument_list|(
name|c
argument_list|)
control|)
name|OMP_CLAUSE_REDUCTION_CODE
argument_list|(
name|c
argument_list|)
operator|=
name|code
expr_stmt|;
name|list
operator|=
name|nl
expr_stmt|;
block|}
name|c_parser_skip_until_found
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
literal|"expected %<)%>"
argument_list|)
expr_stmt|;
block|}
return|return
name|list
return|;
block|}
end_function

begin_comment
comment|/* OpenMP 2.5:    schedule ( schedule-kind )    schedule ( schedule-kind , expression )     schedule-kind:      static | dynamic | guided | runtime */
end_comment

begin_function
specifier|static
name|tree
name|c_parser_omp_clause_schedule
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|,
name|tree
name|list
parameter_list|)
block|{
name|tree
name|c
decl_stmt|,
name|t
decl_stmt|;
if|if
condition|(
operator|!
name|c_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_PAREN
argument_list|,
literal|"expected %<(%>"
argument_list|)
condition|)
return|return
name|list
return|;
name|c
operator|=
name|build_omp_clause
argument_list|(
name|OMP_CLAUSE_SCHEDULE
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_NAME
argument_list|)
condition|)
block|{
name|tree
name|kind
init|=
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
operator|->
name|value
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|kind
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|p
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'d'
case|:
if|if
condition|(
name|strcmp
argument_list|(
literal|"dynamic"
argument_list|,
name|p
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|invalid_kind
goto|;
name|OMP_CLAUSE_SCHEDULE_KIND
argument_list|(
name|c
argument_list|)
operator|=
name|OMP_CLAUSE_SCHEDULE_DYNAMIC
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
if|if
condition|(
name|strcmp
argument_list|(
literal|"guided"
argument_list|,
name|p
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|invalid_kind
goto|;
name|OMP_CLAUSE_SCHEDULE_KIND
argument_list|(
name|c
argument_list|)
operator|=
name|OMP_CLAUSE_SCHEDULE_GUIDED
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
if|if
condition|(
name|strcmp
argument_list|(
literal|"runtime"
argument_list|,
name|p
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|invalid_kind
goto|;
name|OMP_CLAUSE_SCHEDULE_KIND
argument_list|(
name|c
argument_list|)
operator|=
name|OMP_CLAUSE_SCHEDULE_RUNTIME
expr_stmt|;
break|break;
default|default:
goto|goto
name|invalid_kind
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|c_parser_next_token_is_keyword
argument_list|(
name|parser
argument_list|,
name|RID_STATIC
argument_list|)
condition|)
name|OMP_CLAUSE_SCHEDULE_KIND
argument_list|(
name|c
argument_list|)
operator|=
name|OMP_CLAUSE_SCHEDULE_STATIC
expr_stmt|;
else|else
goto|goto
name|invalid_kind
goto|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_COMMA
argument_list|)
condition|)
block|{
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|t
operator|=
name|c_parser_expr_no_commas
argument_list|(
name|parser
argument_list|,
name|NULL
argument_list|)
operator|.
name|value
expr_stmt|;
if|if
condition|(
name|OMP_CLAUSE_SCHEDULE_KIND
argument_list|(
name|c
argument_list|)
operator|==
name|OMP_CLAUSE_SCHEDULE_RUNTIME
condition|)
name|error
argument_list|(
literal|"schedule %<runtime%> does not take "
literal|"a %<chunk_size%> parameter"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
condition|)
name|OMP_CLAUSE_SCHEDULE_CHUNK_EXPR
argument_list|(
name|c
argument_list|)
operator|=
name|t
expr_stmt|;
else|else
name|c_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected integer expression"
argument_list|)
expr_stmt|;
name|c_parser_skip_until_found
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
literal|"expected %<)%>"
argument_list|)
expr_stmt|;
block|}
else|else
name|c_parser_skip_until_found
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
literal|"expected %<,%> or %<)%>"
argument_list|)
expr_stmt|;
name|check_no_duplicate_clause
argument_list|(
name|list
argument_list|,
name|OMP_CLAUSE_SCHEDULE
argument_list|,
literal|"schedule"
argument_list|)
expr_stmt|;
name|OMP_CLAUSE_CHAIN
argument_list|(
name|c
argument_list|)
operator|=
name|list
expr_stmt|;
return|return
name|c
return|;
name|invalid_kind
label|:
name|c_parser_error
argument_list|(
name|parser
argument_list|,
literal|"invalid schedule kind"
argument_list|)
expr_stmt|;
name|c_parser_skip_until_found
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|list
return|;
block|}
end_function

begin_comment
comment|/* OpenMP 2.5:    shared ( variable-list ) */
end_comment

begin_function
specifier|static
name|tree
name|c_parser_omp_clause_shared
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|,
name|tree
name|list
parameter_list|)
block|{
return|return
name|c_parser_omp_var_list_parens
argument_list|(
name|parser
argument_list|,
name|OMP_CLAUSE_SHARED
argument_list|,
name|list
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Parse all OpenMP clauses.  The set clauses allowed by the directive    is a bitmask in MASK.  Return the list of clauses found; the result    of clause default goes in *pdefault.  */
end_comment

begin_function
specifier|static
name|tree
name|c_parser_omp_all_clauses
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|,
name|unsigned
name|int
name|mask
parameter_list|,
specifier|const
name|char
modifier|*
name|where
parameter_list|)
block|{
name|tree
name|clauses
init|=
name|NULL
decl_stmt|;
while|while
condition|(
name|c_parser_next_token_is_not
argument_list|(
name|parser
argument_list|,
name|CPP_PRAGMA_EOL
argument_list|)
condition|)
block|{
specifier|const
name|pragma_omp_clause
name|c_kind
init|=
name|c_parser_omp_clause_name
argument_list|(
name|parser
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|c_name
decl_stmt|;
name|tree
name|prev
init|=
name|clauses
decl_stmt|;
switch|switch
condition|(
name|c_kind
condition|)
block|{
case|case
name|PRAGMA_OMP_CLAUSE_COPYIN
case|:
name|clauses
operator|=
name|c_parser_omp_clause_copyin
argument_list|(
name|parser
argument_list|,
name|clauses
argument_list|)
expr_stmt|;
name|c_name
operator|=
literal|"copyin"
expr_stmt|;
break|break;
case|case
name|PRAGMA_OMP_CLAUSE_COPYPRIVATE
case|:
name|clauses
operator|=
name|c_parser_omp_clause_copyprivate
argument_list|(
name|parser
argument_list|,
name|clauses
argument_list|)
expr_stmt|;
name|c_name
operator|=
literal|"copyprivate"
expr_stmt|;
break|break;
case|case
name|PRAGMA_OMP_CLAUSE_DEFAULT
case|:
name|clauses
operator|=
name|c_parser_omp_clause_default
argument_list|(
name|parser
argument_list|,
name|clauses
argument_list|)
expr_stmt|;
name|c_name
operator|=
literal|"default"
expr_stmt|;
break|break;
case|case
name|PRAGMA_OMP_CLAUSE_FIRSTPRIVATE
case|:
name|clauses
operator|=
name|c_parser_omp_clause_firstprivate
argument_list|(
name|parser
argument_list|,
name|clauses
argument_list|)
expr_stmt|;
name|c_name
operator|=
literal|"firstprivate"
expr_stmt|;
break|break;
case|case
name|PRAGMA_OMP_CLAUSE_IF
case|:
name|clauses
operator|=
name|c_parser_omp_clause_if
argument_list|(
name|parser
argument_list|,
name|clauses
argument_list|)
expr_stmt|;
name|c_name
operator|=
literal|"if"
expr_stmt|;
break|break;
case|case
name|PRAGMA_OMP_CLAUSE_LASTPRIVATE
case|:
name|clauses
operator|=
name|c_parser_omp_clause_lastprivate
argument_list|(
name|parser
argument_list|,
name|clauses
argument_list|)
expr_stmt|;
name|c_name
operator|=
literal|"lastprivate"
expr_stmt|;
break|break;
case|case
name|PRAGMA_OMP_CLAUSE_NOWAIT
case|:
name|clauses
operator|=
name|c_parser_omp_clause_nowait
argument_list|(
name|parser
argument_list|,
name|clauses
argument_list|)
expr_stmt|;
name|c_name
operator|=
literal|"nowait"
expr_stmt|;
break|break;
case|case
name|PRAGMA_OMP_CLAUSE_NUM_THREADS
case|:
name|clauses
operator|=
name|c_parser_omp_clause_num_threads
argument_list|(
name|parser
argument_list|,
name|clauses
argument_list|)
expr_stmt|;
name|c_name
operator|=
literal|"num_threads"
expr_stmt|;
break|break;
case|case
name|PRAGMA_OMP_CLAUSE_ORDERED
case|:
name|clauses
operator|=
name|c_parser_omp_clause_ordered
argument_list|(
name|parser
argument_list|,
name|clauses
argument_list|)
expr_stmt|;
name|c_name
operator|=
literal|"ordered"
expr_stmt|;
break|break;
case|case
name|PRAGMA_OMP_CLAUSE_PRIVATE
case|:
name|clauses
operator|=
name|c_parser_omp_clause_private
argument_list|(
name|parser
argument_list|,
name|clauses
argument_list|)
expr_stmt|;
name|c_name
operator|=
literal|"private"
expr_stmt|;
break|break;
case|case
name|PRAGMA_OMP_CLAUSE_REDUCTION
case|:
name|clauses
operator|=
name|c_parser_omp_clause_reduction
argument_list|(
name|parser
argument_list|,
name|clauses
argument_list|)
expr_stmt|;
name|c_name
operator|=
literal|"reduction"
expr_stmt|;
break|break;
case|case
name|PRAGMA_OMP_CLAUSE_SCHEDULE
case|:
name|clauses
operator|=
name|c_parser_omp_clause_schedule
argument_list|(
name|parser
argument_list|,
name|clauses
argument_list|)
expr_stmt|;
name|c_name
operator|=
literal|"schedule"
expr_stmt|;
break|break;
case|case
name|PRAGMA_OMP_CLAUSE_SHARED
case|:
name|clauses
operator|=
name|c_parser_omp_clause_shared
argument_list|(
name|parser
argument_list|,
name|clauses
argument_list|)
expr_stmt|;
name|c_name
operator|=
literal|"shared"
expr_stmt|;
break|break;
default|default:
name|c_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected %<#pragma omp%> clause"
argument_list|)
expr_stmt|;
goto|goto
name|saw_error
goto|;
block|}
if|if
condition|(
operator|(
operator|(
name|mask
operator|>>
name|c_kind
operator|)
operator|&
literal|1
operator|)
operator|==
literal|0
operator|&&
operator|!
name|parser
operator|->
name|error
condition|)
block|{
comment|/* Remove the invalid clause(s) from the list to avoid 	     confusing the rest of the compiler.  */
name|clauses
operator|=
name|prev
expr_stmt|;
name|error
argument_list|(
literal|"%qs is not valid for %qs"
argument_list|,
name|c_name
argument_list|,
name|where
argument_list|)
expr_stmt|;
block|}
block|}
name|saw_error
label|:
name|c_parser_skip_to_pragma_eol
argument_list|(
name|parser
argument_list|)
expr_stmt|;
return|return
name|c_finish_omp_clauses
argument_list|(
name|clauses
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* OpenMP 2.5:    structured-block:      statement     In practice, we're also interested in adding the statement to an    outer node.  So it is convenient if we work around the fact that    c_parser_statement calls add_stmt.  */
end_comment

begin_function
specifier|static
name|tree
name|c_parser_omp_structured_block
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|stmt
init|=
name|push_stmt_list
argument_list|()
decl_stmt|;
name|c_parser_statement
argument_list|(
name|parser
argument_list|)
expr_stmt|;
return|return
name|pop_stmt_list
argument_list|(
name|stmt
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* OpenMP 2.5:    # pragma omp atomic new-line      expression-stmt     expression-stmt:      x binop= expr | x++ | ++x | x-- | --x    binop:      +, *, -, /,&, ^, |,<<,>>    where x is an lvalue expression with scalar type.  */
end_comment

begin_function
specifier|static
name|void
name|c_parser_omp_atomic
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|lhs
decl_stmt|,
name|rhs
decl_stmt|;
name|tree
name|stmt
decl_stmt|;
name|enum
name|tree_code
name|code
decl_stmt|;
name|c_parser_skip_to_pragma_eol
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|lhs
operator|=
name|c_parser_unary_expression
argument_list|(
name|parser
argument_list|)
operator|.
name|value
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|lhs
argument_list|)
condition|)
block|{
case|case
name|ERROR_MARK
case|:
name|saw_error
label|:
name|c_parser_skip_to_end_of_block_or_statement
argument_list|(
name|parser
argument_list|)
expr_stmt|;
return|return;
case|case
name|PREINCREMENT_EXPR
case|:
case|case
name|POSTINCREMENT_EXPR
case|:
name|lhs
operator|=
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|code
operator|=
name|PLUS_EXPR
expr_stmt|;
name|rhs
operator|=
name|integer_one_node
expr_stmt|;
break|break;
case|case
name|PREDECREMENT_EXPR
case|:
case|case
name|POSTDECREMENT_EXPR
case|:
name|lhs
operator|=
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|code
operator|=
name|MINUS_EXPR
expr_stmt|;
name|rhs
operator|=
name|integer_one_node
expr_stmt|;
break|break;
default|default:
switch|switch
condition|(
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
operator|->
name|type
condition|)
block|{
case|case
name|CPP_MULT_EQ
case|:
name|code
operator|=
name|MULT_EXPR
expr_stmt|;
break|break;
case|case
name|CPP_DIV_EQ
case|:
name|code
operator|=
name|TRUNC_DIV_EXPR
expr_stmt|;
break|break;
case|case
name|CPP_PLUS_EQ
case|:
name|code
operator|=
name|PLUS_EXPR
expr_stmt|;
break|break;
case|case
name|CPP_MINUS_EQ
case|:
name|code
operator|=
name|MINUS_EXPR
expr_stmt|;
break|break;
case|case
name|CPP_LSHIFT_EQ
case|:
name|code
operator|=
name|LSHIFT_EXPR
expr_stmt|;
break|break;
case|case
name|CPP_RSHIFT_EQ
case|:
name|code
operator|=
name|RSHIFT_EXPR
expr_stmt|;
break|break;
case|case
name|CPP_AND_EQ
case|:
name|code
operator|=
name|BIT_AND_EXPR
expr_stmt|;
break|break;
case|case
name|CPP_OR_EQ
case|:
name|code
operator|=
name|BIT_IOR_EXPR
expr_stmt|;
break|break;
case|case
name|CPP_XOR_EQ
case|:
name|code
operator|=
name|BIT_XOR_EXPR
expr_stmt|;
break|break;
default|default:
name|c_parser_error
argument_list|(
name|parser
argument_list|,
literal|"invalid operator for %<#pragma omp atomic%>"
argument_list|)
expr_stmt|;
goto|goto
name|saw_error
goto|;
block|}
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|rhs
operator|=
name|c_parser_expression
argument_list|(
name|parser
argument_list|)
operator|.
name|value
expr_stmt|;
break|break;
block|}
name|stmt
operator|=
name|c_finish_omp_atomic
argument_list|(
name|code
argument_list|,
name|lhs
argument_list|,
name|rhs
argument_list|)
expr_stmt|;
if|if
condition|(
name|stmt
operator|!=
name|error_mark_node
condition|)
name|add_stmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|c_parser_skip_until_found
argument_list|(
name|parser
argument_list|,
name|CPP_SEMICOLON
argument_list|,
literal|"expected %<;%>"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* OpenMP 2.5:    # pragma omp barrier new-line */
end_comment

begin_function
specifier|static
name|void
name|c_parser_omp_barrier
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|)
block|{
name|c_parser_consume_pragma
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|c_parser_skip_to_pragma_eol
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|c_finish_omp_barrier
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* OpenMP 2.5:    # pragma omp critical [(name)] new-line      structured-block */
end_comment

begin_function
specifier|static
name|tree
name|c_parser_omp_critical
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|stmt
decl_stmt|,
name|name
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_PAREN
argument_list|)
condition|)
block|{
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_NAME
argument_list|)
condition|)
block|{
name|name
operator|=
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
operator|->
name|value
expr_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|c_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
literal|"expected %<)%>"
argument_list|)
expr_stmt|;
block|}
else|else
name|c_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected identifier"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c_parser_next_token_is_not
argument_list|(
name|parser
argument_list|,
name|CPP_PRAGMA_EOL
argument_list|)
condition|)
name|c_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected %<(%> or end of line"
argument_list|)
expr_stmt|;
name|c_parser_skip_to_pragma_eol
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|c_parser_omp_structured_block
argument_list|(
name|parser
argument_list|)
expr_stmt|;
return|return
name|c_finish_omp_critical
argument_list|(
name|stmt
argument_list|,
name|name
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* OpenMP 2.5:    # pragma omp flush flush-vars[opt] new-line     flush-vars:      ( variable-list ) */
end_comment

begin_function
specifier|static
name|void
name|c_parser_omp_flush
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|)
block|{
name|c_parser_consume_pragma
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_PAREN
argument_list|)
condition|)
name|c_parser_omp_var_list_parens
argument_list|(
name|parser
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c_parser_next_token_is_not
argument_list|(
name|parser
argument_list|,
name|CPP_PRAGMA_EOL
argument_list|)
condition|)
name|c_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected %<(%> or end of line"
argument_list|)
expr_stmt|;
name|c_parser_skip_to_pragma_eol
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|c_finish_omp_flush
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse the restricted form of the for statment allowed by OpenMP.    The real trick here is to determine the loop control variable early    so that we can push a new decl if necessary to make it private.  */
end_comment

begin_function
specifier|static
name|tree
name|c_parser_omp_for_loop
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|decl
decl_stmt|,
name|cond
decl_stmt|,
name|incr
decl_stmt|,
name|save_break
decl_stmt|,
name|save_cont
decl_stmt|,
name|body
decl_stmt|,
name|init
decl_stmt|;
name|location_t
name|loc
decl_stmt|;
if|if
condition|(
operator|!
name|c_parser_next_token_is_keyword
argument_list|(
name|parser
argument_list|,
name|RID_FOR
argument_list|)
condition|)
block|{
name|c_parser_error
argument_list|(
name|parser
argument_list|,
literal|"for statement expected"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|loc
operator|=
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
operator|->
name|location
expr_stmt|;
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|c_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_PAREN
argument_list|,
literal|"expected %<(%>"
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|/* Parse the initialization declaration or expression.  */
if|if
condition|(
name|c_parser_next_token_starts_declspecs
argument_list|(
name|parser
argument_list|)
condition|)
block|{
name|c_parser_declaration_or_fndef
argument_list|(
name|parser
argument_list|,
name|true
argument_list|,
name|true
argument_list|,
name|true
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|decl
operator|=
name|check_for_loop_decls
argument_list|()
expr_stmt|;
if|if
condition|(
name|decl
operator|==
name|NULL
condition|)
goto|goto
name|error_init
goto|;
name|init
operator|=
name|decl
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_NAME
argument_list|)
operator|&&
name|c_parser_peek_2nd_token
argument_list|(
name|parser
argument_list|)
operator|->
name|type
operator|==
name|CPP_EQ
condition|)
block|{
name|decl
operator|=
name|c_parser_postfix_expression
argument_list|(
name|parser
argument_list|)
operator|.
name|value
expr_stmt|;
name|c_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_EQ
argument_list|,
literal|"expected %<=%>"
argument_list|)
expr_stmt|;
name|init
operator|=
name|c_parser_expr_no_commas
argument_list|(
name|parser
argument_list|,
name|NULL
argument_list|)
operator|.
name|value
expr_stmt|;
name|init
operator|=
name|build_modify_expr
argument_list|(
name|decl
argument_list|,
name|NOP_EXPR
argument_list|,
name|init
argument_list|)
expr_stmt|;
name|init
operator|=
name|c_process_expr_stmt
argument_list|(
name|init
argument_list|)
expr_stmt|;
name|c_parser_skip_until_found
argument_list|(
name|parser
argument_list|,
name|CPP_SEMICOLON
argument_list|,
literal|"expected %<;%>"
argument_list|)
expr_stmt|;
block|}
else|else
goto|goto
name|error_init
goto|;
comment|/* Parse the loop condition.  */
name|cond
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|c_parser_next_token_is_not
argument_list|(
name|parser
argument_list|,
name|CPP_SEMICOLON
argument_list|)
condition|)
block|{
name|cond
operator|=
name|c_parser_expression_conv
argument_list|(
name|parser
argument_list|)
operator|.
name|value
expr_stmt|;
name|cond
operator|=
name|c_objc_common_truthvalue_conversion
argument_list|(
name|cond
argument_list|)
expr_stmt|;
if|if
condition|(
name|EXPR_P
argument_list|(
name|cond
argument_list|)
condition|)
name|SET_EXPR_LOCATION
argument_list|(
name|cond
argument_list|,
name|input_location
argument_list|)
expr_stmt|;
block|}
name|c_parser_skip_until_found
argument_list|(
name|parser
argument_list|,
name|CPP_SEMICOLON
argument_list|,
literal|"expected %<;%>"
argument_list|)
expr_stmt|;
comment|/* Parse the increment expression.  */
name|incr
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|c_parser_next_token_is_not
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|)
condition|)
name|incr
operator|=
name|c_process_expr_stmt
argument_list|(
name|c_parser_expression
argument_list|(
name|parser
argument_list|)
operator|.
name|value
argument_list|)
expr_stmt|;
name|c_parser_skip_until_found
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
literal|"expected %<)%>"
argument_list|)
expr_stmt|;
name|parse_body
label|:
name|save_break
operator|=
name|c_break_label
expr_stmt|;
name|c_break_label
operator|=
name|size_one_node
expr_stmt|;
name|save_cont
operator|=
name|c_cont_label
expr_stmt|;
name|c_cont_label
operator|=
name|NULL_TREE
expr_stmt|;
name|body
operator|=
name|push_stmt_list
argument_list|()
expr_stmt|;
name|add_stmt
argument_list|(
name|c_parser_c99_block_statement
argument_list|(
name|parser
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_cont_label
condition|)
name|add_stmt
argument_list|(
name|build1
argument_list|(
name|LABEL_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|c_cont_label
argument_list|)
argument_list|)
expr_stmt|;
name|body
operator|=
name|pop_stmt_list
argument_list|(
name|body
argument_list|)
expr_stmt|;
name|c_break_label
operator|=
name|save_break
expr_stmt|;
name|c_cont_label
operator|=
name|save_cont
expr_stmt|;
comment|/* Only bother calling c_finish_omp_for if we havn't already generated      an error from the initialization parsing.  */
if|if
condition|(
name|decl
operator|!=
name|NULL
operator|&&
name|decl
operator|!=
name|error_mark_node
operator|&&
name|init
operator|!=
name|error_mark_node
condition|)
return|return
name|c_finish_omp_for
argument_list|(
name|loc
argument_list|,
name|decl
argument_list|,
name|init
argument_list|,
name|cond
argument_list|,
name|incr
argument_list|,
name|body
argument_list|,
name|NULL
argument_list|)
return|;
return|return
name|NULL
return|;
name|error_init
label|:
name|c_parser_error
argument_list|(
name|parser
argument_list|,
literal|"expected iteration declaration or initialization"
argument_list|)
expr_stmt|;
name|c_parser_skip_until_found
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_PAREN
argument_list|,
literal|"expected %<)%>"
argument_list|)
expr_stmt|;
name|decl
operator|=
name|init
operator|=
name|cond
operator|=
name|incr
operator|=
name|NULL_TREE
expr_stmt|;
goto|goto
name|parse_body
goto|;
block|}
end_function

begin_comment
comment|/* OpenMP 2.5:    #pragma omp for for-clause[optseq] new-line      for-loop */
end_comment

begin_define
define|#
directive|define
name|OMP_FOR_CLAUSE_MASK
define|\
value|( (1u<< PRAGMA_OMP_CLAUSE_PRIVATE)		\ 	| (1u<< PRAGMA_OMP_CLAUSE_FIRSTPRIVATE)	\ 	| (1u<< PRAGMA_OMP_CLAUSE_LASTPRIVATE)		\ 	| (1u<< PRAGMA_OMP_CLAUSE_REDUCTION)		\ 	| (1u<< PRAGMA_OMP_CLAUSE_ORDERED)		\ 	| (1u<< PRAGMA_OMP_CLAUSE_SCHEDULE)		\ 	| (1u<< PRAGMA_OMP_CLAUSE_NOWAIT))
end_define

begin_function
specifier|static
name|tree
name|c_parser_omp_for
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|block
decl_stmt|,
name|clauses
decl_stmt|,
name|ret
decl_stmt|;
name|clauses
operator|=
name|c_parser_omp_all_clauses
argument_list|(
name|parser
argument_list|,
name|OMP_FOR_CLAUSE_MASK
argument_list|,
literal|"#pragma omp for"
argument_list|)
expr_stmt|;
name|block
operator|=
name|c_begin_compound_stmt
argument_list|(
name|true
argument_list|)
expr_stmt|;
name|ret
operator|=
name|c_parser_omp_for_loop
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|OMP_FOR_CLAUSES
argument_list|(
name|ret
argument_list|)
operator|=
name|clauses
expr_stmt|;
name|block
operator|=
name|c_end_compound_stmt
argument_list|(
name|block
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|add_stmt
argument_list|(
name|block
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* OpenMP 2.5:    # pragma omp master new-line      structured-block */
end_comment

begin_function
specifier|static
name|tree
name|c_parser_omp_master
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|)
block|{
name|c_parser_skip_to_pragma_eol
argument_list|(
name|parser
argument_list|)
expr_stmt|;
return|return
name|c_finish_omp_master
argument_list|(
name|c_parser_omp_structured_block
argument_list|(
name|parser
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* OpenMP 2.5:    # pragma omp ordered new-line      structured-block */
end_comment

begin_function
specifier|static
name|tree
name|c_parser_omp_ordered
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|)
block|{
name|c_parser_skip_to_pragma_eol
argument_list|(
name|parser
argument_list|)
expr_stmt|;
return|return
name|c_finish_omp_ordered
argument_list|(
name|c_parser_omp_structured_block
argument_list|(
name|parser
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* OpenMP 2.5:     section-scope:      { section-sequence }     section-sequence:      section-directive[opt] structured-block      section-sequence section-directive structured-block  */
end_comment

begin_function
specifier|static
name|tree
name|c_parser_omp_sections_scope
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|stmt
decl_stmt|,
name|substmt
decl_stmt|;
name|bool
name|error_suppress
init|=
name|false
decl_stmt|;
name|location_t
name|loc
decl_stmt|;
if|if
condition|(
operator|!
name|c_parser_require
argument_list|(
name|parser
argument_list|,
name|CPP_OPEN_BRACE
argument_list|,
literal|"expected %<{%>"
argument_list|)
condition|)
block|{
comment|/* Avoid skipping until the end of the block.  */
name|parser
operator|->
name|error
operator|=
name|false
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
name|stmt
operator|=
name|push_stmt_list
argument_list|()
expr_stmt|;
name|loc
operator|=
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
operator|->
name|location
expr_stmt|;
if|if
condition|(
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
operator|->
name|pragma_kind
operator|!=
name|PRAGMA_OMP_SECTION
condition|)
block|{
name|substmt
operator|=
name|push_stmt_list
argument_list|()
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|c_parser_statement
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
operator|->
name|pragma_kind
operator|==
name|PRAGMA_OMP_SECTION
condition|)
break|break;
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_BRACE
argument_list|)
condition|)
break|break;
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_EOF
argument_list|)
condition|)
break|break;
block|}
name|substmt
operator|=
name|pop_stmt_list
argument_list|(
name|substmt
argument_list|)
expr_stmt|;
name|substmt
operator|=
name|build1
argument_list|(
name|OMP_SECTION
argument_list|,
name|void_type_node
argument_list|,
name|substmt
argument_list|)
expr_stmt|;
name|SET_EXPR_LOCATION
argument_list|(
name|substmt
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|add_stmt
argument_list|(
name|substmt
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_BRACE
argument_list|)
condition|)
break|break;
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_EOF
argument_list|)
condition|)
break|break;
name|loc
operator|=
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
operator|->
name|location
expr_stmt|;
if|if
condition|(
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
operator|->
name|pragma_kind
operator|==
name|PRAGMA_OMP_SECTION
condition|)
block|{
name|c_parser_consume_pragma
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|c_parser_skip_to_pragma_eol
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|error_suppress
operator|=
name|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|error_suppress
condition|)
block|{
name|error
argument_list|(
literal|"expected %<#pragma omp section%> or %<}%>"
argument_list|)
expr_stmt|;
name|error_suppress
operator|=
name|true
expr_stmt|;
block|}
name|substmt
operator|=
name|c_parser_omp_structured_block
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|substmt
operator|=
name|build1
argument_list|(
name|OMP_SECTION
argument_list|,
name|void_type_node
argument_list|,
name|substmt
argument_list|)
expr_stmt|;
name|SET_EXPR_LOCATION
argument_list|(
name|substmt
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|add_stmt
argument_list|(
name|substmt
argument_list|)
expr_stmt|;
block|}
name|c_parser_skip_until_found
argument_list|(
name|parser
argument_list|,
name|CPP_CLOSE_BRACE
argument_list|,
literal|"expected %<#pragma omp section%> or %<}%>"
argument_list|)
expr_stmt|;
name|substmt
operator|=
name|pop_stmt_list
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|make_node
argument_list|(
name|OMP_SECTIONS
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|stmt
argument_list|)
operator|=
name|void_type_node
expr_stmt|;
name|OMP_SECTIONS_BODY
argument_list|(
name|stmt
argument_list|)
operator|=
name|substmt
expr_stmt|;
return|return
name|add_stmt
argument_list|(
name|stmt
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* OpenMP 2.5:    # pragma omp sections sections-clause[optseq] newline      sections-scope */
end_comment

begin_define
define|#
directive|define
name|OMP_SECTIONS_CLAUSE_MASK
define|\
value|( (1u<< PRAGMA_OMP_CLAUSE_PRIVATE)		\ 	| (1u<< PRAGMA_OMP_CLAUSE_FIRSTPRIVATE)	\ 	| (1u<< PRAGMA_OMP_CLAUSE_LASTPRIVATE)		\ 	| (1u<< PRAGMA_OMP_CLAUSE_REDUCTION)		\ 	| (1u<< PRAGMA_OMP_CLAUSE_NOWAIT))
end_define

begin_function
specifier|static
name|tree
name|c_parser_omp_sections
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|block
decl_stmt|,
name|clauses
decl_stmt|,
name|ret
decl_stmt|;
name|clauses
operator|=
name|c_parser_omp_all_clauses
argument_list|(
name|parser
argument_list|,
name|OMP_SECTIONS_CLAUSE_MASK
argument_list|,
literal|"#pragma omp sections"
argument_list|)
expr_stmt|;
name|block
operator|=
name|c_begin_compound_stmt
argument_list|(
name|true
argument_list|)
expr_stmt|;
name|ret
operator|=
name|c_parser_omp_sections_scope
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|OMP_SECTIONS_CLAUSES
argument_list|(
name|ret
argument_list|)
operator|=
name|clauses
expr_stmt|;
name|block
operator|=
name|c_end_compound_stmt
argument_list|(
name|block
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|add_stmt
argument_list|(
name|block
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* OpenMP 2.5:    # pragma parallel parallel-clause new-line    # pragma parallel for parallel-for-clause new-line    # pragma parallel sections parallel-sections-clause new-line */
end_comment

begin_define
define|#
directive|define
name|OMP_PARALLEL_CLAUSE_MASK
define|\
value|( (1u<< PRAGMA_OMP_CLAUSE_IF)			\ 	| (1u<< PRAGMA_OMP_CLAUSE_PRIVATE)		\ 	| (1u<< PRAGMA_OMP_CLAUSE_FIRSTPRIVATE)	\ 	| (1u<< PRAGMA_OMP_CLAUSE_DEFAULT)		\ 	| (1u<< PRAGMA_OMP_CLAUSE_SHARED)		\ 	| (1u<< PRAGMA_OMP_CLAUSE_COPYIN)		\ 	| (1u<< PRAGMA_OMP_CLAUSE_REDUCTION)		\ 	| (1u<< PRAGMA_OMP_CLAUSE_NUM_THREADS))
end_define

begin_function
specifier|static
name|tree
name|c_parser_omp_parallel
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|)
block|{
name|enum
name|pragma_kind
name|p_kind
init|=
name|PRAGMA_OMP_PARALLEL
decl_stmt|;
specifier|const
name|char
modifier|*
name|p_name
init|=
literal|"#pragma omp parallel"
decl_stmt|;
name|tree
name|stmt
decl_stmt|,
name|clauses
decl_stmt|,
name|par_clause
decl_stmt|,
name|ws_clause
decl_stmt|,
name|block
decl_stmt|;
name|unsigned
name|int
name|mask
init|=
name|OMP_PARALLEL_CLAUSE_MASK
decl_stmt|;
if|if
condition|(
name|c_parser_next_token_is_keyword
argument_list|(
name|parser
argument_list|,
name|RID_FOR
argument_list|)
condition|)
block|{
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|p_kind
operator|=
name|PRAGMA_OMP_PARALLEL_FOR
expr_stmt|;
name|p_name
operator|=
literal|"#pragma omp parallel for"
expr_stmt|;
name|mask
operator||=
name|OMP_FOR_CLAUSE_MASK
expr_stmt|;
name|mask
operator|&=
operator|~
operator|(
literal|1u
operator|<<
name|PRAGMA_OMP_CLAUSE_NOWAIT
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c_parser_next_token_is
argument_list|(
name|parser
argument_list|,
name|CPP_NAME
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|p
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
operator|->
name|value
argument_list|)
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"sections"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|c_parser_consume_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|p_kind
operator|=
name|PRAGMA_OMP_PARALLEL_SECTIONS
expr_stmt|;
name|p_name
operator|=
literal|"#pragma omp parallel sections"
expr_stmt|;
name|mask
operator||=
name|OMP_SECTIONS_CLAUSE_MASK
expr_stmt|;
name|mask
operator|&=
operator|~
operator|(
literal|1u
operator|<<
name|PRAGMA_OMP_CLAUSE_NOWAIT
operator|)
expr_stmt|;
block|}
block|}
name|clauses
operator|=
name|c_parser_omp_all_clauses
argument_list|(
name|parser
argument_list|,
name|mask
argument_list|,
name|p_name
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|p_kind
condition|)
block|{
case|case
name|PRAGMA_OMP_PARALLEL
case|:
name|block
operator|=
name|c_begin_omp_parallel
argument_list|()
expr_stmt|;
name|c_parser_statement
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|c_finish_omp_parallel
argument_list|(
name|clauses
argument_list|,
name|block
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRAGMA_OMP_PARALLEL_FOR
case|:
name|block
operator|=
name|c_begin_omp_parallel
argument_list|()
expr_stmt|;
name|c_split_parallel_clauses
argument_list|(
name|clauses
argument_list|,
operator|&
name|par_clause
argument_list|,
operator|&
name|ws_clause
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|c_parser_omp_for_loop
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|stmt
condition|)
name|OMP_FOR_CLAUSES
argument_list|(
name|stmt
argument_list|)
operator|=
name|ws_clause
expr_stmt|;
name|stmt
operator|=
name|c_finish_omp_parallel
argument_list|(
name|par_clause
argument_list|,
name|block
argument_list|)
expr_stmt|;
name|OMP_PARALLEL_COMBINED
argument_list|(
name|stmt
argument_list|)
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|PRAGMA_OMP_PARALLEL_SECTIONS
case|:
name|block
operator|=
name|c_begin_omp_parallel
argument_list|()
expr_stmt|;
name|c_split_parallel_clauses
argument_list|(
name|clauses
argument_list|,
operator|&
name|par_clause
argument_list|,
operator|&
name|ws_clause
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|c_parser_omp_sections_scope
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|stmt
condition|)
name|OMP_SECTIONS_CLAUSES
argument_list|(
name|stmt
argument_list|)
operator|=
name|ws_clause
expr_stmt|;
name|stmt
operator|=
name|c_finish_omp_parallel
argument_list|(
name|par_clause
argument_list|,
name|block
argument_list|)
expr_stmt|;
name|OMP_PARALLEL_COMBINED
argument_list|(
name|stmt
argument_list|)
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
return|return
name|stmt
return|;
block|}
end_function

begin_comment
comment|/* OpenMP 2.5:    # pragma omp single single-clause[optseq] new-line      structured-block */
end_comment

begin_define
define|#
directive|define
name|OMP_SINGLE_CLAUSE_MASK
define|\
value|( (1u<< PRAGMA_OMP_CLAUSE_PRIVATE)		\ 	| (1u<< PRAGMA_OMP_CLAUSE_FIRSTPRIVATE)	\ 	| (1u<< PRAGMA_OMP_CLAUSE_COPYPRIVATE)		\ 	| (1u<< PRAGMA_OMP_CLAUSE_NOWAIT))
end_define

begin_function
specifier|static
name|tree
name|c_parser_omp_single
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|stmt
init|=
name|make_node
argument_list|(
name|OMP_SINGLE
argument_list|)
decl_stmt|;
name|TREE_TYPE
argument_list|(
name|stmt
argument_list|)
operator|=
name|void_type_node
expr_stmt|;
name|OMP_SINGLE_CLAUSES
argument_list|(
name|stmt
argument_list|)
operator|=
name|c_parser_omp_all_clauses
argument_list|(
name|parser
argument_list|,
name|OMP_SINGLE_CLAUSE_MASK
argument_list|,
literal|"#pragma omp single"
argument_list|)
expr_stmt|;
name|OMP_SINGLE_BODY
argument_list|(
name|stmt
argument_list|)
operator|=
name|c_parser_omp_structured_block
argument_list|(
name|parser
argument_list|)
expr_stmt|;
return|return
name|add_stmt
argument_list|(
name|stmt
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Main entry point to parsing most OpenMP pragmas.  */
end_comment

begin_function
specifier|static
name|void
name|c_parser_omp_construct
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|)
block|{
name|enum
name|pragma_kind
name|p_kind
decl_stmt|;
name|location_t
name|loc
decl_stmt|;
name|tree
name|stmt
decl_stmt|;
name|loc
operator|=
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
operator|->
name|location
expr_stmt|;
name|p_kind
operator|=
name|c_parser_peek_token
argument_list|(
name|parser
argument_list|)
operator|->
name|pragma_kind
expr_stmt|;
name|c_parser_consume_pragma
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* For all constructs below except #pragma omp atomic      MUST_NOT_THROW catch handlers are needed when exceptions      are enabled.  */
if|if
condition|(
name|p_kind
operator|!=
name|PRAGMA_OMP_ATOMIC
condition|)
name|c_maybe_initialize_eh
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|p_kind
condition|)
block|{
case|case
name|PRAGMA_OMP_ATOMIC
case|:
name|c_parser_omp_atomic
argument_list|(
name|parser
argument_list|)
expr_stmt|;
return|return;
case|case
name|PRAGMA_OMP_CRITICAL
case|:
name|stmt
operator|=
name|c_parser_omp_critical
argument_list|(
name|parser
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRAGMA_OMP_FOR
case|:
name|stmt
operator|=
name|c_parser_omp_for
argument_list|(
name|parser
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRAGMA_OMP_MASTER
case|:
name|stmt
operator|=
name|c_parser_omp_master
argument_list|(
name|parser
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRAGMA_OMP_ORDERED
case|:
name|stmt
operator|=
name|c_parser_omp_ordered
argument_list|(
name|parser
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRAGMA_OMP_PARALLEL
case|:
name|stmt
operator|=
name|c_parser_omp_parallel
argument_list|(
name|parser
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRAGMA_OMP_SECTIONS
case|:
name|stmt
operator|=
name|c_parser_omp_sections
argument_list|(
name|parser
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRAGMA_OMP_SINGLE
case|:
name|stmt
operator|=
name|c_parser_omp_single
argument_list|(
name|parser
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|stmt
condition|)
name|SET_EXPR_LOCATION
argument_list|(
name|stmt
argument_list|,
name|loc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* OpenMP 2.5:    # pragma omp threadprivate (variable-list) */
end_comment

begin_function
specifier|static
name|void
name|c_parser_omp_threadprivate
parameter_list|(
name|c_parser
modifier|*
name|parser
parameter_list|)
block|{
name|tree
name|vars
decl_stmt|,
name|t
decl_stmt|;
name|c_parser_consume_pragma
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|vars
operator|=
name|c_parser_omp_var_list_parens
argument_list|(
name|parser
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|targetm
operator|.
name|have_tls
condition|)
name|sorry
argument_list|(
literal|"threadprivate variables not supported in this target"
argument_list|)
expr_stmt|;
comment|/* Mark every variable in VARS to be assigned thread local storage.  */
for|for
control|(
name|t
operator|=
name|vars
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|tree
name|v
init|=
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
decl_stmt|;
comment|/* If V had already been marked threadprivate, it doesn't matter 	 whether it had been used prior to this point.  */
if|if
condition|(
name|TREE_USED
argument_list|(
name|v
argument_list|)
operator|&&
operator|!
name|C_DECL_THREADPRIVATE_P
argument_list|(
name|v
argument_list|)
condition|)
name|error
argument_list|(
literal|"%qE declared %<threadprivate%> after first use"
argument_list|,
name|v
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|TREE_STATIC
argument_list|(
name|v
argument_list|)
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|v
argument_list|)
condition|)
name|error
argument_list|(
literal|"automatic variable %qE cannot be %<threadprivate%>"
argument_list|,
name|v
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|v
argument_list|)
argument_list|)
condition|)
name|error
argument_list|(
literal|"%<threadprivate%> %qE has incomplete type"
argument_list|,
name|v
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|DECL_THREAD_LOCAL_P
argument_list|(
name|v
argument_list|)
condition|)
block|{
name|DECL_TLS_MODEL
argument_list|(
name|v
argument_list|)
operator|=
name|decl_default_tls_model
argument_list|(
name|v
argument_list|)
expr_stmt|;
comment|/* If rtl has been already set for this var, call 		 make_decl_rtl once again, so that encode_section_info 		 has a chance to look at the new decl flags.  */
if|if
condition|(
name|DECL_RTL_SET_P
argument_list|(
name|v
argument_list|)
condition|)
name|make_decl_rtl
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
name|C_DECL_THREADPRIVATE_P
argument_list|(
name|v
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|c_parser_skip_to_pragma_eol
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Parse a single source file.  */
end_comment

begin_function
name|void
name|c_parse_file
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Use local storage to begin.  If the first token is a pragma, parse it.      If it is #pragma GCC pch_preprocess, then this will load a PCH file      which will cause garbage collection.  */
name|c_parser
name|tparser
decl_stmt|;
name|memset
argument_list|(
operator|&
name|tparser
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|tparser
argument_list|)
expr_stmt|;
name|the_parser
operator|=
operator|&
name|tparser
expr_stmt|;
if|if
condition|(
name|c_parser_peek_token
argument_list|(
operator|&
name|tparser
argument_list|)
operator|->
name|pragma_kind
operator|==
name|PRAGMA_GCC_PCH_PREPROCESS
condition|)
name|c_parser_pragma_pch_preprocess
argument_list|(
operator|&
name|tparser
argument_list|)
expr_stmt|;
name|the_parser
operator|=
name|GGC_NEW
argument_list|(
name|c_parser
argument_list|)
expr_stmt|;
operator|*
name|the_parser
operator|=
name|tparser
expr_stmt|;
name|c_parser_translation_unit
argument_list|(
name|the_parser
argument_list|)
expr_stmt|;
name|the_parser
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_include
include|#
directive|include
file|"gt-c-parser.h"
end_include

end_unit

