begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Top level of GCC compilers (cc1, cc1plus, etc.)    Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* This is the top level of cc1/c++.    It parses command args, opens files, invokes the various passes    in the proper order, and counts the time used by each.    Error messages and low-level interface to malloc also handled here.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_undef
undef|#
directive|undef
name|FLOAT
end_undef

begin_comment
comment|/* This is for hpux. They should change hpux.  */
end_comment

begin_undef
undef|#
directive|undef
name|FFS
end_undef

begin_comment
comment|/* Some systems define this in param.h.  */
end_comment

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_RESOURCE_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_TIMES_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/times.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"line-map.h"
end_include

begin_include
include|#
directive|include
file|"input.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"insn-attr.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"insn-flags.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"intl.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"graph.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_include
include|#
directive|include
file|"params.h"
end_include

begin_include
include|#
directive|include
file|"reload.h"
end_include

begin_include
include|#
directive|include
file|"dwarf2asm.h"
end_include

begin_include
include|#
directive|include
file|"integrate.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"debug.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_include
include|#
directive|include
file|"cfglayout.h"
end_include

begin_include
include|#
directive|include
file|"cfgloop.h"
end_include

begin_include
include|#
directive|include
file|"hosthooks.h"
end_include

begin_include
include|#
directive|include
file|"cgraph.h"
end_include

begin_include
include|#
directive|include
file|"opts.h"
end_include

begin_include
include|#
directive|include
file|"coverage.h"
end_include

begin_include
include|#
directive|include
file|"value-prof.h"
end_include

begin_include
include|#
directive|include
file|"tree-inline.h"
end_include

begin_include
include|#
directive|include
file|"tree-flow.h"
end_include

begin_include
include|#
directive|include
file|"tree-pass.h"
end_include

begin_include
include|#
directive|include
file|"tree-dump.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DWARF2_UNWIND_INFO
argument_list|)
operator|||
name|defined
argument_list|(
name|DWARF2_DEBUGGING_INFO
argument_list|)
end_if

begin_include
include|#
directive|include
file|"dwarf2out.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DBX_DEBUGGING_INFO
argument_list|)
operator|||
name|defined
argument_list|(
name|XCOFF_DEBUGGING_INFO
argument_list|)
end_if

begin_include
include|#
directive|include
file|"dbxout.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SDB_DEBUGGING_INFO
end_ifdef

begin_include
include|#
directive|include
file|"sdbout.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|XCOFF_DEBUGGING_INFO
end_ifdef

begin_include
include|#
directive|include
file|"xcoffout.h"
end_include

begin_comment
comment|/* Needed for external data 				   declarations for e.g. AIX 4.x.  */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Global variables used to communicate with passes.  */
end_comment

begin_decl_stmt
name|int
name|dump_flags
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|in_gimple_form
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is called from various places for FUNCTION_DECL, VAR_DECL,    and TYPE_DECL nodes.     This does nothing for local (non-static) variables, unless the    variable is a register variable with DECL_ASSEMBLER_NAME set.  In    that case, or if the variable is not an automatic, it sets up the    RTL and outputs any assembler code (label definition, storage    allocation and initialization).     DECL is the declaration.  TOP_LEVEL is nonzero    if this declaration is not within a function.  */
end_comment

begin_function
name|void
name|rest_of_decl_compilation
parameter_list|(
name|tree
name|decl
parameter_list|,
name|int
name|top_level
parameter_list|,
name|int
name|at_end
parameter_list|)
block|{
comment|/* We deferred calling assemble_alias so that we could collect      other attributes such as visibility.  Emit the alias now.  */
block|{
name|tree
name|alias
decl_stmt|;
name|alias
operator|=
name|lookup_attribute
argument_list|(
literal|"alias"
argument_list|,
name|DECL_ATTRIBUTES
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|alias
condition|)
block|{
name|alias
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_VALUE
argument_list|(
name|alias
argument_list|)
argument_list|)
expr_stmt|;
name|alias
operator|=
name|get_identifier
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|alias
argument_list|)
argument_list|)
expr_stmt|;
name|assemble_alias
argument_list|(
name|decl
argument_list|,
name|alias
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Can't defer this, because it needs to happen before any      later function definitions are processed.  */
if|if
condition|(
name|DECL_ASSEMBLER_NAME_SET_P
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_REGISTER
argument_list|(
name|decl
argument_list|)
condition|)
name|make_decl_rtl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* Forward declarations for nested functions are not "external",      but we need to treat them as if they were.  */
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|||
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|timevar_push
argument_list|(
name|TV_VARCONST
argument_list|)
expr_stmt|;
comment|/* Don't output anything when a tentative file-scope definition 	 is seen.  But at end of compilation, do output code for them.  	 We do output all variables when unit-at-a-time is active and rely on 	 callgraph code to defer them except for forward declarations 	 (see gcc.c-torture/compile/920624-1.c) */
if|if
condition|(
operator|(
name|at_end
operator|||
operator|!
name|DECL_DEFER_OUTPUT
argument_list|(
name|decl
argument_list|)
operator|||
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|)
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
name|cgraph_varpool_finalize_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
else|else
name|assemble_variable
argument_list|(
name|decl
argument_list|,
name|top_level
argument_list|,
name|at_end
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ASM_FINISH_DECLARE_OBJECT
if|if
condition|(
name|decl
operator|==
name|last_assemble_variable_decl
condition|)
block|{
name|ASM_FINISH_DECLARE_OBJECT
argument_list|(
name|asm_out_file
argument_list|,
name|decl
argument_list|,
name|top_level
argument_list|,
name|at_end
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|timevar_pop
argument_list|(
name|TV_VARCONST
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
comment|/* Like in rest_of_type_compilation, avoid confusing the debug 	      information machinery when there are errors.  */
operator|&&
operator|!
operator|(
name|sorrycount
operator|||
name|errorcount
operator|)
condition|)
block|{
name|timevar_push
argument_list|(
name|TV_SYMOUT
argument_list|)
expr_stmt|;
name|debug_hooks
operator|->
name|type_decl
argument_list|(
name|decl
argument_list|,
operator|!
name|top_level
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_SYMOUT
argument_list|)
expr_stmt|;
block|}
comment|/* Let cgraph know about the existence of variables.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
name|cgraph_varpool_node
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called after finishing a record, union or enumeral type.  */
end_comment

begin_function
name|void
name|rest_of_type_compilation
parameter_list|(
name|tree
name|type
parameter_list|,
name|int
name|toplev
parameter_list|)
block|{
comment|/* Avoid confusing the debug information machinery when there are      errors.  */
if|if
condition|(
name|errorcount
operator|!=
literal|0
operator|||
name|sorrycount
operator|!=
literal|0
condition|)
return|return;
name|timevar_push
argument_list|(
name|TV_SYMOUT
argument_list|)
expr_stmt|;
name|debug_hooks
operator|->
name|type_decl
argument_list|(
name|TYPE_STUB_DECL
argument_list|(
name|type
argument_list|)
argument_list|,
operator|!
name|toplev
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_SYMOUT
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|finish_optimization_passes
parameter_list|(
name|void
parameter_list|)
block|{
name|enum
name|tree_dump_index
name|i
decl_stmt|;
name|struct
name|dump_file_info
modifier|*
name|dfi
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|timevar_push
argument_list|(
name|TV_DUMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|profile_arc_flag
operator|||
name|flag_test_coverage
operator|||
name|flag_branch_probabilities
condition|)
block|{
name|dump_file
operator|=
name|dump_begin
argument_list|(
name|pass_profile
operator|.
name|static_pass_number
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|end_branch_prob
argument_list|()
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
name|dump_end
argument_list|(
name|pass_profile
operator|.
name|static_pass_number
argument_list|,
name|dump_file
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|optimize
operator|>
literal|0
condition|)
block|{
name|dump_file
operator|=
name|dump_begin
argument_list|(
name|pass_combine
operator|.
name|static_pass_number
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
block|{
name|dump_combine_total_stats
argument_list|(
name|dump_file
argument_list|)
expr_stmt|;
name|dump_end
argument_list|(
name|pass_combine
operator|.
name|static_pass_number
argument_list|,
name|dump_file
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Do whatever is necessary to finish printing the graphs.  */
if|if
condition|(
name|graph_dump_format
operator|!=
name|no_graph
condition|)
for|for
control|(
name|i
operator|=
name|TDI_end
init|;
operator|(
name|dfi
operator|=
name|get_dump_file_info
argument_list|(
name|i
argument_list|)
operator|)
operator|!=
name|NULL
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|dump_initialized_p
argument_list|(
name|i
argument_list|)
operator|&&
operator|(
name|dfi
operator|->
name|flags
operator|&
name|TDF_GRAPH
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|name
operator|=
name|get_dump_file_name
argument_list|(
name|i
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|finish_graph_dump_file
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
name|timevar_pop
argument_list|(
name|TV_DUMP
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bool
name|gate_rest_of_compilation
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Early return if there were errors.  We can run afoul of our      consistency checks, and there's not really much point in fixing them.  */
return|return
operator|!
operator|(
name|rtl_dump_and_exit
operator|||
name|flag_syntax_only
operator|||
name|errorcount
operator|||
name|sorrycount
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|tree_opt_pass
name|pass_rest_of_compilation
init|=
block|{
name|NULL
block|,
comment|/* name */
name|gate_rest_of_compilation
block|,
comment|/* gate */
name|NULL
block|,
comment|/* execute */
name|NULL
block|,
comment|/* sub */
name|NULL
block|,
comment|/* next */
literal|0
block|,
comment|/* static_pass_number */
name|TV_REST_OF_COMPILATION
block|,
comment|/* tv_id */
name|PROP_rtl
block|,
comment|/* properties_required */
literal|0
block|,
comment|/* properties_provided */
literal|0
block|,
comment|/* properties_destroyed */
literal|0
block|,
comment|/* todo_flags_start */
name|TODO_ggc_collect
block|,
comment|/* todo_flags_finish */
literal|0
comment|/* letter */
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|bool
name|gate_postreload
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|reload_completed
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|tree_opt_pass
name|pass_postreload
init|=
block|{
name|NULL
block|,
comment|/* name */
name|gate_postreload
block|,
comment|/* gate */
name|NULL
block|,
comment|/* execute */
name|NULL
block|,
comment|/* sub */
name|NULL
block|,
comment|/* next */
literal|0
block|,
comment|/* static_pass_number */
literal|0
block|,
comment|/* tv_id */
name|PROP_rtl
block|,
comment|/* properties_required */
literal|0
block|,
comment|/* properties_provided */
literal|0
block|,
comment|/* properties_destroyed */
literal|0
block|,
comment|/* todo_flags_start */
name|TODO_ggc_collect
block|,
comment|/* todo_flags_finish */
literal|0
comment|/* letter */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The root of the compilation pass tree, once constructed.  */
end_comment

begin_decl_stmt
name|struct
name|tree_opt_pass
modifier|*
name|all_passes
decl_stmt|,
modifier|*
name|all_ipa_passes
decl_stmt|,
modifier|*
name|all_lowering_passes
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Iterate over the pass tree allocating dump file numbers.  We want    to do this depth first, and independent of whether the pass is    enabled or not.  */
end_comment

begin_function
specifier|static
name|void
name|register_one_dump_file
parameter_list|(
name|struct
name|tree_opt_pass
modifier|*
name|pass
parameter_list|,
name|bool
name|ipa
parameter_list|,
name|int
name|properties
parameter_list|)
block|{
name|char
modifier|*
name|dot_name
decl_stmt|,
modifier|*
name|flag_name
decl_stmt|,
modifier|*
name|glob_name
decl_stmt|;
specifier|const
name|char
modifier|*
name|prefix
decl_stmt|;
name|char
name|num
index|[
literal|10
index|]
decl_stmt|;
name|int
name|flags
decl_stmt|;
comment|/* See below in next_pass_1.  */
name|num
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|pass
operator|->
name|static_pass_number
operator|!=
operator|-
literal|1
condition|)
name|sprintf
argument_list|(
name|num
argument_list|,
literal|"%d"
argument_list|,
operator|(
operator|(
name|int
operator|)
name|pass
operator|->
name|static_pass_number
operator|<
literal|0
condition|?
literal|1
else|:
name|pass
operator|->
name|static_pass_number
operator|)
argument_list|)
expr_stmt|;
name|dot_name
operator|=
name|concat
argument_list|(
literal|"."
argument_list|,
name|pass
operator|->
name|name
argument_list|,
name|num
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ipa
condition|)
name|prefix
operator|=
literal|"ipa-"
operator|,
name|flags
operator|=
name|TDF_IPA
expr_stmt|;
elseif|else
if|if
condition|(
name|properties
operator|&
name|PROP_trees
condition|)
name|prefix
operator|=
literal|"tree-"
operator|,
name|flags
operator|=
name|TDF_TREE
expr_stmt|;
else|else
name|prefix
operator|=
literal|"rtl-"
operator|,
name|flags
operator|=
name|TDF_RTL
expr_stmt|;
name|flag_name
operator|=
name|concat
argument_list|(
name|prefix
argument_list|,
name|pass
operator|->
name|name
argument_list|,
name|num
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|glob_name
operator|=
name|concat
argument_list|(
name|prefix
argument_list|,
name|pass
operator|->
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|pass
operator|->
name|static_pass_number
operator|=
name|dump_register
argument_list|(
name|dot_name
argument_list|,
name|flag_name
argument_list|,
name|glob_name
argument_list|,
name|flags
argument_list|,
name|pass
operator|->
name|letter
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Recursive worker function for register_dump_files.  */
end_comment

begin_function
specifier|static
name|int
name|register_dump_files_1
parameter_list|(
name|struct
name|tree_opt_pass
modifier|*
name|pass
parameter_list|,
name|bool
name|ipa
parameter_list|,
name|int
name|properties
parameter_list|)
block|{
do|do
block|{
name|int
name|new_properties
init|=
operator|(
name|properties
operator||
name|pass
operator|->
name|properties_provided
operator|)
operator|&
operator|~
name|pass
operator|->
name|properties_destroyed
decl_stmt|;
if|if
condition|(
name|pass
operator|->
name|name
condition|)
name|register_one_dump_file
argument_list|(
name|pass
argument_list|,
name|ipa
argument_list|,
name|new_properties
argument_list|)
expr_stmt|;
if|if
condition|(
name|pass
operator|->
name|sub
condition|)
name|new_properties
operator|=
name|register_dump_files_1
argument_list|(
name|pass
operator|->
name|sub
argument_list|,
name|false
argument_list|,
name|new_properties
argument_list|)
expr_stmt|;
comment|/* If we have a gate, combine the properties that we could have with          and without the pass being examined.  */
if|if
condition|(
name|pass
operator|->
name|gate
condition|)
name|properties
operator|&=
name|new_properties
expr_stmt|;
else|else
name|properties
operator|=
name|new_properties
expr_stmt|;
name|pass
operator|=
name|pass
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|pass
condition|)
do|;
return|return
name|properties
return|;
block|}
end_function

begin_comment
comment|/* Register the dump files for the pipeline starting at PASS.  IPA is    true if the pass is inter-procedural, and PROPERTIES reflects the    properties that are guaranteed to be available at the beginning of    the pipeline.  */
end_comment

begin_function
specifier|static
name|void
name|register_dump_files
parameter_list|(
name|struct
name|tree_opt_pass
modifier|*
name|pass
parameter_list|,
name|bool
name|ipa
parameter_list|,
name|int
name|properties
parameter_list|)
block|{
name|pass
operator|->
name|properties_required
operator||=
name|properties
expr_stmt|;
name|pass
operator|->
name|todo_flags_start
operator||=
name|TODO_set_props
expr_stmt|;
name|register_dump_files_1
argument_list|(
name|pass
argument_list|,
name|ipa
argument_list|,
name|properties
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add a pass to the pass list. Duplicate the pass if it's already    in the list.  */
end_comment

begin_function
specifier|static
name|struct
name|tree_opt_pass
modifier|*
modifier|*
name|next_pass_1
parameter_list|(
name|struct
name|tree_opt_pass
modifier|*
modifier|*
name|list
parameter_list|,
name|struct
name|tree_opt_pass
modifier|*
name|pass
parameter_list|)
block|{
comment|/* A nonzero static_pass_number indicates that the      pass is already in the list.  */
if|if
condition|(
name|pass
operator|->
name|static_pass_number
condition|)
block|{
name|struct
name|tree_opt_pass
modifier|*
name|new
decl_stmt|;
name|new
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|new
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|new
argument_list|,
name|pass
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|new
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Indicate to register_dump_files that this pass has duplicates,          and so it should rename the dump file.  The first instance will          be -1, and be number of duplicates = -static_pass_number - 1.          Subsequent instances will be> 0 and just the duplicate number.  */
if|if
condition|(
name|pass
operator|->
name|name
condition|)
block|{
name|pass
operator|->
name|static_pass_number
operator|-=
literal|1
expr_stmt|;
name|new
operator|->
name|static_pass_number
operator|=
operator|-
name|pass
operator|->
name|static_pass_number
expr_stmt|;
block|}
operator|*
name|list
operator|=
name|new
expr_stmt|;
block|}
else|else
block|{
name|pass
operator|->
name|static_pass_number
operator|=
operator|-
literal|1
expr_stmt|;
operator|*
name|list
operator|=
name|pass
expr_stmt|;
block|}
return|return
operator|&
operator|(
operator|*
name|list
operator|)
operator|->
name|next
return|;
block|}
end_function

begin_comment
comment|/* Construct the pass tree.  The sequencing of passes is driven by    the cgraph routines:     cgraph_finalize_compilation_unit ()        for each node N in the cgraph 	   cgraph_analyze_function (N) 	       cgraph_lower_function (N) -> all_lowering_passes     If we are optimizing, cgraph_optimize is then invoked:     cgraph_optimize ()        ipa_passes () 			-> all_ipa_passes        cgraph_expand_all_functions ()            for each node N in the cgraph 	       cgraph_expand_function (N) 	           cgraph_lower_function (N)	-> Now a NOP. 		   lang_hooks.callgraph.expand_function (DECL (N)) 		   	tree_rest_of_compilation (DECL (N))  -> all_passes */
end_comment

begin_function
name|void
name|init_optimization_passes
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|tree_opt_pass
modifier|*
modifier|*
name|p
decl_stmt|;
define|#
directive|define
name|NEXT_PASS
parameter_list|(
name|PASS
parameter_list|)
value|(p = next_pass_1 (p,&PASS))
comment|/* Interprocedural optimization passes.  */
name|p
operator|=
operator|&
name|all_ipa_passes
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_early_ipa_inline
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_early_local_passes
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_ipa_cp
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_ipa_inline
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_ipa_reference
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_ipa_pure_const
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_ipa_type_escape
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_ipa_pta
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|NULL
expr_stmt|;
comment|/* All passes needed to lower the function into shape optimizers can      operate on.  */
name|p
operator|=
operator|&
name|all_lowering_passes
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_remove_useless_stmts
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_mudflap_1
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_lower_omp
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_lower_cf
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_lower_eh
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_build_cfg
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_lower_complex_O0
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_lower_vector
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_warn_function_return
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_early_tree_profile
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|NULL
expr_stmt|;
name|p
operator|=
operator|&
name|pass_early_local_passes
operator|.
name|sub
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_tree_profile
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_cleanup_cfg
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_rebuild_cgraph_edges
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|NULL
expr_stmt|;
name|p
operator|=
operator|&
name|all_passes
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_fixup_cfg
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_init_datastructures
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_expand_omp
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_all_optimizations
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_warn_function_noreturn
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_mudflap_2
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_free_datastructures
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_free_cfg_annotations
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_expand
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_rest_of_compilation
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_clean_state
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|NULL
expr_stmt|;
name|p
operator|=
operator|&
name|pass_all_optimizations
operator|.
name|sub
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_referenced_vars
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_reset_cc_flags
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_create_structure_vars
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_build_ssa
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_may_alias
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_return_slot
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_rename_ssa_copies
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_early_warn_uninitialized
argument_list|)
expr_stmt|;
comment|/* Initial scalar cleanups.  */
name|NEXT_PASS
argument_list|(
name|pass_ccp
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_fre
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_dce
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_forwprop
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_copy_prop
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_merge_phi
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_vrp
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_dce
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_dominator
argument_list|)
expr_stmt|;
comment|/* The only const/copy propagation opportunities left after      DOM should be due to degenerate PHI nodes.  So rather than      run the full propagators, run a specialized pass which      only examines PHIs to discover const/copy propagation      opportunities.  */
name|NEXT_PASS
argument_list|(
name|pass_phi_only_cprop
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_phiopt
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_may_alias
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_tail_recursion
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_profile
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_ch
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_stdarg
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_lower_complex
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_sra
argument_list|)
expr_stmt|;
comment|/* FIXME: SRA may generate arbitrary gimple code, exposing new      aliased and call-clobbered variables.  As mentioned below,      pass_may_alias should be a TODO item.  */
name|NEXT_PASS
argument_list|(
name|pass_may_alias
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_rename_ssa_copies
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_dominator
argument_list|)
expr_stmt|;
comment|/* The only const/copy propagation opportunities left after      DOM should be due to degenerate PHI nodes.  So rather than      run the full propagators, run a specialized pass which      only examines PHIs to discover const/copy propagation      opportunities.  */
name|NEXT_PASS
argument_list|(
name|pass_phi_only_cprop
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_reassoc
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_dce
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_dse
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_may_alias
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_forwprop
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_phiopt
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_object_sizes
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_store_ccp
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_store_copy_prop
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_fold_builtins
argument_list|)
expr_stmt|;
comment|/* FIXME: May alias should a TODO but for 4.0.0,      we add may_alias right after fold builtins      which can create arbitrary GIMPLE.  */
name|NEXT_PASS
argument_list|(
name|pass_may_alias
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_split_crit_edges
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_pre
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_may_alias
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_sink_code
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_tree_loop
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_cse_reciprocals
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_reassoc
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_vrp
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_dominator
argument_list|)
expr_stmt|;
comment|/* The only const/copy propagation opportunities left after      DOM should be due to degenerate PHI nodes.  So rather than      run the full propagators, run a specialized pass which      only examines PHIs to discover const/copy propagation      opportunities.  */
name|NEXT_PASS
argument_list|(
name|pass_phi_only_cprop
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_cd_dce
argument_list|)
expr_stmt|;
comment|/* FIXME: If DCE is not run before checking for uninitialized uses,      we may get false warnings (e.g., testsuite/gcc.dg/uninit-5.c).      However, this also causes us to misdiagnose cases that should be      real warnings (e.g., testsuite/gcc.dg/pr18501.c).            To fix the false positives in uninit-5.c, we would have to      account for the predicates protecting the set and the use of each      variable.  Using a representation like Gated Single Assignment      may help.  */
name|NEXT_PASS
argument_list|(
name|pass_late_warn_uninitialized
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_dse
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_forwprop
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_phiopt
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_tail_calls
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_rename_ssa_copies
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_uncprop
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_del_ssa
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_nrv
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_mark_used_blocks
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_cleanup_cfg_post_optimizing
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|NULL
expr_stmt|;
name|p
operator|=
operator|&
name|pass_tree_loop
operator|.
name|sub
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_tree_loop_init
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_copy_prop
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_lim
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_tree_unswitch
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_scev_cprop
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_empty_loop
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_record_bounds
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_linear_transform
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_iv_canon
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_if_conversion
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_vectorize
argument_list|)
expr_stmt|;
comment|/* NEXT_PASS (pass_may_alias) cannot be done again because the      vectorizer creates alias relations that are not supported by      pass_may_alias.  */
name|NEXT_PASS
argument_list|(
name|pass_complete_unroll
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_loop_prefetch
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_iv_optimize
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_tree_loop_done
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|NULL
expr_stmt|;
name|p
operator|=
operator|&
name|pass_vectorize
operator|.
name|sub
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_lower_vector_ssa
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_dce_loop
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|NULL
expr_stmt|;
name|p
operator|=
operator|&
name|pass_loop2
operator|.
name|sub
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_rtl_loop_init
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_rtl_move_loop_invariants
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_rtl_unswitch
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_rtl_unroll_and_peel_loops
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_rtl_doloop
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_rtl_loop_done
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|NULL
expr_stmt|;
name|p
operator|=
operator|&
name|pass_rest_of_compilation
operator|.
name|sub
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_init_function
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_jump
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_insn_locators_initialize
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_rtl_eh
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_initial_value_sets
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_unshare_all_rtl
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_instantiate_virtual_regs
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_jump2
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_cse
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_gcse
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_jump_bypass
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_rtl_ifcvt
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_tracer
argument_list|)
expr_stmt|;
comment|/* Perform loop optimizations.  It might be better to do them a bit      sooner, but we want the profile feedback to work more      efficiently.  */
name|NEXT_PASS
argument_list|(
name|pass_loop2
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_web
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_cse2
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_life
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_combine
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_if_after_combine
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_partition_blocks
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_regmove
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_split_all_insns
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_mode_switching
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_see
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_recompute_reg_usage
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_sms
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_sched
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_local_alloc
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_global_alloc
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_postreload
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|NULL
expr_stmt|;
name|p
operator|=
operator|&
name|pass_postreload
operator|.
name|sub
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_postreload_cse
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_gcse2
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_flow2
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_rtl_seqabstr
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_stack_adjustments
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_peephole2
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_if_after_reload
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_regrename
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_reorder_blocks
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_branch_target_load_optimize
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_leaf_regs
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_sched2
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_split_before_regstack
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_stack_regs
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_compute_alignments
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_duplicate_computed_gotos
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_variable_tracking
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_free_cfg
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_machine_reorg
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_purge_lineno_notes
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_cleanup_barriers
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_delay_slots
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_split_for_shorten_branches
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_convert_to_eh_region_ranges
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_shorten_branches
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_set_nothrow_function_flags
argument_list|)
expr_stmt|;
name|NEXT_PASS
argument_list|(
name|pass_final
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|NULL
expr_stmt|;
undef|#
directive|undef
name|NEXT_PASS
comment|/* Register the passes with the tree dump code.  */
name|register_dump_files
argument_list|(
name|all_ipa_passes
argument_list|,
name|true
argument_list|,
name|PROP_gimple_any
operator||
name|PROP_gimple_lcf
operator||
name|PROP_gimple_leh
operator||
name|PROP_cfg
argument_list|)
expr_stmt|;
name|register_dump_files
argument_list|(
name|all_lowering_passes
argument_list|,
name|false
argument_list|,
name|PROP_gimple_any
argument_list|)
expr_stmt|;
name|register_dump_files
argument_list|(
name|all_passes
argument_list|,
name|false
argument_list|,
name|PROP_gimple_any
operator||
name|PROP_gimple_lcf
operator||
name|PROP_gimple_leh
operator||
name|PROP_cfg
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|last_verified
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|curr_properties
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|execute_todo
parameter_list|(
name|unsigned
name|int
name|flags
parameter_list|)
block|{
if|#
directive|if
name|defined
name|ENABLE_CHECKING
if|if
condition|(
name|need_ssa_update_p
argument_list|()
condition|)
name|gcc_assert
argument_list|(
name|flags
operator|&
name|TODO_update_ssa_any
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|curr_properties
operator|&
name|PROP_ssa
condition|)
name|flags
operator||=
name|TODO_verify_ssa
expr_stmt|;
name|flags
operator|&=
operator|~
name|last_verified
expr_stmt|;
if|if
condition|(
operator|!
name|flags
condition|)
return|return;
comment|/* Always recalculate SMT usage before doing anything else.  */
if|if
condition|(
name|flags
operator|&
name|TODO_update_smt_usage
condition|)
name|recalculate_used_alone
argument_list|()
expr_stmt|;
comment|/* Always cleanup the CFG before trying to update SSA .  */
if|if
condition|(
name|flags
operator|&
name|TODO_cleanup_cfg
condition|)
block|{
comment|/* CFG Cleanup can cause a constant to prop into an ARRAY_REF.  */
name|updating_used_alone
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|current_loops
condition|)
name|cleanup_tree_cfg_loop
argument_list|()
expr_stmt|;
else|else
name|cleanup_tree_cfg
argument_list|()
expr_stmt|;
comment|/* Update the used alone after cleanup cfg.  */
name|recalculate_used_alone
argument_list|()
expr_stmt|;
comment|/* When cleanup_tree_cfg merges consecutive blocks, it may 	 perform some simplistic propagation when removing single 	 valued PHI nodes.  This propagation may, in turn, cause the 	 SSA form to become out-of-date (see PR 22037).  So, even 	 if the parent pass had not scheduled an SSA update, we may 	 still need to do one.  */
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|TODO_update_ssa_any
operator|)
operator|&&
name|need_ssa_update_p
argument_list|()
condition|)
name|flags
operator||=
name|TODO_update_ssa
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|TODO_update_ssa_any
condition|)
block|{
name|unsigned
name|update_flags
init|=
name|flags
operator|&
name|TODO_update_ssa_any
decl_stmt|;
name|update_ssa
argument_list|(
name|update_flags
argument_list|)
expr_stmt|;
name|last_verified
operator|&=
operator|~
name|TODO_verify_ssa
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|TODO_remove_unused_locals
condition|)
name|remove_unused_locals
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|TODO_dump_func
operator|)
operator|&&
name|dump_file
operator|&&
name|current_function_decl
condition|)
block|{
if|if
condition|(
name|curr_properties
operator|&
name|PROP_trees
condition|)
name|dump_function_to_file
argument_list|(
name|current_function_decl
argument_list|,
name|dump_file
argument_list|,
name|dump_flags
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|dump_flags
operator|&
name|TDF_SLIM
condition|)
name|print_rtl_slim_with_bb
argument_list|(
name|dump_file
argument_list|,
name|get_insns
argument_list|()
argument_list|,
name|dump_flags
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|curr_properties
operator|&
name|PROP_cfg
operator|)
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_BLOCKS
operator|)
condition|)
name|print_rtl_with_bb
argument_list|(
name|dump_file
argument_list|,
name|get_insns
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|print_rtl
argument_list|(
name|dump_file
argument_list|,
name|get_insns
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|curr_properties
operator|&
name|PROP_cfg
operator|&&
name|graph_dump_format
operator|!=
name|no_graph
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_GRAPH
operator|)
condition|)
name|print_rtl_graph_with_bb
argument_list|(
name|dump_file_name
argument_list|,
name|get_insns
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/* Flush the file.  If verification fails, we won't be able to 	 close the file before aborting.  */
name|fflush
argument_list|(
name|dump_file
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|TODO_dump_cgraph
operator|)
operator|&&
name|dump_file
operator|&&
operator|!
name|current_function_decl
condition|)
block|{
name|dump_cgraph
argument_list|(
name|dump_file
argument_list|)
expr_stmt|;
comment|/* Flush the file.  If verification fails, we won't be able to 	 close the file before aborting.  */
name|fflush
argument_list|(
name|dump_file
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|TODO_ggc_collect
condition|)
block|{
name|ggc_collect
argument_list|()
expr_stmt|;
block|}
if|#
directive|if
name|defined
name|ENABLE_CHECKING
if|if
condition|(
name|flags
operator|&
name|TODO_verify_ssa
condition|)
name|verify_ssa
argument_list|(
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|TODO_verify_flow
condition|)
name|verify_flow_info
argument_list|()
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|TODO_verify_stmts
condition|)
name|verify_stmts
argument_list|()
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|TODO_verify_loops
condition|)
name|verify_loop_closed_ssa
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|last_verified
operator|=
name|flags
operator|&
name|TODO_verify_all
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Verify invariants that should hold between passes.  This is a place    to put simple sanity checks.  */
end_comment

begin_function
specifier|static
name|void
name|verify_interpass_invariants
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
name|gcc_assert
argument_list|(
operator|!
name|fold_deferring_overflow_warnings_p
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|bool
name|execute_one_pass
parameter_list|(
name|struct
name|tree_opt_pass
modifier|*
name|pass
parameter_list|)
block|{
name|bool
name|initializing_dump
decl_stmt|;
name|unsigned
name|int
name|todo_after
init|=
literal|0
decl_stmt|;
comment|/* See if we're supposed to run this pass.  */
if|if
condition|(
name|pass
operator|->
name|gate
operator|&&
operator|!
name|pass
operator|->
name|gate
argument_list|()
condition|)
return|return
name|false
return|;
if|if
condition|(
name|pass
operator|->
name|todo_flags_start
operator|&
name|TODO_set_props
condition|)
name|curr_properties
operator|=
name|pass
operator|->
name|properties_required
expr_stmt|;
comment|/* Note that the folders should only create gimple expressions.      This is a hack until the new folder is ready.  */
name|in_gimple_form
operator|=
operator|(
name|curr_properties
operator|&
name|PROP_trees
operator|)
operator|!=
literal|0
expr_stmt|;
comment|/* Run pre-pass verification.  */
name|execute_todo
argument_list|(
name|pass
operator|->
name|todo_flags_start
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|(
name|curr_properties
operator|&
name|pass
operator|->
name|properties_required
operator|)
operator|==
name|pass
operator|->
name|properties_required
argument_list|)
expr_stmt|;
if|if
condition|(
name|pass
operator|->
name|properties_destroyed
operator|&
name|PROP_smt_usage
condition|)
name|updating_used_alone
operator|=
name|true
expr_stmt|;
comment|/* If a dump file name is present, open it if enabled.  */
if|if
condition|(
name|pass
operator|->
name|static_pass_number
operator|!=
operator|-
literal|1
condition|)
block|{
name|initializing_dump
operator|=
operator|!
name|dump_initialized_p
argument_list|(
name|pass
operator|->
name|static_pass_number
argument_list|)
expr_stmt|;
name|dump_file_name
operator|=
name|get_dump_file_name
argument_list|(
name|pass
operator|->
name|static_pass_number
argument_list|)
expr_stmt|;
name|dump_file
operator|=
name|dump_begin
argument_list|(
name|pass
operator|->
name|static_pass_number
argument_list|,
operator|&
name|dump_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
name|current_function_decl
condition|)
block|{
specifier|const
name|char
modifier|*
name|dname
decl_stmt|,
modifier|*
name|aname
decl_stmt|;
name|dname
operator|=
name|lang_hooks
operator|.
name|decl_printable_name
argument_list|(
name|current_function_decl
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|aname
operator|=
operator|(
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n;; Function %s (%s)%s\n\n"
argument_list|,
name|dname
argument_list|,
name|aname
argument_list|,
name|cfun
operator|->
name|function_frequency
operator|==
name|FUNCTION_FREQUENCY_HOT
condition|?
literal|" (hot)"
else|:
name|cfun
operator|->
name|function_frequency
operator|==
name|FUNCTION_FREQUENCY_UNLIKELY_EXECUTED
condition|?
literal|" (unlikely executed)"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|initializing_dump
operator|=
name|false
expr_stmt|;
comment|/* If a timevar is present, start it.  */
if|if
condition|(
name|pass
operator|->
name|tv_id
condition|)
name|timevar_push
argument_list|(
name|pass
operator|->
name|tv_id
argument_list|)
expr_stmt|;
comment|/* Do it!  */
if|if
condition|(
name|pass
operator|->
name|execute
condition|)
block|{
name|todo_after
operator|=
name|pass
operator|->
name|execute
argument_list|()
expr_stmt|;
name|last_verified
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Stop timevar.  */
if|if
condition|(
name|pass
operator|->
name|tv_id
condition|)
name|timevar_pop
argument_list|(
name|pass
operator|->
name|tv_id
argument_list|)
expr_stmt|;
name|curr_properties
operator|=
operator|(
name|curr_properties
operator||
name|pass
operator|->
name|properties_provided
operator|)
operator|&
operator|~
name|pass
operator|->
name|properties_destroyed
expr_stmt|;
if|if
condition|(
name|initializing_dump
operator|&&
name|dump_file
operator|&&
name|graph_dump_format
operator|!=
name|no_graph
operator|&&
operator|(
name|curr_properties
operator|&
operator|(
name|PROP_cfg
operator||
name|PROP_rtl
operator|)
operator|)
operator|==
operator|(
name|PROP_cfg
operator||
name|PROP_rtl
operator|)
condition|)
block|{
name|get_dump_file_info
argument_list|(
name|pass
operator|->
name|static_pass_number
argument_list|)
operator|->
name|flags
operator||=
name|TDF_GRAPH
expr_stmt|;
name|dump_flags
operator||=
name|TDF_GRAPH
expr_stmt|;
name|clean_graph_dump_file
argument_list|(
name|dump_file_name
argument_list|)
expr_stmt|;
block|}
comment|/* Run post-pass cleanup and verification.  */
name|execute_todo
argument_list|(
name|todo_after
operator||
name|pass
operator|->
name|todo_flags_finish
argument_list|)
expr_stmt|;
name|verify_interpass_invariants
argument_list|()
expr_stmt|;
comment|/* Flush and close dump file.  */
if|if
condition|(
name|dump_file_name
condition|)
block|{
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dump_file_name
argument_list|)
expr_stmt|;
name|dump_file_name
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|dump_file
condition|)
block|{
name|dump_end
argument_list|(
name|pass
operator|->
name|static_pass_number
argument_list|,
name|dump_file
argument_list|)
expr_stmt|;
name|dump_file
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|pass
operator|->
name|properties_destroyed
operator|&
name|PROP_smt_usage
condition|)
name|updating_used_alone
operator|=
name|false
expr_stmt|;
comment|/* Reset in_gimple_form to not break non-unit-at-a-time mode.  */
name|in_gimple_form
operator|=
name|false
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_function
name|void
name|execute_pass_list
parameter_list|(
name|struct
name|tree_opt_pass
modifier|*
name|pass
parameter_list|)
block|{
do|do
block|{
if|if
condition|(
name|execute_one_pass
argument_list|(
name|pass
argument_list|)
operator|&&
name|pass
operator|->
name|sub
condition|)
name|execute_pass_list
argument_list|(
name|pass
operator|->
name|sub
argument_list|)
expr_stmt|;
name|pass
operator|=
name|pass
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|pass
condition|)
do|;
block|}
end_function

begin_comment
comment|/* Same as execute_pass_list but assume that subpasses of IPA passes    are local passes.  */
end_comment

begin_function
name|void
name|execute_ipa_pass_list
parameter_list|(
name|struct
name|tree_opt_pass
modifier|*
name|pass
parameter_list|)
block|{
do|do
block|{
if|if
condition|(
name|execute_one_pass
argument_list|(
name|pass
argument_list|)
operator|&&
name|pass
operator|->
name|sub
condition|)
block|{
name|struct
name|cgraph_node
modifier|*
name|node
decl_stmt|;
for|for
control|(
name|node
operator|=
name|cgraph_nodes
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
if|if
condition|(
name|node
operator|->
name|analyzed
condition|)
block|{
name|push_cfun
argument_list|(
name|DECL_STRUCT_FUNCTION
argument_list|(
name|node
operator|->
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|current_function_decl
operator|=
name|node
operator|->
name|decl
expr_stmt|;
name|execute_pass_list
argument_list|(
name|pass
operator|->
name|sub
argument_list|)
expr_stmt|;
name|free_dominance_info
argument_list|(
name|CDI_DOMINATORS
argument_list|)
expr_stmt|;
name|free_dominance_info
argument_list|(
name|CDI_POST_DOMINATORS
argument_list|)
expr_stmt|;
name|current_function_decl
operator|=
name|NULL
expr_stmt|;
name|pop_cfun
argument_list|()
expr_stmt|;
name|ggc_collect
argument_list|()
expr_stmt|;
block|}
block|}
name|pass
operator|=
name|pass
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|pass
condition|)
do|;
block|}
end_function

end_unit

