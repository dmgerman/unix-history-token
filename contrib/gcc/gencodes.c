begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Generate from machine description:     - some macros CODE_FOR_... giving the insn_code_number value    for each of the defined standard insn names.    Copyright (C) 1987, 1991, 1995, 1998, 1999 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"hconfig.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|obstack
modifier|*
name|rtl_obstack
init|=
operator|&
name|obstack
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|obstack_chunk_alloc
value|xmalloc
end_define

begin_define
define|#
directive|define
name|obstack_chunk_free
value|free
end_define

begin_decl_stmt
name|void
name|fatal
name|PVPROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
operator|...
operator|)
argument_list|)
name|ATTRIBUTE_PRINTF_1
name|ATTRIBUTE_NORETURN
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|fancy_abort
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
name|ATTRIBUTE_NORETURN
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Define this so we can link with print-rtl.o to get debug_rtx function.  */
end_comment

begin_decl_stmt
name|char
modifier|*
modifier|*
name|insn_name_ptr
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|insn_code_number
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_insn
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|gen_insn
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
comment|/* Don't mention instructions whose names are the null string      or begin with '*'.  They are in the machine description just      to be recognized.  */
if|if
condition|(
name|XSTR
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|)
index|[
literal|0
index|]
operator|!=
literal|0
operator|&&
name|XSTR
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|)
index|[
literal|0
index|]
operator|!=
literal|'*'
condition|)
name|printf
argument_list|(
literal|"  CODE_FOR_%s = %d,\n"
argument_list|,
name|XSTR
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn_code_number
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|PTR
name|xmalloc
parameter_list|(
name|size
parameter_list|)
name|size_t
name|size
decl_stmt|;
block|{
specifier|register
name|PTR
name|val
init|=
operator|(
name|PTR
operator|)
name|malloc
argument_list|(
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|==
literal|0
condition|)
name|fatal
argument_list|(
literal|"virtual memory exhausted"
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_function
name|PTR
name|xrealloc
parameter_list|(
name|old
parameter_list|,
name|size
parameter_list|)
name|PTR
name|old
decl_stmt|;
name|size_t
name|size
decl_stmt|;
block|{
specifier|register
name|PTR
name|ptr
decl_stmt|;
if|if
condition|(
name|old
condition|)
name|ptr
operator|=
operator|(
name|PTR
operator|)
name|realloc
argument_list|(
name|old
argument_list|,
name|size
argument_list|)
expr_stmt|;
else|else
name|ptr
operator|=
operator|(
name|PTR
operator|)
name|malloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ptr
condition|)
name|fatal
argument_list|(
literal|"virtual memory exhausted"
argument_list|)
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_decl_stmt
name|void
name|fatal
name|VPROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|format
operator|,
operator|...
operator|)
argument_list|)
block|{
ifndef|#
directive|ifndef
name|ANSI_PROTOTYPES
specifier|const
name|char
modifier|*
name|format
decl_stmt|;
endif|#
directive|endif
name|va_list
name|ap
decl_stmt|;
name|VA_START
argument_list|(
name|ap
argument_list|,
name|format
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|ANSI_PROTOTYPES
name|format
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"gencodes: "
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|format
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|FATAL_EXIT_CODE
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* More 'friendly' abort that prints the line and file.    config.h can #define abort fancy_abort if you like that sort of thing.  */
end_comment

begin_function
name|void
name|fancy_abort
parameter_list|()
block|{
name|fatal
argument_list|(
literal|"Internal gcc abort."
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|rtx
name|desc
decl_stmt|;
name|FILE
modifier|*
name|infile
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|obstack_init
argument_list|(
name|rtl_obstack
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|<=
literal|1
condition|)
name|fatal
argument_list|(
literal|"No input file name."
argument_list|)
expr_stmt|;
name|infile
operator|=
name|fopen
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|infile
operator|==
literal|0
condition|)
block|{
name|perror
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|FATAL_EXIT_CODE
argument_list|)
expr_stmt|;
block|}
name|init_rtl
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"/* Generated automatically by the program `gencodes'\n\ from the machine description file `md'.  */\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#ifndef MAX_INSN_CODE\n\n"
argument_list|)
expr_stmt|;
comment|/* Read the machine description.  */
name|insn_code_number
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"enum insn_code {\n"
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|c
operator|=
name|read_skip_spaces
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
break|break;
name|ungetc
argument_list|(
name|c
argument_list|,
name|infile
argument_list|)
expr_stmt|;
name|desc
operator|=
name|read_rtx
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|desc
argument_list|)
operator|==
name|DEFINE_INSN
operator|||
name|GET_CODE
argument_list|(
name|desc
argument_list|)
operator|==
name|DEFINE_EXPAND
condition|)
block|{
name|gen_insn
argument_list|(
name|desc
argument_list|)
expr_stmt|;
name|insn_code_number
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|desc
argument_list|)
operator|==
name|DEFINE_PEEPHOLE
operator|||
name|GET_CODE
argument_list|(
name|desc
argument_list|)
operator|==
name|DEFINE_SPLIT
condition|)
block|{
name|insn_code_number
operator|++
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"  CODE_FOR_nothing };\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n#define MAX_INSN_CODE ((int) CODE_FOR_nothing)\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#endif /* MAX_INSN_CODE */\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|ferror
argument_list|(
name|stdout
argument_list|)
operator|!=
literal|0
condition|?
name|FATAL_EXIT_CODE
else|:
name|SUCCESS_EXIT_CODE
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
return|return
literal|0
return|;
block|}
end_function

end_unit

