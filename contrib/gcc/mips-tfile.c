begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Update the symbol table (the .T file) in a MIPS object to    contain debugging information specified by the GNU compiler    in the form of comments (the mips assembler does not support    assembly access to debug information).    Copyright (C) 1991, 1993, 1994, 1995, 1997, 1998, 1999, 2000, 2001    Free Software Foundation, Inc.    Contributed by Michael Meissner (meissner@cygnus.com).     This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Here is a brief description of the MIPS ECOFF symbol table.  The    MIPS symbol table has the following pieces:  	Symbolic Header 	    | 	    +--	Auxiliary Symbols 	    | 	    +--	Dense number table 	    | 	    +--	Optimizer Symbols 	    | 	    +--	External Strings 	    | 	    +--	External Symbols 	    | 	    +--	Relative file descriptors 	    | 	    +--	File table 		    | 		    +--	Procedure table 		    | 		    +--	Line number table 		    | 		    +--	Local Strings 		    | 		    +--	Local Symbols     The symbolic header points to each of the other tables, and also    contains the number of entries.  It also contains a magic number    and MIPS compiler version number, such as 2.0.     The auxiliary table is a series of 32 bit integers, that are    referenced as needed from the local symbol table.  Unlike standard    COFF, the aux.  information does not follow the symbol that uses    it, but rather is a separate table.  In theory, this would allow    the MIPS compilers to collapse duplicate aux. entries, but I've not    noticed this happening with the 1.31 compiler suite.  The different    types of aux. entries are:      1)	dnLow: Low bound on array dimension.      2)	dnHigh: High bound on array dimension.      3)	isym: Index to the local symbol which is the start of the 	function for the end of function first aux. entry.      4)	width: Width of structures and bitfields.      5)	count: Count of ranges for variant part.      6)	rndx: A relative index into the symbol table.  The relative 	index field has two parts: rfd which is a pointer into the 	relative file index table or ST_RFDESCAPE which says the next 	aux. entry is the file number, and index: which is the pointer 	into the local symbol within a given file table.  This is for 	things like references to types defined in another file.      7)	Type information: This is like the COFF type bits, except it 	is 32 bits instead of 16; they still have room to add new 	basic types; and they can handle more than 6 levels of array, 	pointer, function, etc.  Each type information field contains 	the following structure members:  	    a)	fBitfield: a bit that says this is a bitfield, and the 		size in bits follows as the next aux. entry.  	    b)	continued: a bit that says the next aux. entry is a 		continuation of the current type information (in case 		there are more than 6 levels of array/ptr/function).  	    c)	bt: an integer containing the base type before adding 		array, pointer, function, etc. qualifiers.  The 		current base types that I have documentation for are:  			btNil		-- undefined  			btAdr		-- address - integer same size as ptr 			btChar		-- character  			btUChar		-- unsigned character  			btShort		-- short  			btUShort	-- unsigned short  			btInt		-- int  			btUInt		-- unsigned int  			btLong		-- long  			btULong		-- unsigned long  			btFloat		-- float (real)  			btDouble	-- Double (real)  			btStruct	-- Structure (Record)  			btUnion		-- Union (variant)  			btEnum		-- Enumerated  			btTypedef	-- defined via a typedef isymRef  			btRange		-- subrange of int  			btSet		-- pascal sets  			btComplex	-- fortran complex  			btDComplex	-- fortran double complex  			btIndirect	-- forward or unnamed typedef  			btFixedDec	-- Fixed Decimal  			btFloatDec	-- Float Decimal  			btString	-- Varying Length Character String  			btBit		-- Aligned Bit String  			btPicture	-- Picture 			btVoid		-- Void (MIPS cc revision>= 2.00)  	    d)	tq0 - tq5: type qualifier fields as needed.  The 		current type qualifier fields I have documentation for 		are:  			tqNil		-- no more qualifiers  			tqPtr		-- pointer  			tqProc		-- procedure  			tqArray		-- array  			tqFar		-- 8086 far pointers  			tqVol		-- volatile       The dense number table is used in the front ends, and disappears by    the time the .o is created.     With the 1.31 compiler suite, the optimization symbols don't seem    to be used as far as I can tell.     The linker is the first entity that creates the relative file    descriptor table, and I believe it is used so that the individual    file table pointers don't have to be rewritten when the objects are    merged together into the program file.     Unlike COFF, the basic symbol& string tables are split into    external and local symbols/strings.  The relocation information    only goes off of the external symbol table, and the debug    information only goes off of the internal symbol table.  The    external symbols can have links to an appropriate file index and    symbol within the file to give it the appropriate type information.    Because of this, the external symbols are actually larger than the    internal symbols (to contain the link information), and contain the    local symbol structure as a member, though this member is not the    first member of the external symbol structure (!).  I suspect this    split is to make strip easier to deal with.     Each file table has offsets for where the line numbers, local    strings, local symbols, and procedure table starts from within the    global tables, and the indexs are reset to 0 for each of those    tables for the file.     The procedure table contains the binary equivalents of the .ent    (start of the function address), .frame (what register is the    virtual frame pointer, constant offset from the register to obtain    the VFP, and what register holds the return address), .mask/.fmask    (bitmask of saved registers, and where the first register is stored    relative to the VFP) assembler directives.  It also contains the    low and high bounds of the line numbers if debugging is turned on.     The line number table is a compressed form of the normal COFF line    table.  Each line number entry is either 1 or 3 bytes long, and    contains a signed delta from the previous line, and an unsigned    count of the number of instructions this statement takes.     The local symbol table contains the following fields:      1)	iss: index to the local string table giving the name of the 	symbol.      2)	value: value of the symbol (address, register number, etc.).      3)	st: symbol type.  The current symbol types are:  	    stNil	  -- Nuthin' special 	    stGlobal	  -- external symbol 	    stStatic	  -- static 	    stParam	  -- procedure argument 	    stLocal	  -- local variable 	    stLabel	  -- label 	    stProc	  -- External Procedure 	    stBlock	  -- beginning of block 	    stEnd	  -- end (of anything) 	    stMember	  -- member (of anything) 	    stTypedef	  -- type definition 	    stFile	  -- file name 	    stRegReloc	  -- register relocation 	    stForward	  -- forwarding address 	    stStaticProc  -- Static procedure 	    stConstant	  -- const      4)	sc: storage class.  The current storage classes are:  	    scText	  -- text symbol 	    scData	  -- initialized data symbol 	    scBss	  -- un-initialized data symbol 	    scRegister	  -- value of symbol is register number 	    scAbs	  -- value of symbol is absolute 	    scUndefined   -- who knows? 	    scCdbLocal	  -- variable's value is IN se->va.?? 	    scBits	  -- this is a bit field 	    scCdbSystem	  -- value is IN debugger's address space 	    scRegImage	  -- register value saved on stack 	    scInfo	  -- symbol contains debugger information 	    scUserStruct  -- addr in struct user for current process 	    scSData	  -- load time only small data 	    scSBss	  -- load time only small common 	    scRData	  -- load time only read only data 	    scVar	  -- Var parameter (fortranpascal) 	    scCommon	  -- common variable 	    scSCommon	  -- small common 	    scVarRegister -- Var parameter in a register 	    scVariant	  -- Variant record 	    scSUndefined  -- small undefined(external) data 	    scInit	  -- .init section symbol      5)	index: pointer to a local symbol or aux. entry.       For the following program:  	#include<stdio.h>  	main(){ 		printf("Hello World!\n"); 		return 0; 	}     Mips-tdump produces the following information:        Global file header:        magic number             0x162        # sections               2        timestamp                645311799, Wed Jun 13 17:16:39 1990        symbolic header offset   284        symbolic header size     96        optional header          56        flags                    0x0        Symbolic header, magic number = 0x7009, vstamp = 1.31:            Info                      Offset      Number       Bytes        ====                      ======      ======      =====            Line numbers                 380           4           4 [13]        Dense numbers                  0           0           0        Procedures Tables            384           1          52        Local Symbols                436          16         192        Optimization Symbols           0           0           0        Auxiliary Symbols            628          39         156        Local Strings                784          80          80        External Strings             864         144         144        File Tables                 1008           2         144        Relative Files                 0           0           0        External Symbols            1152          20         320        File #0, "hello2.c"            Name index  = 1          Readin      = No        Merge       = No         Endian      = LITTLE        Debug level = G2         Language    = C        Adr         = 0x00000000            Info                       Start      Number        Size      Offset        ====                       =====      ======        ====      ======        Local strings                  0          15          15         784        Local symbols                  0           6          72         436        Line numbers                   0          13          13         380        Optimization symbols           0           0           0           0        Procedures                     0           1          52         384        Auxiliary symbols              0          14          56         628        Relative Files                 0           0           0           0         There are 6 local symbols, starting at 436  	Symbol# 0: "hello2.c" 	    End+1 symbol  = 6 	    String index  = 1 	    Storage class = Text        Index  = 6 	    Symbol type   = File        Value  = 0  	Symbol# 1: "main" 	    End+1 symbol  = 5 	    Type          = int 	    String index  = 10 	    Storage class = Text        Index  = 12 	    Symbol type   = Proc        Value  = 0  	Symbol# 2: "" 	    End+1 symbol  = 4 	    String index  = 0 	    Storage class = Text        Index  = 4 	    Symbol type   = Block       Value  = 8  	Symbol# 3: "" 	    First symbol  = 2 	    String index  = 0 	    Storage class = Text        Index  = 2 	    Symbol type   = End         Value  = 28  	Symbol# 4: "main" 	    First symbol  = 1 	    String index  = 10 	    Storage class = Text        Index  = 1 	    Symbol type   = End         Value  = 52  	Symbol# 5: "hello2.c" 	    First symbol  = 0 	    String index  = 1 	    Storage class = Text        Index  = 0 	    Symbol type   = End         Value  = 0      There are 14 auxiliary table entries, starting at 628.  	* #0               0, [   0/      0], [ 0 0:0 0:0:0:0:0:0] 	* #1              24, [  24/      0], [ 6 0:0 0:0:0:0:0:0] 	* #2               8, [   8/      0], [ 2 0:0 0:0:0:0:0:0] 	* #3              16, [  16/      0], [ 4 0:0 0:0:0:0:0:0] 	* #4              24, [  24/      0], [ 6 0:0 0:0:0:0:0:0] 	* #5              32, [  32/      0], [ 8 0:0 0:0:0:0:0:0] 	* #6              40, [  40/      0], [10 0:0 0:0:0:0:0:0] 	* #7              44, [  44/      0], [11 0:0 0:0:0:0:0:0] 	* #8              12, [  12/      0], [ 3 0:0 0:0:0:0:0:0] 	* #9              20, [  20/      0], [ 5 0:0 0:0:0:0:0:0] 	* #10             28, [  28/      0], [ 7 0:0 0:0:0:0:0:0] 	* #11             36, [  36/      0], [ 9 0:0 0:0:0:0:0:0] 	  #12              5, [   5/      0], [ 1 1:0 0:0:0:0:0:0] 	  #13             24, [  24/      0], [ 6 0:0 0:0:0:0:0:0]      There are 1 procedure descriptor entries, starting at 0.  	Procedure descriptor 0: 	    Name index   = 10          Name          = "main" 	    .mask 0x80000000,-4        .fmask 0x00000000,0 	    .frame $29,24,$31 	    Opt. start   = -1          Symbols start = 1 	    First line # = 3           Last line #   = 6 	    Line Offset  = 0           Address       = 0x00000000  	There are 4 bytes holding line numbers, starting at 380. 	    Line           3,   delta     0,   count  2 	    Line           4,   delta     1,   count  3 	    Line           5,   delta     1,   count  2 	    Line           6,   delta     1,   count  6     File #1, "/usr/include/stdio.h"      Name index  = 1          Readin      = No     Merge       = Yes        Endian      = LITTLE     Debug level = G2         Language    = C     Adr         = 0x00000000      Info                       Start      Number        Size      Offset     ====                       =====      ======        ====      ======     Local strings                 15          65          65         799     Local symbols                  6          10         120         508     Line numbers                   0           0           0         380     Optimization symbols           0           0           0           0     Procedures                     1           0           0         436     Auxiliary symbols             14          25         100         684     Relative Files                 0           0           0           0      There are 10 local symbols, starting at 442  	Symbol# 0: "/usr/include/stdio.h" 	    End+1 symbol  = 10 	    String index  = 1 	    Storage class = Text        Index  = 10 	    Symbol type   = File        Value  = 0  	Symbol# 1: "_iobuf" 	    End+1 symbol  = 9 	    String index  = 22 	    Storage class = Info        Index  = 9 	    Symbol type   = Block       Value  = 20  	Symbol# 2: "_cnt" 	    Type          = int 	    String index  = 29 	    Storage class = Info        Index  = 4 	    Symbol type   = Member      Value  = 0  	Symbol# 3: "_ptr" 	    Type          = ptr to char 	    String index  = 34 	    Storage class = Info        Index  = 15 	    Symbol type   = Member      Value  = 32  	Symbol# 4: "_base" 	    Type          = ptr to char 	    String index  = 39 	    Storage class = Info        Index  = 16 	    Symbol type   = Member      Value  = 64  	Symbol# 5: "_bufsiz" 	    Type          = int 	    String index  = 45 	    Storage class = Info        Index  = 4 	    Symbol type   = Member      Value  = 96  	Symbol# 6: "_flag" 	    Type          = short 	    String index  = 53 	    Storage class = Info        Index  = 3 	    Symbol type   = Member      Value  = 128  	Symbol# 7: "_file" 	    Type          = char 	    String index  = 59 	    Storage class = Info        Index  = 2 	    Symbol type   = Member      Value  = 144  	Symbol# 8: "" 	    First symbol  = 1 	    String index  = 0 	    Storage class = Info        Index  = 1 	    Symbol type   = End         Value  = 0  	Symbol# 9: "/usr/include/stdio.h" 	    First symbol  = 0 	    String index  = 1 	    Storage class = Text        Index  = 0 	    Symbol type   = End         Value  = 0      There are 25 auxiliary table entries, starting at 642.  	* #14             -1, [4095/1048575], [63 1:1 f:f:f:f:f:f] 	  #15          65544, [   8/     16], [ 2 0:0 1:0:0:0:0:0] 	  #16          65544, [   8/     16], [ 2 0:0 1:0:0:0:0:0] 	* #17         196656, [  48/     48], [12 0:0 3:0:0:0:0:0] 	* #18           8191, [4095/      1], [63 1:1 0:0:0:0:f:1] 	* #19              1, [   1/      0], [ 0 1:0 0:0:0:0:0:0] 	* #20          20479, [4095/      4], [63 1:1 0:0:0:0:f:4] 	* #21              1, [   1/      0], [ 0 1:0 0:0:0:0:0:0] 	* #22              0, [   0/      0], [ 0 0:0 0:0:0:0:0:0] 	* #23              2, [   2/      0], [ 0 0:1 0:0:0:0:0:0] 	* #24            160, [ 160/      0], [40 0:0 0:0:0:0:0:0] 	* #25              0, [   0/      0], [ 0 0:0 0:0:0:0:0:0] 	* #26              0, [   0/      0], [ 0 0:0 0:0:0:0:0:0] 	* #27              0, [   0/      0], [ 0 0:0 0:0:0:0:0:0] 	* #28              0, [   0/      0], [ 0 0:0 0:0:0:0:0:0] 	* #29              0, [   0/      0], [ 0 0:0 0:0:0:0:0:0] 	* #30              0, [   0/      0], [ 0 0:0 0:0:0:0:0:0] 	* #31              0, [   0/      0], [ 0 0:0 0:0:0:0:0:0] 	* #32              0, [   0/      0], [ 0 0:0 0:0:0:0:0:0] 	* #33              0, [   0/      0], [ 0 0:0 0:0:0:0:0:0] 	* #34              0, [   0/      0], [ 0 0:0 0:0:0:0:0:0] 	* #35              0, [   0/      0], [ 0 0:0 0:0:0:0:0:0] 	* #36              0, [   0/      0], [ 0 0:0 0:0:0:0:0:0] 	* #37              0, [   0/      0], [ 0 0:0 0:0:0:0:0:0] 	* #38              0, [   0/      0], [ 0 0:0 0:0:0:0:0:0]      There are 0 procedure descriptor entries, starting at 1.     There are 20 external symbols, starting at 1152  	Symbol# 0: "_iob" 	    Type          = array [3 {160}] of struct _iobuf { ifd = 1, index = 1 } 	    String index  = 0           Ifd    = 1 	    Storage class = Nil         Index  = 17 	    Symbol type   = Global      Value  = 60  	Symbol# 1: "fopen" 	    String index  = 5           Ifd    = 1 	    Storage class = Nil         Index  = 1048575 	    Symbol type   = Proc        Value  = 0  	Symbol# 2: "fdopen" 	    String index  = 11          Ifd    = 1 	    Storage class = Nil         Index  = 1048575 	    Symbol type   = Proc        Value  = 0  	Symbol# 3: "freopen" 	    String index  = 18          Ifd    = 1 	    Storage class = Nil         Index  = 1048575 	    Symbol type   = Proc        Value  = 0  	Symbol# 4: "popen" 	    String index  = 26          Ifd    = 1 	    Storage class = Nil         Index  = 1048575 	    Symbol type   = Proc        Value  = 0  	Symbol# 5: "tmpfile" 	    String index  = 32          Ifd    = 1 	    Storage class = Nil         Index  = 1048575 	    Symbol type   = Proc        Value  = 0  	Symbol# 6: "ftell" 	    String index  = 40          Ifd    = 1 	    Storage class = Nil         Index  = 1048575 	    Symbol type   = Proc        Value  = 0  	Symbol# 7: "rewind" 	    String index  = 46          Ifd    = 1 	    Storage class = Nil         Index  = 1048575 	    Symbol type   = Proc        Value  = 0  	Symbol# 8: "setbuf" 	    String index  = 53          Ifd    = 1 	    Storage class = Nil         Index  = 1048575 	    Symbol type   = Proc        Value  = 0  	Symbol# 9: "setbuffer" 	    String index  = 60          Ifd    = 1 	    Storage class = Nil         Index  = 1048575 	    Symbol type   = Proc        Value  = 0  	Symbol# 10: "setlinebuf" 	    String index  = 70          Ifd    = 1 	    Storage class = Nil         Index  = 1048575 	    Symbol type   = Proc        Value  = 0  	Symbol# 11: "fgets" 	    String index  = 81          Ifd    = 1 	    Storage class = Nil         Index  = 1048575 	    Symbol type   = Proc        Value  = 0  	Symbol# 12: "gets" 	    String index  = 87          Ifd    = 1 	    Storage class = Nil         Index  = 1048575 	    Symbol type   = Proc        Value  = 0  	Symbol# 13: "ctermid" 	    String index  = 92          Ifd    = 1 	    Storage class = Nil         Index  = 1048575 	    Symbol type   = Proc        Value  = 0  	Symbol# 14: "cuserid" 	    String index  = 100         Ifd    = 1 	    Storage class = Nil         Index  = 1048575 	    Symbol type   = Proc        Value  = 0  	Symbol# 15: "tempnam" 	    String index  = 108         Ifd    = 1 	    Storage class = Nil         Index  = 1048575 	    Symbol type   = Proc        Value  = 0  	Symbol# 16: "tmpnam" 	    String index  = 116         Ifd    = 1 	    Storage class = Nil         Index  = 1048575 	    Symbol type   = Proc        Value  = 0  	Symbol# 17: "sprintf" 	    String index  = 123         Ifd    = 1 	    Storage class = Nil         Index  = 1048575 	    Symbol type   = Proc        Value  = 0  	Symbol# 18: "main" 	    Type          = int 	    String index  = 131         Ifd    = 0 	    Storage class = Text        Index  = 1 	    Symbol type   = Proc        Value  = 0  	Symbol# 19: "printf" 	    String index  = 136         Ifd    = 0 	    Storage class = Undefined   Index  = 1048575 	    Symbol type   = Proc        Value  = 0     The following auxiliary table entries were unused:      #0               0  0x00000000  void     #2               8  0x00000008  char     #3              16  0x00000010  short     #4              24  0x00000018  int     #5              32  0x00000020  long     #6              40  0x00000028  float     #7              44  0x0000002c  double     #8              12  0x0000000c  unsigned char     #9              20  0x00000014  unsigned short     #10             28  0x0000001c  unsigned int     #11             36  0x00000024  unsigned long     #14              0  0x00000000  void     #15             24  0x00000018  int     #19             32  0x00000020  long     #20             40  0x00000028  float     #21             44  0x0000002c  double     #22             12  0x0000000c  unsigned char     #23             20  0x00000014  unsigned short     #24             28  0x0000001c  unsigned int     #25             36  0x00000024  unsigned long     #26             48  0x00000030  struct no name { ifd = -1, index = 1048575 }  */
end_comment

begin_escape
end_escape

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"version.h"
end_include

begin_include
include|#
directive|include
file|"intl.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|__SABER__
end_ifndef

begin_define
define|#
directive|define
name|saber_stop
parameter_list|()
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|__LINE__
end_ifndef

begin_define
define|#
directive|define
name|__LINE__
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Due to size_t being defined in sys/types.h and different    in stddef.h, we have to do this by hand.....  Note, these    types are correct for MIPS based systems, and may not be    correct for other systems.  Ultrix 4.0 and Silicon Graphics    have this fixed, but since the following is correct, and    the fact that including stddef.h gets you GCC's version    instead of the standard one it's not worth it to fix it.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__OSF1__
argument_list|)
operator|||
name|defined
argument_list|(
name|__OSF__
argument_list|)
operator|||
name|defined
argument_list|(
name|__osf__
argument_list|)
end_if

begin_define
define|#
directive|define
name|Size_t
value|long unsigned int
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|Size_t
value|unsigned int
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|Ptrdiff_t
value|long
end_define

begin_comment
comment|/* The following might be called from obstack or malloc,    so they can't be static.  */
end_comment

begin_decl_stmt
specifier|extern
name|void
name|pfatal_with_name
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
name|ATTRIBUTE_NORETURN
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|fancy_abort
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
name|ATTRIBUTE_NORETURN
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|botch
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
name|ATTRIBUTE_NORETURN
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|fatal
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|format
operator|,
operator|...
operator|)
argument_list|)
name|ATTRIBUTE_PRINTF_1
name|ATTRIBUTE_NORETURN
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|error
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|format
operator|,
operator|...
operator|)
argument_list|)
name|ATTRIBUTE_PRINTF_1
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_ifndef
ifndef|#
directive|ifndef
name|MIPS_DEBUGGING_INFO
end_ifndef

begin_decl_stmt
specifier|static
name|int
name|line_number
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cur_line_start
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|debug
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|had_errors
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|progname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|input_name
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|main
parameter_list|()
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Mips-tfile should only be run on a MIPS computer!\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* MIPS_DEBUGGING defined */
end_comment

begin_escape
end_escape

begin_comment
comment|/* The local and global symbols have a field index, so undo any defines    of index -> strchr.  */
end_comment

begin_undef
undef|#
directive|undef
name|index
end_undef

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|CROSS_COMPILE
end_ifndef

begin_include
include|#
directive|include
file|<a.out.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"mips/a.out.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CROSS_COMPILE */
end_comment

begin_include
include|#
directive|include
file|"gstab.h"
end_include

begin_define
define|#
directive|define
name|STAB_CODE_TYPE
value|enum __stab_debug_code
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|MALLOC_CHECK
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|__SABER__
end_ifdef

begin_define
define|#
directive|define
name|MALLOC_CHECK
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|IS_ASM_IDENT
parameter_list|(
name|ch
parameter_list|)
define|\
value|(ISIDNUM (ch) || (ch) == '.' || (ch) == '$')
end_define

begin_escape
end_escape

begin_comment
comment|/* Redefinition of storage classes as an enumeration for better    debugging.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
name|sc
block|{
name|sc_Nil
init|=
name|scNil
block|,
comment|/* no storage class */
name|sc_Text
init|=
name|scText
block|,
comment|/* text symbol */
name|sc_Data
init|=
name|scData
block|,
comment|/* initialized data symbol */
name|sc_Bss
init|=
name|scBss
block|,
comment|/* un-initialized data symbol */
name|sc_Register
init|=
name|scRegister
block|,
comment|/* value of symbol is register number */
name|sc_Abs
init|=
name|scAbs
block|,
comment|/* value of symbol is absolute */
name|sc_Undefined
init|=
name|scUndefined
block|,
comment|/* who knows? */
name|sc_CdbLocal
init|=
name|scCdbLocal
block|,
comment|/* variable's value is IN se->va.?? */
name|sc_Bits
init|=
name|scBits
block|,
comment|/* this is a bit field */
name|sc_CdbSystem
init|=
name|scCdbSystem
block|,
comment|/* value is IN CDB's address space */
name|sc_RegImage
init|=
name|scRegImage
block|,
comment|/* register value saved on stack */
name|sc_Info
init|=
name|scInfo
block|,
comment|/* symbol contains debugger information */
name|sc_UserStruct
init|=
name|scUserStruct
block|,
comment|/* addr in struct user for current process */
name|sc_SData
init|=
name|scSData
block|,
comment|/* load time only small data */
name|sc_SBss
init|=
name|scSBss
block|,
comment|/* load time only small common */
name|sc_RData
init|=
name|scRData
block|,
comment|/* load time only read only data */
name|sc_Var
init|=
name|scVar
block|,
comment|/* Var parameter (fortran,pascal) */
name|sc_Common
init|=
name|scCommon
block|,
comment|/* common variable */
name|sc_SCommon
init|=
name|scSCommon
block|,
comment|/* small common */
name|sc_VarRegister
init|=
name|scVarRegister
block|,
comment|/* Var parameter in a register */
name|sc_Variant
init|=
name|scVariant
block|,
comment|/* Variant record */
name|sc_SUndefined
init|=
name|scSUndefined
block|,
comment|/* small undefined(external) data */
name|sc_Init
init|=
name|scInit
block|,
comment|/* .init section symbol */
name|sc_Max
init|=
name|scMax
comment|/* Max storage class+1 */
block|}
name|sc_t
typedef|;
end_typedef

begin_comment
comment|/* Redefinition of symbol type.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
name|st
block|{
name|st_Nil
init|=
name|stNil
block|,
comment|/* Nuthin' special */
name|st_Global
init|=
name|stGlobal
block|,
comment|/* external symbol */
name|st_Static
init|=
name|stStatic
block|,
comment|/* static */
name|st_Param
init|=
name|stParam
block|,
comment|/* procedure argument */
name|st_Local
init|=
name|stLocal
block|,
comment|/* local variable */
name|st_Label
init|=
name|stLabel
block|,
comment|/* label */
name|st_Proc
init|=
name|stProc
block|,
comment|/*     "      "	 Procedure */
name|st_Block
init|=
name|stBlock
block|,
comment|/* beginning of block */
name|st_End
init|=
name|stEnd
block|,
comment|/* end (of anything) */
name|st_Member
init|=
name|stMember
block|,
comment|/* member (of anything	- struct/union/enum */
name|st_Typedef
init|=
name|stTypedef
block|,
comment|/* type definition */
name|st_File
init|=
name|stFile
block|,
comment|/* file name */
name|st_RegReloc
init|=
name|stRegReloc
block|,
comment|/* register relocation */
name|st_Forward
init|=
name|stForward
block|,
comment|/* forwarding address */
name|st_StaticProc
init|=
name|stStaticProc
block|,
comment|/* load time only static procs */
name|st_Constant
init|=
name|stConstant
block|,
comment|/* const */
name|st_Str
init|=
name|stStr
block|,
comment|/* string */
name|st_Number
init|=
name|stNumber
block|,
comment|/* pure number (ie. 4 NOR 2+2) */
name|st_Expr
init|=
name|stExpr
block|,
comment|/* 2+2 vs. 4 */
name|st_Type
init|=
name|stType
block|,
comment|/* post-coercion SER */
name|st_Max
init|=
name|stMax
comment|/* max type+1 */
block|}
name|st_t
typedef|;
end_typedef

begin_comment
comment|/* Redefinition of type qualifiers.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
name|tq
block|{
name|tq_Nil
init|=
name|tqNil
block|,
comment|/* bt is what you see */
name|tq_Ptr
init|=
name|tqPtr
block|,
comment|/* pointer */
name|tq_Proc
init|=
name|tqProc
block|,
comment|/* procedure */
name|tq_Array
init|=
name|tqArray
block|,
comment|/* duh */
name|tq_Far
init|=
name|tqFar
block|,
comment|/* longer addressing - 8086/8 land */
name|tq_Vol
init|=
name|tqVol
block|,
comment|/* volatile */
name|tq_Max
init|=
name|tqMax
comment|/* Max type qualifier+1 */
block|}
name|tq_t
typedef|;
end_typedef

begin_comment
comment|/* Redefinition of basic types.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
name|bt
block|{
name|bt_Nil
init|=
name|btNil
block|,
comment|/* undefined */
name|bt_Adr
init|=
name|btAdr
block|,
comment|/* address - integer same size as pointer */
name|bt_Char
init|=
name|btChar
block|,
comment|/* character */
name|bt_UChar
init|=
name|btUChar
block|,
comment|/* unsigned character */
name|bt_Short
init|=
name|btShort
block|,
comment|/* short */
name|bt_UShort
init|=
name|btUShort
block|,
comment|/* unsigned short */
name|bt_Int
init|=
name|btInt
block|,
comment|/* int */
name|bt_UInt
init|=
name|btUInt
block|,
comment|/* unsigned int */
name|bt_Long
init|=
name|btLong
block|,
comment|/* long */
name|bt_ULong
init|=
name|btULong
block|,
comment|/* unsigned long */
name|bt_Float
init|=
name|btFloat
block|,
comment|/* float (real) */
name|bt_Double
init|=
name|btDouble
block|,
comment|/* Double (real) */
name|bt_Struct
init|=
name|btStruct
block|,
comment|/* Structure (Record) */
name|bt_Union
init|=
name|btUnion
block|,
comment|/* Union (variant) */
name|bt_Enum
init|=
name|btEnum
block|,
comment|/* Enumerated */
name|bt_Typedef
init|=
name|btTypedef
block|,
comment|/* defined via a typedef, isymRef points */
name|bt_Range
init|=
name|btRange
block|,
comment|/* subrange of int */
name|bt_Set
init|=
name|btSet
block|,
comment|/* pascal sets */
name|bt_Complex
init|=
name|btComplex
block|,
comment|/* fortran complex */
name|bt_DComplex
init|=
name|btDComplex
block|,
comment|/* fortran double complex */
name|bt_Indirect
init|=
name|btIndirect
block|,
comment|/* forward or unnamed typedef */
name|bt_FixedDec
init|=
name|btFixedDec
block|,
comment|/* Fixed Decimal */
name|bt_FloatDec
init|=
name|btFloatDec
block|,
comment|/* Float Decimal */
name|bt_String
init|=
name|btString
block|,
comment|/* Varying Length Character String */
name|bt_Bit
init|=
name|btBit
block|,
comment|/* Aligned Bit String */
name|bt_Picture
init|=
name|btPicture
block|,
comment|/* Picture */
ifdef|#
directive|ifdef
name|btVoid
name|bt_Void
init|=
name|btVoid
block|,
comment|/* Void */
else|#
directive|else
define|#
directive|define
name|bt_Void
value|bt_Nil
endif|#
directive|endif
name|bt_Max
init|=
name|btMax
comment|/* Max basic type+1 */
block|}
name|bt_t
typedef|;
end_typedef

begin_escape
end_escape

begin_comment
comment|/* Basic COFF storage classes.  */
end_comment

begin_enum
enum|enum
name|coff_storage
block|{
name|C_EFCN
init|=
operator|-
literal|1
block|,
name|C_NULL
init|=
literal|0
block|,
name|C_AUTO
init|=
literal|1
block|,
name|C_EXT
init|=
literal|2
block|,
name|C_STAT
init|=
literal|3
block|,
name|C_REG
init|=
literal|4
block|,
name|C_EXTDEF
init|=
literal|5
block|,
name|C_LABEL
init|=
literal|6
block|,
name|C_ULABEL
init|=
literal|7
block|,
name|C_MOS
init|=
literal|8
block|,
name|C_ARG
init|=
literal|9
block|,
name|C_STRTAG
init|=
literal|10
block|,
name|C_MOU
init|=
literal|11
block|,
name|C_UNTAG
init|=
literal|12
block|,
name|C_TPDEF
init|=
literal|13
block|,
name|C_USTATIC
init|=
literal|14
block|,
name|C_ENTAG
init|=
literal|15
block|,
name|C_MOE
init|=
literal|16
block|,
name|C_REGPARM
init|=
literal|17
block|,
name|C_FIELD
init|=
literal|18
block|,
name|C_BLOCK
init|=
literal|100
block|,
name|C_FCN
init|=
literal|101
block|,
name|C_EOS
init|=
literal|102
block|,
name|C_FILE
init|=
literal|103
block|,
name|C_LINE
init|=
literal|104
block|,
name|C_ALIAS
init|=
literal|105
block|,
name|C_HIDDEN
init|=
literal|106
block|,
name|C_MAX
init|=
literal|107
block|}
name|coff_storage_t
enum|;
end_enum

begin_comment
comment|/* Regular COFF fundamental type.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
name|coff_type
block|{
name|T_NULL
init|=
literal|0
block|,
name|T_ARG
init|=
literal|1
block|,
name|T_CHAR
init|=
literal|2
block|,
name|T_SHORT
init|=
literal|3
block|,
name|T_INT
init|=
literal|4
block|,
name|T_LONG
init|=
literal|5
block|,
name|T_FLOAT
init|=
literal|6
block|,
name|T_DOUBLE
init|=
literal|7
block|,
name|T_STRUCT
init|=
literal|8
block|,
name|T_UNION
init|=
literal|9
block|,
name|T_ENUM
init|=
literal|10
block|,
name|T_MOE
init|=
literal|11
block|,
name|T_UCHAR
init|=
literal|12
block|,
name|T_USHORT
init|=
literal|13
block|,
name|T_UINT
init|=
literal|14
block|,
name|T_ULONG
init|=
literal|15
block|,
name|T_MAX
init|=
literal|16
block|}
name|coff_type_t
typedef|;
end_typedef

begin_comment
comment|/* Regular COFF derived types.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
name|coff_dt
block|{
name|DT_NON
init|=
literal|0
block|,
name|DT_PTR
init|=
literal|1
block|,
name|DT_FCN
init|=
literal|2
block|,
name|DT_ARY
init|=
literal|3
block|,
name|DT_MAX
init|=
literal|4
block|}
name|coff_dt_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|N_BTMASK
value|017
end_define

begin_comment
comment|/* bitmask to isolate basic type */
end_comment

begin_define
define|#
directive|define
name|N_TMASK
value|003
end_define

begin_comment
comment|/* bitmask to isolate derived type */
end_comment

begin_define
define|#
directive|define
name|N_BT_SHIFT
value|4
end_define

begin_comment
comment|/* # bits to shift past basic type */
end_comment

begin_define
define|#
directive|define
name|N_TQ_SHIFT
value|2
end_define

begin_comment
comment|/* # bits to shift derived types */
end_comment

begin_define
define|#
directive|define
name|N_TQ
value|6
end_define

begin_comment
comment|/* # of type qualifiers */
end_comment

begin_comment
comment|/* States for whether to hash type or not.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
name|hash_state
block|{
name|hash_no
init|=
literal|0
block|,
comment|/* don't hash type */
name|hash_yes
init|=
literal|1
block|,
comment|/* ok to hash type, or use previous hash */
name|hash_record
init|=
literal|2
comment|/* ok to record hash, but don't use prev.  */
block|}
name|hash_state_t
typedef|;
end_typedef

begin_comment
comment|/* Types of different sized allocation requests.  */
end_comment

begin_enum
enum|enum
name|alloc_type
block|{
name|alloc_type_none
block|,
comment|/* dummy value */
name|alloc_type_scope
block|,
comment|/* nested scopes linked list */
name|alloc_type_vlinks
block|,
comment|/* glue linking pages in varray */
name|alloc_type_shash
block|,
comment|/* string hash element */
name|alloc_type_thash
block|,
comment|/* type hash element */
name|alloc_type_tag
block|,
comment|/* struct/union/tag element */
name|alloc_type_forward
block|,
comment|/* element to hold unknown tag */
name|alloc_type_thead
block|,
comment|/* head of type hash list */
name|alloc_type_varray
block|,
comment|/* general varray allocation */
name|alloc_type_last
comment|/* last+1 element for array bounds */
block|}
enum|;
end_enum

begin_escape
end_escape

begin_define
define|#
directive|define
name|WORD_ALIGN
parameter_list|(
name|x
parameter_list|)
value|(((x) + (sizeof (long) - 1))& ~ (sizeof (long) - 1))
end_define

begin_define
define|#
directive|define
name|DWORD_ALIGN
parameter_list|(
name|x
parameter_list|)
value|(((x) + 7)& ~7)
end_define

begin_comment
comment|/* Structures to provide n-number of virtual arrays, each of which can    grow linearly, and which are written in the object file as sequential    pages.  On systems with a BSD malloc that define USE_MALLOC, the    MAX_CLUSTER_PAGES should be 1 less than a power of two, since malloc    adds its overhead, and rounds up to the next power of 2.  Pages are    linked together via a linked list.     If PAGE_SIZE is> 4096, the string length in the shash_t structure    can't be represented (assuming there are strings> 4096 bytes).  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|PAGE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|PAGE_SIZE
value|4096
end_define

begin_comment
comment|/* size of varray pages */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|PAGE_USIZE
value|((Size_t) PAGE_SIZE)
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|MAX_CLUSTER_PAGES
end_ifndef

begin_comment
comment|/* # pages to get from system */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|USE_MALLOC
end_ifndef

begin_comment
comment|/* in one memory request */
end_comment

begin_define
define|#
directive|define
name|MAX_CLUSTER_PAGES
value|64
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|MAX_CLUSTER_PAGES
value|63
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Linked list connecting separate page allocations.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|vlinks
block|{
name|struct
name|vlinks
modifier|*
name|prev
decl_stmt|;
comment|/* previous set of pages */
name|struct
name|vlinks
modifier|*
name|next
decl_stmt|;
comment|/* next set of pages */
name|union
name|page
modifier|*
name|datum
decl_stmt|;
comment|/* start of page */
name|unsigned
name|long
name|start_index
decl_stmt|;
comment|/* starting index # of page */
block|}
name|vlinks_t
typedef|;
end_typedef

begin_comment
comment|/* Virtual array header.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|varray
block|{
name|vlinks_t
modifier|*
name|first
decl_stmt|;
comment|/* first page link */
name|vlinks_t
modifier|*
name|last
decl_stmt|;
comment|/* last page link */
name|unsigned
name|long
name|num_allocated
decl_stmt|;
comment|/* # objects allocated */
name|unsigned
name|short
name|object_size
decl_stmt|;
comment|/* size in bytes of each object */
name|unsigned
name|short
name|objects_per_page
decl_stmt|;
comment|/* # objects that can fit on a page */
name|unsigned
name|short
name|objects_last_page
decl_stmt|;
comment|/* # objects allocated on last page */
block|}
name|varray_t
typedef|;
end_typedef

begin_ifndef
ifndef|#
directive|ifndef
name|MALLOC_CHECK
end_ifndef

begin_define
define|#
directive|define
name|OBJECTS_PER_PAGE
parameter_list|(
name|type
parameter_list|)
value|(PAGE_SIZE / sizeof (type))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|OBJECTS_PER_PAGE
parameter_list|(
name|type
parameter_list|)
value|((sizeof (type)> 1) ? 1 : PAGE_SIZE)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|INIT_VARRAY
parameter_list|(
name|type
parameter_list|)
value|{
comment|/* macro to initialize a varray */
value|\   (vlinks_t *) 0,
comment|/* first */
value|\   (vlinks_t *) 0,
comment|/* last */
value|\   0,
comment|/* num_allocated */
value|\   sizeof (type),
comment|/* object_size */
value|\   OBJECTS_PER_PAGE (type),
comment|/* objects_per_page */
value|\   OBJECTS_PER_PAGE (type),
comment|/* objects_last_page */
value|\ }
end_define

begin_comment
comment|/* Master type for indexes within the symbol table.  */
end_comment

begin_typedef
typedef|typedef
name|unsigned
name|long
name|symint_t
typedef|;
end_typedef

begin_comment
comment|/* Linked list support for nested scopes (file, block, structure, etc.).  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|scope
block|{
name|struct
name|scope
modifier|*
name|prev
decl_stmt|;
comment|/* previous scope level */
name|struct
name|scope
modifier|*
name|free
decl_stmt|;
comment|/* free list pointer */
name|SYMR
modifier|*
name|lsym
decl_stmt|;
comment|/* pointer to local symbol node */
name|symint_t
name|lnumber
decl_stmt|;
comment|/* lsym index */
name|st_t
name|type
decl_stmt|;
comment|/* type of the node */
block|}
name|scope_t
typedef|;
end_typedef

begin_comment
comment|/* Forward reference list for tags referenced, but not yet defined.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|forward
block|{
name|struct
name|forward
modifier|*
name|next
decl_stmt|;
comment|/* next forward reference */
name|struct
name|forward
modifier|*
name|free
decl_stmt|;
comment|/* free list pointer */
name|AUXU
modifier|*
name|ifd_ptr
decl_stmt|;
comment|/* pointer to store file index */
name|AUXU
modifier|*
name|index_ptr
decl_stmt|;
comment|/* pointer to store symbol index */
name|AUXU
modifier|*
name|type_ptr
decl_stmt|;
comment|/* pointer to munge type info */
block|}
name|forward_t
typedef|;
end_typedef

begin_comment
comment|/* Linked list support for tags.  The first tag in the list is always    the current tag for that block.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|tag
block|{
name|struct
name|tag
modifier|*
name|free
decl_stmt|;
comment|/* free list pointer */
name|struct
name|shash
modifier|*
name|hash_ptr
decl_stmt|;
comment|/* pointer to the hash table head */
name|struct
name|tag
modifier|*
name|same_name
decl_stmt|;
comment|/* tag with same name in outer scope */
name|struct
name|tag
modifier|*
name|same_block
decl_stmt|;
comment|/* next tag defined in the same block.  */
name|struct
name|forward
modifier|*
name|forward_ref
decl_stmt|;
comment|/* list of forward references */
name|bt_t
name|basic_type
decl_stmt|;
comment|/* bt_Struct, bt_Union, or bt_Enum */
name|symint_t
name|ifd
decl_stmt|;
comment|/* file # tag defined in */
name|symint_t
name|indx
decl_stmt|;
comment|/* index within file's local symbols */
block|}
name|tag_t
typedef|;
end_typedef

begin_comment
comment|/* Head of a block's linked list of tags.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|thead
block|{
name|struct
name|thead
modifier|*
name|prev
decl_stmt|;
comment|/* previous block */
name|struct
name|thead
modifier|*
name|free
decl_stmt|;
comment|/* free list pointer */
name|struct
name|tag
modifier|*
name|first_tag
decl_stmt|;
comment|/* first tag in block defined */
block|}
name|thead_t
typedef|;
end_typedef

begin_comment
comment|/* Union containing pointers to each the small structures which are freed up.  */
end_comment

begin_typedef
typedef|typedef
union|union
name|small_free
block|{
name|scope_t
modifier|*
name|f_scope
decl_stmt|;
comment|/* scope structure */
name|thead_t
modifier|*
name|f_thead
decl_stmt|;
comment|/* tag head structure */
name|tag_t
modifier|*
name|f_tag
decl_stmt|;
comment|/* tag element structure */
name|forward_t
modifier|*
name|f_forward
decl_stmt|;
comment|/* forward tag reference */
block|}
name|small_free_t
typedef|;
end_typedef

begin_comment
comment|/* String hash table support.  The size of the hash table must fit    within a page.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SHASH_SIZE
end_ifndef

begin_define
define|#
directive|define
name|SHASH_SIZE
value|1009
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|HASH_LEN_MAX
value|((1<< 12) - 1)
end_define

begin_comment
comment|/* Max length we can store */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|shash
block|{
name|struct
name|shash
modifier|*
name|next
decl_stmt|;
comment|/* next hash value */
name|char
modifier|*
name|string
decl_stmt|;
comment|/* string we are hashing */
name|symint_t
name|len
decl_stmt|;
comment|/* string length */
name|symint_t
name|indx
decl_stmt|;
comment|/* index within string table */
name|EXTR
modifier|*
name|esym_ptr
decl_stmt|;
comment|/* global symbol pointer */
name|SYMR
modifier|*
name|sym_ptr
decl_stmt|;
comment|/* local symbol pointer */
name|SYMR
modifier|*
name|end_ptr
decl_stmt|;
comment|/* symbol pointer to end block */
name|tag_t
modifier|*
name|tag_ptr
decl_stmt|;
comment|/* tag pointer */
name|PDR
modifier|*
name|proc_ptr
decl_stmt|;
comment|/* procedure descriptor pointer */
block|}
name|shash_t
typedef|;
end_typedef

begin_comment
comment|/* Type hash table support.  The size of the hash table must fit    within a page with the other extended file descriptor information.    Because unique types which are hashed are fewer in number than    strings, we use a smaller hash value.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|THASH_SIZE
end_ifndef

begin_define
define|#
directive|define
name|THASH_SIZE
value|113
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_typedef
typedef|typedef
struct|struct
name|thash
block|{
name|struct
name|thash
modifier|*
name|next
decl_stmt|;
comment|/* next hash value */
name|AUXU
name|type
decl_stmt|;
comment|/* type we are hashing */
name|symint_t
name|indx
decl_stmt|;
comment|/* index within string table */
block|}
name|thash_t
typedef|;
end_typedef

begin_comment
comment|/* Extended file descriptor that contains all of the support necessary    to add things to each file separately.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|efdr
block|{
name|FDR
name|fdr
decl_stmt|;
comment|/* File header to be written out */
name|FDR
modifier|*
name|orig_fdr
decl_stmt|;
comment|/* original file header */
name|char
modifier|*
name|name
decl_stmt|;
comment|/* filename */
name|int
name|name_len
decl_stmt|;
comment|/* length of the filename */
name|symint_t
name|void_type
decl_stmt|;
comment|/* aux. pointer to 'void' type */
name|symint_t
name|int_type
decl_stmt|;
comment|/* aux. pointer to 'int' type */
name|scope_t
modifier|*
name|cur_scope
decl_stmt|;
comment|/* current nested scopes */
name|symint_t
name|file_index
decl_stmt|;
comment|/* current file number */
name|int
name|nested_scopes
decl_stmt|;
comment|/* # nested scopes */
name|varray_t
name|strings
decl_stmt|;
comment|/* local strings */
name|varray_t
name|symbols
decl_stmt|;
comment|/* local symbols */
name|varray_t
name|procs
decl_stmt|;
comment|/* procedures */
name|varray_t
name|aux_syms
decl_stmt|;
comment|/* auxiliary symbols */
name|struct
name|efdr
modifier|*
name|next_file
decl_stmt|;
comment|/* next file descriptor */
comment|/* string/type hash tables */
name|shash_t
modifier|*
modifier|*
name|shash_head
decl_stmt|;
comment|/* string hash table */
name|thash_t
modifier|*
name|thash_head
index|[
name|THASH_SIZE
index|]
decl_stmt|;
block|}
name|efdr_t
typedef|;
end_typedef

begin_comment
comment|/* Pre-initialized extended file structure.  */
end_comment

begin_decl_stmt
specifier|static
name|efdr_t
name|init_file
init|=
block|{
block|{
comment|/* FDR structure */
ifdef|#
directive|ifdef
name|__alpha
literal|0
block|,
comment|/* adr:		memory address of beginning of file */
literal|0
block|,
comment|/* cbLineOffset: byte offset from header for this file ln's */
literal|0
block|,
comment|/* cbLine:	size of lines for this file */
literal|0
block|,
comment|/* cbSs:	number of bytes in the ss */
literal|0
block|,
comment|/* rss:		file name (of source, if known) */
literal|0
block|,
comment|/* issBase:	file's string space */
literal|0
block|,
comment|/* isymBase:	beginning of symbols */
literal|0
block|,
comment|/* csym:	count file's of symbols */
literal|0
block|,
comment|/* ilineBase:	file's line symbols */
literal|0
block|,
comment|/* cline:	count of file's line symbols */
literal|0
block|,
comment|/* ioptBase:	file's optimization entries */
literal|0
block|,
comment|/* copt:	count of file's optimization entries */
literal|0
block|,
comment|/* ipdFirst:	start of procedures for this file */
literal|0
block|,
comment|/* cpd:		count of procedures for this file */
literal|0
block|,
comment|/* iauxBase:	file's auxiliary entries */
literal|0
block|,
comment|/* caux:	count of file's auxiliary entries */
literal|0
block|,
comment|/* rfdBase:	index into the file indirect table */
literal|0
block|,
comment|/* crfd:	count file indirect entries */
name|langC
block|,
comment|/* lang:	language for this file */
literal|1
block|,
comment|/* fMerge:	whether this file can be merged */
literal|0
block|,
comment|/* fReadin:	true if read in (not just created) */
ifdef|#
directive|ifdef
name|HOST_WORDS_BIG_ENDIAN
literal|1
block|,
comment|/* fBigendian:	if 1, compiled on big endian machine */
else|#
directive|else
literal|0
block|,
comment|/* fBigendian:	if 1, compiled on big endian machine */
endif|#
directive|endif
literal|0
block|,
comment|/* fTrim:	whether the symbol table was trimmed */
name|GLEVEL_2
block|,
comment|/* glevel:	level this file was compiled with */
literal|0
block|,
comment|/* reserved:	reserved for future use */
else|#
directive|else
literal|0
block|,
comment|/* adr:		memory address of beginning of file */
literal|0
block|,
comment|/* rss:		file name (of source, if known) */
literal|0
block|,
comment|/* issBase:	file's string space */
literal|0
block|,
comment|/* cbSs:	number of bytes in the ss */
literal|0
block|,
comment|/* isymBase:	beginning of symbols */
literal|0
block|,
comment|/* csym:	count file's of symbols */
literal|0
block|,
comment|/* ilineBase:	file's line symbols */
literal|0
block|,
comment|/* cline:	count of file's line symbols */
literal|0
block|,
comment|/* ioptBase:	file's optimization entries */
literal|0
block|,
comment|/* copt:	count of file's optimization entries */
literal|0
block|,
comment|/* ipdFirst:	start of procedures for this file */
literal|0
block|,
comment|/* cpd:		count of procedures for this file */
literal|0
block|,
comment|/* iauxBase:	file's auxiliary entries */
literal|0
block|,
comment|/* caux:	count of file's auxiliary entries */
literal|0
block|,
comment|/* rfdBase:	index into the file indirect table */
literal|0
block|,
comment|/* crfd:	count file indirect entries */
name|langC
block|,
comment|/* lang:	language for this file */
literal|1
block|,
comment|/* fMerge:	whether this file can be merged */
literal|0
block|,
comment|/* fReadin:	true if read in (not just created) */
ifdef|#
directive|ifdef
name|HOST_WORDS_BIG_ENDIAN
literal|1
block|,
comment|/* fBigendian:	if 1, compiled on big endian machine */
else|#
directive|else
literal|0
block|,
comment|/* fBigendian:	if 1, compiled on big endian machine */
endif|#
directive|endif
name|GLEVEL_2
block|,
comment|/* glevel:	level this file was compiled with */
literal|0
block|,
comment|/* reserved:	reserved for future use */
literal|0
block|,
comment|/* cbLineOffset: byte offset from header for this file ln's */
literal|0
block|,
comment|/* cbLine:	size of lines for this file */
endif|#
directive|endif
block|}
block|,
operator|(
name|FDR
operator|*
operator|)
literal|0
block|,
comment|/* orig_fdr:	original file header pointer */
operator|(
name|char
operator|*
operator|)
literal|0
block|,
comment|/* name:	pointer to filename */
literal|0
block|,
comment|/* name_len:	length of filename */
literal|0
block|,
comment|/* void_type:	ptr to aux node for void type */
literal|0
block|,
comment|/* int_type:	ptr to aux node for int type */
operator|(
name|scope_t
operator|*
operator|)
literal|0
block|,
comment|/* cur_scope:	current scope being processed */
literal|0
block|,
comment|/* file_index:	current file # */
literal|0
block|,
comment|/* nested_scopes: # nested scopes */
name|INIT_VARRAY
argument_list|(
name|char
argument_list|)
block|,
comment|/* strings:	local string varray */
name|INIT_VARRAY
argument_list|(
name|SYMR
argument_list|)
block|,
comment|/* symbols:	local symbols varray */
name|INIT_VARRAY
argument_list|(
name|PDR
argument_list|)
block|,
comment|/* procs:	procedure varray */
name|INIT_VARRAY
argument_list|(
name|AUXU
argument_list|)
block|,
comment|/* aux_syms:	auxiliary symbols varray */
operator|(
expr|struct
name|efdr
operator|*
operator|)
literal|0
block|,
comment|/* next_file:	next file structure */
operator|(
name|shash_t
operator|*
operator|*
operator|)
literal|0
block|,
comment|/* shash_head:	string hash table */
block|{
literal|0
block|}
block|,
comment|/* thash_head:	type hash table */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|efdr_t
modifier|*
name|first_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* first file descriptor */
end_comment

begin_decl_stmt
specifier|static
name|efdr_t
modifier|*
modifier|*
name|last_file_ptr
init|=
operator|&
name|first_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* file descriptor tail */
end_comment

begin_comment
comment|/* Union of various things that are held in pages.  */
end_comment

begin_typedef
typedef|typedef
union|union
name|page
block|{
name|char
name|byte
index|[
name|PAGE_SIZE
index|]
decl_stmt|;
name|unsigned
name|char
name|ubyte
index|[
name|PAGE_SIZE
index|]
decl_stmt|;
name|efdr_t
name|file
index|[
name|PAGE_SIZE
operator|/
sizeof|sizeof
argument_list|(
name|efdr_t
argument_list|)
index|]
decl_stmt|;
name|FDR
name|ofile
index|[
name|PAGE_SIZE
operator|/
sizeof|sizeof
argument_list|(
name|FDR
argument_list|)
index|]
decl_stmt|;
name|PDR
name|proc
index|[
name|PAGE_SIZE
operator|/
sizeof|sizeof
argument_list|(
name|PDR
argument_list|)
index|]
decl_stmt|;
name|SYMR
name|sym
index|[
name|PAGE_SIZE
operator|/
sizeof|sizeof
argument_list|(
name|SYMR
argument_list|)
index|]
decl_stmt|;
name|EXTR
name|esym
index|[
name|PAGE_SIZE
operator|/
sizeof|sizeof
argument_list|(
name|EXTR
argument_list|)
index|]
decl_stmt|;
name|AUXU
name|aux
index|[
name|PAGE_SIZE
operator|/
sizeof|sizeof
argument_list|(
name|AUXU
argument_list|)
index|]
decl_stmt|;
name|DNR
name|dense
index|[
name|PAGE_SIZE
operator|/
sizeof|sizeof
argument_list|(
name|DNR
argument_list|)
index|]
decl_stmt|;
name|scope_t
name|scope
index|[
name|PAGE_SIZE
operator|/
sizeof|sizeof
argument_list|(
name|scope_t
argument_list|)
index|]
decl_stmt|;
name|vlinks_t
name|vlinks
index|[
name|PAGE_SIZE
operator|/
sizeof|sizeof
argument_list|(
name|vlinks_t
argument_list|)
index|]
decl_stmt|;
name|shash_t
name|shash
index|[
name|PAGE_SIZE
operator|/
sizeof|sizeof
argument_list|(
name|shash_t
argument_list|)
index|]
decl_stmt|;
name|thash_t
name|thash
index|[
name|PAGE_SIZE
operator|/
sizeof|sizeof
argument_list|(
name|thash_t
argument_list|)
index|]
decl_stmt|;
name|tag_t
name|tag
index|[
name|PAGE_SIZE
operator|/
sizeof|sizeof
argument_list|(
name|tag_t
argument_list|)
index|]
decl_stmt|;
name|forward_t
name|forward
index|[
name|PAGE_SIZE
operator|/
sizeof|sizeof
argument_list|(
name|forward_t
argument_list|)
index|]
decl_stmt|;
name|thead_t
name|thead
index|[
name|PAGE_SIZE
operator|/
sizeof|sizeof
argument_list|(
name|thead_t
argument_list|)
index|]
decl_stmt|;
block|}
name|page_t
typedef|;
end_typedef

begin_comment
comment|/* Structure holding allocation information for small sized structures.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|alloc_info
block|{
specifier|const
name|char
modifier|*
name|alloc_name
decl_stmt|;
comment|/* name of this allocation type (must be first) */
name|page_t
modifier|*
name|cur_page
decl_stmt|;
comment|/* current page being allocated from */
name|small_free_t
name|free_list
decl_stmt|;
comment|/* current free list if any */
name|int
name|unallocated
decl_stmt|;
comment|/* number of elements unallocated on page */
name|int
name|total_alloc
decl_stmt|;
comment|/* total number of allocations */
name|int
name|total_free
decl_stmt|;
comment|/* total number of frees */
name|int
name|total_pages
decl_stmt|;
comment|/* total number of pages allocated */
block|}
name|alloc_info_t
typedef|;
end_typedef

begin_comment
comment|/* Type information collected together.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|type_info
block|{
name|bt_t
name|basic_type
decl_stmt|;
comment|/* basic type */
name|coff_type_t
name|orig_type
decl_stmt|;
comment|/* original COFF-based type */
name|int
name|num_tq
decl_stmt|;
comment|/* # type qualifiers */
name|int
name|num_dims
decl_stmt|;
comment|/* # dimensions */
name|int
name|num_sizes
decl_stmt|;
comment|/* # sizes */
name|int
name|extra_sizes
decl_stmt|;
comment|/* # extra sizes not tied with dims */
name|tag_t
modifier|*
name|tag_ptr
decl_stmt|;
comment|/* tag pointer */
name|int
name|bitfield
decl_stmt|;
comment|/* symbol is a bitfield */
name|int
name|unknown_tag
decl_stmt|;
comment|/* this is an unknown tag */
name|tq_t
name|type_qualifiers
index|[
name|N_TQ
index|]
decl_stmt|;
comment|/* type qualifiers (ptr, func, array)*/
name|symint_t
name|dimensions
index|[
name|N_TQ
index|]
decl_stmt|;
comment|/* dimensions for each array */
name|symint_t
name|sizes
index|[
name|N_TQ
operator|+
literal|2
index|]
decl_stmt|;
comment|/* sizes of each array slice + size of 					   struct/union/enum + bitfield size */
block|}
name|type_info_t
typedef|;
end_typedef

begin_comment
comment|/* Pre-initialized type_info struct.  */
end_comment

begin_decl_stmt
specifier|static
name|type_info_t
name|type_info_init
init|=
block|{
name|bt_Nil
block|,
comment|/* basic type */
name|T_NULL
block|,
comment|/* original COFF-based type */
literal|0
block|,
comment|/* # type qualifiers */
literal|0
block|,
comment|/* # dimensions */
literal|0
block|,
comment|/* # sizes */
literal|0
block|,
comment|/* sizes not tied with dims */
name|NULL
block|,
comment|/* ptr to tag */
literal|0
block|,
comment|/* bitfield */
literal|0
block|,
comment|/* unknown tag */
block|{
comment|/* type qualifiers */
name|tq_Nil
block|,
name|tq_Nil
block|,
name|tq_Nil
block|,
name|tq_Nil
block|,
name|tq_Nil
block|,
name|tq_Nil
block|,   }
block|,
block|{
comment|/* dimensions */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
comment|/* sizes */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,   }
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Global virtual arrays& hash table for external strings as well as    for the tags table and global tables for file descriptors, and    dense numbers.  */
end_comment

begin_decl_stmt
specifier|static
name|varray_t
name|file_desc
init|=
name|INIT_VARRAY
argument_list|(
name|efdr_t
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|varray_t
name|dense_num
init|=
name|INIT_VARRAY
argument_list|(
name|DNR
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|varray_t
name|tag_strings
init|=
name|INIT_VARRAY
argument_list|(
name|char
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|varray_t
name|ext_strings
init|=
name|INIT_VARRAY
argument_list|(
name|char
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|varray_t
name|ext_symbols
init|=
name|INIT_VARRAY
argument_list|(
name|EXTR
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|shash_t
modifier|*
name|orig_str_hash
index|[
name|SHASH_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|shash_t
modifier|*
name|ext_str_hash
index|[
name|SHASH_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|shash_t
modifier|*
name|tag_hash
index|[
name|SHASH_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Static types for int and void.  Also, remember the last function's    type (which is set up when we encounter the declaration for the    function, and used when the end block for the function is emitted.  */
end_comment

begin_decl_stmt
specifier|static
name|type_info_t
name|int_type_info
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|type_info_t
name|void_type_info
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|type_info_t
name|last_func_type_info
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|EXTR
modifier|*
name|last_func_eptr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Convert COFF basic type to ECOFF basic type.  The T_NULL type    really should use bt_Void, but this causes the current ecoff GDB to    issue unsupported type messages, and the Ultrix 4.00 dbx (aka MIPS    2.0) doesn't understand it, even though the compiler generates it.    Maybe this will be fixed in 2.10 or 2.20 of the MIPS compiler    suite, but for now go with what works.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|bt_t
name|map_coff_types
index|[
operator|(
name|int
operator|)
name|T_MAX
index|]
init|=
block|{
name|bt_Nil
block|,
comment|/* T_NULL */
name|bt_Nil
block|,
comment|/* T_ARG */
name|bt_Char
block|,
comment|/* T_CHAR */
name|bt_Short
block|,
comment|/* T_SHORT */
name|bt_Int
block|,
comment|/* T_INT */
name|bt_Long
block|,
comment|/* T_LONG */
name|bt_Float
block|,
comment|/* T_FLOAT */
name|bt_Double
block|,
comment|/* T_DOUBLE */
name|bt_Struct
block|,
comment|/* T_STRUCT */
name|bt_Union
block|,
comment|/* T_UNION */
name|bt_Enum
block|,
comment|/* T_ENUM */
name|bt_Enum
block|,
comment|/* T_MOE */
name|bt_UChar
block|,
comment|/* T_UCHAR */
name|bt_UShort
block|,
comment|/* T_USHORT */
name|bt_UInt
block|,
comment|/* T_UINT */
name|bt_ULong
comment|/* T_ULONG */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Convert COFF storage class to ECOFF storage class.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|sc_t
name|map_coff_storage
index|[
operator|(
name|int
operator|)
name|C_MAX
index|]
init|=
block|{
name|sc_Nil
block|,
comment|/*   0: C_NULL */
name|sc_Abs
block|,
comment|/*   1: C_AUTO	  auto var */
name|sc_Undefined
block|,
comment|/*   2: C_EXT	  external */
name|sc_Data
block|,
comment|/*   3: C_STAT	  static */
name|sc_Register
block|,
comment|/*   4: C_REG	  register */
name|sc_Undefined
block|,
comment|/*   5: C_EXTDEF  ??? */
name|sc_Text
block|,
comment|/*   6: C_LABEL	  label */
name|sc_Text
block|,
comment|/*   7: C_ULABEL  user label */
name|sc_Info
block|,
comment|/*   8: C_MOS	  member of struct */
name|sc_Abs
block|,
comment|/*   9: C_ARG	  argument */
name|sc_Info
block|,
comment|/*  10: C_STRTAG  struct tag */
name|sc_Info
block|,
comment|/*  11: C_MOU	  member of union */
name|sc_Info
block|,
comment|/*  12: C_UNTAG   union tag */
name|sc_Info
block|,
comment|/*  13: C_TPDEF	  typedef */
name|sc_Data
block|,
comment|/*  14: C_USTATIC ??? */
name|sc_Info
block|,
comment|/*  15: C_ENTAG	  enum tag */
name|sc_Info
block|,
comment|/*  16: C_MOE	  member of enum */
name|sc_Register
block|,
comment|/*  17: C_REGPARM register parameter */
name|sc_Bits
block|,
comment|/*  18; C_FIELD	  bitfield */
name|sc_Nil
block|,
comment|/*  19 */
name|sc_Nil
block|,
comment|/*  20 */
name|sc_Nil
block|,
comment|/*  21 */
name|sc_Nil
block|,
comment|/*  22 */
name|sc_Nil
block|,
comment|/*  23 */
name|sc_Nil
block|,
comment|/*  24 */
name|sc_Nil
block|,
comment|/*  25 */
name|sc_Nil
block|,
comment|/*  26 */
name|sc_Nil
block|,
comment|/*  27 */
name|sc_Nil
block|,
comment|/*  28 */
name|sc_Nil
block|,
comment|/*  29 */
name|sc_Nil
block|,
comment|/*  30 */
name|sc_Nil
block|,
comment|/*  31 */
name|sc_Nil
block|,
comment|/*  32 */
name|sc_Nil
block|,
comment|/*  33 */
name|sc_Nil
block|,
comment|/*  34 */
name|sc_Nil
block|,
comment|/*  35 */
name|sc_Nil
block|,
comment|/*  36 */
name|sc_Nil
block|,
comment|/*  37 */
name|sc_Nil
block|,
comment|/*  38 */
name|sc_Nil
block|,
comment|/*  39 */
name|sc_Nil
block|,
comment|/*  40 */
name|sc_Nil
block|,
comment|/*  41 */
name|sc_Nil
block|,
comment|/*  42 */
name|sc_Nil
block|,
comment|/*  43 */
name|sc_Nil
block|,
comment|/*  44 */
name|sc_Nil
block|,
comment|/*  45 */
name|sc_Nil
block|,
comment|/*  46 */
name|sc_Nil
block|,
comment|/*  47 */
name|sc_Nil
block|,
comment|/*  48 */
name|sc_Nil
block|,
comment|/*  49 */
name|sc_Nil
block|,
comment|/*  50 */
name|sc_Nil
block|,
comment|/*  51 */
name|sc_Nil
block|,
comment|/*  52 */
name|sc_Nil
block|,
comment|/*  53 */
name|sc_Nil
block|,
comment|/*  54 */
name|sc_Nil
block|,
comment|/*  55 */
name|sc_Nil
block|,
comment|/*  56 */
name|sc_Nil
block|,
comment|/*  57 */
name|sc_Nil
block|,
comment|/*  58 */
name|sc_Nil
block|,
comment|/*  59 */
name|sc_Nil
block|,
comment|/*  60 */
name|sc_Nil
block|,
comment|/*  61 */
name|sc_Nil
block|,
comment|/*  62 */
name|sc_Nil
block|,
comment|/*  63 */
name|sc_Nil
block|,
comment|/*  64 */
name|sc_Nil
block|,
comment|/*  65 */
name|sc_Nil
block|,
comment|/*  66 */
name|sc_Nil
block|,
comment|/*  67 */
name|sc_Nil
block|,
comment|/*  68 */
name|sc_Nil
block|,
comment|/*  69 */
name|sc_Nil
block|,
comment|/*  70 */
name|sc_Nil
block|,
comment|/*  71 */
name|sc_Nil
block|,
comment|/*  72 */
name|sc_Nil
block|,
comment|/*  73 */
name|sc_Nil
block|,
comment|/*  74 */
name|sc_Nil
block|,
comment|/*  75 */
name|sc_Nil
block|,
comment|/*  76 */
name|sc_Nil
block|,
comment|/*  77 */
name|sc_Nil
block|,
comment|/*  78 */
name|sc_Nil
block|,
comment|/*  79 */
name|sc_Nil
block|,
comment|/*  80 */
name|sc_Nil
block|,
comment|/*  81 */
name|sc_Nil
block|,
comment|/*  82 */
name|sc_Nil
block|,
comment|/*  83 */
name|sc_Nil
block|,
comment|/*  84 */
name|sc_Nil
block|,
comment|/*  85 */
name|sc_Nil
block|,
comment|/*  86 */
name|sc_Nil
block|,
comment|/*  87 */
name|sc_Nil
block|,
comment|/*  88 */
name|sc_Nil
block|,
comment|/*  89 */
name|sc_Nil
block|,
comment|/*  90 */
name|sc_Nil
block|,
comment|/*  91 */
name|sc_Nil
block|,
comment|/*  92 */
name|sc_Nil
block|,
comment|/*  93 */
name|sc_Nil
block|,
comment|/*  94 */
name|sc_Nil
block|,
comment|/*  95 */
name|sc_Nil
block|,
comment|/*  96 */
name|sc_Nil
block|,
comment|/*  97 */
name|sc_Nil
block|,
comment|/*  98 */
name|sc_Nil
block|,
comment|/*  99 */
name|sc_Text
block|,
comment|/* 100: C_BLOCK  block start/end */
name|sc_Text
block|,
comment|/* 101: C_FCN	 function start/end */
name|sc_Info
block|,
comment|/* 102: C_EOS	 end of struct/union/enum */
name|sc_Nil
block|,
comment|/* 103: C_FILE	 file start */
name|sc_Nil
block|,
comment|/* 104: C_LINE	 line number */
name|sc_Nil
block|,
comment|/* 105: C_ALIAS	 combined type info */
name|sc_Nil
block|,
comment|/* 106: C_HIDDEN ??? */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Convert COFF storage class to ECOFF symbol type.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|st_t
name|map_coff_sym_type
index|[
operator|(
name|int
operator|)
name|C_MAX
index|]
init|=
block|{
name|st_Nil
block|,
comment|/*   0: C_NULL */
name|st_Local
block|,
comment|/*   1: C_AUTO	  auto var */
name|st_Global
block|,
comment|/*   2: C_EXT	  external */
name|st_Static
block|,
comment|/*   3: C_STAT	  static */
name|st_Local
block|,
comment|/*   4: C_REG	  register */
name|st_Global
block|,
comment|/*   5: C_EXTDEF  ??? */
name|st_Label
block|,
comment|/*   6: C_LABEL	  label */
name|st_Label
block|,
comment|/*   7: C_ULABEL  user label */
name|st_Member
block|,
comment|/*   8: C_MOS	  member of struct */
name|st_Param
block|,
comment|/*   9: C_ARG	  argument */
name|st_Block
block|,
comment|/*  10: C_STRTAG  struct tag */
name|st_Member
block|,
comment|/*  11: C_MOU	  member of union */
name|st_Block
block|,
comment|/*  12: C_UNTAG   union tag */
name|st_Typedef
block|,
comment|/*  13: C_TPDEF	  typedef */
name|st_Static
block|,
comment|/*  14: C_USTATIC ??? */
name|st_Block
block|,
comment|/*  15: C_ENTAG	  enum tag */
name|st_Member
block|,
comment|/*  16: C_MOE	  member of enum */
name|st_Param
block|,
comment|/*  17: C_REGPARM register parameter */
name|st_Member
block|,
comment|/*  18; C_FIELD	  bitfield */
name|st_Nil
block|,
comment|/*  19 */
name|st_Nil
block|,
comment|/*  20 */
name|st_Nil
block|,
comment|/*  21 */
name|st_Nil
block|,
comment|/*  22 */
name|st_Nil
block|,
comment|/*  23 */
name|st_Nil
block|,
comment|/*  24 */
name|st_Nil
block|,
comment|/*  25 */
name|st_Nil
block|,
comment|/*  26 */
name|st_Nil
block|,
comment|/*  27 */
name|st_Nil
block|,
comment|/*  28 */
name|st_Nil
block|,
comment|/*  29 */
name|st_Nil
block|,
comment|/*  30 */
name|st_Nil
block|,
comment|/*  31 */
name|st_Nil
block|,
comment|/*  32 */
name|st_Nil
block|,
comment|/*  33 */
name|st_Nil
block|,
comment|/*  34 */
name|st_Nil
block|,
comment|/*  35 */
name|st_Nil
block|,
comment|/*  36 */
name|st_Nil
block|,
comment|/*  37 */
name|st_Nil
block|,
comment|/*  38 */
name|st_Nil
block|,
comment|/*  39 */
name|st_Nil
block|,
comment|/*  40 */
name|st_Nil
block|,
comment|/*  41 */
name|st_Nil
block|,
comment|/*  42 */
name|st_Nil
block|,
comment|/*  43 */
name|st_Nil
block|,
comment|/*  44 */
name|st_Nil
block|,
comment|/*  45 */
name|st_Nil
block|,
comment|/*  46 */
name|st_Nil
block|,
comment|/*  47 */
name|st_Nil
block|,
comment|/*  48 */
name|st_Nil
block|,
comment|/*  49 */
name|st_Nil
block|,
comment|/*  50 */
name|st_Nil
block|,
comment|/*  51 */
name|st_Nil
block|,
comment|/*  52 */
name|st_Nil
block|,
comment|/*  53 */
name|st_Nil
block|,
comment|/*  54 */
name|st_Nil
block|,
comment|/*  55 */
name|st_Nil
block|,
comment|/*  56 */
name|st_Nil
block|,
comment|/*  57 */
name|st_Nil
block|,
comment|/*  58 */
name|st_Nil
block|,
comment|/*  59 */
name|st_Nil
block|,
comment|/*  60 */
name|st_Nil
block|,
comment|/*  61 */
name|st_Nil
block|,
comment|/*  62 */
name|st_Nil
block|,
comment|/*  63 */
name|st_Nil
block|,
comment|/*  64 */
name|st_Nil
block|,
comment|/*  65 */
name|st_Nil
block|,
comment|/*  66 */
name|st_Nil
block|,
comment|/*  67 */
name|st_Nil
block|,
comment|/*  68 */
name|st_Nil
block|,
comment|/*  69 */
name|st_Nil
block|,
comment|/*  70 */
name|st_Nil
block|,
comment|/*  71 */
name|st_Nil
block|,
comment|/*  72 */
name|st_Nil
block|,
comment|/*  73 */
name|st_Nil
block|,
comment|/*  74 */
name|st_Nil
block|,
comment|/*  75 */
name|st_Nil
block|,
comment|/*  76 */
name|st_Nil
block|,
comment|/*  77 */
name|st_Nil
block|,
comment|/*  78 */
name|st_Nil
block|,
comment|/*  79 */
name|st_Nil
block|,
comment|/*  80 */
name|st_Nil
block|,
comment|/*  81 */
name|st_Nil
block|,
comment|/*  82 */
name|st_Nil
block|,
comment|/*  83 */
name|st_Nil
block|,
comment|/*  84 */
name|st_Nil
block|,
comment|/*  85 */
name|st_Nil
block|,
comment|/*  86 */
name|st_Nil
block|,
comment|/*  87 */
name|st_Nil
block|,
comment|/*  88 */
name|st_Nil
block|,
comment|/*  89 */
name|st_Nil
block|,
comment|/*  90 */
name|st_Nil
block|,
comment|/*  91 */
name|st_Nil
block|,
comment|/*  92 */
name|st_Nil
block|,
comment|/*  93 */
name|st_Nil
block|,
comment|/*  94 */
name|st_Nil
block|,
comment|/*  95 */
name|st_Nil
block|,
comment|/*  96 */
name|st_Nil
block|,
comment|/*  97 */
name|st_Nil
block|,
comment|/*  98 */
name|st_Nil
block|,
comment|/*  99 */
name|st_Block
block|,
comment|/* 100: C_BLOCK  block start/end */
name|st_Proc
block|,
comment|/* 101: C_FCN	 function start/end */
name|st_End
block|,
comment|/* 102: C_EOS	 end of struct/union/enum */
name|st_File
block|,
comment|/* 103: C_FILE	 file start */
name|st_Nil
block|,
comment|/* 104: C_LINE	 line number */
name|st_Nil
block|,
comment|/* 105: C_ALIAS	 combined type info */
name|st_Nil
block|,
comment|/* 106: C_HIDDEN ??? */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Map COFF derived types to ECOFF type qualifiers.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|tq_t
name|map_coff_derived_type
index|[
operator|(
name|int
operator|)
name|DT_MAX
index|]
init|=
block|{
name|tq_Nil
block|,
comment|/* 0: DT_NON	no more qualifiers */
name|tq_Ptr
block|,
comment|/* 1: DT_PTR	pointer */
name|tq_Proc
block|,
comment|/* 2: DT_FCN	function */
name|tq_Array
block|,
comment|/* 3: DT_ARY	array */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Keep track of different sized allocation requests.  */
end_comment

begin_decl_stmt
specifier|static
name|alloc_info_t
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_last
index|]
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Pointers and such to the original symbol table that is read in.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|filehdr
name|orig_file_header
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* global object file header */
end_comment

begin_decl_stmt
specifier|static
name|HDRR
name|orig_sym_hdr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* symbolic header on input */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|orig_linenum
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* line numbers */
end_comment

begin_decl_stmt
specifier|static
name|DNR
modifier|*
name|orig_dense
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* dense numbers */
end_comment

begin_decl_stmt
specifier|static
name|PDR
modifier|*
name|orig_procs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* procedures */
end_comment

begin_decl_stmt
specifier|static
name|SYMR
modifier|*
name|orig_local_syms
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* local symbols */
end_comment

begin_decl_stmt
specifier|static
name|OPTR
modifier|*
name|orig_opt_syms
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* optimization symbols */
end_comment

begin_decl_stmt
specifier|static
name|AUXU
modifier|*
name|orig_aux_syms
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* auxiliary symbols */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|orig_local_strs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* local strings */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|orig_ext_strs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* external strings */
end_comment

begin_decl_stmt
specifier|static
name|FDR
modifier|*
name|orig_files
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* file descriptors */
end_comment

begin_decl_stmt
specifier|static
name|symint_t
modifier|*
name|orig_rfds
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* relative file desc's */
end_comment

begin_decl_stmt
specifier|static
name|EXTR
modifier|*
name|orig_ext_syms
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* external symbols */
end_comment

begin_comment
comment|/* Macros to convert an index into a given object within the original    symbol table.  */
end_comment

begin_define
define|#
directive|define
name|CHECK
parameter_list|(
name|num
parameter_list|,
name|max
parameter_list|,
name|str
parameter_list|)
define|\
value|(((unsigned long) num> (unsigned long) max) ? out_of_bounds (num, max, str, __LINE__) : 0)
end_define

begin_define
define|#
directive|define
name|ORIG_LINENUM
parameter_list|(
name|indx
parameter_list|)
value|(CHECK ((indx), orig_sym_hdr.cbLine,    "line#"), (indx) + orig_linenum)
end_define

begin_define
define|#
directive|define
name|ORIG_DENSE
parameter_list|(
name|indx
parameter_list|)
value|(CHECK ((indx), orig_sym_hdr.idnMax,    "dense"), (indx) + orig_dense)
end_define

begin_define
define|#
directive|define
name|ORIG_PROCS
parameter_list|(
name|indx
parameter_list|)
value|(CHECK ((indx), orig_sym_hdr.ipdMax,    "procs"), (indx) + orig_procs)
end_define

begin_define
define|#
directive|define
name|ORIG_FILES
parameter_list|(
name|indx
parameter_list|)
value|(CHECK ((indx), orig_sym_hdr.ifdMax,    "funcs"), (indx) + orig_files)
end_define

begin_define
define|#
directive|define
name|ORIG_LSYMS
parameter_list|(
name|indx
parameter_list|)
value|(CHECK ((indx), orig_sym_hdr.isymMax,   "lsyms"), (indx) + orig_local_syms)
end_define

begin_define
define|#
directive|define
name|ORIG_LSTRS
parameter_list|(
name|indx
parameter_list|)
value|(CHECK ((indx), orig_sym_hdr.issMax,    "lstrs"), (indx) + orig_local_strs)
end_define

begin_define
define|#
directive|define
name|ORIG_ESYMS
parameter_list|(
name|indx
parameter_list|)
value|(CHECK ((indx), orig_sym_hdr.iextMax,   "esyms"), (indx) + orig_ext_syms)
end_define

begin_define
define|#
directive|define
name|ORIG_ESTRS
parameter_list|(
name|indx
parameter_list|)
value|(CHECK ((indx), orig_sym_hdr.issExtMax, "estrs"), (indx) + orig_ext_strs)
end_define

begin_define
define|#
directive|define
name|ORIG_OPT
parameter_list|(
name|indx
parameter_list|)
value|(CHECK ((indx), orig_sym_hdr.ioptMax,   "opt"),   (indx) + orig_opt_syms)
end_define

begin_define
define|#
directive|define
name|ORIG_AUX
parameter_list|(
name|indx
parameter_list|)
value|(CHECK ((indx), orig_sym_hdr.iauxMax,   "aux"),   (indx) + orig_aux_syms)
end_define

begin_define
define|#
directive|define
name|ORIG_RFDS
parameter_list|(
name|indx
parameter_list|)
value|(CHECK ((indx), orig_sym_hdr.crfd,      "rfds"),  (indx) + orig_rfds)
end_define

begin_comment
comment|/* Various other statics.  */
end_comment

begin_decl_stmt
specifier|static
name|HDRR
name|symbolic_header
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* symbolic header */
end_comment

begin_decl_stmt
specifier|static
name|efdr_t
modifier|*
name|cur_file_ptr
init|=
operator|(
name|efdr_t
operator|*
operator|)
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current file desc. header */
end_comment

begin_decl_stmt
specifier|static
name|PDR
modifier|*
name|cur_proc_ptr
init|=
operator|(
name|PDR
operator|*
operator|)
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current procedure header */
end_comment

begin_decl_stmt
specifier|static
name|SYMR
modifier|*
name|cur_oproc_begin
init|=
operator|(
name|SYMR
operator|*
operator|)
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* original proc. sym begin info */
end_comment

begin_decl_stmt
specifier|static
name|SYMR
modifier|*
name|cur_oproc_end
init|=
operator|(
name|SYMR
operator|*
operator|)
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* original proc. sym end info */
end_comment

begin_decl_stmt
specifier|static
name|PDR
modifier|*
name|cur_oproc_ptr
init|=
operator|(
name|PDR
operator|*
operator|)
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current original procedure*/
end_comment

begin_decl_stmt
specifier|static
name|thead_t
modifier|*
name|cur_tag_head
init|=
operator|(
name|thead_t
operator|*
operator|)
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current tag head */
end_comment

begin_decl_stmt
specifier|static
name|long
name|file_offset
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current file offset */
end_comment

begin_decl_stmt
specifier|static
name|long
name|max_file_offset
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* maximum file offset */
end_comment

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|object_stream
init|=
operator|(
name|FILE
operator|*
operator|)
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* file desc. to output .o */
end_comment

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|obj_in_stream
init|=
operator|(
name|FILE
operator|*
operator|)
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* file desc. to input .o */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|progname
init|=
operator|(
name|char
operator|*
operator|)
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* program name for errors */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|input_name
init|=
literal|"stdin"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* name of input file */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|object_name
init|=
operator|(
name|char
operator|*
operator|)
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* tmp. name of object file */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|obj_in_name
init|=
operator|(
name|char
operator|*
operator|)
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* name of input object file */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|cur_line_start
init|=
operator|(
name|char
operator|*
operator|)
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current line read in */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|cur_line_ptr
init|=
operator|(
name|char
operator|*
operator|)
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ptr within current line */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|cur_line_nbytes
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # bytes for current line */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|cur_line_alloc
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # bytes total in buffer */
end_comment

begin_decl_stmt
specifier|static
name|long
name|line_number
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current input line number */
end_comment

begin_decl_stmt
specifier|static
name|int
name|debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* trace functions */
end_comment

begin_decl_stmt
specifier|static
name|int
name|version
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* print version # */
end_comment

begin_decl_stmt
specifier|static
name|int
name|had_errors
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* != 0 if errors were found */
end_comment

begin_decl_stmt
specifier|static
name|int
name|rename_output
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* != 0 if rename output file*/
end_comment

begin_decl_stmt
specifier|static
name|int
name|delete_input
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* != 0 if delete input after done */
end_comment

begin_decl_stmt
specifier|static
name|int
name|stabs_seen
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* != 0 if stabs have been seen */
end_comment

begin_comment
comment|/* Pseudo symbol to use when putting stabs into the symbol table.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|STABS_SYMBOL
end_ifndef

begin_define
define|#
directive|define
name|STABS_SYMBOL
value|"@stabs"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
specifier|const
name|char
name|stabs_symbol
index|[]
init|=
name|STABS_SYMBOL
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Forward reference for functions.  See the definition for more details.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|STATIC
end_ifndef

begin_define
define|#
directive|define
name|STATIC
value|static
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|STATIC
name|int
name|out_of_bounds
name|PARAMS
argument_list|(
operator|(
name|symint_t
operator|,
name|symint_t
operator|,
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|shash_t
modifier|*
name|hash_string
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|Ptrdiff_t
operator|,
name|shash_t
operator|*
operator|*
operator|,
name|symint_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|symint_t
name|add_string
name|PARAMS
argument_list|(
operator|(
name|varray_t
operator|*
operator|,
name|shash_t
operator|*
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|shash_t
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|symint_t
name|add_local_symbol
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|st_t
operator|,
name|sc_t
operator|,
name|symint_t
operator|,
name|symint_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|symint_t
name|add_ext_symbol
name|PARAMS
argument_list|(
operator|(
name|EXTR
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|symint_t
name|add_aux_sym_symint
name|PARAMS
argument_list|(
operator|(
name|symint_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|symint_t
name|add_aux_sym_rndx
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|symint_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|symint_t
name|add_aux_sym_tir
name|PARAMS
argument_list|(
operator|(
name|type_info_t
operator|*
operator|,
name|hash_state_t
operator|,
name|thash_t
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|tag_t
modifier|*
name|get_tag
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|symint_t
operator|,
name|bt_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|void
name|add_unknown_tag
name|PARAMS
argument_list|(
operator|(
name|tag_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|void
name|add_procedure
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|void
name|add_file
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|void
name|add_bytes
name|PARAMS
argument_list|(
operator|(
name|varray_t
operator|*
operator|,
name|char
operator|*
operator|,
name|Size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|void
name|add_varray_page
name|PARAMS
argument_list|(
operator|(
name|varray_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|void
name|update_headers
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|void
name|write_varray
name|PARAMS
argument_list|(
operator|(
name|varray_t
operator|*
operator|,
name|off_t
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|void
name|write_object
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
specifier|const
name|char
modifier|*
name|st_to_string
name|PARAMS
argument_list|(
operator|(
name|st_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
specifier|const
name|char
modifier|*
name|sc_to_string
name|PARAMS
argument_list|(
operator|(
name|sc_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|char
modifier|*
name|read_line
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|void
name|parse_input
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|void
name|mark_stabs
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|void
name|parse_begin
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|void
name|parse_bend
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|void
name|parse_def
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|void
name|parse_end
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|void
name|parse_ent
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|void
name|parse_file
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|void
name|parse_stabs_common
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|void
name|parse_stabs
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|void
name|parse_stabn
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|page_t
modifier|*
name|read_seek
name|PARAMS
argument_list|(
operator|(
name|Size_t
operator|,
name|off_t
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|void
name|copy_object
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|void
name|catch_signal
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
name|ATTRIBUTE_NORETURN
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|page_t
modifier|*
name|allocate_page
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|page_t
modifier|*
name|allocate_multiple_pages
name|PARAMS
argument_list|(
operator|(
name|Size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|void
name|free_multiple_pages
name|PARAMS
argument_list|(
operator|(
name|page_t
operator|*
operator|,
name|Size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|MALLOC_CHECK
end_ifndef

begin_decl_stmt
name|STATIC
name|page_t
modifier|*
name|allocate_cluster
name|PARAMS
argument_list|(
operator|(
name|Size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|STATIC
name|forward_t
modifier|*
name|allocate_forward
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|scope_t
modifier|*
name|allocate_scope
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|shash_t
modifier|*
name|allocate_shash
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|tag_t
modifier|*
name|allocate_tag
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|thash_t
modifier|*
name|allocate_thash
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|thead_t
modifier|*
name|allocate_thead
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|vlinks_t
modifier|*
name|allocate_vlinks
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|void
name|free_forward
name|PARAMS
argument_list|(
operator|(
name|forward_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|void
name|free_scope
name|PARAMS
argument_list|(
operator|(
name|scope_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|void
name|free_tag
name|PARAMS
argument_list|(
operator|(
name|tag_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|void
name|free_thead
name|PARAMS
argument_list|(
operator|(
name|thead_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|optarg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|optind
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|opterr
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* List of assembler pseudo ops and beginning sequences that need    special actions.  Someday, this should be a hash table, and such,    but for now a linear list of names and calls to memcmp will    do......  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|_pseudo_ops
block|{
specifier|const
name|char
modifier|*
specifier|const
name|name
decl_stmt|;
comment|/* pseudo-op in ascii */
specifier|const
name|int
name|len
decl_stmt|;
comment|/* length of name to compare */
name|void
argument_list|(
argument|*const func
argument_list|)
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
expr_stmt|;
comment|/* function to handle line */
block|}
name|pseudo_ops_t
typedef|;
end_typedef

begin_decl_stmt
specifier|static
specifier|const
name|pseudo_ops_t
name|pseudo_ops
index|[]
init|=
block|{
block|{
literal|"#.def"
block|,
sizeof|sizeof
argument_list|(
literal|"#.def"
argument_list|)
operator|-
literal|1
block|,
name|parse_def
block|}
block|,
block|{
literal|"#.begin"
block|,
sizeof|sizeof
argument_list|(
literal|"#.begin"
argument_list|)
operator|-
literal|1
block|,
name|parse_begin
block|}
block|,
block|{
literal|"#.bend"
block|,
sizeof|sizeof
argument_list|(
literal|"#.bend"
argument_list|)
operator|-
literal|1
block|,
name|parse_bend
block|}
block|,
block|{
literal|".end"
block|,
sizeof|sizeof
argument_list|(
literal|".end"
argument_list|)
operator|-
literal|1
block|,
name|parse_end
block|}
block|,
block|{
literal|".ent"
block|,
sizeof|sizeof
argument_list|(
literal|".ent"
argument_list|)
operator|-
literal|1
block|,
name|parse_ent
block|}
block|,
block|{
literal|".file"
block|,
sizeof|sizeof
argument_list|(
literal|".file"
argument_list|)
operator|-
literal|1
block|,
name|parse_file
block|}
block|,
block|{
literal|"#.stabs"
block|,
sizeof|sizeof
argument_list|(
literal|"#.stabs"
argument_list|)
operator|-
literal|1
block|,
name|parse_stabs
block|}
block|,
block|{
literal|"#.stabn"
block|,
sizeof|sizeof
argument_list|(
literal|"#.stabn"
argument_list|)
operator|-
literal|1
block|,
name|parse_stabn
block|}
block|,
block|{
literal|".stabs"
block|,
sizeof|sizeof
argument_list|(
literal|".stabs"
argument_list|)
operator|-
literal|1
block|,
name|parse_stabs
block|}
block|,
block|{
literal|".stabn"
block|,
sizeof|sizeof
argument_list|(
literal|".stabn"
argument_list|)
operator|-
literal|1
block|,
name|parse_stabn
block|}
block|,
block|{
literal|"#@stabs"
block|,
sizeof|sizeof
argument_list|(
literal|"#@stabs"
argument_list|)
operator|-
literal|1
block|,
name|mark_stabs
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Add a page to a varray object.  */
end_comment

begin_function
name|STATIC
name|void
name|add_varray_page
parameter_list|(
name|vp
parameter_list|)
name|varray_t
modifier|*
name|vp
decl_stmt|;
comment|/* varray to add page to */
block|{
name|vlinks_t
modifier|*
name|new_links
init|=
name|allocate_vlinks
argument_list|()
decl_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_CHECK
if|if
condition|(
name|vp
operator|->
name|object_size
operator|>
literal|1
condition|)
name|new_links
operator|->
name|datum
operator|=
operator|(
name|page_t
operator|*
operator|)
name|xcalloc
argument_list|(
literal|1
argument_list|,
name|vp
operator|->
name|object_size
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|new_links
operator|->
name|datum
operator|=
name|allocate_page
argument_list|()
expr_stmt|;
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_varray
index|]
operator|.
name|total_alloc
operator|++
expr_stmt|;
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_varray
index|]
operator|.
name|total_pages
operator|++
expr_stmt|;
name|new_links
operator|->
name|start_index
operator|=
name|vp
operator|->
name|num_allocated
expr_stmt|;
name|vp
operator|->
name|objects_last_page
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|first
operator|==
operator|(
name|vlinks_t
operator|*
operator|)
literal|0
condition|)
comment|/* first allocation? */
name|vp
operator|->
name|first
operator|=
name|vp
operator|->
name|last
operator|=
name|new_links
expr_stmt|;
else|else
block|{
comment|/* 2nd or greater allocation */
name|new_links
operator|->
name|prev
operator|=
name|vp
operator|->
name|last
expr_stmt|;
name|vp
operator|->
name|last
operator|->
name|next
operator|=
name|new_links
expr_stmt|;
name|vp
operator|->
name|last
operator|=
name|new_links
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Compute hash code (from tree.c) */
end_comment

begin_define
define|#
directive|define
name|HASHBITS
value|30
end_define

begin_function
name|STATIC
name|shash_t
modifier|*
name|hash_string
parameter_list|(
name|text
parameter_list|,
name|hash_len
parameter_list|,
name|hash_tbl
parameter_list|,
name|ret_hash_index
parameter_list|)
specifier|const
name|char
modifier|*
name|text
decl_stmt|;
comment|/* ptr to text to hash */
name|Ptrdiff_t
name|hash_len
decl_stmt|;
comment|/* length of the text */
name|shash_t
modifier|*
modifier|*
name|hash_tbl
decl_stmt|;
comment|/* hash table */
name|symint_t
modifier|*
name|ret_hash_index
decl_stmt|;
comment|/* ptr to store hash index */
block|{
name|unsigned
name|long
name|hi
decl_stmt|;
name|Ptrdiff_t
name|i
decl_stmt|;
name|shash_t
modifier|*
name|ptr
decl_stmt|;
name|int
name|first_ch
init|=
operator|*
name|text
decl_stmt|;
name|hi
operator|=
name|hash_len
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hash_len
condition|;
name|i
operator|++
control|)
name|hi
operator|=
operator|(
operator|(
name|hi
operator|&
literal|0x003fffff
operator|)
operator|*
literal|613
operator|)
operator|+
operator|(
name|text
index|[
name|i
index|]
operator|&
literal|0xff
operator|)
expr_stmt|;
name|hi
operator|&=
operator|(
literal|1
operator|<<
name|HASHBITS
operator|)
operator|-
literal|1
expr_stmt|;
name|hi
operator|%=
name|SHASH_SIZE
expr_stmt|;
if|if
condition|(
name|ret_hash_index
operator|!=
operator|(
name|symint_t
operator|*
operator|)
literal|0
condition|)
operator|*
name|ret_hash_index
operator|=
name|hi
expr_stmt|;
for|for
control|(
name|ptr
operator|=
name|hash_tbl
index|[
name|hi
index|]
init|;
name|ptr
operator|!=
operator|(
name|shash_t
operator|*
operator|)
literal|0
condition|;
name|ptr
operator|=
name|ptr
operator|->
name|next
control|)
if|if
condition|(
operator|(
name|symint_t
operator|)
name|hash_len
operator|==
name|ptr
operator|->
name|len
operator|&&
name|first_ch
operator|==
name|ptr
operator|->
name|string
index|[
literal|0
index|]
operator|&&
name|memcmp
argument_list|(
name|text
argument_list|,
name|ptr
operator|->
name|string
argument_list|,
name|hash_len
argument_list|)
operator|==
literal|0
condition|)
break|break;
return|return
name|ptr
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Add a string (and null pad) to one of the string tables.  A    consequence of hashing strings, is that we don't let strings    cross page boundaries.  The extra nulls will be ignored.  */
end_comment

begin_function
name|STATIC
name|symint_t
name|add_string
parameter_list|(
name|vp
parameter_list|,
name|hash_tbl
parameter_list|,
name|start
parameter_list|,
name|end_p1
parameter_list|,
name|ret_hash
parameter_list|)
name|varray_t
modifier|*
name|vp
decl_stmt|;
comment|/* string virtual array */
name|shash_t
modifier|*
modifier|*
name|hash_tbl
decl_stmt|;
comment|/* ptr to hash table */
specifier|const
name|char
modifier|*
name|start
decl_stmt|;
comment|/* 1st byte in string */
specifier|const
name|char
modifier|*
name|end_p1
decl_stmt|;
comment|/* 1st byte after string */
name|shash_t
modifier|*
modifier|*
name|ret_hash
decl_stmt|;
comment|/* return hash pointer */
block|{
name|Ptrdiff_t
name|len
init|=
name|end_p1
operator|-
name|start
decl_stmt|;
name|shash_t
modifier|*
name|hash_ptr
decl_stmt|;
name|symint_t
name|hi
decl_stmt|;
if|if
condition|(
name|len
operator|>=
operator|(
name|Ptrdiff_t
operator|)
name|PAGE_USIZE
condition|)
name|fatal
argument_list|(
literal|"string too big (%ld bytes)"
argument_list|,
operator|(
name|long
operator|)
name|len
argument_list|)
expr_stmt|;
name|hash_ptr
operator|=
name|hash_string
argument_list|(
name|start
argument_list|,
name|len
argument_list|,
name|hash_tbl
argument_list|,
operator|&
name|hi
argument_list|)
expr_stmt|;
if|if
condition|(
name|hash_ptr
operator|==
operator|(
name|shash_t
operator|*
operator|)
literal|0
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|vp
operator|->
name|objects_last_page
operator|+
name|len
operator|>=
operator|(
name|long
operator|)
name|PAGE_USIZE
condition|)
block|{
name|vp
operator|->
name|num_allocated
operator|=
operator|(
operator|(
name|vp
operator|->
name|num_allocated
operator|+
name|PAGE_USIZE
operator|-
literal|1
operator|)
operator|/
name|PAGE_USIZE
operator|)
operator|*
name|PAGE_USIZE
expr_stmt|;
name|add_varray_page
argument_list|(
name|vp
argument_list|)
expr_stmt|;
block|}
name|hash_ptr
operator|=
name|allocate_shash
argument_list|()
expr_stmt|;
name|hash_ptr
operator|->
name|next
operator|=
name|hash_tbl
index|[
name|hi
index|]
expr_stmt|;
name|hash_tbl
index|[
name|hi
index|]
operator|=
name|hash_ptr
expr_stmt|;
name|hash_ptr
operator|->
name|len
operator|=
name|len
expr_stmt|;
name|hash_ptr
operator|->
name|indx
operator|=
name|vp
operator|->
name|num_allocated
expr_stmt|;
name|hash_ptr
operator|->
name|string
operator|=
name|p
operator|=
operator|&
name|vp
operator|->
name|last
operator|->
name|datum
operator|->
name|byte
index|[
name|vp
operator|->
name|objects_last_page
index|]
expr_stmt|;
name|vp
operator|->
name|objects_last_page
operator|+=
name|len
operator|+
literal|1
expr_stmt|;
name|vp
operator|->
name|num_allocated
operator|+=
name|len
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
operator|*
name|p
operator|++
operator|=
operator|*
name|start
operator|++
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|ret_hash
operator|!=
operator|(
name|shash_t
operator|*
operator|*
operator|)
literal|0
condition|)
operator|*
name|ret_hash
operator|=
name|hash_ptr
expr_stmt|;
return|return
name|hash_ptr
operator|->
name|indx
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Add a local symbol.  */
end_comment

begin_function
name|STATIC
name|symint_t
name|add_local_symbol
parameter_list|(
name|str_start
parameter_list|,
name|str_end_p1
parameter_list|,
name|type
parameter_list|,
name|storage
parameter_list|,
name|value
parameter_list|,
name|indx
parameter_list|)
specifier|const
name|char
modifier|*
name|str_start
decl_stmt|;
comment|/* first byte in string */
specifier|const
name|char
modifier|*
name|str_end_p1
decl_stmt|;
comment|/* first byte after string */
name|st_t
name|type
decl_stmt|;
comment|/* symbol type */
name|sc_t
name|storage
decl_stmt|;
comment|/* storage class */
name|symint_t
name|value
decl_stmt|;
comment|/* value of symbol */
name|symint_t
name|indx
decl_stmt|;
comment|/* index to local/aux. syms */
block|{
name|symint_t
name|ret
decl_stmt|;
name|SYMR
modifier|*
name|psym
decl_stmt|;
name|scope_t
modifier|*
name|pscope
decl_stmt|;
name|thead_t
modifier|*
name|ptag_head
decl_stmt|;
name|tag_t
modifier|*
name|ptag
decl_stmt|;
name|tag_t
modifier|*
name|ptag_next
decl_stmt|;
name|varray_t
modifier|*
name|vp
init|=
operator|&
name|cur_file_ptr
operator|->
name|symbols
decl_stmt|;
name|int
name|scope_delta
init|=
literal|0
decl_stmt|;
name|shash_t
modifier|*
name|hash_ptr
init|=
operator|(
name|shash_t
operator|*
operator|)
literal|0
decl_stmt|;
if|if
condition|(
name|vp
operator|->
name|objects_last_page
operator|==
name|vp
operator|->
name|objects_per_page
condition|)
name|add_varray_page
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|psym
operator|=
operator|&
name|vp
operator|->
name|last
operator|->
name|datum
operator|->
name|sym
index|[
name|vp
operator|->
name|objects_last_page
operator|++
index|]
expr_stmt|;
name|psym
operator|->
name|value
operator|=
name|value
expr_stmt|;
name|psym
operator|->
name|st
operator|=
operator|(
name|unsigned
operator|)
name|type
expr_stmt|;
name|psym
operator|->
name|sc
operator|=
operator|(
name|unsigned
operator|)
name|storage
expr_stmt|;
name|psym
operator|->
name|index
operator|=
name|indx
expr_stmt|;
name|psym
operator|->
name|iss
operator|=
operator|(
name|str_start
operator|==
operator|(
specifier|const
name|char
operator|*
operator|)
literal|0
operator|)
condition|?
literal|0
else|:
name|add_string
argument_list|(
operator|&
name|cur_file_ptr
operator|->
name|strings
argument_list|,
operator|&
name|cur_file_ptr
operator|->
name|shash_head
index|[
literal|0
index|]
argument_list|,
name|str_start
argument_list|,
name|str_end_p1
argument_list|,
operator|&
name|hash_ptr
argument_list|)
expr_stmt|;
name|ret
operator|=
name|vp
operator|->
name|num_allocated
operator|++
expr_stmt|;
if|if
condition|(
name|MIPS_IS_STAB
argument_list|(
name|psym
argument_list|)
condition|)
return|return
name|ret
return|;
comment|/* Save the symbol within the hash table if this is a static      item, and it has a name.  */
if|if
condition|(
name|hash_ptr
operator|!=
operator|(
name|shash_t
operator|*
operator|)
literal|0
operator|&&
operator|(
name|type
operator|==
name|st_Global
operator|||
name|type
operator|==
name|st_Static
operator|||
name|type
operator|==
name|st_Label
operator|||
name|type
operator|==
name|st_Proc
operator|||
name|type
operator|==
name|st_StaticProc
operator|)
condition|)
name|hash_ptr
operator|->
name|sym_ptr
operator|=
name|psym
expr_stmt|;
comment|/* push or pop a scope if appropriate.  */
switch|switch
condition|(
name|type
condition|)
block|{
default|default:
break|break;
case|case
name|st_File
case|:
comment|/* beginning of file */
case|case
name|st_Proc
case|:
comment|/* procedure */
case|case
name|st_StaticProc
case|:
comment|/* static procedure */
case|case
name|st_Block
case|:
comment|/* begin scope */
name|pscope
operator|=
name|allocate_scope
argument_list|()
expr_stmt|;
name|pscope
operator|->
name|prev
operator|=
name|cur_file_ptr
operator|->
name|cur_scope
expr_stmt|;
name|pscope
operator|->
name|lsym
operator|=
name|psym
expr_stmt|;
name|pscope
operator|->
name|lnumber
operator|=
name|ret
expr_stmt|;
name|pscope
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|cur_file_ptr
operator|->
name|cur_scope
operator|=
name|pscope
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|st_File
condition|)
name|scope_delta
operator|=
literal|1
expr_stmt|;
comment|/* For every block type except file, struct, union, or 	 enumeration blocks, push a level on the tag stack.  We omit 	 file types, so that tags can span file boundaries.  */
if|if
condition|(
name|type
operator|!=
name|st_File
operator|&&
name|storage
operator|!=
name|sc_Info
condition|)
block|{
name|ptag_head
operator|=
name|allocate_thead
argument_list|()
expr_stmt|;
name|ptag_head
operator|->
name|first_tag
operator|=
literal|0
expr_stmt|;
name|ptag_head
operator|->
name|prev
operator|=
name|cur_tag_head
expr_stmt|;
name|cur_tag_head
operator|=
name|ptag_head
expr_stmt|;
block|}
break|break;
case|case
name|st_End
case|:
name|pscope
operator|=
name|cur_file_ptr
operator|->
name|cur_scope
expr_stmt|;
if|if
condition|(
name|pscope
operator|==
operator|(
name|scope_t
operator|*
operator|)
literal|0
condition|)
name|error
argument_list|(
literal|"internal error, too many st_End's"
argument_list|)
expr_stmt|;
else|else
block|{
name|st_t
name|begin_type
init|=
operator|(
name|st_t
operator|)
name|pscope
operator|->
name|lsym
operator|->
name|st
decl_stmt|;
if|if
condition|(
name|begin_type
operator|!=
name|st_File
condition|)
name|scope_delta
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Except for file, structure, union, or enumeration end 	     blocks remove all tags created within this scope.  */
if|if
condition|(
name|begin_type
operator|!=
name|st_File
operator|&&
name|storage
operator|!=
name|sc_Info
condition|)
block|{
name|ptag_head
operator|=
name|cur_tag_head
expr_stmt|;
name|cur_tag_head
operator|=
name|ptag_head
operator|->
name|prev
expr_stmt|;
for|for
control|(
name|ptag
operator|=
name|ptag_head
operator|->
name|first_tag
init|;
name|ptag
operator|!=
operator|(
name|tag_t
operator|*
operator|)
literal|0
condition|;
name|ptag
operator|=
name|ptag_next
control|)
block|{
if|if
condition|(
name|ptag
operator|->
name|forward_ref
operator|!=
operator|(
name|forward_t
operator|*
operator|)
literal|0
condition|)
name|add_unknown_tag
argument_list|(
name|ptag
argument_list|)
expr_stmt|;
name|ptag_next
operator|=
name|ptag
operator|->
name|same_block
expr_stmt|;
name|ptag
operator|->
name|hash_ptr
operator|->
name|tag_ptr
operator|=
name|ptag
operator|->
name|same_name
expr_stmt|;
name|free_tag
argument_list|(
name|ptag
argument_list|)
expr_stmt|;
block|}
name|free_thead
argument_list|(
name|ptag_head
argument_list|)
expr_stmt|;
block|}
name|cur_file_ptr
operator|->
name|cur_scope
operator|=
name|pscope
operator|->
name|prev
expr_stmt|;
name|psym
operator|->
name|index
operator|=
name|pscope
operator|->
name|lnumber
expr_stmt|;
comment|/* blk end gets begin sym # */
if|if
condition|(
name|storage
operator|!=
name|sc_Info
condition|)
name|psym
operator|->
name|iss
operator|=
name|pscope
operator|->
name|lsym
operator|->
name|iss
expr_stmt|;
comment|/* blk end gets same name */
if|if
condition|(
name|begin_type
operator|==
name|st_File
operator|||
name|begin_type
operator|==
name|st_Block
condition|)
name|pscope
operator|->
name|lsym
operator|->
name|index
operator|=
name|ret
operator|+
literal|1
expr_stmt|;
comment|/* block begin gets next sym # */
comment|/* Functions push two or more aux words as follows: 	     1st word: index+1 of the end symbol 	     2nd word: type of the function (plus any aux words needed). 	     Also, tie the external pointer back to the function begin symbol.  */
else|else
block|{
name|symint_t
name|type
decl_stmt|;
name|pscope
operator|->
name|lsym
operator|->
name|index
operator|=
name|add_aux_sym_symint
argument_list|(
name|ret
operator|+
literal|1
argument_list|)
expr_stmt|;
name|type
operator|=
name|add_aux_sym_tir
argument_list|(
operator|&
name|last_func_type_info
argument_list|,
name|hash_no
argument_list|,
operator|&
name|cur_file_ptr
operator|->
name|thash_head
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_func_eptr
condition|)
block|{
name|last_func_eptr
operator|->
name|ifd
operator|=
name|cur_file_ptr
operator|->
name|file_index
expr_stmt|;
comment|/* The index for an external st_Proc symbol is the index 		     of the st_Proc symbol in the local symbol table.  */
name|last_func_eptr
operator|->
name|asym
operator|.
name|index
operator|=
name|psym
operator|->
name|index
expr_stmt|;
block|}
block|}
name|free_scope
argument_list|(
name|pscope
argument_list|)
expr_stmt|;
block|}
block|}
name|cur_file_ptr
operator|->
name|nested_scopes
operator|+=
name|scope_delta
expr_stmt|;
if|if
condition|(
name|debug
operator|&&
name|type
operator|!=
name|st_File
operator|&&
operator|(
name|debug
operator|>
literal|2
operator|||
name|type
operator|==
name|st_Block
operator|||
name|type
operator|==
name|st_End
operator|||
name|type
operator|==
name|st_Proc
operator|||
name|type
operator|==
name|st_StaticProc
operator|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|sc_str
init|=
name|sc_to_string
argument_list|(
name|storage
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|st_str
init|=
name|st_to_string
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|int
name|depth
init|=
name|cur_file_ptr
operator|->
name|nested_scopes
operator|+
operator|(
name|scope_delta
operator|<
literal|0
operator|)
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tlsym\tv= %10ld, depth= %2d, sc= %-12s"
argument_list|,
name|value
argument_list|,
name|depth
argument_list|,
name|sc_str
argument_list|)
expr_stmt|;
if|if
condition|(
name|str_start
operator|&&
name|str_end_p1
operator|-
name|str_start
operator|>
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" st= %-11s name= %.*s\n"
argument_list|,
name|st_str
argument_list|,
call|(
name|int
call|)
argument_list|(
name|str_end_p1
operator|-
name|str_start
argument_list|)
argument_list|,
name|str_start
argument_list|)
expr_stmt|;
else|else
block|{
name|Size_t
name|len
init|=
name|strlen
argument_list|(
name|st_str
argument_list|)
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" st= %.*s\n"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|len
operator|-
literal|1
argument_list|)
argument_list|,
name|st_str
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|ret
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Add an external symbol.  */
end_comment

begin_function
name|STATIC
name|symint_t
name|add_ext_symbol
parameter_list|(
name|esym
parameter_list|,
name|ifd
parameter_list|)
name|EXTR
modifier|*
name|esym
decl_stmt|;
comment|/* symbol pointer */
name|int
name|ifd
decl_stmt|;
comment|/* file index */
block|{
specifier|const
name|char
modifier|*
name|str_start
decl_stmt|;
comment|/* first byte in string */
specifier|const
name|char
modifier|*
name|str_end_p1
decl_stmt|;
comment|/* first byte after string */
name|EXTR
modifier|*
name|psym
decl_stmt|;
name|varray_t
modifier|*
name|vp
init|=
operator|&
name|ext_symbols
decl_stmt|;
name|shash_t
modifier|*
name|hash_ptr
init|=
operator|(
name|shash_t
operator|*
operator|)
literal|0
decl_stmt|;
name|str_start
operator|=
name|ORIG_ESTRS
argument_list|(
name|esym
operator|->
name|asym
operator|.
name|iss
argument_list|)
expr_stmt|;
name|str_end_p1
operator|=
name|str_start
operator|+
name|strlen
argument_list|(
name|str_start
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
block|{
name|long
name|value
init|=
name|esym
operator|->
name|asym
operator|.
name|value
decl_stmt|;
specifier|const
name|char
modifier|*
name|sc_str
init|=
name|sc_to_string
argument_list|(
name|esym
operator|->
name|asym
operator|.
name|sc
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|st_str
init|=
name|st_to_string
argument_list|(
name|esym
operator|->
name|asym
operator|.
name|st
argument_list|)
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tesym\tv= %10ld, ifd= %2d, sc= %-12s"
argument_list|,
name|value
argument_list|,
name|ifd
argument_list|,
name|sc_str
argument_list|)
expr_stmt|;
if|if
condition|(
name|str_start
operator|&&
name|str_end_p1
operator|-
name|str_start
operator|>
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" st= %-11s name= %.*s\n"
argument_list|,
name|st_str
argument_list|,
call|(
name|int
call|)
argument_list|(
name|str_end_p1
operator|-
name|str_start
argument_list|)
argument_list|,
name|str_start
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" st= %s\n"
argument_list|,
name|st_str
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vp
operator|->
name|objects_last_page
operator|==
name|vp
operator|->
name|objects_per_page
condition|)
name|add_varray_page
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|psym
operator|=
operator|&
name|vp
operator|->
name|last
operator|->
name|datum
operator|->
name|esym
index|[
name|vp
operator|->
name|objects_last_page
operator|++
index|]
expr_stmt|;
operator|*
name|psym
operator|=
operator|*
name|esym
expr_stmt|;
name|psym
operator|->
name|ifd
operator|=
name|ifd
expr_stmt|;
name|psym
operator|->
name|asym
operator|.
name|index
operator|=
name|indexNil
expr_stmt|;
name|psym
operator|->
name|asym
operator|.
name|iss
operator|=
operator|(
name|str_start
operator|==
operator|(
specifier|const
name|char
operator|*
operator|)
literal|0
operator|)
condition|?
literal|0
else|:
name|add_string
argument_list|(
operator|&
name|ext_strings
argument_list|,
operator|&
name|ext_str_hash
index|[
literal|0
index|]
argument_list|,
name|str_start
argument_list|,
name|str_end_p1
argument_list|,
operator|&
name|hash_ptr
argument_list|)
expr_stmt|;
name|hash_ptr
operator|->
name|esym_ptr
operator|=
name|psym
expr_stmt|;
return|return
name|vp
operator|->
name|num_allocated
operator|++
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Add an auxiliary symbol (passing a symint).  */
end_comment

begin_function
name|STATIC
name|symint_t
name|add_aux_sym_symint
parameter_list|(
name|aux_word
parameter_list|)
name|symint_t
name|aux_word
decl_stmt|;
comment|/* auxiliary information word */
block|{
name|AUXU
modifier|*
name|aux_ptr
decl_stmt|;
name|efdr_t
modifier|*
name|file_ptr
init|=
name|cur_file_ptr
decl_stmt|;
name|varray_t
modifier|*
name|vp
init|=
operator|&
name|file_ptr
operator|->
name|aux_syms
decl_stmt|;
if|if
condition|(
name|vp
operator|->
name|objects_last_page
operator|==
name|vp
operator|->
name|objects_per_page
condition|)
name|add_varray_page
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|aux_ptr
operator|=
operator|&
name|vp
operator|->
name|last
operator|->
name|datum
operator|->
name|aux
index|[
name|vp
operator|->
name|objects_last_page
operator|++
index|]
expr_stmt|;
name|aux_ptr
operator|->
name|isym
operator|=
name|aux_word
expr_stmt|;
return|return
name|vp
operator|->
name|num_allocated
operator|++
return|;
block|}
end_function

begin_comment
comment|/* Add an auxiliary symbol (passing a file/symbol index combo).  */
end_comment

begin_function
name|STATIC
name|symint_t
name|add_aux_sym_rndx
parameter_list|(
name|file_index
parameter_list|,
name|sym_index
parameter_list|)
name|int
name|file_index
decl_stmt|;
name|symint_t
name|sym_index
decl_stmt|;
block|{
name|AUXU
modifier|*
name|aux_ptr
decl_stmt|;
name|efdr_t
modifier|*
name|file_ptr
init|=
name|cur_file_ptr
decl_stmt|;
name|varray_t
modifier|*
name|vp
init|=
operator|&
name|file_ptr
operator|->
name|aux_syms
decl_stmt|;
if|if
condition|(
name|vp
operator|->
name|objects_last_page
operator|==
name|vp
operator|->
name|objects_per_page
condition|)
name|add_varray_page
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|aux_ptr
operator|=
operator|&
name|vp
operator|->
name|last
operator|->
name|datum
operator|->
name|aux
index|[
name|vp
operator|->
name|objects_last_page
operator|++
index|]
expr_stmt|;
name|aux_ptr
operator|->
name|rndx
operator|.
name|rfd
operator|=
name|file_index
expr_stmt|;
name|aux_ptr
operator|->
name|rndx
operator|.
name|index
operator|=
name|sym_index
expr_stmt|;
return|return
name|vp
operator|->
name|num_allocated
operator|++
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Add an auxiliary symbol (passing the basic type and possibly    type qualifiers).  */
end_comment

begin_function
name|STATIC
name|symint_t
name|add_aux_sym_tir
parameter_list|(
name|t
parameter_list|,
name|state
parameter_list|,
name|hash_tbl
parameter_list|)
name|type_info_t
modifier|*
name|t
decl_stmt|;
comment|/* current type information */
name|hash_state_t
name|state
decl_stmt|;
comment|/* whether to hash type or not */
name|thash_t
modifier|*
modifier|*
name|hash_tbl
decl_stmt|;
comment|/* pointer to hash table to use */
block|{
name|AUXU
modifier|*
name|aux_ptr
decl_stmt|;
name|efdr_t
modifier|*
name|file_ptr
init|=
name|cur_file_ptr
decl_stmt|;
name|varray_t
modifier|*
name|vp
init|=
operator|&
name|file_ptr
operator|->
name|aux_syms
decl_stmt|;
specifier|static
name|AUXU
name|init_aux
decl_stmt|;
name|symint_t
name|ret
decl_stmt|;
name|int
name|i
decl_stmt|;
name|AUXU
name|aux
decl_stmt|;
name|aux
operator|=
name|init_aux
expr_stmt|;
name|aux
operator|.
name|ti
operator|.
name|bt
operator|=
operator|(
name|int
operator|)
name|t
operator|->
name|basic_type
expr_stmt|;
name|aux
operator|.
name|ti
operator|.
name|continued
operator|=
literal|0
expr_stmt|;
name|aux
operator|.
name|ti
operator|.
name|fBitfield
operator|=
name|t
operator|->
name|bitfield
expr_stmt|;
name|aux
operator|.
name|ti
operator|.
name|tq0
operator|=
operator|(
name|int
operator|)
name|t
operator|->
name|type_qualifiers
index|[
literal|0
index|]
expr_stmt|;
name|aux
operator|.
name|ti
operator|.
name|tq1
operator|=
operator|(
name|int
operator|)
name|t
operator|->
name|type_qualifiers
index|[
literal|1
index|]
expr_stmt|;
name|aux
operator|.
name|ti
operator|.
name|tq2
operator|=
operator|(
name|int
operator|)
name|t
operator|->
name|type_qualifiers
index|[
literal|2
index|]
expr_stmt|;
name|aux
operator|.
name|ti
operator|.
name|tq3
operator|=
operator|(
name|int
operator|)
name|t
operator|->
name|type_qualifiers
index|[
literal|3
index|]
expr_stmt|;
name|aux
operator|.
name|ti
operator|.
name|tq4
operator|=
operator|(
name|int
operator|)
name|t
operator|->
name|type_qualifiers
index|[
literal|4
index|]
expr_stmt|;
name|aux
operator|.
name|ti
operator|.
name|tq5
operator|=
operator|(
name|int
operator|)
name|t
operator|->
name|type_qualifiers
index|[
literal|5
index|]
expr_stmt|;
comment|/* For anything that adds additional information, we must not hash,      so check here, and reset our state.  */
if|if
condition|(
name|state
operator|!=
name|hash_no
operator|&&
operator|(
name|t
operator|->
name|type_qualifiers
index|[
literal|0
index|]
operator|==
name|tq_Array
operator|||
name|t
operator|->
name|type_qualifiers
index|[
literal|1
index|]
operator|==
name|tq_Array
operator|||
name|t
operator|->
name|type_qualifiers
index|[
literal|2
index|]
operator|==
name|tq_Array
operator|||
name|t
operator|->
name|type_qualifiers
index|[
literal|3
index|]
operator|==
name|tq_Array
operator|||
name|t
operator|->
name|type_qualifiers
index|[
literal|4
index|]
operator|==
name|tq_Array
operator|||
name|t
operator|->
name|type_qualifiers
index|[
literal|5
index|]
operator|==
name|tq_Array
operator|||
name|t
operator|->
name|basic_type
operator|==
name|bt_Struct
operator|||
name|t
operator|->
name|basic_type
operator|==
name|bt_Union
operator|||
name|t
operator|->
name|basic_type
operator|==
name|bt_Enum
operator|||
name|t
operator|->
name|bitfield
operator|||
name|t
operator|->
name|num_dims
operator|>
literal|0
operator|)
condition|)
name|state
operator|=
name|hash_no
expr_stmt|;
comment|/* See if we can hash this type, and save some space, but some types      can't be hashed (because they contain arrays or continuations),      and others can be put into the hash list, but cannot use existing      types because other aux entries precede this one.  */
if|if
condition|(
name|state
operator|!=
name|hash_no
condition|)
block|{
name|thash_t
modifier|*
name|hash_ptr
decl_stmt|;
name|symint_t
name|hi
decl_stmt|;
name|hi
operator|=
name|aux
operator|.
name|isym
operator|&
operator|(
operator|(
literal|1
operator|<<
name|HASHBITS
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
name|hi
operator|%=
name|THASH_SIZE
expr_stmt|;
for|for
control|(
name|hash_ptr
operator|=
name|hash_tbl
index|[
name|hi
index|]
init|;
name|hash_ptr
operator|!=
operator|(
name|thash_t
operator|*
operator|)
literal|0
condition|;
name|hash_ptr
operator|=
name|hash_ptr
operator|->
name|next
control|)
block|{
if|if
condition|(
name|aux
operator|.
name|isym
operator|==
name|hash_ptr
operator|->
name|type
operator|.
name|isym
condition|)
break|break;
block|}
if|if
condition|(
name|hash_ptr
operator|!=
operator|(
name|thash_t
operator|*
operator|)
literal|0
operator|&&
name|state
operator|==
name|hash_yes
condition|)
return|return
name|hash_ptr
operator|->
name|indx
return|;
if|if
condition|(
name|hash_ptr
operator|==
operator|(
name|thash_t
operator|*
operator|)
literal|0
condition|)
block|{
name|hash_ptr
operator|=
name|allocate_thash
argument_list|()
expr_stmt|;
name|hash_ptr
operator|->
name|next
operator|=
name|hash_tbl
index|[
name|hi
index|]
expr_stmt|;
name|hash_ptr
operator|->
name|type
operator|=
name|aux
expr_stmt|;
name|hash_ptr
operator|->
name|indx
operator|=
name|vp
operator|->
name|num_allocated
expr_stmt|;
name|hash_tbl
index|[
name|hi
index|]
operator|=
name|hash_ptr
expr_stmt|;
block|}
block|}
comment|/* Everything is set up, add the aux symbol.  */
if|if
condition|(
name|vp
operator|->
name|objects_last_page
operator|==
name|vp
operator|->
name|objects_per_page
condition|)
name|add_varray_page
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|aux_ptr
operator|=
operator|&
name|vp
operator|->
name|last
operator|->
name|datum
operator|->
name|aux
index|[
name|vp
operator|->
name|objects_last_page
operator|++
index|]
expr_stmt|;
operator|*
name|aux_ptr
operator|=
name|aux
expr_stmt|;
name|ret
operator|=
name|vp
operator|->
name|num_allocated
operator|++
expr_stmt|;
comment|/* Add bitfield length if it exists.            NOTE:  Mips documentation claims bitfield goes at the end of the      AUX record, but the DECstation compiler emits it here.      (This would only make a difference for enum bitfields.)       Also note:  We use the last size given since gcc may emit 2      for an enum bitfield.  */
if|if
condition|(
name|t
operator|->
name|bitfield
condition|)
operator|(
name|void
operator|)
name|add_aux_sym_symint
argument_list|(
operator|(
name|symint_t
operator|)
name|t
operator|->
name|sizes
index|[
name|t
operator|->
name|num_sizes
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* Add tag information if needed.  Structure, union, and enum      references add 2 aux symbols: a [file index, symbol index]      pointer to the structure type, and the current file index.  */
if|if
condition|(
name|t
operator|->
name|basic_type
operator|==
name|bt_Struct
operator|||
name|t
operator|->
name|basic_type
operator|==
name|bt_Union
operator|||
name|t
operator|->
name|basic_type
operator|==
name|bt_Enum
condition|)
block|{
name|symint_t
name|file_index
init|=
name|t
operator|->
name|tag_ptr
operator|->
name|ifd
decl_stmt|;
name|symint_t
name|sym_index
init|=
name|t
operator|->
name|tag_ptr
operator|->
name|indx
decl_stmt|;
if|if
condition|(
name|t
operator|->
name|unknown_tag
condition|)
block|{
operator|(
name|void
operator|)
name|add_aux_sym_rndx
argument_list|(
name|ST_RFDESCAPE
argument_list|,
name|sym_index
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|add_aux_sym_symint
argument_list|(
operator|(
name|symint_t
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sym_index
operator|!=
name|indexNil
condition|)
block|{
operator|(
name|void
operator|)
name|add_aux_sym_rndx
argument_list|(
name|ST_RFDESCAPE
argument_list|,
name|sym_index
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|add_aux_sym_symint
argument_list|(
name|file_index
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|forward_t
modifier|*
name|forward_ref
init|=
name|allocate_forward
argument_list|()
decl_stmt|;
name|forward_ref
operator|->
name|type_ptr
operator|=
name|aux_ptr
expr_stmt|;
name|forward_ref
operator|->
name|next
operator|=
name|t
operator|->
name|tag_ptr
operator|->
name|forward_ref
expr_stmt|;
name|t
operator|->
name|tag_ptr
operator|->
name|forward_ref
operator|=
name|forward_ref
expr_stmt|;
operator|(
name|void
operator|)
name|add_aux_sym_rndx
argument_list|(
name|ST_RFDESCAPE
argument_list|,
name|sym_index
argument_list|)
expr_stmt|;
name|forward_ref
operator|->
name|index_ptr
operator|=
operator|&
name|vp
operator|->
name|last
operator|->
name|datum
operator|->
name|aux
index|[
name|vp
operator|->
name|objects_last_page
operator|-
literal|1
index|]
expr_stmt|;
operator|(
name|void
operator|)
name|add_aux_sym_symint
argument_list|(
name|file_index
argument_list|)
expr_stmt|;
name|forward_ref
operator|->
name|ifd_ptr
operator|=
operator|&
name|vp
operator|->
name|last
operator|->
name|datum
operator|->
name|aux
index|[
name|vp
operator|->
name|objects_last_page
operator|-
literal|1
index|]
expr_stmt|;
block|}
block|}
comment|/* Add information about array bounds if they exist.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|t
operator|->
name|num_dims
condition|;
name|i
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|add_aux_sym_rndx
argument_list|(
name|ST_RFDESCAPE
argument_list|,
name|cur_file_ptr
operator|->
name|int_type
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|add_aux_sym_symint
argument_list|(
name|cur_file_ptr
operator|->
name|file_index
argument_list|)
expr_stmt|;
comment|/* file index*/
operator|(
name|void
operator|)
name|add_aux_sym_symint
argument_list|(
operator|(
name|symint_t
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/* low bound */
operator|(
name|void
operator|)
name|add_aux_sym_symint
argument_list|(
name|t
operator|->
name|dimensions
index|[
name|i
index|]
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* high bound*/
operator|(
name|void
operator|)
name|add_aux_sym_symint
argument_list|(
operator|(
name|t
operator|->
name|dimensions
index|[
name|i
index|]
operator|==
literal|0
operator|)
comment|/* stride */
condition|?
literal|0
else|:
operator|(
name|t
operator|->
name|sizes
index|[
name|i
index|]
operator|*
literal|8
operator|)
operator|/
name|t
operator|->
name|dimensions
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
comment|/* NOTE:  Mips documentation claims that the bitfield width goes here.      But it needs to be emitted earlier.  */
return|return
name|ret
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Add a tag to the tag table (unless it already exists).  */
end_comment

begin_function
name|STATIC
name|tag_t
modifier|*
name|get_tag
parameter_list|(
name|tag_start
parameter_list|,
name|tag_end_p1
parameter_list|,
name|indx
parameter_list|,
name|basic_type
parameter_list|)
specifier|const
name|char
modifier|*
name|tag_start
decl_stmt|;
comment|/* 1st byte of tag name */
specifier|const
name|char
modifier|*
name|tag_end_p1
decl_stmt|;
comment|/* 1st byte after tag name */
name|symint_t
name|indx
decl_stmt|;
comment|/* index of tag start block */
name|bt_t
name|basic_type
decl_stmt|;
comment|/* bt_Struct, bt_Union, or bt_Enum */
block|{
name|shash_t
modifier|*
name|hash_ptr
decl_stmt|;
name|tag_t
modifier|*
name|tag_ptr
decl_stmt|;
name|hash_ptr
operator|=
name|hash_string
argument_list|(
name|tag_start
argument_list|,
name|tag_end_p1
operator|-
name|tag_start
argument_list|,
operator|&
name|tag_hash
index|[
literal|0
index|]
argument_list|,
operator|(
name|symint_t
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|hash_ptr
operator|!=
operator|(
name|shash_t
operator|*
operator|)
literal|0
operator|&&
name|hash_ptr
operator|->
name|tag_ptr
operator|!=
operator|(
name|tag_t
operator|*
operator|)
literal|0
condition|)
block|{
name|tag_ptr
operator|=
name|hash_ptr
operator|->
name|tag_ptr
expr_stmt|;
if|if
condition|(
name|indx
operator|!=
name|indexNil
condition|)
block|{
name|tag_ptr
operator|->
name|basic_type
operator|=
name|basic_type
expr_stmt|;
name|tag_ptr
operator|->
name|ifd
operator|=
name|cur_file_ptr
operator|->
name|file_index
expr_stmt|;
name|tag_ptr
operator|->
name|indx
operator|=
name|indx
expr_stmt|;
block|}
return|return
name|tag_ptr
return|;
block|}
operator|(
name|void
operator|)
name|add_string
argument_list|(
operator|&
name|tag_strings
argument_list|,
operator|&
name|tag_hash
index|[
literal|0
index|]
argument_list|,
name|tag_start
argument_list|,
name|tag_end_p1
argument_list|,
operator|&
name|hash_ptr
argument_list|)
expr_stmt|;
name|tag_ptr
operator|=
name|allocate_tag
argument_list|()
expr_stmt|;
name|tag_ptr
operator|->
name|forward_ref
operator|=
operator|(
name|forward_t
operator|*
operator|)
literal|0
expr_stmt|;
name|tag_ptr
operator|->
name|hash_ptr
operator|=
name|hash_ptr
expr_stmt|;
name|tag_ptr
operator|->
name|same_name
operator|=
name|hash_ptr
operator|->
name|tag_ptr
expr_stmt|;
name|tag_ptr
operator|->
name|basic_type
operator|=
name|basic_type
expr_stmt|;
name|tag_ptr
operator|->
name|indx
operator|=
name|indx
expr_stmt|;
name|tag_ptr
operator|->
name|ifd
operator|=
operator|(
name|indx
operator|==
name|indexNil
condition|?
operator|(
name|symint_t
operator|)
operator|-
literal|1
else|:
name|cur_file_ptr
operator|->
name|file_index
operator|)
expr_stmt|;
name|tag_ptr
operator|->
name|same_block
operator|=
name|cur_tag_head
operator|->
name|first_tag
expr_stmt|;
name|cur_tag_head
operator|->
name|first_tag
operator|=
name|tag_ptr
expr_stmt|;
name|hash_ptr
operator|->
name|tag_ptr
operator|=
name|tag_ptr
expr_stmt|;
return|return
name|tag_ptr
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Add an unknown {struct, union, enum} tag.  */
end_comment

begin_function
name|STATIC
name|void
name|add_unknown_tag
parameter_list|(
name|ptag
parameter_list|)
name|tag_t
modifier|*
name|ptag
decl_stmt|;
comment|/* pointer to tag information */
block|{
name|shash_t
modifier|*
name|hash_ptr
init|=
name|ptag
operator|->
name|hash_ptr
decl_stmt|;
name|char
modifier|*
name|name_start
init|=
name|hash_ptr
operator|->
name|string
decl_stmt|;
name|char
modifier|*
name|name_end_p1
init|=
name|name_start
operator|+
name|hash_ptr
operator|->
name|len
decl_stmt|;
name|forward_t
modifier|*
name|f_next
init|=
name|ptag
operator|->
name|forward_ref
decl_stmt|;
name|forward_t
modifier|*
name|f_cur
decl_stmt|;
name|int
name|sym_index
decl_stmt|;
name|int
name|file_index
init|=
name|cur_file_ptr
operator|->
name|file_index
decl_stmt|;
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
block|{
specifier|const
name|char
modifier|*
name|agg_type
init|=
literal|"{unknown aggregate type}"
decl_stmt|;
switch|switch
condition|(
name|ptag
operator|->
name|basic_type
condition|)
block|{
case|case
name|bt_Struct
case|:
name|agg_type
operator|=
literal|"struct"
expr_stmt|;
break|break;
case|case
name|bt_Union
case|:
name|agg_type
operator|=
literal|"union"
expr_stmt|;
break|break;
case|case
name|bt_Enum
case|:
name|agg_type
operator|=
literal|"enum"
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"unknown %s %.*s found\n"
argument_list|,
name|agg_type
argument_list|,
operator|(
name|int
operator|)
name|hash_ptr
operator|->
name|len
argument_list|,
name|name_start
argument_list|)
expr_stmt|;
block|}
name|sym_index
operator|=
name|add_local_symbol
argument_list|(
name|name_start
argument_list|,
name|name_end_p1
argument_list|,
name|st_Block
argument_list|,
name|sc_Info
argument_list|,
operator|(
name|symint_t
operator|)
literal|0
argument_list|,
operator|(
name|symint_t
operator|)
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|add_local_symbol
argument_list|(
name|name_start
argument_list|,
name|name_end_p1
argument_list|,
name|st_End
argument_list|,
name|sc_Info
argument_list|,
operator|(
name|symint_t
operator|)
literal|0
argument_list|,
operator|(
name|symint_t
operator|)
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|f_next
operator|!=
operator|(
name|forward_t
operator|*
operator|)
literal|0
condition|)
block|{
name|f_cur
operator|=
name|f_next
expr_stmt|;
name|f_next
operator|=
name|f_next
operator|->
name|next
expr_stmt|;
name|f_cur
operator|->
name|ifd_ptr
operator|->
name|isym
operator|=
name|file_index
expr_stmt|;
name|f_cur
operator|->
name|index_ptr
operator|->
name|rndx
operator|.
name|index
operator|=
name|sym_index
expr_stmt|;
name|free_forward
argument_list|(
name|f_cur
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Add a procedure to the current file's list of procedures, and record    this is the current procedure.  If the assembler created a PDR for    this procedure, use that to initialize the current PDR.  */
end_comment

begin_function
name|STATIC
name|void
name|add_procedure
parameter_list|(
name|func_start
parameter_list|,
name|func_end_p1
parameter_list|)
specifier|const
name|char
modifier|*
name|func_start
decl_stmt|;
comment|/* 1st byte of func name */
specifier|const
name|char
modifier|*
name|func_end_p1
decl_stmt|;
comment|/* 1st byte after func name */
block|{
name|PDR
modifier|*
name|new_proc_ptr
decl_stmt|;
name|efdr_t
modifier|*
name|file_ptr
init|=
name|cur_file_ptr
decl_stmt|;
name|varray_t
modifier|*
name|vp
init|=
operator|&
name|file_ptr
operator|->
name|procs
decl_stmt|;
name|symint_t
name|value
init|=
literal|0
decl_stmt|;
name|st_t
name|proc_type
init|=
name|st_Proc
decl_stmt|;
name|shash_t
modifier|*
name|shash_ptr
init|=
name|hash_string
argument_list|(
name|func_start
argument_list|,
name|func_end_p1
operator|-
name|func_start
argument_list|,
operator|&
name|orig_str_hash
index|[
literal|0
index|]
argument_list|,
operator|(
name|symint_t
operator|*
operator|)
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|debug
condition|)
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|objects_last_page
operator|==
name|vp
operator|->
name|objects_per_page
condition|)
name|add_varray_page
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|cur_proc_ptr
operator|=
name|new_proc_ptr
operator|=
operator|&
name|vp
operator|->
name|last
operator|->
name|datum
operator|->
name|proc
index|[
name|vp
operator|->
name|objects_last_page
operator|++
index|]
expr_stmt|;
name|vp
operator|->
name|num_allocated
operator|++
expr_stmt|;
comment|/* Did the assembler create this procedure?  If so, get the PDR information.  */
name|cur_oproc_ptr
operator|=
operator|(
name|PDR
operator|*
operator|)
literal|0
expr_stmt|;
if|if
condition|(
name|shash_ptr
operator|!=
operator|(
name|shash_t
operator|*
operator|)
literal|0
condition|)
block|{
name|PDR
modifier|*
name|old_proc_ptr
init|=
name|shash_ptr
operator|->
name|proc_ptr
decl_stmt|;
name|SYMR
modifier|*
name|sym_ptr
init|=
name|shash_ptr
operator|->
name|sym_ptr
decl_stmt|;
if|if
condition|(
name|old_proc_ptr
operator|!=
operator|(
name|PDR
operator|*
operator|)
literal|0
operator|&&
name|sym_ptr
operator|!=
operator|(
name|SYMR
operator|*
operator|)
literal|0
operator|&&
operator|(
operator|(
name|st_t
operator|)
name|sym_ptr
operator|->
name|st
operator|==
name|st_Proc
operator|||
operator|(
name|st_t
operator|)
name|sym_ptr
operator|->
name|st
operator|==
name|st_StaticProc
operator|)
condition|)
block|{
name|cur_oproc_begin
operator|=
name|sym_ptr
expr_stmt|;
name|cur_oproc_end
operator|=
name|shash_ptr
operator|->
name|end_ptr
expr_stmt|;
name|value
operator|=
name|sym_ptr
operator|->
name|value
expr_stmt|;
name|cur_oproc_ptr
operator|=
name|old_proc_ptr
expr_stmt|;
name|proc_type
operator|=
operator|(
name|st_t
operator|)
name|sym_ptr
operator|->
name|st
expr_stmt|;
operator|*
name|new_proc_ptr
operator|=
operator|*
name|old_proc_ptr
expr_stmt|;
comment|/* initialize */
block|}
block|}
if|if
condition|(
name|cur_oproc_ptr
operator|==
operator|(
name|PDR
operator|*
operator|)
literal|0
condition|)
name|error
argument_list|(
literal|"did not find a PDR block for %.*s"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|func_end_p1
operator|-
name|func_start
argument_list|)
argument_list|,
name|func_start
argument_list|)
expr_stmt|;
comment|/* Determine the start of symbols.  */
name|new_proc_ptr
operator|->
name|isym
operator|=
name|file_ptr
operator|->
name|symbols
operator|.
name|num_allocated
expr_stmt|;
comment|/* Push the start of the function.  */
operator|(
name|void
operator|)
name|add_local_symbol
argument_list|(
name|func_start
argument_list|,
name|func_end_p1
argument_list|,
name|proc_type
argument_list|,
name|sc_Text
argument_list|,
name|value
argument_list|,
operator|(
name|symint_t
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Add a new filename, and set up all of the file relative    virtual arrays (strings, symbols, aux syms, etc.).  Record    where the current file structure lives.  */
end_comment

begin_function
name|STATIC
name|void
name|add_file
parameter_list|(
name|file_start
parameter_list|,
name|file_end_p1
parameter_list|)
specifier|const
name|char
modifier|*
name|file_start
decl_stmt|;
comment|/* first byte in string */
specifier|const
name|char
modifier|*
name|file_end_p1
decl_stmt|;
comment|/* first byte after string */
block|{
specifier|static
name|char
name|zero_bytes
index|[
literal|2
index|]
init|=
block|{
literal|'\0'
block|,
literal|'\0'
block|}
decl_stmt|;
name|Ptrdiff_t
name|len
init|=
name|file_end_p1
operator|-
name|file_start
decl_stmt|;
name|int
name|first_ch
init|=
operator|*
name|file_start
decl_stmt|;
name|efdr_t
modifier|*
name|file_ptr
decl_stmt|;
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tfile\t%.*s\n"
argument_list|,
operator|(
name|int
operator|)
name|len
argument_list|,
name|file_start
argument_list|)
expr_stmt|;
comment|/* See if the file has already been created.  */
for|for
control|(
name|file_ptr
operator|=
name|first_file
init|;
name|file_ptr
operator|!=
operator|(
name|efdr_t
operator|*
operator|)
literal|0
condition|;
name|file_ptr
operator|=
name|file_ptr
operator|->
name|next_file
control|)
block|{
if|if
condition|(
name|first_ch
operator|==
name|file_ptr
operator|->
name|name
index|[
literal|0
index|]
operator|&&
name|file_ptr
operator|->
name|name
index|[
name|len
index|]
operator|==
literal|'\0'
operator|&&
name|memcmp
argument_list|(
name|file_start
argument_list|,
name|file_ptr
operator|->
name|name
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cur_file_ptr
operator|=
name|file_ptr
expr_stmt|;
break|break;
block|}
block|}
comment|/* If this is a new file, create it.  */
if|if
condition|(
name|file_ptr
operator|==
operator|(
name|efdr_t
operator|*
operator|)
literal|0
condition|)
block|{
if|if
condition|(
name|file_desc
operator|.
name|objects_last_page
operator|==
name|file_desc
operator|.
name|objects_per_page
condition|)
name|add_varray_page
argument_list|(
operator|&
name|file_desc
argument_list|)
expr_stmt|;
name|file_ptr
operator|=
name|cur_file_ptr
operator|=
operator|&
name|file_desc
operator|.
name|last
operator|->
name|datum
operator|->
name|file
index|[
name|file_desc
operator|.
name|objects_last_page
operator|++
index|]
expr_stmt|;
operator|*
name|file_ptr
operator|=
name|init_file
expr_stmt|;
name|file_ptr
operator|->
name|file_index
operator|=
name|file_desc
operator|.
name|num_allocated
operator|++
expr_stmt|;
comment|/* Allocate the string hash table.  */
name|file_ptr
operator|->
name|shash_head
operator|=
operator|(
name|shash_t
operator|*
operator|*
operator|)
name|allocate_page
argument_list|()
expr_stmt|;
comment|/* Make sure 0 byte in string table is null  */
name|add_string
argument_list|(
operator|&
name|file_ptr
operator|->
name|strings
argument_list|,
operator|&
name|file_ptr
operator|->
name|shash_head
index|[
literal|0
index|]
argument_list|,
operator|&
name|zero_bytes
index|[
literal|0
index|]
argument_list|,
operator|&
name|zero_bytes
index|[
literal|0
index|]
argument_list|,
operator|(
name|shash_t
operator|*
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|file_end_p1
operator|-
name|file_start
operator|>
operator|(
name|long
operator|)
name|PAGE_USIZE
operator|-
literal|2
condition|)
name|fatal
argument_list|(
literal|"filename goes over one page boundary"
argument_list|)
expr_stmt|;
comment|/* Push the start of the filename. We assume that the filename          will be stored at string offset 1.  */
operator|(
name|void
operator|)
name|add_local_symbol
argument_list|(
name|file_start
argument_list|,
name|file_end_p1
argument_list|,
name|st_File
argument_list|,
name|sc_Text
argument_list|,
operator|(
name|symint_t
operator|)
literal|0
argument_list|,
operator|(
name|symint_t
operator|)
literal|0
argument_list|)
expr_stmt|;
name|file_ptr
operator|->
name|fdr
operator|.
name|rss
operator|=
literal|1
expr_stmt|;
name|file_ptr
operator|->
name|name
operator|=
operator|&
name|file_ptr
operator|->
name|strings
operator|.
name|last
operator|->
name|datum
operator|->
name|byte
index|[
literal|1
index|]
expr_stmt|;
name|file_ptr
operator|->
name|name_len
operator|=
name|file_end_p1
operator|-
name|file_start
expr_stmt|;
comment|/* Update the linked list of file descriptors.  */
operator|*
name|last_file_ptr
operator|=
name|file_ptr
expr_stmt|;
name|last_file_ptr
operator|=
operator|&
name|file_ptr
operator|->
name|next_file
expr_stmt|;
comment|/* Add void& int types to the file (void should be first to catch 	 errant 0's within the index fields).  */
name|file_ptr
operator|->
name|void_type
operator|=
name|add_aux_sym_tir
argument_list|(
operator|&
name|void_type_info
argument_list|,
name|hash_yes
argument_list|,
operator|&
name|cur_file_ptr
operator|->
name|thash_head
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|file_ptr
operator|->
name|int_type
operator|=
name|add_aux_sym_tir
argument_list|(
operator|&
name|int_type_info
argument_list|,
name|hash_yes
argument_list|,
operator|&
name|cur_file_ptr
operator|->
name|thash_head
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Add a stream of random bytes to a varray.  */
end_comment

begin_function
name|STATIC
name|void
name|add_bytes
parameter_list|(
name|vp
parameter_list|,
name|input_ptr
parameter_list|,
name|nitems
parameter_list|)
name|varray_t
modifier|*
name|vp
decl_stmt|;
comment|/* virtual array to add too */
name|char
modifier|*
name|input_ptr
decl_stmt|;
comment|/* start of the bytes */
name|Size_t
name|nitems
decl_stmt|;
comment|/* # items to move */
block|{
name|Size_t
name|move_items
decl_stmt|;
name|Size_t
name|move_bytes
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
while|while
condition|(
name|nitems
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|vp
operator|->
name|objects_last_page
operator|>=
name|vp
operator|->
name|objects_per_page
condition|)
name|add_varray_page
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|ptr
operator|=
operator|&
name|vp
operator|->
name|last
operator|->
name|datum
operator|->
name|byte
index|[
name|vp
operator|->
name|objects_last_page
operator|*
name|vp
operator|->
name|object_size
index|]
expr_stmt|;
name|move_items
operator|=
name|vp
operator|->
name|objects_per_page
operator|-
name|vp
operator|->
name|objects_last_page
expr_stmt|;
if|if
condition|(
name|move_items
operator|>
name|nitems
condition|)
name|move_items
operator|=
name|nitems
expr_stmt|;
name|move_bytes
operator|=
name|move_items
operator|*
name|vp
operator|->
name|object_size
expr_stmt|;
name|nitems
operator|-=
name|move_items
expr_stmt|;
if|if
condition|(
name|move_bytes
operator|>=
literal|32
condition|)
block|{
operator|(
name|void
operator|)
name|memcpy
argument_list|(
name|ptr
argument_list|,
name|input_ptr
argument_list|,
name|move_bytes
argument_list|)
expr_stmt|;
name|input_ptr
operator|+=
name|move_bytes
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|move_bytes
operator|--
operator|>
literal|0
condition|)
operator|*
name|ptr
operator|++
operator|=
operator|*
name|input_ptr
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Convert storage class to string.  */
end_comment

begin_function
name|STATIC
specifier|const
name|char
modifier|*
name|sc_to_string
parameter_list|(
name|storage_class
parameter_list|)
name|sc_t
name|storage_class
decl_stmt|;
block|{
switch|switch
condition|(
name|storage_class
condition|)
block|{
case|case
name|sc_Nil
case|:
return|return
literal|"Nil,"
return|;
case|case
name|sc_Text
case|:
return|return
literal|"Text,"
return|;
case|case
name|sc_Data
case|:
return|return
literal|"Data,"
return|;
case|case
name|sc_Bss
case|:
return|return
literal|"Bss,"
return|;
case|case
name|sc_Register
case|:
return|return
literal|"Register,"
return|;
case|case
name|sc_Abs
case|:
return|return
literal|"Abs,"
return|;
case|case
name|sc_Undefined
case|:
return|return
literal|"Undefined,"
return|;
case|case
name|sc_CdbLocal
case|:
return|return
literal|"CdbLocal,"
return|;
case|case
name|sc_Bits
case|:
return|return
literal|"Bits,"
return|;
case|case
name|sc_CdbSystem
case|:
return|return
literal|"CdbSystem,"
return|;
case|case
name|sc_RegImage
case|:
return|return
literal|"RegImage,"
return|;
case|case
name|sc_Info
case|:
return|return
literal|"Info,"
return|;
case|case
name|sc_UserStruct
case|:
return|return
literal|"UserStruct,"
return|;
case|case
name|sc_SData
case|:
return|return
literal|"SData,"
return|;
case|case
name|sc_SBss
case|:
return|return
literal|"SBss,"
return|;
case|case
name|sc_RData
case|:
return|return
literal|"RData,"
return|;
case|case
name|sc_Var
case|:
return|return
literal|"Var,"
return|;
case|case
name|sc_Common
case|:
return|return
literal|"Common,"
return|;
case|case
name|sc_SCommon
case|:
return|return
literal|"SCommon,"
return|;
case|case
name|sc_VarRegister
case|:
return|return
literal|"VarRegister,"
return|;
case|case
name|sc_Variant
case|:
return|return
literal|"Variant,"
return|;
case|case
name|sc_SUndefined
case|:
return|return
literal|"SUndefined,"
return|;
case|case
name|sc_Init
case|:
return|return
literal|"Init,"
return|;
case|case
name|sc_Max
case|:
return|return
literal|"Max,"
return|;
block|}
return|return
literal|"???,"
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Convert symbol type to string.  */
end_comment

begin_function
name|STATIC
specifier|const
name|char
modifier|*
name|st_to_string
parameter_list|(
name|symbol_type
parameter_list|)
name|st_t
name|symbol_type
decl_stmt|;
block|{
switch|switch
condition|(
name|symbol_type
condition|)
block|{
case|case
name|st_Nil
case|:
return|return
literal|"Nil,"
return|;
case|case
name|st_Global
case|:
return|return
literal|"Global,"
return|;
case|case
name|st_Static
case|:
return|return
literal|"Static,"
return|;
case|case
name|st_Param
case|:
return|return
literal|"Param,"
return|;
case|case
name|st_Local
case|:
return|return
literal|"Local,"
return|;
case|case
name|st_Label
case|:
return|return
literal|"Label,"
return|;
case|case
name|st_Proc
case|:
return|return
literal|"Proc,"
return|;
case|case
name|st_Block
case|:
return|return
literal|"Block,"
return|;
case|case
name|st_End
case|:
return|return
literal|"End,"
return|;
case|case
name|st_Member
case|:
return|return
literal|"Member,"
return|;
case|case
name|st_Typedef
case|:
return|return
literal|"Typedef,"
return|;
case|case
name|st_File
case|:
return|return
literal|"File,"
return|;
case|case
name|st_RegReloc
case|:
return|return
literal|"RegReloc,"
return|;
case|case
name|st_Forward
case|:
return|return
literal|"Forward,"
return|;
case|case
name|st_StaticProc
case|:
return|return
literal|"StaticProc,"
return|;
case|case
name|st_Constant
case|:
return|return
literal|"Constant,"
return|;
case|case
name|st_Str
case|:
return|return
literal|"String,"
return|;
case|case
name|st_Number
case|:
return|return
literal|"Number,"
return|;
case|case
name|st_Expr
case|:
return|return
literal|"Expr,"
return|;
case|case
name|st_Type
case|:
return|return
literal|"Type,"
return|;
case|case
name|st_Max
case|:
return|return
literal|"Max,"
return|;
block|}
return|return
literal|"???,"
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Read a line from standard input, and return the start of the buffer    (which is grows if the line is too big).  We split lines at the    semi-colon, and return each logical line independently.  */
end_comment

begin_function
name|STATIC
name|char
modifier|*
name|read_line
parameter_list|()
block|{
specifier|static
name|int
name|line_split_p
init|=
literal|0
decl_stmt|;
name|int
name|string_p
init|=
literal|0
decl_stmt|;
name|int
name|comment_p
init|=
literal|0
decl_stmt|;
name|int
name|ch
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
if|if
condition|(
name|cur_line_start
operator|==
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
block|{
comment|/* allocate initial page */
name|cur_line_start
operator|=
operator|(
name|char
operator|*
operator|)
name|allocate_page
argument_list|()
expr_stmt|;
name|cur_line_alloc
operator|=
name|PAGE_SIZE
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|line_split_p
condition|)
name|line_number
operator|++
expr_stmt|;
name|line_split_p
operator|=
literal|0
expr_stmt|;
name|cur_line_nbytes
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ptr
operator|=
name|cur_line_start
init|;
operator|(
name|ch
operator|=
name|getchar
argument_list|()
operator|)
operator|!=
name|EOF
condition|;
operator|*
name|ptr
operator|++
operator|=
name|ch
control|)
block|{
if|if
condition|(
operator|++
name|cur_line_nbytes
operator|>=
name|cur_line_alloc
operator|-
literal|1
condition|)
block|{
name|int
name|num_pages
init|=
name|cur_line_alloc
operator|/
name|PAGE_SIZE
decl_stmt|;
name|char
modifier|*
name|old_buffer
init|=
name|cur_line_start
decl_stmt|;
name|cur_line_alloc
operator|+=
name|PAGE_SIZE
expr_stmt|;
name|cur_line_start
operator|=
operator|(
name|char
operator|*
operator|)
name|allocate_multiple_pages
argument_list|(
name|num_pages
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|cur_line_start
argument_list|,
name|old_buffer
argument_list|,
name|num_pages
operator|*
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|cur_line_start
operator|+
name|cur_line_nbytes
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|ch
operator|==
literal|'\n'
condition|)
block|{
operator|*
name|ptr
operator|++
operator|=
literal|'\n'
expr_stmt|;
operator|*
name|ptr
operator|=
literal|'\0'
expr_stmt|;
name|cur_line_ptr
operator|=
name|cur_line_start
expr_stmt|;
return|return
name|cur_line_ptr
return|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'\0'
condition|)
name|error
argument_list|(
literal|"null character found in input"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|comment_p
condition|)
block|{
if|if
condition|(
name|ch
operator|==
literal|'"'
condition|)
name|string_p
operator|=
operator|!
name|string_p
expr_stmt|;
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'#'
condition|)
name|comment_p
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|ch
operator|==
literal|';'
operator|&&
operator|!
name|string_p
condition|)
block|{
name|line_split_p
operator|=
literal|1
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
literal|'\n'
expr_stmt|;
operator|*
name|ptr
operator|=
literal|'\0'
expr_stmt|;
name|cur_line_ptr
operator|=
name|cur_line_start
expr_stmt|;
return|return
name|cur_line_ptr
return|;
block|}
block|}
block|}
if|if
condition|(
name|ferror
argument_list|(
name|stdin
argument_list|)
condition|)
name|pfatal_with_name
argument_list|(
name|input_name
argument_list|)
expr_stmt|;
name|cur_line_ptr
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
return|return
operator|(
name|char
operator|*
operator|)
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Parse #.begin directives which have a label as the first argument    which gives the location of the start of the block.  */
end_comment

begin_function
name|STATIC
name|void
name|parse_begin
parameter_list|(
name|start
parameter_list|)
specifier|const
name|char
modifier|*
name|start
decl_stmt|;
comment|/* start of directive */
block|{
specifier|const
name|char
modifier|*
name|end_p1
decl_stmt|;
comment|/* end of label */
name|int
name|ch
decl_stmt|;
name|shash_t
modifier|*
name|hash_ptr
decl_stmt|;
comment|/* hash pointer to lookup label */
if|if
condition|(
name|cur_file_ptr
operator|==
operator|(
name|efdr_t
operator|*
operator|)
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"#.begin directive without a preceding .file directive"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|cur_proc_ptr
operator|==
operator|(
name|PDR
operator|*
operator|)
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"#.begin directive without a preceding .ent directive"
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|end_p1
operator|=
name|start
init|;
operator|(
name|ch
operator|=
operator|*
name|end_p1
operator|)
operator|!=
literal|'\0'
operator|&&
operator|!
name|ISSPACE
argument_list|(
name|ch
argument_list|)
condition|;
name|end_p1
operator|++
control|)
empty_stmt|;
name|hash_ptr
operator|=
name|hash_string
argument_list|(
name|start
argument_list|,
name|end_p1
operator|-
name|start
argument_list|,
operator|&
name|orig_str_hash
index|[
literal|0
index|]
argument_list|,
operator|(
name|symint_t
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|hash_ptr
operator|==
operator|(
name|shash_t
operator|*
operator|)
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"label %.*s not found for #.begin"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|end_p1
operator|-
name|start
argument_list|)
argument_list|,
name|start
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|cur_oproc_begin
operator|==
operator|(
name|SYMR
operator|*
operator|)
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"procedure table %.*s not found for #.begin"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|end_p1
operator|-
name|start
argument_list|)
argument_list|,
name|start
argument_list|)
expr_stmt|;
return|return;
block|}
operator|(
name|void
operator|)
name|add_local_symbol
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
literal|0
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
literal|0
argument_list|,
name|st_Block
argument_list|,
name|sc_Text
argument_list|,
operator|(
name|symint_t
operator|)
name|hash_ptr
operator|->
name|sym_ptr
operator|->
name|value
operator|-
name|cur_oproc_begin
operator|->
name|value
argument_list|,
operator|(
name|symint_t
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Parse #.bend directives which have a label as the first argument    which gives the location of the end of the block.  */
end_comment

begin_function
name|STATIC
name|void
name|parse_bend
parameter_list|(
name|start
parameter_list|)
specifier|const
name|char
modifier|*
name|start
decl_stmt|;
comment|/* start of directive */
block|{
specifier|const
name|char
modifier|*
name|end_p1
decl_stmt|;
comment|/* end of label */
name|int
name|ch
decl_stmt|;
name|shash_t
modifier|*
name|hash_ptr
decl_stmt|;
comment|/* hash pointer to lookup label */
if|if
condition|(
name|cur_file_ptr
operator|==
operator|(
name|efdr_t
operator|*
operator|)
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"#.begin directive without a preceding .file directive"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|cur_proc_ptr
operator|==
operator|(
name|PDR
operator|*
operator|)
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"#.bend directive without a preceding .ent directive"
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|end_p1
operator|=
name|start
init|;
operator|(
name|ch
operator|=
operator|*
name|end_p1
operator|)
operator|!=
literal|'\0'
operator|&&
operator|!
name|ISSPACE
argument_list|(
name|ch
argument_list|)
condition|;
name|end_p1
operator|++
control|)
empty_stmt|;
name|hash_ptr
operator|=
name|hash_string
argument_list|(
name|start
argument_list|,
name|end_p1
operator|-
name|start
argument_list|,
operator|&
name|orig_str_hash
index|[
literal|0
index|]
argument_list|,
operator|(
name|symint_t
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|hash_ptr
operator|==
operator|(
name|shash_t
operator|*
operator|)
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"label %.*s not found for #.bend"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|end_p1
operator|-
name|start
argument_list|)
argument_list|,
name|start
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|cur_oproc_begin
operator|==
operator|(
name|SYMR
operator|*
operator|)
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"procedure table %.*s not found for #.bend"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|end_p1
operator|-
name|start
argument_list|)
argument_list|,
name|start
argument_list|)
expr_stmt|;
return|return;
block|}
operator|(
name|void
operator|)
name|add_local_symbol
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
literal|0
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
literal|0
argument_list|,
name|st_End
argument_list|,
name|sc_Text
argument_list|,
operator|(
name|symint_t
operator|)
name|hash_ptr
operator|->
name|sym_ptr
operator|->
name|value
operator|-
name|cur_oproc_begin
operator|->
name|value
argument_list|,
operator|(
name|symint_t
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Parse #.def directives, which are contain standard COFF subdirectives    to describe the debugging format.  These subdirectives include:  	.scl	specify storage class 	.val	specify a value 	.endef	specify end of COFF directives 	.type	specify the type 	.size	specify the size of an array 	.dim	specify an array dimension 	.tag	specify a tag for a struct, union, or enum.  */
end_comment

begin_function
name|STATIC
name|void
name|parse_def
parameter_list|(
name|name_start
parameter_list|)
specifier|const
name|char
modifier|*
name|name_start
decl_stmt|;
comment|/* start of directive */
block|{
specifier|const
name|char
modifier|*
name|dir_start
decl_stmt|;
comment|/* start of current directive*/
specifier|const
name|char
modifier|*
name|dir_end_p1
decl_stmt|;
comment|/* end+1 of current directive*/
specifier|const
name|char
modifier|*
name|arg_start
decl_stmt|;
comment|/* start of current argument */
specifier|const
name|char
modifier|*
name|arg_end_p1
decl_stmt|;
comment|/* end+1 of current argument */
specifier|const
name|char
modifier|*
name|name_end_p1
decl_stmt|;
comment|/* end+1 of label */
specifier|const
name|char
modifier|*
name|tag_start
init|=
literal|0
decl_stmt|;
comment|/* start of tag name */
specifier|const
name|char
modifier|*
name|tag_end_p1
init|=
literal|0
decl_stmt|;
comment|/* end+1 of tag name */
name|sc_t
name|storage_class
init|=
name|sc_Nil
decl_stmt|;
name|st_t
name|symbol_type
init|=
name|st_Nil
decl_stmt|;
name|type_info_t
name|t
decl_stmt|;
name|EXTR
modifier|*
name|eptr
init|=
operator|(
name|EXTR
operator|*
operator|)
literal|0
decl_stmt|;
comment|/* ext. sym equivalent to def*/
name|int
name|is_function
init|=
literal|0
decl_stmt|;
comment|/* != 0 if function */
name|symint_t
name|value
init|=
literal|0
decl_stmt|;
name|symint_t
name|indx
init|=
name|cur_file_ptr
operator|->
name|void_type
decl_stmt|;
name|int
name|error_line
init|=
literal|0
decl_stmt|;
name|symint_t
name|arg_number
decl_stmt|;
name|symint_t
name|temp_array
index|[
name|N_TQ
index|]
decl_stmt|;
name|int
name|arg_was_number
decl_stmt|;
name|int
name|ch
decl_stmt|,
name|i
decl_stmt|;
name|Ptrdiff_t
name|len
decl_stmt|;
specifier|static
name|int
name|inside_enumeration
init|=
literal|0
decl_stmt|;
comment|/* is this an enumeration? */
comment|/* Initialize the type information.  */
name|t
operator|=
name|type_info_init
expr_stmt|;
comment|/* Search for the end of the name being defined.  */
comment|/* Allow spaces and such in names for G++ templates, which produce stabs      that look like:       #.def   SMANIP<long unsigned int>; .scl 10; .type 0x8; .size 8; .endef */
for|for
control|(
name|name_end_p1
operator|=
name|name_start
init|;
operator|(
name|ch
operator|=
operator|*
name|name_end_p1
operator|)
operator|!=
literal|';'
operator|&&
name|ch
operator|!=
literal|'\0'
condition|;
name|name_end_p1
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'\0'
condition|)
block|{
name|error_line
operator|=
name|__LINE__
expr_stmt|;
name|saber_stop
argument_list|()
expr_stmt|;
goto|goto
name|bomb_out
goto|;
block|}
comment|/* Parse the remaining subdirectives now.  */
name|dir_start
operator|=
name|name_end_p1
operator|+
literal|1
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
while|while
condition|(
operator|(
name|ch
operator|=
operator|*
name|dir_start
operator|)
operator|==
literal|' '
operator|||
name|ch
operator|==
literal|'\t'
condition|)
operator|++
name|dir_start
expr_stmt|;
if|if
condition|(
name|ch
operator|!=
literal|'.'
condition|)
block|{
name|error_line
operator|=
name|__LINE__
expr_stmt|;
name|saber_stop
argument_list|()
expr_stmt|;
goto|goto
name|bomb_out
goto|;
block|}
comment|/* Are we done? */
if|if
condition|(
name|dir_start
index|[
literal|1
index|]
operator|==
literal|'e'
operator|&&
name|memcmp
argument_list|(
name|dir_start
argument_list|,
literal|".endef"
argument_list|,
sizeof|sizeof
argument_list|(
literal|".endef"
argument_list|)
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
break|break;
comment|/* Pick up the subdirective now */
for|for
control|(
name|dir_end_p1
operator|=
name|dir_start
operator|+
literal|1
init|;
operator|(
name|ch
operator|=
operator|*
name|dir_end_p1
operator|)
operator|!=
literal|' '
operator|&&
name|ch
operator|!=
literal|'\t'
condition|;
name|dir_end_p1
operator|++
control|)
block|{
if|if
condition|(
name|ch
operator|==
literal|'\0'
operator|||
name|ISSPACE
argument_list|(
name|ch
argument_list|)
condition|)
block|{
name|error_line
operator|=
name|__LINE__
expr_stmt|;
name|saber_stop
argument_list|()
expr_stmt|;
goto|goto
name|bomb_out
goto|;
block|}
block|}
comment|/* Pick up the subdirective argument now.  */
name|arg_was_number
operator|=
name|arg_number
operator|=
literal|0
expr_stmt|;
name|arg_end_p1
operator|=
literal|0
expr_stmt|;
name|arg_start
operator|=
name|dir_end_p1
operator|+
literal|1
expr_stmt|;
name|ch
operator|=
operator|*
name|arg_start
expr_stmt|;
while|while
condition|(
name|ch
operator|==
literal|' '
operator|||
name|ch
operator|==
literal|'\t'
condition|)
name|ch
operator|=
operator|*
operator|++
name|arg_start
expr_stmt|;
if|if
condition|(
name|ISDIGIT
argument_list|(
name|ch
argument_list|)
operator|||
name|ch
operator|==
literal|'-'
operator|||
name|ch
operator|==
literal|'+'
condition|)
block|{
name|int
name|ch2
decl_stmt|;
name|arg_number
operator|=
name|strtol
argument_list|(
name|arg_start
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
operator|&
name|arg_end_p1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg_end_p1
operator|!=
name|arg_start
operator|||
operator|(
name|ch2
operator|=
operator|*
name|arg_end_p1
operator|!=
literal|';'
operator|)
operator|||
name|ch2
operator|!=
literal|','
condition|)
name|arg_was_number
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'\0'
operator|||
name|ISSPACE
argument_list|(
name|ch
argument_list|)
condition|)
block|{
name|error_line
operator|=
name|__LINE__
expr_stmt|;
name|saber_stop
argument_list|()
expr_stmt|;
goto|goto
name|bomb_out
goto|;
block|}
if|if
condition|(
operator|!
name|arg_was_number
condition|)
block|{
comment|/* Allow spaces and such in names for G++ templates.  */
for|for
control|(
name|arg_end_p1
operator|=
name|arg_start
operator|+
literal|1
init|;
operator|(
name|ch
operator|=
operator|*
name|arg_end_p1
operator|)
operator|!=
literal|';'
operator|&&
name|ch
operator|!=
literal|'\0'
condition|;
name|arg_end_p1
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'\0'
condition|)
block|{
name|error_line
operator|=
name|__LINE__
expr_stmt|;
name|saber_stop
argument_list|()
expr_stmt|;
goto|goto
name|bomb_out
goto|;
block|}
block|}
comment|/* Classify the directives now.  */
name|len
operator|=
name|dir_end_p1
operator|-
name|dir_start
expr_stmt|;
switch|switch
condition|(
name|dir_start
index|[
literal|1
index|]
condition|)
block|{
default|default:
name|error_line
operator|=
name|__LINE__
expr_stmt|;
name|saber_stop
argument_list|()
expr_stmt|;
goto|goto
name|bomb_out
goto|;
case|case
literal|'d'
case|:
if|if
condition|(
name|len
operator|==
sizeof|sizeof
argument_list|(
literal|".dim"
argument_list|)
operator|-
literal|1
operator|&&
name|memcmp
argument_list|(
name|dir_start
argument_list|,
literal|".dim"
argument_list|,
sizeof|sizeof
argument_list|(
literal|".dim"
argument_list|)
operator|-
literal|1
argument_list|)
operator|==
literal|0
operator|&&
name|arg_was_number
condition|)
block|{
name|symint_t
modifier|*
name|t_ptr
init|=
operator|&
name|temp_array
index|[
name|N_TQ
operator|-
literal|1
index|]
decl_stmt|;
operator|*
name|t_ptr
operator|=
name|arg_number
expr_stmt|;
while|while
condition|(
operator|*
name|arg_end_p1
operator|==
literal|','
operator|&&
name|arg_was_number
condition|)
block|{
name|arg_start
operator|=
name|arg_end_p1
operator|+
literal|1
expr_stmt|;
name|ch
operator|=
operator|*
name|arg_start
expr_stmt|;
while|while
condition|(
name|ch
operator|==
literal|' '
operator|||
name|ch
operator|==
literal|'\t'
condition|)
name|ch
operator|=
operator|*
operator|++
name|arg_start
expr_stmt|;
name|arg_was_number
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ISDIGIT
argument_list|(
name|ch
argument_list|)
operator|||
name|ch
operator|==
literal|'-'
operator|||
name|ch
operator|==
literal|'+'
condition|)
block|{
name|int
name|ch2
decl_stmt|;
name|arg_number
operator|=
name|strtol
argument_list|(
name|arg_start
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
operator|&
name|arg_end_p1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg_end_p1
operator|!=
name|arg_start
operator|||
operator|(
name|ch2
operator|=
operator|*
name|arg_end_p1
operator|!=
literal|';'
operator|)
operator|||
name|ch2
operator|!=
literal|','
condition|)
name|arg_was_number
operator|++
expr_stmt|;
if|if
condition|(
name|t_ptr
operator|==
operator|&
name|temp_array
index|[
literal|0
index|]
condition|)
block|{
name|error_line
operator|=
name|__LINE__
expr_stmt|;
name|saber_stop
argument_list|()
expr_stmt|;
goto|goto
name|bomb_out
goto|;
block|}
operator|*
operator|--
name|t_ptr
operator|=
name|arg_number
expr_stmt|;
block|}
block|}
comment|/* Reverse order of dimensions.  */
while|while
condition|(
name|t_ptr
operator|<=
operator|&
name|temp_array
index|[
name|N_TQ
operator|-
literal|1
index|]
condition|)
block|{
if|if
condition|(
name|t
operator|.
name|num_dims
operator|>=
name|N_TQ
operator|-
literal|1
condition|)
block|{
name|error_line
operator|=
name|__LINE__
expr_stmt|;
name|saber_stop
argument_list|()
expr_stmt|;
goto|goto
name|bomb_out
goto|;
block|}
name|t
operator|.
name|dimensions
index|[
name|t
operator|.
name|num_dims
operator|++
index|]
operator|=
operator|*
name|t_ptr
operator|++
expr_stmt|;
block|}
break|break;
block|}
else|else
block|{
name|error_line
operator|=
name|__LINE__
expr_stmt|;
name|saber_stop
argument_list|()
expr_stmt|;
goto|goto
name|bomb_out
goto|;
block|}
case|case
literal|'s'
case|:
if|if
condition|(
name|len
operator|==
sizeof|sizeof
argument_list|(
literal|".scl"
argument_list|)
operator|-
literal|1
operator|&&
name|memcmp
argument_list|(
name|dir_start
argument_list|,
literal|".scl"
argument_list|,
sizeof|sizeof
argument_list|(
literal|".scl"
argument_list|)
operator|-
literal|1
argument_list|)
operator|==
literal|0
operator|&&
name|arg_was_number
operator|&&
name|arg_number
operator|<
operator|(
operator|(
name|symint_t
operator|)
name|C_MAX
operator|)
condition|)
block|{
comment|/* If the symbol is a static or external, we have 		 already gotten the appropriate type and class, so 		 make sure we don't override those values.  This is 		 needed because there are some type and classes that 		 are not in COFF, such as short data, etc.  */
if|if
condition|(
name|symbol_type
operator|==
name|st_Nil
condition|)
block|{
name|symbol_type
operator|=
name|map_coff_sym_type
index|[
name|arg_number
index|]
expr_stmt|;
name|storage_class
operator|=
name|map_coff_storage
index|[
name|arg_number
index|]
expr_stmt|;
block|}
break|break;
block|}
elseif|else
if|if
condition|(
name|len
operator|==
sizeof|sizeof
argument_list|(
literal|".size"
argument_list|)
operator|-
literal|1
operator|&&
name|memcmp
argument_list|(
name|dir_start
argument_list|,
literal|".size"
argument_list|,
sizeof|sizeof
argument_list|(
literal|".size"
argument_list|)
operator|-
literal|1
argument_list|)
operator|==
literal|0
operator|&&
name|arg_was_number
condition|)
block|{
name|symint_t
modifier|*
name|t_ptr
init|=
operator|&
name|temp_array
index|[
name|N_TQ
operator|-
literal|1
index|]
decl_stmt|;
operator|*
name|t_ptr
operator|=
name|arg_number
expr_stmt|;
while|while
condition|(
operator|*
name|arg_end_p1
operator|==
literal|','
operator|&&
name|arg_was_number
condition|)
block|{
name|arg_start
operator|=
name|arg_end_p1
operator|+
literal|1
expr_stmt|;
name|ch
operator|=
operator|*
name|arg_start
expr_stmt|;
while|while
condition|(
name|ch
operator|==
literal|' '
operator|||
name|ch
operator|==
literal|'\t'
condition|)
name|ch
operator|=
operator|*
operator|++
name|arg_start
expr_stmt|;
name|arg_was_number
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ISDIGIT
argument_list|(
name|ch
argument_list|)
operator|||
name|ch
operator|==
literal|'-'
operator|||
name|ch
operator|==
literal|'+'
condition|)
block|{
name|int
name|ch2
decl_stmt|;
name|arg_number
operator|=
name|strtol
argument_list|(
name|arg_start
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
operator|&
name|arg_end_p1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg_end_p1
operator|!=
name|arg_start
operator|||
operator|(
name|ch2
operator|=
operator|*
name|arg_end_p1
operator|!=
literal|';'
operator|)
operator|||
name|ch2
operator|!=
literal|','
condition|)
name|arg_was_number
operator|++
expr_stmt|;
if|if
condition|(
name|t_ptr
operator|==
operator|&
name|temp_array
index|[
literal|0
index|]
condition|)
block|{
name|error_line
operator|=
name|__LINE__
expr_stmt|;
name|saber_stop
argument_list|()
expr_stmt|;
goto|goto
name|bomb_out
goto|;
block|}
operator|*
operator|--
name|t_ptr
operator|=
name|arg_number
expr_stmt|;
block|}
block|}
comment|/* Reverse order of sizes.  */
while|while
condition|(
name|t_ptr
operator|<=
operator|&
name|temp_array
index|[
name|N_TQ
operator|-
literal|1
index|]
condition|)
block|{
if|if
condition|(
name|t
operator|.
name|num_sizes
operator|>=
name|N_TQ
operator|-
literal|1
condition|)
block|{
name|error_line
operator|=
name|__LINE__
expr_stmt|;
name|saber_stop
argument_list|()
expr_stmt|;
goto|goto
name|bomb_out
goto|;
block|}
name|t
operator|.
name|sizes
index|[
name|t
operator|.
name|num_sizes
operator|++
index|]
operator|=
operator|*
name|t_ptr
operator|++
expr_stmt|;
block|}
break|break;
block|}
else|else
block|{
name|error_line
operator|=
name|__LINE__
expr_stmt|;
name|saber_stop
argument_list|()
expr_stmt|;
goto|goto
name|bomb_out
goto|;
block|}
case|case
literal|'t'
case|:
if|if
condition|(
name|len
operator|==
sizeof|sizeof
argument_list|(
literal|".type"
argument_list|)
operator|-
literal|1
operator|&&
name|memcmp
argument_list|(
name|dir_start
argument_list|,
literal|".type"
argument_list|,
sizeof|sizeof
argument_list|(
literal|".type"
argument_list|)
operator|-
literal|1
argument_list|)
operator|==
literal|0
operator|&&
name|arg_was_number
condition|)
block|{
name|tq_t
modifier|*
name|tq_ptr
init|=
operator|&
name|t
operator|.
name|type_qualifiers
index|[
literal|0
index|]
decl_stmt|;
name|t
operator|.
name|orig_type
operator|=
call|(
name|coff_type_t
call|)
argument_list|(
name|arg_number
operator|&
name|N_BTMASK
argument_list|)
expr_stmt|;
name|t
operator|.
name|basic_type
operator|=
name|map_coff_types
index|[
operator|(
name|int
operator|)
name|t
operator|.
name|orig_type
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
name|N_TQ
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|int
name|dt
init|=
operator|(
name|arg_number
operator|>>
operator|(
operator|(
name|i
operator|*
name|N_TQ_SHIFT
operator|)
operator|+
name|N_BT_SHIFT
operator|)
operator|&
name|N_TMASK
operator|)
decl_stmt|;
if|if
condition|(
name|dt
operator|!=
operator|(
name|int
operator|)
name|DT_NON
condition|)
operator|*
name|tq_ptr
operator|++
operator|=
name|map_coff_derived_type
index|[
name|dt
index|]
expr_stmt|;
block|}
comment|/* If this is a function, ignore it, so that we don't get 		 two entries (one from the .ent, and one for the .def 		 that precedes it).  Save the type information so that 		 the end block can properly add it after the begin block 		 index.  For MIPS knows what reason, we must strip off 		 the function type at this point.  */
if|if
condition|(
name|tq_ptr
operator|!=
operator|&
name|t
operator|.
name|type_qualifiers
index|[
literal|0
index|]
operator|&&
name|tq_ptr
index|[
operator|-
literal|1
index|]
operator|==
name|tq_Proc
condition|)
block|{
name|is_function
operator|=
literal|1
expr_stmt|;
name|tq_ptr
index|[
operator|-
literal|1
index|]
operator|=
name|tq_Nil
expr_stmt|;
block|}
break|break;
block|}
elseif|else
if|if
condition|(
name|len
operator|==
sizeof|sizeof
argument_list|(
literal|".tag"
argument_list|)
operator|-
literal|1
operator|&&
name|memcmp
argument_list|(
name|dir_start
argument_list|,
literal|".tag"
argument_list|,
sizeof|sizeof
argument_list|(
literal|".tag"
argument_list|)
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tag_start
operator|=
name|arg_start
expr_stmt|;
name|tag_end_p1
operator|=
name|arg_end_p1
expr_stmt|;
break|break;
block|}
else|else
block|{
name|error_line
operator|=
name|__LINE__
expr_stmt|;
name|saber_stop
argument_list|()
expr_stmt|;
goto|goto
name|bomb_out
goto|;
block|}
case|case
literal|'v'
case|:
if|if
condition|(
name|len
operator|==
sizeof|sizeof
argument_list|(
literal|".val"
argument_list|)
operator|-
literal|1
operator|&&
name|memcmp
argument_list|(
name|dir_start
argument_list|,
literal|".val"
argument_list|,
sizeof|sizeof
argument_list|(
literal|".val"
argument_list|)
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|arg_was_number
condition|)
name|value
operator|=
name|arg_number
expr_stmt|;
comment|/* If the value is not an integer value, it must be the 		 name of a static or global item.  Look up the name in 		 the original symbol table to pick up the storage 		 class, symbol type, etc.  */
else|else
block|{
name|shash_t
modifier|*
name|orig_hash_ptr
decl_stmt|;
comment|/* hash within orig sym table*/
name|shash_t
modifier|*
name|ext_hash_ptr
decl_stmt|;
comment|/* hash within ext. sym table*/
name|ext_hash_ptr
operator|=
name|hash_string
argument_list|(
name|arg_start
argument_list|,
name|arg_end_p1
operator|-
name|arg_start
argument_list|,
operator|&
name|ext_str_hash
index|[
literal|0
index|]
argument_list|,
operator|(
name|symint_t
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ext_hash_ptr
operator|!=
operator|(
name|shash_t
operator|*
operator|)
literal|0
operator|&&
name|ext_hash_ptr
operator|->
name|esym_ptr
operator|!=
operator|(
name|EXTR
operator|*
operator|)
literal|0
condition|)
name|eptr
operator|=
name|ext_hash_ptr
operator|->
name|esym_ptr
expr_stmt|;
name|orig_hash_ptr
operator|=
name|hash_string
argument_list|(
name|arg_start
argument_list|,
name|arg_end_p1
operator|-
name|arg_start
argument_list|,
operator|&
name|orig_str_hash
index|[
literal|0
index|]
argument_list|,
operator|(
name|symint_t
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|orig_hash_ptr
operator|==
operator|(
name|shash_t
operator|*
operator|)
literal|0
operator|||
name|orig_hash_ptr
operator|->
name|sym_ptr
operator|==
operator|(
name|SYMR
operator|*
operator|)
literal|0
operator|)
operator|&&
name|eptr
operator|==
operator|(
name|EXTR
operator|*
operator|)
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"warning, %.*s not found in original or external symbol tables, value defaults to 0\n"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|arg_end_p1
operator|-
name|arg_start
argument_list|)
argument_list|,
name|arg_start
argument_list|)
expr_stmt|;
name|value
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|SYMR
modifier|*
name|ptr
init|=
operator|(
name|orig_hash_ptr
operator|!=
operator|(
name|shash_t
operator|*
operator|)
literal|0
operator|&&
name|orig_hash_ptr
operator|->
name|sym_ptr
operator|!=
operator|(
name|SYMR
operator|*
operator|)
literal|0
operator|)
condition|?
name|orig_hash_ptr
operator|->
name|sym_ptr
else|:
operator|&
name|eptr
operator|->
name|asym
decl_stmt|;
name|symbol_type
operator|=
operator|(
name|st_t
operator|)
name|ptr
operator|->
name|st
expr_stmt|;
name|storage_class
operator|=
operator|(
name|sc_t
operator|)
name|ptr
operator|->
name|sc
expr_stmt|;
name|value
operator|=
name|ptr
operator|->
name|value
expr_stmt|;
block|}
block|}
break|break;
block|}
else|else
block|{
name|error_line
operator|=
name|__LINE__
expr_stmt|;
name|saber_stop
argument_list|()
expr_stmt|;
goto|goto
name|bomb_out
goto|;
block|}
block|}
comment|/* Set up to find next directive.  */
name|dir_start
operator|=
name|arg_end_p1
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|storage_class
operator|==
name|sc_Bits
condition|)
block|{
name|t
operator|.
name|bitfield
operator|=
literal|1
expr_stmt|;
name|t
operator|.
name|extra_sizes
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|t
operator|.
name|extra_sizes
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|t
operator|.
name|num_dims
operator|>
literal|0
condition|)
block|{
name|int
name|num_real_sizes
init|=
name|t
operator|.
name|num_sizes
operator|-
name|t
operator|.
name|extra_sizes
decl_stmt|;
name|int
name|diff
init|=
name|t
operator|.
name|num_dims
operator|-
name|num_real_sizes
decl_stmt|;
name|int
name|i
init|=
name|t
operator|.
name|num_dims
operator|-
literal|1
decl_stmt|;
name|int
name|j
decl_stmt|;
if|if
condition|(
name|num_real_sizes
operator|!=
literal|1
operator|||
name|diff
operator|<
literal|0
condition|)
block|{
name|error_line
operator|=
name|__LINE__
expr_stmt|;
name|saber_stop
argument_list|()
expr_stmt|;
goto|goto
name|bomb_out
goto|;
block|}
comment|/* If this is an array, make sure the same number of dimensions 	 and sizes were passed, creating extra sizes for multiply 	 dimensioned arrays if not passed.  */
if|if
condition|(
name|diff
condition|)
block|{
for|for
control|(
name|j
operator|=
name|ARRAY_SIZE
argument_list|(
name|t
operator|.
name|sizes
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
name|t
operator|.
name|sizes
index|[
name|j
index|]
operator|=
operator|(
operator|(
name|j
operator|-
name|diff
operator|)
operator|>=
literal|0
operator|)
condition|?
name|t
operator|.
name|sizes
index|[
name|j
operator|-
name|diff
index|]
else|:
literal|0
expr_stmt|;
name|t
operator|.
name|num_sizes
operator|=
name|i
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|--
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|t
operator|.
name|dimensions
index|[
name|i
operator|+
literal|1
index|]
condition|)
name|t
operator|.
name|sizes
index|[
name|i
index|]
operator|=
name|t
operator|.
name|sizes
index|[
name|i
operator|+
literal|1
index|]
operator|/
name|t
operator|.
name|dimensions
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
else|else
name|t
operator|.
name|sizes
index|[
name|i
index|]
operator|=
name|t
operator|.
name|sizes
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
block|}
block|}
block|}
comment|/* Except for enumeration members& begin/ending of scopes, put the      type word in the aux. symbol table.  */
if|if
condition|(
name|symbol_type
operator|==
name|st_Block
operator|||
name|symbol_type
operator|==
name|st_End
condition|)
name|indx
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|inside_enumeration
condition|)
name|indx
operator|=
name|cur_file_ptr
operator|->
name|void_type
expr_stmt|;
else|else
block|{
if|if
condition|(
name|t
operator|.
name|basic_type
operator|==
name|bt_Struct
operator|||
name|t
operator|.
name|basic_type
operator|==
name|bt_Union
operator|||
name|t
operator|.
name|basic_type
operator|==
name|bt_Enum
condition|)
block|{
if|if
condition|(
name|tag_start
operator|==
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"no tag specified for %.*s"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|name_end_p1
operator|-
name|name_start
argument_list|)
argument_list|,
name|name_start
argument_list|)
expr_stmt|;
return|return;
block|}
name|t
operator|.
name|tag_ptr
operator|=
name|get_tag
argument_list|(
name|tag_start
argument_list|,
name|tag_end_p1
argument_list|,
operator|(
name|symint_t
operator|)
name|indexNil
argument_list|,
name|t
operator|.
name|basic_type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|is_function
condition|)
block|{
name|last_func_type_info
operator|=
name|t
expr_stmt|;
name|last_func_eptr
operator|=
name|eptr
expr_stmt|;
return|return;
block|}
name|indx
operator|=
name|add_aux_sym_tir
argument_list|(
operator|&
name|t
argument_list|,
name|hash_yes
argument_list|,
operator|&
name|cur_file_ptr
operator|->
name|thash_head
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* If this is an external or static symbol, update the appropriate      external symbol.  */
if|if
condition|(
name|eptr
operator|!=
operator|(
name|EXTR
operator|*
operator|)
literal|0
operator|&&
operator|(
name|eptr
operator|->
name|asym
operator|.
name|index
operator|==
name|indexNil
operator|||
name|cur_proc_ptr
operator|==
operator|(
name|PDR
operator|*
operator|)
literal|0
operator|)
condition|)
block|{
name|eptr
operator|->
name|ifd
operator|=
name|cur_file_ptr
operator|->
name|file_index
expr_stmt|;
name|eptr
operator|->
name|asym
operator|.
name|index
operator|=
name|indx
expr_stmt|;
block|}
comment|/* Do any last minute adjustments that are necessary.  */
switch|switch
condition|(
name|symbol_type
condition|)
block|{
default|default:
break|break;
comment|/* For the beginning of structs, unions, and enumerations, the 	 size info needs to be passed in the value field.  */
case|case
name|st_Block
case|:
if|if
condition|(
name|t
operator|.
name|num_sizes
operator|-
name|t
operator|.
name|num_dims
operator|-
name|t
operator|.
name|extra_sizes
operator|!=
literal|1
condition|)
block|{
name|error_line
operator|=
name|__LINE__
expr_stmt|;
name|saber_stop
argument_list|()
expr_stmt|;
goto|goto
name|bomb_out
goto|;
block|}
else|else
name|value
operator|=
name|t
operator|.
name|sizes
index|[
literal|0
index|]
expr_stmt|;
name|inside_enumeration
operator|=
operator|(
name|t
operator|.
name|orig_type
operator|==
name|T_ENUM
operator|)
expr_stmt|;
break|break;
comment|/* For the end of structs, unions, and enumerations, omit the 	 name which is always ".eos".  This needs to be done last, so 	 that any error reporting above gives the correct name.  */
case|case
name|st_End
case|:
name|name_start
operator|=
name|name_end_p1
operator|=
literal|0
expr_stmt|;
name|value
operator|=
name|inside_enumeration
operator|=
literal|0
expr_stmt|;
break|break;
comment|/* Members of structures and unions that aren't bitfields, need 	 to adjust the value from a byte offset to a bit offset. 	 Members of enumerations do not have the value adjusted, and 	 can be distinguished by indx == indexNil.  For enumerations, 	 update the maximum enumeration value.  */
case|case
name|st_Member
case|:
if|if
condition|(
operator|!
name|t
operator|.
name|bitfield
operator|&&
operator|!
name|inside_enumeration
condition|)
name|value
operator|*=
literal|8
expr_stmt|;
break|break;
block|}
comment|/* Add the symbol, except for global symbols outside of functions,      for which the external symbol table is fine enough.  */
if|if
condition|(
name|eptr
operator|==
operator|(
name|EXTR
operator|*
operator|)
literal|0
operator|||
name|eptr
operator|->
name|asym
operator|.
name|st
operator|==
operator|(
name|int
operator|)
name|st_Nil
operator|||
name|cur_proc_ptr
operator|!=
operator|(
name|PDR
operator|*
operator|)
literal|0
condition|)
block|{
name|symint_t
name|isym
init|=
name|add_local_symbol
argument_list|(
name|name_start
argument_list|,
name|name_end_p1
argument_list|,
name|symbol_type
argument_list|,
name|storage_class
argument_list|,
name|value
argument_list|,
name|indx
argument_list|)
decl_stmt|;
comment|/* deal with struct, union, and enum tags.  */
if|if
condition|(
name|symbol_type
operator|==
name|st_Block
condition|)
block|{
comment|/* Create or update the tag information.  */
name|tag_t
modifier|*
name|tag_ptr
init|=
name|get_tag
argument_list|(
name|name_start
argument_list|,
name|name_end_p1
argument_list|,
name|isym
argument_list|,
name|t
operator|.
name|basic_type
argument_list|)
decl_stmt|;
comment|/* If there are any forward references, fill in the appropriate 	     file and symbol indexes.  */
name|symint_t
name|file_index
init|=
name|cur_file_ptr
operator|->
name|file_index
decl_stmt|;
name|forward_t
modifier|*
name|f_next
init|=
name|tag_ptr
operator|->
name|forward_ref
decl_stmt|;
name|forward_t
modifier|*
name|f_cur
decl_stmt|;
while|while
condition|(
name|f_next
operator|!=
operator|(
name|forward_t
operator|*
operator|)
literal|0
condition|)
block|{
name|f_cur
operator|=
name|f_next
expr_stmt|;
name|f_next
operator|=
name|f_next
operator|->
name|next
expr_stmt|;
name|f_cur
operator|->
name|ifd_ptr
operator|->
name|isym
operator|=
name|file_index
expr_stmt|;
name|f_cur
operator|->
name|index_ptr
operator|->
name|rndx
operator|.
name|index
operator|=
name|isym
expr_stmt|;
name|free_forward
argument_list|(
name|f_cur
argument_list|)
expr_stmt|;
block|}
name|tag_ptr
operator|->
name|forward_ref
operator|=
operator|(
name|forward_t
operator|*
operator|)
literal|0
expr_stmt|;
block|}
block|}
comment|/* Normal return  */
return|return;
comment|/* Error return, issue message.  */
name|bomb_out
label|:
if|if
condition|(
name|error_line
condition|)
name|error
argument_list|(
literal|"compiler error, badly formed #.def (internal line # = %d)"
argument_list|,
name|error_line
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"compiler error, badly formed #.def"
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Parse .end directives.  */
end_comment

begin_function
name|STATIC
name|void
name|parse_end
parameter_list|(
name|start
parameter_list|)
specifier|const
name|char
modifier|*
name|start
decl_stmt|;
comment|/* start of directive */
block|{
specifier|const
name|char
modifier|*
name|start_func
decl_stmt|,
modifier|*
name|end_func_p1
decl_stmt|;
name|int
name|ch
decl_stmt|;
name|symint_t
name|value
decl_stmt|;
name|FDR
modifier|*
name|orig_fdr
decl_stmt|;
if|if
condition|(
name|cur_file_ptr
operator|==
operator|(
name|efdr_t
operator|*
operator|)
literal|0
condition|)
block|{
name|error
argument_list|(
literal|".end directive without a preceding .file directive"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|cur_proc_ptr
operator|==
operator|(
name|PDR
operator|*
operator|)
literal|0
condition|)
block|{
name|error
argument_list|(
literal|".end directive without a preceding .ent directive"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Get the function name, skipping whitespace.  */
for|for
control|(
name|start_func
operator|=
name|start
init|;
name|ISSPACE
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|start_func
argument_list|)
condition|;
name|start_func
operator|++
control|)
empty_stmt|;
name|ch
operator|=
operator|*
name|start_func
expr_stmt|;
if|if
condition|(
operator|!
name|IS_ASM_IDENT
argument_list|(
name|ch
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|".end directive has no name"
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|end_func_p1
operator|=
name|start_func
init|;
name|IS_ASM_IDENT
argument_list|(
name|ch
argument_list|)
condition|;
name|ch
operator|=
operator|*
operator|++
name|end_func_p1
control|)
empty_stmt|;
comment|/* Get the value field for creating the end from the original object      file (which we find by locating the procedure start, and using the      pointer to the end+1 block and backing up.  The index points to a      two word aux. symbol, whose first word is the index of the end      symbol, and the second word is the type of the function return      value.  */
name|orig_fdr
operator|=
name|cur_file_ptr
operator|->
name|orig_fdr
expr_stmt|;
name|value
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|orig_fdr
operator|!=
operator|(
name|FDR
operator|*
operator|)
literal|0
operator|&&
name|cur_oproc_end
operator|!=
operator|(
name|SYMR
operator|*
operator|)
literal|0
condition|)
name|value
operator|=
name|cur_oproc_end
operator|->
name|value
expr_stmt|;
else|else
name|error
argument_list|(
literal|"cannot find .end block for %.*s"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|end_func_p1
operator|-
name|start_func
argument_list|)
argument_list|,
name|start_func
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|add_local_symbol
argument_list|(
name|start_func
argument_list|,
name|end_func_p1
argument_list|,
name|st_End
argument_list|,
name|sc_Text
argument_list|,
name|value
argument_list|,
operator|(
name|symint_t
operator|)
literal|0
argument_list|)
expr_stmt|;
name|cur_proc_ptr
operator|=
name|cur_oproc_ptr
operator|=
operator|(
name|PDR
operator|*
operator|)
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Parse .ent directives.  */
end_comment

begin_function
name|STATIC
name|void
name|parse_ent
parameter_list|(
name|start
parameter_list|)
specifier|const
name|char
modifier|*
name|start
decl_stmt|;
comment|/* start of directive */
block|{
specifier|const
name|char
modifier|*
name|start_func
decl_stmt|,
modifier|*
name|end_func_p1
decl_stmt|;
name|int
name|ch
decl_stmt|;
if|if
condition|(
name|cur_file_ptr
operator|==
operator|(
name|efdr_t
operator|*
operator|)
literal|0
condition|)
block|{
name|error
argument_list|(
literal|".ent directive without a preceding .file directive"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|cur_proc_ptr
operator|!=
operator|(
name|PDR
operator|*
operator|)
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"second .ent directive found before .end directive"
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|start_func
operator|=
name|start
init|;
name|ISSPACE
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|start_func
argument_list|)
condition|;
name|start_func
operator|++
control|)
empty_stmt|;
name|ch
operator|=
operator|*
name|start_func
expr_stmt|;
if|if
condition|(
operator|!
name|IS_ASM_IDENT
argument_list|(
name|ch
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|".ent directive has no name"
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|end_func_p1
operator|=
name|start_func
init|;
name|IS_ASM_IDENT
argument_list|(
name|ch
argument_list|)
condition|;
name|ch
operator|=
operator|*
operator|++
name|end_func_p1
control|)
empty_stmt|;
operator|(
name|void
operator|)
name|add_procedure
argument_list|(
name|start_func
argument_list|,
name|end_func_p1
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Parse .file directives.  */
end_comment

begin_function
name|STATIC
name|void
name|parse_file
parameter_list|(
name|start
parameter_list|)
specifier|const
name|char
modifier|*
name|start
decl_stmt|;
comment|/* start of directive */
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|start_name
decl_stmt|,
modifier|*
name|end_name_p1
decl_stmt|;
operator|(
name|void
operator|)
name|strtol
argument_list|(
name|start
argument_list|,
operator|&
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|start
operator|==
name|p
operator|||
operator|(
name|start_name
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|'"'
argument_list|)
operator|)
operator|==
operator|(
name|char
operator|*
operator|)
literal|0
operator|||
operator|(
name|end_name_p1
operator|=
name|strrchr
argument_list|(
operator|++
name|start_name
argument_list|,
literal|'"'
argument_list|)
operator|)
operator|==
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"invalid .file directive"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|cur_proc_ptr
operator|!=
operator|(
name|PDR
operator|*
operator|)
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"no way to handle .file within .ent/.end section"
argument_list|)
expr_stmt|;
return|return;
block|}
name|add_file
argument_list|(
name|start_name
argument_list|,
name|end_name_p1
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Make sure the @stabs symbol is emitted.  */
end_comment

begin_function
specifier|static
name|void
name|mark_stabs
parameter_list|(
name|start
parameter_list|)
specifier|const
name|char
modifier|*
name|start
name|ATTRIBUTE_UNUSED
decl_stmt|;
comment|/* Start of directive (ignored) */
block|{
if|if
condition|(
operator|!
name|stabs_seen
condition|)
block|{
comment|/* Add a dummy @stabs symbol.  */
name|stabs_seen
operator|=
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|add_local_symbol
argument_list|(
name|stabs_symbol
argument_list|,
name|stabs_symbol
operator|+
sizeof|sizeof
argument_list|(
name|stabs_symbol
argument_list|)
argument_list|,
name|stNil
argument_list|,
name|scInfo
argument_list|,
operator|-
literal|1
argument_list|,
name|MIPS_MARK_STAB
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Parse .stabs directives.     .stabs directives have five fields: 	"string"	a string, encoding the type information. 	code		a numeric code, defined in<stab.h> 	0		a zero 	0		a zero or line number 	value		a numeric value or an address.      If the value is relocatable, we transform this into: 	iss		points as an index into string space 	value		value from lookup of the name 	st		st from lookup of the name 	sc		sc from lookup of the name 	index		code|CODE_MASK      If the value is not relocatable, we transform this into: 	iss		points as an index into string space 	value		value 	st		st_Nil 	sc		sc_Nil 	index		code|CODE_MASK      .stabn directives have four fields (string is null): 	code		a numeric code, defined in<stab.h> 	0		a zero 	0		a zero or a line number 	value		a numeric value or an address.  */
end_comment

begin_function
name|STATIC
name|void
name|parse_stabs_common
parameter_list|(
name|string_start
parameter_list|,
name|string_end
parameter_list|,
name|rest
parameter_list|)
specifier|const
name|char
modifier|*
name|string_start
decl_stmt|;
comment|/* start of string or NULL */
specifier|const
name|char
modifier|*
name|string_end
decl_stmt|;
comment|/* end+1 of string or NULL */
specifier|const
name|char
modifier|*
name|rest
decl_stmt|;
comment|/* rest of the directive.  */
block|{
name|efdr_t
modifier|*
name|save_file_ptr
init|=
name|cur_file_ptr
decl_stmt|;
name|symint_t
name|code
decl_stmt|;
name|symint_t
name|value
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|st_t
name|st
decl_stmt|;
name|sc_t
name|sc
decl_stmt|;
name|int
name|ch
decl_stmt|;
if|if
condition|(
name|stabs_seen
operator|==
literal|0
condition|)
name|mark_stabs
argument_list|(
literal|""
argument_list|)
expr_stmt|;
comment|/* Read code from stabs.  */
if|if
condition|(
operator|!
name|ISDIGIT
argument_list|(
operator|*
name|rest
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"invalid .stabs/.stabn directive, code is non-numeric"
argument_list|)
expr_stmt|;
return|return;
block|}
name|code
operator|=
name|strtol
argument_list|(
name|rest
argument_list|,
operator|&
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Line number stabs are handled differently, since they have two values,      the line number and the address of the label.  We use the index field      (aka code) to hold the line number, and the value field to hold the      address.  The symbol type is st_Label, which should be different from      the other stabs, so that gdb can recognize it.  */
if|if
condition|(
name|code
operator|==
operator|(
name|int
operator|)
name|N_SLINE
condition|)
block|{
name|SYMR
modifier|*
name|sym_ptr
decl_stmt|,
name|dummy_symr
decl_stmt|;
name|shash_t
modifier|*
name|shash_ptr
decl_stmt|;
comment|/* Skip ,0, */
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|!=
literal|','
operator|||
name|p
index|[
literal|1
index|]
operator|!=
literal|'0'
operator|||
name|p
index|[
literal|2
index|]
operator|!=
literal|','
operator|||
operator|!
name|ISDIGIT
argument_list|(
name|p
index|[
literal|3
index|]
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"invalid line number .stabs/.stabn directive"
argument_list|)
expr_stmt|;
return|return;
block|}
name|code
operator|=
name|strtol
argument_list|(
name|p
operator|+
literal|3
argument_list|,
operator|&
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ch
operator|=
operator|*
operator|++
name|p
expr_stmt|;
if|if
condition|(
name|p
index|[
operator|-
literal|1
index|]
operator|!=
literal|','
operator|||
name|ISDIGIT
argument_list|(
name|ch
argument_list|)
operator|||
operator|!
name|IS_ASM_IDENT
argument_list|(
name|ch
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"invalid line number .stabs/.stabn directive"
argument_list|)
expr_stmt|;
return|return;
block|}
name|dummy_symr
operator|.
name|index
operator|=
name|code
expr_stmt|;
if|if
condition|(
name|dummy_symr
operator|.
name|index
operator|!=
name|code
condition|)
block|{
name|error
argument_list|(
literal|"line number (%lu) for .stabs/.stabn directive cannot fit in index field (20 bits)"
argument_list|,
name|code
argument_list|)
expr_stmt|;
return|return;
block|}
name|shash_ptr
operator|=
name|hash_string
argument_list|(
name|p
argument_list|,
name|strlen
argument_list|(
name|p
argument_list|)
operator|-
literal|1
argument_list|,
operator|&
name|orig_str_hash
index|[
literal|0
index|]
argument_list|,
operator|(
name|symint_t
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|shash_ptr
operator|==
operator|(
name|shash_t
operator|*
operator|)
literal|0
operator|||
operator|(
name|sym_ptr
operator|=
name|shash_ptr
operator|->
name|sym_ptr
operator|)
operator|==
operator|(
name|SYMR
operator|*
operator|)
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"invalid .stabs/.stabn directive, value not found"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|st_t
operator|)
name|sym_ptr
operator|->
name|st
operator|!=
name|st_Label
condition|)
block|{
name|error
argument_list|(
literal|"invalid line number .stabs/.stabn directive"
argument_list|)
expr_stmt|;
return|return;
block|}
name|st
operator|=
name|st_Label
expr_stmt|;
name|sc
operator|=
operator|(
name|sc_t
operator|)
name|sym_ptr
operator|->
name|sc
expr_stmt|;
name|value
operator|=
name|sym_ptr
operator|->
name|value
expr_stmt|;
block|}
else|else
block|{
comment|/* Skip ,<num>,<num>, */
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
literal|','
condition|)
goto|goto
name|failure
goto|;
for|for
control|(
init|;
name|ISDIGIT
argument_list|(
operator|*
name|p
argument_list|)
condition|;
name|p
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
literal|','
condition|)
goto|goto
name|failure
goto|;
for|for
control|(
init|;
name|ISDIGIT
argument_list|(
operator|*
name|p
argument_list|)
condition|;
name|p
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
literal|','
condition|)
goto|goto
name|failure
goto|;
name|ch
operator|=
operator|*
name|p
expr_stmt|;
if|if
condition|(
operator|!
name|IS_ASM_IDENT
argument_list|(
name|ch
argument_list|)
operator|&&
name|ch
operator|!=
literal|'-'
condition|)
block|{
name|failure
label|:
name|error
argument_list|(
literal|"invalid .stabs/.stabn directive, bad character"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ISDIGIT
argument_list|(
name|ch
argument_list|)
operator|||
name|ch
operator|==
literal|'-'
condition|)
block|{
name|st
operator|=
name|st_Nil
expr_stmt|;
name|sc
operator|=
name|sc_Nil
expr_stmt|;
name|value
operator|=
name|strtol
argument_list|(
name|p
argument_list|,
operator|&
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|'\n'
condition|)
block|{
name|error
argument_list|(
literal|"invalid .stabs/.stabn directive, stuff after numeric value"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|IS_ASM_IDENT
argument_list|(
name|ch
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"invalid .stabs/.stabn directive, bad character"
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|SYMR
modifier|*
name|sym_ptr
decl_stmt|;
name|shash_t
modifier|*
name|shash_ptr
decl_stmt|;
specifier|const
name|char
modifier|*
name|start
decl_stmt|,
modifier|*
name|end_p1
decl_stmt|;
name|start
operator|=
name|p
expr_stmt|;
if|if
condition|(
operator|(
name|end_p1
operator|=
name|strchr
argument_list|(
name|start
argument_list|,
literal|'+'
argument_list|)
operator|)
operator|==
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|end_p1
operator|=
name|strchr
argument_list|(
name|start
argument_list|,
literal|'-'
argument_list|)
operator|)
operator|==
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
name|end_p1
operator|=
name|start
operator|+
name|strlen
argument_list|(
name|start
argument_list|)
operator|-
literal|1
expr_stmt|;
block|}
name|shash_ptr
operator|=
name|hash_string
argument_list|(
name|start
argument_list|,
name|end_p1
operator|-
name|start
argument_list|,
operator|&
name|orig_str_hash
index|[
literal|0
index|]
argument_list|,
operator|(
name|symint_t
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|shash_ptr
operator|==
operator|(
name|shash_t
operator|*
operator|)
literal|0
operator|||
operator|(
name|sym_ptr
operator|=
name|shash_ptr
operator|->
name|sym_ptr
operator|)
operator|==
operator|(
name|SYMR
operator|*
operator|)
literal|0
condition|)
block|{
name|shash_ptr
operator|=
name|hash_string
argument_list|(
name|start
argument_list|,
name|end_p1
operator|-
name|start
argument_list|,
operator|&
name|ext_str_hash
index|[
literal|0
index|]
argument_list|,
operator|(
name|symint_t
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|shash_ptr
operator|==
operator|(
name|shash_t
operator|*
operator|)
literal|0
operator|||
name|shash_ptr
operator|->
name|esym_ptr
operator|==
operator|(
name|EXTR
operator|*
operator|)
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"invalid .stabs/.stabn directive, value not found"
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
name|sym_ptr
operator|=
operator|&
operator|(
name|shash_ptr
operator|->
name|esym_ptr
operator|->
name|asym
operator|)
expr_stmt|;
block|}
comment|/* Traditionally, N_LBRAC and N_RBRAC are *not* relocated.  */
if|if
condition|(
name|code
operator|==
operator|(
name|int
operator|)
name|N_LBRAC
operator|||
name|code
operator|==
operator|(
name|int
operator|)
name|N_RBRAC
condition|)
block|{
name|sc
operator|=
name|scNil
expr_stmt|;
name|st
operator|=
name|stNil
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|=
operator|(
name|sc_t
operator|)
name|sym_ptr
operator|->
name|sc
expr_stmt|;
name|st
operator|=
operator|(
name|st_t
operator|)
name|sym_ptr
operator|->
name|st
expr_stmt|;
block|}
name|value
operator|=
name|sym_ptr
operator|->
name|value
expr_stmt|;
name|ch
operator|=
operator|*
name|end_p1
operator|++
expr_stmt|;
if|if
condition|(
name|ch
operator|!=
literal|'\n'
condition|)
block|{
if|if
condition|(
operator|(
operator|(
operator|!
name|ISDIGIT
argument_list|(
operator|*
name|end_p1
argument_list|)
operator|)
operator|&&
operator|(
operator|*
name|end_p1
operator|!=
literal|'-'
operator|)
operator|)
operator|||
operator|(
operator|(
name|ch
operator|!=
literal|'+'
operator|)
operator|&&
operator|(
name|ch
operator|!=
literal|'-'
operator|)
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"invalid .stabs/.stabn directive, badly formed value"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ch
operator|==
literal|'+'
condition|)
name|value
operator|+=
name|strtol
argument_list|(
name|end_p1
argument_list|,
operator|&
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'-'
condition|)
name|value
operator|-=
name|strtol
argument_list|(
name|end_p1
argument_list|,
operator|&
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|'\n'
condition|)
block|{
name|error
argument_list|(
literal|"invalid .stabs/.stabn directive, stuff after numeric value"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
name|code
operator|=
name|MIPS_MARK_STAB
argument_list|(
name|code
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|add_local_symbol
argument_list|(
name|string_start
argument_list|,
name|string_end
argument_list|,
name|st
argument_list|,
name|sc
argument_list|,
name|value
argument_list|,
name|code
argument_list|)
expr_stmt|;
comment|/* Restore normal file type.  */
name|cur_file_ptr
operator|=
name|save_file_ptr
expr_stmt|;
block|}
end_function

begin_function
name|STATIC
name|void
name|parse_stabs
parameter_list|(
name|start
parameter_list|)
specifier|const
name|char
modifier|*
name|start
decl_stmt|;
comment|/* start of directive */
block|{
specifier|const
name|char
modifier|*
name|end
init|=
name|strchr
argument_list|(
name|start
operator|+
literal|1
argument_list|,
literal|'"'
argument_list|)
decl_stmt|;
if|if
condition|(
operator|*
name|start
operator|!=
literal|'"'
operator|||
name|end
operator|==
operator|(
specifier|const
name|char
operator|*
operator|)
literal|0
operator|||
name|end
index|[
literal|1
index|]
operator|!=
literal|','
condition|)
block|{
name|error
argument_list|(
literal|"invalid .stabs directive, no string"
argument_list|)
expr_stmt|;
return|return;
block|}
name|parse_stabs_common
argument_list|(
name|start
operator|+
literal|1
argument_list|,
name|end
argument_list|,
name|end
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|STATIC
name|void
name|parse_stabn
parameter_list|(
name|start
parameter_list|)
specifier|const
name|char
modifier|*
name|start
decl_stmt|;
comment|/* start of directive */
block|{
name|parse_stabs_common
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
literal|0
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
literal|0
argument_list|,
name|start
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Parse the input file, and write the lines to the output file    if needed.  */
end_comment

begin_function
name|STATIC
name|void
name|parse_input
parameter_list|()
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|Size_t
name|i
decl_stmt|;
name|thead_t
modifier|*
name|ptag_head
decl_stmt|;
name|tag_t
modifier|*
name|ptag
decl_stmt|;
name|tag_t
modifier|*
name|ptag_next
decl_stmt|;
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tinput\n"
argument_list|)
expr_stmt|;
comment|/* Add a dummy scope block around the entire compilation unit for      structures defined outside of blocks.  */
name|ptag_head
operator|=
name|allocate_thead
argument_list|()
expr_stmt|;
name|ptag_head
operator|->
name|first_tag
operator|=
literal|0
expr_stmt|;
name|ptag_head
operator|->
name|prev
operator|=
name|cur_tag_head
expr_stmt|;
name|cur_tag_head
operator|=
name|ptag_head
expr_stmt|;
while|while
condition|(
operator|(
name|p
operator|=
name|read_line
argument_list|()
operator|)
operator|!=
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
block|{
comment|/* Skip leading blanks */
while|while
condition|(
name|ISSPACE
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
comment|/* See if it's a directive we handle.  If so, dispatch handler.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|pseudo_ops
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|memcmp
argument_list|(
name|p
argument_list|,
name|pseudo_ops
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|pseudo_ops
index|[
name|i
index|]
operator|.
name|len
argument_list|)
operator|==
literal|0
operator|&&
name|ISSPACE
argument_list|(
call|(
name|unsigned
name|char
call|)
argument_list|(
name|p
index|[
name|pseudo_ops
index|[
name|i
index|]
operator|.
name|len
index|]
argument_list|)
argument_list|)
condition|)
block|{
name|p
operator|+=
name|pseudo_ops
index|[
name|i
index|]
operator|.
name|len
expr_stmt|;
comment|/* skip to first argument */
while|while
condition|(
name|ISSPACE
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
operator|(
operator|*
name|pseudo_ops
index|[
name|i
index|]
operator|.
name|func
operator|)
operator|(
name|p
operator|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* Process any tags at global level.  */
name|ptag_head
operator|=
name|cur_tag_head
expr_stmt|;
name|cur_tag_head
operator|=
name|ptag_head
operator|->
name|prev
expr_stmt|;
for|for
control|(
name|ptag
operator|=
name|ptag_head
operator|->
name|first_tag
init|;
name|ptag
operator|!=
operator|(
name|tag_t
operator|*
operator|)
literal|0
condition|;
name|ptag
operator|=
name|ptag_next
control|)
block|{
if|if
condition|(
name|ptag
operator|->
name|forward_ref
operator|!=
operator|(
name|forward_t
operator|*
operator|)
literal|0
condition|)
name|add_unknown_tag
argument_list|(
name|ptag
argument_list|)
expr_stmt|;
name|ptag_next
operator|=
name|ptag
operator|->
name|same_block
expr_stmt|;
name|ptag
operator|->
name|hash_ptr
operator|->
name|tag_ptr
operator|=
name|ptag
operator|->
name|same_name
expr_stmt|;
name|free_tag
argument_list|(
name|ptag
argument_list|)
expr_stmt|;
block|}
name|free_thead
argument_list|(
name|ptag_head
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Update the global headers with the final offsets in preparation    to write out the .T file.  */
end_comment

begin_function
name|STATIC
name|void
name|update_headers
parameter_list|()
block|{
name|symint_t
name|i
decl_stmt|;
name|efdr_t
modifier|*
name|file_ptr
decl_stmt|;
comment|/* Set up the symbolic header.  */
name|file_offset
operator|=
sizeof|sizeof
argument_list|(
name|symbolic_header
argument_list|)
operator|+
name|orig_file_header
operator|.
name|f_symptr
expr_stmt|;
name|symbolic_header
operator|.
name|magic
operator|=
name|orig_sym_hdr
operator|.
name|magic
expr_stmt|;
name|symbolic_header
operator|.
name|vstamp
operator|=
name|orig_sym_hdr
operator|.
name|vstamp
expr_stmt|;
comment|/* Set up global counts.  */
name|symbolic_header
operator|.
name|issExtMax
operator|=
name|ext_strings
operator|.
name|num_allocated
expr_stmt|;
name|symbolic_header
operator|.
name|idnMax
operator|=
name|dense_num
operator|.
name|num_allocated
expr_stmt|;
name|symbolic_header
operator|.
name|ifdMax
operator|=
name|file_desc
operator|.
name|num_allocated
expr_stmt|;
name|symbolic_header
operator|.
name|iextMax
operator|=
name|ext_symbols
operator|.
name|num_allocated
expr_stmt|;
name|symbolic_header
operator|.
name|ilineMax
operator|=
name|orig_sym_hdr
operator|.
name|ilineMax
expr_stmt|;
name|symbolic_header
operator|.
name|ioptMax
operator|=
name|orig_sym_hdr
operator|.
name|ioptMax
expr_stmt|;
name|symbolic_header
operator|.
name|cbLine
operator|=
name|orig_sym_hdr
operator|.
name|cbLine
expr_stmt|;
name|symbolic_header
operator|.
name|crfd
operator|=
name|orig_sym_hdr
operator|.
name|crfd
expr_stmt|;
comment|/* Loop through each file, figuring out how many local syms,      line numbers, etc. there are.  Also, put out end symbol      for the filename.  */
for|for
control|(
name|file_ptr
operator|=
name|first_file
init|;
name|file_ptr
operator|!=
operator|(
name|efdr_t
operator|*
operator|)
literal|0
condition|;
name|file_ptr
operator|=
name|file_ptr
operator|->
name|next_file
control|)
block|{
name|SYMR
modifier|*
name|sym_start
decl_stmt|;
name|SYMR
modifier|*
name|sym
decl_stmt|;
name|SYMR
modifier|*
name|sym_end_p1
decl_stmt|;
name|FDR
modifier|*
name|fd_ptr
init|=
name|file_ptr
operator|->
name|orig_fdr
decl_stmt|;
name|cur_file_ptr
operator|=
name|file_ptr
expr_stmt|;
comment|/* Copy st_Static symbols from the original local symbol table if 	 they did not get added to the new local symbol table. 	 This happens with stabs-in-ecoff or if the source file is 	 compiled without debugging.  */
name|sym_start
operator|=
name|ORIG_LSYMS
argument_list|(
name|fd_ptr
operator|->
name|isymBase
argument_list|)
expr_stmt|;
name|sym_end_p1
operator|=
name|sym_start
operator|+
name|fd_ptr
operator|->
name|csym
expr_stmt|;
for|for
control|(
name|sym
operator|=
name|sym_start
init|;
name|sym
operator|<
name|sym_end_p1
condition|;
name|sym
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|st_t
operator|)
name|sym
operator|->
name|st
operator|==
name|st_Static
condition|)
block|{
name|char
modifier|*
name|str
init|=
name|ORIG_LSTRS
argument_list|(
name|fd_ptr
operator|->
name|issBase
operator|+
name|sym
operator|->
name|iss
argument_list|)
decl_stmt|;
name|Size_t
name|len
init|=
name|strlen
argument_list|(
name|str
argument_list|)
decl_stmt|;
name|shash_t
modifier|*
name|hash_ptr
decl_stmt|;
comment|/* Ignore internal labels.  */
if|if
condition|(
name|str
index|[
literal|0
index|]
operator|==
literal|'$'
operator|&&
name|str
index|[
literal|1
index|]
operator|==
literal|'L'
condition|)
continue|continue;
name|hash_ptr
operator|=
name|hash_string
argument_list|(
name|str
argument_list|,
operator|(
name|Ptrdiff_t
operator|)
name|len
argument_list|,
operator|&
name|file_ptr
operator|->
name|shash_head
index|[
literal|0
index|]
argument_list|,
operator|(
name|symint_t
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|hash_ptr
operator|==
operator|(
name|shash_t
operator|*
operator|)
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|add_local_symbol
argument_list|(
name|str
argument_list|,
name|str
operator|+
name|len
argument_list|,
operator|(
name|st_t
operator|)
name|sym
operator|->
name|st
argument_list|,
operator|(
name|sc_t
operator|)
name|sym
operator|->
name|sc
argument_list|,
operator|(
name|symint_t
operator|)
name|sym
operator|->
name|value
argument_list|,
operator|(
name|symint_t
operator|)
name|indexNil
argument_list|)
expr_stmt|;
block|}
block|}
block|}
operator|(
name|void
operator|)
name|add_local_symbol
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
literal|0
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
literal|0
argument_list|,
name|st_End
argument_list|,
name|sc_Text
argument_list|,
operator|(
name|symint_t
operator|)
literal|0
argument_list|,
operator|(
name|symint_t
operator|)
literal|0
argument_list|)
expr_stmt|;
name|file_ptr
operator|->
name|fdr
operator|.
name|cpd
operator|=
name|file_ptr
operator|->
name|procs
operator|.
name|num_allocated
expr_stmt|;
name|file_ptr
operator|->
name|fdr
operator|.
name|ipdFirst
operator|=
name|symbolic_header
operator|.
name|ipdMax
expr_stmt|;
name|symbolic_header
operator|.
name|ipdMax
operator|+=
name|file_ptr
operator|->
name|fdr
operator|.
name|cpd
expr_stmt|;
name|file_ptr
operator|->
name|fdr
operator|.
name|csym
operator|=
name|file_ptr
operator|->
name|symbols
operator|.
name|num_allocated
expr_stmt|;
name|file_ptr
operator|->
name|fdr
operator|.
name|isymBase
operator|=
name|symbolic_header
operator|.
name|isymMax
expr_stmt|;
name|symbolic_header
operator|.
name|isymMax
operator|+=
name|file_ptr
operator|->
name|fdr
operator|.
name|csym
expr_stmt|;
name|file_ptr
operator|->
name|fdr
operator|.
name|caux
operator|=
name|file_ptr
operator|->
name|aux_syms
operator|.
name|num_allocated
expr_stmt|;
name|file_ptr
operator|->
name|fdr
operator|.
name|iauxBase
operator|=
name|symbolic_header
operator|.
name|iauxMax
expr_stmt|;
name|symbolic_header
operator|.
name|iauxMax
operator|+=
name|file_ptr
operator|->
name|fdr
operator|.
name|caux
expr_stmt|;
name|file_ptr
operator|->
name|fdr
operator|.
name|cbSs
operator|=
name|file_ptr
operator|->
name|strings
operator|.
name|num_allocated
expr_stmt|;
name|file_ptr
operator|->
name|fdr
operator|.
name|issBase
operator|=
name|symbolic_header
operator|.
name|issMax
expr_stmt|;
name|symbolic_header
operator|.
name|issMax
operator|+=
name|file_ptr
operator|->
name|fdr
operator|.
name|cbSs
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|ALIGN_SYMTABLE_OFFSET
define|#
directive|define
name|ALIGN_SYMTABLE_OFFSET
parameter_list|(
name|OFFSET
parameter_list|)
value|(OFFSET)
endif|#
directive|endif
name|file_offset
operator|=
name|ALIGN_SYMTABLE_OFFSET
argument_list|(
name|file_offset
argument_list|)
expr_stmt|;
name|i
operator|=
name|WORD_ALIGN
argument_list|(
name|symbolic_header
operator|.
name|cbLine
argument_list|)
expr_stmt|;
comment|/* line numbers */
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|symbolic_header
operator|.
name|cbLineOffset
operator|=
name|file_offset
expr_stmt|;
name|file_offset
operator|+=
name|i
expr_stmt|;
name|file_offset
operator|=
name|ALIGN_SYMTABLE_OFFSET
argument_list|(
name|file_offset
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
name|symbolic_header
operator|.
name|ioptMax
expr_stmt|;
comment|/* optimization symbols */
if|if
condition|(
operator|(
operator|(
name|long
operator|)
name|i
operator|)
operator|>
literal|0
condition|)
block|{
name|symbolic_header
operator|.
name|cbOptOffset
operator|=
name|file_offset
expr_stmt|;
name|file_offset
operator|+=
name|i
operator|*
sizeof|sizeof
argument_list|(
name|OPTR
argument_list|)
expr_stmt|;
name|file_offset
operator|=
name|ALIGN_SYMTABLE_OFFSET
argument_list|(
name|file_offset
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
name|symbolic_header
operator|.
name|idnMax
expr_stmt|;
comment|/* dense numbers */
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|symbolic_header
operator|.
name|cbDnOffset
operator|=
name|file_offset
expr_stmt|;
name|file_offset
operator|+=
name|i
operator|*
sizeof|sizeof
argument_list|(
name|DNR
argument_list|)
expr_stmt|;
name|file_offset
operator|=
name|ALIGN_SYMTABLE_OFFSET
argument_list|(
name|file_offset
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
name|symbolic_header
operator|.
name|ipdMax
expr_stmt|;
comment|/* procedure tables */
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|symbolic_header
operator|.
name|cbPdOffset
operator|=
name|file_offset
expr_stmt|;
name|file_offset
operator|+=
name|i
operator|*
sizeof|sizeof
argument_list|(
name|PDR
argument_list|)
expr_stmt|;
name|file_offset
operator|=
name|ALIGN_SYMTABLE_OFFSET
argument_list|(
name|file_offset
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
name|symbolic_header
operator|.
name|isymMax
expr_stmt|;
comment|/* local symbols */
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|symbolic_header
operator|.
name|cbSymOffset
operator|=
name|file_offset
expr_stmt|;
name|file_offset
operator|+=
name|i
operator|*
sizeof|sizeof
argument_list|(
name|SYMR
argument_list|)
expr_stmt|;
name|file_offset
operator|=
name|ALIGN_SYMTABLE_OFFSET
argument_list|(
name|file_offset
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
name|symbolic_header
operator|.
name|iauxMax
expr_stmt|;
comment|/* aux syms.  */
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|symbolic_header
operator|.
name|cbAuxOffset
operator|=
name|file_offset
expr_stmt|;
name|file_offset
operator|+=
name|i
operator|*
sizeof|sizeof
argument_list|(
name|TIR
argument_list|)
expr_stmt|;
name|file_offset
operator|=
name|ALIGN_SYMTABLE_OFFSET
argument_list|(
name|file_offset
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
name|WORD_ALIGN
argument_list|(
name|symbolic_header
operator|.
name|issMax
argument_list|)
expr_stmt|;
comment|/* local strings */
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|symbolic_header
operator|.
name|cbSsOffset
operator|=
name|file_offset
expr_stmt|;
name|file_offset
operator|+=
name|i
expr_stmt|;
name|file_offset
operator|=
name|ALIGN_SYMTABLE_OFFSET
argument_list|(
name|file_offset
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
name|WORD_ALIGN
argument_list|(
name|symbolic_header
operator|.
name|issExtMax
argument_list|)
expr_stmt|;
comment|/* external strings */
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|symbolic_header
operator|.
name|cbSsExtOffset
operator|=
name|file_offset
expr_stmt|;
name|file_offset
operator|+=
name|i
expr_stmt|;
name|file_offset
operator|=
name|ALIGN_SYMTABLE_OFFSET
argument_list|(
name|file_offset
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
name|symbolic_header
operator|.
name|ifdMax
expr_stmt|;
comment|/* file tables */
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|symbolic_header
operator|.
name|cbFdOffset
operator|=
name|file_offset
expr_stmt|;
name|file_offset
operator|+=
name|i
operator|*
sizeof|sizeof
argument_list|(
name|FDR
argument_list|)
expr_stmt|;
name|file_offset
operator|=
name|ALIGN_SYMTABLE_OFFSET
argument_list|(
name|file_offset
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
name|symbolic_header
operator|.
name|crfd
expr_stmt|;
comment|/* relative file descriptors */
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|symbolic_header
operator|.
name|cbRfdOffset
operator|=
name|file_offset
expr_stmt|;
name|file_offset
operator|+=
name|i
operator|*
sizeof|sizeof
argument_list|(
name|symint_t
argument_list|)
expr_stmt|;
name|file_offset
operator|=
name|ALIGN_SYMTABLE_OFFSET
argument_list|(
name|file_offset
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
name|symbolic_header
operator|.
name|iextMax
expr_stmt|;
comment|/* external symbols */
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|symbolic_header
operator|.
name|cbExtOffset
operator|=
name|file_offset
expr_stmt|;
name|file_offset
operator|+=
name|i
operator|*
sizeof|sizeof
argument_list|(
name|EXTR
argument_list|)
expr_stmt|;
name|file_offset
operator|=
name|ALIGN_SYMTABLE_OFFSET
argument_list|(
name|file_offset
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Write out a varray at a given location.  */
end_comment

begin_function
name|STATIC
name|void
name|write_varray
parameter_list|(
name|vp
parameter_list|,
name|offset
parameter_list|,
name|str
parameter_list|)
name|varray_t
modifier|*
name|vp
decl_stmt|;
comment|/* virtual array */
name|off_t
name|offset
decl_stmt|;
comment|/* offset to write varray to */
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
comment|/* string to print out when tracing */
block|{
name|int
name|num_write
decl_stmt|,
name|sys_write
decl_stmt|;
name|vlinks_t
modifier|*
name|ptr
decl_stmt|;
if|if
condition|(
name|vp
operator|->
name|num_allocated
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|debug
condition|)
block|{
name|fputs
argument_list|(
literal|"\twarray\tvp = "
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|HOST_PTR_PRINTF
argument_list|,
operator|(
name|PTR
operator|)
name|vp
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|", offset = %7lu, size = %7lu, %s\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|offset
argument_list|,
name|vp
operator|->
name|num_allocated
operator|*
name|vp
operator|->
name|object_size
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|file_offset
operator|!=
name|offset
operator|&&
name|fseek
argument_list|(
name|object_stream
argument_list|,
operator|(
name|long
operator|)
name|offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|<
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|object_name
argument_list|)
expr_stmt|;
for|for
control|(
name|ptr
operator|=
name|vp
operator|->
name|first
init|;
name|ptr
operator|!=
operator|(
name|vlinks_t
operator|*
operator|)
literal|0
condition|;
name|ptr
operator|=
name|ptr
operator|->
name|next
control|)
block|{
name|num_write
operator|=
operator|(
name|ptr
operator|->
name|next
operator|==
operator|(
name|vlinks_t
operator|*
operator|)
literal|0
operator|)
condition|?
name|vp
operator|->
name|objects_last_page
operator|*
name|vp
operator|->
name|object_size
else|:
name|vp
operator|->
name|objects_per_page
operator|*
name|vp
operator|->
name|object_size
expr_stmt|;
name|sys_write
operator|=
name|fwrite
argument_list|(
operator|(
name|PTR
operator|)
name|ptr
operator|->
name|datum
argument_list|,
literal|1
argument_list|,
name|num_write
argument_list|,
name|object_stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|sys_write
operator|<=
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|object_name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sys_write
operator|!=
name|num_write
condition|)
name|fatal
argument_list|(
literal|"wrote %d bytes to %s, system returned %d"
argument_list|,
name|num_write
argument_list|,
name|object_name
argument_list|,
name|sys_write
argument_list|)
expr_stmt|;
name|file_offset
operator|+=
name|num_write
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Write out the symbol table in the object file.  */
end_comment

begin_function
name|STATIC
name|void
name|write_object
parameter_list|()
block|{
name|int
name|sys_write
decl_stmt|;
name|efdr_t
modifier|*
name|file_ptr
decl_stmt|;
name|off_t
name|offset
decl_stmt|;
if|if
condition|(
name|debug
condition|)
block|{
name|fputs
argument_list|(
literal|"\n\twrite\tvp = "
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|HOST_PTR_PRINTF
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|symbolic_header
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|", offset = %7u, size = %7lu, %s\n"
argument_list|,
literal|0
argument_list|,
operator|(
name|unsigned
name|long
operator|)
sizeof|sizeof
argument_list|(
name|symbolic_header
argument_list|)
argument_list|,
literal|"symbolic header"
argument_list|)
expr_stmt|;
block|}
name|sys_write
operator|=
name|fwrite
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|symbolic_header
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|symbolic_header
argument_list|)
argument_list|,
name|object_stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|sys_write
operator|<
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|object_name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sys_write
operator|!=
sizeof|sizeof
argument_list|(
name|symbolic_header
argument_list|)
condition|)
name|fatal
argument_list|(
literal|"wrote %d bytes to %s, system returned %d"
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|symbolic_header
argument_list|)
argument_list|,
name|object_name
argument_list|,
name|sys_write
argument_list|)
expr_stmt|;
name|file_offset
operator|=
sizeof|sizeof
argument_list|(
name|symbolic_header
argument_list|)
operator|+
name|orig_file_header
operator|.
name|f_symptr
expr_stmt|;
if|if
condition|(
name|symbolic_header
operator|.
name|cbLine
operator|>
literal|0
condition|)
comment|/* line numbers */
block|{
name|long
name|sys_write
decl_stmt|;
if|if
condition|(
name|file_offset
operator|!=
name|symbolic_header
operator|.
name|cbLineOffset
operator|&&
name|fseek
argument_list|(
name|object_stream
argument_list|,
name|symbolic_header
operator|.
name|cbLineOffset
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|object_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
block|{
name|fputs
argument_list|(
literal|"\twrite\tvp = "
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|HOST_PTR_PRINTF
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|orig_linenum
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|", offset = %7lu, size = %7lu, %s\n"
argument_list|,
operator|(
name|long
operator|)
name|symbolic_header
operator|.
name|cbLineOffset
argument_list|,
operator|(
name|long
operator|)
name|symbolic_header
operator|.
name|cbLine
argument_list|,
literal|"Line numbers"
argument_list|)
expr_stmt|;
block|}
name|sys_write
operator|=
name|fwrite
argument_list|(
operator|(
name|PTR
operator|)
name|orig_linenum
argument_list|,
literal|1
argument_list|,
name|symbolic_header
operator|.
name|cbLine
argument_list|,
name|object_stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|sys_write
operator|<=
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|object_name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sys_write
operator|!=
name|symbolic_header
operator|.
name|cbLine
condition|)
name|fatal
argument_list|(
literal|"wrote %ld bytes to %s, system returned %ld"
argument_list|,
operator|(
name|long
operator|)
name|symbolic_header
operator|.
name|cbLine
argument_list|,
name|object_name
argument_list|,
name|sys_write
argument_list|)
expr_stmt|;
name|file_offset
operator|=
name|symbolic_header
operator|.
name|cbLineOffset
operator|+
name|symbolic_header
operator|.
name|cbLine
expr_stmt|;
block|}
if|if
condition|(
name|symbolic_header
operator|.
name|ioptMax
operator|>
literal|0
condition|)
comment|/* optimization symbols */
block|{
name|long
name|sys_write
decl_stmt|;
name|long
name|num_write
init|=
name|symbolic_header
operator|.
name|ioptMax
operator|*
sizeof|sizeof
argument_list|(
name|OPTR
argument_list|)
decl_stmt|;
if|if
condition|(
name|file_offset
operator|!=
name|symbolic_header
operator|.
name|cbOptOffset
operator|&&
name|fseek
argument_list|(
name|object_stream
argument_list|,
name|symbolic_header
operator|.
name|cbOptOffset
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|object_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
block|{
name|fputs
argument_list|(
literal|"\twrite\tvp = "
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|HOST_PTR_PRINTF
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|orig_opt_syms
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|", offset = %7lu, size = %7lu, %s\n"
argument_list|,
operator|(
name|long
operator|)
name|symbolic_header
operator|.
name|cbOptOffset
argument_list|,
name|num_write
argument_list|,
literal|"Optimizer symbols"
argument_list|)
expr_stmt|;
block|}
name|sys_write
operator|=
name|fwrite
argument_list|(
operator|(
name|PTR
operator|)
name|orig_opt_syms
argument_list|,
literal|1
argument_list|,
name|num_write
argument_list|,
name|object_stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|sys_write
operator|<=
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|object_name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sys_write
operator|!=
name|num_write
condition|)
name|fatal
argument_list|(
literal|"wrote %ld bytes to %s, system returned %ld"
argument_list|,
name|num_write
argument_list|,
name|object_name
argument_list|,
name|sys_write
argument_list|)
expr_stmt|;
name|file_offset
operator|=
name|symbolic_header
operator|.
name|cbOptOffset
operator|+
name|num_write
expr_stmt|;
block|}
if|if
condition|(
name|symbolic_header
operator|.
name|idnMax
operator|>
literal|0
condition|)
comment|/* dense numbers */
name|write_varray
argument_list|(
operator|&
name|dense_num
argument_list|,
operator|(
name|off_t
operator|)
name|symbolic_header
operator|.
name|cbDnOffset
argument_list|,
literal|"Dense numbers"
argument_list|)
expr_stmt|;
if|if
condition|(
name|symbolic_header
operator|.
name|ipdMax
operator|>
literal|0
condition|)
comment|/* procedure tables */
block|{
name|offset
operator|=
name|symbolic_header
operator|.
name|cbPdOffset
expr_stmt|;
for|for
control|(
name|file_ptr
operator|=
name|first_file
init|;
name|file_ptr
operator|!=
operator|(
name|efdr_t
operator|*
operator|)
literal|0
condition|;
name|file_ptr
operator|=
name|file_ptr
operator|->
name|next_file
control|)
block|{
name|write_varray
argument_list|(
operator|&
name|file_ptr
operator|->
name|procs
argument_list|,
name|offset
argument_list|,
literal|"Procedure tables"
argument_list|)
expr_stmt|;
name|offset
operator|=
name|file_offset
expr_stmt|;
block|}
block|}
if|if
condition|(
name|symbolic_header
operator|.
name|isymMax
operator|>
literal|0
condition|)
comment|/* local symbols */
block|{
name|offset
operator|=
name|symbolic_header
operator|.
name|cbSymOffset
expr_stmt|;
for|for
control|(
name|file_ptr
operator|=
name|first_file
init|;
name|file_ptr
operator|!=
operator|(
name|efdr_t
operator|*
operator|)
literal|0
condition|;
name|file_ptr
operator|=
name|file_ptr
operator|->
name|next_file
control|)
block|{
name|write_varray
argument_list|(
operator|&
name|file_ptr
operator|->
name|symbols
argument_list|,
name|offset
argument_list|,
literal|"Local symbols"
argument_list|)
expr_stmt|;
name|offset
operator|=
name|file_offset
expr_stmt|;
block|}
block|}
if|if
condition|(
name|symbolic_header
operator|.
name|iauxMax
operator|>
literal|0
condition|)
comment|/* aux symbols */
block|{
name|offset
operator|=
name|symbolic_header
operator|.
name|cbAuxOffset
expr_stmt|;
for|for
control|(
name|file_ptr
operator|=
name|first_file
init|;
name|file_ptr
operator|!=
operator|(
name|efdr_t
operator|*
operator|)
literal|0
condition|;
name|file_ptr
operator|=
name|file_ptr
operator|->
name|next_file
control|)
block|{
name|write_varray
argument_list|(
operator|&
name|file_ptr
operator|->
name|aux_syms
argument_list|,
name|offset
argument_list|,
literal|"Aux. symbols"
argument_list|)
expr_stmt|;
name|offset
operator|=
name|file_offset
expr_stmt|;
block|}
block|}
if|if
condition|(
name|symbolic_header
operator|.
name|issMax
operator|>
literal|0
condition|)
comment|/* local strings */
block|{
name|offset
operator|=
name|symbolic_header
operator|.
name|cbSsOffset
expr_stmt|;
for|for
control|(
name|file_ptr
operator|=
name|first_file
init|;
name|file_ptr
operator|!=
operator|(
name|efdr_t
operator|*
operator|)
literal|0
condition|;
name|file_ptr
operator|=
name|file_ptr
operator|->
name|next_file
control|)
block|{
name|write_varray
argument_list|(
operator|&
name|file_ptr
operator|->
name|strings
argument_list|,
name|offset
argument_list|,
literal|"Local strings"
argument_list|)
expr_stmt|;
name|offset
operator|=
name|file_offset
expr_stmt|;
block|}
block|}
if|if
condition|(
name|symbolic_header
operator|.
name|issExtMax
operator|>
literal|0
condition|)
comment|/* external strings */
name|write_varray
argument_list|(
operator|&
name|ext_strings
argument_list|,
name|symbolic_header
operator|.
name|cbSsExtOffset
argument_list|,
literal|"External strings"
argument_list|)
expr_stmt|;
if|if
condition|(
name|symbolic_header
operator|.
name|ifdMax
operator|>
literal|0
condition|)
comment|/* file tables */
block|{
name|offset
operator|=
name|symbolic_header
operator|.
name|cbFdOffset
expr_stmt|;
if|if
condition|(
name|file_offset
operator|!=
name|offset
operator|&&
name|fseek
argument_list|(
name|object_stream
argument_list|,
operator|(
name|long
operator|)
name|offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|<
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|object_name
argument_list|)
expr_stmt|;
name|file_offset
operator|=
name|offset
expr_stmt|;
for|for
control|(
name|file_ptr
operator|=
name|first_file
init|;
name|file_ptr
operator|!=
operator|(
name|efdr_t
operator|*
operator|)
literal|0
condition|;
name|file_ptr
operator|=
name|file_ptr
operator|->
name|next_file
control|)
block|{
if|if
condition|(
name|debug
condition|)
block|{
name|fputs
argument_list|(
literal|"\twrite\tvp = "
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|HOST_PTR_PRINTF
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|file_ptr
operator|->
name|fdr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|", offset = %7lu, size = %7lu, %s\n"
argument_list|,
name|file_offset
argument_list|,
operator|(
name|unsigned
name|long
operator|)
sizeof|sizeof
argument_list|(
name|FDR
argument_list|)
argument_list|,
literal|"File header"
argument_list|)
expr_stmt|;
block|}
name|sys_write
operator|=
name|fwrite
argument_list|(
operator|&
name|file_ptr
operator|->
name|fdr
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|FDR
argument_list|)
argument_list|,
name|object_stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|sys_write
operator|<
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|object_name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sys_write
operator|!=
sizeof|sizeof
argument_list|(
name|FDR
argument_list|)
condition|)
name|fatal
argument_list|(
literal|"wrote %d bytes to %s, system returned %d"
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|FDR
argument_list|)
argument_list|,
name|object_name
argument_list|,
name|sys_write
argument_list|)
expr_stmt|;
name|file_offset
operator|=
name|offset
operator|+=
sizeof|sizeof
argument_list|(
name|FDR
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|symbolic_header
operator|.
name|crfd
operator|>
literal|0
condition|)
comment|/* relative file descriptors */
block|{
name|long
name|sys_write
decl_stmt|;
name|symint_t
name|num_write
init|=
name|symbolic_header
operator|.
name|crfd
operator|*
sizeof|sizeof
argument_list|(
name|symint_t
argument_list|)
decl_stmt|;
if|if
condition|(
name|file_offset
operator|!=
name|symbolic_header
operator|.
name|cbRfdOffset
operator|&&
name|fseek
argument_list|(
name|object_stream
argument_list|,
name|symbolic_header
operator|.
name|cbRfdOffset
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|object_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
block|{
name|fputs
argument_list|(
literal|"\twrite\tvp = "
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|HOST_PTR_PRINTF
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|orig_rfds
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|", offset = %7lu, size = %7lu, %s\n"
argument_list|,
operator|(
name|long
operator|)
name|symbolic_header
operator|.
name|cbRfdOffset
argument_list|,
name|num_write
argument_list|,
literal|"Relative file descriptors"
argument_list|)
expr_stmt|;
block|}
name|sys_write
operator|=
name|fwrite
argument_list|(
name|orig_rfds
argument_list|,
literal|1
argument_list|,
name|num_write
argument_list|,
name|object_stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|sys_write
operator|<=
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|object_name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sys_write
operator|!=
operator|(
name|long
operator|)
name|num_write
condition|)
name|fatal
argument_list|(
literal|"wrote %lu bytes to %s, system returned %ld"
argument_list|,
name|num_write
argument_list|,
name|object_name
argument_list|,
name|sys_write
argument_list|)
expr_stmt|;
name|file_offset
operator|=
name|symbolic_header
operator|.
name|cbRfdOffset
operator|+
name|num_write
expr_stmt|;
block|}
if|if
condition|(
name|symbolic_header
operator|.
name|issExtMax
operator|>
literal|0
condition|)
comment|/* external symbols */
name|write_varray
argument_list|(
operator|&
name|ext_symbols
argument_list|,
operator|(
name|off_t
operator|)
name|symbolic_header
operator|.
name|cbExtOffset
argument_list|,
literal|"External symbols"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|object_stream
argument_list|)
operator|!=
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|object_name
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Read some bytes at a specified location, and return a pointer.  */
end_comment

begin_function
name|STATIC
name|page_t
modifier|*
name|read_seek
parameter_list|(
name|size
parameter_list|,
name|offset
parameter_list|,
name|str
parameter_list|)
name|Size_t
name|size
decl_stmt|;
comment|/* # bytes to read */
name|off_t
name|offset
decl_stmt|;
comment|/* offset to read at */
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
comment|/* name for tracing */
block|{
name|page_t
modifier|*
name|ptr
decl_stmt|;
name|long
name|sys_read
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
comment|/* nothing to read */
return|return
operator|(
name|page_t
operator|*
operator|)
literal|0
return|;
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\trseek\tsize = %7lu, offset = %7lu, currently at %7lu, %s\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|size
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|offset
argument_list|,
name|file_offset
argument_list|,
name|str
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|MALLOC_CHECK
name|ptr
operator|=
name|allocate_multiple_pages
argument_list|(
operator|(
name|size
operator|+
name|PAGE_USIZE
operator|-
literal|1
operator|)
operator|/
name|PAGE_USIZE
argument_list|)
expr_stmt|;
else|#
directive|else
name|ptr
operator|=
operator|(
name|page_t
operator|*
operator|)
name|xcalloc
argument_list|(
literal|1
argument_list|,
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* If we need to seek, and the distance is nearby, just do some reads,      to speed things up.  */
if|if
condition|(
name|file_offset
operator|!=
name|offset
condition|)
block|{
name|symint_t
name|difference
init|=
name|offset
operator|-
name|file_offset
decl_stmt|;
if|if
condition|(
name|difference
operator|<
literal|8
condition|)
block|{
name|char
name|small_buffer
index|[
literal|8
index|]
decl_stmt|;
name|sys_read
operator|=
name|fread
argument_list|(
name|small_buffer
argument_list|,
literal|1
argument_list|,
name|difference
argument_list|,
name|obj_in_stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|sys_read
operator|<=
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|obj_in_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|symint_t
operator|)
name|sys_read
operator|!=
name|difference
condition|)
name|fatal
argument_list|(
literal|"wanted to read %lu bytes from %s, system returned %ld"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|size
argument_list|,
name|obj_in_name
argument_list|,
name|sys_read
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fseek
argument_list|(
name|obj_in_stream
argument_list|,
name|offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|<
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|obj_in_name
argument_list|)
expr_stmt|;
block|}
name|sys_read
operator|=
name|fread
argument_list|(
operator|(
name|PTR
operator|)
name|ptr
argument_list|,
literal|1
argument_list|,
name|size
argument_list|,
name|obj_in_stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|sys_read
operator|<=
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|obj_in_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|sys_read
operator|!=
operator|(
name|long
operator|)
name|size
condition|)
name|fatal
argument_list|(
literal|"wanted to read %lu bytes from %s, system returned %ld"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|size
argument_list|,
name|obj_in_name
argument_list|,
name|sys_read
argument_list|)
expr_stmt|;
name|file_offset
operator|=
name|offset
operator|+
name|size
expr_stmt|;
if|if
condition|(
name|file_offset
operator|>
name|max_file_offset
condition|)
name|max_file_offset
operator|=
name|file_offset
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Read the existing object file (and copy to the output object file    if it is different from the input object file), and remove the old    symbol table.  */
end_comment

begin_function
name|STATIC
name|void
name|copy_object
parameter_list|()
block|{
name|char
name|buffer
index|[
name|PAGE_SIZE
index|]
decl_stmt|;
name|int
name|sys_read
decl_stmt|;
name|int
name|remaining
decl_stmt|;
name|int
name|num_write
decl_stmt|;
name|int
name|sys_write
decl_stmt|;
name|int
name|fd
decl_stmt|,
name|es
decl_stmt|;
name|int
name|delete_ifd
init|=
literal|0
decl_stmt|;
name|int
modifier|*
name|remap_file_number
decl_stmt|;
name|struct
name|stat
name|stat_buf
decl_stmt|;
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tcopy\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fstat
argument_list|(
name|fileno
argument_list|(
name|obj_in_stream
argument_list|)
argument_list|,
operator|&
name|stat_buf
argument_list|)
operator|!=
literal|0
operator|||
name|fseek
argument_list|(
name|obj_in_stream
argument_list|,
literal|0L
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|obj_in_name
argument_list|)
expr_stmt|;
name|sys_read
operator|=
name|fread
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|orig_file_header
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|filehdr
argument_list|)
argument_list|,
name|obj_in_stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|sys_read
operator|<
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|obj_in_name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sys_read
operator|==
literal|0
operator|&&
name|feof
argument_list|(
name|obj_in_stream
argument_list|)
condition|)
return|return;
comment|/* create a .T file sans file header */
elseif|else
if|if
condition|(
name|sys_read
operator|<
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|filehdr
argument_list|)
condition|)
name|fatal
argument_list|(
literal|"wanted to read %d bytes from %s, system returned %d"
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|filehdr
argument_list|)
argument_list|,
name|obj_in_name
argument_list|,
name|sys_read
argument_list|)
expr_stmt|;
if|if
condition|(
name|orig_file_header
operator|.
name|f_nsyms
operator|!=
sizeof|sizeof
argument_list|(
name|HDRR
argument_list|)
condition|)
name|fatal
argument_list|(
literal|"%s symbolic header wrong size (%ld bytes, should be %ld)"
argument_list|,
name|input_name
argument_list|,
operator|(
name|long
operator|)
name|orig_file_header
operator|.
name|f_nsyms
argument_list|,
operator|(
name|long
operator|)
sizeof|sizeof
argument_list|(
name|HDRR
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Read in the current symbolic header.  */
if|if
condition|(
name|fseek
argument_list|(
name|obj_in_stream
argument_list|,
operator|(
name|long
operator|)
name|orig_file_header
operator|.
name|f_symptr
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|input_name
argument_list|)
expr_stmt|;
name|sys_read
operator|=
name|fread
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|orig_sym_hdr
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|orig_sym_hdr
argument_list|)
argument_list|,
name|obj_in_stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|sys_read
operator|<
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|object_name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sys_read
operator|<
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|filehdr
argument_list|)
condition|)
name|fatal
argument_list|(
literal|"wanted to read %d bytes from %s, system returned %d"
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|filehdr
argument_list|)
argument_list|,
name|obj_in_name
argument_list|,
name|sys_read
argument_list|)
expr_stmt|;
comment|/* Read in each of the sections if they exist in the object file.      We read things in in the order the mips assembler creates the      sections, so in theory no extra seeks are done.       For simplicity sake, round each read up to a page boundary,      we may want to revisit this later....  */
name|file_offset
operator|=
name|orig_file_header
operator|.
name|f_symptr
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|filehdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|orig_sym_hdr
operator|.
name|cbLine
operator|>
literal|0
condition|)
comment|/* line numbers */
name|orig_linenum
operator|=
operator|(
name|char
operator|*
operator|)
name|read_seek
argument_list|(
operator|(
name|Size_t
operator|)
name|orig_sym_hdr
operator|.
name|cbLine
argument_list|,
name|orig_sym_hdr
operator|.
name|cbLineOffset
argument_list|,
literal|"Line numbers"
argument_list|)
expr_stmt|;
if|if
condition|(
name|orig_sym_hdr
operator|.
name|ipdMax
operator|>
literal|0
condition|)
comment|/* procedure tables */
name|orig_procs
operator|=
operator|(
name|PDR
operator|*
operator|)
name|read_seek
argument_list|(
operator|(
name|Size_t
operator|)
name|orig_sym_hdr
operator|.
name|ipdMax
operator|*
sizeof|sizeof
argument_list|(
name|PDR
argument_list|)
argument_list|,
name|orig_sym_hdr
operator|.
name|cbPdOffset
argument_list|,
literal|"Procedure tables"
argument_list|)
expr_stmt|;
if|if
condition|(
name|orig_sym_hdr
operator|.
name|isymMax
operator|>
literal|0
condition|)
comment|/* local symbols */
name|orig_local_syms
operator|=
operator|(
name|SYMR
operator|*
operator|)
name|read_seek
argument_list|(
operator|(
name|Size_t
operator|)
name|orig_sym_hdr
operator|.
name|isymMax
operator|*
sizeof|sizeof
argument_list|(
name|SYMR
argument_list|)
argument_list|,
name|orig_sym_hdr
operator|.
name|cbSymOffset
argument_list|,
literal|"Local symbols"
argument_list|)
expr_stmt|;
if|if
condition|(
name|orig_sym_hdr
operator|.
name|iauxMax
operator|>
literal|0
condition|)
comment|/* aux symbols */
name|orig_aux_syms
operator|=
operator|(
name|AUXU
operator|*
operator|)
name|read_seek
argument_list|(
operator|(
name|Size_t
operator|)
name|orig_sym_hdr
operator|.
name|iauxMax
operator|*
sizeof|sizeof
argument_list|(
name|AUXU
argument_list|)
argument_list|,
name|orig_sym_hdr
operator|.
name|cbAuxOffset
argument_list|,
literal|"Aux. symbols"
argument_list|)
expr_stmt|;
if|if
condition|(
name|orig_sym_hdr
operator|.
name|issMax
operator|>
literal|0
condition|)
comment|/* local strings */
name|orig_local_strs
operator|=
operator|(
name|char
operator|*
operator|)
name|read_seek
argument_list|(
operator|(
name|Size_t
operator|)
name|orig_sym_hdr
operator|.
name|issMax
argument_list|,
name|orig_sym_hdr
operator|.
name|cbSsOffset
argument_list|,
literal|"Local strings"
argument_list|)
expr_stmt|;
if|if
condition|(
name|orig_sym_hdr
operator|.
name|issExtMax
operator|>
literal|0
condition|)
comment|/* external strings */
name|orig_ext_strs
operator|=
operator|(
name|char
operator|*
operator|)
name|read_seek
argument_list|(
operator|(
name|Size_t
operator|)
name|orig_sym_hdr
operator|.
name|issExtMax
argument_list|,
name|orig_sym_hdr
operator|.
name|cbSsExtOffset
argument_list|,
literal|"External strings"
argument_list|)
expr_stmt|;
if|if
condition|(
name|orig_sym_hdr
operator|.
name|ifdMax
operator|>
literal|0
condition|)
comment|/* file tables */
name|orig_files
operator|=
operator|(
name|FDR
operator|*
operator|)
name|read_seek
argument_list|(
operator|(
name|Size_t
operator|)
name|orig_sym_hdr
operator|.
name|ifdMax
operator|*
sizeof|sizeof
argument_list|(
name|FDR
argument_list|)
argument_list|,
name|orig_sym_hdr
operator|.
name|cbFdOffset
argument_list|,
literal|"File tables"
argument_list|)
expr_stmt|;
if|if
condition|(
name|orig_sym_hdr
operator|.
name|crfd
operator|>
literal|0
condition|)
comment|/* relative file descriptors */
name|orig_rfds
operator|=
operator|(
name|symint_t
operator|*
operator|)
name|read_seek
argument_list|(
operator|(
name|Size_t
operator|)
name|orig_sym_hdr
operator|.
name|crfd
operator|*
sizeof|sizeof
argument_list|(
name|symint_t
argument_list|)
argument_list|,
name|orig_sym_hdr
operator|.
name|cbRfdOffset
argument_list|,
literal|"Relative file descriptors"
argument_list|)
expr_stmt|;
if|if
condition|(
name|orig_sym_hdr
operator|.
name|issExtMax
operator|>
literal|0
condition|)
comment|/* external symbols */
name|orig_ext_syms
operator|=
operator|(
name|EXTR
operator|*
operator|)
name|read_seek
argument_list|(
operator|(
name|Size_t
operator|)
name|orig_sym_hdr
operator|.
name|iextMax
operator|*
sizeof|sizeof
argument_list|(
name|EXTR
argument_list|)
argument_list|,
name|orig_sym_hdr
operator|.
name|cbExtOffset
argument_list|,
literal|"External symbols"
argument_list|)
expr_stmt|;
if|if
condition|(
name|orig_sym_hdr
operator|.
name|idnMax
operator|>
literal|0
condition|)
comment|/* dense numbers */
block|{
name|orig_dense
operator|=
operator|(
name|DNR
operator|*
operator|)
name|read_seek
argument_list|(
operator|(
name|Size_t
operator|)
name|orig_sym_hdr
operator|.
name|idnMax
operator|*
sizeof|sizeof
argument_list|(
name|DNR
argument_list|)
argument_list|,
name|orig_sym_hdr
operator|.
name|cbDnOffset
argument_list|,
literal|"Dense numbers"
argument_list|)
expr_stmt|;
name|add_bytes
argument_list|(
operator|&
name|dense_num
argument_list|,
operator|(
name|char
operator|*
operator|)
name|orig_dense
argument_list|,
operator|(
name|Size_t
operator|)
name|orig_sym_hdr
operator|.
name|idnMax
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|orig_sym_hdr
operator|.
name|ioptMax
operator|>
literal|0
condition|)
comment|/* opt symbols */
name|orig_opt_syms
operator|=
operator|(
name|OPTR
operator|*
operator|)
name|read_seek
argument_list|(
operator|(
name|Size_t
operator|)
name|orig_sym_hdr
operator|.
name|ioptMax
operator|*
sizeof|sizeof
argument_list|(
name|OPTR
argument_list|)
argument_list|,
name|orig_sym_hdr
operator|.
name|cbOptOffset
argument_list|,
literal|"Optimizer symbols"
argument_list|)
expr_stmt|;
comment|/* Abort if the symbol table is not last.  */
if|if
condition|(
name|max_file_offset
operator|!=
name|stat_buf
operator|.
name|st_size
condition|)
name|fatal
argument_list|(
literal|"symbol table is not last (symbol table ends at %ld, .o ends at %ld"
argument_list|,
name|max_file_offset
argument_list|,
operator|(
name|long
operator|)
name|stat_buf
operator|.
name|st_size
argument_list|)
expr_stmt|;
comment|/* If the first original file descriptor is a dummy which the assembler      put out, but there are no symbols in it, skip it now.  */
if|if
condition|(
name|orig_sym_hdr
operator|.
name|ifdMax
operator|>
literal|1
operator|&&
name|orig_files
operator|->
name|csym
operator|==
literal|2
operator|&&
name|orig_files
operator|->
name|caux
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|filename
init|=
name|orig_local_strs
operator|+
operator|(
name|orig_files
operator|->
name|issBase
operator|+
name|orig_files
operator|->
name|rss
operator|)
decl_stmt|;
name|char
modifier|*
name|suffix
init|=
name|strrchr
argument_list|(
name|filename
argument_list|,
literal|'.'
argument_list|)
decl_stmt|;
if|if
condition|(
name|suffix
operator|!=
operator|(
name|char
operator|*
operator|)
literal|0
operator|&&
name|strcmp
argument_list|(
name|suffix
argument_list|,
literal|".s"
argument_list|)
operator|==
literal|0
condition|)
name|delete_ifd
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Create array to map original file numbers to the new file numbers      (in case there are duplicate filenames, we collapse them into one      file section, the MIPS assembler may or may not collapse them).  */
name|remap_file_number
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|orig_sym_hdr
operator|.
name|ifdMax
argument_list|)
expr_stmt|;
for|for
control|(
name|fd
operator|=
name|delete_ifd
init|;
name|fd
operator|<
name|orig_sym_hdr
operator|.
name|ifdMax
condition|;
name|fd
operator|++
control|)
block|{
name|FDR
modifier|*
name|fd_ptr
init|=
name|ORIG_FILES
argument_list|(
name|fd
argument_list|)
decl_stmt|;
name|char
modifier|*
name|filename
init|=
name|ORIG_LSTRS
argument_list|(
name|fd_ptr
operator|->
name|issBase
operator|+
name|fd_ptr
operator|->
name|rss
argument_list|)
decl_stmt|;
comment|/* file support itself.  */
name|add_file
argument_list|(
name|filename
argument_list|,
name|filename
operator|+
name|strlen
argument_list|(
name|filename
argument_list|)
argument_list|)
expr_stmt|;
name|remap_file_number
index|[
name|fd
index|]
operator|=
name|cur_file_ptr
operator|->
name|file_index
expr_stmt|;
block|}
if|if
condition|(
name|delete_ifd
operator|>
literal|0
condition|)
comment|/* just in case */
name|remap_file_number
index|[
literal|0
index|]
operator|=
name|remap_file_number
index|[
literal|1
index|]
expr_stmt|;
comment|/* Loop, adding each of the external symbols.  These must be in      order or otherwise we would have to change the relocation      entries.  We don't just call add_bytes, because we need to have      the names put into the external hash table.  We set the type to      'void' for now, and parse_def will fill in the correct type if it      is in the symbol table.  We must add the external symbols before      the locals, since the locals do lookups against the externals.  */
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tehash\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|es
operator|=
literal|0
init|;
name|es
operator|<
name|orig_sym_hdr
operator|.
name|iextMax
condition|;
name|es
operator|++
control|)
block|{
name|EXTR
modifier|*
name|eptr
init|=
name|orig_ext_syms
operator|+
name|es
decl_stmt|;
name|unsigned
name|ifd
init|=
name|eptr
operator|->
name|ifd
decl_stmt|;
operator|(
name|void
operator|)
name|add_ext_symbol
argument_list|(
name|eptr
argument_list|,
operator|(
operator|(
name|long
operator|)
name|ifd
operator|<
name|orig_sym_hdr
operator|.
name|ifdMax
operator|)
condition|?
name|remap_file_number
index|[
name|ifd
index|]
else|:
name|ifd
argument_list|)
expr_stmt|;
block|}
comment|/* For each of the files in the object file, copy the symbols, and such      into the varrays for the new object file.  */
for|for
control|(
name|fd
operator|=
name|delete_ifd
init|;
name|fd
operator|<
name|orig_sym_hdr
operator|.
name|ifdMax
condition|;
name|fd
operator|++
control|)
block|{
name|FDR
modifier|*
name|fd_ptr
init|=
name|ORIG_FILES
argument_list|(
name|fd
argument_list|)
decl_stmt|;
name|char
modifier|*
name|filename
init|=
name|ORIG_LSTRS
argument_list|(
name|fd_ptr
operator|->
name|issBase
operator|+
name|fd_ptr
operator|->
name|rss
argument_list|)
decl_stmt|;
name|SYMR
modifier|*
name|sym_start
decl_stmt|;
name|SYMR
modifier|*
name|sym
decl_stmt|;
name|SYMR
modifier|*
name|sym_end_p1
decl_stmt|;
name|PDR
modifier|*
name|proc_start
decl_stmt|;
name|PDR
modifier|*
name|proc
decl_stmt|;
name|PDR
modifier|*
name|proc_end_p1
decl_stmt|;
comment|/* file support itself.  */
name|add_file
argument_list|(
name|filename
argument_list|,
name|filename
operator|+
name|strlen
argument_list|(
name|filename
argument_list|)
argument_list|)
expr_stmt|;
name|cur_file_ptr
operator|->
name|orig_fdr
operator|=
name|fd_ptr
expr_stmt|;
comment|/* Copy stuff that's just passed through (such as line #'s) */
name|cur_file_ptr
operator|->
name|fdr
operator|.
name|adr
operator|=
name|fd_ptr
operator|->
name|adr
expr_stmt|;
name|cur_file_ptr
operator|->
name|fdr
operator|.
name|ilineBase
operator|=
name|fd_ptr
operator|->
name|ilineBase
expr_stmt|;
name|cur_file_ptr
operator|->
name|fdr
operator|.
name|cline
operator|=
name|fd_ptr
operator|->
name|cline
expr_stmt|;
name|cur_file_ptr
operator|->
name|fdr
operator|.
name|rfdBase
operator|=
name|fd_ptr
operator|->
name|rfdBase
expr_stmt|;
name|cur_file_ptr
operator|->
name|fdr
operator|.
name|crfd
operator|=
name|fd_ptr
operator|->
name|crfd
expr_stmt|;
name|cur_file_ptr
operator|->
name|fdr
operator|.
name|cbLineOffset
operator|=
name|fd_ptr
operator|->
name|cbLineOffset
expr_stmt|;
name|cur_file_ptr
operator|->
name|fdr
operator|.
name|cbLine
operator|=
name|fd_ptr
operator|->
name|cbLine
expr_stmt|;
name|cur_file_ptr
operator|->
name|fdr
operator|.
name|fMerge
operator|=
name|fd_ptr
operator|->
name|fMerge
expr_stmt|;
name|cur_file_ptr
operator|->
name|fdr
operator|.
name|fReadin
operator|=
name|fd_ptr
operator|->
name|fReadin
expr_stmt|;
name|cur_file_ptr
operator|->
name|fdr
operator|.
name|glevel
operator|=
name|fd_ptr
operator|->
name|glevel
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\thash\tstart, filename %s\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
comment|/* For each of the static and global symbols defined, add them 	 to the hash table of original symbols, so we can look up 	 their values.  */
name|sym_start
operator|=
name|ORIG_LSYMS
argument_list|(
name|fd_ptr
operator|->
name|isymBase
argument_list|)
expr_stmt|;
name|sym_end_p1
operator|=
name|sym_start
operator|+
name|fd_ptr
operator|->
name|csym
expr_stmt|;
for|for
control|(
name|sym
operator|=
name|sym_start
init|;
name|sym
operator|<
name|sym_end_p1
condition|;
name|sym
operator|++
control|)
block|{
switch|switch
condition|(
operator|(
name|st_t
operator|)
name|sym
operator|->
name|st
condition|)
block|{
default|default:
break|break;
case|case
name|st_Global
case|:
case|case
name|st_Static
case|:
case|case
name|st_Label
case|:
case|case
name|st_Proc
case|:
case|case
name|st_StaticProc
case|:
block|{
specifier|auto
name|symint_t
name|hash_index
decl_stmt|;
name|char
modifier|*
name|str
init|=
name|ORIG_LSTRS
argument_list|(
name|fd_ptr
operator|->
name|issBase
operator|+
name|sym
operator|->
name|iss
argument_list|)
decl_stmt|;
name|Size_t
name|len
init|=
name|strlen
argument_list|(
name|str
argument_list|)
decl_stmt|;
name|shash_t
modifier|*
name|shash_ptr
init|=
name|hash_string
argument_list|(
name|str
argument_list|,
operator|(
name|Ptrdiff_t
operator|)
name|len
argument_list|,
operator|&
name|orig_str_hash
index|[
literal|0
index|]
argument_list|,
operator|&
name|hash_index
argument_list|)
decl_stmt|;
if|if
condition|(
name|shash_ptr
operator|!=
operator|(
name|shash_t
operator|*
operator|)
literal|0
condition|)
name|error
argument_list|(
literal|"internal error, %s is already in original symbol table"
argument_list|,
name|str
argument_list|)
expr_stmt|;
else|else
block|{
name|shash_ptr
operator|=
name|allocate_shash
argument_list|()
expr_stmt|;
name|shash_ptr
operator|->
name|next
operator|=
name|orig_str_hash
index|[
name|hash_index
index|]
expr_stmt|;
name|orig_str_hash
index|[
name|hash_index
index|]
operator|=
name|shash_ptr
expr_stmt|;
name|shash_ptr
operator|->
name|len
operator|=
name|len
expr_stmt|;
name|shash_ptr
operator|->
name|indx
operator|=
name|indexNil
expr_stmt|;
name|shash_ptr
operator|->
name|string
operator|=
name|str
expr_stmt|;
name|shash_ptr
operator|->
name|sym_ptr
operator|=
name|sym
expr_stmt|;
block|}
block|}
break|break;
case|case
name|st_End
case|:
if|if
condition|(
operator|(
name|sc_t
operator|)
name|sym
operator|->
name|sc
operator|==
name|sc_Text
condition|)
block|{
name|char
modifier|*
name|str
init|=
name|ORIG_LSTRS
argument_list|(
name|fd_ptr
operator|->
name|issBase
operator|+
name|sym
operator|->
name|iss
argument_list|)
decl_stmt|;
if|if
condition|(
operator|*
name|str
operator|!=
literal|'\0'
condition|)
block|{
name|Size_t
name|len
init|=
name|strlen
argument_list|(
name|str
argument_list|)
decl_stmt|;
name|shash_t
modifier|*
name|shash_ptr
init|=
name|hash_string
argument_list|(
name|str
argument_list|,
operator|(
name|Ptrdiff_t
operator|)
name|len
argument_list|,
operator|&
name|orig_str_hash
index|[
literal|0
index|]
argument_list|,
operator|(
name|symint_t
operator|*
operator|)
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|shash_ptr
operator|!=
operator|(
name|shash_t
operator|*
operator|)
literal|0
condition|)
name|shash_ptr
operator|->
name|end_ptr
operator|=
name|sym
expr_stmt|;
block|}
block|}
break|break;
block|}
block|}
if|if
condition|(
name|debug
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\thash\tdone,  filename %s\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tproc\tstart, filename %s\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
comment|/* Go through each of the procedures in this file, and add the 	 procedure pointer to the hash entry for the given name.  */
name|proc_start
operator|=
name|ORIG_PROCS
argument_list|(
name|fd_ptr
operator|->
name|ipdFirst
argument_list|)
expr_stmt|;
name|proc_end_p1
operator|=
name|proc_start
operator|+
name|fd_ptr
operator|->
name|cpd
expr_stmt|;
for|for
control|(
name|proc
operator|=
name|proc_start
init|;
name|proc
operator|<
name|proc_end_p1
condition|;
name|proc
operator|++
control|)
block|{
name|SYMR
modifier|*
name|proc_sym
init|=
name|ORIG_LSYMS
argument_list|(
name|fd_ptr
operator|->
name|isymBase
operator|+
name|proc
operator|->
name|isym
argument_list|)
decl_stmt|;
name|char
modifier|*
name|str
init|=
name|ORIG_LSTRS
argument_list|(
name|fd_ptr
operator|->
name|issBase
operator|+
name|proc_sym
operator|->
name|iss
argument_list|)
decl_stmt|;
name|Size_t
name|len
init|=
name|strlen
argument_list|(
name|str
argument_list|)
decl_stmt|;
name|shash_t
modifier|*
name|shash_ptr
init|=
name|hash_string
argument_list|(
name|str
argument_list|,
operator|(
name|Ptrdiff_t
operator|)
name|len
argument_list|,
operator|&
name|orig_str_hash
index|[
literal|0
index|]
argument_list|,
operator|(
name|symint_t
operator|*
operator|)
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|shash_ptr
operator|==
operator|(
name|shash_t
operator|*
operator|)
literal|0
condition|)
name|error
argument_list|(
literal|"internal error, function %s is not in original symbol table"
argument_list|,
name|str
argument_list|)
expr_stmt|;
else|else
name|shash_ptr
operator|->
name|proc_ptr
operator|=
name|proc
expr_stmt|;
block|}
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tproc\tdone,  filename %s\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
name|cur_file_ptr
operator|=
name|first_file
expr_stmt|;
comment|/* Copy all of the object file up to the symbol table.  Originally      we were going to use ftruncate, but that doesn't seem to work      on Ultrix 3.1....  */
if|if
condition|(
name|fseek
argument_list|(
name|obj_in_stream
argument_list|,
operator|(
name|long
operator|)
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|obj_in_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|fseek
argument_list|(
name|object_stream
argument_list|,
operator|(
name|long
operator|)
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|object_name
argument_list|)
expr_stmt|;
for|for
control|(
name|remaining
operator|=
name|orig_file_header
operator|.
name|f_symptr
init|;
name|remaining
operator|>
literal|0
condition|;
name|remaining
operator|-=
name|num_write
control|)
block|{
name|num_write
operator|=
operator|(
name|remaining
operator|<=
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
operator|)
condition|?
name|remaining
else|:
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|sys_read
operator|=
name|fread
argument_list|(
operator|(
name|PTR
operator|)
name|buffer
argument_list|,
literal|1
argument_list|,
name|num_write
argument_list|,
name|obj_in_stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|sys_read
operator|<=
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|obj_in_name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sys_read
operator|!=
name|num_write
condition|)
name|fatal
argument_list|(
literal|"wanted to read %d bytes from %s, system returned %d"
argument_list|,
name|num_write
argument_list|,
name|obj_in_name
argument_list|,
name|sys_read
argument_list|)
expr_stmt|;
name|sys_write
operator|=
name|fwrite
argument_list|(
name|buffer
argument_list|,
literal|1
argument_list|,
name|num_write
argument_list|,
name|object_stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|sys_write
operator|<=
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|object_name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sys_write
operator|!=
name|num_write
condition|)
name|fatal
argument_list|(
literal|"wrote %d bytes to %s, system returned %d"
argument_list|,
name|num_write
argument_list|,
name|object_name
argument_list|,
name|sys_write
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Ye olde main program.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
decl|main
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|iflag
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|strrchr
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|'/'
argument_list|)
decl_stmt|;
name|char
modifier|*
name|num_end
decl_stmt|;
name|int
name|option
decl_stmt|;
name|int
name|i
decl_stmt|;
name|progname
operator|=
operator|(
name|p
operator|!=
literal|0
operator|)
condition|?
name|p
operator|+
literal|1
else|:
name|argv
index|[
literal|0
index|]
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGSEGV
argument_list|,
name|catch_signal
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGBUS
argument_list|,
name|catch_signal
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGABRT
argument_list|,
name|catch_signal
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__SABER__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|lint
argument_list|)
if|if
condition|(
sizeof|sizeof
argument_list|(
name|efdr_t
argument_list|)
operator|>
name|PAGE_USIZE
condition|)
name|fatal
argument_list|(
literal|"efdr_t has a sizeof %d bytes, when it should be less than %d"
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|efdr_t
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|PAGE_USIZE
argument_list|)
expr_stmt|;
if|if
condition|(
sizeof|sizeof
argument_list|(
name|page_t
argument_list|)
operator|!=
name|PAGE_USIZE
condition|)
name|fatal
argument_list|(
literal|"page_t has a sizeof %d bytes, when it should be %d"
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|page_t
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|PAGE_USIZE
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|alloc_counts
index|[
name|alloc_type_none
index|]
operator|.
name|alloc_name
operator|=
literal|"none"
expr_stmt|;
name|alloc_counts
index|[
name|alloc_type_scope
index|]
operator|.
name|alloc_name
operator|=
literal|"scope"
expr_stmt|;
name|alloc_counts
index|[
name|alloc_type_vlinks
index|]
operator|.
name|alloc_name
operator|=
literal|"vlinks"
expr_stmt|;
name|alloc_counts
index|[
name|alloc_type_shash
index|]
operator|.
name|alloc_name
operator|=
literal|"shash"
expr_stmt|;
name|alloc_counts
index|[
name|alloc_type_thash
index|]
operator|.
name|alloc_name
operator|=
literal|"thash"
expr_stmt|;
name|alloc_counts
index|[
name|alloc_type_tag
index|]
operator|.
name|alloc_name
operator|=
literal|"tag"
expr_stmt|;
name|alloc_counts
index|[
name|alloc_type_forward
index|]
operator|.
name|alloc_name
operator|=
literal|"forward"
expr_stmt|;
name|alloc_counts
index|[
name|alloc_type_thead
index|]
operator|.
name|alloc_name
operator|=
literal|"thead"
expr_stmt|;
name|alloc_counts
index|[
name|alloc_type_varray
index|]
operator|.
name|alloc_name
operator|=
literal|"varray"
expr_stmt|;
name|int_type_info
operator|=
name|type_info_init
expr_stmt|;
name|int_type_info
operator|.
name|basic_type
operator|=
name|bt_Int
expr_stmt|;
name|void_type_info
operator|=
name|type_info_init
expr_stmt|;
name|void_type_info
operator|.
name|basic_type
operator|=
name|bt_Void
expr_stmt|;
while|while
condition|(
operator|(
name|option
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"d:i:I:o:v"
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
switch|switch
condition|(
name|option
condition|)
block|{
default|default:
name|had_errors
operator|++
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|debug
operator|=
name|strtol
argument_list|(
name|optarg
argument_list|,
operator|&
name|num_end
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
operator|)
name|debug
operator|>
literal|4
operator|||
name|num_end
operator|==
name|optarg
condition|)
name|had_errors
operator|++
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
if|if
condition|(
name|rename_output
operator|||
name|obj_in_name
operator|!=
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
name|had_errors
operator|++
expr_stmt|;
else|else
name|rename_output
operator|=
literal|1
expr_stmt|;
comment|/* fall through to 'i' case.  */
case|case
literal|'i'
case|:
if|if
condition|(
name|obj_in_name
operator|==
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
block|{
name|obj_in_name
operator|=
name|optarg
expr_stmt|;
name|iflag
operator|++
expr_stmt|;
block|}
else|else
name|had_errors
operator|++
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
if|if
condition|(
name|object_name
operator|==
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
name|object_name
operator|=
name|optarg
expr_stmt|;
else|else
name|had_errors
operator|++
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|version
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|obj_in_name
operator|==
operator|(
name|char
operator|*
operator|)
literal|0
operator|&&
name|optind
operator|<=
name|argc
operator|-
literal|2
condition|)
name|obj_in_name
operator|=
name|argv
index|[
operator|--
name|argc
index|]
expr_stmt|;
if|if
condition|(
name|object_name
operator|==
operator|(
name|char
operator|*
operator|)
literal|0
operator|&&
name|optind
operator|<=
name|argc
operator|-
literal|2
condition|)
name|object_name
operator|=
name|argv
index|[
operator|--
name|argc
index|]
expr_stmt|;
comment|/* If there is an output name, but no input name use      the same file for both, deleting the name between      opening it for input and opening it for output.  */
if|if
condition|(
name|obj_in_name
operator|==
operator|(
name|char
operator|*
operator|)
literal|0
operator|&&
name|object_name
operator|!=
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
block|{
name|obj_in_name
operator|=
name|object_name
expr_stmt|;
name|delete_input
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|object_name
operator|==
operator|(
name|char
operator|*
operator|)
literal|0
operator|||
name|had_errors
operator|||
name|optind
operator|!=
name|argc
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"Calling Sequence:\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"\tmips-tfile [-d<num>] [-v] [-i<o-in-file>] -o<o-out-file><s-file> (or)\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"\tmips-tfile [-d<num>] [-v] [-I<o-in-file>] -o<o-out-file><s-file> (or)\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"\tmips-tfile [-d<num>] [-v]<s-file><o-in-file><o-out-file>\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"Debug levels are:\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"    1\tGeneral debug + trace functions/blocks.\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"    2\tDebug level 1 + trace externals.\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"    3\tDebug level 2 + trace all symbols.\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"    4\tDebug level 3 + trace memory allocations.\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|version
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"mips-tfile version %s"
argument_list|)
argument_list|,
name|version_string
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TARGET_VERSION
name|TARGET_VERSION
expr_stmt|;
endif|#
directive|endif
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|obj_in_name
operator|==
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
name|obj_in_name
operator|=
name|object_name
expr_stmt|;
if|if
condition|(
name|rename_output
operator|&&
name|rename
argument_list|(
name|object_name
argument_list|,
name|obj_in_name
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|char
modifier|*
name|buffer
init|=
operator|(
name|char
operator|*
operator|)
name|allocate_multiple_pages
argument_list|(
literal|4
argument_list|)
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|len2
decl_stmt|;
name|int
name|in_fd
decl_stmt|;
name|int
name|out_fd
decl_stmt|;
comment|/* Rename failed, copy input file */
name|in_fd
operator|=
name|open
argument_list|(
name|object_name
argument_list|,
name|O_RDONLY
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
if|if
condition|(
name|in_fd
operator|<
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|object_name
argument_list|)
expr_stmt|;
name|out_fd
operator|=
name|open
argument_list|(
name|obj_in_name
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_TRUNC
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
if|if
condition|(
name|out_fd
operator|<
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|obj_in_name
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|len
operator|=
name|read
argument_list|(
name|in_fd
argument_list|,
name|buffer
argument_list|,
literal|4
operator|*
name|PAGE_SIZE
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|len2
operator|=
name|write
argument_list|(
name|out_fd
argument_list|,
name|buffer
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|len2
operator|<
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|object_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|!=
name|len2
condition|)
name|fatal
argument_list|(
literal|"wrote %d bytes to %s, expected to write %d"
argument_list|,
name|len2
argument_list|,
name|obj_in_name
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
name|free_multiple_pages
argument_list|(
operator|(
name|page_t
operator|*
operator|)
name|buffer
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|object_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|close
argument_list|(
name|in_fd
argument_list|)
operator|<
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|object_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|close
argument_list|(
name|out_fd
argument_list|)
operator|<
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|obj_in_name
argument_list|)
expr_stmt|;
block|}
comment|/* Must open input before output, since the output may be the same file, and      we need to get the input handle before truncating it.  */
name|obj_in_stream
operator|=
name|fopen
argument_list|(
name|obj_in_name
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj_in_stream
operator|==
operator|(
name|FILE
operator|*
operator|)
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|obj_in_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|delete_input
operator|&&
name|unlink
argument_list|(
name|obj_in_name
argument_list|)
operator|!=
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|obj_in_name
argument_list|)
expr_stmt|;
name|object_stream
operator|=
name|fopen
argument_list|(
name|object_name
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|object_stream
operator|==
operator|(
name|FILE
operator|*
operator|)
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|object_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|optind
index|]
argument_list|,
literal|"-"
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|input_name
operator|=
name|argv
index|[
name|optind
index|]
expr_stmt|;
if|if
condition|(
name|freopen
argument_list|(
name|argv
index|[
name|optind
index|]
argument_list|,
literal|"r"
argument_list|,
name|stdin
argument_list|)
operator|!=
name|stdin
condition|)
name|pfatal_with_name
argument_list|(
name|argv
index|[
name|optind
index|]
argument_list|)
expr_stmt|;
block|}
name|copy_object
argument_list|()
expr_stmt|;
comment|/* scan& copy object file */
name|parse_input
argument_list|()
expr_stmt|;
comment|/* scan all of input */
name|update_headers
argument_list|()
expr_stmt|;
comment|/* write out tfile */
name|write_object
argument_list|()
expr_stmt|;
if|if
condition|(
name|debug
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n\tAllocation summary:\n\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
operator|(
name|int
operator|)
name|alloc_type_none
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|alloc_type_last
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|alloc_counts
index|[
name|i
index|]
operator|.
name|total_alloc
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t%s\t%5d allocation(s), %5d free(s), %2d page(s)\n"
argument_list|,
name|alloc_counts
index|[
name|i
index|]
operator|.
name|alloc_name
argument_list|,
name|alloc_counts
index|[
name|i
index|]
operator|.
name|total_alloc
argument_list|,
name|alloc_counts
index|[
name|i
index|]
operator|.
name|total_free
argument_list|,
name|alloc_counts
index|[
name|i
index|]
operator|.
name|total_pages
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|had_errors
operator|)
condition|?
literal|1
else|:
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Catch a signal and exit without dumping core.  */
end_comment

begin_function
name|STATIC
name|void
name|catch_signal
parameter_list|(
name|signum
parameter_list|)
name|int
name|signum
decl_stmt|;
block|{
operator|(
name|void
operator|)
name|signal
argument_list|(
name|signum
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
comment|/* just in case...  */
name|fatal
argument_list|(
literal|"%s"
argument_list|,
name|strsignal
argument_list|(
name|signum
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print a fatal error message.  NAME is the text.    Also include a system error message based on `errno'.  */
end_comment

begin_function
name|void
name|pfatal_with_name
parameter_list|(
name|msg
parameter_list|)
specifier|const
name|char
modifier|*
name|msg
decl_stmt|;
block|{
name|int
name|save_errno
init|=
name|errno
decl_stmt|;
comment|/* just in case....  */
if|if
condition|(
name|line_number
operator|>
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s, %s:%ld "
argument_list|,
name|progname
argument_list|,
name|input_name
argument_list|,
name|line_number
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|errno
operator|=
name|save_errno
expr_stmt|;
if|if
condition|(
name|errno
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"[errno = 0] %s\n"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
else|else
name|perror
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Procedure to abort with an out of bounds error message.  It has    type int, so it can be used with an ?: expression within the    ORIG_xxx macros, but the function never returns.  */
end_comment

begin_function
specifier|static
name|int
name|out_of_bounds
parameter_list|(
name|indx
parameter_list|,
name|max
parameter_list|,
name|str
parameter_list|,
name|prog_line
parameter_list|)
name|symint_t
name|indx
decl_stmt|;
comment|/* index that is out of bounds */
name|symint_t
name|max
decl_stmt|;
comment|/* maximum index */
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
comment|/* string to print out */
name|int
name|prog_line
decl_stmt|;
comment|/* line number within mips-tfile.c */
block|{
if|if
condition|(
name|indx
operator|<
name|max
condition|)
comment|/* just in case */
return|return
literal|0
return|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s, %s:%ld index %lu is out of bounds for %s, max is %lu, mips-tfile.c line# %d\n"
argument_list|,
name|progname
argument_list|,
name|input_name
argument_list|,
name|line_number
argument_list|,
name|indx
argument_list|,
name|str
argument_list|,
name|max
argument_list|,
name|prog_line
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
comment|/* turn off warning messages */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Allocate a cluster of pages.  USE_MALLOC says that malloc does not    like sbrk's behind its back (or sbrk isn't available).  If we use    sbrk, we assume it gives us zeroed pages.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MALLOC_CHECK
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|USE_MALLOC
end_ifdef

begin_function
name|STATIC
name|page_t
modifier|*
name|allocate_cluster
parameter_list|(
name|npages
parameter_list|)
name|Size_t
name|npages
decl_stmt|;
block|{
name|page_t
modifier|*
name|value
init|=
operator|(
name|page_t
operator|*
operator|)
name|xcalloc
argument_list|(
name|npages
argument_list|,
name|PAGE_USIZE
argument_list|)
decl_stmt|;
if|if
condition|(
name|debug
operator|>
literal|3
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\talloc\tnpages = %d, value = 0x%.8x\n"
argument_list|,
name|npages
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* USE_MALLOC */
end_comment

begin_function
name|STATIC
name|page_t
modifier|*
name|allocate_cluster
parameter_list|(
name|npages
parameter_list|)
name|Size_t
name|npages
decl_stmt|;
block|{
name|page_t
modifier|*
name|ptr
init|=
operator|(
name|page_t
operator|*
operator|)
name|sbrk
argument_list|(
literal|0
argument_list|)
decl_stmt|;
comment|/* current sbreak */
name|unsigned
name|long
name|offset
init|=
operator|(
operator|(
name|unsigned
name|long
operator|)
name|ptr
operator|)
operator|&
operator|(
name|PAGE_SIZE
operator|-
literal|1
operator|)
decl_stmt|;
if|if
condition|(
name|offset
operator|!=
literal|0
condition|)
comment|/* align to a page boundary */
block|{
if|if
condition|(
name|sbrk
argument_list|(
name|PAGE_USIZE
operator|-
name|offset
argument_list|)
operator|==
operator|(
name|char
operator|*
operator|)
operator|-
literal|1
condition|)
name|pfatal_with_name
argument_list|(
literal|"allocate_cluster"
argument_list|)
expr_stmt|;
name|ptr
operator|=
operator|(
name|page_t
operator|*
operator|)
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
name|ptr
operator|)
operator|+
name|PAGE_SIZE
operator|-
name|offset
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|sbrk
argument_list|(
name|npages
operator|*
name|PAGE_USIZE
argument_list|)
operator|==
operator|(
name|char
operator|*
operator|)
operator|-
literal|1
condition|)
name|pfatal_with_name
argument_list|(
literal|"allocate_cluster"
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|>
literal|3
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\talloc\tnpages = %lu, value = "
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|npages
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|HOST_PTR_PRINTF
argument_list|,
operator|(
name|PTR
operator|)
name|ptr
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
return|return
name|ptr
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_MALLOC */
end_comment

begin_decl_stmt
specifier|static
name|page_t
modifier|*
name|cluster_ptr
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|pages_left
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MALLOC_CHECK */
end_comment

begin_comment
comment|/* Allocate some pages (which is initialized to 0).  */
end_comment

begin_function
name|STATIC
name|page_t
modifier|*
name|allocate_multiple_pages
parameter_list|(
name|npages
parameter_list|)
name|Size_t
name|npages
decl_stmt|;
block|{
ifndef|#
directive|ifndef
name|MALLOC_CHECK
if|if
condition|(
name|pages_left
operator|==
literal|0
operator|&&
name|npages
operator|<
name|MAX_CLUSTER_PAGES
condition|)
block|{
name|pages_left
operator|=
name|MAX_CLUSTER_PAGES
expr_stmt|;
name|cluster_ptr
operator|=
name|allocate_cluster
argument_list|(
name|MAX_CLUSTER_PAGES
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|npages
operator|<=
name|pages_left
condition|)
block|{
name|page_t
modifier|*
name|ptr
init|=
name|cluster_ptr
decl_stmt|;
name|cluster_ptr
operator|+=
name|npages
expr_stmt|;
name|pages_left
operator|-=
name|npages
expr_stmt|;
return|return
name|ptr
return|;
block|}
return|return
name|allocate_cluster
argument_list|(
name|npages
argument_list|)
return|;
else|#
directive|else
comment|/* MALLOC_CHECK */
return|return
operator|(
name|page_t
operator|*
operator|)
name|xcalloc
argument_list|(
name|npages
argument_list|,
name|PAGE_SIZE
argument_list|)
return|;
endif|#
directive|endif
comment|/* MALLOC_CHECK */
block|}
end_function

begin_comment
comment|/* Release some pages.  */
end_comment

begin_function
name|STATIC
name|void
name|free_multiple_pages
parameter_list|(
name|page_ptr
parameter_list|,
name|npages
parameter_list|)
name|page_t
modifier|*
name|page_ptr
decl_stmt|;
name|Size_t
name|npages
decl_stmt|;
block|{
ifndef|#
directive|ifndef
name|MALLOC_CHECK
if|if
condition|(
name|pages_left
operator|==
literal|0
condition|)
block|{
name|cluster_ptr
operator|=
name|page_ptr
expr_stmt|;
name|pages_left
operator|=
name|npages
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|page_ptr
operator|+
name|npages
operator|)
operator|==
name|cluster_ptr
condition|)
block|{
name|cluster_ptr
operator|-=
name|npages
expr_stmt|;
name|pages_left
operator|+=
name|npages
expr_stmt|;
block|}
comment|/* otherwise the page is not freed.  If more than call is      done, we probably should worry about it, but at present,      the free pages is done right after an allocate.  */
else|#
directive|else
comment|/* MALLOC_CHECK */
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|page_ptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MALLOC_CHECK */
block|}
end_function

begin_comment
comment|/* Allocate one page (which is initialized to 0).  */
end_comment

begin_function
name|STATIC
name|page_t
modifier|*
name|allocate_page
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|MALLOC_CHECK
if|if
condition|(
name|pages_left
operator|==
literal|0
condition|)
block|{
name|pages_left
operator|=
name|MAX_CLUSTER_PAGES
expr_stmt|;
name|cluster_ptr
operator|=
name|allocate_cluster
argument_list|(
name|MAX_CLUSTER_PAGES
argument_list|)
expr_stmt|;
block|}
name|pages_left
operator|--
expr_stmt|;
return|return
name|cluster_ptr
operator|++
return|;
else|#
directive|else
comment|/* MALLOC_CHECK */
return|return
operator|(
name|page_t
operator|*
operator|)
name|xcalloc
argument_list|(
literal|1
argument_list|,
name|PAGE_SIZE
argument_list|)
return|;
endif|#
directive|endif
comment|/* MALLOC_CHECK */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Allocate scoping information.  */
end_comment

begin_function
name|STATIC
name|scope_t
modifier|*
name|allocate_scope
parameter_list|()
block|{
name|scope_t
modifier|*
name|ptr
decl_stmt|;
specifier|static
name|scope_t
name|initial_scope
decl_stmt|;
ifndef|#
directive|ifndef
name|MALLOC_CHECK
name|ptr
operator|=
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_scope
index|]
operator|.
name|free_list
operator|.
name|f_scope
expr_stmt|;
if|if
condition|(
name|ptr
operator|!=
operator|(
name|scope_t
operator|*
operator|)
literal|0
condition|)
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_scope
index|]
operator|.
name|free_list
operator|.
name|f_scope
operator|=
name|ptr
operator|->
name|free
expr_stmt|;
else|else
block|{
name|int
name|unallocated
init|=
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_scope
index|]
operator|.
name|unallocated
decl_stmt|;
name|page_t
modifier|*
name|cur_page
init|=
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_scope
index|]
operator|.
name|cur_page
decl_stmt|;
if|if
condition|(
name|unallocated
operator|==
literal|0
condition|)
block|{
name|unallocated
operator|=
name|PAGE_SIZE
operator|/
sizeof|sizeof
argument_list|(
name|scope_t
argument_list|)
expr_stmt|;
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_scope
index|]
operator|.
name|cur_page
operator|=
name|cur_page
operator|=
name|allocate_page
argument_list|()
expr_stmt|;
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_scope
index|]
operator|.
name|total_pages
operator|++
expr_stmt|;
block|}
name|ptr
operator|=
operator|&
name|cur_page
operator|->
name|scope
index|[
operator|--
name|unallocated
index|]
expr_stmt|;
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_scope
index|]
operator|.
name|unallocated
operator|=
name|unallocated
expr_stmt|;
block|}
else|#
directive|else
name|ptr
operator|=
operator|(
name|scope_t
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|scope_t
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_scope
index|]
operator|.
name|total_alloc
operator|++
expr_stmt|;
operator|*
name|ptr
operator|=
name|initial_scope
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_comment
comment|/* Free scoping information.  */
end_comment

begin_function
name|STATIC
name|void
name|free_scope
parameter_list|(
name|ptr
parameter_list|)
name|scope_t
modifier|*
name|ptr
decl_stmt|;
block|{
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_scope
index|]
operator|.
name|total_free
operator|++
expr_stmt|;
ifndef|#
directive|ifndef
name|MALLOC_CHECK
name|ptr
operator|->
name|free
operator|=
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_scope
index|]
operator|.
name|free_list
operator|.
name|f_scope
expr_stmt|;
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_scope
index|]
operator|.
name|free_list
operator|.
name|f_scope
operator|=
name|ptr
expr_stmt|;
else|#
directive|else
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|ptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Allocate links for pages in a virtual array.  */
end_comment

begin_function
name|STATIC
name|vlinks_t
modifier|*
name|allocate_vlinks
parameter_list|()
block|{
name|vlinks_t
modifier|*
name|ptr
decl_stmt|;
specifier|static
name|vlinks_t
name|initial_vlinks
decl_stmt|;
ifndef|#
directive|ifndef
name|MALLOC_CHECK
name|int
name|unallocated
init|=
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_vlinks
index|]
operator|.
name|unallocated
decl_stmt|;
name|page_t
modifier|*
name|cur_page
init|=
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_vlinks
index|]
operator|.
name|cur_page
decl_stmt|;
if|if
condition|(
name|unallocated
operator|==
literal|0
condition|)
block|{
name|unallocated
operator|=
name|PAGE_SIZE
operator|/
sizeof|sizeof
argument_list|(
name|vlinks_t
argument_list|)
expr_stmt|;
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_vlinks
index|]
operator|.
name|cur_page
operator|=
name|cur_page
operator|=
name|allocate_page
argument_list|()
expr_stmt|;
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_vlinks
index|]
operator|.
name|total_pages
operator|++
expr_stmt|;
block|}
name|ptr
operator|=
operator|&
name|cur_page
operator|->
name|vlinks
index|[
operator|--
name|unallocated
index|]
expr_stmt|;
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_vlinks
index|]
operator|.
name|unallocated
operator|=
name|unallocated
expr_stmt|;
else|#
directive|else
name|ptr
operator|=
operator|(
name|vlinks_t
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|vlinks_t
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_vlinks
index|]
operator|.
name|total_alloc
operator|++
expr_stmt|;
operator|*
name|ptr
operator|=
name|initial_vlinks
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Allocate string hash buckets.  */
end_comment

begin_function
name|STATIC
name|shash_t
modifier|*
name|allocate_shash
parameter_list|()
block|{
name|shash_t
modifier|*
name|ptr
decl_stmt|;
specifier|static
name|shash_t
name|initial_shash
decl_stmt|;
ifndef|#
directive|ifndef
name|MALLOC_CHECK
name|int
name|unallocated
init|=
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_shash
index|]
operator|.
name|unallocated
decl_stmt|;
name|page_t
modifier|*
name|cur_page
init|=
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_shash
index|]
operator|.
name|cur_page
decl_stmt|;
if|if
condition|(
name|unallocated
operator|==
literal|0
condition|)
block|{
name|unallocated
operator|=
name|PAGE_SIZE
operator|/
sizeof|sizeof
argument_list|(
name|shash_t
argument_list|)
expr_stmt|;
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_shash
index|]
operator|.
name|cur_page
operator|=
name|cur_page
operator|=
name|allocate_page
argument_list|()
expr_stmt|;
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_shash
index|]
operator|.
name|total_pages
operator|++
expr_stmt|;
block|}
name|ptr
operator|=
operator|&
name|cur_page
operator|->
name|shash
index|[
operator|--
name|unallocated
index|]
expr_stmt|;
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_shash
index|]
operator|.
name|unallocated
operator|=
name|unallocated
expr_stmt|;
else|#
directive|else
name|ptr
operator|=
operator|(
name|shash_t
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|shash_t
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_shash
index|]
operator|.
name|total_alloc
operator|++
expr_stmt|;
operator|*
name|ptr
operator|=
name|initial_shash
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Allocate type hash buckets.  */
end_comment

begin_function
name|STATIC
name|thash_t
modifier|*
name|allocate_thash
parameter_list|()
block|{
name|thash_t
modifier|*
name|ptr
decl_stmt|;
specifier|static
name|thash_t
name|initial_thash
decl_stmt|;
ifndef|#
directive|ifndef
name|MALLOC_CHECK
name|int
name|unallocated
init|=
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_thash
index|]
operator|.
name|unallocated
decl_stmt|;
name|page_t
modifier|*
name|cur_page
init|=
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_thash
index|]
operator|.
name|cur_page
decl_stmt|;
if|if
condition|(
name|unallocated
operator|==
literal|0
condition|)
block|{
name|unallocated
operator|=
name|PAGE_SIZE
operator|/
sizeof|sizeof
argument_list|(
name|thash_t
argument_list|)
expr_stmt|;
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_thash
index|]
operator|.
name|cur_page
operator|=
name|cur_page
operator|=
name|allocate_page
argument_list|()
expr_stmt|;
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_thash
index|]
operator|.
name|total_pages
operator|++
expr_stmt|;
block|}
name|ptr
operator|=
operator|&
name|cur_page
operator|->
name|thash
index|[
operator|--
name|unallocated
index|]
expr_stmt|;
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_thash
index|]
operator|.
name|unallocated
operator|=
name|unallocated
expr_stmt|;
else|#
directive|else
name|ptr
operator|=
operator|(
name|thash_t
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|thash_t
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_thash
index|]
operator|.
name|total_alloc
operator|++
expr_stmt|;
operator|*
name|ptr
operator|=
name|initial_thash
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Allocate structure, union, or enum tag information.  */
end_comment

begin_function
name|STATIC
name|tag_t
modifier|*
name|allocate_tag
parameter_list|()
block|{
name|tag_t
modifier|*
name|ptr
decl_stmt|;
specifier|static
name|tag_t
name|initial_tag
decl_stmt|;
ifndef|#
directive|ifndef
name|MALLOC_CHECK
name|ptr
operator|=
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_tag
index|]
operator|.
name|free_list
operator|.
name|f_tag
expr_stmt|;
if|if
condition|(
name|ptr
operator|!=
operator|(
name|tag_t
operator|*
operator|)
literal|0
condition|)
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_tag
index|]
operator|.
name|free_list
operator|.
name|f_tag
operator|=
name|ptr
operator|->
name|free
expr_stmt|;
else|else
block|{
name|int
name|unallocated
init|=
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_tag
index|]
operator|.
name|unallocated
decl_stmt|;
name|page_t
modifier|*
name|cur_page
init|=
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_tag
index|]
operator|.
name|cur_page
decl_stmt|;
if|if
condition|(
name|unallocated
operator|==
literal|0
condition|)
block|{
name|unallocated
operator|=
name|PAGE_SIZE
operator|/
sizeof|sizeof
argument_list|(
name|tag_t
argument_list|)
expr_stmt|;
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_tag
index|]
operator|.
name|cur_page
operator|=
name|cur_page
operator|=
name|allocate_page
argument_list|()
expr_stmt|;
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_tag
index|]
operator|.
name|total_pages
operator|++
expr_stmt|;
block|}
name|ptr
operator|=
operator|&
name|cur_page
operator|->
name|tag
index|[
operator|--
name|unallocated
index|]
expr_stmt|;
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_tag
index|]
operator|.
name|unallocated
operator|=
name|unallocated
expr_stmt|;
block|}
else|#
directive|else
name|ptr
operator|=
operator|(
name|tag_t
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|tag_t
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_tag
index|]
operator|.
name|total_alloc
operator|++
expr_stmt|;
operator|*
name|ptr
operator|=
name|initial_tag
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_comment
comment|/* Free scoping information.  */
end_comment

begin_function
name|STATIC
name|void
name|free_tag
parameter_list|(
name|ptr
parameter_list|)
name|tag_t
modifier|*
name|ptr
decl_stmt|;
block|{
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_tag
index|]
operator|.
name|total_free
operator|++
expr_stmt|;
ifndef|#
directive|ifndef
name|MALLOC_CHECK
name|ptr
operator|->
name|free
operator|=
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_tag
index|]
operator|.
name|free_list
operator|.
name|f_tag
expr_stmt|;
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_tag
index|]
operator|.
name|free_list
operator|.
name|f_tag
operator|=
name|ptr
expr_stmt|;
else|#
directive|else
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|ptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Allocate forward reference to a yet unknown tag.  */
end_comment

begin_function
name|STATIC
name|forward_t
modifier|*
name|allocate_forward
parameter_list|()
block|{
name|forward_t
modifier|*
name|ptr
decl_stmt|;
specifier|static
name|forward_t
name|initial_forward
decl_stmt|;
ifndef|#
directive|ifndef
name|MALLOC_CHECK
name|ptr
operator|=
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_forward
index|]
operator|.
name|free_list
operator|.
name|f_forward
expr_stmt|;
if|if
condition|(
name|ptr
operator|!=
operator|(
name|forward_t
operator|*
operator|)
literal|0
condition|)
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_forward
index|]
operator|.
name|free_list
operator|.
name|f_forward
operator|=
name|ptr
operator|->
name|free
expr_stmt|;
else|else
block|{
name|int
name|unallocated
init|=
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_forward
index|]
operator|.
name|unallocated
decl_stmt|;
name|page_t
modifier|*
name|cur_page
init|=
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_forward
index|]
operator|.
name|cur_page
decl_stmt|;
if|if
condition|(
name|unallocated
operator|==
literal|0
condition|)
block|{
name|unallocated
operator|=
name|PAGE_SIZE
operator|/
sizeof|sizeof
argument_list|(
name|forward_t
argument_list|)
expr_stmt|;
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_forward
index|]
operator|.
name|cur_page
operator|=
name|cur_page
operator|=
name|allocate_page
argument_list|()
expr_stmt|;
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_forward
index|]
operator|.
name|total_pages
operator|++
expr_stmt|;
block|}
name|ptr
operator|=
operator|&
name|cur_page
operator|->
name|forward
index|[
operator|--
name|unallocated
index|]
expr_stmt|;
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_forward
index|]
operator|.
name|unallocated
operator|=
name|unallocated
expr_stmt|;
block|}
else|#
directive|else
name|ptr
operator|=
operator|(
name|forward_t
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|forward_t
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_forward
index|]
operator|.
name|total_alloc
operator|++
expr_stmt|;
operator|*
name|ptr
operator|=
name|initial_forward
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_comment
comment|/* Free scoping information.  */
end_comment

begin_function
name|STATIC
name|void
name|free_forward
parameter_list|(
name|ptr
parameter_list|)
name|forward_t
modifier|*
name|ptr
decl_stmt|;
block|{
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_forward
index|]
operator|.
name|total_free
operator|++
expr_stmt|;
ifndef|#
directive|ifndef
name|MALLOC_CHECK
name|ptr
operator|->
name|free
operator|=
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_forward
index|]
operator|.
name|free_list
operator|.
name|f_forward
expr_stmt|;
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_forward
index|]
operator|.
name|free_list
operator|.
name|f_forward
operator|=
name|ptr
expr_stmt|;
else|#
directive|else
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|ptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Allocate head of type hash list.  */
end_comment

begin_function
name|STATIC
name|thead_t
modifier|*
name|allocate_thead
parameter_list|()
block|{
name|thead_t
modifier|*
name|ptr
decl_stmt|;
specifier|static
name|thead_t
name|initial_thead
decl_stmt|;
ifndef|#
directive|ifndef
name|MALLOC_CHECK
name|ptr
operator|=
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_thead
index|]
operator|.
name|free_list
operator|.
name|f_thead
expr_stmt|;
if|if
condition|(
name|ptr
operator|!=
operator|(
name|thead_t
operator|*
operator|)
literal|0
condition|)
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_thead
index|]
operator|.
name|free_list
operator|.
name|f_thead
operator|=
name|ptr
operator|->
name|free
expr_stmt|;
else|else
block|{
name|int
name|unallocated
init|=
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_thead
index|]
operator|.
name|unallocated
decl_stmt|;
name|page_t
modifier|*
name|cur_page
init|=
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_thead
index|]
operator|.
name|cur_page
decl_stmt|;
if|if
condition|(
name|unallocated
operator|==
literal|0
condition|)
block|{
name|unallocated
operator|=
name|PAGE_SIZE
operator|/
sizeof|sizeof
argument_list|(
name|thead_t
argument_list|)
expr_stmt|;
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_thead
index|]
operator|.
name|cur_page
operator|=
name|cur_page
operator|=
name|allocate_page
argument_list|()
expr_stmt|;
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_thead
index|]
operator|.
name|total_pages
operator|++
expr_stmt|;
block|}
name|ptr
operator|=
operator|&
name|cur_page
operator|->
name|thead
index|[
operator|--
name|unallocated
index|]
expr_stmt|;
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_thead
index|]
operator|.
name|unallocated
operator|=
name|unallocated
expr_stmt|;
block|}
else|#
directive|else
name|ptr
operator|=
operator|(
name|thead_t
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|thead_t
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_thead
index|]
operator|.
name|total_alloc
operator|++
expr_stmt|;
operator|*
name|ptr
operator|=
name|initial_thead
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_comment
comment|/* Free scoping information.  */
end_comment

begin_function
name|STATIC
name|void
name|free_thead
parameter_list|(
name|ptr
parameter_list|)
name|thead_t
modifier|*
name|ptr
decl_stmt|;
block|{
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_thead
index|]
operator|.
name|total_free
operator|++
expr_stmt|;
ifndef|#
directive|ifndef
name|MALLOC_CHECK
name|ptr
operator|->
name|free
operator|=
operator|(
name|thead_t
operator|*
operator|)
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_thead
index|]
operator|.
name|free_list
operator|.
name|f_thead
expr_stmt|;
name|alloc_counts
index|[
operator|(
name|int
operator|)
name|alloc_type_thead
index|]
operator|.
name|free_list
operator|.
name|f_thead
operator|=
name|ptr
expr_stmt|;
else|#
directive|else
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|ptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MIPS_DEBUGGING_INFO */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Output an error message and exit */
end_comment

begin_comment
comment|/*VARARGS*/
end_comment

begin_decl_stmt
name|void
name|fatal
name|VPARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|format
operator|,
operator|...
operator|)
argument_list|)
block|{
name|VA_OPEN
argument_list|(
name|ap
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
name|format
argument_list|)
expr_stmt|;
if|if
condition|(
name|line_number
operator|>
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s, %s:%ld "
argument_list|,
name|progname
argument_list|,
name|input_name
argument_list|,
name|line_number
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|format
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|VA_CLOSE
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|line_number
operator|>
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"line:\t%s\n"
argument_list|,
name|cur_line_start
argument_list|)
expr_stmt|;
name|saber_stop
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/*VARARGS*/
end_comment

begin_decl_stmt
name|void
name|error
name|VPARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|format
operator|,
operator|...
operator|)
argument_list|)
block|{
name|VA_OPEN
argument_list|(
name|ap
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
name|char
operator|*
argument_list|,
name|format
argument_list|)
expr_stmt|;
if|if
condition|(
name|line_number
operator|>
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s, %s:%ld "
argument_list|,
name|progname
argument_list|,
name|input_name
argument_list|,
name|line_number
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|format
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|line_number
operator|>
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"line:\t%s\n"
argument_list|,
name|cur_line_start
argument_list|)
expr_stmt|;
name|had_errors
operator|++
expr_stmt|;
name|VA_CLOSE
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|saber_stop
argument_list|()
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* More 'friendly' abort that prints the line and file.    config.h can #define abort fancy_abort if you like that sort of thing.  */
end_comment

begin_function
name|void
name|fancy_abort
parameter_list|()
block|{
name|fatal
argument_list|(
literal|"internal abort"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* When `malloc.c' is compiled with `rcheck' defined,    it calls this function to report clobberage.  */
end_comment

begin_function
name|void
name|botch
parameter_list|(
name|s
parameter_list|)
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|fatal
argument_list|(
literal|"%s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

