begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Perform various loop optimizations, including strength reduction.    Copyright (C) 1987, 1988, 1989, 1991, 1992, 1993, 1994, 1995, 1996, 1997,    1998, 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* This is the loop optimization pass of the compiler.    It finds invariant computations within loops and moves them    to the beginning of the loop.  Then it identifies basic and    general induction variables.  Strength reduction is applied to the general    induction variables, and induction variable elimination is applied to    the basic induction variables.     It also finds cases where    a register is set within the loop by zero-extending a narrower value    and changes these to zero the entire register once before the loop    and merely copy the low part within the loop.     Most of the complexity is in heuristics to decide when it is worth    while to do these things.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"loop.h"
end_include

begin_include
include|#
directive|include
file|"cselib.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"predict.h"
end_include

begin_include
include|#
directive|include
file|"insn-flags.h"
end_include

begin_include
include|#
directive|include
file|"optabs.h"
end_include

begin_comment
comment|/* Not really meaningful values, but at least something.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SIMULTANEOUS_PREFETCHES
end_ifndef

begin_define
define|#
directive|define
name|SIMULTANEOUS_PREFETCHES
value|3
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PREFETCH_BLOCK
end_ifndef

begin_define
define|#
directive|define
name|PREFETCH_BLOCK
value|32
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_prefetch
end_ifndef

begin_define
define|#
directive|define
name|HAVE_prefetch
value|0
end_define

begin_define
define|#
directive|define
name|CODE_FOR_prefetch
value|0
end_define

begin_define
define|#
directive|define
name|gen_prefetch
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
value|(abort(), NULL_RTX)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Give up the prefetch optimizations once we exceed a given threshhold.    It is unlikely that we would be able to optimize something in a loop    with so many detected prefetches.  */
end_comment

begin_define
define|#
directive|define
name|MAX_PREFETCHES
value|100
end_define

begin_comment
comment|/* The number of prefetch blocks that are beneficial to fetch at once before    a loop with a known (and low) iteration count.  */
end_comment

begin_define
define|#
directive|define
name|PREFETCH_BLOCKS_BEFORE_LOOP_MAX
value|6
end_define

begin_comment
comment|/* For very tiny loops it is not worthwhile to prefetch even before the loop,    since it is likely that the data are already in the cache.  */
end_comment

begin_define
define|#
directive|define
name|PREFETCH_BLOCKS_BEFORE_LOOP_MIN
value|2
end_define

begin_comment
comment|/* Parameterize some prefetch heuristics so they can be turned on and off    easily for performance testing on new architecures.  These can be    defined in target-dependent files.  */
end_comment

begin_comment
comment|/* Prefetch is worthwhile only when loads/stores are dense.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|PREFETCH_ONLY_DENSE_MEM
end_ifndef

begin_define
define|#
directive|define
name|PREFETCH_ONLY_DENSE_MEM
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Define what we mean by "dense" loads and stores; This value divided by 256    is the minimum percentage of memory references that worth prefetching.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|PREFETCH_DENSE_MEM
end_ifndef

begin_define
define|#
directive|define
name|PREFETCH_DENSE_MEM
value|220
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Do not prefetch for a loop whose iteration count is known to be low.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|PREFETCH_NO_LOW_LOOPCNT
end_ifndef

begin_define
define|#
directive|define
name|PREFETCH_NO_LOW_LOOPCNT
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Define what we mean by a "low" iteration count.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|PREFETCH_LOW_LOOPCNT
end_ifndef

begin_define
define|#
directive|define
name|PREFETCH_LOW_LOOPCNT
value|32
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Do not prefetch for a loop that contains a function call; such a loop is    probably not an internal loop.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|PREFETCH_NO_CALL
end_ifndef

begin_define
define|#
directive|define
name|PREFETCH_NO_CALL
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Do not prefetch accesses with an extreme stride.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|PREFETCH_NO_EXTREME_STRIDE
end_ifndef

begin_define
define|#
directive|define
name|PREFETCH_NO_EXTREME_STRIDE
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Define what we mean by an "extreme" stride.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|PREFETCH_EXTREME_STRIDE
end_ifndef

begin_define
define|#
directive|define
name|PREFETCH_EXTREME_STRIDE
value|4096
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Define a limit to how far apart indices can be and still be merged    into a single prefetch.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|PREFETCH_EXTREME_DIFFERENCE
end_ifndef

begin_define
define|#
directive|define
name|PREFETCH_EXTREME_DIFFERENCE
value|4096
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Issue prefetch instructions before the loop to fetch data to be used    in the first few loop iterations.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|PREFETCH_BEFORE_LOOP
end_ifndef

begin_define
define|#
directive|define
name|PREFETCH_BEFORE_LOOP
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Do not handle reversed order prefetches (negative stride).  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|PREFETCH_NO_REVERSE_ORDER
end_ifndef

begin_define
define|#
directive|define
name|PREFETCH_NO_REVERSE_ORDER
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Prefetch even if the GIV is in conditional code.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|PREFETCH_CONDITIONAL
end_ifndef

begin_define
define|#
directive|define
name|PREFETCH_CONDITIONAL
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|LOOP_REG_LIFETIME
parameter_list|(
name|LOOP
parameter_list|,
name|REGNO
parameter_list|)
define|\
value|((REGNO_LAST_LUID (REGNO) - REGNO_FIRST_LUID (REGNO)))
end_define

begin_define
define|#
directive|define
name|LOOP_REG_GLOBAL_P
parameter_list|(
name|LOOP
parameter_list|,
name|REGNO
parameter_list|)
define|\
value|((REGNO_LAST_LUID (REGNO)> INSN_LUID ((LOOP)->end) \  || REGNO_FIRST_LUID (REGNO)< INSN_LUID ((LOOP)->start)))
end_define

begin_define
define|#
directive|define
name|LOOP_REGNO_NREGS
parameter_list|(
name|REGNO
parameter_list|,
name|SET_DEST
parameter_list|)
define|\
value|((REGNO)< FIRST_PSEUDO_REGISTER \  ? (int) HARD_REGNO_NREGS ((REGNO), GET_MODE (SET_DEST)) : 1)
end_define

begin_comment
comment|/* Vector mapping INSN_UIDs to luids.    The luids are like uids but increase monotonically always.    We use them to see whether a jump comes from outside a given loop.  */
end_comment

begin_decl_stmt
name|int
modifier|*
name|uid_luid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by INSN_UID, contains the ordinal giving the (innermost) loop    number the insn is contained in.  */
end_comment

begin_decl_stmt
name|struct
name|loop
modifier|*
modifier|*
name|uid_loop
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 + largest uid of any insn.  */
end_comment

begin_decl_stmt
name|int
name|max_uid_for_loop
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 + luid of last insn.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|max_luid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of loops detected in current function.  Used as index to the    next few tables.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|max_loop_num
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Bound on pseudo register number before loop optimization.    A pseudo has valid regscan info if its number is< max_reg_before_loop.  */
end_comment

begin_decl_stmt
name|unsigned
name|int
name|max_reg_before_loop
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The value to pass to the next call of reg_scan_update.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|loop_max_reg
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* During the analysis of a loop, a chain of `struct movable's    is made to record all the movable insns found.    Then the entire chain can be scanned to decide which to move.  */
end_comment

begin_struct
struct|struct
name|movable
block|{
name|rtx
name|insn
decl_stmt|;
comment|/* A movable insn */
name|rtx
name|set_src
decl_stmt|;
comment|/* The expression this reg is set from.  */
name|rtx
name|set_dest
decl_stmt|;
comment|/* The destination of this SET.  */
name|rtx
name|dependencies
decl_stmt|;
comment|/* When INSN is libcall, this is an EXPR_LIST 				   of any registers used within the LIBCALL.  */
name|int
name|consec
decl_stmt|;
comment|/* Number of consecutive following insns 				   that must be moved with this one.  */
name|unsigned
name|int
name|regno
decl_stmt|;
comment|/* The register it sets */
name|short
name|lifetime
decl_stmt|;
comment|/* lifetime of that register; 				   may be adjusted when matching movables 				   that load the same value are found.  */
name|short
name|savings
decl_stmt|;
comment|/* Number of insns we can move for this reg, 				   including other movables that force this 				   or match this one.  */
name|unsigned
name|int
name|cond
range|:
literal|1
decl_stmt|;
comment|/* 1 if only conditionally movable */
name|unsigned
name|int
name|force
range|:
literal|1
decl_stmt|;
comment|/* 1 means MUST move this insn */
name|unsigned
name|int
name|global
range|:
literal|1
decl_stmt|;
comment|/* 1 means reg is live outside this loop */
comment|/* If PARTIAL is 1, GLOBAL means something different: 		   that the reg is live outside the range from where it is set 		   to the following label.  */
name|unsigned
name|int
name|done
range|:
literal|1
decl_stmt|;
comment|/* 1 inhibits further processing of this */
name|unsigned
name|int
name|partial
range|:
literal|1
decl_stmt|;
comment|/* 1 means this reg is used for zero-extending. 				   In particular, moving it does not make it 				   invariant.  */
name|unsigned
name|int
name|move_insn
range|:
literal|1
decl_stmt|;
comment|/* 1 means that we call emit_move_insn to 				   load SRC, rather than copying INSN.  */
name|unsigned
name|int
name|move_insn_first
range|:
literal|1
decl_stmt|;
comment|/* Same as above, if this is necessary for the 				    first insn of a consecutive sets group.  */
name|unsigned
name|int
name|is_equiv
range|:
literal|1
decl_stmt|;
comment|/* 1 means a REG_EQUIV is present on INSN.  */
name|enum
name|machine_mode
name|savemode
decl_stmt|;
comment|/* Nonzero means it is a mode for a low part 				   that we should avoid changing when clearing 				   the rest of the reg.  */
name|struct
name|movable
modifier|*
name|match
decl_stmt|;
comment|/* First entry for same value */
name|struct
name|movable
modifier|*
name|forces
decl_stmt|;
comment|/* An insn that must be moved if this is */
name|struct
name|movable
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|FILE
modifier|*
name|loop_dump_stream
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forward declarations.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|invalidate_loops_containing_label
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|find_and_verify_loops
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
expr|struct
name|loops
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mark_loop_jump
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
expr|struct
name|loop
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|prescan_loop
name|PARAMS
argument_list|(
operator|(
expr|struct
name|loop
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|reg_in_basic_block_p
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|consec_sets_invariant_p
name|PARAMS
argument_list|(
operator|(
specifier|const
expr|struct
name|loop
operator|*
operator|,
name|rtx
operator|,
name|int
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|labels_in_range_p
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|count_one_set
name|PARAMS
argument_list|(
operator|(
expr|struct
name|loop_regs
operator|*
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|note_addr_stored
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|note_set_pseudo_multiple_uses
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|loop_reg_used_before_p
name|PARAMS
argument_list|(
operator|(
specifier|const
expr|struct
name|loop
operator|*
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|scan_loop
name|PARAMS
argument_list|(
operator|(
expr|struct
name|loop
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static void replace_call_address PARAMS ((rtx, rtx, rtx));
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|rtx
name|skip_consec_insns
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|libcall_benefit
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ignore_some_movables
name|PARAMS
argument_list|(
operator|(
expr|struct
name|loop_movables
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|force_movables
name|PARAMS
argument_list|(
operator|(
expr|struct
name|loop_movables
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|combine_movables
name|PARAMS
argument_list|(
operator|(
expr|struct
name|loop_movables
operator|*
operator|,
expr|struct
name|loop_regs
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|num_unmoved_movables
name|PARAMS
argument_list|(
operator|(
specifier|const
expr|struct
name|loop
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|regs_match_p
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
expr|struct
name|loop_movables
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|rtx_equal_for_loop_p
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
expr|struct
name|loop_movables
operator|*
operator|,
expr|struct
name|loop_regs
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_label_notes
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|move_movables
name|PARAMS
argument_list|(
operator|(
expr|struct
name|loop
operator|*
name|loop
operator|,
expr|struct
name|loop_movables
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|loop_movables_add
name|PARAMS
argument_list|(
operator|(
expr|struct
name|loop_movables
operator|*
operator|,
expr|struct
name|movable
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|loop_movables_free
name|PARAMS
argument_list|(
operator|(
expr|struct
name|loop_movables
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|count_nonfixed_reads
name|PARAMS
argument_list|(
operator|(
specifier|const
expr|struct
name|loop
operator|*
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|loop_bivs_find
name|PARAMS
argument_list|(
operator|(
expr|struct
name|loop
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|loop_bivs_init_find
name|PARAMS
argument_list|(
operator|(
expr|struct
name|loop
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|loop_bivs_check
name|PARAMS
argument_list|(
operator|(
expr|struct
name|loop
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|loop_givs_find
name|PARAMS
argument_list|(
operator|(
expr|struct
name|loop
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|loop_givs_check
name|PARAMS
argument_list|(
operator|(
expr|struct
name|loop
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|loop_biv_eliminable_p
name|PARAMS
argument_list|(
operator|(
expr|struct
name|loop
operator|*
operator|,
expr|struct
name|iv_class
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|loop_giv_reduce_benefit
name|PARAMS
argument_list|(
operator|(
expr|struct
name|loop
operator|*
operator|,
expr|struct
name|iv_class
operator|*
operator|,
expr|struct
name|induction
operator|*
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|loop_givs_dead_check
name|PARAMS
argument_list|(
operator|(
expr|struct
name|loop
operator|*
operator|,
expr|struct
name|iv_class
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|loop_givs_reduce
name|PARAMS
argument_list|(
operator|(
expr|struct
name|loop
operator|*
operator|,
expr|struct
name|iv_class
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|loop_givs_rescan
name|PARAMS
argument_list|(
operator|(
expr|struct
name|loop
operator|*
operator|,
expr|struct
name|iv_class
operator|*
operator|,
name|rtx
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|loop_ivs_free
name|PARAMS
argument_list|(
operator|(
expr|struct
name|loop
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|strength_reduce
name|PARAMS
argument_list|(
operator|(
expr|struct
name|loop
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|find_single_use_in_loop
name|PARAMS
argument_list|(
operator|(
expr|struct
name|loop_regs
operator|*
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|valid_initial_value_p
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|int
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|find_mem_givs
name|PARAMS
argument_list|(
operator|(
specifier|const
expr|struct
name|loop
operator|*
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|record_biv
name|PARAMS
argument_list|(
operator|(
expr|struct
name|loop
operator|*
operator|,
expr|struct
name|induction
operator|*
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|check_final_value
name|PARAMS
argument_list|(
operator|(
specifier|const
expr|struct
name|loop
operator|*
operator|,
expr|struct
name|induction
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|loop_ivs_dump
name|PARAMS
argument_list|(
operator|(
specifier|const
expr|struct
name|loop
operator|*
operator|,
name|FILE
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|loop_iv_class_dump
name|PARAMS
argument_list|(
operator|(
specifier|const
expr|struct
name|iv_class
operator|*
operator|,
name|FILE
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|loop_biv_dump
name|PARAMS
argument_list|(
operator|(
specifier|const
expr|struct
name|induction
operator|*
operator|,
name|FILE
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|loop_giv_dump
name|PARAMS
argument_list|(
operator|(
specifier|const
expr|struct
name|induction
operator|*
operator|,
name|FILE
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|record_giv
name|PARAMS
argument_list|(
operator|(
specifier|const
expr|struct
name|loop
operator|*
operator|,
expr|struct
name|induction
operator|*
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|int
operator|,
expr|enum
name|g_types
operator|,
name|int
operator|,
name|int
operator|,
name|rtx
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|update_giv_derive
name|PARAMS
argument_list|(
operator|(
specifier|const
expr|struct
name|loop
operator|*
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|check_ext_dependent_givs
name|PARAMS
argument_list|(
operator|(
expr|struct
name|iv_class
operator|*
operator|,
expr|struct
name|loop_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|basic_induction_var
name|PARAMS
argument_list|(
operator|(
specifier|const
expr|struct
name|loop
operator|*
operator|,
name|rtx
operator|,
expr|enum
name|machine_mode
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|*
operator|,
name|rtx
operator|*
operator|,
name|rtx
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|simplify_giv_expr
name|PARAMS
argument_list|(
operator|(
specifier|const
expr|struct
name|loop
operator|*
operator|,
name|rtx
operator|,
name|rtx
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|general_induction_var
name|PARAMS
argument_list|(
operator|(
specifier|const
expr|struct
name|loop
operator|*
name|loop
operator|,
name|rtx
operator|,
name|rtx
operator|*
operator|,
name|rtx
operator|*
operator|,
name|rtx
operator|*
operator|,
name|rtx
operator|*
operator|,
name|int
operator|,
name|int
operator|*
operator|,
expr|enum
name|machine_mode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|consec_sets_giv
name|PARAMS
argument_list|(
operator|(
specifier|const
expr|struct
name|loop
operator|*
operator|,
name|int
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|*
operator|,
name|rtx
operator|*
operator|,
name|rtx
operator|*
operator|,
name|rtx
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|check_dbra_loop
name|PARAMS
argument_list|(
operator|(
expr|struct
name|loop
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|express_from_1
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|combine_givs_p
name|PARAMS
argument_list|(
operator|(
expr|struct
name|induction
operator|*
operator|,
expr|struct
name|induction
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cmp_combine_givs_stats
name|PARAMS
argument_list|(
operator|(
specifier|const
name|PTR
operator|,
specifier|const
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|combine_givs
name|PARAMS
argument_list|(
operator|(
expr|struct
name|loop_regs
operator|*
operator|,
expr|struct
name|iv_class
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|product_cheap_p
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|maybe_eliminate_biv
name|PARAMS
argument_list|(
operator|(
specifier|const
expr|struct
name|loop
operator|*
operator|,
expr|struct
name|iv_class
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|maybe_eliminate_biv_1
name|PARAMS
argument_list|(
operator|(
specifier|const
expr|struct
name|loop
operator|*
operator|,
name|rtx
operator|,
name|rtx
operator|,
expr|struct
name|iv_class
operator|*
operator|,
name|int
operator|,
name|basic_block
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|last_use_this_basic_block
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|record_initial
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|update_reg_last_use
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|next_insn_in_loop
name|PARAMS
argument_list|(
operator|(
specifier|const
expr|struct
name|loop
operator|*
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|loop_regs_scan
name|PARAMS
argument_list|(
operator|(
specifier|const
expr|struct
name|loop
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|count_insns_in_loop
name|PARAMS
argument_list|(
operator|(
specifier|const
expr|struct
name|loop
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|find_mem_in_note_1
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|find_mem_in_note
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|load_mems
name|PARAMS
argument_list|(
operator|(
specifier|const
expr|struct
name|loop
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|insert_loop_mem
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|replace_loop_mem
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|replace_loop_mems
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|replace_loop_reg
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|replace_loop_regs
name|PARAMS
argument_list|(
operator|(
name|rtx
name|insn
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|note_reg_stored
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|try_copy_prop
name|PARAMS
argument_list|(
operator|(
specifier|const
expr|struct
name|loop
operator|*
operator|,
name|rtx
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|try_swap_copy_prop
name|PARAMS
argument_list|(
operator|(
specifier|const
expr|struct
name|loop
operator|*
operator|,
name|rtx
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|replace_label
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|check_insn_for_givs
name|PARAMS
argument_list|(
operator|(
expr|struct
name|loop
operator|*
operator|,
name|rtx
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|check_insn_for_bivs
name|PARAMS
argument_list|(
operator|(
expr|struct
name|loop
operator|*
operator|,
name|rtx
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|gen_add_mult
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|loop_regs_update
name|PARAMS
argument_list|(
operator|(
specifier|const
expr|struct
name|loop
operator|*
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|iv_add_mult_cost
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|loop_insn_emit_after
name|PARAMS
argument_list|(
operator|(
specifier|const
expr|struct
name|loop
operator|*
operator|,
name|basic_block
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|loop_call_insn_emit_before
name|PARAMS
argument_list|(
operator|(
specifier|const
expr|struct
name|loop
operator|*
operator|,
name|basic_block
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|loop_call_insn_hoist
name|PARAMS
argument_list|(
operator|(
specifier|const
expr|struct
name|loop
operator|*
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|loop_insn_sink_or_swim
name|PARAMS
argument_list|(
operator|(
specifier|const
expr|struct
name|loop
operator|*
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|loop_dump_aux
name|PARAMS
argument_list|(
operator|(
specifier|const
expr|struct
name|loop
operator|*
operator|,
name|FILE
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|loop_delete_insns
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|HOST_WIDE_INT
name|remove_constant_addition
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|gen_load_of_final_value
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|debug_ivs
name|PARAMS
argument_list|(
operator|(
specifier|const
expr|struct
name|loop
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|debug_iv_class
name|PARAMS
argument_list|(
operator|(
specifier|const
expr|struct
name|iv_class
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|debug_biv
name|PARAMS
argument_list|(
operator|(
specifier|const
expr|struct
name|induction
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|debug_giv
name|PARAMS
argument_list|(
operator|(
specifier|const
expr|struct
name|induction
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|debug_loop
name|PARAMS
argument_list|(
operator|(
specifier|const
expr|struct
name|loop
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|debug_loops
name|PARAMS
argument_list|(
operator|(
specifier|const
expr|struct
name|loops
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
name|rtx_pair
block|{
name|rtx
name|r1
decl_stmt|;
name|rtx
name|r2
decl_stmt|;
block|}
name|rtx_pair
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|loop_replace_args
block|{
name|rtx
name|match
decl_stmt|;
name|rtx
name|replacement
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|}
name|loop_replace_args
typedef|;
end_typedef

begin_comment
comment|/* Nonzero iff INSN is between START and END, inclusive.  */
end_comment

begin_define
define|#
directive|define
name|INSN_IN_RANGE_P
parameter_list|(
name|INSN
parameter_list|,
name|START
parameter_list|,
name|END
parameter_list|)
define|\
value|(INSN_UID (INSN)< max_uid_for_loop		\&& INSN_LUID (INSN)>= INSN_LUID (START)	\&& INSN_LUID (INSN)<= INSN_LUID (END))
end_define

begin_comment
comment|/* Indirect_jump_in_function is computed once per function.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|indirect_jump_in_function
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|indirect_jump_in_function_p
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|compute_luids
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|biv_elimination_giv_has_0_offset
name|PARAMS
argument_list|(
operator|(
expr|struct
name|induction
operator|*
operator|,
expr|struct
name|induction
operator|*
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Benefit penalty, if a giv is not replaceable, i.e. must emit an insn to    copy the value of the strength reduced giv to its original register.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|copy_cost
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Cost of using a register, to normalize the benefits of a giv.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|reg_address_cost
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|init_loop
parameter_list|()
block|{
name|rtx
name|reg
init|=
name|gen_rtx_REG
argument_list|(
name|word_mode
argument_list|,
name|LAST_VIRTUAL_REGISTER
operator|+
literal|1
argument_list|)
decl_stmt|;
name|reg_address_cost
operator|=
name|address_cost
argument_list|(
name|reg
argument_list|,
name|SImode
argument_list|)
expr_stmt|;
name|copy_cost
operator|=
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Compute the mapping from uids to luids.    LUIDs are numbers assigned to insns, like uids,    except that luids increase monotonically through the code.    Start at insn START and stop just before END.  Assign LUIDs    starting with PREV_LUID + 1.  Return the last assigned LUID + 1.  */
end_comment

begin_function
specifier|static
name|int
name|compute_luids
parameter_list|(
name|start
parameter_list|,
name|end
parameter_list|,
name|prev_luid
parameter_list|)
name|rtx
name|start
decl_stmt|,
name|end
decl_stmt|;
name|int
name|prev_luid
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|start
operator|,
name|i
operator|=
name|prev_luid
init|;
name|insn
operator|!=
name|end
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|INSN_UID
argument_list|(
name|insn
argument_list|)
operator|>=
name|max_uid_for_loop
condition|)
continue|continue;
comment|/* Don't assign luids to line-number NOTEs, so that the distance in 	 luids between two insns is not affected by -g.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE
operator|||
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|<=
literal|0
condition|)
name|uid_luid
index|[
name|INSN_UID
argument_list|(
name|insn
argument_list|)
index|]
operator|=
operator|++
name|i
expr_stmt|;
else|else
comment|/* Give a line number note the same luid as preceding insn.  */
name|uid_luid
index|[
name|INSN_UID
argument_list|(
name|insn
argument_list|)
index|]
operator|=
name|i
expr_stmt|;
block|}
return|return
name|i
operator|+
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Entry point of this file.  Perform loop optimization    on the current function.  F is the first insn of the function    and DUMPFILE is a stream for output of a trace of actions taken    (or 0 if none should be output).  */
end_comment

begin_function
name|void
name|loop_optimize
parameter_list|(
name|f
parameter_list|,
name|dumpfile
parameter_list|,
name|flags
parameter_list|)
comment|/* f is the first instruction of a chain of insns for one function */
name|rtx
name|f
decl_stmt|;
name|FILE
modifier|*
name|dumpfile
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|loops
name|loops_data
decl_stmt|;
name|struct
name|loops
modifier|*
name|loops
init|=
operator|&
name|loops_data
decl_stmt|;
name|struct
name|loop_info
modifier|*
name|loops_info
decl_stmt|;
name|loop_dump_stream
operator|=
name|dumpfile
expr_stmt|;
name|init_recog_no_volatile
argument_list|()
expr_stmt|;
name|max_reg_before_loop
operator|=
name|max_reg_num
argument_list|()
expr_stmt|;
name|loop_max_reg
operator|=
name|max_reg_before_loop
expr_stmt|;
name|regs_may_share
operator|=
literal|0
expr_stmt|;
comment|/* Count the number of loops.  */
name|max_loop_num
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|f
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_LOOP_BEG
condition|)
name|max_loop_num
operator|++
expr_stmt|;
block|}
comment|/* Don't waste time if no loops.  */
if|if
condition|(
name|max_loop_num
operator|==
literal|0
condition|)
return|return;
name|loops
operator|->
name|num
operator|=
name|max_loop_num
expr_stmt|;
comment|/* Get size to use for tables indexed by uids.      Leave some space for labels allocated by find_and_verify_loops.  */
name|max_uid_for_loop
operator|=
name|get_max_uid
argument_list|()
operator|+
literal|1
operator|+
name|max_loop_num
operator|*
literal|32
expr_stmt|;
name|uid_luid
operator|=
operator|(
name|int
operator|*
operator|)
name|xcalloc
argument_list|(
name|max_uid_for_loop
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|uid_loop
operator|=
operator|(
expr|struct
name|loop
operator|*
operator|*
operator|)
name|xcalloc
argument_list|(
name|max_uid_for_loop
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|loop
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Allocate storage for array of loops.  */
name|loops
operator|->
name|array
operator|=
operator|(
expr|struct
name|loop
operator|*
operator|)
name|xcalloc
argument_list|(
name|loops
operator|->
name|num
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|loop
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Find and process each loop.      First, find them, and record them in order of their beginnings.  */
name|find_and_verify_loops
argument_list|(
name|f
argument_list|,
name|loops
argument_list|)
expr_stmt|;
comment|/* Allocate and initialize auxiliary loop information.  */
name|loops_info
operator|=
name|xcalloc
argument_list|(
name|loops
operator|->
name|num
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|loop_info
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|loops
operator|->
name|num
condition|;
name|i
operator|++
control|)
name|loops
operator|->
name|array
index|[
name|i
index|]
operator|.
name|aux
operator|=
name|loops_info
operator|+
name|i
expr_stmt|;
comment|/* Now find all register lifetimes.  This must be done after      find_and_verify_loops, because it might reorder the insns in the      function.  */
name|reg_scan
argument_list|(
name|f
argument_list|,
name|max_reg_before_loop
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* This must occur after reg_scan so that registers created by gcse      will have entries in the register tables.       We could have added a call to reg_scan after gcse_main in toplev.c,      but moving this call to init_alias_analysis is more efficient.  */
name|init_alias_analysis
argument_list|()
expr_stmt|;
comment|/* See if we went too far.  Note that get_max_uid already returns      one more that the maximum uid of all insn.  */
if|if
condition|(
name|get_max_uid
argument_list|()
operator|>
name|max_uid_for_loop
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Now reset it to the actual size we need.  See above.  */
name|max_uid_for_loop
operator|=
name|get_max_uid
argument_list|()
expr_stmt|;
comment|/* find_and_verify_loops has already called compute_luids, but it      might have rearranged code afterwards, so we need to recompute      the luids now.  */
name|max_luid
operator|=
name|compute_luids
argument_list|(
name|f
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Don't leave gaps in uid_luid for insns that have been      deleted.  It is possible that the first or last insn      using some register has been deleted by cross-jumping.      Make sure that uid_luid for that former insn's uid      points to the general area where that insn used to be.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_uid_for_loop
condition|;
name|i
operator|++
control|)
block|{
name|uid_luid
index|[
literal|0
index|]
operator|=
name|uid_luid
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|uid_luid
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
break|break;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_uid_for_loop
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|uid_luid
index|[
name|i
index|]
operator|==
literal|0
condition|)
name|uid_luid
index|[
name|i
index|]
operator|=
name|uid_luid
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
comment|/* Determine if the function has indirect jump.  On some systems      this prevents low overhead loop instructions from being used.  */
name|indirect_jump_in_function
operator|=
name|indirect_jump_in_function_p
argument_list|(
name|f
argument_list|)
expr_stmt|;
comment|/* Now scan the loops, last ones first, since this means inner ones are done      before outer ones.  */
for|for
control|(
name|i
operator|=
name|max_loop_num
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|struct
name|loop
modifier|*
name|loop
init|=
operator|&
name|loops
operator|->
name|array
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|loop
operator|->
name|invalid
operator|&&
name|loop
operator|->
name|end
condition|)
name|scan_loop
argument_list|(
name|loop
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
name|end_alias_analysis
argument_list|()
expr_stmt|;
comment|/* Clean up.  */
name|free
argument_list|(
name|uid_luid
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|uid_loop
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|loops_info
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|loops
operator|->
name|array
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Returns the next insn, in execution order, after INSN.  START and    END are the NOTE_INSN_LOOP_BEG and NOTE_INSN_LOOP_END for the loop,    respectively.  LOOP->TOP, if non-NULL, is the top of the loop in the    insn-stream; it is used with loops that are entered near the    bottom.  */
end_comment

begin_function
specifier|static
name|rtx
name|next_insn_in_loop
parameter_list|(
name|loop
parameter_list|,
name|insn
parameter_list|)
specifier|const
name|struct
name|loop
modifier|*
name|loop
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|==
name|loop
operator|->
name|end
condition|)
block|{
if|if
condition|(
name|loop
operator|->
name|top
condition|)
comment|/* Go to the top of the loop, and continue there.  */
name|insn
operator|=
name|loop
operator|->
name|top
expr_stmt|;
else|else
comment|/* We're done.  */
name|insn
operator|=
name|NULL_RTX
expr_stmt|;
block|}
if|if
condition|(
name|insn
operator|==
name|loop
operator|->
name|scan_start
condition|)
comment|/* We're done.  */
name|insn
operator|=
name|NULL_RTX
expr_stmt|;
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Optimize one loop described by LOOP.  */
end_comment

begin_comment
comment|/* ??? Could also move memory writes out of loops if the destination address    is invariant, the source is invariant, the memory write is not volatile,    and if we can prove that no read inside the loop can read this address    before the write occurs.  If there is a read of this address after the    write, then we can also mark the memory read as invariant.  */
end_comment

begin_function
specifier|static
name|void
name|scan_loop
parameter_list|(
name|loop
parameter_list|,
name|flags
parameter_list|)
name|struct
name|loop
modifier|*
name|loop
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|struct
name|loop_info
modifier|*
name|loop_info
init|=
name|LOOP_INFO
argument_list|(
name|loop
argument_list|)
decl_stmt|;
name|struct
name|loop_regs
modifier|*
name|regs
init|=
name|LOOP_REGS
argument_list|(
name|loop
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|rtx
name|loop_start
init|=
name|loop
operator|->
name|start
decl_stmt|;
name|rtx
name|loop_end
init|=
name|loop
operator|->
name|end
decl_stmt|;
name|rtx
name|p
decl_stmt|;
comment|/* 1 if we are scanning insns that could be executed zero times.  */
name|int
name|maybe_never
init|=
literal|0
decl_stmt|;
comment|/* 1 if we are scanning insns that might never be executed      due to a subroutine call which might exit before they are reached.  */
name|int
name|call_passed
init|=
literal|0
decl_stmt|;
comment|/* Jump insn that enters the loop, or 0 if control drops in.  */
name|rtx
name|loop_entry_jump
init|=
literal|0
decl_stmt|;
comment|/* Number of insns in the loop.  */
name|int
name|insn_count
decl_stmt|;
name|int
name|tem
decl_stmt|;
name|rtx
name|temp
decl_stmt|,
name|update_start
decl_stmt|,
name|update_end
decl_stmt|;
comment|/* The SET from an insn, if it is the only SET in the insn.  */
name|rtx
name|set
decl_stmt|,
name|set1
decl_stmt|;
comment|/* Chain describing insns movable in current loop.  */
name|struct
name|loop_movables
modifier|*
name|movables
init|=
name|LOOP_MOVABLES
argument_list|(
name|loop
argument_list|)
decl_stmt|;
comment|/* Ratio of extra register life span we can justify      for saving an instruction.  More if loop doesn't call subroutines      since in that case saving an insn makes more difference      and more registers are available.  */
name|int
name|threshold
decl_stmt|;
comment|/* Nonzero if we are scanning instructions in a sub-loop.  */
name|int
name|loop_depth
init|=
literal|0
decl_stmt|;
name|int
name|in_libcall
decl_stmt|;
name|loop
operator|->
name|top
operator|=
literal|0
expr_stmt|;
name|movables
operator|->
name|head
operator|=
literal|0
expr_stmt|;
name|movables
operator|->
name|last
operator|=
literal|0
expr_stmt|;
comment|/* Determine whether this loop starts with a jump down to a test at      the end.  This will occur for a small number of loops with a test      that is too complex to duplicate in front of the loop.       We search for the first insn or label in the loop, skipping NOTEs.      However, we must be careful not to skip past a NOTE_INSN_LOOP_BEG      (because we might have a loop executed only once that contains a      loop which starts with a jump to its exit test) or a NOTE_INSN_LOOP_END      (in case we have a degenerate loop).       Note that if we mistakenly think that a loop is entered at the top      when, in fact, it is entered at the exit test, the only effect will be      slightly poorer optimization.  Making the opposite error can generate      incorrect code.  Since very few loops now start with a jump to the      exit test, the code here to detect that case is very conservative.  */
for|for
control|(
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|loop_start
argument_list|)
init|;
name|p
operator|!=
name|loop_end
operator|&&
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|!=
name|CODE_LABEL
operator|&&
operator|!
name|INSN_P
argument_list|(
name|p
argument_list|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|!=
name|NOTE
operator|||
operator|(
name|NOTE_LINE_NUMBER
argument_list|(
name|p
argument_list|)
operator|!=
name|NOTE_INSN_LOOP_BEG
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|p
argument_list|)
operator|!=
name|NOTE_INSN_LOOP_END
operator|)
operator|)
condition|;
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
control|)
empty_stmt|;
name|loop
operator|->
name|scan_start
operator|=
name|p
expr_stmt|;
comment|/* If loop end is the end of the current function, then emit a      NOTE_INSN_DELETED after loop_end and set loop->sink to the dummy      note insn.  This is the position we use when sinking insns out of      the loop.  */
if|if
condition|(
name|NEXT_INSN
argument_list|(
name|loop
operator|->
name|end
argument_list|)
operator|!=
literal|0
condition|)
name|loop
operator|->
name|sink
operator|=
name|NEXT_INSN
argument_list|(
name|loop
operator|->
name|end
argument_list|)
expr_stmt|;
else|else
name|loop
operator|->
name|sink
operator|=
name|emit_note_after
argument_list|(
name|NOTE_INSN_DELETED
argument_list|,
name|loop
operator|->
name|end
argument_list|)
expr_stmt|;
comment|/* Set up variables describing this loop.  */
name|prescan_loop
argument_list|(
name|loop
argument_list|)
expr_stmt|;
name|threshold
operator|=
operator|(
name|loop_info
operator|->
name|has_call
condition|?
literal|1
else|:
literal|2
operator|)
operator|*
operator|(
literal|1
operator|+
name|n_non_fixed_regs
operator|)
expr_stmt|;
comment|/* If loop has a jump before the first label,      the true entry is the target of that jump.      Start scan from there.      But record in LOOP->TOP the place where the end-test jumps      back to so we can scan that after the end of the loop.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|JUMP_INSN
condition|)
block|{
name|loop_entry_jump
operator|=
name|p
expr_stmt|;
comment|/* Loop entry must be unconditional jump (and not a RETURN)  */
if|if
condition|(
name|any_uncondjump_p
argument_list|(
name|p
argument_list|)
operator|&&
name|JUMP_LABEL
argument_list|(
name|p
argument_list|)
operator|!=
literal|0
comment|/* Check to see whether the jump actually 	     jumps out of the loop (meaning it's no loop). 	     This case can happen for things like 	     do {..} while (0).  If this label was generated previously 	     by loop, we can't tell anything about it and have to reject 	     the loop.  */
operator|&&
name|INSN_IN_RANGE_P
argument_list|(
name|JUMP_LABEL
argument_list|(
name|p
argument_list|)
argument_list|,
name|loop_start
argument_list|,
name|loop_end
argument_list|)
condition|)
block|{
name|loop
operator|->
name|top
operator|=
name|next_label
argument_list|(
name|loop
operator|->
name|scan_start
argument_list|)
expr_stmt|;
name|loop
operator|->
name|scan_start
operator|=
name|JUMP_LABEL
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If LOOP->SCAN_START was an insn created by loop, we don't know its luid      as required by loop_reg_used_before_p.  So skip such loops.  (This      test may never be true, but it's best to play it safe.)       Also, skip loops where we do not start scanning at a label.  This      test also rejects loops starting with a JUMP_INSN that failed the      test above.  */
if|if
condition|(
name|INSN_UID
argument_list|(
name|loop
operator|->
name|scan_start
argument_list|)
operator|>=
name|max_uid_for_loop
operator|||
name|GET_CODE
argument_list|(
name|loop
operator|->
name|scan_start
argument_list|)
operator|!=
name|CODE_LABEL
condition|)
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"\nLoop from %d to %d is phony.\n\n"
argument_list|,
name|INSN_UID
argument_list|(
name|loop_start
argument_list|)
argument_list|,
name|INSN_UID
argument_list|(
name|loop_end
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Allocate extra space for REGs that might be created by load_mems.      We allocate a little extra slop as well, in the hopes that we      won't have to reallocate the regs array.  */
name|loop_regs_scan
argument_list|(
name|loop
argument_list|,
name|loop_info
operator|->
name|mems_idx
operator|+
literal|16
argument_list|)
expr_stmt|;
name|insn_count
operator|=
name|count_insns_in_loop
argument_list|(
name|loop
argument_list|)
expr_stmt|;
if|if
condition|(
name|loop_dump_stream
condition|)
block|{
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"\nLoop from %d to %d: %d real insns.\n"
argument_list|,
name|INSN_UID
argument_list|(
name|loop_start
argument_list|)
argument_list|,
name|INSN_UID
argument_list|(
name|loop_end
argument_list|)
argument_list|,
name|insn_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|loop
operator|->
name|cont
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Continue at insn %d.\n"
argument_list|,
name|INSN_UID
argument_list|(
name|loop
operator|->
name|cont
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Scan through the loop finding insns that are safe to move.      Set REGS->ARRAY[I].SET_IN_LOOP negative for the reg I being set, so that      this reg will be considered invariant for subsequent insns.      We consider whether subsequent insns use the reg      in deciding whether it is worth actually moving.       MAYBE_NEVER is nonzero if we have passed a conditional jump insn      and therefore it is possible that the insns we are scanning      would never be executed.  At such times, we must make sure      that it is safe to execute the insn once instead of zero times.      When MAYBE_NEVER is 0, all insns will be executed at least once      so that is not a problem.  */
for|for
control|(
name|in_libcall
operator|=
literal|0
operator|,
name|p
operator|=
name|next_insn_in_loop
argument_list|(
name|loop
argument_list|,
name|loop
operator|->
name|scan_start
argument_list|)
init|;
name|p
operator|!=
name|NULL_RTX
condition|;
name|p
operator|=
name|next_insn_in_loop
argument_list|(
name|loop
argument_list|,
name|p
argument_list|)
control|)
block|{
if|if
condition|(
name|in_libcall
operator|&&
name|INSN_P
argument_list|(
name|p
argument_list|)
operator|&&
name|find_reg_note
argument_list|(
name|p
argument_list|,
name|REG_RETVAL
argument_list|,
name|NULL_RTX
argument_list|)
condition|)
name|in_libcall
operator|--
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|INSN
condition|)
block|{
name|temp
operator|=
name|find_reg_note
argument_list|(
name|p
argument_list|,
name|REG_LIBCALL
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
condition|)
name|in_libcall
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|in_libcall
operator|&&
operator|(
name|set
operator|=
name|single_set
argument_list|(
name|p
argument_list|)
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|REG
ifdef|#
directive|ifdef
name|PIC_OFFSET_TABLE_REG_CALL_CLOBBERED
operator|&&
name|SET_DEST
argument_list|(
name|set
argument_list|)
operator|!=
name|pic_offset_table_rtx
endif|#
directive|endif
operator|&&
operator|!
name|regs
operator|->
name|array
index|[
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
index|]
operator|.
name|may_not_optimize
condition|)
block|{
name|int
name|tem1
init|=
literal|0
decl_stmt|;
name|int
name|tem2
init|=
literal|0
decl_stmt|;
name|int
name|move_insn
init|=
literal|0
decl_stmt|;
name|rtx
name|src
init|=
name|SET_SRC
argument_list|(
name|set
argument_list|)
decl_stmt|;
name|rtx
name|dependencies
init|=
literal|0
decl_stmt|;
comment|/* Figure out what to use as a source of this insn.  If a 		 REG_EQUIV note is given or if a REG_EQUAL note with a 		 constant operand is specified, use it as the source and 		 mark that we should move this insn by calling 		 emit_move_insn rather that duplicating the insn.  		 Otherwise, only use the REG_EQUAL contents if a REG_RETVAL 		 note is present.  */
name|temp
operator|=
name|find_reg_note
argument_list|(
name|p
argument_list|,
name|REG_EQUIV
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
condition|)
name|src
operator|=
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
operator|,
name|move_insn
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|temp
operator|=
name|find_reg_note
argument_list|(
name|p
argument_list|,
name|REG_EQUAL
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|&&
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|src
operator|=
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
operator|,
name|move_insn
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|temp
operator|&&
name|find_reg_note
argument_list|(
name|p
argument_list|,
name|REG_RETVAL
argument_list|,
name|NULL_RTX
argument_list|)
condition|)
block|{
name|src
operator|=
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* A libcall block can use regs that don't appear in 			 the equivalent expression.  To move the libcall, 			 we must move those regs too.  */
name|dependencies
operator|=
name|libcall_other_reg
argument_list|(
name|p
argument_list|,
name|src
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* For parallels, add any possible uses to the depencies, as 		 we can't move the insn without resolving them first.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|x
init|=
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|USE
condition|)
name|dependencies
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|dependencies
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Don't try to optimize a MODE_CC set with a constant 		 source.  It probably will be combined with a conditional 		 jump.  */
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
argument_list|)
operator|==
name|MODE_CC
operator|&&
name|CONSTANT_P
argument_list|(
name|src
argument_list|)
condition|)
empty_stmt|;
comment|/* Don't try to optimize a register that was made 		 by loop-optimization for an inner loop. 		 We don't know its life-span, so we can't compute 		 the benefit.  */
elseif|else
if|if
condition|(
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|>=
name|max_reg_before_loop
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
comment|/* The register is used in basic blocks other 			  than the one where it is set (meaning that 			  something after this point in the loop might 			  depend on its value before the set).  */
operator|!
name|reg_in_basic_block_p
argument_list|(
name|p
argument_list|,
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
comment|/* And the set is not guaranteed to be executed once 			  the loop starts, or the value before the set is 			  needed before the set occurs...  			  ??? Note we have quadratic behavior here, mitigated 			  by the fact that the previous test will often fail for 			  large loops.  Rather than re-scanning the entire loop 			  each time for register usage, we should build tables 			  of the register usage and use them here instead.  */
operator|&&
operator|(
name|maybe_never
operator|||
name|loop_reg_used_before_p
argument_list|(
name|loop
argument_list|,
name|set
argument_list|,
name|p
argument_list|)
operator|)
condition|)
comment|/* It is unsafe to move the set.  		   This code used to consider it OK to move a set of a variable 		   which was not created by the user and not used in an exit 		   test. 		   That behavior is incorrect and was removed.  */
empty_stmt|;
elseif|else
if|if
condition|(
operator|(
name|tem
operator|=
name|loop_invariant_p
argument_list|(
name|loop
argument_list|,
name|src
argument_list|)
operator|)
operator|&&
operator|(
name|dependencies
operator|==
literal|0
operator|||
operator|(
name|tem2
operator|=
name|loop_invariant_p
argument_list|(
name|loop
argument_list|,
name|dependencies
argument_list|)
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|regs
operator|->
name|array
index|[
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
index|]
operator|.
name|set_in_loop
operator|==
literal|1
operator|||
operator|(
name|tem1
operator|=
name|consec_sets_invariant_p
argument_list|(
name|loop
argument_list|,
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|,
name|regs
operator|->
name|array
index|[
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
index|]
operator|.
name|set_in_loop
argument_list|,
name|p
argument_list|)
operator|)
operator|)
comment|/* If the insn can cause a trap (such as divide by zero), 			  can't move it unless it's guaranteed to be executed 			  once loop is entered.  Even a function call might 			  prevent the trap insn from being reached 			  (since it might exit!)  */
operator|&&
operator|!
operator|(
operator|(
name|maybe_never
operator|||
name|call_passed
operator|)
operator|&&
name|may_trap_p
argument_list|(
name|src
argument_list|)
operator|)
condition|)
block|{
name|struct
name|movable
modifier|*
name|m
decl_stmt|;
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
decl_stmt|;
comment|/* A potential lossage is where we have a case where two insns 		     can be combined as long as they are both in the loop, but 		     we move one of them outside the loop.  For large loops, 		     this can lose.  The most common case of this is the address 		     of a function being called.  		     Therefore, if this register is marked as being used 		     exactly once if we are in a loop with calls 		     (a "large loop"), see if we can replace the usage of 		     this register with the source of this SET.  If we can, 		     delete this insn.  		     Don't do this if P has a REG_RETVAL note or if we have 		     SMALL_REGISTER_CLASSES and SET_SRC is a hard register.  */
if|if
condition|(
name|loop_info
operator|->
name|has_call
operator|&&
name|regs
operator|->
name|array
index|[
name|regno
index|]
operator|.
name|single_usage
operator|!=
literal|0
operator|&&
name|regs
operator|->
name|array
index|[
name|regno
index|]
operator|.
name|single_usage
operator|!=
name|const0_rtx
operator|&&
name|REGNO_FIRST_UID
argument_list|(
name|regno
argument_list|)
operator|==
name|INSN_UID
argument_list|(
name|p
argument_list|)
operator|&&
operator|(
name|REGNO_LAST_UID
argument_list|(
name|regno
argument_list|)
operator|==
name|INSN_UID
argument_list|(
name|regs
operator|->
name|array
index|[
name|regno
index|]
operator|.
name|single_usage
argument_list|)
operator|)
operator|&&
name|regs
operator|->
name|array
index|[
name|regno
index|]
operator|.
name|set_in_loop
operator|==
literal|1
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|!=
name|ASM_OPERANDS
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|&&
operator|!
name|find_reg_note
argument_list|(
name|p
argument_list|,
name|REG_RETVAL
argument_list|,
name|NULL_RTX
argument_list|)
operator|&&
operator|(
operator|!
name|SMALL_REGISTER_CLASSES
operator|||
operator|(
operator|!
operator|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|REGNO
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|)
operator|)
operator|)
operator|)
comment|/* This test is not redundant; SET_SRC (set) might be 			 a call-clobbered register and the life of REGNO 			 might span a call.  */
operator|&&
operator|!
name|modified_between_p
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
name|p
argument_list|,
name|regs
operator|->
name|array
index|[
name|regno
index|]
operator|.
name|single_usage
argument_list|)
operator|&&
name|no_labels_between_p
argument_list|(
name|p
argument_list|,
name|regs
operator|->
name|array
index|[
name|regno
index|]
operator|.
name|single_usage
argument_list|)
operator|&&
name|validate_replace_rtx
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|,
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
name|regs
operator|->
name|array
index|[
name|regno
index|]
operator|.
name|single_usage
argument_list|)
condition|)
block|{
comment|/* Replace any usage in a REG_EQUAL note.  Must copy 			 the new source, so that we don't get rtx sharing 			 between the SET_SOURCE and REG_NOTES of insn p.  */
name|REG_NOTES
argument_list|(
name|regs
operator|->
name|array
index|[
name|regno
index|]
operator|.
name|single_usage
argument_list|)
operator|=
operator|(
name|replace_rtx
argument_list|(
name|REG_NOTES
argument_list|(
name|regs
operator|->
name|array
index|[
name|regno
index|]
operator|.
name|single_usage
argument_list|)
argument_list|,
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|,
name|copy_rtx
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|delete_insn
argument_list|(
name|p
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LOOP_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
condition|;
name|i
operator|++
control|)
name|regs
operator|->
name|array
index|[
name|regno
operator|+
name|i
index|]
operator|.
name|set_in_loop
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
name|m
operator|=
operator|(
expr|struct
name|movable
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|movable
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|->
name|next
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|insn
operator|=
name|p
expr_stmt|;
name|m
operator|->
name|set_src
operator|=
name|src
expr_stmt|;
name|m
operator|->
name|dependencies
operator|=
name|dependencies
expr_stmt|;
name|m
operator|->
name|set_dest
operator|=
name|SET_DEST
argument_list|(
name|set
argument_list|)
expr_stmt|;
name|m
operator|->
name|force
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|consec
operator|=
name|regs
operator|->
name|array
index|[
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
index|]
operator|.
name|set_in_loop
operator|-
literal|1
expr_stmt|;
name|m
operator|->
name|done
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|forces
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|partial
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|move_insn
operator|=
name|move_insn
expr_stmt|;
name|m
operator|->
name|move_insn_first
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|is_equiv
operator|=
operator|(
name|find_reg_note
argument_list|(
name|p
argument_list|,
name|REG_EQUIV
argument_list|,
name|NULL_RTX
argument_list|)
operator|!=
literal|0
operator|)
expr_stmt|;
name|m
operator|->
name|savemode
operator|=
name|VOIDmode
expr_stmt|;
name|m
operator|->
name|regno
operator|=
name|regno
expr_stmt|;
comment|/* Set M->cond if either loop_invariant_p 		     or consec_sets_invariant_p returned 2 		     (only conditionally invariant).  */
name|m
operator|->
name|cond
operator|=
operator|(
operator|(
name|tem
operator||
name|tem1
operator||
name|tem2
operator|)
operator|>
literal|1
operator|)
expr_stmt|;
name|m
operator|->
name|global
operator|=
name|LOOP_REG_GLOBAL_P
argument_list|(
name|loop
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|m
operator|->
name|match
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|lifetime
operator|=
name|LOOP_REG_LIFETIME
argument_list|(
name|loop
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|m
operator|->
name|savings
operator|=
name|regs
operator|->
name|array
index|[
name|regno
index|]
operator|.
name|n_times_set
expr_stmt|;
if|if
condition|(
name|find_reg_note
argument_list|(
name|p
argument_list|,
name|REG_RETVAL
argument_list|,
name|NULL_RTX
argument_list|)
condition|)
name|m
operator|->
name|savings
operator|+=
name|libcall_benefit
argument_list|(
name|p
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LOOP_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
condition|;
name|i
operator|++
control|)
name|regs
operator|->
name|array
index|[
name|regno
operator|+
name|i
index|]
operator|.
name|set_in_loop
operator|=
name|move_insn
condition|?
operator|-
literal|2
else|:
operator|-
literal|1
expr_stmt|;
comment|/* Add M to the end of the chain MOVABLES.  */
name|loop_movables_add
argument_list|(
name|movables
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|consec
operator|>
literal|0
condition|)
block|{
comment|/* It is possible for the first instruction to have a 			 REG_EQUAL note but a non-invariant SET_SRC, so we must 			 remember the status of the first instruction in case 			 the last instruction doesn't have a REG_EQUAL note.  */
name|m
operator|->
name|move_insn_first
operator|=
name|m
operator|->
name|move_insn
expr_stmt|;
comment|/* Skip this insn, not checking REG_LIBCALL notes.  */
name|p
operator|=
name|next_nonnote_insn
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* Skip the consecutive insns, if there are any.  */
name|p
operator|=
name|skip_consec_insns
argument_list|(
name|p
argument_list|,
name|m
operator|->
name|consec
argument_list|)
expr_stmt|;
comment|/* Back up to the last insn of the consecutive group.  */
name|p
operator|=
name|prev_nonnote_insn
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* We must now reset m->move_insn, m->is_equiv, and 			 possibly m->set_src to correspond to the effects of 			 all the insns.  */
name|temp
operator|=
name|find_reg_note
argument_list|(
name|p
argument_list|,
name|REG_EQUIV
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
condition|)
name|m
operator|->
name|set_src
operator|=
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
operator|,
name|m
operator|->
name|move_insn
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|temp
operator|=
name|find_reg_note
argument_list|(
name|p
argument_list|,
name|REG_EQUAL
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|&&
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|m
operator|->
name|set_src
operator|=
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
operator|,
name|m
operator|->
name|move_insn
operator|=
literal|1
expr_stmt|;
else|else
name|m
operator|->
name|move_insn
operator|=
literal|0
expr_stmt|;
block|}
name|m
operator|->
name|is_equiv
operator|=
operator|(
name|find_reg_note
argument_list|(
name|p
argument_list|,
name|REG_EQUIV
argument_list|,
name|NULL_RTX
argument_list|)
operator|!=
literal|0
operator|)
expr_stmt|;
block|}
block|}
comment|/* If this register is always set within a STRICT_LOW_PART 		 or set to zero, then its high bytes are constant. 		 So clear them outside the loop and within the loop 		 just load the low bytes. 		 We must check that the machine has an instruction to do so. 		 Also, if the value loaded into the register 		 depends on the same register, this cannot be done.  */
elseif|else
if|if
condition|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
operator|==
name|const0_rtx
operator|&&
name|GET_CODE
argument_list|(
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
argument_list|)
operator|==
name|INSN
operator|&&
operator|(
name|set1
operator|=
name|single_set
argument_list|(
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
argument_list|)
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|set1
argument_list|)
operator|==
name|SET
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set1
argument_list|)
argument_list|)
operator|==
name|STRICT_LOW_PART
operator|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|set1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|)
operator|&&
operator|(
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|set1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SET_DEST
argument_list|(
name|set
argument_list|)
operator|)
operator|&&
operator|!
name|reg_mentioned_p
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|,
name|SET_SRC
argument_list|(
name|set1
argument_list|)
argument_list|)
condition|)
block|{
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|regs
operator|->
name|array
index|[
name|regno
index|]
operator|.
name|set_in_loop
operator|==
literal|2
condition|)
block|{
name|struct
name|movable
modifier|*
name|m
decl_stmt|;
name|m
operator|=
operator|(
expr|struct
name|movable
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|movable
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|->
name|next
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|insn
operator|=
name|p
expr_stmt|;
name|m
operator|->
name|set_dest
operator|=
name|SET_DEST
argument_list|(
name|set
argument_list|)
expr_stmt|;
name|m
operator|->
name|dependencies
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|force
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|consec
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|done
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|forces
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|move_insn
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|move_insn_first
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|partial
operator|=
literal|1
expr_stmt|;
comment|/* If the insn may not be executed on some cycles, 			 we can't clear the whole reg; clear just high part. 			 Not even if the reg is used only within this loop. 			 Consider this: 			 while (1) 			   while (s != t) { 			     if (foo ()) x = *s; 			     use (x); 			   } 			 Clearing x before the inner loop could clobber a value 			 being saved from the last time around the outer loop. 			 However, if the reg is not used outside this loop 			 and all uses of the register are in the same 			 basic block as the store, there is no problem.  			 If this insn was made by loop, we don't know its 			 INSN_LUID and hence must make a conservative 			 assumption.  */
name|m
operator|->
name|global
operator|=
operator|(
name|INSN_UID
argument_list|(
name|p
argument_list|)
operator|>=
name|max_uid_for_loop
operator|||
name|LOOP_REG_GLOBAL_P
argument_list|(
name|loop
argument_list|,
name|regno
argument_list|)
operator|||
operator|(
name|labels_in_range_p
argument_list|(
name|p
argument_list|,
name|REGNO_FIRST_LUID
argument_list|(
name|regno
argument_list|)
argument_list|)
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|maybe_never
operator|&&
name|m
operator|->
name|global
condition|)
name|m
operator|->
name|savemode
operator|=
name|GET_MODE
argument_list|(
name|SET_SRC
argument_list|(
name|set1
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|m
operator|->
name|savemode
operator|=
name|VOIDmode
expr_stmt|;
name|m
operator|->
name|regno
operator|=
name|regno
expr_stmt|;
name|m
operator|->
name|cond
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|match
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|lifetime
operator|=
name|LOOP_REG_LIFETIME
argument_list|(
name|loop
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|m
operator|->
name|savings
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LOOP_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
condition|;
name|i
operator|++
control|)
name|regs
operator|->
name|array
index|[
name|regno
operator|+
name|i
index|]
operator|.
name|set_in_loop
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Add M to the end of the chain MOVABLES.  */
name|loop_movables_add
argument_list|(
name|movables
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* Past a call insn, we get to insns which might not be executed 	 because the call might exit.  This matters for insns that trap. 	 Constant and pure call insns always return, so they don't count.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|CALL_INSN
operator|&&
operator|!
name|CONST_OR_PURE_CALL_P
argument_list|(
name|p
argument_list|)
condition|)
name|call_passed
operator|=
literal|1
expr_stmt|;
comment|/* Past a label or a jump, we get to insns for which we 	 can't count on whether or how many times they will be 	 executed during each iteration.  Therefore, we can 	 only move out sets of trivial variables 	 (those not used after the loop).  */
comment|/* Similar code appears twice in strength_reduce.  */
elseif|else
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|CODE_LABEL
operator|||
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|JUMP_INSN
operator|)
comment|/* If we enter the loop in the middle, and scan around to the 		  beginning, don't set maybe_never for that.  This must be an 		  unconditional jump, otherwise the code at the top of the 		  loop might never be executed.  Unconditional jumps are 		  followed by a barrier then the loop_end.  */
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|JUMP_LABEL
argument_list|(
name|p
argument_list|)
operator|==
name|loop
operator|->
name|top
operator|&&
name|NEXT_INSN
argument_list|(
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
argument_list|)
operator|==
name|loop_end
operator|&&
name|any_uncondjump_p
argument_list|(
name|p
argument_list|)
operator|)
condition|)
name|maybe_never
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|NOTE
condition|)
block|{
comment|/* At the virtual top of a converted loop, insns are again known to 	     be executed: logically, the loop begins here even though the exit 	     code has been duplicated.  */
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|p
argument_list|)
operator|==
name|NOTE_INSN_LOOP_VTOP
operator|&&
name|loop_depth
operator|==
literal|0
condition|)
name|maybe_never
operator|=
name|call_passed
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|p
argument_list|)
operator|==
name|NOTE_INSN_LOOP_BEG
condition|)
name|loop_depth
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|p
argument_list|)
operator|==
name|NOTE_INSN_LOOP_END
condition|)
name|loop_depth
operator|--
expr_stmt|;
block|}
block|}
comment|/* If one movable subsumes another, ignore that other.  */
name|ignore_some_movables
argument_list|(
name|movables
argument_list|)
expr_stmt|;
comment|/* For each movable insn, see if the reg that it loads      leads when it dies right into another conditionally movable insn.      If so, record that the second insn "forces" the first one,      since the second can be moved only if the first is.  */
name|force_movables
argument_list|(
name|movables
argument_list|)
expr_stmt|;
comment|/* See if there are multiple movable insns that load the same value.      If there are, make all but the first point at the first one      through the `match' field, and add the priorities of them      all together as the priority of the first.  */
name|combine_movables
argument_list|(
name|movables
argument_list|,
name|regs
argument_list|)
expr_stmt|;
comment|/* Now consider each movable insn to decide whether it is worth moving.      Store 0 in regs->array[I].set_in_loop for each reg I that is moved.       Generally this increases code size, so do not move moveables when      optimizing for code size.  */
if|if
condition|(
operator|!
name|optimize_size
condition|)
block|{
name|move_movables
argument_list|(
name|loop
argument_list|,
name|movables
argument_list|,
name|threshold
argument_list|,
name|insn_count
argument_list|)
expr_stmt|;
comment|/* Recalculate regs->array if move_movables has created new 	 registers.  */
if|if
condition|(
name|max_reg_num
argument_list|()
operator|>
name|regs
operator|->
name|num
condition|)
block|{
name|loop_regs_scan
argument_list|(
name|loop
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|update_start
operator|=
name|loop_start
init|;
name|PREV_INSN
argument_list|(
name|update_start
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|PREV_INSN
argument_list|(
name|update_start
argument_list|)
argument_list|)
operator|!=
name|CODE_LABEL
condition|;
name|update_start
operator|=
name|PREV_INSN
argument_list|(
name|update_start
argument_list|)
control|)
empty_stmt|;
name|update_end
operator|=
name|NEXT_INSN
argument_list|(
name|loop_end
argument_list|)
expr_stmt|;
name|reg_scan_update
argument_list|(
name|update_start
argument_list|,
name|update_end
argument_list|,
name|loop_max_reg
argument_list|)
expr_stmt|;
name|loop_max_reg
operator|=
name|max_reg_num
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* Now candidates that still are negative are those not moved.      Change regs->array[I].set_in_loop to indicate that those are not actually      invariant.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|regs
operator|->
name|num
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|regs
operator|->
name|array
index|[
name|i
index|]
operator|.
name|set_in_loop
operator|<
literal|0
condition|)
name|regs
operator|->
name|array
index|[
name|i
index|]
operator|.
name|set_in_loop
operator|=
name|regs
operator|->
name|array
index|[
name|i
index|]
operator|.
name|n_times_set
expr_stmt|;
comment|/* Now that we've moved some things out of the loop, we might be able to      hoist even more memory references.  */
name|load_mems
argument_list|(
name|loop
argument_list|)
expr_stmt|;
comment|/* Recalculate regs->array if load_mems has created new registers.  */
if|if
condition|(
name|max_reg_num
argument_list|()
operator|>
name|regs
operator|->
name|num
condition|)
name|loop_regs_scan
argument_list|(
name|loop
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|update_start
operator|=
name|loop_start
init|;
name|PREV_INSN
argument_list|(
name|update_start
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|PREV_INSN
argument_list|(
name|update_start
argument_list|)
argument_list|)
operator|!=
name|CODE_LABEL
condition|;
name|update_start
operator|=
name|PREV_INSN
argument_list|(
name|update_start
argument_list|)
control|)
empty_stmt|;
name|update_end
operator|=
name|NEXT_INSN
argument_list|(
name|loop_end
argument_list|)
expr_stmt|;
name|reg_scan_update
argument_list|(
name|update_start
argument_list|,
name|update_end
argument_list|,
name|loop_max_reg
argument_list|)
expr_stmt|;
name|loop_max_reg
operator|=
name|max_reg_num
argument_list|()
expr_stmt|;
if|if
condition|(
name|flag_strength_reduce
condition|)
block|{
if|if
condition|(
name|update_end
operator|&&
name|GET_CODE
argument_list|(
name|update_end
argument_list|)
operator|==
name|CODE_LABEL
condition|)
comment|/* Ensure our label doesn't go away.  */
name|LABEL_NUSES
argument_list|(
name|update_end
argument_list|)
operator|++
expr_stmt|;
name|strength_reduce
argument_list|(
name|loop
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|reg_scan_update
argument_list|(
name|update_start
argument_list|,
name|update_end
argument_list|,
name|loop_max_reg
argument_list|)
expr_stmt|;
name|loop_max_reg
operator|=
name|max_reg_num
argument_list|()
expr_stmt|;
if|if
condition|(
name|update_end
operator|&&
name|GET_CODE
argument_list|(
name|update_end
argument_list|)
operator|==
name|CODE_LABEL
operator|&&
operator|--
name|LABEL_NUSES
argument_list|(
name|update_end
argument_list|)
operator|==
literal|0
condition|)
name|delete_related_insns
argument_list|(
name|update_end
argument_list|)
expr_stmt|;
block|}
comment|/* The movable information is required for strength reduction.  */
name|loop_movables_free
argument_list|(
name|movables
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|regs
operator|->
name|array
argument_list|)
expr_stmt|;
name|regs
operator|->
name|array
operator|=
literal|0
expr_stmt|;
name|regs
operator|->
name|num
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Add elements to *OUTPUT to record all the pseudo-regs    mentioned in IN_THIS but not mentioned in NOT_IN_THIS.  */
end_comment

begin_function
name|void
name|record_excess_regs
parameter_list|(
name|in_this
parameter_list|,
name|not_in_this
parameter_list|,
name|output
parameter_list|)
name|rtx
name|in_this
decl_stmt|,
name|not_in_this
decl_stmt|;
name|rtx
modifier|*
name|output
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|i
decl_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|in_this
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PC
case|:
case|case
name|CC0
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CONST
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
return|return;
case|case
name|REG
case|:
if|if
condition|(
name|REGNO
argument_list|(
name|in_this
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
operator|!
name|reg_mentioned_p
argument_list|(
name|in_this
argument_list|,
name|not_in_this
argument_list|)
condition|)
operator|*
name|output
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|in_this
argument_list|,
operator|*
name|output
argument_list|)
expr_stmt|;
return|return;
default|default:
break|break;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|int
name|j
decl_stmt|;
switch|switch
condition|(
name|fmt
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'E'
case|:
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|in_this
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|record_excess_regs
argument_list|(
name|XVECEXP
argument_list|(
name|in_this
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|not_in_this
argument_list|,
name|output
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|record_excess_regs
argument_list|(
name|XEXP
argument_list|(
name|in_this
argument_list|,
name|i
argument_list|)
argument_list|,
name|not_in_this
argument_list|,
name|output
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Check what regs are referred to in the libcall block ending with INSN,    aside from those mentioned in the equivalent value.    If there are none, return 0.    If there are one or more, return an EXPR_LIST containing all of them.  */
end_comment

begin_function
name|rtx
name|libcall_other_reg
parameter_list|(
name|insn
parameter_list|,
name|equiv
parameter_list|)
name|rtx
name|insn
decl_stmt|,
name|equiv
decl_stmt|;
block|{
name|rtx
name|note
init|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_RETVAL
argument_list|,
name|NULL_RTX
argument_list|)
decl_stmt|;
name|rtx
name|p
init|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|output
init|=
literal|0
decl_stmt|;
comment|/* First, find all the regs used in the libcall block      that are not mentioned as inputs to the result.  */
while|while
condition|(
name|p
operator|!=
name|insn
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|JUMP_INSN
operator|||
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|CALL_INSN
condition|)
name|record_excess_regs
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|,
name|equiv
argument_list|,
operator|&
name|output
argument_list|)
expr_stmt|;
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
return|return
name|output
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if all uses of REG    are between INSN and the end of the basic block.  */
end_comment

begin_function
specifier|static
name|int
name|reg_in_basic_block_p
parameter_list|(
name|insn
parameter_list|,
name|reg
parameter_list|)
name|rtx
name|insn
decl_stmt|,
name|reg
decl_stmt|;
block|{
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|reg
argument_list|)
decl_stmt|;
name|rtx
name|p
decl_stmt|;
if|if
condition|(
name|REGNO_FIRST_UID
argument_list|(
name|regno
argument_list|)
operator|!=
name|INSN_UID
argument_list|(
name|insn
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Search this basic block for the already recorded last use of the reg.  */
for|for
control|(
name|p
operator|=
name|insn
init|;
name|p
condition|;
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
control|)
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
condition|)
block|{
case|case
name|NOTE
case|:
break|break;
case|case
name|INSN
case|:
case|case
name|CALL_INSN
case|:
comment|/* Ordinary insn: if this is the last use, we win.  */
if|if
condition|(
name|REGNO_LAST_UID
argument_list|(
name|regno
argument_list|)
operator|==
name|INSN_UID
argument_list|(
name|p
argument_list|)
condition|)
return|return
literal|1
return|;
break|break;
case|case
name|JUMP_INSN
case|:
comment|/* Jump insn: if this is the last use, we win.  */
if|if
condition|(
name|REGNO_LAST_UID
argument_list|(
name|regno
argument_list|)
operator|==
name|INSN_UID
argument_list|(
name|p
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Otherwise, it's the end of the basic block, so we lose.  */
return|return
literal|0
return|;
case|case
name|CODE_LABEL
case|:
case|case
name|BARRIER
case|:
comment|/* It's the end of the basic block, so we lose.  */
return|return
literal|0
return|;
default|default:
break|break;
block|}
block|}
comment|/* The "last use" that was recorded can't be found after the first      use.  This can happen when the last use was deleted while      processing an inner loop, this inner loop was then completely      unrolled, and the outer loop is always exited after the inner loop,      so that everything after the first use becomes a single basic block.  */
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Compute the benefit of eliminating the insns in the block whose    last insn is LAST.  This may be a group of insns used to compute a    value directly or can contain a library call.  */
end_comment

begin_function
specifier|static
name|int
name|libcall_benefit
parameter_list|(
name|last
parameter_list|)
name|rtx
name|last
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|;
name|int
name|benefit
init|=
literal|0
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|XEXP
argument_list|(
name|find_reg_note
argument_list|(
name|last
argument_list|,
name|REG_RETVAL
argument_list|,
name|NULL_RTX
argument_list|)
argument_list|,
literal|0
argument_list|)
init|;
name|insn
operator|!=
name|last
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
name|benefit
operator|+=
literal|10
expr_stmt|;
comment|/* Assume at least this many insns in a library 				   routine.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|USE
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|CLOBBER
condition|)
name|benefit
operator|++
expr_stmt|;
block|}
return|return
name|benefit
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Skip COUNT insns from INSN, counting library calls as 1 insn.  */
end_comment

begin_function
specifier|static
name|rtx
name|skip_consec_insns
parameter_list|(
name|insn
parameter_list|,
name|count
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|int
name|count
decl_stmt|;
block|{
for|for
control|(
init|;
name|count
operator|>
literal|0
condition|;
name|count
operator|--
control|)
block|{
name|rtx
name|temp
decl_stmt|;
comment|/* If first insn of libcall sequence, skip to end.  */
comment|/* Do this at start of loop, since INSN is guaranteed to 	 be an insn here.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE
operator|&&
operator|(
name|temp
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_LIBCALL
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
condition|)
name|insn
operator|=
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
do|do
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
do|while
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
do|;
block|}
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Ignore any movable whose insn falls within a libcall    which is part of another movable.    We make use of the fact that the movable for the libcall value    was made later and so appears later on the chain.  */
end_comment

begin_function
specifier|static
name|void
name|ignore_some_movables
parameter_list|(
name|movables
parameter_list|)
name|struct
name|loop_movables
modifier|*
name|movables
decl_stmt|;
block|{
name|struct
name|movable
modifier|*
name|m
decl_stmt|,
modifier|*
name|m1
decl_stmt|;
for|for
control|(
name|m
operator|=
name|movables
operator|->
name|head
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|next
control|)
block|{
comment|/* Is this a movable for the value of a libcall?  */
name|rtx
name|note
init|=
name|find_reg_note
argument_list|(
name|m
operator|->
name|insn
argument_list|,
name|REG_RETVAL
argument_list|,
name|NULL_RTX
argument_list|)
decl_stmt|;
if|if
condition|(
name|note
condition|)
block|{
name|rtx
name|insn
decl_stmt|;
comment|/* Check for earlier movables inside that range, 	     and mark them invalid.  We cannot use LUIDs here because 	     insns created by loop.c for prior loops don't have LUIDs. 	     Rather than reject all such insns from movables, we just 	     explicitly check each insn in the libcall (since invariant 	     libcalls aren't that common).  */
for|for
control|(
name|insn
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
init|;
name|insn
operator|!=
name|m
operator|->
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
for|for
control|(
name|m1
operator|=
name|movables
operator|->
name|head
init|;
name|m1
operator|!=
name|m
condition|;
name|m1
operator|=
name|m1
operator|->
name|next
control|)
if|if
condition|(
name|m1
operator|->
name|insn
operator|==
name|insn
condition|)
name|m1
operator|->
name|done
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* For each movable insn, see if the reg that it loads    leads when it dies right into another conditionally movable insn.    If so, record that the second insn "forces" the first one,    since the second can be moved only if the first is.  */
end_comment

begin_function
specifier|static
name|void
name|force_movables
parameter_list|(
name|movables
parameter_list|)
name|struct
name|loop_movables
modifier|*
name|movables
decl_stmt|;
block|{
name|struct
name|movable
modifier|*
name|m
decl_stmt|,
modifier|*
name|m1
decl_stmt|;
for|for
control|(
name|m1
operator|=
name|movables
operator|->
name|head
init|;
name|m1
condition|;
name|m1
operator|=
name|m1
operator|->
name|next
control|)
comment|/* Omit this if moving just the (SET (REG) 0) of a zero-extend.  */
if|if
condition|(
operator|!
name|m1
operator|->
name|partial
operator|&&
operator|!
name|m1
operator|->
name|done
condition|)
block|{
name|int
name|regno
init|=
name|m1
operator|->
name|regno
decl_stmt|;
for|for
control|(
name|m
operator|=
name|m1
operator|->
name|next
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|next
control|)
comment|/* ??? Could this be a bug?  What if CSE caused the 	     register of M1 to be used after this insn? 	     Since CSE does not update regno_last_uid, 	     this insn M->insn might not be where it dies. 	     But very likely this doesn't matter; what matters is 	     that M's reg is computed from M1's reg.  */
if|if
condition|(
name|INSN_UID
argument_list|(
name|m
operator|->
name|insn
argument_list|)
operator|==
name|REGNO_LAST_UID
argument_list|(
name|regno
argument_list|)
operator|&&
operator|!
name|m
operator|->
name|done
condition|)
break|break;
if|if
condition|(
name|m
operator|!=
literal|0
operator|&&
name|m
operator|->
name|set_src
operator|==
name|m1
operator|->
name|set_dest
comment|/* If m->consec, m->set_src isn't valid.  */
operator|&&
name|m
operator|->
name|consec
operator|==
literal|0
condition|)
name|m
operator|=
literal|0
expr_stmt|;
comment|/* Increase the priority of the moving the first insn 	   since it permits the second to be moved as well.  */
if|if
condition|(
name|m
operator|!=
literal|0
condition|)
block|{
name|m
operator|->
name|forces
operator|=
name|m1
expr_stmt|;
name|m1
operator|->
name|lifetime
operator|+=
name|m
operator|->
name|lifetime
expr_stmt|;
name|m1
operator|->
name|savings
operator|+=
name|m
operator|->
name|savings
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Find invariant expressions that are equal and can be combined into    one register.  */
end_comment

begin_function
specifier|static
name|void
name|combine_movables
parameter_list|(
name|movables
parameter_list|,
name|regs
parameter_list|)
name|struct
name|loop_movables
modifier|*
name|movables
decl_stmt|;
name|struct
name|loop_regs
modifier|*
name|regs
decl_stmt|;
block|{
name|struct
name|movable
modifier|*
name|m
decl_stmt|;
name|char
modifier|*
name|matched_regs
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|regs
operator|->
name|num
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
comment|/* Regs that are set more than once are not allowed to match      or be matched.  I'm no longer sure why not.  */
comment|/* Only pseudo registers are allowed to match or be matched,      since move_movables does not validate the change.  */
comment|/* Perhaps testing m->consec_sets would be more appropriate here?  */
for|for
control|(
name|m
operator|=
name|movables
operator|->
name|head
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|next
control|)
if|if
condition|(
name|m
operator|->
name|match
operator|==
literal|0
operator|&&
name|regs
operator|->
name|array
index|[
name|m
operator|->
name|regno
index|]
operator|.
name|n_times_set
operator|==
literal|1
operator|&&
name|m
operator|->
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
operator|!
name|m
operator|->
name|partial
condition|)
block|{
name|struct
name|movable
modifier|*
name|m1
decl_stmt|;
name|int
name|regno
init|=
name|m
operator|->
name|regno
decl_stmt|;
name|memset
argument_list|(
name|matched_regs
argument_list|,
literal|0
argument_list|,
name|regs
operator|->
name|num
argument_list|)
expr_stmt|;
name|matched_regs
index|[
name|regno
index|]
operator|=
literal|1
expr_stmt|;
comment|/* We want later insns to match the first one.  Don't make the first 	   one match any later ones.  So start this loop at m->next.  */
for|for
control|(
name|m1
operator|=
name|m
operator|->
name|next
init|;
name|m1
condition|;
name|m1
operator|=
name|m1
operator|->
name|next
control|)
if|if
condition|(
name|m
operator|!=
name|m1
operator|&&
name|m1
operator|->
name|match
operator|==
literal|0
operator|&&
name|regs
operator|->
name|array
index|[
name|m1
operator|->
name|regno
index|]
operator|.
name|n_times_set
operator|==
literal|1
operator|&&
name|m1
operator|->
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
comment|/* A reg used outside the loop mustn't be eliminated.  */
operator|&&
operator|!
name|m1
operator|->
name|global
comment|/* A reg used for zero-extending mustn't be eliminated.  */
operator|&&
operator|!
name|m1
operator|->
name|partial
operator|&&
operator|(
name|matched_regs
index|[
name|m1
operator|->
name|regno
index|]
operator|||
operator|(
comment|/* Can combine regs with different modes loaded from the 		      same constant only if the modes are the same or 		      if both are integer modes with M wider or the same 		      width as M1.  The check for integer is redundant, but 		      safe, since the only case of differing destination 		      modes with equal sources is when both sources are 		      VOIDmode, i.e., CONST_INT.  */
operator|(
name|GET_MODE
argument_list|(
name|m
operator|->
name|set_dest
argument_list|)
operator|==
name|GET_MODE
argument_list|(
name|m1
operator|->
name|set_dest
argument_list|)
operator|||
operator|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|m
operator|->
name|set_dest
argument_list|)
argument_list|)
operator|==
name|MODE_INT
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|m1
operator|->
name|set_dest
argument_list|)
argument_list|)
operator|==
name|MODE_INT
operator|&&
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|m
operator|->
name|set_dest
argument_list|)
argument_list|)
operator|>=
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|m1
operator|->
name|set_dest
argument_list|)
argument_list|)
operator|)
operator|)
operator|)
comment|/* See if the source of M1 says it matches M.  */
operator|&&
operator|(
operator|(
name|GET_CODE
argument_list|(
name|m1
operator|->
name|set_src
argument_list|)
operator|==
name|REG
operator|&&
name|matched_regs
index|[
name|REGNO
argument_list|(
name|m1
operator|->
name|set_src
argument_list|)
index|]
operator|)
operator|||
name|rtx_equal_for_loop_p
argument_list|(
name|m
operator|->
name|set_src
argument_list|,
name|m1
operator|->
name|set_src
argument_list|,
name|movables
argument_list|,
name|regs
argument_list|)
operator|)
operator|)
operator|)
operator|&&
operator|(
operator|(
name|m
operator|->
name|dependencies
operator|==
name|m1
operator|->
name|dependencies
operator|)
operator|||
name|rtx_equal_p
argument_list|(
name|m
operator|->
name|dependencies
argument_list|,
name|m1
operator|->
name|dependencies
argument_list|)
operator|)
condition|)
block|{
name|m
operator|->
name|lifetime
operator|+=
name|m1
operator|->
name|lifetime
expr_stmt|;
name|m
operator|->
name|savings
operator|+=
name|m1
operator|->
name|savings
expr_stmt|;
name|m1
operator|->
name|done
operator|=
literal|1
expr_stmt|;
name|m1
operator|->
name|match
operator|=
name|m
expr_stmt|;
name|matched_regs
index|[
name|m1
operator|->
name|regno
index|]
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* Now combine the regs used for zero-extension.      This can be done for those not marked `global'      provided their lives don't overlap.  */
for|for
control|(
name|mode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_INT
argument_list|)
init|;
name|mode
operator|!=
name|VOIDmode
condition|;
name|mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
control|)
block|{
name|struct
name|movable
modifier|*
name|m0
init|=
literal|0
decl_stmt|;
comment|/* Combine all the registers for extension from mode MODE. 	 Don't combine any that are used outside this loop.  */
for|for
control|(
name|m
operator|=
name|movables
operator|->
name|head
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|next
control|)
if|if
condition|(
name|m
operator|->
name|partial
operator|&&
operator|!
name|m
operator|->
name|global
operator|&&
name|mode
operator|==
name|GET_MODE
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|NEXT_INSN
argument_list|(
name|m
operator|->
name|insn
argument_list|)
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|struct
name|movable
modifier|*
name|m1
decl_stmt|;
name|int
name|first
init|=
name|REGNO_FIRST_LUID
argument_list|(
name|m
operator|->
name|regno
argument_list|)
decl_stmt|;
name|int
name|last
init|=
name|REGNO_LAST_LUID
argument_list|(
name|m
operator|->
name|regno
argument_list|)
decl_stmt|;
if|if
condition|(
name|m0
operator|==
literal|0
condition|)
block|{
comment|/* First one: don't check for overlap, just record it.  */
name|m0
operator|=
name|m
expr_stmt|;
continue|continue;
block|}
comment|/* Make sure they extend to the same mode. 	       (Almost always true.)  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|m
operator|->
name|set_dest
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|m0
operator|->
name|set_dest
argument_list|)
condition|)
continue|continue;
comment|/* We already have one: check for overlap with those 	       already combined together.  */
for|for
control|(
name|m1
operator|=
name|movables
operator|->
name|head
init|;
name|m1
operator|!=
name|m
condition|;
name|m1
operator|=
name|m1
operator|->
name|next
control|)
if|if
condition|(
name|m1
operator|==
name|m0
operator|||
operator|(
name|m1
operator|->
name|partial
operator|&&
name|m1
operator|->
name|match
operator|==
name|m0
operator|)
condition|)
if|if
condition|(
operator|!
operator|(
name|REGNO_FIRST_LUID
argument_list|(
name|m1
operator|->
name|regno
argument_list|)
operator|>
name|last
operator|||
name|REGNO_LAST_LUID
argument_list|(
name|m1
operator|->
name|regno
argument_list|)
operator|<
name|first
operator|)
condition|)
goto|goto
name|overlap
goto|;
comment|/* No overlap: we can combine this with the others.  */
name|m0
operator|->
name|lifetime
operator|+=
name|m
operator|->
name|lifetime
expr_stmt|;
name|m0
operator|->
name|savings
operator|+=
name|m
operator|->
name|savings
expr_stmt|;
name|m
operator|->
name|done
operator|=
literal|1
expr_stmt|;
name|m
operator|->
name|match
operator|=
name|m0
expr_stmt|;
name|overlap
label|:
empty_stmt|;
block|}
block|}
comment|/* Clean up.  */
name|free
argument_list|(
name|matched_regs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns the number of movable instructions in LOOP that were not    moved outside the loop.  */
end_comment

begin_function
specifier|static
name|int
name|num_unmoved_movables
parameter_list|(
name|loop
parameter_list|)
specifier|const
name|struct
name|loop
modifier|*
name|loop
decl_stmt|;
block|{
name|int
name|num
init|=
literal|0
decl_stmt|;
name|struct
name|movable
modifier|*
name|m
decl_stmt|;
for|for
control|(
name|m
operator|=
name|LOOP_MOVABLES
argument_list|(
name|loop
argument_list|)
operator|->
name|head
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|next
control|)
if|if
condition|(
operator|!
name|m
operator|->
name|done
condition|)
operator|++
name|num
expr_stmt|;
return|return
name|num
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if regs X and Y will become the same if moved.  */
end_comment

begin_function
specifier|static
name|int
name|regs_match_p
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|movables
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|y
decl_stmt|;
name|struct
name|loop_movables
modifier|*
name|movables
decl_stmt|;
block|{
name|unsigned
name|int
name|xn
init|=
name|REGNO
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|yn
init|=
name|REGNO
argument_list|(
name|y
argument_list|)
decl_stmt|;
name|struct
name|movable
modifier|*
name|mx
decl_stmt|,
modifier|*
name|my
decl_stmt|;
for|for
control|(
name|mx
operator|=
name|movables
operator|->
name|head
init|;
name|mx
condition|;
name|mx
operator|=
name|mx
operator|->
name|next
control|)
if|if
condition|(
name|mx
operator|->
name|regno
operator|==
name|xn
condition|)
break|break;
for|for
control|(
name|my
operator|=
name|movables
operator|->
name|head
init|;
name|my
condition|;
name|my
operator|=
name|my
operator|->
name|next
control|)
if|if
condition|(
name|my
operator|->
name|regno
operator|==
name|yn
condition|)
break|break;
return|return
operator|(
name|mx
operator|&&
name|my
operator|&&
operator|(
operator|(
name|mx
operator|->
name|match
operator|==
name|my
operator|->
name|match
operator|&&
name|mx
operator|->
name|match
operator|!=
literal|0
operator|)
operator|||
name|mx
operator|->
name|match
operator|==
name|my
operator|||
name|mx
operator|==
name|my
operator|->
name|match
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if X and Y are identical-looking rtx's.    This is the Lisp function EQUAL for rtx arguments.     If two registers are matching movables or a movable register and an    equivalent constant, consider them equal.  */
end_comment

begin_function
specifier|static
name|int
name|rtx_equal_for_loop_p
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|movables
parameter_list|,
name|regs
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|y
decl_stmt|;
name|struct
name|loop_movables
modifier|*
name|movables
decl_stmt|;
name|struct
name|loop_regs
modifier|*
name|regs
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|j
decl_stmt|;
name|struct
name|movable
modifier|*
name|m
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|x
operator|==
name|y
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|x
operator|==
literal|0
operator|||
name|y
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* If we have a register and a constant, they may sometimes be      equal.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
operator|&&
name|regs
operator|->
name|array
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
operator|.
name|set_in_loop
operator|==
operator|-
literal|2
operator|&&
name|CONSTANT_P
argument_list|(
name|y
argument_list|)
condition|)
block|{
for|for
control|(
name|m
operator|=
name|movables
operator|->
name|head
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|next
control|)
if|if
condition|(
name|m
operator|->
name|move_insn
operator|&&
name|m
operator|->
name|regno
operator|==
name|REGNO
argument_list|(
name|x
argument_list|)
operator|&&
name|rtx_equal_p
argument_list|(
name|m
operator|->
name|set_src
argument_list|,
name|y
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|REG
operator|&&
name|regs
operator|->
name|array
index|[
name|REGNO
argument_list|(
name|y
argument_list|)
index|]
operator|.
name|set_in_loop
operator|==
operator|-
literal|2
operator|&&
name|CONSTANT_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
for|for
control|(
name|m
operator|=
name|movables
operator|->
name|head
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|next
control|)
if|if
condition|(
name|m
operator|->
name|move_insn
operator|&&
name|m
operator|->
name|regno
operator|==
name|REGNO
argument_list|(
name|y
argument_list|)
operator|&&
name|rtx_equal_p
argument_list|(
name|m
operator|->
name|set_src
argument_list|,
name|x
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
comment|/* Otherwise, rtx's of different codes cannot be equal.  */
if|if
condition|(
name|code
operator|!=
name|GET_CODE
argument_list|(
name|y
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* (MULT:SI x y) and (MULT:HI x y) are NOT equivalent.      (REG:SI x) and (REG:HI x) are NOT equivalent.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|y
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* These three types of rtx's can be compared nonrecursively.  */
if|if
condition|(
name|code
operator|==
name|REG
condition|)
return|return
operator|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|==
name|REGNO
argument_list|(
name|y
argument_list|)
operator|||
name|regs_match_p
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|movables
argument_list|)
operator|)
return|;
if|if
condition|(
name|code
operator|==
name|LABEL_REF
condition|)
return|return
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|SYMBOL_REF
condition|)
return|return
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|XSTR
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
return|;
comment|/* Compare the elements.  If any pair of corresponding elements      fail to match, return 0 for the whole things.  */
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
switch|switch
condition|(
name|fmt
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'w'
case|:
if|if
condition|(
name|XWINT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
name|XWINT
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'i'
case|:
if|if
condition|(
name|XINT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
name|XINT
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'E'
case|:
comment|/* Two vectors must have the same length.  */
if|if
condition|(
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
name|XVECLEN
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* And the corresponding elements must match.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|rtx_equal_for_loop_p
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|XVECEXP
argument_list|(
name|y
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|movables
argument_list|,
name|regs
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'e'
case|:
if|if
condition|(
name|rtx_equal_for_loop_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
argument_list|,
name|movables
argument_list|,
name|regs
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'s'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|XSTR
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|XSTR
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'u'
case|:
comment|/* These are just backpointers, so they don't matter.  */
break|break;
case|case
literal|'0'
case|:
break|break;
comment|/* It is believed that rtx's at this level will never 	     contain anything but integers and other rtx's, 	     except for within LABEL_REFs and SYMBOL_REFs.  */
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If X contains any LABEL_REF's, add REG_LABEL notes for them to all    insns in INSNS which use the reference.  LABEL_NUSES for CODE_LABEL    references is incremented once for each added note.  */
end_comment

begin_function
specifier|static
name|void
name|add_label_notes
parameter_list|(
name|x
parameter_list|,
name|insns
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|rtx
name|insns
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|LABEL_REF
operator|&&
operator|!
name|LABEL_REF_NONLOCAL_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
comment|/* This code used to ignore labels that referred to dispatch tables to          avoid flow generating (slighly) worse code.           We no longer ignore such label references (see LABEL_REF handling in          mark_jump_label for additional information).  */
for|for
control|(
name|insn
operator|=
name|insns
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|reg_mentioned_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn
argument_list|)
condition|)
block|{
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_INSN_LIST
argument_list|(
name|REG_LABEL
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|LABEL_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|LABEL_NUSES
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|++
expr_stmt|;
block|}
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|add_label_notes
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|insns
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
name|add_label_notes
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|insns
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Scan MOVABLES, and move the insns that deserve to be moved.    If two matching movables are combined, replace one reg with the    other throughout.  */
end_comment

begin_function
specifier|static
name|void
name|move_movables
parameter_list|(
name|loop
parameter_list|,
name|movables
parameter_list|,
name|threshold
parameter_list|,
name|insn_count
parameter_list|)
name|struct
name|loop
modifier|*
name|loop
decl_stmt|;
name|struct
name|loop_movables
modifier|*
name|movables
decl_stmt|;
name|int
name|threshold
decl_stmt|;
name|int
name|insn_count
decl_stmt|;
block|{
name|struct
name|loop_regs
modifier|*
name|regs
init|=
name|LOOP_REGS
argument_list|(
name|loop
argument_list|)
decl_stmt|;
name|int
name|nregs
init|=
name|regs
operator|->
name|num
decl_stmt|;
name|rtx
name|new_start
init|=
literal|0
decl_stmt|;
name|struct
name|movable
modifier|*
name|m
decl_stmt|;
name|rtx
name|p
decl_stmt|;
name|rtx
name|loop_start
init|=
name|loop
operator|->
name|start
decl_stmt|;
name|rtx
name|loop_end
init|=
name|loop
operator|->
name|end
decl_stmt|;
comment|/* Map of pseudo-register replacements to handle combining      when we move several insns that load the same value      into different pseudo-registers.  */
name|rtx
modifier|*
name|reg_map
init|=
operator|(
name|rtx
operator|*
operator|)
name|xcalloc
argument_list|(
name|nregs
argument_list|,
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
decl_stmt|;
name|char
modifier|*
name|already_moved
init|=
operator|(
name|char
operator|*
operator|)
name|xcalloc
argument_list|(
name|nregs
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|m
operator|=
name|movables
operator|->
name|head
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|next
control|)
block|{
comment|/* Describe this movable insn.  */
if|if
condition|(
name|loop_dump_stream
condition|)
block|{
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Insn %d: regno %d (life %d), "
argument_list|,
name|INSN_UID
argument_list|(
name|m
operator|->
name|insn
argument_list|)
argument_list|,
name|m
operator|->
name|regno
argument_list|,
name|m
operator|->
name|lifetime
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|consec
operator|>
literal|0
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"consec %d, "
argument_list|,
name|m
operator|->
name|consec
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|cond
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"cond "
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|force
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"force "
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|global
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"global "
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|done
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"done "
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|move_insn
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"move-insn "
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|match
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"matches %d "
argument_list|,
name|INSN_UID
argument_list|(
name|m
operator|->
name|match
operator|->
name|insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|forces
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"forces %d "
argument_list|,
name|INSN_UID
argument_list|(
name|m
operator|->
name|forces
operator|->
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Ignore the insn if it's already done (it matched something else). 	 Otherwise, see if it is now safe to move.  */
if|if
condition|(
operator|!
name|m
operator|->
name|done
operator|&&
operator|(
operator|!
name|m
operator|->
name|cond
operator|||
operator|(
literal|1
operator|==
name|loop_invariant_p
argument_list|(
name|loop
argument_list|,
name|m
operator|->
name|set_src
argument_list|)
operator|&&
operator|(
name|m
operator|->
name|dependencies
operator|==
literal|0
operator|||
literal|1
operator|==
name|loop_invariant_p
argument_list|(
name|loop
argument_list|,
name|m
operator|->
name|dependencies
argument_list|)
operator|)
operator|&&
operator|(
name|m
operator|->
name|consec
operator|==
literal|0
operator|||
literal|1
operator|==
name|consec_sets_invariant_p
argument_list|(
name|loop
argument_list|,
name|m
operator|->
name|set_dest
argument_list|,
name|m
operator|->
name|consec
operator|+
literal|1
argument_list|,
name|m
operator|->
name|insn
argument_list|)
operator|)
operator|)
operator|)
operator|&&
operator|(
operator|!
name|m
operator|->
name|forces
operator|||
name|m
operator|->
name|forces
operator|->
name|done
operator|)
condition|)
block|{
name|int
name|regno
decl_stmt|;
name|rtx
name|p
decl_stmt|;
name|int
name|savings
init|=
name|m
operator|->
name|savings
decl_stmt|;
comment|/* We have an insn that is safe to move. 	     Compute its desirability.  */
name|p
operator|=
name|m
operator|->
name|insn
expr_stmt|;
name|regno
operator|=
name|m
operator|->
name|regno
expr_stmt|;
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"savings %d "
argument_list|,
name|savings
argument_list|)
expr_stmt|;
if|if
condition|(
name|regs
operator|->
name|array
index|[
name|regno
index|]
operator|.
name|moved_once
operator|&&
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"halved since already moved "
argument_list|)
expr_stmt|;
comment|/* An insn MUST be moved if we already moved something else 	     which is safe only if this one is moved too: that is, 	     if already_moved[REGNO] is nonzero.  */
comment|/* An insn is desirable to move if the new lifetime of the 	     register is no more than THRESHOLD times the old lifetime. 	     If it's not desirable, it means the loop is so big 	     that moving won't speed things up much, 	     and it is liable to make register usage worse.  */
comment|/* It is also desirable to move if it can be moved at no 	     extra cost because something else was already moved.  */
if|if
condition|(
name|already_moved
index|[
name|regno
index|]
operator|||
name|flag_move_all_movables
operator|||
operator|(
name|threshold
operator|*
name|savings
operator|*
name|m
operator|->
name|lifetime
operator|)
operator|>=
operator|(
name|regs
operator|->
name|array
index|[
name|regno
index|]
operator|.
name|moved_once
condition|?
name|insn_count
operator|*
literal|2
else|:
name|insn_count
operator|)
operator|||
operator|(
name|m
operator|->
name|forces
operator|&&
name|m
operator|->
name|forces
operator|->
name|done
operator|&&
name|regs
operator|->
name|array
index|[
name|m
operator|->
name|forces
operator|->
name|regno
index|]
operator|.
name|n_times_set
operator|==
literal|1
operator|)
condition|)
block|{
name|int
name|count
decl_stmt|;
name|struct
name|movable
modifier|*
name|m1
decl_stmt|;
name|rtx
name|first
init|=
name|NULL_RTX
decl_stmt|;
comment|/* Now move the insns that set the reg.  */
if|if
condition|(
name|m
operator|->
name|partial
operator|&&
name|m
operator|->
name|match
condition|)
block|{
name|rtx
name|newpat
decl_stmt|,
name|i1
decl_stmt|;
name|rtx
name|r1
decl_stmt|,
name|r2
decl_stmt|;
comment|/* Find the end of this chain of matching regs. 		     Thus, we load each reg in the chain from that one reg. 		     And that reg is loaded with 0 directly, 		     since it has ->match == 0.  */
for|for
control|(
name|m1
operator|=
name|m
init|;
name|m1
operator|->
name|match
condition|;
name|m1
operator|=
name|m1
operator|->
name|match
control|)
empty_stmt|;
name|newpat
operator|=
name|gen_move_insn
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|m
operator|->
name|insn
argument_list|)
argument_list|)
argument_list|,
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|m1
operator|->
name|insn
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|i1
operator|=
name|loop_insn_hoist
argument_list|(
name|loop
argument_list|,
name|newpat
argument_list|)
expr_stmt|;
comment|/* Mark the moved, invariant reg as being allowed to 		     share a hard reg with the other matching invariant.  */
name|REG_NOTES
argument_list|(
name|i1
argument_list|)
operator|=
name|REG_NOTES
argument_list|(
name|m
operator|->
name|insn
argument_list|)
expr_stmt|;
name|r1
operator|=
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|m
operator|->
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|r2
operator|=
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|m1
operator|->
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|regs_may_share
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|r1
argument_list|,
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|r2
argument_list|,
name|regs_may_share
argument_list|)
argument_list|)
expr_stmt|;
name|delete_insn
argument_list|(
name|m
operator|->
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_start
operator|==
literal|0
condition|)
name|new_start
operator|=
name|i1
expr_stmt|;
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|" moved to %d"
argument_list|,
name|INSN_UID
argument_list|(
name|i1
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If we are to re-generate the item being moved with a 		 new move insn, first delete what we have and then emit 		 the move insn before the loop.  */
elseif|else
if|if
condition|(
name|m
operator|->
name|move_insn
condition|)
block|{
name|rtx
name|i1
decl_stmt|,
name|temp
decl_stmt|,
name|seq
decl_stmt|;
for|for
control|(
name|count
operator|=
name|m
operator|->
name|consec
init|;
name|count
operator|>=
literal|0
condition|;
name|count
operator|--
control|)
block|{
comment|/* If this is the first insn of a library call sequence, 			 something is very wrong.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|!=
name|NOTE
operator|&&
operator|(
name|temp
operator|=
name|find_reg_note
argument_list|(
name|p
argument_list|,
name|REG_LIBCALL
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* If this is the last insn of a libcall sequence, then 			 delete every insn in the sequence except the last. 			 The last insn is handled in the normal manner.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|!=
name|NOTE
operator|&&
operator|(
name|temp
operator|=
name|find_reg_note
argument_list|(
name|p
argument_list|,
name|REG_RETVAL
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
condition|)
block|{
name|temp
operator|=
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|temp
operator|!=
name|p
condition|)
name|temp
operator|=
name|delete_insn
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
name|temp
operator|=
name|p
expr_stmt|;
name|p
operator|=
name|delete_insn
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* simplify_giv_expr expects that it can walk the insns 			 at m->insn forwards and see this old sequence we are 			 tossing here.  delete_insn does preserve the next 			 pointers, but when we skip over a NOTE we must fix 			 it up.  Otherwise that code walks into the non-deleted 			 insn stream.  */
while|while
condition|(
name|p
operator|&&
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|NOTE
condition|)
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|temp
argument_list|)
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|start_sequence
argument_list|()
expr_stmt|;
name|emit_move_insn
argument_list|(
name|m
operator|->
name|set_dest
argument_list|,
name|m
operator|->
name|set_src
argument_list|)
expr_stmt|;
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|add_label_notes
argument_list|(
name|m
operator|->
name|set_src
argument_list|,
name|seq
argument_list|)
expr_stmt|;
name|i1
operator|=
name|loop_insn_hoist
argument_list|(
name|loop
argument_list|,
name|seq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|find_reg_note
argument_list|(
name|i1
argument_list|,
name|REG_EQUAL
argument_list|,
name|NULL_RTX
argument_list|)
condition|)
name|set_unique_reg_note
argument_list|(
name|i1
argument_list|,
name|m
operator|->
name|is_equiv
condition|?
name|REG_EQUIV
else|:
name|REG_EQUAL
argument_list|,
name|m
operator|->
name|set_src
argument_list|)
expr_stmt|;
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|" moved to %d"
argument_list|,
name|INSN_UID
argument_list|(
name|i1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The more regs we move, the less we like moving them.  */
name|threshold
operator|-=
literal|3
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|count
operator|=
name|m
operator|->
name|consec
init|;
name|count
operator|>=
literal|0
condition|;
name|count
operator|--
control|)
block|{
name|rtx
name|i1
decl_stmt|,
name|temp
decl_stmt|;
comment|/* If first insn of libcall sequence, skip to end.  */
comment|/* Do this at start of loop, since p is guaranteed to 			 be an insn here.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|!=
name|NOTE
operator|&&
operator|(
name|temp
operator|=
name|find_reg_note
argument_list|(
name|p
argument_list|,
name|REG_LIBCALL
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
condition|)
name|p
operator|=
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If last insn of libcall sequence, move all 			 insns except the last before the loop.  The last 			 insn is handled in the normal manner.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|!=
name|NOTE
operator|&&
operator|(
name|temp
operator|=
name|find_reg_note
argument_list|(
name|p
argument_list|,
name|REG_RETVAL
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
condition|)
block|{
name|rtx
name|fn_address
init|=
literal|0
decl_stmt|;
name|rtx
name|fn_reg
init|=
literal|0
decl_stmt|;
name|rtx
name|fn_address_insn
init|=
literal|0
decl_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|temp
operator|=
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
init|;
name|temp
operator|!=
name|p
condition|;
name|temp
operator|=
name|NEXT_INSN
argument_list|(
name|temp
argument_list|)
control|)
block|{
name|rtx
name|body
decl_stmt|;
name|rtx
name|n
decl_stmt|;
name|rtx
name|next
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|==
name|NOTE
condition|)
continue|continue;
name|body
operator|=
name|PATTERN
argument_list|(
name|temp
argument_list|)
expr_stmt|;
comment|/* Find the next insn after TEMP, 				 not counting USE or NOTE insns.  */
for|for
control|(
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|temp
argument_list|)
init|;
name|next
operator|!=
name|p
condition|;
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|next
argument_list|)
control|)
if|if
condition|(
operator|!
operator|(
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|next
argument_list|)
argument_list|)
operator|==
name|USE
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|!=
name|NOTE
condition|)
break|break;
comment|/* If that is the call, this may be the insn 				 that loads the function address.  				 Extract the function address from the insn 				 that loads it into a register. 				 If this insn was cse'd, we get incorrect code.  				 So emit a new move insn that copies the 				 function address into the register that the 				 call insn will use.  flow.c will delete any 				 redundant stores that we have created.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|CALL_INSN
operator|&&
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|body
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|n
operator|=
name|find_reg_note
argument_list|(
name|temp
argument_list|,
name|REG_EQUAL
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
condition|)
block|{
name|fn_reg
operator|=
name|SET_SRC
argument_list|(
name|body
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|fn_reg
argument_list|)
operator|!=
name|REG
condition|)
name|fn_reg
operator|=
name|SET_DEST
argument_list|(
name|body
argument_list|)
expr_stmt|;
name|fn_address
operator|=
name|XEXP
argument_list|(
name|n
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fn_address_insn
operator|=
name|temp
expr_stmt|;
block|}
comment|/* We have the call insn. 				 If it uses the register we suspect it might, 				 load it with the correct address directly.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|==
name|CALL_INSN
operator|&&
name|fn_address
operator|!=
literal|0
operator|&&
name|reg_referenced_p
argument_list|(
name|fn_reg
argument_list|,
name|body
argument_list|)
condition|)
name|loop_insn_emit_after
argument_list|(
name|loop
argument_list|,
literal|0
argument_list|,
name|fn_address_insn
argument_list|,
name|gen_move_insn
argument_list|(
name|fn_reg
argument_list|,
name|fn_address
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
name|i1
operator|=
name|loop_call_insn_hoist
argument_list|(
name|loop
argument_list|,
name|body
argument_list|)
expr_stmt|;
comment|/* Because the USAGE information potentially 				     contains objects other than hard registers 				     we need to copy it.  */
if|if
condition|(
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|temp
argument_list|)
condition|)
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|i1
argument_list|)
operator|=
name|copy_rtx
argument_list|(
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|temp
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|i1
operator|=
name|loop_insn_hoist
argument_list|(
name|loop
argument_list|,
name|body
argument_list|)
expr_stmt|;
if|if
condition|(
name|first
operator|==
literal|0
condition|)
name|first
operator|=
name|i1
expr_stmt|;
if|if
condition|(
name|temp
operator|==
name|fn_address_insn
condition|)
name|fn_address_insn
operator|=
name|i1
expr_stmt|;
name|REG_NOTES
argument_list|(
name|i1
argument_list|)
operator|=
name|REG_NOTES
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|temp
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|delete_insn
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|new_start
operator|==
literal|0
condition|)
name|new_start
operator|=
name|first
expr_stmt|;
block|}
if|if
condition|(
name|m
operator|->
name|savemode
operator|!=
name|VOIDmode
condition|)
block|{
comment|/* P sets REG to zero; but we should clear only 			     the bits that are not covered by the mode 			     m->savemode.  */
name|rtx
name|reg
init|=
name|m
operator|->
name|set_dest
decl_stmt|;
name|rtx
name|sequence
decl_stmt|;
name|rtx
name|tem
decl_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|tem
operator|=
name|expand_simple_binop
argument_list|(
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|,
name|AND
argument_list|,
name|reg
argument_list|,
name|GEN_INT
argument_list|(
operator|(
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|GET_MODE_BITSIZE
argument_list|(
name|m
operator|->
name|savemode
argument_list|)
operator|)
operator|)
operator|-
literal|1
argument_list|)
argument_list|,
name|reg
argument_list|,
literal|1
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|tem
operator|!=
name|reg
condition|)
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|tem
argument_list|)
expr_stmt|;
name|sequence
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|i1
operator|=
name|loop_insn_hoist
argument_list|(
name|loop
argument_list|,
name|sequence
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
name|i1
operator|=
name|loop_call_insn_hoist
argument_list|(
name|loop
argument_list|,
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Because the USAGE information potentially 			     contains objects other than hard registers 			     we need to copy it.  */
if|if
condition|(
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|p
argument_list|)
condition|)
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|i1
argument_list|)
operator|=
name|copy_rtx
argument_list|(
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|count
operator|==
name|m
operator|->
name|consec
operator|&&
name|m
operator|->
name|move_insn_first
condition|)
block|{
name|rtx
name|seq
decl_stmt|;
comment|/* The SET_SRC might not be invariant, so we must 			     use the REG_EQUAL note.  */
name|start_sequence
argument_list|()
expr_stmt|;
name|emit_move_insn
argument_list|(
name|m
operator|->
name|set_dest
argument_list|,
name|m
operator|->
name|set_src
argument_list|)
expr_stmt|;
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|add_label_notes
argument_list|(
name|m
operator|->
name|set_src
argument_list|,
name|seq
argument_list|)
expr_stmt|;
name|i1
operator|=
name|loop_insn_hoist
argument_list|(
name|loop
argument_list|,
name|seq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|find_reg_note
argument_list|(
name|i1
argument_list|,
name|REG_EQUAL
argument_list|,
name|NULL_RTX
argument_list|)
condition|)
name|set_unique_reg_note
argument_list|(
name|i1
argument_list|,
name|m
operator|->
name|is_equiv
condition|?
name|REG_EQUIV
else|:
name|REG_EQUAL
argument_list|,
name|m
operator|->
name|set_src
argument_list|)
expr_stmt|;
block|}
else|else
name|i1
operator|=
name|loop_insn_hoist
argument_list|(
name|loop
argument_list|,
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|REG_NOTES
argument_list|(
name|i1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|REG_NOTES
argument_list|(
name|i1
argument_list|)
operator|=
name|REG_NOTES
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|p
argument_list|)
operator|=
name|NULL
expr_stmt|;
comment|/* If there is a REG_EQUAL note present whose value 			     is not loop invariant, then delete it, since it 			     may cause problems with later optimization passes. 			     It is possible for cse to create such notes 			     like this as a result of record_jump_cond.  */
if|if
condition|(
operator|(
name|temp
operator|=
name|find_reg_note
argument_list|(
name|i1
argument_list|,
name|REG_EQUAL
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
operator|&&
operator|!
name|loop_invariant_p
argument_list|(
name|loop
argument_list|,
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|remove_note
argument_list|(
name|i1
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|new_start
operator|==
literal|0
condition|)
name|new_start
operator|=
name|i1
expr_stmt|;
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|" moved to %d"
argument_list|,
name|INSN_UID
argument_list|(
name|i1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If library call, now fix the REG_NOTES that contain 			 insn pointers, namely REG_LIBCALL on FIRST 			 and REG_RETVAL on I1.  */
if|if
condition|(
operator|(
name|temp
operator|=
name|find_reg_note
argument_list|(
name|i1
argument_list|,
name|REG_RETVAL
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
condition|)
block|{
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
operator|=
name|first
expr_stmt|;
name|temp
operator|=
name|find_reg_note
argument_list|(
name|first
argument_list|,
name|REG_LIBCALL
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
operator|=
name|i1
expr_stmt|;
block|}
name|temp
operator|=
name|p
expr_stmt|;
name|delete_insn
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* simplify_giv_expr expects that it can walk the insns 			 at m->insn forwards and see this old sequence we are 			 tossing here.  delete_insn does preserve the next 			 pointers, but when we skip over a NOTE we must fix 			 it up.  Otherwise that code walks into the non-deleted 			 insn stream.  */
while|while
condition|(
name|p
operator|&&
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|NOTE
condition|)
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|temp
argument_list|)
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
comment|/* The more regs we move, the less we like moving them.  */
name|threshold
operator|-=
literal|3
expr_stmt|;
block|}
comment|/* Any other movable that loads the same register 		 MUST be moved.  */
name|already_moved
index|[
name|regno
index|]
operator|=
literal|1
expr_stmt|;
comment|/* This reg has been moved out of one loop.  */
name|regs
operator|->
name|array
index|[
name|regno
index|]
operator|.
name|moved_once
operator|=
literal|1
expr_stmt|;
comment|/* The reg set here is now invariant.  */
if|if
condition|(
operator|!
name|m
operator|->
name|partial
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LOOP_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|m
operator|->
name|set_dest
argument_list|)
condition|;
name|i
operator|++
control|)
name|regs
operator|->
name|array
index|[
name|regno
operator|+
name|i
index|]
operator|.
name|set_in_loop
operator|=
literal|0
expr_stmt|;
block|}
name|m
operator|->
name|done
operator|=
literal|1
expr_stmt|;
comment|/* Change the length-of-life info for the register 		 to say it lives at least the full length of this loop. 		 This will help guide optimizations in outer loops.  */
if|if
condition|(
name|REGNO_FIRST_LUID
argument_list|(
name|regno
argument_list|)
operator|>
name|INSN_LUID
argument_list|(
name|loop_start
argument_list|)
condition|)
comment|/* This is the old insn before all the moved insns. 		   We can't use the moved insn because it is out of range 		   in uid_luid.  Only the old insns have luids.  */
name|REGNO_FIRST_UID
argument_list|(
name|regno
argument_list|)
operator|=
name|INSN_UID
argument_list|(
name|loop_start
argument_list|)
expr_stmt|;
if|if
condition|(
name|REGNO_LAST_LUID
argument_list|(
name|regno
argument_list|)
operator|<
name|INSN_LUID
argument_list|(
name|loop_end
argument_list|)
condition|)
name|REGNO_LAST_UID
argument_list|(
name|regno
argument_list|)
operator|=
name|INSN_UID
argument_list|(
name|loop_end
argument_list|)
expr_stmt|;
comment|/* Combine with this moved insn any other matching movables.  */
if|if
condition|(
operator|!
name|m
operator|->
name|partial
condition|)
for|for
control|(
name|m1
operator|=
name|movables
operator|->
name|head
init|;
name|m1
condition|;
name|m1
operator|=
name|m1
operator|->
name|next
control|)
if|if
condition|(
name|m1
operator|->
name|match
operator|==
name|m
condition|)
block|{
name|rtx
name|temp
decl_stmt|;
comment|/* Schedule the reg loaded by M1 			 for replacement so that shares the reg of M. 			 If the modes differ (only possible in restricted 			 circumstances, make a SUBREG.  			 Note this assumes that the target dependent files 			 treat REG and SUBREG equally, including within 			 GO_IF_LEGITIMATE_ADDRESS and in all the 			 predicates since we never verify that replacing the 			 original register with a SUBREG results in a 			 recognizable insn.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|m
operator|->
name|set_dest
argument_list|)
operator|==
name|GET_MODE
argument_list|(
name|m1
operator|->
name|set_dest
argument_list|)
condition|)
name|reg_map
index|[
name|m1
operator|->
name|regno
index|]
operator|=
name|m
operator|->
name|set_dest
expr_stmt|;
else|else
name|reg_map
index|[
name|m1
operator|->
name|regno
index|]
operator|=
name|gen_lowpart_common
argument_list|(
name|GET_MODE
argument_list|(
name|m1
operator|->
name|set_dest
argument_list|)
argument_list|,
name|m
operator|->
name|set_dest
argument_list|)
expr_stmt|;
comment|/* Get rid of the matching insn 			 and prevent further processing of it.  */
name|m1
operator|->
name|done
operator|=
literal|1
expr_stmt|;
comment|/* if library call, delete all insns.  */
if|if
condition|(
operator|(
name|temp
operator|=
name|find_reg_note
argument_list|(
name|m1
operator|->
name|insn
argument_list|,
name|REG_RETVAL
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
condition|)
name|delete_insn_chain
argument_list|(
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|m1
operator|->
name|insn
argument_list|)
expr_stmt|;
else|else
name|delete_insn
argument_list|(
name|m1
operator|->
name|insn
argument_list|)
expr_stmt|;
comment|/* Any other movable that loads the same register 			 MUST be moved.  */
name|already_moved
index|[
name|m1
operator|->
name|regno
index|]
operator|=
literal|1
expr_stmt|;
comment|/* The reg merged here is now invariant, 			 if the reg it matches is invariant.  */
if|if
condition|(
operator|!
name|m
operator|->
name|partial
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LOOP_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|m1
operator|->
name|set_dest
argument_list|)
condition|;
name|i
operator|++
control|)
name|regs
operator|->
name|array
index|[
name|m1
operator|->
name|regno
operator|+
name|i
index|]
operator|.
name|set_in_loop
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"not desirable"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|loop_dump_stream
operator|&&
operator|!
name|m
operator|->
name|match
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"not safe"
argument_list|)
expr_stmt|;
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|new_start
operator|==
literal|0
condition|)
name|new_start
operator|=
name|loop_start
expr_stmt|;
comment|/* Go through all the instructions in the loop, making      all the register substitutions scheduled in REG_MAP.  */
for|for
control|(
name|p
operator|=
name|new_start
init|;
name|p
operator|!=
name|loop_end
condition|;
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|JUMP_INSN
operator|||
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
name|replace_regs
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|,
name|reg_map
argument_list|,
name|nregs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|replace_regs
argument_list|(
name|REG_NOTES
argument_list|(
name|p
argument_list|)
argument_list|,
name|reg_map
argument_list|,
name|nregs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|INSN_CODE
argument_list|(
name|p
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* Clean up.  */
name|free
argument_list|(
name|reg_map
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|already_moved
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|loop_movables_add
parameter_list|(
name|movables
parameter_list|,
name|m
parameter_list|)
name|struct
name|loop_movables
modifier|*
name|movables
decl_stmt|;
name|struct
name|movable
modifier|*
name|m
decl_stmt|;
block|{
if|if
condition|(
name|movables
operator|->
name|head
operator|==
literal|0
condition|)
name|movables
operator|->
name|head
operator|=
name|m
expr_stmt|;
else|else
name|movables
operator|->
name|last
operator|->
name|next
operator|=
name|m
expr_stmt|;
name|movables
operator|->
name|last
operator|=
name|m
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|loop_movables_free
parameter_list|(
name|movables
parameter_list|)
name|struct
name|loop_movables
modifier|*
name|movables
decl_stmt|;
block|{
name|struct
name|movable
modifier|*
name|m
decl_stmt|;
name|struct
name|movable
modifier|*
name|m_next
decl_stmt|;
for|for
control|(
name|m
operator|=
name|movables
operator|->
name|head
init|;
name|m
condition|;
name|m
operator|=
name|m_next
control|)
block|{
name|m_next
operator|=
name|m
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Scan X and replace the address of any MEM in it with ADDR.    REG is the address that MEM should have before the replacement.  */
end_comment

begin_comment
unit|static void replace_call_address (x, reg, addr)      rtx x, reg, addr; {   enum rtx_code code;   int i;   const char *fmt;    if (x == 0)     return;   code = GET_CODE (x);   switch (code)     {     case PC:     case CC0:     case CONST_INT:     case CONST_DOUBLE:     case CONST:     case SYMBOL_REF:     case LABEL_REF:     case REG:       return;      case SET:
comment|/* Short cut for very common case.  */
end_comment

begin_comment
unit|replace_call_address (XEXP (x, 1), reg, addr);       return;      case CALL:
comment|/* Short cut for very common case.  */
end_comment

begin_comment
unit|replace_call_address (XEXP (x, 0), reg, addr);       return;      case MEM:
comment|/* If this MEM uses a reg other than the one we expected, 	 something is wrong.  */
end_comment

begin_endif
unit|if (XEXP (x, 0) != reg) 	abort ();       XEXP (x, 0) = addr;       return;      default:       break;     }    fmt = GET_RTX_FORMAT (code);   for (i = GET_RTX_LENGTH (code) - 1; i>= 0; i--)     {       if (fmt[i] == 'e') 	replace_call_address (XEXP (x, i), reg, addr);       else if (fmt[i] == 'E') 	{ 	  int j; 	  for (j = 0; j< XVECLEN (x, i); j++) 	    replace_call_address (XVECEXP (x, i, j), reg, addr); 	}     } }
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Return the number of memory refs to addresses that vary    in the rtx X.  */
end_comment

begin_function
specifier|static
name|int
name|count_nonfixed_reads
parameter_list|(
name|loop
parameter_list|,
name|x
parameter_list|)
specifier|const
name|struct
name|loop
modifier|*
name|loop
decl_stmt|;
name|rtx
name|x
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|value
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PC
case|:
case|case
name|CC0
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CONST
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
case|case
name|REG
case|:
return|return
literal|0
return|;
case|case
name|MEM
case|:
return|return
operator|(
operator|(
name|loop_invariant_p
argument_list|(
name|loop
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
literal|1
operator|)
operator|+
name|count_nonfixed_reads
argument_list|(
name|loop
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
return|;
default|default:
break|break;
block|}
name|value
operator|=
literal|0
expr_stmt|;
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|value
operator|+=
name|count_nonfixed_reads
argument_list|(
name|loop
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|value
operator|+=
name|count_nonfixed_reads
argument_list|(
name|loop
argument_list|,
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|value
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Scan a loop setting the elements `cont', `vtop', `loops_enclosed',    `has_call', `has_nonconst_call', `has_volatile', `has_tablejump',    `unknown_address_altered', `unknown_constant_address_altered', and    `num_mem_sets' in LOOP.  Also, fill in the array `mems' and the    list `store_mems' in LOOP.  */
end_comment

begin_function
specifier|static
name|void
name|prescan_loop
parameter_list|(
name|loop
parameter_list|)
name|struct
name|loop
modifier|*
name|loop
decl_stmt|;
block|{
name|int
name|level
init|=
literal|1
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|struct
name|loop_info
modifier|*
name|loop_info
init|=
name|LOOP_INFO
argument_list|(
name|loop
argument_list|)
decl_stmt|;
name|rtx
name|start
init|=
name|loop
operator|->
name|start
decl_stmt|;
name|rtx
name|end
init|=
name|loop
operator|->
name|end
decl_stmt|;
comment|/* The label after END.  Jumping here is just like falling off the      end of the loop.  We use next_nonnote_insn instead of next_label      as a hedge against the (pathological) case where some actual insn      might end up between the two.  */
name|rtx
name|exit_target
init|=
name|next_nonnote_insn
argument_list|(
name|end
argument_list|)
decl_stmt|;
name|loop_info
operator|->
name|has_indirect_jump
operator|=
name|indirect_jump_in_function
expr_stmt|;
name|loop_info
operator|->
name|pre_header_has_call
operator|=
literal|0
expr_stmt|;
name|loop_info
operator|->
name|has_call
operator|=
literal|0
expr_stmt|;
name|loop_info
operator|->
name|has_nonconst_call
operator|=
literal|0
expr_stmt|;
name|loop_info
operator|->
name|has_prefetch
operator|=
literal|0
expr_stmt|;
name|loop_info
operator|->
name|has_volatile
operator|=
literal|0
expr_stmt|;
name|loop_info
operator|->
name|has_tablejump
operator|=
literal|0
expr_stmt|;
name|loop_info
operator|->
name|has_multiple_exit_targets
operator|=
literal|0
expr_stmt|;
name|loop
operator|->
name|level
operator|=
literal|1
expr_stmt|;
name|loop_info
operator|->
name|unknown_address_altered
operator|=
literal|0
expr_stmt|;
name|loop_info
operator|->
name|unknown_constant_address_altered
operator|=
literal|0
expr_stmt|;
name|loop_info
operator|->
name|store_mems
operator|=
name|NULL_RTX
expr_stmt|;
name|loop_info
operator|->
name|first_loop_store_insn
operator|=
name|NULL_RTX
expr_stmt|;
name|loop_info
operator|->
name|mems_idx
operator|=
literal|0
expr_stmt|;
name|loop_info
operator|->
name|num_mem_sets
operator|=
literal|0
expr_stmt|;
comment|/* If loop opts run twice, this was set on 1st pass for 2nd.  */
name|loop_info
operator|->
name|preconditioned
operator|=
name|NOTE_PRECONDITIONED
argument_list|(
name|end
argument_list|)
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|start
init|;
name|insn
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|CODE_LABEL
condition|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
name|loop_info
operator|->
name|pre_header_has_call
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
for|for
control|(
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|start
argument_list|)
init|;
name|insn
operator|!=
name|NEXT_INSN
argument_list|(
name|end
argument_list|)
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
condition|)
block|{
case|case
name|NOTE
case|:
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_LOOP_BEG
condition|)
block|{
operator|++
name|level
expr_stmt|;
comment|/* Count number of loops contained in this one.  */
name|loop
operator|->
name|level
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_LOOP_END
condition|)
operator|--
name|level
expr_stmt|;
break|break;
case|case
name|CALL_INSN
case|:
if|if
condition|(
operator|!
name|CONST_OR_PURE_CALL_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|loop_info
operator|->
name|unknown_address_altered
operator|=
literal|1
expr_stmt|;
name|loop_info
operator|->
name|has_nonconst_call
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pure_call_p
argument_list|(
name|insn
argument_list|)
condition|)
name|loop_info
operator|->
name|has_nonconst_call
operator|=
literal|1
expr_stmt|;
name|loop_info
operator|->
name|has_call
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|can_throw_internal
argument_list|(
name|insn
argument_list|)
condition|)
name|loop_info
operator|->
name|has_multiple_exit_targets
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|JUMP_INSN
case|:
if|if
condition|(
operator|!
name|loop_info
operator|->
name|has_multiple_exit_targets
condition|)
block|{
name|rtx
name|set
init|=
name|pc_set
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|set
condition|)
block|{
name|rtx
name|src
init|=
name|SET_SRC
argument_list|(
name|set
argument_list|)
decl_stmt|;
name|rtx
name|label1
decl_stmt|,
name|label2
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|IF_THEN_ELSE
condition|)
block|{
name|label1
operator|=
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|label2
operator|=
name|XEXP
argument_list|(
name|src
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|label1
operator|=
name|src
expr_stmt|;
name|label2
operator|=
name|NULL_RTX
expr_stmt|;
block|}
do|do
block|{
if|if
condition|(
name|label1
operator|&&
name|label1
operator|!=
name|pc_rtx
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|label1
argument_list|)
operator|!=
name|LABEL_REF
condition|)
block|{
comment|/* Something tricky.  */
name|loop_info
operator|->
name|has_multiple_exit_targets
operator|=
literal|1
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|XEXP
argument_list|(
name|label1
argument_list|,
literal|0
argument_list|)
operator|!=
name|exit_target
operator|&&
name|LABEL_OUTSIDE_LOOP_P
argument_list|(
name|label1
argument_list|)
condition|)
block|{
comment|/* A jump outside the current loop.  */
name|loop_info
operator|->
name|has_multiple_exit_targets
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
name|label1
operator|=
name|label2
expr_stmt|;
name|label2
operator|=
name|NULL_RTX
expr_stmt|;
block|}
do|while
condition|(
name|label1
condition|)
do|;
block|}
else|else
block|{
comment|/* A return, or something tricky.  */
name|loop_info
operator|->
name|has_multiple_exit_targets
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* FALLTHRU */
case|case
name|INSN
case|:
if|if
condition|(
name|volatile_refs_p
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
name|loop_info
operator|->
name|has_volatile
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|ADDR_DIFF_VEC
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|ADDR_VEC
operator|)
condition|)
name|loop_info
operator|->
name|has_tablejump
operator|=
literal|1
expr_stmt|;
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|note_addr_stored
argument_list|,
name|loop_info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|loop_info
operator|->
name|first_loop_store_insn
operator|&&
name|loop_info
operator|->
name|store_mems
condition|)
name|loop_info
operator|->
name|first_loop_store_insn
operator|=
name|insn
expr_stmt|;
if|if
condition|(
name|flag_non_call_exceptions
operator|&&
name|can_throw_internal
argument_list|(
name|insn
argument_list|)
condition|)
name|loop_info
operator|->
name|has_multiple_exit_targets
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
comment|/* Now, rescan the loop, setting up the LOOP_MEMS array.  */
if|if
condition|(
comment|/* An exception thrown by a called function might land us 	 anywhere.  */
operator|!
name|loop_info
operator|->
name|has_nonconst_call
comment|/* We don't want loads for MEMs moved to a location before the 	 one at which their stack memory becomes allocated.  (Note 	 that this is not a problem for malloc, etc., since those 	 require actual function calls.  */
operator|&&
operator|!
name|current_function_calls_alloca
comment|/* There are ways to leave the loop other than falling off the 	 end.  */
operator|&&
operator|!
name|loop_info
operator|->
name|has_multiple_exit_targets
condition|)
for|for
control|(
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|start
argument_list|)
init|;
name|insn
operator|!=
name|NEXT_INSN
argument_list|(
name|end
argument_list|)
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
name|for_each_rtx
argument_list|(
operator|&
name|insn
argument_list|,
name|insert_loop_mem
argument_list|,
name|loop_info
argument_list|)
expr_stmt|;
comment|/* BLKmode MEMs are added to LOOP_STORE_MEM as necessary so      that loop_invariant_p and load_mems can use true_dependence      to determine what is really clobbered.  */
if|if
condition|(
name|loop_info
operator|->
name|unknown_address_altered
condition|)
block|{
name|rtx
name|mem
init|=
name|gen_rtx_MEM
argument_list|(
name|BLKmode
argument_list|,
name|const0_rtx
argument_list|)
decl_stmt|;
name|loop_info
operator|->
name|store_mems
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|mem
argument_list|,
name|loop_info
operator|->
name|store_mems
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|loop_info
operator|->
name|unknown_constant_address_altered
condition|)
block|{
name|rtx
name|mem
init|=
name|gen_rtx_MEM
argument_list|(
name|BLKmode
argument_list|,
name|const0_rtx
argument_list|)
decl_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|mem
argument_list|)
operator|=
literal|1
expr_stmt|;
name|loop_info
operator|->
name|store_mems
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|mem
argument_list|,
name|loop_info
operator|->
name|store_mems
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Invalidate all loops containing LABEL.  */
end_comment

begin_function
specifier|static
name|void
name|invalidate_loops_containing_label
parameter_list|(
name|label
parameter_list|)
name|rtx
name|label
decl_stmt|;
block|{
name|struct
name|loop
modifier|*
name|loop
decl_stmt|;
for|for
control|(
name|loop
operator|=
name|uid_loop
index|[
name|INSN_UID
argument_list|(
name|label
argument_list|)
index|]
init|;
name|loop
condition|;
name|loop
operator|=
name|loop
operator|->
name|outer
control|)
name|loop
operator|->
name|invalid
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Scan the function looking for loops.  Record the start and end of each loop.    Also mark as invalid loops any loops that contain a setjmp or are branched    to from outside the loop.  */
end_comment

begin_function
specifier|static
name|void
name|find_and_verify_loops
parameter_list|(
name|f
parameter_list|,
name|loops
parameter_list|)
name|rtx
name|f
decl_stmt|;
name|struct
name|loops
modifier|*
name|loops
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|;
name|rtx
name|label
decl_stmt|;
name|int
name|num_loops
decl_stmt|;
name|struct
name|loop
modifier|*
name|current_loop
decl_stmt|;
name|struct
name|loop
modifier|*
name|next_loop
decl_stmt|;
name|struct
name|loop
modifier|*
name|loop
decl_stmt|;
name|num_loops
operator|=
name|loops
operator|->
name|num
expr_stmt|;
name|compute_luids
argument_list|(
name|f
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If there are jumps to undefined labels,      treat them as jumps out of any/all loops.      This also avoids writing past end of tables when there are no loops.  */
name|uid_loop
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* Find boundaries of loops, mark which loops are contained within      loops, and invalidate loops that have setjmp.  */
name|num_loops
operator|=
literal|0
expr_stmt|;
name|current_loop
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|f
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
switch|switch
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
condition|)
block|{
case|case
name|NOTE_INSN_LOOP_BEG
case|:
name|next_loop
operator|=
name|loops
operator|->
name|array
operator|+
name|num_loops
expr_stmt|;
name|next_loop
operator|->
name|num
operator|=
name|num_loops
expr_stmt|;
name|num_loops
operator|++
expr_stmt|;
name|next_loop
operator|->
name|start
operator|=
name|insn
expr_stmt|;
name|next_loop
operator|->
name|outer
operator|=
name|current_loop
expr_stmt|;
name|current_loop
operator|=
name|next_loop
expr_stmt|;
break|break;
case|case
name|NOTE_INSN_LOOP_CONT
case|:
name|current_loop
operator|->
name|cont
operator|=
name|insn
expr_stmt|;
break|break;
case|case
name|NOTE_INSN_LOOP_VTOP
case|:
name|current_loop
operator|->
name|vtop
operator|=
name|insn
expr_stmt|;
break|break;
case|case
name|NOTE_INSN_LOOP_END
case|:
if|if
condition|(
operator|!
name|current_loop
condition|)
name|abort
argument_list|()
expr_stmt|;
name|current_loop
operator|->
name|end
operator|=
name|insn
expr_stmt|;
name|current_loop
operator|=
name|current_loop
operator|->
name|outer
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
operator|&&
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_SETJMP
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
comment|/* In this case, we must invalidate our current loop and any 	     enclosing loop.  */
for|for
control|(
name|loop
operator|=
name|current_loop
init|;
name|loop
condition|;
name|loop
operator|=
name|loop
operator|->
name|outer
control|)
block|{
name|loop
operator|->
name|invalid
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"\nLoop at %d ignored due to setjmp.\n"
argument_list|,
name|INSN_UID
argument_list|(
name|loop
operator|->
name|start
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Note that this will mark the NOTE_INSN_LOOP_END note as being in the 	 enclosing loop, but this doesn't matter.  */
name|uid_loop
index|[
name|INSN_UID
argument_list|(
name|insn
argument_list|)
index|]
operator|=
name|current_loop
expr_stmt|;
block|}
comment|/* Any loop containing a label used in an initializer must be invalidated,      because it can be jumped into from anywhere.  */
for|for
control|(
name|label
operator|=
name|forced_labels
init|;
name|label
condition|;
name|label
operator|=
name|XEXP
argument_list|(
name|label
argument_list|,
literal|1
argument_list|)
control|)
name|invalidate_loops_containing_label
argument_list|(
name|XEXP
argument_list|(
name|label
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Any loop containing a label used for an exception handler must be      invalidated, because it can be jumped into from anywhere.  */
name|for_each_eh_label
argument_list|(
name|invalidate_loops_containing_label
argument_list|)
expr_stmt|;
comment|/* Now scan all insn's in the function.  If any JUMP_INSN branches into a      loop that it is not contained within, that loop is marked invalid.      If any INSN or CALL_INSN uses a label's address, then the loop containing      that label is marked invalid, because it could be jumped into from      anywhere.       Also look for blocks of code ending in an unconditional branch that      exits the loop.  If such a block is surrounded by a conditional      branch around the block, move the block elsewhere (see below) and      invert the jump to point to the code block.  This may eliminate a      label in our loop and will simplify processing by both us and a      possible second cse pass.  */
for|for
control|(
name|insn
operator|=
name|f
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|struct
name|loop
modifier|*
name|this_loop
init|=
name|uid_loop
index|[
name|INSN_UID
argument_list|(
name|insn
argument_list|)
index|]
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
name|rtx
name|note
init|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_LABEL
argument_list|,
name|NULL_RTX
argument_list|)
decl_stmt|;
if|if
condition|(
name|note
condition|)
name|invalidate_loops_containing_label
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|JUMP_INSN
condition|)
continue|continue;
name|mark_loop_jump
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|this_loop
argument_list|)
expr_stmt|;
comment|/* See if this is an unconditional branch outside the loop.  */
if|if
condition|(
name|this_loop
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|RETURN
operator|||
operator|(
name|any_uncondjump_p
argument_list|(
name|insn
argument_list|)
operator|&&
name|onlyjump_p
argument_list|(
name|insn
argument_list|)
operator|&&
operator|(
name|uid_loop
index|[
name|INSN_UID
argument_list|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
argument_list|)
index|]
operator|!=
name|this_loop
operator|)
operator|)
operator|)
operator|&&
name|get_max_uid
argument_list|()
operator|<
name|max_uid_for_loop
condition|)
block|{
name|rtx
name|p
decl_stmt|;
name|rtx
name|our_next
init|=
name|next_real_insn
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|last_insn_to_move
init|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|struct
name|loop
modifier|*
name|dest_loop
decl_stmt|;
name|struct
name|loop
modifier|*
name|outer_loop
init|=
name|NULL
decl_stmt|;
comment|/* Go backwards until we reach the start of the loop, a label, 	       or a JUMP_INSN.  */
for|for
control|(
name|p
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
init|;
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|!=
name|CODE_LABEL
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|p
argument_list|)
operator|==
name|NOTE_INSN_LOOP_BEG
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|!=
name|JUMP_INSN
condition|;
name|p
operator|=
name|PREV_INSN
argument_list|(
name|p
argument_list|)
control|)
empty_stmt|;
comment|/* Check for the case where we have a jump to an inner nested 	       loop, and do not perform the optimization in that case.  */
if|if
condition|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|dest_loop
operator|=
name|uid_loop
index|[
name|INSN_UID
argument_list|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|dest_loop
condition|)
block|{
for|for
control|(
name|outer_loop
operator|=
name|dest_loop
init|;
name|outer_loop
condition|;
name|outer_loop
operator|=
name|outer_loop
operator|->
name|outer
control|)
if|if
condition|(
name|outer_loop
operator|==
name|this_loop
condition|)
break|break;
block|}
block|}
comment|/* Make sure that the target of P is within the current loop.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|JUMP_LABEL
argument_list|(
name|p
argument_list|)
operator|&&
name|uid_loop
index|[
name|INSN_UID
argument_list|(
name|JUMP_LABEL
argument_list|(
name|p
argument_list|)
argument_list|)
index|]
operator|!=
name|this_loop
condition|)
name|outer_loop
operator|=
name|this_loop
expr_stmt|;
comment|/* If we stopped on a JUMP_INSN to the next insn after INSN, 	       we have a block of code to try to move.  	       We look backward and then forward from the target of INSN 	       to find a BARRIER at the same loop depth as the target. 	       If we find such a BARRIER, we make a new label for the start 	       of the block, invert the jump in P and point it to that label, 	       and move the block of code to the spot we found.  */
if|if
condition|(
operator|!
name|outer_loop
operator|&&
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|JUMP_LABEL
argument_list|(
name|p
argument_list|)
operator|!=
literal|0
comment|/* Just ignore jumps to labels that were never emitted. 		   These always indicate compilation errors.  */
operator|&&
name|INSN_UID
argument_list|(
name|JUMP_LABEL
argument_list|(
name|p
argument_list|)
argument_list|)
operator|!=
literal|0
operator|&&
name|any_condjump_p
argument_list|(
name|p
argument_list|)
operator|&&
name|onlyjump_p
argument_list|(
name|p
argument_list|)
operator|&&
name|next_real_insn
argument_list|(
name|JUMP_LABEL
argument_list|(
name|p
argument_list|)
argument_list|)
operator|==
name|our_next
comment|/* If it's not safe to move the sequence, then we 		   mustn't try.  */
operator|&&
name|insns_safe_to_move_p
argument_list|(
name|p
argument_list|,
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|,
operator|&
name|last_insn_to_move
argument_list|)
condition|)
block|{
name|rtx
name|target
init|=
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
condition|?
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
else|:
name|get_last_insn
argument_list|()
decl_stmt|;
name|struct
name|loop
modifier|*
name|target_loop
init|=
name|uid_loop
index|[
name|INSN_UID
argument_list|(
name|target
argument_list|)
index|]
decl_stmt|;
name|rtx
name|loc
decl_stmt|,
name|loc2
decl_stmt|;
name|rtx
name|tmp
decl_stmt|;
comment|/* Search for possible garbage past the conditional jumps 		   and look for the last barrier.  */
for|for
control|(
name|tmp
operator|=
name|last_insn_to_move
init|;
name|tmp
operator|&&
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|!=
name|CODE_LABEL
condition|;
name|tmp
operator|=
name|NEXT_INSN
argument_list|(
name|tmp
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|BARRIER
condition|)
name|last_insn_to_move
operator|=
name|tmp
expr_stmt|;
for|for
control|(
name|loc
operator|=
name|target
init|;
name|loc
condition|;
name|loc
operator|=
name|PREV_INSN
argument_list|(
name|loc
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|loc
argument_list|)
operator|==
name|BARRIER
comment|/* Don't move things inside a tablejump.  */
operator|&&
operator|(
operator|(
name|loc2
operator|=
name|next_nonnote_insn
argument_list|(
name|loc
argument_list|)
operator|)
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|loc2
argument_list|)
operator|!=
name|CODE_LABEL
operator|||
operator|(
name|loc2
operator|=
name|next_nonnote_insn
argument_list|(
name|loc2
argument_list|)
operator|)
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|loc2
argument_list|)
operator|!=
name|JUMP_INSN
operator|||
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|loc2
argument_list|)
argument_list|)
operator|!=
name|ADDR_VEC
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|loc2
argument_list|)
argument_list|)
operator|!=
name|ADDR_DIFF_VEC
operator|)
operator|)
operator|&&
name|uid_loop
index|[
name|INSN_UID
argument_list|(
name|loc
argument_list|)
index|]
operator|==
name|target_loop
condition|)
break|break;
if|if
condition|(
name|loc
operator|==
literal|0
condition|)
for|for
control|(
name|loc
operator|=
name|target
init|;
name|loc
condition|;
name|loc
operator|=
name|NEXT_INSN
argument_list|(
name|loc
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|loc
argument_list|)
operator|==
name|BARRIER
comment|/* Don't move things inside a tablejump.  */
operator|&&
operator|(
operator|(
name|loc2
operator|=
name|next_nonnote_insn
argument_list|(
name|loc
argument_list|)
operator|)
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|loc2
argument_list|)
operator|!=
name|CODE_LABEL
operator|||
operator|(
name|loc2
operator|=
name|next_nonnote_insn
argument_list|(
name|loc2
argument_list|)
operator|)
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|loc2
argument_list|)
operator|!=
name|JUMP_INSN
operator|||
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|loc2
argument_list|)
argument_list|)
operator|!=
name|ADDR_VEC
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|loc2
argument_list|)
argument_list|)
operator|!=
name|ADDR_DIFF_VEC
operator|)
operator|)
operator|&&
name|uid_loop
index|[
name|INSN_UID
argument_list|(
name|loc
argument_list|)
index|]
operator|==
name|target_loop
condition|)
break|break;
if|if
condition|(
name|loc
condition|)
block|{
name|rtx
name|cond_label
init|=
name|JUMP_LABEL
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|rtx
name|new_label
init|=
name|get_label_after
argument_list|(
name|p
argument_list|)
decl_stmt|;
comment|/* Ensure our label doesn't go away.  */
name|LABEL_NUSES
argument_list|(
name|cond_label
argument_list|)
operator|++
expr_stmt|;
comment|/* Verify that uid_loop is large enough and that 		       we can invert P.  */
if|if
condition|(
name|invert_jump
argument_list|(
name|p
argument_list|,
name|new_label
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|rtx
name|q
decl_stmt|,
name|r
decl_stmt|;
comment|/* If no suitable BARRIER was found, create a suitable 			   one before TARGET.  Since TARGET is a fall through 			   path, we'll need to insert a jump around our block 			   and add a BARRIER before TARGET.  			   This creates an extra unconditional jump outside 			   the loop.  However, the benefits of removing rarely 			   executed instructions from inside the loop usually 			   outweighs the cost of the extra unconditional jump 			   outside the loop.  */
if|if
condition|(
name|loc
operator|==
literal|0
condition|)
block|{
name|rtx
name|temp
decl_stmt|;
name|temp
operator|=
name|gen_jump
argument_list|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|=
name|emit_jump_insn_before
argument_list|(
name|temp
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|JUMP_LABEL
argument_list|(
name|temp
argument_list|)
operator|=
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|LABEL_NUSES
argument_list|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|++
expr_stmt|;
name|loc
operator|=
name|emit_barrier_before
argument_list|(
name|target
argument_list|)
expr_stmt|;
block|}
comment|/* Include the BARRIER after INSN and copy the 			   block after LOC.  */
if|if
condition|(
name|squeeze_notes
argument_list|(
operator|&
name|new_label
argument_list|,
operator|&
name|last_insn_to_move
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|reorder_insns
argument_list|(
name|new_label
argument_list|,
name|last_insn_to_move
argument_list|,
name|loc
argument_list|)
expr_stmt|;
comment|/* All those insns are now in TARGET_LOOP.  */
for|for
control|(
name|q
operator|=
name|new_label
init|;
name|q
operator|!=
name|NEXT_INSN
argument_list|(
name|last_insn_to_move
argument_list|)
condition|;
name|q
operator|=
name|NEXT_INSN
argument_list|(
name|q
argument_list|)
control|)
name|uid_loop
index|[
name|INSN_UID
argument_list|(
name|q
argument_list|)
index|]
operator|=
name|target_loop
expr_stmt|;
comment|/* The label jumped to by INSN is no longer a loop 			   exit.  Unless INSN does not have a label (e.g., 			   it is a RETURN insn), search loop->exit_labels 			   to find its label_ref, and remove it.  Also turn 			   off LABEL_OUTSIDE_LOOP_P bit.  */
if|if
condition|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
condition|)
block|{
for|for
control|(
name|q
operator|=
literal|0
operator|,
name|r
operator|=
name|this_loop
operator|->
name|exit_labels
init|;
name|r
condition|;
name|q
operator|=
name|r
operator|,
name|r
operator|=
name|LABEL_NEXTREF
argument_list|(
name|r
argument_list|)
control|)
if|if
condition|(
name|XEXP
argument_list|(
name|r
argument_list|,
literal|0
argument_list|)
operator|==
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|LABEL_OUTSIDE_LOOP_P
argument_list|(
name|r
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|q
condition|)
name|LABEL_NEXTREF
argument_list|(
name|q
argument_list|)
operator|=
name|LABEL_NEXTREF
argument_list|(
name|r
argument_list|)
expr_stmt|;
else|else
name|this_loop
operator|->
name|exit_labels
operator|=
name|LABEL_NEXTREF
argument_list|(
name|r
argument_list|)
expr_stmt|;
break|break;
block|}
for|for
control|(
name|loop
operator|=
name|this_loop
init|;
name|loop
operator|&&
name|loop
operator|!=
name|target_loop
condition|;
name|loop
operator|=
name|loop
operator|->
name|outer
control|)
name|loop
operator|->
name|exit_count
operator|--
expr_stmt|;
comment|/* If we didn't find it, then something is 			       wrong.  */
if|if
condition|(
operator|!
name|r
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* P is now a jump outside the loop, so it must be put 			   in loop->exit_labels, and marked as such. 			   The easiest way to do this is to just call 			   mark_loop_jump again for P.  */
name|mark_loop_jump
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|,
name|this_loop
argument_list|)
expr_stmt|;
comment|/* If INSN now jumps to the insn after it, 			   delete INSN.  */
if|if
condition|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
operator|!=
literal|0
operator|&&
operator|(
name|next_real_insn
argument_list|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|next_real_insn
argument_list|(
name|insn
argument_list|)
operator|)
condition|)
name|delete_related_insns
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
comment|/* Continue the loop after where the conditional 		       branch used to jump, since the only branch insn 		       in the block (if it still remains) is an inter-loop 		       branch and hence needs no processing.  */
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|cond_label
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|LABEL_NUSES
argument_list|(
name|cond_label
argument_list|)
operator|==
literal|0
condition|)
name|delete_related_insns
argument_list|(
name|cond_label
argument_list|)
expr_stmt|;
comment|/* This loop will be continued with NEXT_INSN (insn).  */
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* If any label in X jumps to a loop different from LOOP_NUM and any of the    loops it is contained in, mark the target loop invalid.     For speed, we assume that X is part of a pattern of a JUMP_INSN.  */
end_comment

begin_function
specifier|static
name|void
name|mark_loop_jump
parameter_list|(
name|x
parameter_list|,
name|loop
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|struct
name|loop
modifier|*
name|loop
decl_stmt|;
block|{
name|struct
name|loop
modifier|*
name|dest_loop
decl_stmt|;
name|struct
name|loop
modifier|*
name|outer_loop
decl_stmt|;
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|PC
case|:
case|case
name|USE
case|:
case|case
name|CLOBBER
case|:
case|case
name|REG
case|:
case|case
name|MEM
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|RETURN
case|:
return|return;
case|case
name|CONST
case|:
comment|/* There could be a label reference in here.  */
name|mark_loop_jump
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|loop
argument_list|)
expr_stmt|;
return|return;
case|case
name|PLUS
case|:
case|case
name|MINUS
case|:
case|case
name|MULT
case|:
name|mark_loop_jump
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|loop
argument_list|)
expr_stmt|;
name|mark_loop_jump
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|loop
argument_list|)
expr_stmt|;
return|return;
case|case
name|LO_SUM
case|:
comment|/* This may refer to a LABEL_REF or SYMBOL_REF.  */
name|mark_loop_jump
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|loop
argument_list|)
expr_stmt|;
return|return;
case|case
name|SIGN_EXTEND
case|:
case|case
name|ZERO_EXTEND
case|:
name|mark_loop_jump
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|loop
argument_list|)
expr_stmt|;
return|return;
case|case
name|LABEL_REF
case|:
name|dest_loop
operator|=
name|uid_loop
index|[
name|INSN_UID
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
expr_stmt|;
comment|/* Link together all labels that branch outside the loop.  This 	 is used by final_[bg]iv_value and the loop unrolling code.  Also 	 mark this LABEL_REF so we know that this branch should predict 	 false.  */
comment|/* A check to make sure the label is not in an inner nested loop, 	 since this does not count as a loop exit.  */
if|if
condition|(
name|dest_loop
condition|)
block|{
for|for
control|(
name|outer_loop
operator|=
name|dest_loop
init|;
name|outer_loop
condition|;
name|outer_loop
operator|=
name|outer_loop
operator|->
name|outer
control|)
if|if
condition|(
name|outer_loop
operator|==
name|loop
condition|)
break|break;
block|}
else|else
name|outer_loop
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|loop
operator|&&
operator|!
name|outer_loop
condition|)
block|{
name|LABEL_OUTSIDE_LOOP_P
argument_list|(
name|x
argument_list|)
operator|=
literal|1
expr_stmt|;
name|LABEL_NEXTREF
argument_list|(
name|x
argument_list|)
operator|=
name|loop
operator|->
name|exit_labels
expr_stmt|;
name|loop
operator|->
name|exit_labels
operator|=
name|x
expr_stmt|;
for|for
control|(
name|outer_loop
operator|=
name|loop
init|;
name|outer_loop
operator|&&
name|outer_loop
operator|!=
name|dest_loop
condition|;
name|outer_loop
operator|=
name|outer_loop
operator|->
name|outer
control|)
name|outer_loop
operator|->
name|exit_count
operator|++
expr_stmt|;
block|}
comment|/* If this is inside a loop, but not in the current loop or one enclosed 	 by it, it invalidates at least one loop.  */
if|if
condition|(
operator|!
name|dest_loop
condition|)
return|return;
comment|/* We must invalidate every nested loop containing the target of this 	 label, except those that also contain the jump insn.  */
for|for
control|(
init|;
name|dest_loop
condition|;
name|dest_loop
operator|=
name|dest_loop
operator|->
name|outer
control|)
block|{
comment|/* Stop when we reach a loop that also contains the jump insn.  */
for|for
control|(
name|outer_loop
operator|=
name|loop
init|;
name|outer_loop
condition|;
name|outer_loop
operator|=
name|outer_loop
operator|->
name|outer
control|)
if|if
condition|(
name|dest_loop
operator|==
name|outer_loop
condition|)
return|return;
comment|/* If we get here, we know we need to invalidate a loop.  */
if|if
condition|(
name|loop_dump_stream
operator|&&
operator|!
name|dest_loop
operator|->
name|invalid
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"\nLoop at %d ignored due to multiple entry points.\n"
argument_list|,
name|INSN_UID
argument_list|(
name|dest_loop
operator|->
name|start
argument_list|)
argument_list|)
expr_stmt|;
name|dest_loop
operator|->
name|invalid
operator|=
literal|1
expr_stmt|;
block|}
return|return;
case|case
name|SET
case|:
comment|/* If this is not setting pc, ignore.  */
if|if
condition|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
operator|==
name|pc_rtx
condition|)
name|mark_loop_jump
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|loop
argument_list|)
expr_stmt|;
return|return;
case|case
name|IF_THEN_ELSE
case|:
name|mark_loop_jump
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|loop
argument_list|)
expr_stmt|;
name|mark_loop_jump
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
argument_list|,
name|loop
argument_list|)
expr_stmt|;
return|return;
case|case
name|PARALLEL
case|:
case|case
name|ADDR_VEC
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
name|mark_loop_jump
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|loop
argument_list|)
expr_stmt|;
return|return;
case|case
name|ADDR_DIFF_VEC
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
condition|;
name|i
operator|++
control|)
name|mark_loop_jump
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|,
name|i
argument_list|)
argument_list|,
name|loop
argument_list|)
expr_stmt|;
return|return;
default|default:
comment|/* Strictly speaking this is not a jump into the loop, only a possible 	 jump out of the loop.  However, we have no way to link the destination 	 of this jump onto the list of exit labels.  To be safe we mark this 	 loop and any containing loops as invalid.  */
if|if
condition|(
name|loop
condition|)
block|{
for|for
control|(
name|outer_loop
operator|=
name|loop
init|;
name|outer_loop
condition|;
name|outer_loop
operator|=
name|outer_loop
operator|->
name|outer
control|)
block|{
if|if
condition|(
name|loop_dump_stream
operator|&&
operator|!
name|outer_loop
operator|->
name|invalid
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"\nLoop at %d ignored due to unknown exit jump.\n"
argument_list|,
name|INSN_UID
argument_list|(
name|outer_loop
operator|->
name|start
argument_list|)
argument_list|)
expr_stmt|;
name|outer_loop
operator|->
name|invalid
operator|=
literal|1
expr_stmt|;
block|}
block|}
return|return;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return nonzero if there is a label in the range from    insn INSN to and including the insn whose luid is END    INSN must have an assigned luid (i.e., it must not have    been previously created by loop.c).  */
end_comment

begin_function
specifier|static
name|int
name|labels_in_range_p
parameter_list|(
name|insn
parameter_list|,
name|end
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|int
name|end
decl_stmt|;
block|{
while|while
condition|(
name|insn
operator|&&
name|INSN_LUID
argument_list|(
name|insn
argument_list|)
operator|<=
name|end
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
condition|)
return|return
literal|1
return|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Record that a memory reference X is being set.  */
end_comment

begin_function
specifier|static
name|void
name|note_addr_stored
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|data
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|rtx
name|y
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|struct
name|loop_info
modifier|*
name|loop_info
init|=
name|data
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|MEM
condition|)
return|return;
comment|/* Count number of memory writes.      This affects heuristics in strength_reduce.  */
name|loop_info
operator|->
name|num_mem_sets
operator|++
expr_stmt|;
comment|/* BLKmode MEM means all memory is clobbered.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|BLKmode
condition|)
block|{
if|if
condition|(
name|RTX_UNCHANGING_P
argument_list|(
name|x
argument_list|)
condition|)
name|loop_info
operator|->
name|unknown_constant_address_altered
operator|=
literal|1
expr_stmt|;
else|else
name|loop_info
operator|->
name|unknown_address_altered
operator|=
literal|1
expr_stmt|;
return|return;
block|}
name|loop_info
operator|->
name|store_mems
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|x
argument_list|,
name|loop_info
operator|->
name|store_mems
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* X is a value modified by an INSN that references a biv inside a loop    exit test (ie, X is somehow related to the value of the biv).  If X    is a pseudo that is used more than once, then the biv is (effectively)    used more than once.  DATA is a pointer to a loop_regs structure.  */
end_comment

begin_function
specifier|static
name|void
name|note_set_pseudo_multiple_uses
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|data
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|rtx
name|y
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
name|struct
name|loop_regs
modifier|*
name|regs
init|=
operator|(
expr|struct
name|loop_regs
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return;
while|while
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|STRICT_LOW_PART
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SIGN_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SUBREG
condition|)
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO
argument_list|(
name|x
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
return|return;
comment|/* If we do not have usage information, or if we know the register      is used more than once, note that fact for check_dbra_loop.  */
if|if
condition|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|>=
name|max_reg_before_loop
operator|||
operator|!
name|regs
operator|->
name|array
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
operator|.
name|single_usage
operator|||
name|regs
operator|->
name|array
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
operator|.
name|single_usage
operator|==
name|const0_rtx
condition|)
name|regs
operator|->
name|multiple_uses
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return nonzero if the rtx X is invariant over the current loop.     The value is 2 if we refer to something only conditionally invariant.     A memory ref is invariant if it is not volatile and does not conflict    with anything stored in `loop_info->store_mems'.  */
end_comment

begin_function
name|int
name|loop_invariant_p
parameter_list|(
name|loop
parameter_list|,
name|x
parameter_list|)
specifier|const
name|struct
name|loop
modifier|*
name|loop
decl_stmt|;
name|rtx
name|x
decl_stmt|;
block|{
name|struct
name|loop_info
modifier|*
name|loop_info
init|=
name|LOOP_INFO
argument_list|(
name|loop
argument_list|)
decl_stmt|;
name|struct
name|loop_regs
modifier|*
name|regs
init|=
name|LOOP_REGS
argument_list|(
name|loop
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|conditional
init|=
literal|0
decl_stmt|;
name|rtx
name|mem_list_entry
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return
literal|1
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|CONST
case|:
return|return
literal|1
return|;
case|case
name|LABEL_REF
case|:
comment|/* A LABEL_REF is normally invariant, however, if we are unrolling 	 loops, and this label is inside the loop, then it isn't invariant. 	 This is because each unrolled copy of the loop body will have 	 a copy of this label.  If this was invariant, then an insn loading 	 the address of this label into a register might get moved outside 	 the loop, and then each loop body would end up using the same label.  	 We don't know the loop bounds here though, so just fail for all 	 labels.  */
if|if
condition|(
name|flag_unroll_loops
condition|)
return|return
literal|0
return|;
else|else
return|return
literal|1
return|;
case|case
name|PC
case|:
case|case
name|CC0
case|:
case|case
name|UNSPEC_VOLATILE
case|:
return|return
literal|0
return|;
case|case
name|REG
case|:
comment|/* We used to check RTX_UNCHANGING_P (x) here, but that is invalid 	 since the reg might be set by initialization within the loop.  */
if|if
condition|(
operator|(
name|x
operator|==
name|frame_pointer_rtx
operator|||
name|x
operator|==
name|hard_frame_pointer_rtx
operator|||
name|x
operator|==
name|arg_pointer_rtx
operator|||
name|x
operator|==
name|pic_offset_table_rtx
operator|)
operator|&&
operator|!
name|current_function_has_nonlocal_goto
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|LOOP_INFO
argument_list|(
name|loop
argument_list|)
operator|->
name|has_call
operator|&&
name|REGNO
argument_list|(
name|x
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|call_used_regs
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
condition|)
return|return
literal|0
return|;
comment|/* Out-of-range regs can occur when we are called from unrolling. 	 These have always been created by the unroller and are set in 	 the loop, hence are never invariant. */
if|if
condition|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|>=
operator|(
name|unsigned
operator|)
name|regs
operator|->
name|num
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|regs
operator|->
name|array
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
operator|.
name|set_in_loop
operator|<
literal|0
condition|)
return|return
literal|2
return|;
return|return
name|regs
operator|->
name|array
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
operator|.
name|set_in_loop
operator|==
literal|0
return|;
case|case
name|MEM
case|:
comment|/* Volatile memory references must be rejected.  Do this before 	 checking for read-only items, so that volatile read-only items 	 will be rejected also.  */
if|if
condition|(
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* See if there is any dependence between a store and this load.  */
name|mem_list_entry
operator|=
name|loop_info
operator|->
name|store_mems
expr_stmt|;
while|while
condition|(
name|mem_list_entry
condition|)
block|{
if|if
condition|(
name|true_dependence
argument_list|(
name|XEXP
argument_list|(
name|mem_list_entry
argument_list|,
literal|0
argument_list|)
argument_list|,
name|VOIDmode
argument_list|,
name|x
argument_list|,
name|rtx_varies_p
argument_list|)
condition|)
return|return
literal|0
return|;
name|mem_list_entry
operator|=
name|XEXP
argument_list|(
name|mem_list_entry
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* It's not invalidated by a store in memory 	 but we must still verify the address is invariant.  */
break|break;
case|case
name|ASM_OPERANDS
case|:
comment|/* Don't mess with insns declared volatile.  */
if|if
condition|(
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
default|default:
break|break;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
name|int
name|tem
init|=
name|loop_invariant_p
argument_list|(
name|loop
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|tem
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|tem
operator|==
literal|2
condition|)
name|conditional
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
name|int
name|tem
init|=
name|loop_invariant_p
argument_list|(
name|loop
argument_list|,
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|tem
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|tem
operator|==
literal|2
condition|)
name|conditional
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
return|return
literal|1
operator|+
name|conditional
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return nonzero if all the insns in the loop that set REG    are INSN and the immediately following insns,    and if each of those insns sets REG in an invariant way    (not counting uses of REG in them).     The value is 2 if some of these insns are only conditionally invariant.     We assume that INSN itself is the first set of REG    and that its source is invariant.  */
end_comment

begin_function
specifier|static
name|int
name|consec_sets_invariant_p
parameter_list|(
name|loop
parameter_list|,
name|reg
parameter_list|,
name|n_sets
parameter_list|,
name|insn
parameter_list|)
specifier|const
name|struct
name|loop
modifier|*
name|loop
decl_stmt|;
name|int
name|n_sets
decl_stmt|;
name|rtx
name|reg
decl_stmt|,
name|insn
decl_stmt|;
block|{
name|struct
name|loop_regs
modifier|*
name|regs
init|=
name|LOOP_REGS
argument_list|(
name|loop
argument_list|)
decl_stmt|;
name|rtx
name|p
init|=
name|insn
decl_stmt|;
name|unsigned
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|reg
argument_list|)
decl_stmt|;
name|rtx
name|temp
decl_stmt|;
comment|/* Number of sets we have to insist on finding after INSN.  */
name|int
name|count
init|=
name|n_sets
operator|-
literal|1
decl_stmt|;
name|int
name|old
init|=
name|regs
operator|->
name|array
index|[
name|regno
index|]
operator|.
name|set_in_loop
decl_stmt|;
name|int
name|value
init|=
literal|0
decl_stmt|;
name|int
name|this
decl_stmt|;
comment|/* If N_SETS hit the limit, we can't rely on its value.  */
if|if
condition|(
name|n_sets
operator|==
literal|127
condition|)
return|return
literal|0
return|;
name|regs
operator|->
name|array
index|[
name|regno
index|]
operator|.
name|set_in_loop
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|enum
name|rtx_code
name|code
decl_stmt|;
name|rtx
name|set
decl_stmt|;
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* If library call, skip to end of it.  */
if|if
condition|(
name|code
operator|==
name|INSN
operator|&&
operator|(
name|temp
operator|=
name|find_reg_note
argument_list|(
name|p
argument_list|,
name|REG_LIBCALL
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
condition|)
name|p
operator|=
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|this
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|INSN
operator|&&
operator|(
name|set
operator|=
name|single_set
argument_list|(
name|p
argument_list|)
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|regno
condition|)
block|{
name|this
operator|=
name|loop_invariant_p
argument_list|(
name|loop
argument_list|,
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|!=
literal|0
condition|)
name|value
operator||=
name|this
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|temp
operator|=
name|find_reg_note
argument_list|(
name|p
argument_list|,
name|REG_EQUAL
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
condition|)
block|{
comment|/* If this is a libcall, then any invariant REG_EQUAL note is OK. 		 If this is an ordinary insn, then only CONSTANT_P REG_EQUAL 		 notes are OK.  */
name|this
operator|=
operator|(
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
operator|(
name|find_reg_note
argument_list|(
name|p
argument_list|,
name|REG_RETVAL
argument_list|,
name|NULL_RTX
argument_list|)
operator|&&
name|loop_invariant_p
argument_list|(
name|loop
argument_list|,
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|this
operator|!=
literal|0
condition|)
name|value
operator||=
name|this
expr_stmt|;
block|}
block|}
if|if
condition|(
name|this
operator|!=
literal|0
condition|)
name|count
operator|--
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|!=
name|NOTE
condition|)
block|{
name|regs
operator|->
name|array
index|[
name|regno
index|]
operator|.
name|set_in_loop
operator|=
name|old
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|regs
operator|->
name|array
index|[
name|regno
index|]
operator|.
name|set_in_loop
operator|=
name|old
expr_stmt|;
comment|/* If loop_invariant_p ever returned 2, we return 2.  */
return|return
literal|1
operator|+
operator|(
name|value
operator|&
literal|2
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* I don't think this condition is sufficient to allow INSN    to be moved, so we no longer test it.  */
end_comment

begin_comment
comment|/* Return 1 if all insns in the basic block of INSN and following INSN    that set REG are invariant according to TABLE.  */
end_comment

begin_endif
unit|static int all_sets_invariant_p (reg, insn, table)      rtx reg, insn;      short *table; {   rtx p = insn;   int regno = REGNO (reg);    while (1)     {       enum rtx_code code;       p = NEXT_INSN (p);       code = GET_CODE (p);       if (code == CODE_LABEL || code == JUMP_INSN) 	return 1;       if (code == INSN&& GET_CODE (PATTERN (p)) == SET&& GET_CODE (SET_DEST (PATTERN (p))) == REG&& REGNO (SET_DEST (PATTERN (p))) == regno) 	{ 	  if (! loop_invariant_p (loop, SET_SRC (PATTERN (p)), table)) 	    return 0; 	}     } }
endif|#
directive|endif
end_endif

begin_comment
comment|/* 0 */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Look at all uses (not sets) of registers in X.  For each, if it is    the single use, set USAGE[REGNO] to INSN; if there was a previous use in    a different insn, set USAGE[REGNO] to const0_rtx.  */
end_comment

begin_function
specifier|static
name|void
name|find_single_use_in_loop
parameter_list|(
name|regs
parameter_list|,
name|insn
parameter_list|,
name|x
parameter_list|)
name|struct
name|loop_regs
modifier|*
name|regs
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|rtx
name|x
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
init|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|REG
condition|)
name|regs
operator|->
name|array
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
operator|.
name|single_usage
operator|=
operator|(
name|regs
operator|->
name|array
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
operator|.
name|single_usage
operator|!=
literal|0
operator|&&
name|regs
operator|->
name|array
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
operator|.
name|single_usage
operator|!=
name|insn
operator|)
condition|?
name|const0_rtx
else|:
name|insn
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|SET
condition|)
block|{
comment|/* Don't count SET_DEST if it is a REG; otherwise count things 	 in SET_DEST because if a register is partially modified, it won't 	 show up as a potential movable so we don't care how USAGE is set 	 for it.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|REG
condition|)
name|find_single_use_in_loop
argument_list|(
name|regs
argument_list|,
name|insn
argument_list|,
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|find_single_use_in_loop
argument_list|(
name|regs
argument_list|,
name|insn
argument_list|,
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
operator|&&
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
literal|0
condition|)
name|find_single_use_in_loop
argument_list|(
name|regs
argument_list|,
name|insn
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
name|find_single_use_in_loop
argument_list|(
name|regs
argument_list|,
name|insn
argument_list|,
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Count and record any set in X which is contained in INSN.  Update    REGS->array[I].MAY_NOT_OPTIMIZE and LAST_SET for any register I set    in X.  */
end_comment

begin_function
specifier|static
name|void
name|count_one_set
parameter_list|(
name|regs
parameter_list|,
name|insn
parameter_list|,
name|x
parameter_list|,
name|last_set
parameter_list|)
name|struct
name|loop_regs
modifier|*
name|regs
decl_stmt|;
name|rtx
name|insn
decl_stmt|,
name|x
decl_stmt|;
name|rtx
modifier|*
name|last_set
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CLOBBER
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
comment|/* Don't move a reg that has an explicit clobber.        It's not worth the pain to try to do it correctly.  */
name|regs
operator|->
name|array
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
operator|.
name|may_not_optimize
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SET
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CLOBBER
condition|)
block|{
name|rtx
name|dest
init|=
name|SET_DEST
argument_list|(
name|x
argument_list|)
decl_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SIGN_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|STRICT_LOW_PART
condition|)
name|dest
operator|=
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
condition|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|dest
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LOOP_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|dest
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
comment|/* If this is the first setting of this reg 		 in current basic block, and it was set before, 		 it must be set in two basic blocks, so it cannot 		 be moved out of the loop.  */
if|if
condition|(
name|regs
operator|->
name|array
index|[
name|regno
index|]
operator|.
name|set_in_loop
operator|>
literal|0
operator|&&
name|last_set
operator|==
literal|0
condition|)
name|regs
operator|->
name|array
index|[
name|regno
operator|+
name|i
index|]
operator|.
name|may_not_optimize
operator|=
literal|1
expr_stmt|;
comment|/* If this is not first setting in current basic block, 		 see if reg was used in between previous one and this. 		 If so, neither one can be moved.  */
if|if
condition|(
name|last_set
index|[
name|regno
index|]
operator|!=
literal|0
operator|&&
name|reg_used_between_p
argument_list|(
name|dest
argument_list|,
name|last_set
index|[
name|regno
index|]
argument_list|,
name|insn
argument_list|)
condition|)
name|regs
operator|->
name|array
index|[
name|regno
operator|+
name|i
index|]
operator|.
name|may_not_optimize
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|regs
operator|->
name|array
index|[
name|regno
operator|+
name|i
index|]
operator|.
name|set_in_loop
operator|<
literal|127
condition|)
operator|++
name|regs
operator|->
name|array
index|[
name|regno
operator|+
name|i
index|]
operator|.
name|set_in_loop
expr_stmt|;
name|last_set
index|[
name|regno
operator|+
name|i
index|]
operator|=
name|insn
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a loop that is bounded by LOOP->START and LOOP->END and that    is entered at LOOP->SCAN_START, return 1 if the register set in SET    contained in insn INSN is used by any insn that precedes INSN in    cyclic order starting from the loop entry point.     We don't want to use INSN_LUID here because if we restrict INSN to those    that have a valid INSN_LUID, it means we cannot move an invariant out    from an inner loop past two loops.  */
end_comment

begin_function
specifier|static
name|int
name|loop_reg_used_before_p
parameter_list|(
name|loop
parameter_list|,
name|set
parameter_list|,
name|insn
parameter_list|)
specifier|const
name|struct
name|loop
modifier|*
name|loop
decl_stmt|;
name|rtx
name|set
decl_stmt|,
name|insn
decl_stmt|;
block|{
name|rtx
name|reg
init|=
name|SET_DEST
argument_list|(
name|set
argument_list|)
decl_stmt|;
name|rtx
name|p
decl_stmt|;
comment|/* Scan forward checking for register usage.  If we hit INSN, we      are done.  Otherwise, if we hit LOOP->END, wrap around to LOOP->START.  */
for|for
control|(
name|p
operator|=
name|loop
operator|->
name|scan_start
init|;
name|p
operator|!=
name|insn
condition|;
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
control|)
block|{
if|if
condition|(
name|INSN_P
argument_list|(
name|p
argument_list|)
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|reg
argument_list|,
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|p
operator|==
name|loop
operator|->
name|end
condition|)
name|p
operator|=
name|loop
operator|->
name|start
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Information we collect about arrays that we might want to prefetch.  */
end_comment

begin_struct
struct|struct
name|prefetch_info
block|{
name|struct
name|iv_class
modifier|*
name|class
decl_stmt|;
comment|/* Class this prefetch is based on.  */
name|struct
name|induction
modifier|*
name|giv
decl_stmt|;
comment|/* GIV this prefetch is based on.  */
name|rtx
name|base_address
decl_stmt|;
comment|/* Start prefetching from this address plus 				   index.  */
name|HOST_WIDE_INT
name|index
decl_stmt|;
name|HOST_WIDE_INT
name|stride
decl_stmt|;
comment|/* Prefetch stride in bytes in each 				   iteration.  */
name|unsigned
name|int
name|bytes_accessed
decl_stmt|;
comment|/* Sum of sizes of all accesses to this 				   prefetch area in one iteration.  */
name|unsigned
name|int
name|total_bytes
decl_stmt|;
comment|/* Total bytes loop will access in this block. 				   This is set only for loops with known 				   iteration counts and is 0xffffffff 				   otherwise.  */
name|int
name|prefetch_in_loop
decl_stmt|;
comment|/* Number of prefetch insns in loop.  */
name|int
name|prefetch_before_loop
decl_stmt|;
comment|/* Number of prefetch insns before loop.  */
name|unsigned
name|int
name|write
range|:
literal|1
decl_stmt|;
comment|/* 1 for read/write prefetches.  */
block|}
struct|;
end_struct

begin_comment
comment|/* Data used by check_store function.  */
end_comment

begin_struct
struct|struct
name|check_store_data
block|{
name|rtx
name|mem_address
decl_stmt|;
name|int
name|mem_write
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|void
name|check_store
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|emit_prefetch_instructions
name|PARAMS
argument_list|(
operator|(
expr|struct
name|loop
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|rtx_equal_for_prefetch_p
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set mem_write when mem_address is found.  Used as callback to    note_stores.  */
end_comment

begin_function
specifier|static
name|void
name|check_store
parameter_list|(
name|x
parameter_list|,
name|pat
parameter_list|,
name|data
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|pat
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
name|struct
name|check_store_data
modifier|*
name|d
init|=
operator|(
expr|struct
name|check_store_data
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
operator|)
operator|&&
name|rtx_equal_p
argument_list|(
name|d
operator|->
name|mem_address
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|d
operator|->
name|mem_write
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Like rtx_equal_p, but attempts to swap commutative operands.  This is    important to get some addresses combined.  Later more sophisticated    transformations can be added when necesary.     ??? Same trick with swapping operand is done at several other places.    It can be nice to develop some common way to handle this.  */
end_comment

begin_function
specifier|static
name|int
name|rtx_equal_for_prefetch_p
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|y
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|j
decl_stmt|;
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|x
operator|==
name|y
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|code
operator|!=
name|GET_CODE
argument_list|(
name|y
argument_list|)
condition|)
return|return
literal|0
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'c'
condition|)
block|{
return|return
operator|(
operator|(
name|rtx_equal_for_prefetch_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|rtx_equal_for_prefetch_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|rtx_equal_for_prefetch_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|rtx_equal_for_prefetch_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|)
return|;
block|}
comment|/* Compare the elements.  If any pair of corresponding elements fails to      match, return 0 for the whole thing.  */
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
switch|switch
condition|(
name|fmt
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'w'
case|:
if|if
condition|(
name|XWINT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
name|XWINT
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'i'
case|:
if|if
condition|(
name|XINT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
name|XINT
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'E'
case|:
comment|/* Two vectors must have the same length.  */
if|if
condition|(
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
name|XVECLEN
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* And the corresponding elements must match.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|rtx_equal_for_prefetch_p
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|XVECEXP
argument_list|(
name|y
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'e'
case|:
if|if
condition|(
name|rtx_equal_for_prefetch_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'s'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|XSTR
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|XSTR
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'u'
case|:
comment|/* These are just backpointers, so they don't matter.  */
break|break;
case|case
literal|'0'
case|:
break|break;
comment|/* It is believed that rtx's at this level will never 	     contain anything but integers and other rtx's, 	     except for within LABEL_REFs and SYMBOL_REFs.  */
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Remove constant addition value from the expression X (when present)    and return it.  */
end_comment

begin_function
specifier|static
name|HOST_WIDE_INT
name|remove_constant_addition
parameter_list|(
name|x
parameter_list|)
name|rtx
modifier|*
name|x
decl_stmt|;
block|{
name|HOST_WIDE_INT
name|addval
init|=
literal|0
decl_stmt|;
name|rtx
name|exp
init|=
operator|*
name|x
decl_stmt|;
comment|/* Avoid clobbering a shared CONST expression.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|CONST
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
operator|*
name|x
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|addval
operator|=
name|INTVAL
argument_list|(
name|exp
argument_list|)
expr_stmt|;
operator|*
name|x
operator|=
name|const0_rtx
expr_stmt|;
block|}
comment|/* For plus expression recurse on ourself.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|addval
operator|+=
name|remove_constant_addition
argument_list|(
operator|&
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|addval
operator|+=
name|remove_constant_addition
argument_list|(
operator|&
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* In case our parameter was constant, remove extra zero from the 	 expression.  */
if|if
condition|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
operator|==
name|const0_rtx
condition|)
operator|*
name|x
operator|=
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
operator|==
name|const0_rtx
condition|)
operator|*
name|x
operator|=
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|addval
return|;
block|}
end_function

begin_comment
comment|/* Attempt to identify accesses to arrays that are most likely to cause cache    misses, and emit prefetch instructions a few prefetch blocks forward.     To detect the arrays we use the GIV information that was collected by the    strength reduction pass.     The prefetch instructions are generated after the GIV information is done    and before the strength reduction process. The new GIVs are injected into    the strength reduction tables, so the prefetch addresses are optimized as    well.     GIVs are split into base address, stride, and constant addition values.    GIVs with the same address, stride and close addition values are combined    into a single prefetch.  Also writes to GIVs are detected, so that prefetch    for write instructions can be used for the block we write to, on machines    that support write prefetches.     Several heuristics are used to determine when to prefetch.  They are    controlled by defined symbols that can be overridden for each target.  */
end_comment

begin_function
specifier|static
name|void
name|emit_prefetch_instructions
parameter_list|(
name|loop
parameter_list|)
name|struct
name|loop
modifier|*
name|loop
decl_stmt|;
block|{
name|int
name|num_prefetches
init|=
literal|0
decl_stmt|;
name|int
name|num_real_prefetches
init|=
literal|0
decl_stmt|;
name|int
name|num_real_write_prefetches
init|=
literal|0
decl_stmt|;
name|int
name|num_prefetches_before
init|=
literal|0
decl_stmt|;
name|int
name|num_write_prefetches_before
init|=
literal|0
decl_stmt|;
name|int
name|ahead
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|iv_class
modifier|*
name|bl
decl_stmt|;
name|struct
name|induction
modifier|*
name|iv
decl_stmt|;
name|struct
name|prefetch_info
name|info
index|[
name|MAX_PREFETCHES
index|]
decl_stmt|;
name|struct
name|loop_ivs
modifier|*
name|ivs
init|=
name|LOOP_IVS
argument_list|(
name|loop
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|HAVE_prefetch
condition|)
return|return;
comment|/* Consider only loops w/o calls.  When a call is done, the loop is probably      slow enough to read the memory.  */
if|if
condition|(
name|PREFETCH_NO_CALL
operator|&&
name|LOOP_INFO
argument_list|(
name|loop
argument_list|)
operator|->
name|has_call
condition|)
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Prefetch: ignoring loop: has call.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Don't prefetch in loops known to have few iterations.  */
if|if
condition|(
name|PREFETCH_NO_LOW_LOOPCNT
operator|&&
name|LOOP_INFO
argument_list|(
name|loop
argument_list|)
operator|->
name|n_iterations
operator|&&
name|LOOP_INFO
argument_list|(
name|loop
argument_list|)
operator|->
name|n_iterations
operator|<=
name|PREFETCH_LOW_LOOPCNT
condition|)
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Prefetch: ignoring loop: not enough iterations.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Search all induction variables and pick those interesting for the prefetch      machinery.  */
for|for
control|(
name|bl
operator|=
name|ivs
operator|->
name|list
init|;
name|bl
condition|;
name|bl
operator|=
name|bl
operator|->
name|next
control|)
block|{
name|struct
name|induction
modifier|*
name|biv
init|=
name|bl
operator|->
name|biv
decl_stmt|,
modifier|*
name|biv1
decl_stmt|;
name|int
name|basestride
init|=
literal|0
decl_stmt|;
name|biv1
operator|=
name|biv
expr_stmt|;
comment|/* Expect all BIVs to be executed in each iteration.  This makes our 	 analysis more conservative.  */
while|while
condition|(
name|biv1
condition|)
block|{
comment|/* Discard non-constant additions that we can't handle well yet, and 	     BIVs that are executed multiple times; such BIVs ought to be 	     handled in the nested loop.  We accept not_every_iteration BIVs, 	     since these only result in larger strides and make our 	     heuristics more conservative.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|biv
operator|->
name|add_val
argument_list|)
operator|!=
name|CONST_INT
condition|)
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
block|{
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Prefetch: ignoring biv %d: non-constant addition at insn %d:"
argument_list|,
name|REGNO
argument_list|(
name|biv
operator|->
name|src_reg
argument_list|)
argument_list|,
name|INSN_UID
argument_list|(
name|biv
operator|->
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|print_rtl
argument_list|(
name|loop_dump_stream
argument_list|,
name|biv
operator|->
name|add_val
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|biv
operator|->
name|maybe_multiple
condition|)
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
block|{
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Prefetch: ignoring biv %d: maybe_multiple at insn %i:"
argument_list|,
name|REGNO
argument_list|(
name|biv
operator|->
name|src_reg
argument_list|)
argument_list|,
name|INSN_UID
argument_list|(
name|biv
operator|->
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|print_rtl
argument_list|(
name|loop_dump_stream
argument_list|,
name|biv
operator|->
name|add_val
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|basestride
operator|+=
name|INTVAL
argument_list|(
name|biv1
operator|->
name|add_val
argument_list|)
expr_stmt|;
name|biv1
operator|=
name|biv1
operator|->
name|next_iv
expr_stmt|;
block|}
if|if
condition|(
name|biv1
operator|||
operator|!
name|basestride
condition|)
continue|continue;
for|for
control|(
name|iv
operator|=
name|bl
operator|->
name|giv
init|;
name|iv
condition|;
name|iv
operator|=
name|iv
operator|->
name|next_iv
control|)
block|{
name|rtx
name|address
decl_stmt|;
name|rtx
name|temp
decl_stmt|;
name|HOST_WIDE_INT
name|index
init|=
literal|0
decl_stmt|;
name|int
name|add
init|=
literal|1
decl_stmt|;
name|HOST_WIDE_INT
name|stride
init|=
literal|0
decl_stmt|;
name|int
name|stride_sign
init|=
literal|1
decl_stmt|;
name|struct
name|check_store_data
name|d
decl_stmt|;
specifier|const
name|char
modifier|*
name|ignore_reason
init|=
name|NULL
decl_stmt|;
name|int
name|size
init|=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|iv
argument_list|)
argument_list|)
decl_stmt|;
comment|/* See whether an induction variable is interesting to us and if 	     not, report the reason.  */
if|if
condition|(
name|iv
operator|->
name|giv_type
operator|!=
name|DEST_ADDR
condition|)
name|ignore_reason
operator|=
literal|"giv is not a destination address"
expr_stmt|;
comment|/* We are interested only in constant stride memory references 	     in order to be able to compute density easily.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|iv
operator|->
name|mult_val
argument_list|)
operator|!=
name|CONST_INT
condition|)
name|ignore_reason
operator|=
literal|"stride is not constant"
expr_stmt|;
else|else
block|{
name|stride
operator|=
name|INTVAL
argument_list|(
name|iv
operator|->
name|mult_val
argument_list|)
operator|*
name|basestride
expr_stmt|;
if|if
condition|(
name|stride
operator|<
literal|0
condition|)
block|{
name|stride
operator|=
operator|-
name|stride
expr_stmt|;
name|stride_sign
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* On some targets, reversed order prefetches are not 		 worthwhile.  */
if|if
condition|(
name|PREFETCH_NO_REVERSE_ORDER
operator|&&
name|stride_sign
operator|<
literal|0
condition|)
name|ignore_reason
operator|=
literal|"reversed order stride"
expr_stmt|;
comment|/* Prefetch of accesses with an extreme stride might not be 		 worthwhile, either.  */
elseif|else
if|if
condition|(
name|PREFETCH_NO_EXTREME_STRIDE
operator|&&
name|stride
operator|>
name|PREFETCH_EXTREME_STRIDE
condition|)
name|ignore_reason
operator|=
literal|"extreme stride"
expr_stmt|;
comment|/* Ignore GIVs with varying add values; we can't predict the 		 value for the next iteration.  */
elseif|else
if|if
condition|(
operator|!
name|loop_invariant_p
argument_list|(
name|loop
argument_list|,
name|iv
operator|->
name|add_val
argument_list|)
condition|)
name|ignore_reason
operator|=
literal|"giv has varying add value"
expr_stmt|;
comment|/* Ignore GIVs in the nested loops; they ought to have been 		 handled already.  */
elseif|else
if|if
condition|(
name|iv
operator|->
name|maybe_multiple
condition|)
name|ignore_reason
operator|=
literal|"giv is in nested loop"
expr_stmt|;
block|}
if|if
condition|(
name|ignore_reason
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Prefetch: ignoring giv at %d: %s.\n"
argument_list|,
name|INSN_UID
argument_list|(
name|iv
operator|->
name|insn
argument_list|)
argument_list|,
name|ignore_reason
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Determine the pointer to the basic array we are examining.  It is 	     the sum of the BIV's initial value and the GIV's add_val.  */
name|address
operator|=
name|copy_rtx
argument_list|(
name|iv
operator|->
name|add_val
argument_list|)
expr_stmt|;
name|temp
operator|=
name|copy_rtx
argument_list|(
name|bl
operator|->
name|initial_value
argument_list|)
expr_stmt|;
name|address
operator|=
name|simplify_gen_binary
argument_list|(
name|PLUS
argument_list|,
name|Pmode
argument_list|,
name|temp
argument_list|,
name|address
argument_list|)
expr_stmt|;
name|index
operator|=
name|remove_constant_addition
argument_list|(
operator|&
name|address
argument_list|)
expr_stmt|;
name|d
operator|.
name|mem_write
operator|=
literal|0
expr_stmt|;
name|d
operator|.
name|mem_address
operator|=
operator|*
name|iv
operator|->
name|location
expr_stmt|;
comment|/* When the GIV is not always executed, we might be better off by 	     not dirtying the cache pages.  */
if|if
condition|(
name|PREFETCH_CONDITIONAL
operator|||
name|iv
operator|->
name|always_executed
condition|)
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|iv
operator|->
name|insn
argument_list|)
argument_list|,
name|check_store
argument_list|,
operator|&
name|d
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Prefetch: Ignoring giv at %d: %s\n"
argument_list|,
name|INSN_UID
argument_list|(
name|iv
operator|->
name|insn
argument_list|)
argument_list|,
literal|"in conditional code."
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Attempt to find another prefetch to the same array and see if we 	     can merge this one.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_prefetches
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|rtx_equal_for_prefetch_p
argument_list|(
name|address
argument_list|,
name|info
index|[
name|i
index|]
operator|.
name|base_address
argument_list|)
operator|&&
name|stride
operator|==
name|info
index|[
name|i
index|]
operator|.
name|stride
condition|)
block|{
comment|/* In case both access same array (same location 		   just with small difference in constant indexes), merge 		   the prefetches.  Just do the later and the earlier will 		   get prefetched from previous iteration. 		   The artificial threshold should not be too small, 		   but also not bigger than small portion of memory usually 		   traversed by single loop.  */
if|if
condition|(
name|index
operator|>=
name|info
index|[
name|i
index|]
operator|.
name|index
operator|&&
name|index
operator|-
name|info
index|[
name|i
index|]
operator|.
name|index
operator|<
name|PREFETCH_EXTREME_DIFFERENCE
condition|)
block|{
name|info
index|[
name|i
index|]
operator|.
name|write
operator||=
name|d
operator|.
name|mem_write
expr_stmt|;
name|info
index|[
name|i
index|]
operator|.
name|bytes_accessed
operator|+=
name|size
expr_stmt|;
name|info
index|[
name|i
index|]
operator|.
name|index
operator|=
name|index
expr_stmt|;
name|info
index|[
name|i
index|]
operator|.
name|giv
operator|=
name|iv
expr_stmt|;
name|info
index|[
name|i
index|]
operator|.
name|class
operator|=
name|bl
expr_stmt|;
name|info
index|[
name|num_prefetches
index|]
operator|.
name|base_address
operator|=
name|address
expr_stmt|;
name|add
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|index
operator|<
name|info
index|[
name|i
index|]
operator|.
name|index
operator|&&
name|info
index|[
name|i
index|]
operator|.
name|index
operator|-
name|index
operator|<
name|PREFETCH_EXTREME_DIFFERENCE
condition|)
block|{
name|info
index|[
name|i
index|]
operator|.
name|write
operator||=
name|d
operator|.
name|mem_write
expr_stmt|;
name|info
index|[
name|i
index|]
operator|.
name|bytes_accessed
operator|+=
name|size
expr_stmt|;
name|add
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
comment|/* Merging failed.  */
if|if
condition|(
name|add
condition|)
block|{
name|info
index|[
name|num_prefetches
index|]
operator|.
name|giv
operator|=
name|iv
expr_stmt|;
name|info
index|[
name|num_prefetches
index|]
operator|.
name|class
operator|=
name|bl
expr_stmt|;
name|info
index|[
name|num_prefetches
index|]
operator|.
name|index
operator|=
name|index
expr_stmt|;
name|info
index|[
name|num_prefetches
index|]
operator|.
name|stride
operator|=
name|stride
expr_stmt|;
name|info
index|[
name|num_prefetches
index|]
operator|.
name|base_address
operator|=
name|address
expr_stmt|;
name|info
index|[
name|num_prefetches
index|]
operator|.
name|write
operator|=
name|d
operator|.
name|mem_write
expr_stmt|;
name|info
index|[
name|num_prefetches
index|]
operator|.
name|bytes_accessed
operator|=
name|size
expr_stmt|;
name|num_prefetches
operator|++
expr_stmt|;
if|if
condition|(
name|num_prefetches
operator|>=
name|MAX_PREFETCHES
condition|)
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Maximal number of prefetches exceeded.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_prefetches
condition|;
name|i
operator|++
control|)
block|{
name|int
name|density
decl_stmt|;
comment|/* Attempt to calculate the total number of bytes fetched by all 	 iterations of the loop.  Avoid overflow.  */
if|if
condition|(
name|LOOP_INFO
argument_list|(
name|loop
argument_list|)
operator|->
name|n_iterations
operator|&&
operator|(
call|(
name|unsigned
name|HOST_WIDE_INT
call|)
argument_list|(
literal|0xffffffff
operator|/
name|info
index|[
name|i
index|]
operator|.
name|stride
argument_list|)
operator|>=
name|LOOP_INFO
argument_list|(
name|loop
argument_list|)
operator|->
name|n_iterations
operator|)
condition|)
name|info
index|[
name|i
index|]
operator|.
name|total_bytes
operator|=
name|info
index|[
name|i
index|]
operator|.
name|stride
operator|*
name|LOOP_INFO
argument_list|(
name|loop
argument_list|)
operator|->
name|n_iterations
expr_stmt|;
else|else
name|info
index|[
name|i
index|]
operator|.
name|total_bytes
operator|=
literal|0xffffffff
expr_stmt|;
name|density
operator|=
name|info
index|[
name|i
index|]
operator|.
name|bytes_accessed
operator|*
literal|100
operator|/
name|info
index|[
name|i
index|]
operator|.
name|stride
expr_stmt|;
comment|/* Prefetch might be worthwhile only when the loads/stores are dense.  */
if|if
condition|(
name|PREFETCH_ONLY_DENSE_MEM
condition|)
if|if
condition|(
name|density
operator|*
literal|256
operator|>
name|PREFETCH_DENSE_MEM
operator|*
literal|100
operator|&&
operator|(
name|info
index|[
name|i
index|]
operator|.
name|total_bytes
operator|/
name|PREFETCH_BLOCK
operator|>=
name|PREFETCH_BLOCKS_BEFORE_LOOP_MIN
operator|)
condition|)
block|{
name|info
index|[
name|i
index|]
operator|.
name|prefetch_before_loop
operator|=
literal|1
expr_stmt|;
name|info
index|[
name|i
index|]
operator|.
name|prefetch_in_loop
operator|=
operator|(
name|info
index|[
name|i
index|]
operator|.
name|total_bytes
operator|/
name|PREFETCH_BLOCK
operator|>
name|PREFETCH_BLOCKS_BEFORE_LOOP_MAX
operator|)
expr_stmt|;
block|}
else|else
block|{
name|info
index|[
name|i
index|]
operator|.
name|prefetch_in_loop
operator|=
literal|0
operator|,
name|info
index|[
name|i
index|]
operator|.
name|prefetch_before_loop
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Prefetch: ignoring giv at %d: %d%% density is too low.\n"
argument_list|,
name|INSN_UID
argument_list|(
name|info
index|[
name|i
index|]
operator|.
name|giv
operator|->
name|insn
argument_list|)
argument_list|,
name|density
argument_list|)
expr_stmt|;
block|}
else|else
name|info
index|[
name|i
index|]
operator|.
name|prefetch_in_loop
operator|=
literal|1
operator|,
name|info
index|[
name|i
index|]
operator|.
name|prefetch_before_loop
operator|=
literal|1
expr_stmt|;
comment|/* Find how many prefetch instructions we'll use within the loop.  */
if|if
condition|(
name|info
index|[
name|i
index|]
operator|.
name|prefetch_in_loop
operator|!=
literal|0
condition|)
block|{
name|info
index|[
name|i
index|]
operator|.
name|prefetch_in_loop
operator|=
operator|(
operator|(
name|info
index|[
name|i
index|]
operator|.
name|stride
operator|+
name|PREFETCH_BLOCK
operator|-
literal|1
operator|)
operator|/
name|PREFETCH_BLOCK
operator|)
expr_stmt|;
name|num_real_prefetches
operator|+=
name|info
index|[
name|i
index|]
operator|.
name|prefetch_in_loop
expr_stmt|;
if|if
condition|(
name|info
index|[
name|i
index|]
operator|.
name|write
condition|)
name|num_real_write_prefetches
operator|+=
name|info
index|[
name|i
index|]
operator|.
name|prefetch_in_loop
expr_stmt|;
block|}
block|}
comment|/* Determine how many iterations ahead to prefetch within the loop, based      on how many prefetches we currently expect to do within the loop.  */
if|if
condition|(
name|num_real_prefetches
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|ahead
operator|=
name|SIMULTANEOUS_PREFETCHES
operator|/
name|num_real_prefetches
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Prefetch: ignoring prefetches within loop: ahead is zero; %d< %d\n"
argument_list|,
name|SIMULTANEOUS_PREFETCHES
argument_list|,
name|num_real_prefetches
argument_list|)
expr_stmt|;
name|num_real_prefetches
operator|=
literal|0
operator|,
name|num_real_write_prefetches
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* We'll also use AHEAD to determine how many prefetch instructions to      emit before a loop, so don't leave it zero.  */
if|if
condition|(
name|ahead
operator|==
literal|0
condition|)
name|ahead
operator|=
name|PREFETCH_BLOCKS_BEFORE_LOOP_MAX
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_prefetches
condition|;
name|i
operator|++
control|)
block|{
comment|/* Update if we've decided not to prefetch anything within the loop.  */
if|if
condition|(
name|num_real_prefetches
operator|==
literal|0
condition|)
name|info
index|[
name|i
index|]
operator|.
name|prefetch_in_loop
operator|=
literal|0
expr_stmt|;
comment|/* Find how many prefetch instructions we'll use before the loop.  */
if|if
condition|(
name|info
index|[
name|i
index|]
operator|.
name|prefetch_before_loop
operator|!=
literal|0
condition|)
block|{
name|int
name|n
init|=
name|info
index|[
name|i
index|]
operator|.
name|total_bytes
operator|/
name|PREFETCH_BLOCK
decl_stmt|;
if|if
condition|(
name|n
operator|>
name|ahead
condition|)
name|n
operator|=
name|ahead
expr_stmt|;
name|info
index|[
name|i
index|]
operator|.
name|prefetch_before_loop
operator|=
name|n
expr_stmt|;
name|num_prefetches_before
operator|+=
name|n
expr_stmt|;
if|if
condition|(
name|info
index|[
name|i
index|]
operator|.
name|write
condition|)
name|num_write_prefetches_before
operator|+=
name|n
expr_stmt|;
block|}
if|if
condition|(
name|loop_dump_stream
condition|)
block|{
if|if
condition|(
name|info
index|[
name|i
index|]
operator|.
name|prefetch_in_loop
operator|==
literal|0
operator|&&
name|info
index|[
name|i
index|]
operator|.
name|prefetch_before_loop
operator|==
literal|0
condition|)
continue|continue;
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Prefetch insn: %d"
argument_list|,
name|INSN_UID
argument_list|(
name|info
index|[
name|i
index|]
operator|.
name|giv
operator|->
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"; in loop: %d; before: %d; %s\n"
argument_list|,
name|info
index|[
name|i
index|]
operator|.
name|prefetch_in_loop
argument_list|,
name|info
index|[
name|i
index|]
operator|.
name|prefetch_before_loop
argument_list|,
name|info
index|[
name|i
index|]
operator|.
name|write
condition|?
literal|"read/write"
else|:
literal|"read only"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|" density: %d%%; bytes_accessed: %u; total_bytes: %u\n"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|info
index|[
name|i
index|]
operator|.
name|bytes_accessed
operator|*
literal|100
operator|/
name|info
index|[
name|i
index|]
operator|.
name|stride
argument_list|)
argument_list|,
name|info
index|[
name|i
index|]
operator|.
name|bytes_accessed
argument_list|,
name|info
index|[
name|i
index|]
operator|.
name|total_bytes
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|" index: "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|info
index|[
name|i
index|]
operator|.
name|index
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"; stride: "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|info
index|[
name|i
index|]
operator|.
name|stride
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"; address: "
argument_list|)
expr_stmt|;
name|print_rtl
argument_list|(
name|loop_dump_stream
argument_list|,
name|info
index|[
name|i
index|]
operator|.
name|base_address
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|num_real_prefetches
operator|+
name|num_prefetches_before
operator|>
literal|0
condition|)
block|{
comment|/* Record that this loop uses prefetch instructions.  */
name|LOOP_INFO
argument_list|(
name|loop
argument_list|)
operator|->
name|has_prefetch
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|loop_dump_stream
condition|)
block|{
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Real prefetches needed within loop: %d (write: %d)\n"
argument_list|,
name|num_real_prefetches
argument_list|,
name|num_real_write_prefetches
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Real prefetches needed before loop: %d (write: %d)\n"
argument_list|,
name|num_prefetches_before
argument_list|,
name|num_write_prefetches_before
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_prefetches
condition|;
name|i
operator|++
control|)
block|{
name|int
name|y
decl_stmt|;
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|info
index|[
name|i
index|]
operator|.
name|prefetch_in_loop
condition|;
name|y
operator|++
control|)
block|{
name|rtx
name|loc
init|=
name|copy_rtx
argument_list|(
operator|*
name|info
index|[
name|i
index|]
operator|.
name|giv
operator|->
name|location
argument_list|)
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|int
name|bytes_ahead
init|=
name|PREFETCH_BLOCK
operator|*
operator|(
name|ahead
operator|+
name|y
operator|)
decl_stmt|;
name|rtx
name|before_insn
init|=
name|info
index|[
name|i
index|]
operator|.
name|giv
operator|->
name|insn
decl_stmt|;
name|rtx
name|prev_insn
init|=
name|PREV_INSN
argument_list|(
name|info
index|[
name|i
index|]
operator|.
name|giv
operator|->
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|seq
decl_stmt|;
comment|/* We can save some effort by offsetting the address on 	     architectures with offsettable memory references.  */
if|if
condition|(
name|offsettable_address_p
argument_list|(
literal|0
argument_list|,
name|VOIDmode
argument_list|,
name|loc
argument_list|)
condition|)
name|loc
operator|=
name|plus_constant
argument_list|(
name|loc
argument_list|,
name|bytes_ahead
argument_list|)
expr_stmt|;
else|else
block|{
name|rtx
name|reg
init|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
decl_stmt|;
name|loop_iv_add_mult_emit_before
argument_list|(
name|loop
argument_list|,
name|loc
argument_list|,
name|const1_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|bytes_ahead
argument_list|)
argument_list|,
name|reg
argument_list|,
literal|0
argument_list|,
name|before_insn
argument_list|)
expr_stmt|;
name|loc
operator|=
name|reg
expr_stmt|;
block|}
name|start_sequence
argument_list|()
expr_stmt|;
comment|/* Make sure the address operand is valid for prefetch.  */
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
operator|(
name|int
operator|)
name|CODE_FOR_prefetch
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|loc
operator|,
name|insn_data
index|[
operator|(
name|int
operator|)
name|CODE_FOR_prefetch
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
operator|)
condition|)
name|loc
operator|=
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_prefetch
argument_list|(
name|loc
argument_list|,
name|GEN_INT
argument_list|(
name|info
index|[
name|i
index|]
operator|.
name|write
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
literal|3
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_insn_before
argument_list|(
name|seq
argument_list|,
name|before_insn
argument_list|)
expr_stmt|;
comment|/* Check all insns emitted and record the new GIV 	     information.  */
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|prev_insn
argument_list|)
expr_stmt|;
while|while
condition|(
name|insn
operator|!=
name|before_insn
condition|)
block|{
name|insn
operator|=
name|check_insn_for_givs
argument_list|(
name|loop
argument_list|,
name|insn
argument_list|,
name|info
index|[
name|i
index|]
operator|.
name|giv
operator|->
name|always_executed
argument_list|,
name|info
index|[
name|i
index|]
operator|.
name|giv
operator|->
name|maybe_multiple
argument_list|)
expr_stmt|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|PREFETCH_BEFORE_LOOP
condition|)
block|{
comment|/* Emit insns before the loop to fetch the first cache lines or, 	     if we're not prefetching within the loop, everything we expect 	     to need.  */
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|info
index|[
name|i
index|]
operator|.
name|prefetch_before_loop
condition|;
name|y
operator|++
control|)
block|{
name|rtx
name|reg
init|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
decl_stmt|;
name|rtx
name|loop_start
init|=
name|loop
operator|->
name|start
decl_stmt|;
name|rtx
name|init_val
init|=
name|info
index|[
name|i
index|]
operator|.
name|class
operator|->
name|initial_value
decl_stmt|;
name|rtx
name|add_val
init|=
name|simplify_gen_binary
argument_list|(
name|PLUS
argument_list|,
name|Pmode
argument_list|,
name|info
index|[
name|i
index|]
operator|.
name|giv
operator|->
name|add_val
argument_list|,
name|GEN_INT
argument_list|(
name|y
operator|*
name|PREFETCH_BLOCK
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Functions called by LOOP_IV_ADD_EMIT_BEFORE expect a 		 non-constant INIT_VAL to have the same mode as REG, which 		 in this case we know to be Pmode.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|init_val
argument_list|)
operator|!=
name|Pmode
operator|&&
operator|!
name|CONSTANT_P
argument_list|(
name|init_val
argument_list|)
condition|)
block|{
name|rtx
name|seq
decl_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|init_val
operator|=
name|convert_to_mode
argument_list|(
name|Pmode
argument_list|,
name|init_val
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|loop_insn_emit_before
argument_list|(
name|loop
argument_list|,
literal|0
argument_list|,
name|loop_start
argument_list|,
name|seq
argument_list|)
expr_stmt|;
block|}
name|loop_iv_add_mult_emit_before
argument_list|(
name|loop
argument_list|,
name|init_val
argument_list|,
name|info
index|[
name|i
index|]
operator|.
name|giv
operator|->
name|mult_val
argument_list|,
name|add_val
argument_list|,
name|reg
argument_list|,
literal|0
argument_list|,
name|loop_start
argument_list|)
expr_stmt|;
name|emit_insn_before
argument_list|(
name|gen_prefetch
argument_list|(
name|reg
argument_list|,
name|GEN_INT
argument_list|(
name|info
index|[
name|i
index|]
operator|.
name|write
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
literal|3
argument_list|)
argument_list|)
argument_list|,
name|loop_start
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* A "basic induction variable" or biv is a pseudo reg that is set    (within this loop) only by incrementing or decrementing it.  */
end_comment

begin_comment
comment|/* A "general induction variable" or giv is a pseudo reg whose    value is a linear function of a biv.  */
end_comment

begin_comment
comment|/* Bivs are recognized by `basic_induction_var';    Givs by `general_induction_var'.  */
end_comment

begin_comment
comment|/* Communication with routines called via `note_stores'.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|note_insn
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Dummy register to have nonzero DEST_REG for DEST_ADDR type givs.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|addr_placeholder
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ??? Unfinished optimizations, and possible future optimizations,    for the strength reduction code.  */
end_comment

begin_comment
comment|/* ??? The interaction of biv elimination, and recognition of 'constant'    bivs, may cause problems.  */
end_comment

begin_comment
comment|/* ??? Add heuristics so that DEST_ADDR strength reduction does not cause    performance problems.     Perhaps don't eliminate things that can be combined with an addressing    mode.  Find all givs that have the same biv, mult_val, and add_val;    then for each giv, check to see if its only use dies in a following    memory address.  If so, generate a new memory address and check to see    if it is valid.   If it is valid, then store the modified memory address,    otherwise, mark the giv as not done so that it will get its own iv.  */
end_comment

begin_comment
comment|/* ??? Could try to optimize branches when it is known that a biv is always    positive.  */
end_comment

begin_comment
comment|/* ??? When replace a biv in a compare insn, we should replace with closest    giv so that an optimized branch can still be recognized by the combiner,    e.g. the VAX acb insn.  */
end_comment

begin_comment
comment|/* ??? Many of the checks involving uid_luid could be simplified if regscan    was rerun in loop_optimize whenever a register was added or moved.    Also, some of the optimizations could be a little less conservative.  */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Scan the loop body and call FNCALL for each insn.  In the addition to the    LOOP and INSN parameters pass MAYBE_MULTIPLE and NOT_EVERY_ITERATION to the    callback.     NOT_EVERY_ITERATION is 1 if current insn is not known to be executed at    least once for every loop iteration except for the last one.     MAYBE_MULTIPLE is 1 if current insn may be executed more than once for every    loop iteration.  */
end_comment

begin_function
name|void
name|for_each_insn_in_loop
parameter_list|(
name|loop
parameter_list|,
name|fncall
parameter_list|)
name|struct
name|loop
modifier|*
name|loop
decl_stmt|;
name|loop_insn_callback
name|fncall
decl_stmt|;
block|{
name|int
name|not_every_iteration
init|=
literal|0
decl_stmt|;
name|int
name|maybe_multiple
init|=
literal|0
decl_stmt|;
name|int
name|past_loop_latch
init|=
literal|0
decl_stmt|;
name|int
name|loop_depth
init|=
literal|0
decl_stmt|;
name|rtx
name|p
decl_stmt|;
comment|/* If loop_scan_start points to the loop exit test, we have to be wary of      subversive use of gotos inside expression statements.  */
if|if
condition|(
name|prev_nonnote_insn
argument_list|(
name|loop
operator|->
name|scan_start
argument_list|)
operator|!=
name|prev_nonnote_insn
argument_list|(
name|loop
operator|->
name|start
argument_list|)
condition|)
name|maybe_multiple
operator|=
name|back_branch_in_range_p
argument_list|(
name|loop
argument_list|,
name|loop
operator|->
name|scan_start
argument_list|)
expr_stmt|;
comment|/* Scan through loop and update NOT_EVERY_ITERATION and MAYBE_MULTIPLE.  */
for|for
control|(
name|p
operator|=
name|next_insn_in_loop
argument_list|(
name|loop
argument_list|,
name|loop
operator|->
name|scan_start
argument_list|)
init|;
name|p
operator|!=
name|NULL_RTX
condition|;
name|p
operator|=
name|next_insn_in_loop
argument_list|(
name|loop
argument_list|,
name|p
argument_list|)
control|)
block|{
name|p
operator|=
name|fncall
argument_list|(
name|loop
argument_list|,
name|p
argument_list|,
name|not_every_iteration
argument_list|,
name|maybe_multiple
argument_list|)
expr_stmt|;
comment|/* Past CODE_LABEL, we get to insns that may be executed multiple          times.  The only way we can be sure that they can't is if every          jump insn between here and the end of the loop either          returns, exits the loop, is a jump to a location that is still          behind the label, or is a jump to the loop start.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|CODE_LABEL
condition|)
block|{
name|rtx
name|insn
init|=
name|p
decl_stmt|;
name|maybe_multiple
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|==
name|loop
operator|->
name|scan_start
condition|)
break|break;
if|if
condition|(
name|insn
operator|==
name|loop
operator|->
name|end
condition|)
block|{
if|if
condition|(
name|loop
operator|->
name|top
operator|!=
literal|0
condition|)
name|insn
operator|=
name|loop
operator|->
name|top
expr_stmt|;
else|else
break|break;
if|if
condition|(
name|insn
operator|==
name|loop
operator|->
name|scan_start
condition|)
break|break;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|RETURN
operator|&&
operator|(
operator|!
name|any_condjump_p
argument_list|(
name|insn
argument_list|)
operator|||
operator|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
operator|!=
literal|0
operator|&&
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
operator|!=
name|loop
operator|->
name|scan_start
operator|&&
operator|!
name|loop_insn_first_p
argument_list|(
name|p
argument_list|,
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
block|{
name|maybe_multiple
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* Past a jump, we get to insns for which we can't count          on whether they will be executed during each iteration.  */
comment|/* This code appears twice in strength_reduce.  There is also similar          code in scan_loop.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|JUMP_INSN
comment|/* If we enter the loop in the middle, and scan around to the          beginning, don't set not_every_iteration for that.          This can be any kind of jump, since we want to know if insns          will be executed if the loop is executed.  */
operator|&&
operator|!
operator|(
name|JUMP_LABEL
argument_list|(
name|p
argument_list|)
operator|==
name|loop
operator|->
name|top
operator|&&
operator|(
operator|(
name|NEXT_INSN
argument_list|(
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
argument_list|)
operator|==
name|loop
operator|->
name|end
operator|&&
name|any_uncondjump_p
argument_list|(
name|p
argument_list|)
operator|)
operator|||
operator|(
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
operator|==
name|loop
operator|->
name|end
operator|&&
name|any_condjump_p
argument_list|(
name|p
argument_list|)
operator|)
operator|)
operator|)
condition|)
block|{
name|rtx
name|label
init|=
literal|0
decl_stmt|;
comment|/* If this is a jump outside the loop, then it also doesn't 	     matter.  Check to see if the target of this branch is on the 	     loop->exits_labels list.  */
for|for
control|(
name|label
operator|=
name|loop
operator|->
name|exit_labels
init|;
name|label
condition|;
name|label
operator|=
name|LABEL_NEXTREF
argument_list|(
name|label
argument_list|)
control|)
if|if
condition|(
name|XEXP
argument_list|(
name|label
argument_list|,
literal|0
argument_list|)
operator|==
name|JUMP_LABEL
argument_list|(
name|p
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|!
name|label
condition|)
name|not_every_iteration
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|NOTE
condition|)
block|{
comment|/* At the virtual top of a converted loop, insns are again known to 	     be executed each iteration: logically, the loop begins here 	     even though the exit code has been duplicated.  	     Insns are also again known to be executed each iteration at 	     the LOOP_CONT note.  */
if|if
condition|(
operator|(
name|NOTE_LINE_NUMBER
argument_list|(
name|p
argument_list|)
operator|==
name|NOTE_INSN_LOOP_VTOP
operator|||
name|NOTE_LINE_NUMBER
argument_list|(
name|p
argument_list|)
operator|==
name|NOTE_INSN_LOOP_CONT
operator|)
operator|&&
name|loop_depth
operator|==
literal|0
condition|)
name|not_every_iteration
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|p
argument_list|)
operator|==
name|NOTE_INSN_LOOP_BEG
condition|)
name|loop_depth
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|p
argument_list|)
operator|==
name|NOTE_INSN_LOOP_END
condition|)
name|loop_depth
operator|--
expr_stmt|;
block|}
comment|/* Note if we pass a loop latch.  If we do, then we can not clear          NOT_EVERY_ITERATION below when we pass the last CODE_LABEL in          a loop since a jump before the last CODE_LABEL may have started          a new loop iteration.           Note that LOOP_TOP is only set for rotated loops and we need          this check for all loops, so compare against the CODE_LABEL          which immediately follows LOOP_START.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|JUMP_LABEL
argument_list|(
name|p
argument_list|)
operator|==
name|NEXT_INSN
argument_list|(
name|loop
operator|->
name|start
argument_list|)
condition|)
name|past_loop_latch
operator|=
literal|1
expr_stmt|;
comment|/* Unlike in the code motion pass where MAYBE_NEVER indicates that          an insn may never be executed, NOT_EVERY_ITERATION indicates whether          or not an insn is known to be executed each iteration of the          loop, whether or not any iterations are known to occur.           Therefore, if we have just passed a label and have no more labels          between here and the test insn of the loop, and we have not passed          a jump to the top of the loop, then we know these insns will be          executed each iteration.  */
if|if
condition|(
name|not_every_iteration
operator|&&
operator|!
name|past_loop_latch
operator|&&
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|CODE_LABEL
operator|&&
name|no_labels_between_p
argument_list|(
name|p
argument_list|,
name|loop
operator|->
name|end
argument_list|)
operator|&&
name|loop_insn_first_p
argument_list|(
name|p
argument_list|,
name|loop
operator|->
name|cont
argument_list|)
condition|)
name|not_every_iteration
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|loop_bivs_find
parameter_list|(
name|loop
parameter_list|)
name|struct
name|loop
modifier|*
name|loop
decl_stmt|;
block|{
name|struct
name|loop_regs
modifier|*
name|regs
init|=
name|LOOP_REGS
argument_list|(
name|loop
argument_list|)
decl_stmt|;
name|struct
name|loop_ivs
modifier|*
name|ivs
init|=
name|LOOP_IVS
argument_list|(
name|loop
argument_list|)
decl_stmt|;
comment|/* Temporary list pointers for traversing ivs->list.  */
name|struct
name|iv_class
modifier|*
name|bl
decl_stmt|,
modifier|*
modifier|*
name|backbl
decl_stmt|;
name|ivs
operator|->
name|list
operator|=
literal|0
expr_stmt|;
name|for_each_insn_in_loop
argument_list|(
name|loop
argument_list|,
name|check_insn_for_bivs
argument_list|)
expr_stmt|;
comment|/* Scan ivs->list to remove all regs that proved not to be bivs.      Make a sanity check against regs->n_times_set.  */
for|for
control|(
name|backbl
operator|=
operator|&
name|ivs
operator|->
name|list
operator|,
name|bl
operator|=
operator|*
name|backbl
init|;
name|bl
condition|;
name|bl
operator|=
name|bl
operator|->
name|next
control|)
block|{
if|if
condition|(
name|REG_IV_TYPE
argument_list|(
name|ivs
argument_list|,
name|bl
operator|->
name|regno
argument_list|)
operator|!=
name|BASIC_INDUCT
comment|/* Above happens if register modified by subreg, etc.  */
comment|/* Make sure it is not recognized as a basic induction var: */
operator|||
name|regs
operator|->
name|array
index|[
name|bl
operator|->
name|regno
index|]
operator|.
name|n_times_set
operator|!=
name|bl
operator|->
name|biv_count
comment|/* If never incremented, it is invariant that we decided not to 	     move.  So leave it alone.  */
operator|||
operator|!
name|bl
operator|->
name|incremented
condition|)
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Biv %d: discarded, %s\n"
argument_list|,
name|bl
operator|->
name|regno
argument_list|,
operator|(
name|REG_IV_TYPE
argument_list|(
name|ivs
argument_list|,
name|bl
operator|->
name|regno
argument_list|)
operator|!=
name|BASIC_INDUCT
condition|?
literal|"not induction variable"
else|:
operator|(
operator|!
name|bl
operator|->
name|incremented
condition|?
literal|"never incremented"
else|:
literal|"count error"
operator|)
operator|)
argument_list|)
expr_stmt|;
name|REG_IV_TYPE
argument_list|(
name|ivs
argument_list|,
name|bl
operator|->
name|regno
argument_list|)
operator|=
name|NOT_BASIC_INDUCT
expr_stmt|;
operator|*
name|backbl
operator|=
name|bl
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
name|backbl
operator|=
operator|&
name|bl
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Biv %d: verified\n"
argument_list|,
name|bl
operator|->
name|regno
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Determine how BIVS are initialized by looking through pre-header    extended basic block.  */
end_comment

begin_function
specifier|static
name|void
name|loop_bivs_init_find
parameter_list|(
name|loop
parameter_list|)
name|struct
name|loop
modifier|*
name|loop
decl_stmt|;
block|{
name|struct
name|loop_ivs
modifier|*
name|ivs
init|=
name|LOOP_IVS
argument_list|(
name|loop
argument_list|)
decl_stmt|;
comment|/* Temporary list pointers for traversing ivs->list.  */
name|struct
name|iv_class
modifier|*
name|bl
decl_stmt|;
name|int
name|call_seen
decl_stmt|;
name|rtx
name|p
decl_stmt|;
comment|/* Find initial value for each biv by searching backwards from loop_start,      halting at first label.  Also record any test condition.  */
name|call_seen
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|loop
operator|->
name|start
init|;
name|p
operator|&&
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|!=
name|CODE_LABEL
condition|;
name|p
operator|=
name|PREV_INSN
argument_list|(
name|p
argument_list|)
control|)
block|{
name|rtx
name|test
decl_stmt|;
name|note_insn
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|CALL_INSN
condition|)
name|call_seen
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|INSN_P
argument_list|(
name|p
argument_list|)
condition|)
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|,
name|record_initial
argument_list|,
name|ivs
argument_list|)
expr_stmt|;
comment|/* Record any test of a biv that branches around the loop if no store 	 between it and the start of loop.  We only care about tests with 	 constants and registers and only certain of those.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|JUMP_LABEL
argument_list|(
name|p
argument_list|)
operator|!=
literal|0
operator|&&
name|next_real_insn
argument_list|(
name|JUMP_LABEL
argument_list|(
name|p
argument_list|)
argument_list|)
operator|==
name|next_real_insn
argument_list|(
name|loop
operator|->
name|end
argument_list|)
operator|&&
operator|(
name|test
operator|=
name|get_condition_for_loop
argument_list|(
name|loop
argument_list|,
name|p
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|test
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|test
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|<
name|max_reg_before_loop
operator|&&
operator|(
name|bl
operator|=
name|REG_IV_CLASS
argument_list|(
name|ivs
argument_list|,
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|test
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|valid_initial_value_p
argument_list|(
name|XEXP
argument_list|(
name|test
argument_list|,
literal|1
argument_list|)
argument_list|,
name|p
argument_list|,
name|call_seen
argument_list|,
name|loop
operator|->
name|start
argument_list|)
operator|&&
name|bl
operator|->
name|init_insn
operator|==
literal|0
condition|)
block|{
comment|/* If an NE test, we have an initial value!  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|test
argument_list|)
operator|==
name|NE
condition|)
block|{
name|bl
operator|->
name|init_insn
operator|=
name|p
expr_stmt|;
name|bl
operator|->
name|init_set
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|XEXP
argument_list|(
name|test
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|test
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|bl
operator|->
name|initial_test
operator|=
name|test
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Look at the each biv and see if we can say anything better about its    initial value from any initializing insns set up above.  (This is done    in two passes to avoid missing SETs in a PARALLEL.)  */
end_comment

begin_function
specifier|static
name|void
name|loop_bivs_check
parameter_list|(
name|loop
parameter_list|)
name|struct
name|loop
modifier|*
name|loop
decl_stmt|;
block|{
name|struct
name|loop_ivs
modifier|*
name|ivs
init|=
name|LOOP_IVS
argument_list|(
name|loop
argument_list|)
decl_stmt|;
comment|/* Temporary list pointers for traversing ivs->list.  */
name|struct
name|iv_class
modifier|*
name|bl
decl_stmt|;
name|struct
name|iv_class
modifier|*
modifier|*
name|backbl
decl_stmt|;
for|for
control|(
name|backbl
operator|=
operator|&
name|ivs
operator|->
name|list
init|;
operator|(
name|bl
operator|=
operator|*
name|backbl
operator|)
condition|;
name|backbl
operator|=
operator|&
name|bl
operator|->
name|next
control|)
block|{
name|rtx
name|src
decl_stmt|;
name|rtx
name|note
decl_stmt|;
if|if
condition|(
operator|!
name|bl
operator|->
name|init_insn
condition|)
continue|continue;
comment|/* IF INIT_INSN has a REG_EQUAL or REG_EQUIV note and the value 	 is a constant, use the value of that.  */
if|if
condition|(
operator|(
operator|(
name|note
operator|=
name|find_reg_note
argument_list|(
name|bl
operator|->
name|init_insn
argument_list|,
name|REG_EQUAL
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
operator|(
name|note
operator|=
name|find_reg_note
argument_list|(
name|bl
operator|->
name|init_insn
argument_list|,
name|REG_EQUIV
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
condition|)
name|src
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|src
operator|=
name|SET_SRC
argument_list|(
name|bl
operator|->
name|init_set
argument_list|)
expr_stmt|;
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Biv %d: initialized at insn %d: initial value "
argument_list|,
name|bl
operator|->
name|regno
argument_list|,
name|INSN_UID
argument_list|(
name|bl
operator|->
name|init_insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|GET_MODE
argument_list|(
name|src
argument_list|)
operator|==
name|GET_MODE
argument_list|(
name|regno_reg_rtx
index|[
name|bl
operator|->
name|regno
index|]
argument_list|)
operator|||
name|GET_MODE
argument_list|(
name|src
argument_list|)
operator|==
name|VOIDmode
operator|)
operator|&&
name|valid_initial_value_p
argument_list|(
name|src
argument_list|,
name|bl
operator|->
name|init_insn
argument_list|,
name|LOOP_INFO
argument_list|(
name|loop
argument_list|)
operator|->
name|pre_header_has_call
argument_list|,
name|loop
operator|->
name|start
argument_list|)
condition|)
block|{
name|bl
operator|->
name|initial_value
operator|=
name|src
expr_stmt|;
if|if
condition|(
name|loop_dump_stream
condition|)
block|{
name|print_simple_rtl
argument_list|(
name|loop_dump_stream
argument_list|,
name|src
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|loop_dump_stream
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If we can't make it a giv, 	 let biv keep initial value of "itself".  */
elseif|else
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"is complex\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Search the loop for general induction variables.  */
end_comment

begin_function
specifier|static
name|void
name|loop_givs_find
parameter_list|(
name|loop
parameter_list|)
name|struct
name|loop
modifier|*
name|loop
decl_stmt|;
block|{
name|for_each_insn_in_loop
argument_list|(
name|loop
argument_list|,
name|check_insn_for_givs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* For each giv for which we still don't know whether or not it is    replaceable, check to see if it is replaceable because its final value    can be calculated.  */
end_comment

begin_function
specifier|static
name|void
name|loop_givs_check
parameter_list|(
name|loop
parameter_list|)
name|struct
name|loop
modifier|*
name|loop
decl_stmt|;
block|{
name|struct
name|loop_ivs
modifier|*
name|ivs
init|=
name|LOOP_IVS
argument_list|(
name|loop
argument_list|)
decl_stmt|;
name|struct
name|iv_class
modifier|*
name|bl
decl_stmt|;
for|for
control|(
name|bl
operator|=
name|ivs
operator|->
name|list
init|;
name|bl
condition|;
name|bl
operator|=
name|bl
operator|->
name|next
control|)
block|{
name|struct
name|induction
modifier|*
name|v
decl_stmt|;
for|for
control|(
name|v
operator|=
name|bl
operator|->
name|giv
init|;
name|v
condition|;
name|v
operator|=
name|v
operator|->
name|next_iv
control|)
if|if
condition|(
operator|!
name|v
operator|->
name|replaceable
operator|&&
operator|!
name|v
operator|->
name|not_replaceable
condition|)
name|check_final_value
argument_list|(
name|loop
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return nonzero if it is possible to eliminate the biv BL provided    all givs are reduced.  This is possible if either the reg is not    used outside the loop, or we can compute what its final value will    be.  */
end_comment

begin_function
specifier|static
name|int
name|loop_biv_eliminable_p
parameter_list|(
name|loop
parameter_list|,
name|bl
parameter_list|,
name|threshold
parameter_list|,
name|insn_count
parameter_list|)
name|struct
name|loop
modifier|*
name|loop
decl_stmt|;
name|struct
name|iv_class
modifier|*
name|bl
decl_stmt|;
name|int
name|threshold
decl_stmt|;
name|int
name|insn_count
decl_stmt|;
block|{
comment|/* For architectures with a decrement_and_branch_until_zero insn,      don't do this if we put a REG_NONNEG note on the endtest for this      biv.  */
ifdef|#
directive|ifdef
name|HAVE_decrement_and_branch_until_zero
if|if
condition|(
name|bl
operator|->
name|nonneg
condition|)
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Cannot eliminate nonneg biv %d.\n"
argument_list|,
name|bl
operator|->
name|regno
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
endif|#
directive|endif
comment|/* Check that biv is used outside loop or if it has a final value.      Compare against bl->init_insn rather than loop->start.  We aren't      concerned with any uses of the biv between init_insn and      loop->start since these won't be affected by the value of the biv      elsewhere in the function, so long as init_insn doesn't use the      biv itself.  */
if|if
condition|(
operator|(
name|REGNO_LAST_LUID
argument_list|(
name|bl
operator|->
name|regno
argument_list|)
operator|<
name|INSN_LUID
argument_list|(
name|loop
operator|->
name|end
argument_list|)
operator|&&
name|bl
operator|->
name|init_insn
operator|&&
name|INSN_UID
argument_list|(
name|bl
operator|->
name|init_insn
argument_list|)
operator|<
name|max_uid_for_loop
operator|&&
name|REGNO_FIRST_LUID
argument_list|(
name|bl
operator|->
name|regno
argument_list|)
operator|>=
name|INSN_LUID
argument_list|(
name|bl
operator|->
name|init_insn
argument_list|)
operator|&&
operator|!
name|reg_mentioned_p
argument_list|(
name|bl
operator|->
name|biv
operator|->
name|dest_reg
argument_list|,
name|SET_SRC
argument_list|(
name|bl
operator|->
name|init_set
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|bl
operator|->
name|final_value
operator|=
name|final_biv_value
argument_list|(
name|loop
argument_list|,
name|bl
argument_list|)
operator|)
condition|)
return|return
name|maybe_eliminate_biv
argument_list|(
name|loop
argument_list|,
name|bl
argument_list|,
literal|0
argument_list|,
name|threshold
argument_list|,
name|insn_count
argument_list|)
return|;
if|if
condition|(
name|loop_dump_stream
condition|)
block|{
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Cannot eliminate biv %d.\n"
argument_list|,
name|bl
operator|->
name|regno
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"First use: insn %d, last use: insn %d.\n"
argument_list|,
name|REGNO_FIRST_UID
argument_list|(
name|bl
operator|->
name|regno
argument_list|)
argument_list|,
name|REGNO_LAST_UID
argument_list|(
name|bl
operator|->
name|regno
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Reduce each giv of BL that we have decided to reduce.  */
end_comment

begin_function
specifier|static
name|void
name|loop_givs_reduce
parameter_list|(
name|loop
parameter_list|,
name|bl
parameter_list|)
name|struct
name|loop
modifier|*
name|loop
decl_stmt|;
name|struct
name|iv_class
modifier|*
name|bl
decl_stmt|;
block|{
name|struct
name|induction
modifier|*
name|v
decl_stmt|;
for|for
control|(
name|v
operator|=
name|bl
operator|->
name|giv
init|;
name|v
condition|;
name|v
operator|=
name|v
operator|->
name|next_iv
control|)
block|{
name|struct
name|induction
modifier|*
name|tv
decl_stmt|;
if|if
condition|(
operator|!
name|v
operator|->
name|ignore
operator|&&
name|v
operator|->
name|same
operator|==
literal|0
condition|)
block|{
name|int
name|auto_inc_opt
init|=
literal|0
decl_stmt|;
comment|/* If the code for derived givs immediately below has already 	     allocated a new_reg, we must keep it.  */
if|if
condition|(
operator|!
name|v
operator|->
name|new_reg
condition|)
name|v
operator|->
name|new_reg
operator|=
name|gen_reg_rtx
argument_list|(
name|v
operator|->
name|mode
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AUTO_INC_DEC
comment|/* If the target has auto-increment addressing modes, and 	     this is an address giv, then try to put the increment 	     immediately after its use, so that flow can create an 	     auto-increment addressing mode.  */
if|if
condition|(
name|v
operator|->
name|giv_type
operator|==
name|DEST_ADDR
operator|&&
name|bl
operator|->
name|biv_count
operator|==
literal|1
operator|&&
name|bl
operator|->
name|biv
operator|->
name|always_executed
operator|&&
operator|!
name|bl
operator|->
name|biv
operator|->
name|maybe_multiple
comment|/* We don't handle reversed biv's because bl->biv->insn 		 does not have a valid INSN_LUID.  */
operator|&&
operator|!
name|bl
operator|->
name|reversed
operator|&&
name|v
operator|->
name|always_executed
operator|&&
operator|!
name|v
operator|->
name|maybe_multiple
operator|&&
name|INSN_UID
argument_list|(
name|v
operator|->
name|insn
argument_list|)
operator|<
name|max_uid_for_loop
condition|)
block|{
comment|/* If other giv's have been combined with this one, then 		 this will work only if all uses of the other giv's occur 		 before this giv's insn.  This is difficult to check.  		 We simplify this by looking for the common case where 		 there is one DEST_REG giv, and this giv's insn is the 		 last use of the dest_reg of that DEST_REG giv.  If the 		 increment occurs after the address giv, then we can 		 perform the optimization.  (Otherwise, the increment 		 would have to go before other_giv, and we would not be 		 able to combine it with the address giv to get an 		 auto-inc address.)  */
if|if
condition|(
name|v
operator|->
name|combined_with
condition|)
block|{
name|struct
name|induction
modifier|*
name|other_giv
init|=
literal|0
decl_stmt|;
for|for
control|(
name|tv
operator|=
name|bl
operator|->
name|giv
init|;
name|tv
condition|;
name|tv
operator|=
name|tv
operator|->
name|next_iv
control|)
if|if
condition|(
name|tv
operator|->
name|same
operator|==
name|v
condition|)
block|{
if|if
condition|(
name|other_giv
condition|)
break|break;
else|else
name|other_giv
operator|=
name|tv
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|tv
operator|&&
name|other_giv
operator|&&
name|REGNO
argument_list|(
name|other_giv
operator|->
name|dest_reg
argument_list|)
operator|<
name|max_reg_before_loop
operator|&&
operator|(
name|REGNO_LAST_UID
argument_list|(
name|REGNO
argument_list|(
name|other_giv
operator|->
name|dest_reg
argument_list|)
argument_list|)
operator|==
name|INSN_UID
argument_list|(
name|v
operator|->
name|insn
argument_list|)
operator|)
operator|&&
name|INSN_LUID
argument_list|(
name|v
operator|->
name|insn
argument_list|)
operator|<
name|INSN_LUID
argument_list|(
name|bl
operator|->
name|biv
operator|->
name|insn
argument_list|)
condition|)
name|auto_inc_opt
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Check for case where increment is before the address 		 giv.  Do this test in "loop order".  */
elseif|else
if|if
condition|(
operator|(
name|INSN_LUID
argument_list|(
name|v
operator|->
name|insn
argument_list|)
operator|>
name|INSN_LUID
argument_list|(
name|bl
operator|->
name|biv
operator|->
name|insn
argument_list|)
operator|&&
operator|(
name|INSN_LUID
argument_list|(
name|v
operator|->
name|insn
argument_list|)
operator|<
name|INSN_LUID
argument_list|(
name|loop
operator|->
name|scan_start
argument_list|)
operator|||
operator|(
name|INSN_LUID
argument_list|(
name|bl
operator|->
name|biv
operator|->
name|insn
argument_list|)
operator|>
name|INSN_LUID
argument_list|(
name|loop
operator|->
name|scan_start
argument_list|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|INSN_LUID
argument_list|(
name|v
operator|->
name|insn
argument_list|)
operator|<
name|INSN_LUID
argument_list|(
name|loop
operator|->
name|scan_start
argument_list|)
operator|&&
operator|(
name|INSN_LUID
argument_list|(
name|loop
operator|->
name|scan_start
argument_list|)
operator|<
name|INSN_LUID
argument_list|(
name|bl
operator|->
name|biv
operator|->
name|insn
argument_list|)
operator|)
operator|)
condition|)
name|auto_inc_opt
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|auto_inc_opt
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_cc0
block|{
name|rtx
name|prev
decl_stmt|;
comment|/* We can't put an insn immediately after one setting 		   cc0, or immediately before one using cc0.  */
if|if
condition|(
operator|(
name|auto_inc_opt
operator|==
literal|1
operator|&&
name|sets_cc0_p
argument_list|(
name|PATTERN
argument_list|(
name|v
operator|->
name|insn
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|auto_inc_opt
operator|==
operator|-
literal|1
operator|&&
operator|(
name|prev
operator|=
name|prev_nonnote_insn
argument_list|(
name|v
operator|->
name|insn
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|INSN_P
argument_list|(
name|prev
argument_list|)
operator|&&
name|sets_cc0_p
argument_list|(
name|PATTERN
argument_list|(
name|prev
argument_list|)
argument_list|)
operator|)
condition|)
name|auto_inc_opt
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|auto_inc_opt
condition|)
name|v
operator|->
name|auto_inc_opt
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* For each place where the biv is incremented, add an insn 	     to increment the new, reduced reg for the giv.  */
for|for
control|(
name|tv
operator|=
name|bl
operator|->
name|biv
init|;
name|tv
condition|;
name|tv
operator|=
name|tv
operator|->
name|next_iv
control|)
block|{
name|rtx
name|insert_before
decl_stmt|;
comment|/* Skip if location is the same as a previous one.  */
if|if
condition|(
name|tv
operator|->
name|same
condition|)
continue|continue;
if|if
condition|(
operator|!
name|auto_inc_opt
condition|)
name|insert_before
operator|=
name|NEXT_INSN
argument_list|(
name|tv
operator|->
name|insn
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|auto_inc_opt
operator|==
literal|1
condition|)
name|insert_before
operator|=
name|NEXT_INSN
argument_list|(
name|v
operator|->
name|insn
argument_list|)
expr_stmt|;
else|else
name|insert_before
operator|=
name|v
operator|->
name|insn
expr_stmt|;
if|if
condition|(
name|tv
operator|->
name|mult_val
operator|==
name|const1_rtx
condition|)
name|loop_iv_add_mult_emit_before
argument_list|(
name|loop
argument_list|,
name|tv
operator|->
name|add_val
argument_list|,
name|v
operator|->
name|mult_val
argument_list|,
name|v
operator|->
name|new_reg
argument_list|,
name|v
operator|->
name|new_reg
argument_list|,
literal|0
argument_list|,
name|insert_before
argument_list|)
expr_stmt|;
else|else
comment|/* tv->mult_val == const0_rtx */
comment|/* A multiply is acceptable here 		   since this is presumed to be seldom executed.  */
name|loop_iv_add_mult_emit_before
argument_list|(
name|loop
argument_list|,
name|tv
operator|->
name|add_val
argument_list|,
name|v
operator|->
name|mult_val
argument_list|,
name|v
operator|->
name|add_val
argument_list|,
name|v
operator|->
name|new_reg
argument_list|,
literal|0
argument_list|,
name|insert_before
argument_list|)
expr_stmt|;
block|}
comment|/* Add code at loop start to initialize giv's reduced reg.  */
name|loop_iv_add_mult_hoist
argument_list|(
name|loop
argument_list|,
name|extend_value_for_giv
argument_list|(
name|v
argument_list|,
name|bl
operator|->
name|initial_value
argument_list|)
argument_list|,
name|v
operator|->
name|mult_val
argument_list|,
name|v
operator|->
name|add_val
argument_list|,
name|v
operator|->
name|new_reg
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Check for givs whose first use is their definition and whose    last use is the definition of another giv.  If so, it is likely    dead and should not be used to derive another giv nor to    eliminate a biv.  */
end_comment

begin_function
specifier|static
name|void
name|loop_givs_dead_check
parameter_list|(
name|loop
parameter_list|,
name|bl
parameter_list|)
name|struct
name|loop
modifier|*
name|loop
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|iv_class
modifier|*
name|bl
decl_stmt|;
block|{
name|struct
name|induction
modifier|*
name|v
decl_stmt|;
for|for
control|(
name|v
operator|=
name|bl
operator|->
name|giv
init|;
name|v
condition|;
name|v
operator|=
name|v
operator|->
name|next_iv
control|)
block|{
if|if
condition|(
name|v
operator|->
name|ignore
operator|||
operator|(
name|v
operator|->
name|same
operator|&&
name|v
operator|->
name|same
operator|->
name|ignore
operator|)
condition|)
continue|continue;
if|if
condition|(
name|v
operator|->
name|giv_type
operator|==
name|DEST_REG
operator|&&
name|REGNO_FIRST_UID
argument_list|(
name|REGNO
argument_list|(
name|v
operator|->
name|dest_reg
argument_list|)
argument_list|)
operator|==
name|INSN_UID
argument_list|(
name|v
operator|->
name|insn
argument_list|)
condition|)
block|{
name|struct
name|induction
modifier|*
name|v1
decl_stmt|;
for|for
control|(
name|v1
operator|=
name|bl
operator|->
name|giv
init|;
name|v1
condition|;
name|v1
operator|=
name|v1
operator|->
name|next_iv
control|)
if|if
condition|(
name|REGNO_LAST_UID
argument_list|(
name|REGNO
argument_list|(
name|v
operator|->
name|dest_reg
argument_list|)
argument_list|)
operator|==
name|INSN_UID
argument_list|(
name|v1
operator|->
name|insn
argument_list|)
condition|)
name|v
operator|->
name|maybe_dead
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|loop_givs_rescan
parameter_list|(
name|loop
parameter_list|,
name|bl
parameter_list|,
name|reg_map
parameter_list|)
name|struct
name|loop
modifier|*
name|loop
decl_stmt|;
name|struct
name|iv_class
modifier|*
name|bl
decl_stmt|;
name|rtx
modifier|*
name|reg_map
decl_stmt|;
block|{
name|struct
name|induction
modifier|*
name|v
decl_stmt|;
for|for
control|(
name|v
operator|=
name|bl
operator|->
name|giv
init|;
name|v
condition|;
name|v
operator|=
name|v
operator|->
name|next_iv
control|)
block|{
if|if
condition|(
name|v
operator|->
name|same
operator|&&
name|v
operator|->
name|same
operator|->
name|ignore
condition|)
name|v
operator|->
name|ignore
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|ignore
condition|)
continue|continue;
comment|/* Update expression if this was combined, in case other giv was 	 replaced.  */
if|if
condition|(
name|v
operator|->
name|same
condition|)
name|v
operator|->
name|new_reg
operator|=
name|replace_rtx
argument_list|(
name|v
operator|->
name|new_reg
argument_list|,
name|v
operator|->
name|same
operator|->
name|dest_reg
argument_list|,
name|v
operator|->
name|same
operator|->
name|new_reg
argument_list|)
expr_stmt|;
comment|/* See if this register is known to be a pointer to something.  If 	 so, see if we can find the alignment.  First see if there is a 	 destination register that is a pointer.  If so, this shares the 	 alignment too.  Next see if we can deduce anything from the 	 computational information.  If not, and this is a DEST_ADDR 	 giv, at least we know that it's a pointer, though we don't know 	 the alignment.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|v
operator|->
name|new_reg
argument_list|)
operator|==
name|REG
operator|&&
name|v
operator|->
name|giv_type
operator|==
name|DEST_REG
operator|&&
name|REG_POINTER
argument_list|(
name|v
operator|->
name|dest_reg
argument_list|)
condition|)
name|mark_reg_pointer
argument_list|(
name|v
operator|->
name|new_reg
argument_list|,
name|REGNO_POINTER_ALIGN
argument_list|(
name|REGNO
argument_list|(
name|v
operator|->
name|dest_reg
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|v
operator|->
name|new_reg
argument_list|)
operator|==
name|REG
operator|&&
name|REG_POINTER
argument_list|(
name|v
operator|->
name|src_reg
argument_list|)
condition|)
block|{
name|unsigned
name|int
name|align
init|=
name|REGNO_POINTER_ALIGN
argument_list|(
name|REGNO
argument_list|(
name|v
operator|->
name|src_reg
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|align
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|v
operator|->
name|add_val
argument_list|)
operator|!=
name|CONST_INT
operator|||
name|INTVAL
argument_list|(
name|v
operator|->
name|add_val
argument_list|)
operator|%
operator|(
name|align
operator|/
name|BITS_PER_UNIT
operator|)
operator|!=
literal|0
condition|)
name|align
operator|=
literal|0
expr_stmt|;
name|mark_reg_pointer
argument_list|(
name|v
operator|->
name|new_reg
argument_list|,
name|align
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|v
operator|->
name|new_reg
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|v
operator|->
name|add_val
argument_list|)
operator|==
name|REG
operator|&&
name|REG_POINTER
argument_list|(
name|v
operator|->
name|add_val
argument_list|)
condition|)
block|{
name|unsigned
name|int
name|align
init|=
name|REGNO_POINTER_ALIGN
argument_list|(
name|REGNO
argument_list|(
name|v
operator|->
name|add_val
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|align
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|v
operator|->
name|mult_val
argument_list|)
operator|!=
name|CONST_INT
operator|||
name|INTVAL
argument_list|(
name|v
operator|->
name|mult_val
argument_list|)
operator|%
operator|(
name|align
operator|/
name|BITS_PER_UNIT
operator|)
operator|!=
literal|0
condition|)
name|align
operator|=
literal|0
expr_stmt|;
name|mark_reg_pointer
argument_list|(
name|v
operator|->
name|new_reg
argument_list|,
name|align
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|v
operator|->
name|new_reg
argument_list|)
operator|==
name|REG
operator|&&
name|v
operator|->
name|giv_type
operator|==
name|DEST_ADDR
condition|)
name|mark_reg_pointer
argument_list|(
name|v
operator|->
name|new_reg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|giv_type
operator|==
name|DEST_ADDR
condition|)
comment|/* Store reduced reg as the address in the memref where we found 	   this giv.  */
name|validate_change
argument_list|(
name|v
operator|->
name|insn
argument_list|,
name|v
operator|->
name|location
argument_list|,
name|v
operator|->
name|new_reg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|v
operator|->
name|replaceable
condition|)
block|{
name|reg_map
index|[
name|REGNO
argument_list|(
name|v
operator|->
name|dest_reg
argument_list|)
index|]
operator|=
name|v
operator|->
name|new_reg
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|original_insn
init|=
name|v
operator|->
name|insn
decl_stmt|;
name|rtx
name|note
decl_stmt|;
comment|/* Not replaceable; emit an insn to set the original giv reg from 	     the reduced giv, same as above.  */
name|v
operator|->
name|insn
operator|=
name|loop_insn_emit_after
argument_list|(
name|loop
argument_list|,
literal|0
argument_list|,
name|original_insn
argument_list|,
name|gen_move_insn
argument_list|(
name|v
operator|->
name|dest_reg
argument_list|,
name|v
operator|->
name|new_reg
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The original insn may have a REG_EQUAL note.  This note is  	     now incorrect and may result in invalid substitutions later.  	     The original insn is dead, but may be part of a libcall  	     sequence, which doesn't seem worth the bother of handling.  */
name|note
operator|=
name|find_reg_note
argument_list|(
name|original_insn
argument_list|,
name|REG_EQUAL
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
if|if
condition|(
name|note
condition|)
name|remove_note
argument_list|(
name|original_insn
argument_list|,
name|note
argument_list|)
expr_stmt|;
block|}
comment|/* When a loop is reversed, givs which depend on the reversed 	 biv, and which are live outside the loop, must be set to their 	 correct final value.  This insn is only needed if the giv is 	 not replaceable.  The correct final value is the same as the 	 value that the giv starts the reversed loop with.  */
if|if
condition|(
name|bl
operator|->
name|reversed
operator|&&
operator|!
name|v
operator|->
name|replaceable
condition|)
name|loop_iv_add_mult_sink
argument_list|(
name|loop
argument_list|,
name|extend_value_for_giv
argument_list|(
name|v
argument_list|,
name|bl
operator|->
name|initial_value
argument_list|)
argument_list|,
name|v
operator|->
name|mult_val
argument_list|,
name|v
operator|->
name|add_val
argument_list|,
name|v
operator|->
name|dest_reg
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|v
operator|->
name|final_value
condition|)
name|loop_insn_sink_or_swim
argument_list|(
name|loop
argument_list|,
name|gen_load_of_final_value
argument_list|(
name|v
operator|->
name|dest_reg
argument_list|,
name|v
operator|->
name|final_value
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|loop_dump_stream
condition|)
block|{
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"giv at %d reduced to "
argument_list|,
name|INSN_UID
argument_list|(
name|v
operator|->
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|print_simple_rtl
argument_list|(
name|loop_dump_stream
argument_list|,
name|v
operator|->
name|new_reg
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|loop_giv_reduce_benefit
parameter_list|(
name|loop
parameter_list|,
name|bl
parameter_list|,
name|v
parameter_list|,
name|test_reg
parameter_list|)
name|struct
name|loop
modifier|*
name|loop
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|iv_class
modifier|*
name|bl
decl_stmt|;
name|struct
name|induction
modifier|*
name|v
decl_stmt|;
name|rtx
name|test_reg
decl_stmt|;
block|{
name|int
name|add_cost
decl_stmt|;
name|int
name|benefit
decl_stmt|;
name|benefit
operator|=
name|v
operator|->
name|benefit
expr_stmt|;
name|PUT_MODE
argument_list|(
name|test_reg
argument_list|,
name|v
operator|->
name|mode
argument_list|)
expr_stmt|;
name|add_cost
operator|=
name|iv_add_mult_cost
argument_list|(
name|bl
operator|->
name|biv
operator|->
name|add_val
argument_list|,
name|v
operator|->
name|mult_val
argument_list|,
name|test_reg
argument_list|,
name|test_reg
argument_list|)
expr_stmt|;
comment|/* Reduce benefit if not replaceable, since we will insert a      move-insn to replace the insn that calculates this giv.  Don't do      this unless the giv is a user variable, since it will often be      marked non-replaceable because of the duplication of the exit      code outside the loop.  In such a case, the copies we insert are      dead and will be deleted.  So they don't have a cost.  Similar      situations exist.  */
comment|/* ??? The new final_[bg]iv_value code does a much better job of      finding replaceable giv's, and hence this code may no longer be      necessary.  */
if|if
condition|(
operator|!
name|v
operator|->
name|replaceable
operator|&&
operator|!
name|bl
operator|->
name|eliminable
operator|&&
name|REG_USERVAR_P
argument_list|(
name|v
operator|->
name|dest_reg
argument_list|)
condition|)
name|benefit
operator|-=
name|copy_cost
expr_stmt|;
comment|/* Decrease the benefit to count the add-insns that we will insert      to increment the reduced reg for the giv.  ??? This can      overestimate the run-time cost of the additional insns, e.g. if      there are multiple basic blocks that increment the biv, but only      one of these blocks is executed during each iteration.  There is      no good way to detect cases like this with the current structure      of the loop optimizer.  This code is more accurate for      determining code size than run-time benefits.  */
name|benefit
operator|-=
name|add_cost
operator|*
name|bl
operator|->
name|biv_count
expr_stmt|;
comment|/* Decide whether to strength-reduce this giv or to leave the code      unchanged (recompute it from the biv each time it is used).  This      decision can be made independently for each giv.  */
ifdef|#
directive|ifdef
name|AUTO_INC_DEC
comment|/* Attempt to guess whether autoincrement will handle some of the      new add insns; if so, increase BENEFIT (undo the subtraction of      add_cost that was done above).  */
if|if
condition|(
name|v
operator|->
name|giv_type
operator|==
name|DEST_ADDR
comment|/* Increasing the benefit is risky, since this is only a guess. 	 Avoid increasing register pressure in cases where there would 	 be no other benefit from reducing this giv.  */
operator|&&
name|benefit
operator|>
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|v
operator|->
name|mult_val
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|int
name|size
init|=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|v
operator|->
name|mem
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|HAVE_POST_INCREMENT
operator|&&
name|INTVAL
argument_list|(
name|v
operator|->
name|mult_val
argument_list|)
operator|==
name|size
condition|)
name|benefit
operator|+=
name|add_cost
operator|*
name|bl
operator|->
name|biv_count
expr_stmt|;
elseif|else
if|if
condition|(
name|HAVE_PRE_INCREMENT
operator|&&
name|INTVAL
argument_list|(
name|v
operator|->
name|mult_val
argument_list|)
operator|==
name|size
condition|)
name|benefit
operator|+=
name|add_cost
operator|*
name|bl
operator|->
name|biv_count
expr_stmt|;
elseif|else
if|if
condition|(
name|HAVE_POST_DECREMENT
operator|&&
operator|-
name|INTVAL
argument_list|(
name|v
operator|->
name|mult_val
argument_list|)
operator|==
name|size
condition|)
name|benefit
operator|+=
name|add_cost
operator|*
name|bl
operator|->
name|biv_count
expr_stmt|;
elseif|else
if|if
condition|(
name|HAVE_PRE_DECREMENT
operator|&&
operator|-
name|INTVAL
argument_list|(
name|v
operator|->
name|mult_val
argument_list|)
operator|==
name|size
condition|)
name|benefit
operator|+=
name|add_cost
operator|*
name|bl
operator|->
name|biv_count
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|benefit
return|;
block|}
end_function

begin_comment
comment|/* Free IV structures for LOOP.  */
end_comment

begin_function
specifier|static
name|void
name|loop_ivs_free
parameter_list|(
name|loop
parameter_list|)
name|struct
name|loop
modifier|*
name|loop
decl_stmt|;
block|{
name|struct
name|loop_ivs
modifier|*
name|ivs
init|=
name|LOOP_IVS
argument_list|(
name|loop
argument_list|)
decl_stmt|;
name|struct
name|iv_class
modifier|*
name|iv
init|=
name|ivs
operator|->
name|list
decl_stmt|;
name|free
argument_list|(
name|ivs
operator|->
name|regs
argument_list|)
expr_stmt|;
while|while
condition|(
name|iv
condition|)
block|{
name|struct
name|iv_class
modifier|*
name|next
init|=
name|iv
operator|->
name|next
decl_stmt|;
name|struct
name|induction
modifier|*
name|induction
decl_stmt|;
name|struct
name|induction
modifier|*
name|next_induction
decl_stmt|;
for|for
control|(
name|induction
operator|=
name|iv
operator|->
name|biv
init|;
name|induction
condition|;
name|induction
operator|=
name|next_induction
control|)
block|{
name|next_induction
operator|=
name|induction
operator|->
name|next_iv
expr_stmt|;
name|free
argument_list|(
name|induction
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|induction
operator|=
name|iv
operator|->
name|giv
init|;
name|induction
condition|;
name|induction
operator|=
name|next_induction
control|)
block|{
name|next_induction
operator|=
name|induction
operator|->
name|next_iv
expr_stmt|;
name|free
argument_list|(
name|induction
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|iv
argument_list|)
expr_stmt|;
name|iv
operator|=
name|next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Perform strength reduction and induction variable elimination.     Pseudo registers created during this function will be beyond the    last valid index in several tables including    REGS->ARRAY[I].N_TIMES_SET and REGNO_LAST_UID.  This does not cause a    problem here, because the added registers cannot be givs outside of    their loop, and hence will never be reconsidered.  But scan_loop    must check regnos to make sure they are in bounds.  */
end_comment

begin_function
specifier|static
name|void
name|strength_reduce
parameter_list|(
name|loop
parameter_list|,
name|flags
parameter_list|)
name|struct
name|loop
modifier|*
name|loop
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|struct
name|loop_info
modifier|*
name|loop_info
init|=
name|LOOP_INFO
argument_list|(
name|loop
argument_list|)
decl_stmt|;
name|struct
name|loop_regs
modifier|*
name|regs
init|=
name|LOOP_REGS
argument_list|(
name|loop
argument_list|)
decl_stmt|;
name|struct
name|loop_ivs
modifier|*
name|ivs
init|=
name|LOOP_IVS
argument_list|(
name|loop
argument_list|)
decl_stmt|;
name|rtx
name|p
decl_stmt|;
comment|/* Temporary list pointer for traversing ivs->list.  */
name|struct
name|iv_class
modifier|*
name|bl
decl_stmt|;
comment|/* Ratio of extra register life span we can justify      for saving an instruction.  More if loop doesn't call subroutines      since in that case saving an insn makes more difference      and more registers are available.  */
comment|/* ??? could set this to last value of threshold in move_movables */
name|int
name|threshold
init|=
operator|(
name|loop_info
operator|->
name|has_call
condition|?
literal|1
else|:
literal|2
operator|)
operator|*
operator|(
literal|3
operator|+
name|n_non_fixed_regs
operator|)
decl_stmt|;
comment|/* Map of pseudo-register replacements.  */
name|rtx
modifier|*
name|reg_map
init|=
name|NULL
decl_stmt|;
name|int
name|reg_map_size
decl_stmt|;
name|int
name|unrolled_insn_copies
init|=
literal|0
decl_stmt|;
name|rtx
name|test_reg
init|=
name|gen_rtx_REG
argument_list|(
name|word_mode
argument_list|,
name|LAST_VIRTUAL_REGISTER
operator|+
literal|1
argument_list|)
decl_stmt|;
name|int
name|insn_count
init|=
name|count_insns_in_loop
argument_list|(
name|loop
argument_list|)
decl_stmt|;
name|addr_placeholder
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|ivs
operator|->
name|n_regs
operator|=
name|max_reg_before_loop
expr_stmt|;
name|ivs
operator|->
name|regs
operator|=
operator|(
expr|struct
name|iv
operator|*
operator|)
name|xcalloc
argument_list|(
name|ivs
operator|->
name|n_regs
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|iv
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Find all BIVs in loop.  */
name|loop_bivs_find
argument_list|(
name|loop
argument_list|)
expr_stmt|;
comment|/* Exit if there are no bivs.  */
if|if
condition|(
operator|!
name|ivs
operator|->
name|list
condition|)
block|{
comment|/* Can still unroll the loop anyways, but indicate that there is no 	 strength reduction info available.  */
if|if
condition|(
name|flags
operator|&
name|LOOP_UNROLL
condition|)
name|unroll_loop
argument_list|(
name|loop
argument_list|,
name|insn_count
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|loop_ivs_free
argument_list|(
name|loop
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Determine how BIVS are initialized by looking through pre-header      extended basic block.  */
name|loop_bivs_init_find
argument_list|(
name|loop
argument_list|)
expr_stmt|;
comment|/* Look at the each biv and see if we can say anything better about its      initial value from any initializing insns set up above.  */
name|loop_bivs_check
argument_list|(
name|loop
argument_list|)
expr_stmt|;
comment|/* Search the loop for general induction variables.  */
name|loop_givs_find
argument_list|(
name|loop
argument_list|)
expr_stmt|;
comment|/* Try to calculate and save the number of loop iterations.  This is      set to zero if the actual number can not be calculated.  This must      be called after all giv's have been identified, since otherwise it may      fail if the iteration variable is a giv.  */
name|loop_iterations
argument_list|(
name|loop
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_prefetch
if|if
condition|(
name|flags
operator|&
name|LOOP_PREFETCH
condition|)
name|emit_prefetch_instructions
argument_list|(
name|loop
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Now for each giv for which we still don't know whether or not it is      replaceable, check to see if it is replaceable because its final value      can be calculated.  This must be done after loop_iterations is called,      so that final_giv_value will work correctly.  */
name|loop_givs_check
argument_list|(
name|loop
argument_list|)
expr_stmt|;
comment|/* Try to prove that the loop counter variable (if any) is always      nonnegative; if so, record that fact with a REG_NONNEG note      so that "decrement and branch until zero" insn can be used.  */
name|check_dbra_loop
argument_list|(
name|loop
argument_list|,
name|insn_count
argument_list|)
expr_stmt|;
comment|/* Create reg_map to hold substitutions for replaceable giv regs.      Some givs might have been made from biv increments, so look at      ivs->reg_iv_type for a suitable size.  */
name|reg_map_size
operator|=
name|ivs
operator|->
name|n_regs
expr_stmt|;
name|reg_map
operator|=
operator|(
name|rtx
operator|*
operator|)
name|xcalloc
argument_list|(
name|reg_map_size
argument_list|,
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Examine each iv class for feasibility of strength reduction/induction      variable elimination.  */
for|for
control|(
name|bl
operator|=
name|ivs
operator|->
name|list
init|;
name|bl
condition|;
name|bl
operator|=
name|bl
operator|->
name|next
control|)
block|{
name|struct
name|induction
modifier|*
name|v
decl_stmt|;
name|int
name|benefit
decl_stmt|;
comment|/* Test whether it will be possible to eliminate this biv 	 provided all givs are reduced.  */
name|bl
operator|->
name|eliminable
operator|=
name|loop_biv_eliminable_p
argument_list|(
name|loop
argument_list|,
name|bl
argument_list|,
name|threshold
argument_list|,
name|insn_count
argument_list|)
expr_stmt|;
comment|/* This will be true at the end, if all givs which depend on this 	 biv have been strength reduced. 	 We can't (currently) eliminate the biv unless this is so.  */
name|bl
operator|->
name|all_reduced
operator|=
literal|1
expr_stmt|;
comment|/* Check each extension dependent giv in this class to see if its 	 root biv is safe from wrapping in the interior mode.  */
name|check_ext_dependent_givs
argument_list|(
name|bl
argument_list|,
name|loop_info
argument_list|)
expr_stmt|;
comment|/* Combine all giv's for this iv_class.  */
name|combine_givs
argument_list|(
name|regs
argument_list|,
name|bl
argument_list|)
expr_stmt|;
for|for
control|(
name|v
operator|=
name|bl
operator|->
name|giv
init|;
name|v
condition|;
name|v
operator|=
name|v
operator|->
name|next_iv
control|)
block|{
name|struct
name|induction
modifier|*
name|tv
decl_stmt|;
if|if
condition|(
name|v
operator|->
name|ignore
operator|||
name|v
operator|->
name|same
condition|)
continue|continue;
name|benefit
operator|=
name|loop_giv_reduce_benefit
argument_list|(
name|loop
argument_list|,
name|bl
argument_list|,
name|v
argument_list|,
name|test_reg
argument_list|)
expr_stmt|;
comment|/* If an insn is not to be strength reduced, then set its ignore 	     flag, and clear bl->all_reduced.  */
comment|/* A giv that depends on a reversed biv must be reduced if it is 	     used after the loop exit, otherwise, it would have the wrong 	     value after the loop exit.  To make it simple, just reduce all 	     of such giv's whether or not we know they are used after the loop 	     exit.  */
if|if
condition|(
operator|!
name|flag_reduce_all_givs
operator|&&
name|v
operator|->
name|lifetime
operator|*
name|threshold
operator|*
name|benefit
operator|<
name|insn_count
operator|&&
operator|!
name|bl
operator|->
name|reversed
condition|)
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"giv of insn %d not worth while, %d vs %d.\n"
argument_list|,
name|INSN_UID
argument_list|(
name|v
operator|->
name|insn
argument_list|)
argument_list|,
name|v
operator|->
name|lifetime
operator|*
name|threshold
operator|*
name|benefit
argument_list|,
name|insn_count
argument_list|)
expr_stmt|;
name|v
operator|->
name|ignore
operator|=
literal|1
expr_stmt|;
name|bl
operator|->
name|all_reduced
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* Check that we can increment the reduced giv without a 		 multiply insn.  If not, reject it.  */
for|for
control|(
name|tv
operator|=
name|bl
operator|->
name|biv
init|;
name|tv
condition|;
name|tv
operator|=
name|tv
operator|->
name|next_iv
control|)
if|if
condition|(
name|tv
operator|->
name|mult_val
operator|==
name|const1_rtx
operator|&&
operator|!
name|product_cheap_p
argument_list|(
name|tv
operator|->
name|add_val
argument_list|,
name|v
operator|->
name|mult_val
argument_list|)
condition|)
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"giv of insn %d: would need a multiply.\n"
argument_list|,
name|INSN_UID
argument_list|(
name|v
operator|->
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|v
operator|->
name|ignore
operator|=
literal|1
expr_stmt|;
name|bl
operator|->
name|all_reduced
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* Check for givs whose first use is their definition and whose 	 last use is the definition of another giv.  If so, it is likely 	 dead and should not be used to derive another giv nor to 	 eliminate a biv.  */
name|loop_givs_dead_check
argument_list|(
name|loop
argument_list|,
name|bl
argument_list|)
expr_stmt|;
comment|/* Reduce each giv that we decided to reduce.  */
name|loop_givs_reduce
argument_list|(
name|loop
argument_list|,
name|bl
argument_list|)
expr_stmt|;
comment|/* Rescan all givs.  If a giv is the same as a giv not reduced, mark it 	 as not reduced.  	 For each giv register that can be reduced now: if replaceable, 	 substitute reduced reg wherever the old giv occurs; 	 else add new move insn "giv_reg = reduced_reg".  */
name|loop_givs_rescan
argument_list|(
name|loop
argument_list|,
name|bl
argument_list|,
name|reg_map
argument_list|)
expr_stmt|;
comment|/* All the givs based on the biv bl have been reduced if they 	 merit it.  */
comment|/* For each giv not marked as maybe dead that has been combined with a 	 second giv, clear any "maybe dead" mark on that second giv. 	 v->new_reg will either be or refer to the register of the giv it 	 combined with.  	 Doing this clearing avoids problems in biv elimination where 	 a giv's new_reg is a complex value that can't be put in the 	 insn but the giv combined with (with a reg as new_reg) is 	 marked maybe_dead.  Since the register will be used in either 	 case, we'd prefer it be used from the simpler giv.  */
for|for
control|(
name|v
operator|=
name|bl
operator|->
name|giv
init|;
name|v
condition|;
name|v
operator|=
name|v
operator|->
name|next_iv
control|)
if|if
condition|(
operator|!
name|v
operator|->
name|maybe_dead
operator|&&
name|v
operator|->
name|same
condition|)
name|v
operator|->
name|same
operator|->
name|maybe_dead
operator|=
literal|0
expr_stmt|;
comment|/* Try to eliminate the biv, if it is a candidate. 	 This won't work if ! bl->all_reduced, 	 since the givs we planned to use might not have been reduced.  	 We have to be careful that we didn't initially think we could 	 eliminate this biv because of a giv that we now think may be 	 dead and shouldn't be used as a biv replacement.  	 Also, there is the possibility that we may have a giv that looks 	 like it can be used to eliminate a biv, but the resulting insn 	 isn't valid.  This can happen, for example, on the 88k, where a 	 JUMP_INSN can compare a register only with zero.  Attempts to 	 replace it with a compare with a constant will fail.  	 Note that in cases where this call fails, we may have replaced some 	 of the occurrences of the biv with a giv, but no harm was done in 	 doing so in the rare cases where it can occur.  */
if|if
condition|(
name|bl
operator|->
name|all_reduced
operator|==
literal|1
operator|&&
name|bl
operator|->
name|eliminable
operator|&&
name|maybe_eliminate_biv
argument_list|(
name|loop
argument_list|,
name|bl
argument_list|,
literal|1
argument_list|,
name|threshold
argument_list|,
name|insn_count
argument_list|)
condition|)
block|{
comment|/* ?? If we created a new test to bypass the loop entirely, 	     or otherwise drop straight in, based on this test, then 	     we might want to rewrite it also.  This way some later 	     pass has more hope of removing the initialization of this 	     biv entirely.  */
comment|/* If final_value != 0, then the biv may be used after loop end 	     and we must emit an insn to set it just in case.  	     Reversed bivs already have an insn after the loop setting their 	     value, so we don't need another one.  We can't calculate the 	     proper final value for such a biv here anyways.  */
if|if
condition|(
name|bl
operator|->
name|final_value
operator|&&
operator|!
name|bl
operator|->
name|reversed
condition|)
name|loop_insn_sink_or_swim
argument_list|(
name|loop
argument_list|,
name|gen_load_of_final_value
argument_list|(
name|bl
operator|->
name|biv
operator|->
name|dest_reg
argument_list|,
name|bl
operator|->
name|final_value
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Reg %d: biv eliminated\n"
argument_list|,
name|bl
operator|->
name|regno
argument_list|)
expr_stmt|;
block|}
comment|/* See above note wrt final_value.  But since we couldn't eliminate 	 the biv, we must set the value after the loop instead of before.  */
elseif|else
if|if
condition|(
name|bl
operator|->
name|final_value
operator|&&
operator|!
name|bl
operator|->
name|reversed
condition|)
name|loop_insn_sink
argument_list|(
name|loop
argument_list|,
name|gen_load_of_final_value
argument_list|(
name|bl
operator|->
name|biv
operator|->
name|dest_reg
argument_list|,
name|bl
operator|->
name|final_value
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Go through all the instructions in the loop, making all the      register substitutions scheduled in REG_MAP.  */
for|for
control|(
name|p
operator|=
name|loop
operator|->
name|start
init|;
name|p
operator|!=
name|loop
operator|->
name|end
condition|;
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|JUMP_INSN
operator|||
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
name|replace_regs
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|,
name|reg_map
argument_list|,
name|reg_map_size
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|replace_regs
argument_list|(
name|REG_NOTES
argument_list|(
name|p
argument_list|)
argument_list|,
name|reg_map
argument_list|,
name|reg_map_size
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|INSN_CODE
argument_list|(
name|p
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|loop_info
operator|->
name|n_iterations
operator|>
literal|0
condition|)
block|{
comment|/* When we completely unroll a loop we will likely not need the increment 	 of the loop BIV and we will not need the conditional branch at the 	 end of the loop.  */
name|unrolled_insn_copies
operator|=
name|insn_count
operator|-
literal|2
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_cc0
comment|/* When we completely unroll a loop on a HAVE_cc0 machine we will not 	 need the comparison before the conditional branch at the end of the 	 loop.  */
name|unrolled_insn_copies
operator|-=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* We'll need one copy for each loop iteration.  */
name|unrolled_insn_copies
operator|*=
name|loop_info
operator|->
name|n_iterations
expr_stmt|;
comment|/* A little slop to account for the ability to remove initialization 	 code, better CSE, and other secondary benefits of completely 	 unrolling some loops.  */
name|unrolled_insn_copies
operator|-=
literal|1
expr_stmt|;
comment|/* Clamp the value.  */
if|if
condition|(
name|unrolled_insn_copies
operator|<
literal|0
condition|)
name|unrolled_insn_copies
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Unroll loops from within strength reduction so that we can use the      induction variable information that strength_reduce has already      collected.  Always unroll loops that would be as small or smaller      unrolled than when rolled.  */
if|if
condition|(
operator|(
name|flags
operator|&
name|LOOP_UNROLL
operator|)
operator|||
operator|(
operator|(
name|flags
operator|&
name|LOOP_AUTO_UNROLL
operator|)
operator|&&
name|loop_info
operator|->
name|n_iterations
operator|>
literal|0
operator|&&
name|unrolled_insn_copies
operator|<=
name|insn_count
operator|)
condition|)
name|unroll_loop
argument_list|(
name|loop
argument_list|,
name|insn_count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_doloop_end
if|if
condition|(
name|HAVE_doloop_end
operator|&&
operator|(
name|flags
operator|&
name|LOOP_BCT
operator|)
operator|&&
name|flag_branch_on_count_reg
condition|)
name|doloop_optimize
argument_list|(
name|loop
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_doloop_end  */
comment|/* In case number of iterations is known, drop branch prediction note      in the branch.  Do that only in second loop pass, as loop unrolling      may change the number of iterations performed.  */
if|if
condition|(
name|flags
operator|&
name|LOOP_BCT
condition|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|n
init|=
name|loop_info
operator|->
name|n_iterations
operator|/
name|loop_info
operator|->
name|unroll_number
decl_stmt|;
if|if
condition|(
name|n
operator|>
literal|1
condition|)
name|predict_insn
argument_list|(
name|prev_nonnote_insn
argument_list|(
name|loop
operator|->
name|end
argument_list|)
argument_list|,
name|PRED_LOOP_ITERATIONS
argument_list|,
name|REG_BR_PROB_BASE
operator|-
name|REG_BR_PROB_BASE
operator|/
name|n
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|loop_ivs_free
argument_list|(
name|loop
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_map
condition|)
name|free
argument_list|(
name|reg_map
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*Record all basic induction variables calculated in the insn.  */
end_comment

begin_function
specifier|static
name|rtx
name|check_insn_for_bivs
parameter_list|(
name|loop
parameter_list|,
name|p
parameter_list|,
name|not_every_iteration
parameter_list|,
name|maybe_multiple
parameter_list|)
name|struct
name|loop
modifier|*
name|loop
decl_stmt|;
name|rtx
name|p
decl_stmt|;
name|int
name|not_every_iteration
decl_stmt|;
name|int
name|maybe_multiple
decl_stmt|;
block|{
name|struct
name|loop_ivs
modifier|*
name|ivs
init|=
name|LOOP_IVS
argument_list|(
name|loop
argument_list|)
decl_stmt|;
name|rtx
name|set
decl_stmt|;
name|rtx
name|dest_reg
decl_stmt|;
name|rtx
name|inc_val
decl_stmt|;
name|rtx
name|mult_val
decl_stmt|;
name|rtx
modifier|*
name|location
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|INSN
operator|&&
operator|(
name|set
operator|=
name|single_set
argument_list|(
name|p
argument_list|)
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|dest_reg
operator|=
name|SET_DEST
argument_list|(
name|set
argument_list|)
expr_stmt|;
if|if
condition|(
name|REGNO
argument_list|(
name|dest_reg
argument_list|)
operator|<
name|max_reg_before_loop
operator|&&
name|REGNO
argument_list|(
name|dest_reg
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|REG_IV_TYPE
argument_list|(
name|ivs
argument_list|,
name|REGNO
argument_list|(
name|dest_reg
argument_list|)
argument_list|)
operator|!=
name|NOT_BASIC_INDUCT
condition|)
block|{
if|if
condition|(
name|basic_induction_var
argument_list|(
name|loop
argument_list|,
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
argument_list|,
name|dest_reg
argument_list|,
name|p
argument_list|,
operator|&
name|inc_val
argument_list|,
operator|&
name|mult_val
argument_list|,
operator|&
name|location
argument_list|)
condition|)
block|{
comment|/* It is a possible basic induction variable. 	         Create and initialize an induction structure for it.  */
name|struct
name|induction
modifier|*
name|v
init|=
operator|(
expr|struct
name|induction
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|induction
argument_list|)
argument_list|)
decl_stmt|;
name|record_biv
argument_list|(
name|loop
argument_list|,
name|v
argument_list|,
name|p
argument_list|,
name|dest_reg
argument_list|,
name|inc_val
argument_list|,
name|mult_val
argument_list|,
name|location
argument_list|,
name|not_every_iteration
argument_list|,
name|maybe_multiple
argument_list|)
expr_stmt|;
name|REG_IV_TYPE
argument_list|(
name|ivs
argument_list|,
name|REGNO
argument_list|(
name|dest_reg
argument_list|)
argument_list|)
operator|=
name|BASIC_INDUCT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|REGNO
argument_list|(
name|dest_reg
argument_list|)
operator|<
name|ivs
operator|->
name|n_regs
condition|)
name|REG_IV_TYPE
argument_list|(
name|ivs
argument_list|,
name|REGNO
argument_list|(
name|dest_reg
argument_list|)
argument_list|)
operator|=
name|NOT_BASIC_INDUCT
expr_stmt|;
block|}
block|}
return|return
name|p
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Record all givs calculated in the insn.    A register is a giv if: it is only set once, it is a function of a    biv and a constant (or invariant), and it is not a biv.  */
end_comment

begin_function
specifier|static
name|rtx
name|check_insn_for_givs
parameter_list|(
name|loop
parameter_list|,
name|p
parameter_list|,
name|not_every_iteration
parameter_list|,
name|maybe_multiple
parameter_list|)
name|struct
name|loop
modifier|*
name|loop
decl_stmt|;
name|rtx
name|p
decl_stmt|;
name|int
name|not_every_iteration
decl_stmt|;
name|int
name|maybe_multiple
decl_stmt|;
block|{
name|struct
name|loop_regs
modifier|*
name|regs
init|=
name|LOOP_REGS
argument_list|(
name|loop
argument_list|)
decl_stmt|;
name|rtx
name|set
decl_stmt|;
comment|/* Look for a general induction variable in a register.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|INSN
operator|&&
operator|(
name|set
operator|=
name|single_set
argument_list|(
name|p
argument_list|)
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
operator|!
name|regs
operator|->
name|array
index|[
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
index|]
operator|.
name|may_not_optimize
condition|)
block|{
name|rtx
name|src_reg
decl_stmt|;
name|rtx
name|dest_reg
decl_stmt|;
name|rtx
name|add_val
decl_stmt|;
name|rtx
name|mult_val
decl_stmt|;
name|rtx
name|ext_val
decl_stmt|;
name|int
name|benefit
decl_stmt|;
name|rtx
name|regnote
init|=
literal|0
decl_stmt|;
name|rtx
name|last_consec_insn
decl_stmt|;
name|dest_reg
operator|=
name|SET_DEST
argument_list|(
name|set
argument_list|)
expr_stmt|;
if|if
condition|(
name|REGNO
argument_list|(
name|dest_reg
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
return|return
name|p
return|;
if|if
condition|(
comment|/* SET_SRC is a giv.  */
operator|(
name|general_induction_var
argument_list|(
name|loop
argument_list|,
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
operator|&
name|src_reg
argument_list|,
operator|&
name|add_val
argument_list|,
operator|&
name|mult_val
argument_list|,
operator|&
name|ext_val
argument_list|,
literal|0
argument_list|,
operator|&
name|benefit
argument_list|,
name|VOIDmode
argument_list|)
comment|/* Equivalent expression is a giv.  */
operator|||
operator|(
operator|(
name|regnote
operator|=
name|find_reg_note
argument_list|(
name|p
argument_list|,
name|REG_EQUAL
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
operator|&&
name|general_induction_var
argument_list|(
name|loop
argument_list|,
name|XEXP
argument_list|(
name|regnote
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|src_reg
argument_list|,
operator|&
name|add_val
argument_list|,
operator|&
name|mult_val
argument_list|,
operator|&
name|ext_val
argument_list|,
literal|0
argument_list|,
operator|&
name|benefit
argument_list|,
name|VOIDmode
argument_list|)
operator|)
operator|)
comment|/* Don't try to handle any regs made by loop optimization. 	     We have nothing on them in regno_first_uid, etc.  */
operator|&&
name|REGNO
argument_list|(
name|dest_reg
argument_list|)
operator|<
name|max_reg_before_loop
comment|/* Don't recognize a BASIC_INDUCT_VAR here.  */
operator|&&
name|dest_reg
operator|!=
name|src_reg
comment|/* This must be the only place where the register is set.  */
operator|&&
operator|(
name|regs
operator|->
name|array
index|[
name|REGNO
argument_list|(
name|dest_reg
argument_list|)
index|]
operator|.
name|n_times_set
operator|==
literal|1
comment|/* or all sets must be consecutive and make a giv.  */
operator|||
operator|(
name|benefit
operator|=
name|consec_sets_giv
argument_list|(
name|loop
argument_list|,
name|benefit
argument_list|,
name|p
argument_list|,
name|src_reg
argument_list|,
name|dest_reg
argument_list|,
operator|&
name|add_val
argument_list|,
operator|&
name|mult_val
argument_list|,
operator|&
name|ext_val
argument_list|,
operator|&
name|last_consec_insn
argument_list|)
operator|)
operator|)
condition|)
block|{
name|struct
name|induction
modifier|*
name|v
init|=
operator|(
expr|struct
name|induction
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|induction
argument_list|)
argument_list|)
decl_stmt|;
comment|/* If this is a library call, increase benefit.  */
if|if
condition|(
name|find_reg_note
argument_list|(
name|p
argument_list|,
name|REG_RETVAL
argument_list|,
name|NULL_RTX
argument_list|)
condition|)
name|benefit
operator|+=
name|libcall_benefit
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* Skip the consecutive insns, if there are any.  */
if|if
condition|(
name|regs
operator|->
name|array
index|[
name|REGNO
argument_list|(
name|dest_reg
argument_list|)
index|]
operator|.
name|n_times_set
operator|!=
literal|1
condition|)
name|p
operator|=
name|last_consec_insn
expr_stmt|;
name|record_giv
argument_list|(
name|loop
argument_list|,
name|v
argument_list|,
name|p
argument_list|,
name|src_reg
argument_list|,
name|dest_reg
argument_list|,
name|mult_val
argument_list|,
name|add_val
argument_list|,
name|ext_val
argument_list|,
name|benefit
argument_list|,
name|DEST_REG
argument_list|,
name|not_every_iteration
argument_list|,
name|maybe_multiple
argument_list|,
operator|(
name|rtx
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
ifndef|#
directive|ifndef
name|DONT_REDUCE_ADDR
comment|/* Look for givs which are memory addresses.  */
comment|/* This resulted in worse code on a VAX 8600.  I wonder if it      still does.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|INSN
condition|)
name|find_mem_givs
argument_list|(
name|loop
argument_list|,
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|,
name|p
argument_list|,
name|not_every_iteration
argument_list|,
name|maybe_multiple
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Update the status of whether giv can derive other givs.  This can      change when we pass a label or an insn that updates a biv.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|JUMP_INSN
operator|||
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|CODE_LABEL
condition|)
name|update_giv_derive
argument_list|(
name|loop
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if X is a valid source for an initial value (or as value being    compared against in an initial test).     X must be either a register or constant and must not be clobbered between    the current insn and the start of the loop.     INSN is the insn containing X.  */
end_comment

begin_function
specifier|static
name|int
name|valid_initial_value_p
parameter_list|(
name|x
parameter_list|,
name|insn
parameter_list|,
name|call_seen
parameter_list|,
name|loop_start
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|int
name|call_seen
decl_stmt|;
name|rtx
name|loop_start
decl_stmt|;
block|{
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|x
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Only consider pseudos we know about initialized in insns whose luids      we know.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO
argument_list|(
name|x
argument_list|)
operator|>=
name|max_reg_before_loop
condition|)
return|return
literal|0
return|;
comment|/* Don't use call-clobbered registers across a call which clobbers it.  On      some machines, don't use any hard registers at all.  */
if|if
condition|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
operator|(
name|SMALL_REGISTER_CLASSES
operator|||
operator|(
name|call_used_regs
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
operator|&&
name|call_seen
operator|)
operator|)
condition|)
return|return
literal|0
return|;
comment|/* Don't use registers that have been clobbered before the start of the      loop.  */
if|if
condition|(
name|reg_set_between_p
argument_list|(
name|x
argument_list|,
name|insn
argument_list|,
name|loop_start
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Scan X for memory refs and check each memory address    as a possible giv.  INSN is the insn whose pattern X comes from.    NOT_EVERY_ITERATION is 1 if the insn might not be executed during    every loop iteration.  MAYBE_MULTIPLE is 1 if the insn might be executed    more thanonce in each loop iteration.  */
end_comment

begin_function
specifier|static
name|void
name|find_mem_givs
parameter_list|(
name|loop
parameter_list|,
name|x
parameter_list|,
name|insn
parameter_list|,
name|not_every_iteration
parameter_list|,
name|maybe_multiple
parameter_list|)
specifier|const
name|struct
name|loop
modifier|*
name|loop
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|int
name|not_every_iteration
decl_stmt|,
name|maybe_multiple
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|REG
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
case|case
name|PC
case|:
case|case
name|CC0
case|:
case|case
name|ADDR_VEC
case|:
case|case
name|ADDR_DIFF_VEC
case|:
case|case
name|USE
case|:
case|case
name|CLOBBER
case|:
return|return;
case|case
name|MEM
case|:
block|{
name|rtx
name|src_reg
decl_stmt|;
name|rtx
name|add_val
decl_stmt|;
name|rtx
name|mult_val
decl_stmt|;
name|rtx
name|ext_val
decl_stmt|;
name|int
name|benefit
decl_stmt|;
comment|/* This code used to disable creating GIVs with mult_val == 1 and 	   add_val == 0.  However, this leads to lost optimizations when 	   it comes time to combine a set of related DEST_ADDR GIVs, since 	   this one would not be seen.  */
if|if
condition|(
name|general_induction_var
argument_list|(
name|loop
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|src_reg
argument_list|,
operator|&
name|add_val
argument_list|,
operator|&
name|mult_val
argument_list|,
operator|&
name|ext_val
argument_list|,
literal|1
argument_list|,
operator|&
name|benefit
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Found one; record it.  */
name|struct
name|induction
modifier|*
name|v
init|=
operator|(
expr|struct
name|induction
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|induction
argument_list|)
argument_list|)
decl_stmt|;
name|record_giv
argument_list|(
name|loop
argument_list|,
name|v
argument_list|,
name|insn
argument_list|,
name|src_reg
argument_list|,
name|addr_placeholder
argument_list|,
name|mult_val
argument_list|,
name|add_val
argument_list|,
name|ext_val
argument_list|,
name|benefit
argument_list|,
name|DEST_ADDR
argument_list|,
name|not_every_iteration
argument_list|,
name|maybe_multiple
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|v
operator|->
name|mem
operator|=
name|x
expr_stmt|;
block|}
block|}
return|return;
default|default:
break|break;
block|}
comment|/* Recursively scan the subexpressions for other mem refs.  */
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|find_mem_givs
argument_list|(
name|loop
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|insn
argument_list|,
name|not_every_iteration
argument_list|,
name|maybe_multiple
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|find_mem_givs
argument_list|(
name|loop
argument_list|,
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|insn
argument_list|,
name|not_every_iteration
argument_list|,
name|maybe_multiple
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Fill in the data about one biv update.    V is the `struct induction' in which we record the biv.  (It is    allocated by the caller, with alloca.)    INSN is the insn that sets it.    DEST_REG is the biv's reg.     MULT_VAL is const1_rtx if the biv is being incremented here, in which case    INC_VAL is the increment.  Otherwise, MULT_VAL is const0_rtx and the biv is    being set to INC_VAL.     NOT_EVERY_ITERATION is nonzero if this biv update is not know to be    executed every iteration; MAYBE_MULTIPLE is nonzero if this biv update    can be executed more than once per iteration.  If MAYBE_MULTIPLE    and NOT_EVERY_ITERATION are both zero, we know that the biv update is    executed exactly once per iteration.  */
end_comment

begin_function
specifier|static
name|void
name|record_biv
parameter_list|(
name|loop
parameter_list|,
name|v
parameter_list|,
name|insn
parameter_list|,
name|dest_reg
parameter_list|,
name|inc_val
parameter_list|,
name|mult_val
parameter_list|,
name|location
parameter_list|,
name|not_every_iteration
parameter_list|,
name|maybe_multiple
parameter_list|)
name|struct
name|loop
modifier|*
name|loop
decl_stmt|;
name|struct
name|induction
modifier|*
name|v
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|rtx
name|dest_reg
decl_stmt|;
name|rtx
name|inc_val
decl_stmt|;
name|rtx
name|mult_val
decl_stmt|;
name|rtx
modifier|*
name|location
decl_stmt|;
name|int
name|not_every_iteration
decl_stmt|;
name|int
name|maybe_multiple
decl_stmt|;
block|{
name|struct
name|loop_ivs
modifier|*
name|ivs
init|=
name|LOOP_IVS
argument_list|(
name|loop
argument_list|)
decl_stmt|;
name|struct
name|iv_class
modifier|*
name|bl
decl_stmt|;
name|v
operator|->
name|insn
operator|=
name|insn
expr_stmt|;
name|v
operator|->
name|src_reg
operator|=
name|dest_reg
expr_stmt|;
name|v
operator|->
name|dest_reg
operator|=
name|dest_reg
expr_stmt|;
name|v
operator|->
name|mult_val
operator|=
name|mult_val
expr_stmt|;
name|v
operator|->
name|add_val
operator|=
name|inc_val
expr_stmt|;
name|v
operator|->
name|ext_dependent
operator|=
name|NULL_RTX
expr_stmt|;
name|v
operator|->
name|location
operator|=
name|location
expr_stmt|;
name|v
operator|->
name|mode
operator|=
name|GET_MODE
argument_list|(
name|dest_reg
argument_list|)
expr_stmt|;
name|v
operator|->
name|always_computable
operator|=
operator|!
name|not_every_iteration
expr_stmt|;
name|v
operator|->
name|always_executed
operator|=
operator|!
name|not_every_iteration
expr_stmt|;
name|v
operator|->
name|maybe_multiple
operator|=
name|maybe_multiple
expr_stmt|;
name|v
operator|->
name|same
operator|=
literal|0
expr_stmt|;
comment|/* Add this to the reg's iv_class, creating a class      if this is the first incrementation of the reg.  */
name|bl
operator|=
name|REG_IV_CLASS
argument_list|(
name|ivs
argument_list|,
name|REGNO
argument_list|(
name|dest_reg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bl
operator|==
literal|0
condition|)
block|{
comment|/* Create and initialize new iv_class.  */
name|bl
operator|=
operator|(
expr|struct
name|iv_class
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|iv_class
argument_list|)
argument_list|)
expr_stmt|;
name|bl
operator|->
name|regno
operator|=
name|REGNO
argument_list|(
name|dest_reg
argument_list|)
expr_stmt|;
name|bl
operator|->
name|biv
operator|=
literal|0
expr_stmt|;
name|bl
operator|->
name|giv
operator|=
literal|0
expr_stmt|;
name|bl
operator|->
name|biv_count
operator|=
literal|0
expr_stmt|;
name|bl
operator|->
name|giv_count
operator|=
literal|0
expr_stmt|;
comment|/* Set initial value to the reg itself.  */
name|bl
operator|->
name|initial_value
operator|=
name|dest_reg
expr_stmt|;
name|bl
operator|->
name|final_value
operator|=
literal|0
expr_stmt|;
comment|/* We haven't seen the initializing insn yet */
name|bl
operator|->
name|init_insn
operator|=
literal|0
expr_stmt|;
name|bl
operator|->
name|init_set
operator|=
literal|0
expr_stmt|;
name|bl
operator|->
name|initial_test
operator|=
literal|0
expr_stmt|;
name|bl
operator|->
name|incremented
operator|=
literal|0
expr_stmt|;
name|bl
operator|->
name|eliminable
operator|=
literal|0
expr_stmt|;
name|bl
operator|->
name|nonneg
operator|=
literal|0
expr_stmt|;
name|bl
operator|->
name|reversed
operator|=
literal|0
expr_stmt|;
name|bl
operator|->
name|total_benefit
operator|=
literal|0
expr_stmt|;
comment|/* Add this class to ivs->list.  */
name|bl
operator|->
name|next
operator|=
name|ivs
operator|->
name|list
expr_stmt|;
name|ivs
operator|->
name|list
operator|=
name|bl
expr_stmt|;
comment|/* Put it in the array of biv register classes.  */
name|REG_IV_CLASS
argument_list|(
name|ivs
argument_list|,
name|REGNO
argument_list|(
name|dest_reg
argument_list|)
argument_list|)
operator|=
name|bl
expr_stmt|;
block|}
else|else
block|{
comment|/* Check if location is the same as a previous one.  */
name|struct
name|induction
modifier|*
name|induction
decl_stmt|;
for|for
control|(
name|induction
operator|=
name|bl
operator|->
name|biv
init|;
name|induction
condition|;
name|induction
operator|=
name|induction
operator|->
name|next_iv
control|)
if|if
condition|(
name|location
operator|==
name|induction
operator|->
name|location
condition|)
block|{
name|v
operator|->
name|same
operator|=
name|induction
expr_stmt|;
break|break;
block|}
block|}
comment|/* Update IV_CLASS entry for this biv.  */
name|v
operator|->
name|next_iv
operator|=
name|bl
operator|->
name|biv
expr_stmt|;
name|bl
operator|->
name|biv
operator|=
name|v
expr_stmt|;
name|bl
operator|->
name|biv_count
operator|++
expr_stmt|;
if|if
condition|(
name|mult_val
operator|==
name|const1_rtx
condition|)
name|bl
operator|->
name|incremented
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|loop_dump_stream
condition|)
name|loop_biv_dump
argument_list|(
name|v
argument_list|,
name|loop_dump_stream
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Fill in the data about one giv.    V is the `struct induction' in which we record the giv.  (It is    allocated by the caller, with alloca.)    INSN is the insn that sets it.    BENEFIT estimates the savings from deleting this insn.    TYPE is DEST_REG or DEST_ADDR; it says whether the giv is computed    into a register or is used as a memory address.     SRC_REG is the biv reg which the giv is computed from.    DEST_REG is the giv's reg (if the giv is stored in a reg).    MULT_VAL and ADD_VAL are the coefficients used to compute the giv.    LOCATION points to the place where this giv's value appears in INSN.  */
end_comment

begin_function
specifier|static
name|void
name|record_giv
parameter_list|(
name|loop
parameter_list|,
name|v
parameter_list|,
name|insn
parameter_list|,
name|src_reg
parameter_list|,
name|dest_reg
parameter_list|,
name|mult_val
parameter_list|,
name|add_val
parameter_list|,
name|ext_val
parameter_list|,
name|benefit
parameter_list|,
name|type
parameter_list|,
name|not_every_iteration
parameter_list|,
name|maybe_multiple
parameter_list|,
name|location
parameter_list|)
specifier|const
name|struct
name|loop
modifier|*
name|loop
decl_stmt|;
name|struct
name|induction
modifier|*
name|v
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|rtx
name|src_reg
decl_stmt|;
name|rtx
name|dest_reg
decl_stmt|;
name|rtx
name|mult_val
decl_stmt|,
name|add_val
decl_stmt|,
name|ext_val
decl_stmt|;
name|int
name|benefit
decl_stmt|;
name|enum
name|g_types
name|type
decl_stmt|;
name|int
name|not_every_iteration
decl_stmt|,
name|maybe_multiple
decl_stmt|;
name|rtx
modifier|*
name|location
decl_stmt|;
block|{
name|struct
name|loop_ivs
modifier|*
name|ivs
init|=
name|LOOP_IVS
argument_list|(
name|loop
argument_list|)
decl_stmt|;
name|struct
name|induction
modifier|*
name|b
decl_stmt|;
name|struct
name|iv_class
modifier|*
name|bl
decl_stmt|;
name|rtx
name|set
init|=
name|single_set
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|temp
decl_stmt|;
comment|/* Attempt to prove constantness of the values.  Don't let simplity_rtx      undo the MULT canonicalization that we performed earlier.  */
name|temp
operator|=
name|simplify_rtx
argument_list|(
name|add_val
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|add_val
argument_list|)
operator|==
name|MULT
operator|&&
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|==
name|ASHIFT
operator|)
condition|)
name|add_val
operator|=
name|temp
expr_stmt|;
name|v
operator|->
name|insn
operator|=
name|insn
expr_stmt|;
name|v
operator|->
name|src_reg
operator|=
name|src_reg
expr_stmt|;
name|v
operator|->
name|giv_type
operator|=
name|type
expr_stmt|;
name|v
operator|->
name|dest_reg
operator|=
name|dest_reg
expr_stmt|;
name|v
operator|->
name|mult_val
operator|=
name|mult_val
expr_stmt|;
name|v
operator|->
name|add_val
operator|=
name|add_val
expr_stmt|;
name|v
operator|->
name|ext_dependent
operator|=
name|ext_val
expr_stmt|;
name|v
operator|->
name|benefit
operator|=
name|benefit
expr_stmt|;
name|v
operator|->
name|location
operator|=
name|location
expr_stmt|;
name|v
operator|->
name|cant_derive
operator|=
literal|0
expr_stmt|;
name|v
operator|->
name|combined_with
operator|=
literal|0
expr_stmt|;
name|v
operator|->
name|maybe_multiple
operator|=
name|maybe_multiple
expr_stmt|;
name|v
operator|->
name|maybe_dead
operator|=
literal|0
expr_stmt|;
name|v
operator|->
name|derive_adjustment
operator|=
literal|0
expr_stmt|;
name|v
operator|->
name|same
operator|=
literal|0
expr_stmt|;
name|v
operator|->
name|ignore
operator|=
literal|0
expr_stmt|;
name|v
operator|->
name|new_reg
operator|=
literal|0
expr_stmt|;
name|v
operator|->
name|final_value
operator|=
literal|0
expr_stmt|;
name|v
operator|->
name|same_insn
operator|=
literal|0
expr_stmt|;
name|v
operator|->
name|auto_inc_opt
operator|=
literal|0
expr_stmt|;
name|v
operator|->
name|unrolled
operator|=
literal|0
expr_stmt|;
name|v
operator|->
name|shared
operator|=
literal|0
expr_stmt|;
comment|/* The v->always_computable field is used in update_giv_derive, to      determine whether a giv can be used to derive another giv.  For a      DEST_REG giv, INSN computes a new value for the giv, so its value      isn't computable if INSN insn't executed every iteration.      However, for a DEST_ADDR giv, INSN merely uses the value of the giv;      it does not compute a new value.  Hence the value is always computable      regardless of whether INSN is executed each iteration.  */
if|if
condition|(
name|type
operator|==
name|DEST_ADDR
condition|)
name|v
operator|->
name|always_computable
operator|=
literal|1
expr_stmt|;
else|else
name|v
operator|->
name|always_computable
operator|=
operator|!
name|not_every_iteration
expr_stmt|;
name|v
operator|->
name|always_executed
operator|=
operator|!
name|not_every_iteration
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|DEST_ADDR
condition|)
block|{
name|v
operator|->
name|mode
operator|=
name|GET_MODE
argument_list|(
operator|*
name|location
argument_list|)
expr_stmt|;
name|v
operator|->
name|lifetime
operator|=
literal|1
expr_stmt|;
block|}
else|else
comment|/* type == DEST_REG */
block|{
name|v
operator|->
name|mode
operator|=
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
expr_stmt|;
name|v
operator|->
name|lifetime
operator|=
name|LOOP_REG_LIFETIME
argument_list|(
name|loop
argument_list|,
name|REGNO
argument_list|(
name|dest_reg
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the lifetime is zero, it means that this register is 	 really a dead store.  So mark this as a giv that can be 	 ignored.  This will not prevent the biv from being eliminated.  */
if|if
condition|(
name|v
operator|->
name|lifetime
operator|==
literal|0
condition|)
name|v
operator|->
name|ignore
operator|=
literal|1
expr_stmt|;
name|REG_IV_TYPE
argument_list|(
name|ivs
argument_list|,
name|REGNO
argument_list|(
name|dest_reg
argument_list|)
argument_list|)
operator|=
name|GENERAL_INDUCT
expr_stmt|;
name|REG_IV_INFO
argument_list|(
name|ivs
argument_list|,
name|REGNO
argument_list|(
name|dest_reg
argument_list|)
argument_list|)
operator|=
name|v
expr_stmt|;
block|}
comment|/* Add the giv to the class of givs computed from one biv.  */
name|bl
operator|=
name|REG_IV_CLASS
argument_list|(
name|ivs
argument_list|,
name|REGNO
argument_list|(
name|src_reg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bl
condition|)
block|{
name|v
operator|->
name|next_iv
operator|=
name|bl
operator|->
name|giv
expr_stmt|;
name|bl
operator|->
name|giv
operator|=
name|v
expr_stmt|;
comment|/* Don't count DEST_ADDR.  This is supposed to count the number of 	 insns that calculate givs.  */
if|if
condition|(
name|type
operator|==
name|DEST_REG
condition|)
name|bl
operator|->
name|giv_count
operator|++
expr_stmt|;
name|bl
operator|->
name|total_benefit
operator|+=
name|benefit
expr_stmt|;
block|}
else|else
comment|/* Fatal error, biv missing for this giv?  */
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|DEST_ADDR
condition|)
block|{
name|v
operator|->
name|replaceable
operator|=
literal|1
expr_stmt|;
name|v
operator|->
name|not_replaceable
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* The giv can be replaced outright by the reduced register only if all 	 of the following conditions are true: 	 - the insn that sets the giv is always executed on any iteration 	   on which the giv is used at all 	   (there are two ways to deduce this: 	    either the insn is executed on every iteration, 	    or all uses follow that insn in the same basic block), 	 - the giv is not used outside the loop 	 - no assignments to the biv occur during the giv's lifetime.  */
if|if
condition|(
name|REGNO_FIRST_UID
argument_list|(
name|REGNO
argument_list|(
name|dest_reg
argument_list|)
argument_list|)
operator|==
name|INSN_UID
argument_list|(
name|insn
argument_list|)
comment|/* Previous line always fails if INSN was moved by loop opt.  */
operator|&&
name|REGNO_LAST_LUID
argument_list|(
name|REGNO
argument_list|(
name|dest_reg
argument_list|)
argument_list|)
operator|<
name|INSN_LUID
argument_list|(
name|loop
operator|->
name|end
argument_list|)
operator|&&
operator|(
operator|!
name|not_every_iteration
operator|||
name|last_use_this_basic_block
argument_list|(
name|dest_reg
argument_list|,
name|insn
argument_list|)
operator|)
condition|)
block|{
comment|/* Now check that there are no assignments to the biv within the 	     giv's lifetime.  This requires two separate checks.  */
comment|/* Check each biv update, and fail if any are between the first 	     and last use of the giv.  	     If this loop contains an inner loop that was unrolled, then 	     the insn modifying the biv may have been emitted by the loop 	     unrolling code, and hence does not have a valid luid.  Just 	     mark the biv as not replaceable in this case.  It is not very 	     useful as a biv, because it is used in two different loops. 	     It is very unlikely that we would be able to optimize the giv 	     using this biv anyways.  */
name|v
operator|->
name|replaceable
operator|=
literal|1
expr_stmt|;
name|v
operator|->
name|not_replaceable
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|b
operator|=
name|bl
operator|->
name|biv
init|;
name|b
condition|;
name|b
operator|=
name|b
operator|->
name|next_iv
control|)
block|{
if|if
condition|(
name|INSN_UID
argument_list|(
name|b
operator|->
name|insn
argument_list|)
operator|>=
name|max_uid_for_loop
operator|||
operator|(
operator|(
name|INSN_LUID
argument_list|(
name|b
operator|->
name|insn
argument_list|)
operator|>=
name|REGNO_FIRST_LUID
argument_list|(
name|REGNO
argument_list|(
name|dest_reg
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
name|INSN_LUID
argument_list|(
name|b
operator|->
name|insn
argument_list|)
operator|<=
name|REGNO_LAST_LUID
argument_list|(
name|REGNO
argument_list|(
name|dest_reg
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
block|{
name|v
operator|->
name|replaceable
operator|=
literal|0
expr_stmt|;
name|v
operator|->
name|not_replaceable
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
comment|/* If there are any backwards branches that go from after the 	     biv update to before it, then this giv is not replaceable.  */
if|if
condition|(
name|v
operator|->
name|replaceable
condition|)
for|for
control|(
name|b
operator|=
name|bl
operator|->
name|biv
init|;
name|b
condition|;
name|b
operator|=
name|b
operator|->
name|next_iv
control|)
if|if
condition|(
name|back_branch_in_range_p
argument_list|(
name|loop
argument_list|,
name|b
operator|->
name|insn
argument_list|)
condition|)
block|{
name|v
operator|->
name|replaceable
operator|=
literal|0
expr_stmt|;
name|v
operator|->
name|not_replaceable
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
comment|/* May still be replaceable, we don't have enough info here to 	     decide.  */
name|v
operator|->
name|replaceable
operator|=
literal|0
expr_stmt|;
name|v
operator|->
name|not_replaceable
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Record whether the add_val contains a const_int, for later use by      combine_givs.  */
block|{
name|rtx
name|tem
init|=
name|add_val
decl_stmt|;
name|v
operator|->
name|no_const_addval
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|tem
operator|==
name|const0_rtx
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|add_val
argument_list|)
condition|)
name|v
operator|->
name|no_const_addval
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|PLUS
condition|)
block|{
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
condition|)
name|tem
operator|=
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|PLUS
condition|)
name|tem
operator|=
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
break|break;
block|}
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
name|v
operator|->
name|no_const_addval
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|loop_dump_stream
condition|)
name|loop_giv_dump
argument_list|(
name|v
argument_list|,
name|loop_dump_stream
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* All this does is determine whether a giv can be made replaceable because    its final value can be calculated.  This code can not be part of record_giv    above, because final_giv_value requires that the number of loop iterations    be known, and that can not be accurately calculated until after all givs    have been identified.  */
end_comment

begin_function
specifier|static
name|void
name|check_final_value
parameter_list|(
name|loop
parameter_list|,
name|v
parameter_list|)
specifier|const
name|struct
name|loop
modifier|*
name|loop
decl_stmt|;
name|struct
name|induction
modifier|*
name|v
decl_stmt|;
block|{
name|struct
name|loop_ivs
modifier|*
name|ivs
init|=
name|LOOP_IVS
argument_list|(
name|loop
argument_list|)
decl_stmt|;
name|struct
name|iv_class
modifier|*
name|bl
decl_stmt|;
name|rtx
name|final_value
init|=
literal|0
decl_stmt|;
name|bl
operator|=
name|REG_IV_CLASS
argument_list|(
name|ivs
argument_list|,
name|REGNO
argument_list|(
name|v
operator|->
name|src_reg
argument_list|)
argument_list|)
expr_stmt|;
comment|/* DEST_ADDR givs will never reach here, because they are always marked      replaceable above in record_giv.  */
comment|/* The giv can be replaced outright by the reduced register only if all      of the following conditions are true:      - the insn that sets the giv is always executed on any iteration        on which the giv is used at all        (there are two ways to deduce this:         either the insn is executed on every iteration,         or all uses follow that insn in the same basic block),      - its final value can be calculated (this condition is different        than the one above in record_giv)      - it's not used before the it's set      - no assignments to the biv occur during the giv's lifetime.  */
if|#
directive|if
literal|0
comment|/* This is only called now when replaceable is known to be false.  */
comment|/* Clear replaceable, so that it won't confuse final_giv_value.  */
block|v->replaceable = 0;
endif|#
directive|endif
if|if
condition|(
operator|(
name|final_value
operator|=
name|final_giv_value
argument_list|(
name|loop
argument_list|,
name|v
argument_list|)
operator|)
operator|&&
operator|(
name|v
operator|->
name|always_executed
operator|||
name|last_use_this_basic_block
argument_list|(
name|v
operator|->
name|dest_reg
argument_list|,
name|v
operator|->
name|insn
argument_list|)
operator|)
condition|)
block|{
name|int
name|biv_increment_seen
init|=
literal|0
decl_stmt|,
name|before_giv_insn
init|=
literal|0
decl_stmt|;
name|rtx
name|p
init|=
name|v
operator|->
name|insn
decl_stmt|;
name|rtx
name|last_giv_use
decl_stmt|;
name|v
operator|->
name|replaceable
operator|=
literal|1
expr_stmt|;
name|v
operator|->
name|not_replaceable
operator|=
literal|0
expr_stmt|;
comment|/* When trying to determine whether or not a biv increment occurs 	 during the lifetime of the giv, we can ignore uses of the variable 	 outside the loop because final_value is true.  Hence we can not 	 use regno_last_uid and regno_first_uid as above in record_giv.  */
comment|/* Search the loop to determine whether any assignments to the 	 biv occur during the giv's lifetime.  Start with the insn 	 that sets the giv, and search around the loop until we come 	 back to that insn again.  	 Also fail if there is a jump within the giv's lifetime that jumps 	 to somewhere outside the lifetime but still within the loop.  This 	 catches spaghetti code where the execution order is not linear, and 	 hence the above test fails.  Here we assume that the giv lifetime 	 does not extend from one iteration of the loop to the next, so as 	 to make the test easier.  Since the lifetime isn't known yet, 	 this requires two loops.  See also record_giv above.  */
name|last_giv_use
operator|=
name|v
operator|->
name|insn
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|loop
operator|->
name|end
condition|)
block|{
name|before_giv_insn
operator|=
literal|1
expr_stmt|;
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|loop
operator|->
name|start
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|==
name|v
operator|->
name|insn
condition|)
break|break;
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|JUMP_INSN
operator|||
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
comment|/* It is possible for the BIV increment to use the GIV if we 		 have a cycle.  Thus we must be sure to check each insn for 		 both BIV and GIV uses, and we must check for BIV uses 		 first.  */
if|if
condition|(
operator|!
name|biv_increment_seen
operator|&&
name|reg_set_p
argument_list|(
name|v
operator|->
name|src_reg
argument_list|,
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
condition|)
name|biv_increment_seen
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|reg_mentioned_p
argument_list|(
name|v
operator|->
name|dest_reg
argument_list|,
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|biv_increment_seen
operator|||
name|before_giv_insn
condition|)
block|{
name|v
operator|->
name|replaceable
operator|=
literal|0
expr_stmt|;
name|v
operator|->
name|not_replaceable
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|last_giv_use
operator|=
name|p
expr_stmt|;
block|}
block|}
block|}
comment|/* Now that the lifetime of the giv is known, check for branches 	 from within the lifetime to outside the lifetime if it is still 	 replaceable.  */
if|if
condition|(
name|v
operator|->
name|replaceable
condition|)
block|{
name|p
operator|=
name|v
operator|->
name|insn
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|loop
operator|->
name|end
condition|)
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|loop
operator|->
name|start
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|last_giv_use
condition|)
break|break;
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|JUMP_LABEL
argument_list|(
name|p
argument_list|)
operator|&&
name|LABEL_NAME
argument_list|(
name|JUMP_LABEL
argument_list|(
name|p
argument_list|)
argument_list|)
operator|&&
operator|(
operator|(
name|loop_insn_first_p
argument_list|(
name|JUMP_LABEL
argument_list|(
name|p
argument_list|)
argument_list|,
name|v
operator|->
name|insn
argument_list|)
operator|&&
name|loop_insn_first_p
argument_list|(
name|loop
operator|->
name|start
argument_list|,
name|JUMP_LABEL
argument_list|(
name|p
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|loop_insn_first_p
argument_list|(
name|last_giv_use
argument_list|,
name|JUMP_LABEL
argument_list|(
name|p
argument_list|)
argument_list|)
operator|&&
name|loop_insn_first_p
argument_list|(
name|JUMP_LABEL
argument_list|(
name|p
argument_list|)
argument_list|,
name|loop
operator|->
name|end
argument_list|)
operator|)
operator|)
condition|)
block|{
name|v
operator|->
name|replaceable
operator|=
literal|0
expr_stmt|;
name|v
operator|->
name|not_replaceable
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Found branch outside giv lifetime.\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* If it is replaceable, then save the final value.  */
if|if
condition|(
name|v
operator|->
name|replaceable
condition|)
name|v
operator|->
name|final_value
operator|=
name|final_value
expr_stmt|;
block|}
if|if
condition|(
name|loop_dump_stream
operator|&&
name|v
operator|->
name|replaceable
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Insn %d: giv reg %d final_value replaceable\n"
argument_list|,
name|INSN_UID
argument_list|(
name|v
operator|->
name|insn
argument_list|)
argument_list|,
name|REGNO
argument_list|(
name|v
operator|->
name|dest_reg
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Update the status of whether a giv can derive other givs.     We need to do something special if there is or may be an update to the biv    between the time the giv is defined and the time it is used to derive    another giv.     In addition, a giv that is only conditionally set is not allowed to    derive another giv once a label has been passed.     The cases we look at are when a label or an update to a biv is passed.  */
end_comment

begin_function
specifier|static
name|void
name|update_giv_derive
parameter_list|(
name|loop
parameter_list|,
name|p
parameter_list|)
specifier|const
name|struct
name|loop
modifier|*
name|loop
decl_stmt|;
name|rtx
name|p
decl_stmt|;
block|{
name|struct
name|loop_ivs
modifier|*
name|ivs
init|=
name|LOOP_IVS
argument_list|(
name|loop
argument_list|)
decl_stmt|;
name|struct
name|iv_class
modifier|*
name|bl
decl_stmt|;
name|struct
name|induction
modifier|*
name|biv
decl_stmt|,
modifier|*
name|giv
decl_stmt|;
name|rtx
name|tem
decl_stmt|;
name|int
name|dummy
decl_stmt|;
comment|/* Search all IV classes, then all bivs, and finally all givs.       There are three cases we are concerned with.  First we have the situation      of a giv that is only updated conditionally.  In that case, it may not      derive any givs after a label is passed.       The second case is when a biv update occurs, or may occur, after the      definition of a giv.  For certain biv updates (see below) that are      known to occur between the giv definition and use, we can adjust the      giv definition.  For others, or when the biv update is conditional,      we must prevent the giv from deriving any other givs.  There are two      sub-cases within this case.       If this is a label, we are concerned with any biv update that is done      conditionally, since it may be done after the giv is defined followed by      a branch here (actually, we need to pass both a jump and a label, but      this extra tracking doesn't seem worth it).       If this is a jump, we are concerned about any biv update that may be      executed multiple times.  We are actually only concerned about      backward jumps, but it is probably not worth performing the test      on the jump again here.       If this is a biv update, we must adjust the giv status to show that a      subsequent biv update was performed.  If this adjustment cannot be done,      the giv cannot derive further givs.  */
for|for
control|(
name|bl
operator|=
name|ivs
operator|->
name|list
init|;
name|bl
condition|;
name|bl
operator|=
name|bl
operator|->
name|next
control|)
for|for
control|(
name|biv
operator|=
name|bl
operator|->
name|biv
init|;
name|biv
condition|;
name|biv
operator|=
name|biv
operator|->
name|next_iv
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|CODE_LABEL
operator|||
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|JUMP_INSN
operator|||
name|biv
operator|->
name|insn
operator|==
name|p
condition|)
block|{
for|for
control|(
name|giv
operator|=
name|bl
operator|->
name|giv
init|;
name|giv
condition|;
name|giv
operator|=
name|giv
operator|->
name|next_iv
control|)
block|{
comment|/* If cant_derive is already true, there is no point in 		 checking all of these conditions again.  */
if|if
condition|(
name|giv
operator|->
name|cant_derive
condition|)
continue|continue;
comment|/* If this giv is conditionally set and we have passed a label, 		 it cannot derive anything.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|CODE_LABEL
operator|&&
operator|!
name|giv
operator|->
name|always_computable
condition|)
name|giv
operator|->
name|cant_derive
operator|=
literal|1
expr_stmt|;
comment|/* Skip givs that have mult_val == 0, since 		 they are really invariants.  Also skip those that are 		 replaceable, since we know their lifetime doesn't contain 		 any biv update.  */
elseif|else
if|if
condition|(
name|giv
operator|->
name|mult_val
operator|==
name|const0_rtx
operator|||
name|giv
operator|->
name|replaceable
condition|)
continue|continue;
comment|/* The only way we can allow this giv to derive another 		 is if this is a biv increment and we can form the product 		 of biv->add_val and giv->mult_val.  In this case, we will 		 be able to compute a compensation.  */
elseif|else
if|if
condition|(
name|biv
operator|->
name|insn
operator|==
name|p
condition|)
block|{
name|rtx
name|ext_val_dummy
decl_stmt|;
name|tem
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|biv
operator|->
name|mult_val
operator|==
name|const1_rtx
condition|)
name|tem
operator|=
name|simplify_giv_expr
argument_list|(
name|loop
argument_list|,
name|gen_rtx_MULT
argument_list|(
name|giv
operator|->
name|mode
argument_list|,
name|biv
operator|->
name|add_val
argument_list|,
name|giv
operator|->
name|mult_val
argument_list|)
argument_list|,
operator|&
name|ext_val_dummy
argument_list|,
operator|&
name|dummy
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
operator|&&
name|giv
operator|->
name|derive_adjustment
condition|)
name|tem
operator|=
name|simplify_giv_expr
argument_list|(
name|loop
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|giv
operator|->
name|mode
argument_list|,
name|tem
argument_list|,
name|giv
operator|->
name|derive_adjustment
argument_list|)
argument_list|,
operator|&
name|ext_val_dummy
argument_list|,
operator|&
name|dummy
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
condition|)
name|giv
operator|->
name|derive_adjustment
operator|=
name|tem
expr_stmt|;
else|else
name|giv
operator|->
name|cant_derive
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|CODE_LABEL
operator|&&
operator|!
name|biv
operator|->
name|always_computable
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|biv
operator|->
name|maybe_multiple
operator|)
condition|)
name|giv
operator|->
name|cant_derive
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Check whether an insn is an increment legitimate for a basic induction var.    X is the source of insn P, or a part of it.    MODE is the mode in which X should be interpreted.     DEST_REG is the putative biv, also the destination of the insn.    We accept patterns of these forms:      REG = REG + INVARIANT (includes REG = REG - CONSTANT)      REG = INVARIANT + REG     If X is suitable, we return 1, set *MULT_VAL to CONST1_RTX,    store the additive term into *INC_VAL, and store the place where    we found the additive term into *LOCATION.     If X is an assignment of an invariant into DEST_REG, we set    *MULT_VAL to CONST0_RTX, and store the invariant into *INC_VAL.     We also want to detect a BIV when it corresponds to a variable    whose mode was promoted via PROMOTED_MODE.  In that case, an increment    of the variable may be a PLUS that adds a SUBREG of that variable to    an invariant and then sign- or zero-extends the result of the PLUS    into the variable.     Most GIVs in such cases will be in the promoted mode, since that is the    probably the natural computation mode (and almost certainly the mode    used for addresses) on the machine.  So we view the pseudo-reg containing    the variable as the BIV, as if it were simply incremented.     Note that treating the entire pseudo as a BIV will result in making    simple increments to any GIVs based on it.  However, if the variable    overflows in its declared mode but not its promoted mode, the result will    be incorrect.  This is acceptable if the variable is signed, since    overflows in such cases are undefined, but not if it is unsigned, since    those overflows are defined.  So we only check for SIGN_EXTEND and    not ZERO_EXTEND.     If we cannot find a biv, we return 0.  */
end_comment

begin_function
specifier|static
name|int
name|basic_induction_var
parameter_list|(
name|loop
parameter_list|,
name|x
parameter_list|,
name|mode
parameter_list|,
name|dest_reg
parameter_list|,
name|p
parameter_list|,
name|inc_val
parameter_list|,
name|mult_val
parameter_list|,
name|location
parameter_list|)
specifier|const
name|struct
name|loop
modifier|*
name|loop
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|dest_reg
decl_stmt|;
name|rtx
name|p
decl_stmt|;
name|rtx
modifier|*
name|inc_val
decl_stmt|;
name|rtx
modifier|*
name|mult_val
decl_stmt|;
name|rtx
modifier|*
modifier|*
name|location
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
decl_stmt|;
name|rtx
modifier|*
name|argp
decl_stmt|,
name|arg
decl_stmt|;
name|rtx
name|insn
decl_stmt|,
name|set
init|=
literal|0
decl_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
operator|*
name|location
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PLUS
case|:
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|dest_reg
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
name|SUBREG_PROMOTED_VAR_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|dest_reg
operator|)
condition|)
block|{
name|argp
operator|=
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|dest_reg
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
name|SUBREG_PROMOTED_VAR_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|dest_reg
operator|)
condition|)
block|{
name|argp
operator|=
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
return|return
literal|0
return|;
name|arg
operator|=
operator|*
name|argp
expr_stmt|;
if|if
condition|(
name|loop_invariant_p
argument_list|(
name|loop
argument_list|,
name|arg
argument_list|)
operator|!=
literal|1
condition|)
return|return
literal|0
return|;
operator|*
name|inc_val
operator|=
name|convert_modes
argument_list|(
name|GET_MODE
argument_list|(
name|dest_reg
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|arg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|mult_val
operator|=
name|const1_rtx
expr_stmt|;
operator|*
name|location
operator|=
name|argp
expr_stmt|;
return|return
literal|1
return|;
case|case
name|SUBREG
case|:
comment|/* If what's inside the SUBREG is a BIV, then the SUBREG.  This will 	 handle addition of promoted variables. 	 ??? The comment at the start of this function is wrong: promoted 	 variable increments don't look like it says they do.  */
return|return
name|basic_induction_var
argument_list|(
name|loop
argument_list|,
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|dest_reg
argument_list|,
name|p
argument_list|,
name|inc_val
argument_list|,
name|mult_val
argument_list|,
name|location
argument_list|)
return|;
case|case
name|REG
case|:
comment|/* If this register is assigned in a previous insn, look at its 	 source, but don't go outside the loop or past a label.  */
comment|/* If this sets a register to itself, we would repeat any previous 	 biv increment if we applied this strategy blindly.  */
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|dest_reg
argument_list|,
name|x
argument_list|)
condition|)
return|return
literal|0
return|;
name|insn
operator|=
name|p
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|rtx
name|dest
decl_stmt|;
do|do
block|{
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|insn
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE_INSN_LOOP_BEG
condition|)
do|;
if|if
condition|(
operator|!
name|insn
condition|)
break|break;
name|set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|set
operator|==
literal|0
condition|)
break|break;
name|dest
operator|=
name|SET_DEST
argument_list|(
name|set
argument_list|)
expr_stmt|;
if|if
condition|(
name|dest
operator|==
name|x
operator|||
operator|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|<=
name|UNITS_PER_WORD
operator|)
operator|&&
operator|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|==
name|MODE_INT
operator|)
operator|&&
name|SUBREG_REG
argument_list|(
name|dest
argument_list|)
operator|==
name|x
operator|)
condition|)
return|return
name|basic_induction_var
argument_list|(
name|loop
argument_list|,
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
operator|(
name|GET_MODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|VOIDmode
condition|?
name|GET_MODE
argument_list|(
name|x
argument_list|)
else|:
name|GET_MODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|)
argument_list|,
name|dest_reg
argument_list|,
name|insn
argument_list|,
name|inc_val
argument_list|,
name|mult_val
argument_list|,
name|location
argument_list|)
return|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SIGN_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|STRICT_LOW_PART
condition|)
name|dest
operator|=
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|dest
operator|==
name|x
condition|)
break|break;
block|}
comment|/* Fall through.  */
comment|/* Can accept constant setting of biv only when inside inner most loop. 	 Otherwise, a biv of an inner loop may be incorrectly recognized 	 as a biv of the outer loop, 	 causing code to be moved INTO the inner loop.  */
case|case
name|MEM
case|:
if|if
condition|(
name|loop_invariant_p
argument_list|(
name|loop
argument_list|,
name|x
argument_list|)
operator|!=
literal|1
condition|)
return|return
literal|0
return|;
case|case
name|CONST_INT
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|CONST
case|:
comment|/* convert_modes aborts if we try to convert to or from CCmode, so just          exclude that case.  It is very unlikely that a condition code value 	 would be a useful iterator anyways.  convert_modes aborts if we try to 	 convert a float mode to non-float or vice versa too.  */
if|if
condition|(
name|loop
operator|->
name|level
operator|==
literal|1
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|dest_reg
argument_list|)
argument_list|)
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|!=
name|MODE_CC
condition|)
block|{
comment|/* Possible bug here?  Perhaps we don't know the mode of X.  */
operator|*
name|inc_val
operator|=
name|convert_modes
argument_list|(
name|GET_MODE
argument_list|(
name|dest_reg
argument_list|)
argument_list|,
name|mode
argument_list|,
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|mult_val
operator|=
name|const0_rtx
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
return|return
literal|0
return|;
case|case
name|SIGN_EXTEND
case|:
return|return
name|basic_induction_var
argument_list|(
name|loop
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|dest_reg
argument_list|,
name|p
argument_list|,
name|inc_val
argument_list|,
name|mult_val
argument_list|,
name|location
argument_list|)
return|;
case|case
name|ASHIFTRT
case|:
comment|/* Similar, since this can be a sign extension.  */
for|for
control|(
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|p
argument_list|)
init|;
operator|(
name|insn
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE_INSN_LOOP_BEG
operator|)
condition|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
control|)
empty_stmt|;
if|if
condition|(
name|insn
condition|)
name|set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rtx_equal_p
argument_list|(
name|dest_reg
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|set
operator|&&
name|SET_DEST
argument_list|(
name|set
argument_list|)
operator|==
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|>=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|ASHIFT
operator|&&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|==
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|basic_induction_var
argument_list|(
name|loop
argument_list|,
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|dest_reg
argument_list|,
name|insn
argument_list|,
name|inc_val
argument_list|,
name|mult_val
argument_list|,
name|location
argument_list|)
return|;
return|return
literal|0
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* A general induction variable (giv) is any quantity that is a linear    function   of a basic induction variable,    i.e. giv = biv * mult_val + add_val.    The coefficients can be any loop invariant quantity.    A giv need not be computed directly from the biv;    it can be computed by way of other givs.  */
end_comment

begin_comment
comment|/* Determine whether X computes a giv.    If it does, return a nonzero value      which is the benefit from eliminating the computation of X;    set *SRC_REG to the register of the biv that it is computed from;    set *ADD_VAL and *MULT_VAL to the coefficients,      such that the value of X is biv * mult + add;  */
end_comment

begin_function
specifier|static
name|int
name|general_induction_var
parameter_list|(
name|loop
parameter_list|,
name|x
parameter_list|,
name|src_reg
parameter_list|,
name|add_val
parameter_list|,
name|mult_val
parameter_list|,
name|ext_val
parameter_list|,
name|is_addr
parameter_list|,
name|pbenefit
parameter_list|,
name|addr_mode
parameter_list|)
specifier|const
name|struct
name|loop
modifier|*
name|loop
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|rtx
modifier|*
name|src_reg
decl_stmt|;
name|rtx
modifier|*
name|add_val
decl_stmt|;
name|rtx
modifier|*
name|mult_val
decl_stmt|;
name|rtx
modifier|*
name|ext_val
decl_stmt|;
name|int
name|is_addr
decl_stmt|;
name|int
modifier|*
name|pbenefit
decl_stmt|;
name|enum
name|machine_mode
name|addr_mode
decl_stmt|;
block|{
name|struct
name|loop_ivs
modifier|*
name|ivs
init|=
name|LOOP_IVS
argument_list|(
name|loop
argument_list|)
decl_stmt|;
name|rtx
name|orig_x
init|=
name|x
decl_stmt|;
comment|/* If this is an invariant, forget it, it isn't a giv.  */
if|if
condition|(
name|loop_invariant_p
argument_list|(
name|loop
argument_list|,
name|x
argument_list|)
operator|==
literal|1
condition|)
return|return
literal|0
return|;
operator|*
name|pbenefit
operator|=
literal|0
expr_stmt|;
operator|*
name|ext_val
operator|=
name|NULL_RTX
expr_stmt|;
name|x
operator|=
name|simplify_giv_expr
argument_list|(
name|loop
argument_list|,
name|x
argument_list|,
name|ext_val
argument_list|,
name|pbenefit
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|USE
case|:
case|case
name|CONST_INT
case|:
comment|/* Since this is now an invariant and wasn't before, it must be a giv 	 with MULT_VAL == 0.  It doesn't matter which BIV we associate this 	 with.  */
operator|*
name|src_reg
operator|=
name|ivs
operator|->
name|list
operator|->
name|biv
operator|->
name|dest_reg
expr_stmt|;
operator|*
name|mult_val
operator|=
name|const0_rtx
expr_stmt|;
operator|*
name|add_val
operator|=
name|x
expr_stmt|;
break|break;
case|case
name|REG
case|:
comment|/* This is equivalent to a BIV.  */
operator|*
name|src_reg
operator|=
name|x
expr_stmt|;
operator|*
name|mult_val
operator|=
name|const1_rtx
expr_stmt|;
operator|*
name|add_val
operator|=
name|const0_rtx
expr_stmt|;
break|break;
case|case
name|PLUS
case|:
comment|/* Either (plus (biv) (invar)) or 	 (plus (mult (biv) (invar_1)) (invar_2)).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MULT
condition|)
block|{
operator|*
name|src_reg
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|mult_val
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|src_reg
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|mult_val
operator|=
name|const1_rtx
expr_stmt|;
block|}
operator|*
name|add_val
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|MULT
case|:
comment|/* ADD_VAL is zero.  */
operator|*
name|src_reg
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|mult_val
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|*
name|add_val
operator|=
name|const0_rtx
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Remove any enclosing USE from ADD_VAL and MULT_VAL (there will be      unless they are CONST_INT).  */
if|if
condition|(
name|GET_CODE
argument_list|(
operator|*
name|add_val
argument_list|)
operator|==
name|USE
condition|)
operator|*
name|add_val
operator|=
name|XEXP
argument_list|(
operator|*
name|add_val
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
operator|*
name|mult_val
argument_list|)
operator|==
name|USE
condition|)
operator|*
name|mult_val
operator|=
name|XEXP
argument_list|(
operator|*
name|mult_val
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_addr
condition|)
operator|*
name|pbenefit
operator|+=
name|address_cost
argument_list|(
name|orig_x
argument_list|,
name|addr_mode
argument_list|)
operator|-
name|reg_address_cost
expr_stmt|;
else|else
operator|*
name|pbenefit
operator|+=
name|rtx_cost
argument_list|(
name|orig_x
argument_list|,
name|SET
argument_list|)
expr_stmt|;
comment|/* Always return true if this is a giv so it will be detected as such,      even if the benefit is zero or negative.  This allows elimination      of bivs that might otherwise not be eliminated.  */
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given an expression, X, try to form it as a linear function of a biv.    We will canonicalize it to be of the form 	(plus (mult (BIV) (invar_1)) 	      (invar_2))    with possible degeneracies.     The invariant expressions must each be of a form that can be used as a    machine operand.  We surround then with a USE rtx (a hack, but localized    and certainly unambiguous!) if not a CONST_INT for simplicity in this    routine; it is the caller's responsibility to strip them.     If no such canonicalization is possible (i.e., two biv's are used or an    expression that is neither invariant nor a biv or giv), this routine    returns 0.     For a nonzero return, the result will have a code of CONST_INT, USE,    REG (for a BIV), PLUS, or MULT.  No other codes will occur.     *BENEFIT will be incremented by the benefit of any sub-giv encountered.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|sge_plus
name|PARAMS
argument_list|(
operator|(
expr|enum
name|machine_mode
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|sge_plus_constant
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|rtx
name|simplify_giv_expr
parameter_list|(
name|loop
parameter_list|,
name|x
parameter_list|,
name|ext_val
parameter_list|,
name|benefit
parameter_list|)
specifier|const
name|struct
name|loop
modifier|*
name|loop
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|rtx
modifier|*
name|ext_val
decl_stmt|;
name|int
modifier|*
name|benefit
decl_stmt|;
block|{
name|struct
name|loop_ivs
modifier|*
name|ivs
init|=
name|LOOP_IVS
argument_list|(
name|loop
argument_list|)
decl_stmt|;
name|struct
name|loop_regs
modifier|*
name|regs
init|=
name|LOOP_REGS
argument_list|(
name|loop
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|rtx
name|arg0
decl_stmt|,
name|arg1
decl_stmt|;
name|rtx
name|tem
decl_stmt|;
comment|/* If this is not an integer mode, or if we cannot do arithmetic in this      mode, this can't be a giv.  */
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
operator|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|!=
name|MODE_INT
operator|||
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|>
name|HOST_BITS_PER_WIDE_INT
operator|)
condition|)
return|return
name|NULL_RTX
return|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|PLUS
case|:
name|arg0
operator|=
name|simplify_giv_expr
argument_list|(
name|loop
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|ext_val
argument_list|,
name|benefit
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|simplify_giv_expr
argument_list|(
name|loop
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|ext_val
argument_list|,
name|benefit
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg0
operator|==
literal|0
operator|||
name|arg1
operator|==
literal|0
condition|)
return|return
name|NULL_RTX
return|;
comment|/* Put constant last, CONST_INT last if both constant.  */
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|USE
operator|||
name|GET_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|CONST_INT
operator|)
operator|&&
operator|!
operator|(
operator|(
name|GET_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|USE
operator|&&
name|GET_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|USE
operator|)
operator|||
name|GET_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|CONST_INT
operator|)
condition|)
name|tem
operator|=
name|arg0
operator|,
name|arg0
operator|=
name|arg1
operator|,
name|arg1
operator|=
name|tem
expr_stmt|;
comment|/* Handle addition of zero, then addition of an invariant.  */
if|if
condition|(
name|arg1
operator|==
name|const0_rtx
condition|)
return|return
name|arg0
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|CONST_INT
operator|||
name|GET_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|USE
condition|)
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|arg0
argument_list|)
condition|)
block|{
case|case
name|CONST_INT
case|:
case|case
name|USE
case|:
comment|/* Adding two invariants must result in an invariant, so enclose 	       addition operation inside a USE and return it.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|USE
condition|)
name|arg0
operator|=
name|XEXP
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|USE
condition|)
name|arg1
operator|=
name|XEXP
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|CONST_INT
condition|)
name|tem
operator|=
name|arg0
operator|,
name|arg0
operator|=
name|arg1
operator|,
name|arg1
operator|=
name|tem
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|CONST_INT
condition|)
name|tem
operator|=
name|sge_plus_constant
argument_list|(
name|arg0
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
else|else
name|tem
operator|=
name|sge_plus
argument_list|(
name|mode
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|!=
name|CONST_INT
condition|)
name|tem
operator|=
name|gen_rtx_USE
argument_list|(
name|mode
argument_list|,
name|tem
argument_list|)
expr_stmt|;
return|return
name|tem
return|;
case|case
name|REG
case|:
case|case
name|MULT
case|:
comment|/* biv + invar or mult + invar.  Return sum.  */
return|return
name|gen_rtx_PLUS
argument_list|(
name|mode
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
return|;
case|case
name|PLUS
case|:
comment|/* (a + invar_1) + invar_2.  Associate.  */
return|return
name|simplify_giv_expr
argument_list|(
name|loop
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|arg1
argument_list|)
argument_list|)
argument_list|,
name|ext_val
argument_list|,
name|benefit
argument_list|)
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Each argument must be either REG, PLUS, or MULT.  Convert REG to 	 MULT to reduce cases.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|REG
condition|)
name|arg0
operator|=
name|gen_rtx_MULT
argument_list|(
name|mode
argument_list|,
name|arg0
argument_list|,
name|const1_rtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|REG
condition|)
name|arg1
operator|=
name|gen_rtx_MULT
argument_list|(
name|mode
argument_list|,
name|arg1
argument_list|,
name|const1_rtx
argument_list|)
expr_stmt|;
comment|/* Now have PLUS + PLUS, PLUS + MULT, MULT + PLUS, or MULT + MULT. 	 Put a MULT first, leaving PLUS + PLUS, MULT + PLUS, or MULT + MULT. 	 Recurse to associate the second PLUS.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|MULT
condition|)
name|tem
operator|=
name|arg0
operator|,
name|arg0
operator|=
name|arg1
operator|,
name|arg1
operator|=
name|tem
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|PLUS
condition|)
return|return
name|simplify_giv_expr
argument_list|(
name|loop
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|mode
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|mode
argument_list|,
name|arg0
argument_list|,
name|XEXP
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|ext_val
argument_list|,
name|benefit
argument_list|)
return|;
comment|/* Now must have MULT + MULT.  Distribute if same biv, else not giv.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|arg0
argument_list|)
operator|!=
name|MULT
operator|||
name|GET_CODE
argument_list|(
name|arg1
argument_list|)
operator|!=
name|MULT
condition|)
return|return
name|NULL_RTX
return|;
if|if
condition|(
operator|!
name|rtx_equal_p
argument_list|(
name|arg0
argument_list|,
name|arg1
argument_list|)
condition|)
return|return
name|NULL_RTX
return|;
return|return
name|simplify_giv_expr
argument_list|(
name|loop
argument_list|,
name|gen_rtx_MULT
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|ext_val
argument_list|,
name|benefit
argument_list|)
return|;
case|case
name|MINUS
case|:
comment|/* Handle "a - b" as "a + b * (-1)".  */
return|return
name|simplify_giv_expr
argument_list|(
name|loop
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|gen_rtx_MULT
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|constm1_rtx
argument_list|)
argument_list|)
argument_list|,
name|ext_val
argument_list|,
name|benefit
argument_list|)
return|;
case|case
name|MULT
case|:
name|arg0
operator|=
name|simplify_giv_expr
argument_list|(
name|loop
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|ext_val
argument_list|,
name|benefit
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|simplify_giv_expr
argument_list|(
name|loop
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|ext_val
argument_list|,
name|benefit
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg0
operator|==
literal|0
operator|||
name|arg1
operator|==
literal|0
condition|)
return|return
name|NULL_RTX
return|;
comment|/* Put constant last, CONST_INT last if both constant.  */
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|USE
operator|||
name|GET_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|CONST_INT
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|arg1
argument_list|)
operator|!=
name|CONST_INT
condition|)
name|tem
operator|=
name|arg0
operator|,
name|arg0
operator|=
name|arg1
operator|,
name|arg1
operator|=
name|tem
expr_stmt|;
comment|/* If second argument is not now constant, not giv.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|arg1
argument_list|)
operator|!=
name|USE
operator|&&
name|GET_CODE
argument_list|(
name|arg1
argument_list|)
operator|!=
name|CONST_INT
condition|)
return|return
name|NULL_RTX
return|;
comment|/* Handle multiply by 0 or 1.  */
if|if
condition|(
name|arg1
operator|==
name|const0_rtx
condition|)
return|return
name|const0_rtx
return|;
elseif|else
if|if
condition|(
name|arg1
operator|==
name|const1_rtx
condition|)
return|return
name|arg0
return|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|arg0
argument_list|)
condition|)
block|{
case|case
name|REG
case|:
comment|/* biv * invar.  Done.  */
return|return
name|gen_rtx_MULT
argument_list|(
name|mode
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
return|;
case|case
name|CONST_INT
case|:
comment|/* Product of two constants.  */
return|return
name|GEN_INT
argument_list|(
name|INTVAL
argument_list|(
name|arg0
argument_list|)
operator|*
name|INTVAL
argument_list|(
name|arg1
argument_list|)
argument_list|)
return|;
case|case
name|USE
case|:
comment|/* invar * invar is a giv, but attempt to simplify it somehow.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|arg1
argument_list|)
operator|!=
name|CONST_INT
condition|)
return|return
name|NULL_RTX
return|;
name|arg0
operator|=
name|XEXP
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|MULT
condition|)
block|{
comment|/* (invar_0 * invar_1) * invar_2.  Associate.  */
return|return
name|simplify_giv_expr
argument_list|(
name|loop
argument_list|,
name|gen_rtx_MULT
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|gen_rtx_MULT
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|arg1
argument_list|)
argument_list|)
argument_list|,
name|ext_val
argument_list|,
name|benefit
argument_list|)
return|;
block|}
comment|/* Porpagate the MULT expressions to the intermost nodes.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|PLUS
condition|)
block|{
comment|/* (invar_0 + invar_1) * invar_2.  Distribute.  */
return|return
name|simplify_giv_expr
argument_list|(
name|loop
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|mode
argument_list|,
name|gen_rtx_MULT
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|arg1
argument_list|)
argument_list|,
name|gen_rtx_MULT
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|arg1
argument_list|)
argument_list|)
argument_list|,
name|ext_val
argument_list|,
name|benefit
argument_list|)
return|;
block|}
return|return
name|gen_rtx_USE
argument_list|(
name|mode
argument_list|,
name|gen_rtx_MULT
argument_list|(
name|mode
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
argument_list|)
return|;
case|case
name|MULT
case|:
comment|/* (a * invar_1) * invar_2.  Associate.  */
return|return
name|simplify_giv_expr
argument_list|(
name|loop
argument_list|,
name|gen_rtx_MULT
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|gen_rtx_MULT
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|arg1
argument_list|)
argument_list|)
argument_list|,
name|ext_val
argument_list|,
name|benefit
argument_list|)
return|;
case|case
name|PLUS
case|:
comment|/* (a + invar_1) * invar_2.  Distribute.  */
return|return
name|simplify_giv_expr
argument_list|(
name|loop
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|mode
argument_list|,
name|gen_rtx_MULT
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|arg1
argument_list|)
argument_list|,
name|gen_rtx_MULT
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|arg1
argument_list|)
argument_list|)
argument_list|,
name|ext_val
argument_list|,
name|benefit
argument_list|)
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
case|case
name|ASHIFT
case|:
comment|/* Shift by constant is multiply by power of two.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
condition|)
return|return
literal|0
return|;
return|return
name|simplify_giv_expr
argument_list|(
name|loop
argument_list|,
name|gen_rtx_MULT
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|ext_val
argument_list|,
name|benefit
argument_list|)
return|;
case|case
name|NEG
case|:
comment|/* "-a" is "a * (-1)" */
return|return
name|simplify_giv_expr
argument_list|(
name|loop
argument_list|,
name|gen_rtx_MULT
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|constm1_rtx
argument_list|)
argument_list|,
name|ext_val
argument_list|,
name|benefit
argument_list|)
return|;
case|case
name|NOT
case|:
comment|/* "~a" is "-a - 1". Silly, but easy.  */
return|return
name|simplify_giv_expr
argument_list|(
name|loop
argument_list|,
name|gen_rtx_MINUS
argument_list|(
name|mode
argument_list|,
name|gen_rtx_NEG
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|const1_rtx
argument_list|)
argument_list|,
name|ext_val
argument_list|,
name|benefit
argument_list|)
return|;
case|case
name|USE
case|:
comment|/* Already in proper form for invariant.  */
return|return
name|x
return|;
case|case
name|SIGN_EXTEND
case|:
case|case
name|ZERO_EXTEND
case|:
case|case
name|TRUNCATE
case|:
comment|/* Conditionally recognize extensions of simple IVs.  After we've 	 computed loop traversal counts and verified the range of the 	 source IV, we'll reevaluate this as a GIV.  */
if|if
condition|(
operator|*
name|ext_val
operator|==
name|NULL_RTX
condition|)
block|{
name|arg0
operator|=
name|simplify_giv_expr
argument_list|(
name|loop
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|ext_val
argument_list|,
name|benefit
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg0
operator|&&
operator|*
name|ext_val
operator|==
name|NULL_RTX
operator|&&
name|GET_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|REG
condition|)
block|{
operator|*
name|ext_val
operator|=
name|gen_rtx_fmt_e
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|mode
argument_list|,
name|arg0
argument_list|)
expr_stmt|;
return|return
name|arg0
return|;
block|}
block|}
goto|goto
name|do_default
goto|;
case|case
name|REG
case|:
comment|/* If this is a new register, we can't deal with it.  */
if|if
condition|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|>=
name|max_reg_before_loop
condition|)
return|return
literal|0
return|;
comment|/* Check for biv or giv.  */
switch|switch
condition|(
name|REG_IV_TYPE
argument_list|(
name|ivs
argument_list|,
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|BASIC_INDUCT
case|:
return|return
name|x
return|;
case|case
name|GENERAL_INDUCT
case|:
block|{
name|struct
name|induction
modifier|*
name|v
init|=
name|REG_IV_INFO
argument_list|(
name|ivs
argument_list|,
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Form expression from giv and add benefit.  Ensure this giv 	       can derive another and subtract any needed adjustment if so.  */
comment|/* Increasing the benefit here is risky.  The only case in which it 	       is arguably correct is if this is the only use of V.  In other 	       cases, this will artificially inflate the benefit of the current 	       giv, and lead to suboptimal code.  Thus, it is disabled, since 	       potentially not reducing an only marginally beneficial giv is 	       less harmful than reducing many givs that are not really 	       beneficial.  */
block|{
name|rtx
name|single_use
init|=
name|regs
operator|->
name|array
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
operator|.
name|single_usage
decl_stmt|;
if|if
condition|(
name|single_use
operator|&&
name|single_use
operator|!=
name|const0_rtx
condition|)
operator|*
name|benefit
operator|+=
name|v
operator|->
name|benefit
expr_stmt|;
block|}
if|if
condition|(
name|v
operator|->
name|cant_derive
condition|)
return|return
literal|0
return|;
name|tem
operator|=
name|gen_rtx_PLUS
argument_list|(
name|mode
argument_list|,
name|gen_rtx_MULT
argument_list|(
name|mode
argument_list|,
name|v
operator|->
name|src_reg
argument_list|,
name|v
operator|->
name|mult_val
argument_list|)
argument_list|,
name|v
operator|->
name|add_val
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|derive_adjustment
condition|)
name|tem
operator|=
name|gen_rtx_MINUS
argument_list|(
name|mode
argument_list|,
name|tem
argument_list|,
name|v
operator|->
name|derive_adjustment
argument_list|)
expr_stmt|;
name|arg0
operator|=
name|simplify_giv_expr
argument_list|(
name|loop
argument_list|,
name|tem
argument_list|,
name|ext_val
argument_list|,
name|benefit
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ext_val
condition|)
block|{
if|if
condition|(
operator|!
name|v
operator|->
name|ext_dependent
condition|)
return|return
name|arg0
return|;
block|}
else|else
block|{
operator|*
name|ext_val
operator|=
name|v
operator|->
name|ext_dependent
expr_stmt|;
return|return
name|arg0
return|;
block|}
return|return
literal|0
return|;
block|}
default|default:
name|do_default
label|:
comment|/* If it isn't an induction variable, and it is invariant, we 	     may be able to simplify things further by looking through 	     the bits we just moved outside the loop.  */
if|if
condition|(
name|loop_invariant_p
argument_list|(
name|loop
argument_list|,
name|x
argument_list|)
operator|==
literal|1
condition|)
block|{
name|struct
name|movable
modifier|*
name|m
decl_stmt|;
name|struct
name|loop_movables
modifier|*
name|movables
init|=
name|LOOP_MOVABLES
argument_list|(
name|loop
argument_list|)
decl_stmt|;
for|for
control|(
name|m
operator|=
name|movables
operator|->
name|head
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|next
control|)
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|x
argument_list|,
name|m
operator|->
name|set_dest
argument_list|)
condition|)
block|{
comment|/* Ok, we found a match.  Substitute and simplify.  */
comment|/* If we match another movable, we must use that, as 		       this one is going away.  */
if|if
condition|(
name|m
operator|->
name|match
condition|)
return|return
name|simplify_giv_expr
argument_list|(
name|loop
argument_list|,
name|m
operator|->
name|match
operator|->
name|set_dest
argument_list|,
name|ext_val
argument_list|,
name|benefit
argument_list|)
return|;
comment|/* If consec is nonzero, this is a member of a group of 		       instructions that were moved together.  We handle this 		       case only to the point of seeking to the last insn and 		       looking for a REG_EQUAL.  Fail if we don't find one.  */
if|if
condition|(
name|m
operator|->
name|consec
operator|!=
literal|0
condition|)
block|{
name|int
name|i
init|=
name|m
operator|->
name|consec
decl_stmt|;
name|tem
operator|=
name|m
operator|->
name|insn
expr_stmt|;
do|do
block|{
name|tem
operator|=
name|NEXT_INSN
argument_list|(
name|tem
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|i
operator|>
literal|0
condition|)
do|;
name|tem
operator|=
name|find_reg_note
argument_list|(
name|tem
argument_list|,
name|REG_EQUAL
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
condition|)
name|tem
operator|=
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tem
operator|=
name|single_set
argument_list|(
name|m
operator|->
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
condition|)
name|tem
operator|=
name|SET_SRC
argument_list|(
name|tem
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tem
condition|)
block|{
comment|/* What we are most interested in is pointer 			   arithmetic on invariants -- only take 			   patterns we may be able to do something with.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|PLUS
operator|||
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|MULT
operator|||
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|ASHIFT
operator|||
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|CONST_INT
operator|||
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
block|{
name|tem
operator|=
name|simplify_giv_expr
argument_list|(
name|loop
argument_list|,
name|tem
argument_list|,
name|ext_val
argument_list|,
name|benefit
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
condition|)
return|return
name|tem
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|tem
operator|=
name|simplify_giv_expr
argument_list|(
name|loop
argument_list|,
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|,
name|ext_val
argument_list|,
name|benefit
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
condition|)
return|return
name|tem
return|;
block|}
block|}
break|break;
block|}
block|}
break|break;
block|}
comment|/* Fall through to general case.  */
default|default:
comment|/* If invariant, return as USE (unless CONST_INT). 	 Otherwise, not giv.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|USE
condition|)
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|loop_invariant_p
argument_list|(
name|loop
argument_list|,
name|x
argument_list|)
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|x
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|gen_rtx_USE
argument_list|(
name|mode
argument_list|,
name|x
argument_list|)
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* This routine folds invariants such that there is only ever one    CONST_INT in the summation.  It is only used by simplify_giv_expr.  */
end_comment

begin_function
specifier|static
name|rtx
name|sge_plus_constant
parameter_list|(
name|x
parameter_list|,
name|c
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|c
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|GEN_INT
argument_list|(
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|+
name|INTVAL
argument_list|(
name|c
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|PLUS
condition|)
return|return
name|gen_rtx_PLUS
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|x
argument_list|,
name|c
argument_list|)
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
return|return
name|gen_rtx_PLUS
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|+
name|INTVAL
argument_list|(
name|c
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|PLUS
condition|)
block|{
return|return
name|gen_rtx_PLUS
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|sge_plus_constant
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|c
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|gen_rtx_PLUS
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|sge_plus_constant
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|c
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|rtx
name|sge_plus
parameter_list|(
name|mode
parameter_list|,
name|x
parameter_list|,
name|y
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|x
decl_stmt|,
name|y
decl_stmt|;
block|{
while|while
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|rtx
name|a
init|=
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|a
argument_list|)
operator|==
name|CONST_INT
condition|)
name|x
operator|=
name|sge_plus_constant
argument_list|(
name|x
argument_list|,
name|a
argument_list|)
expr_stmt|;
else|else
name|x
operator|=
name|gen_rtx_PLUS
argument_list|(
name|mode
argument_list|,
name|x
argument_list|,
name|a
argument_list|)
expr_stmt|;
name|y
operator|=
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|CONST_INT
condition|)
name|x
operator|=
name|sge_plus_constant
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
else|else
name|x
operator|=
name|gen_rtx_PLUS
argument_list|(
name|mode
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Help detect a giv that is calculated by several consecutive insns;    for example,       giv = biv * M       giv = giv + A    The caller has already identified the first insn P as having a giv as dest;    we check that all other insns that set the same register follow    immediately after P, that they alter nothing else,    and that the result of the last is still a giv.     The value is 0 if the reg set in P is not really a giv.    Otherwise, the value is the amount gained by eliminating    all the consecutive insns that compute the value.     FIRST_BENEFIT is the amount gained by eliminating the first insn, P.    SRC_REG is the reg of the biv; DEST_REG is the reg of the giv.     The coefficients of the ultimate giv value are stored in    *MULT_VAL and *ADD_VAL.  */
end_comment

begin_function
specifier|static
name|int
name|consec_sets_giv
parameter_list|(
name|loop
parameter_list|,
name|first_benefit
parameter_list|,
name|p
parameter_list|,
name|src_reg
parameter_list|,
name|dest_reg
parameter_list|,
name|add_val
parameter_list|,
name|mult_val
parameter_list|,
name|ext_val
parameter_list|,
name|last_consec_insn
parameter_list|)
specifier|const
name|struct
name|loop
modifier|*
name|loop
decl_stmt|;
name|int
name|first_benefit
decl_stmt|;
name|rtx
name|p
decl_stmt|;
name|rtx
name|src_reg
decl_stmt|;
name|rtx
name|dest_reg
decl_stmt|;
name|rtx
modifier|*
name|add_val
decl_stmt|;
name|rtx
modifier|*
name|mult_val
decl_stmt|;
name|rtx
modifier|*
name|ext_val
decl_stmt|;
name|rtx
modifier|*
name|last_consec_insn
decl_stmt|;
block|{
name|struct
name|loop_ivs
modifier|*
name|ivs
init|=
name|LOOP_IVS
argument_list|(
name|loop
argument_list|)
decl_stmt|;
name|struct
name|loop_regs
modifier|*
name|regs
init|=
name|LOOP_REGS
argument_list|(
name|loop
argument_list|)
decl_stmt|;
name|int
name|count
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
name|int
name|benefit
decl_stmt|;
name|rtx
name|temp
decl_stmt|;
name|rtx
name|set
decl_stmt|;
comment|/* Indicate that this is a giv so that we can update the value produced in      each insn of the multi-insn sequence.       This induction structure will be used only by the call to      general_induction_var below, so we can allocate it on our stack.      If this is a giv, our caller will replace the induct var entry with      a new induction structure.  */
name|struct
name|induction
modifier|*
name|v
decl_stmt|;
if|if
condition|(
name|REG_IV_TYPE
argument_list|(
name|ivs
argument_list|,
name|REGNO
argument_list|(
name|dest_reg
argument_list|)
argument_list|)
operator|!=
name|UNKNOWN_INDUCT
condition|)
return|return
literal|0
return|;
name|v
operator|=
operator|(
expr|struct
name|induction
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|induction
argument_list|)
argument_list|)
expr_stmt|;
name|v
operator|->
name|src_reg
operator|=
name|src_reg
expr_stmt|;
name|v
operator|->
name|mult_val
operator|=
operator|*
name|mult_val
expr_stmt|;
name|v
operator|->
name|add_val
operator|=
operator|*
name|add_val
expr_stmt|;
name|v
operator|->
name|benefit
operator|=
name|first_benefit
expr_stmt|;
name|v
operator|->
name|cant_derive
operator|=
literal|0
expr_stmt|;
name|v
operator|->
name|derive_adjustment
operator|=
literal|0
expr_stmt|;
name|v
operator|->
name|ext_dependent
operator|=
name|NULL_RTX
expr_stmt|;
name|REG_IV_TYPE
argument_list|(
name|ivs
argument_list|,
name|REGNO
argument_list|(
name|dest_reg
argument_list|)
argument_list|)
operator|=
name|GENERAL_INDUCT
expr_stmt|;
name|REG_IV_INFO
argument_list|(
name|ivs
argument_list|,
name|REGNO
argument_list|(
name|dest_reg
argument_list|)
argument_list|)
operator|=
name|v
expr_stmt|;
name|count
operator|=
name|regs
operator|->
name|array
index|[
name|REGNO
argument_list|(
name|dest_reg
argument_list|)
index|]
operator|.
name|n_times_set
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* If libcall, skip to end of call sequence.  */
if|if
condition|(
name|code
operator|==
name|INSN
operator|&&
operator|(
name|temp
operator|=
name|find_reg_note
argument_list|(
name|p
argument_list|,
name|REG_LIBCALL
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
condition|)
name|p
operator|=
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|INSN
operator|&&
operator|(
name|set
operator|=
name|single_set
argument_list|(
name|p
argument_list|)
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|SET_DEST
argument_list|(
name|set
argument_list|)
operator|==
name|dest_reg
operator|&&
operator|(
name|general_induction_var
argument_list|(
name|loop
argument_list|,
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
operator|&
name|src_reg
argument_list|,
name|add_val
argument_list|,
name|mult_val
argument_list|,
name|ext_val
argument_list|,
literal|0
argument_list|,
operator|&
name|benefit
argument_list|,
name|VOIDmode
argument_list|)
comment|/* Giv created by equivalent expression.  */
operator|||
operator|(
operator|(
name|temp
operator|=
name|find_reg_note
argument_list|(
name|p
argument_list|,
name|REG_EQUAL
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
operator|&&
name|general_induction_var
argument_list|(
name|loop
argument_list|,
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|src_reg
argument_list|,
name|add_val
argument_list|,
name|mult_val
argument_list|,
name|ext_val
argument_list|,
literal|0
argument_list|,
operator|&
name|benefit
argument_list|,
name|VOIDmode
argument_list|)
operator|)
operator|)
operator|&&
name|src_reg
operator|==
name|v
operator|->
name|src_reg
condition|)
block|{
if|if
condition|(
name|find_reg_note
argument_list|(
name|p
argument_list|,
name|REG_RETVAL
argument_list|,
name|NULL_RTX
argument_list|)
condition|)
name|benefit
operator|+=
name|libcall_benefit
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|count
operator|--
expr_stmt|;
name|v
operator|->
name|mult_val
operator|=
operator|*
name|mult_val
expr_stmt|;
name|v
operator|->
name|add_val
operator|=
operator|*
name|add_val
expr_stmt|;
name|v
operator|->
name|benefit
operator|+=
name|benefit
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|!=
name|NOTE
condition|)
block|{
comment|/* Allow insns that set something other than this giv to a 	     constant.  Such insns are needed on machines which cannot 	     include long constants and should not disqualify a giv.  */
if|if
condition|(
name|code
operator|==
name|INSN
operator|&&
operator|(
name|set
operator|=
name|single_set
argument_list|(
name|p
argument_list|)
operator|)
operator|&&
name|SET_DEST
argument_list|(
name|set
argument_list|)
operator|!=
name|dest_reg
operator|&&
name|CONSTANT_P
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
condition|)
continue|continue;
name|REG_IV_TYPE
argument_list|(
name|ivs
argument_list|,
name|REGNO
argument_list|(
name|dest_reg
argument_list|)
argument_list|)
operator|=
name|UNKNOWN_INDUCT
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|REG_IV_TYPE
argument_list|(
name|ivs
argument_list|,
name|REGNO
argument_list|(
name|dest_reg
argument_list|)
argument_list|)
operator|=
name|UNKNOWN_INDUCT
expr_stmt|;
operator|*
name|last_consec_insn
operator|=
name|p
expr_stmt|;
return|return
name|v
operator|->
name|benefit
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return an rtx, if any, that expresses giv G2 as a function of the register    represented by G1.  If no such expression can be found, or it is clear that    it cannot possibly be a valid address, 0 is returned.     To perform the computation, we note that 	G1 = x * v + a		and 	G2 = y * v + b    where `v' is the biv.     So G2 = (y/b) * G1 + (b - a*y/x).     Note that MULT = y/x.     Update: A and B are now allowed to be additive expressions such that    B contains all variables in A.  That is, computing B-A will not require    subtracting variables.  */
end_comment

begin_function
specifier|static
name|rtx
name|express_from_1
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|mult
parameter_list|)
name|rtx
name|a
decl_stmt|,
name|b
decl_stmt|,
name|mult
decl_stmt|;
block|{
comment|/* If MULT is zero, then A*MULT is zero, and our expression is B.  */
if|if
condition|(
name|mult
operator|==
name|const0_rtx
condition|)
return|return
name|b
return|;
comment|/* If MULT is not 1, we cannot handle A with non-constants, since we      would then be required to subtract multiples of the registers in A.      This is theoretically possible, and may even apply to some Fortran      constructs, but it is a lot of work and we do not attempt it here.  */
if|if
condition|(
name|mult
operator|!=
name|const1_rtx
operator|&&
name|GET_CODE
argument_list|(
name|a
argument_list|)
operator|!=
name|CONST_INT
condition|)
return|return
name|NULL_RTX
return|;
comment|/* In general these structures are sorted top to bottom (down the PLUS      chain), but not left to right across the PLUS.  If B is a higher      order giv than A, we can strip one level and recurse.  If A is higher      order, we'll eventually bail out, but won't know that until the end.      If they are the same, we'll strip one level around this loop.  */
while|while
condition|(
name|GET_CODE
argument_list|(
name|a
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|b
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|rtx
name|ra
decl_stmt|,
name|rb
decl_stmt|,
name|oa
decl_stmt|,
name|ob
decl_stmt|,
name|tmp
decl_stmt|;
name|ra
operator|=
name|XEXP
argument_list|(
name|a
argument_list|,
literal|0
argument_list|)
operator|,
name|oa
operator|=
name|XEXP
argument_list|(
name|a
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|ra
argument_list|)
operator|==
name|PLUS
condition|)
name|tmp
operator|=
name|ra
operator|,
name|ra
operator|=
name|oa
operator|,
name|oa
operator|=
name|tmp
expr_stmt|;
name|rb
operator|=
name|XEXP
argument_list|(
name|b
argument_list|,
literal|0
argument_list|)
operator|,
name|ob
operator|=
name|XEXP
argument_list|(
name|b
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|rb
argument_list|)
operator|==
name|PLUS
condition|)
name|tmp
operator|=
name|rb
operator|,
name|rb
operator|=
name|ob
operator|,
name|ob
operator|=
name|tmp
expr_stmt|;
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|ra
argument_list|,
name|rb
argument_list|)
condition|)
comment|/* We matched: remove one reg completely.  */
name|a
operator|=
name|oa
operator|,
name|b
operator|=
name|ob
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|ob
argument_list|)
operator|!=
name|PLUS
operator|&&
name|rtx_equal_p
argument_list|(
name|ra
argument_list|,
name|ob
argument_list|)
condition|)
comment|/* An alternate match.  */
name|a
operator|=
name|oa
operator|,
name|b
operator|=
name|rb
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|oa
argument_list|)
operator|!=
name|PLUS
operator|&&
name|rtx_equal_p
argument_list|(
name|oa
argument_list|,
name|rb
argument_list|)
condition|)
comment|/* An alternate match.  */
name|a
operator|=
name|ra
operator|,
name|b
operator|=
name|ob
expr_stmt|;
else|else
block|{
comment|/* Indicates an extra register in B.  Strip one level from B and 	     recurse, hoping B was the higher order expression.  */
name|ob
operator|=
name|express_from_1
argument_list|(
name|a
argument_list|,
name|ob
argument_list|,
name|mult
argument_list|)
expr_stmt|;
if|if
condition|(
name|ob
operator|==
name|NULL_RTX
condition|)
return|return
name|NULL_RTX
return|;
return|return
name|gen_rtx_PLUS
argument_list|(
name|GET_MODE
argument_list|(
name|b
argument_list|)
argument_list|,
name|rb
argument_list|,
name|ob
argument_list|)
return|;
block|}
block|}
comment|/* Here we are at the last level of A, go through the cases hoping to      get rid of everything but a constant.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|a
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|rtx
name|ra
decl_stmt|,
name|oa
decl_stmt|;
name|ra
operator|=
name|XEXP
argument_list|(
name|a
argument_list|,
literal|0
argument_list|)
operator|,
name|oa
operator|=
name|XEXP
argument_list|(
name|a
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|oa
argument_list|,
name|b
argument_list|)
condition|)
name|oa
operator|=
name|ra
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|rtx_equal_p
argument_list|(
name|ra
argument_list|,
name|b
argument_list|)
condition|)
return|return
name|NULL_RTX
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|oa
argument_list|)
operator|!=
name|CONST_INT
condition|)
return|return
name|NULL_RTX
return|;
return|return
name|GEN_INT
argument_list|(
operator|-
name|INTVAL
argument_list|(
name|oa
argument_list|)
operator|*
name|INTVAL
argument_list|(
name|mult
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|a
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
return|return
name|plus_constant
argument_list|(
name|b
argument_list|,
operator|-
name|INTVAL
argument_list|(
name|a
argument_list|)
operator|*
name|INTVAL
argument_list|(
name|mult
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|a
argument_list|)
condition|)
block|{
name|enum
name|machine_mode
name|mode_a
init|=
name|GET_MODE
argument_list|(
name|a
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode_b
init|=
name|GET_MODE
argument_list|(
name|b
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|mode_b
operator|==
name|VOIDmode
condition|?
name|mode_a
else|:
name|mode_b
decl_stmt|;
return|return
name|simplify_gen_binary
argument_list|(
name|MINUS
argument_list|,
name|mode
argument_list|,
name|b
argument_list|,
name|a
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|b
argument_list|)
operator|==
name|PLUS
condition|)
block|{
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|a
argument_list|,
name|XEXP
argument_list|(
name|b
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|XEXP
argument_list|(
name|b
argument_list|,
literal|1
argument_list|)
return|;
elseif|else
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|a
argument_list|,
name|XEXP
argument_list|(
name|b
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
return|return
name|XEXP
argument_list|(
name|b
argument_list|,
literal|0
argument_list|)
return|;
else|else
return|return
name|NULL_RTX
return|;
block|}
elseif|else
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
condition|)
return|return
name|const0_rtx
return|;
return|return
name|NULL_RTX
return|;
block|}
end_function

begin_function
name|rtx
name|express_from
parameter_list|(
name|g1
parameter_list|,
name|g2
parameter_list|)
name|struct
name|induction
modifier|*
name|g1
decl_stmt|,
decl|*
name|g2
decl_stmt|;
end_function

begin_block
block|{
name|rtx
name|mult
decl_stmt|,
name|add
decl_stmt|;
comment|/* The value that G1 will be multiplied by must be a constant integer.  Also,      the only chance we have of getting a valid address is if b*c/a (see above      for notation) is also an integer.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|g1
operator|->
name|mult_val
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|g2
operator|->
name|mult_val
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
if|if
condition|(
name|g1
operator|->
name|mult_val
operator|==
name|const0_rtx
operator|||
name|INTVAL
argument_list|(
name|g2
operator|->
name|mult_val
argument_list|)
operator|%
name|INTVAL
argument_list|(
name|g1
operator|->
name|mult_val
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|NULL_RTX
return|;
name|mult
operator|=
name|GEN_INT
argument_list|(
name|INTVAL
argument_list|(
name|g2
operator|->
name|mult_val
argument_list|)
operator|/
name|INTVAL
argument_list|(
name|g1
operator|->
name|mult_val
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|g1
operator|->
name|mult_val
argument_list|,
name|g2
operator|->
name|mult_val
argument_list|)
condition|)
name|mult
operator|=
name|const1_rtx
expr_stmt|;
else|else
block|{
comment|/* ??? Find out if the one is a multiple of the other?  */
return|return
name|NULL_RTX
return|;
block|}
name|add
operator|=
name|express_from_1
argument_list|(
name|g1
operator|->
name|add_val
argument_list|,
name|g2
operator|->
name|add_val
argument_list|,
name|mult
argument_list|)
expr_stmt|;
if|if
condition|(
name|add
operator|==
name|NULL_RTX
condition|)
block|{
comment|/* Failed.  If we've got a multiplication factor between G1 and G2, 	 scale G1's addend and try again.  */
if|if
condition|(
name|INTVAL
argument_list|(
name|mult
argument_list|)
operator|>
literal|1
condition|)
block|{
name|rtx
name|g1_add_val
init|=
name|g1
operator|->
name|add_val
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|g1_add_val
argument_list|)
operator|==
name|MULT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|g1_add_val
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|HOST_WIDE_INT
name|m
decl_stmt|;
name|m
operator|=
name|INTVAL
argument_list|(
name|mult
argument_list|)
operator|*
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|g1_add_val
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|g1_add_val
operator|=
name|gen_rtx_MULT
argument_list|(
name|GET_MODE
argument_list|(
name|g1_add_val
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|g1_add_val
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|g1_add_val
operator|=
name|gen_rtx_MULT
argument_list|(
name|GET_MODE
argument_list|(
name|g1_add_val
argument_list|)
argument_list|,
name|g1_add_val
argument_list|,
name|mult
argument_list|)
expr_stmt|;
block|}
name|add
operator|=
name|express_from_1
argument_list|(
name|g1_add_val
argument_list|,
name|g2
operator|->
name|add_val
argument_list|,
name|const1_rtx
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|add
operator|==
name|NULL_RTX
condition|)
return|return
name|NULL_RTX
return|;
comment|/* Form simplified final result.  */
if|if
condition|(
name|mult
operator|==
name|const0_rtx
condition|)
return|return
name|add
return|;
elseif|else
if|if
condition|(
name|mult
operator|==
name|const1_rtx
condition|)
name|mult
operator|=
name|g1
operator|->
name|dest_reg
expr_stmt|;
else|else
name|mult
operator|=
name|gen_rtx_MULT
argument_list|(
name|g2
operator|->
name|mode
argument_list|,
name|g1
operator|->
name|dest_reg
argument_list|,
name|mult
argument_list|)
expr_stmt|;
if|if
condition|(
name|add
operator|==
name|const0_rtx
condition|)
return|return
name|mult
return|;
else|else
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|add
argument_list|)
operator|==
name|PLUS
operator|&&
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|add
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|tem
init|=
name|XEXP
argument_list|(
name|add
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|mult
operator|=
name|gen_rtx_PLUS
argument_list|(
name|g2
operator|->
name|mode
argument_list|,
name|mult
argument_list|,
name|XEXP
argument_list|(
name|add
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|add
operator|=
name|tem
expr_stmt|;
block|}
return|return
name|gen_rtx_PLUS
argument_list|(
name|g2
operator|->
name|mode
argument_list|,
name|mult
argument_list|,
name|add
argument_list|)
return|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Return an rtx, if any, that expresses giv G2 as a function of the register    represented by G1.  This indicates that G2 should be combined with G1 and    that G2 can use (either directly or via an address expression) a register    used to represent G1.  */
end_comment

begin_function
specifier|static
name|rtx
name|combine_givs_p
parameter_list|(
name|g1
parameter_list|,
name|g2
parameter_list|)
name|struct
name|induction
modifier|*
name|g1
decl_stmt|,
decl|*
name|g2
decl_stmt|;
end_function

begin_block
block|{
name|rtx
name|comb
decl_stmt|,
name|ret
decl_stmt|;
comment|/* With the introduction of ext dependent givs, we must care for modes.      G2 must not use a wider mode than G1.  */
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|g1
operator|->
name|mode
argument_list|)
operator|<
name|GET_MODE_SIZE
argument_list|(
name|g2
operator|->
name|mode
argument_list|)
condition|)
return|return
name|NULL_RTX
return|;
name|ret
operator|=
name|comb
operator|=
name|express_from
argument_list|(
name|g1
argument_list|,
name|g2
argument_list|)
expr_stmt|;
if|if
condition|(
name|comb
operator|==
name|NULL_RTX
condition|)
return|return
name|NULL_RTX
return|;
if|if
condition|(
name|g1
operator|->
name|mode
operator|!=
name|g2
operator|->
name|mode
condition|)
name|ret
operator|=
name|gen_lowpart
argument_list|(
name|g2
operator|->
name|mode
argument_list|,
name|comb
argument_list|)
expr_stmt|;
comment|/* If these givs are identical, they can be combined.  We use the results      of express_from because the addends are not in a canonical form, so      rtx_equal_p is a weaker test.  */
comment|/* But don't combine a DEST_REG giv with a DEST_ADDR giv; we want the      combination to be the other way round.  */
if|if
condition|(
name|comb
operator|==
name|g1
operator|->
name|dest_reg
operator|&&
operator|(
name|g1
operator|->
name|giv_type
operator|==
name|DEST_REG
operator|||
name|g2
operator|->
name|giv_type
operator|==
name|DEST_ADDR
operator|)
condition|)
block|{
return|return
name|ret
return|;
block|}
comment|/* If G2 can be expressed as a function of G1 and that function is valid      as an address and no more expensive than using a register for G2,      the expression of G2 in terms of G1 can be used.  */
if|if
condition|(
name|ret
operator|!=
name|NULL_RTX
operator|&&
name|g2
operator|->
name|giv_type
operator|==
name|DEST_ADDR
operator|&&
name|memory_address_p
argument_list|(
name|GET_MODE
argument_list|(
name|g2
operator|->
name|mem
argument_list|)
argument_list|,
name|ret
argument_list|)
comment|/* ??? Looses, especially with -fforce-addr, where *g2->location 	 will always be a register, and so anything more complicated 	 gets discarded.  */
if|#
directive|if
literal|0
ifdef|#
directive|ifdef
name|ADDRESS_COST
condition|&& ADDRESS_COST (tem)<= ADDRESS_COST (*g2->location)
else|#
directive|else
condition|&& rtx_cost (tem, MEM)<= rtx_cost (*g2->location, MEM)
endif|#
directive|endif
endif|#
directive|endif
condition|)
block|{
return|return
name|ret
return|;
block|}
return|return
name|NULL_RTX
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Check each extension dependent giv in this class to see if its    root biv is safe from wrapping in the interior mode, which would    make the giv illegal.  */
end_comment

begin_function
specifier|static
name|void
name|check_ext_dependent_givs
parameter_list|(
name|bl
parameter_list|,
name|loop_info
parameter_list|)
name|struct
name|iv_class
modifier|*
name|bl
decl_stmt|;
name|struct
name|loop_info
modifier|*
name|loop_info
decl_stmt|;
block|{
name|int
name|ze_ok
init|=
literal|0
decl_stmt|,
name|se_ok
init|=
literal|0
decl_stmt|,
name|info_ok
init|=
literal|0
decl_stmt|;
name|enum
name|machine_mode
name|biv_mode
init|=
name|GET_MODE
argument_list|(
name|bl
operator|->
name|biv
operator|->
name|src_reg
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|start_val
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|u_end_val
init|=
literal|0
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|u_start_val
init|=
literal|0
decl_stmt|;
name|rtx
name|incr
init|=
name|pc_rtx
decl_stmt|;
name|struct
name|induction
modifier|*
name|v
decl_stmt|;
comment|/* Make sure the iteration data is available.  We must have      constants in order to be certain of no overflow.  */
comment|/* ??? An unknown iteration count with an increment of +-1      combined with friendly exit tests of against an invariant      value is also ameanable to optimization.  Not implemented.  */
if|if
condition|(
name|loop_info
operator|->
name|n_iterations
operator|>
literal|0
operator|&&
name|bl
operator|->
name|initial_value
operator|&&
name|GET_CODE
argument_list|(
name|bl
operator|->
name|initial_value
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|incr
operator|=
name|biv_total_increment
argument_list|(
name|bl
argument_list|)
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|incr
argument_list|)
operator|==
name|CONST_INT
comment|/* Make sure the host can represent the arithmetic.  */
operator|&&
name|HOST_BITS_PER_WIDE_INT
operator|>=
name|GET_MODE_BITSIZE
argument_list|(
name|biv_mode
argument_list|)
condition|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|abs_incr
decl_stmt|,
name|total_incr
decl_stmt|;
name|HOST_WIDE_INT
name|s_end_val
decl_stmt|;
name|int
name|neg_incr
decl_stmt|;
name|info_ok
operator|=
literal|1
expr_stmt|;
name|start_val
operator|=
name|INTVAL
argument_list|(
name|bl
operator|->
name|initial_value
argument_list|)
expr_stmt|;
name|u_start_val
operator|=
name|start_val
expr_stmt|;
name|neg_incr
operator|=
literal|0
operator|,
name|abs_incr
operator|=
name|INTVAL
argument_list|(
name|incr
argument_list|)
expr_stmt|;
if|if
condition|(
name|INTVAL
argument_list|(
name|incr
argument_list|)
operator|<
literal|0
condition|)
name|neg_incr
operator|=
literal|1
operator|,
name|abs_incr
operator|=
operator|-
name|abs_incr
expr_stmt|;
name|total_incr
operator|=
name|abs_incr
operator|*
name|loop_info
operator|->
name|n_iterations
expr_stmt|;
comment|/* Check for host arithmatic overflow.  */
if|if
condition|(
name|total_incr
operator|/
name|loop_info
operator|->
name|n_iterations
operator|==
name|abs_incr
condition|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|u_max
decl_stmt|;
name|HOST_WIDE_INT
name|s_max
decl_stmt|;
name|u_end_val
operator|=
name|start_val
operator|+
operator|(
name|neg_incr
condition|?
operator|-
name|total_incr
else|:
name|total_incr
operator|)
expr_stmt|;
name|s_end_val
operator|=
name|u_end_val
expr_stmt|;
name|u_max
operator|=
name|GET_MODE_MASK
argument_list|(
name|biv_mode
argument_list|)
expr_stmt|;
name|s_max
operator|=
name|u_max
operator|>>
literal|1
expr_stmt|;
comment|/* Check zero extension of biv ok.  */
if|if
condition|(
name|start_val
operator|>=
literal|0
comment|/* Check for host arithmatic overflow.  */
operator|&&
operator|(
name|neg_incr
condition|?
name|u_end_val
operator|<
name|u_start_val
else|:
name|u_end_val
operator|>
name|u_start_val
operator|)
comment|/* Check for target arithmetic overflow.  */
operator|&&
operator|(
name|neg_incr
condition|?
literal|1
comment|/* taken care of with host overflow */
else|:
name|u_end_val
operator|<=
name|u_max
operator|)
condition|)
block|{
name|ze_ok
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Check sign extension of biv ok.  */
comment|/* ??? While it is true that overflow with signed and pointer 	     arithmetic is undefined, I fear too many programmers don't 	     keep this fact in mind -- myself included on occasion. 	     So leave alone with the signed overflow optimizations.  */
if|if
condition|(
name|start_val
operator|>=
operator|-
name|s_max
operator|-
literal|1
comment|/* Check for host arithmatic overflow.  */
operator|&&
operator|(
name|neg_incr
condition|?
name|s_end_val
operator|<
name|start_val
else|:
name|s_end_val
operator|>
name|start_val
operator|)
comment|/* Check for target arithmetic overflow.  */
operator|&&
operator|(
name|neg_incr
condition|?
name|s_end_val
operator|>=
operator|-
name|s_max
operator|-
literal|1
else|:
name|s_end_val
operator|<=
name|s_max
operator|)
condition|)
block|{
name|se_ok
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
comment|/* Invalidate givs that fail the tests.  */
for|for
control|(
name|v
operator|=
name|bl
operator|->
name|giv
init|;
name|v
condition|;
name|v
operator|=
name|v
operator|->
name|next_iv
control|)
if|if
condition|(
name|v
operator|->
name|ext_dependent
condition|)
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|v
operator|->
name|ext_dependent
argument_list|)
decl_stmt|;
name|int
name|ok
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|SIGN_EXTEND
case|:
name|ok
operator|=
name|se_ok
expr_stmt|;
break|break;
case|case
name|ZERO_EXTEND
case|:
name|ok
operator|=
name|ze_ok
expr_stmt|;
break|break;
case|case
name|TRUNCATE
case|:
comment|/* We don't know whether this value is being used as either 	       signed or unsigned, so to safely truncate we must satisfy 	       both.  The initial check here verifies the BIV itself; 	       once that is successful we may check its range wrt the 	       derived GIV.  */
if|if
condition|(
name|se_ok
operator|&&
name|ze_ok
condition|)
block|{
name|enum
name|machine_mode
name|outer_mode
init|=
name|GET_MODE
argument_list|(
name|v
operator|->
name|ext_dependent
argument_list|)
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|max
init|=
name|GET_MODE_MASK
argument_list|(
name|outer_mode
argument_list|)
operator|>>
literal|1
decl_stmt|;
comment|/* We know from the above that both endpoints are nonnegative, 		   and that there is no wrapping.  Verify that both endpoints 		   are within the (signed) range of the outer mode.  */
if|if
condition|(
name|u_start_val
operator|<=
name|max
operator|&&
name|u_end_val
operator|<=
name|max
condition|)
name|ok
operator|=
literal|1
expr_stmt|;
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|ok
condition|)
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
block|{
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Verified ext dependent giv at %d of reg %d\n"
argument_list|,
name|INSN_UID
argument_list|(
name|v
operator|->
name|insn
argument_list|)
argument_list|,
name|bl
operator|->
name|regno
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
block|{
specifier|const
name|char
modifier|*
name|why
decl_stmt|;
if|if
condition|(
name|info_ok
condition|)
name|why
operator|=
literal|"biv iteration values overflowed"
expr_stmt|;
else|else
block|{
if|if
condition|(
name|incr
operator|==
name|pc_rtx
condition|)
name|incr
operator|=
name|biv_total_increment
argument_list|(
name|bl
argument_list|)
expr_stmt|;
if|if
condition|(
name|incr
operator|==
name|const1_rtx
condition|)
name|why
operator|=
literal|"biv iteration info incomplete; incr by 1"
expr_stmt|;
else|else
name|why
operator|=
literal|"biv iteration info incomplete"
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Failed ext dependent giv at %d, %s\n"
argument_list|,
name|INSN_UID
argument_list|(
name|v
operator|->
name|insn
argument_list|)
argument_list|,
name|why
argument_list|)
expr_stmt|;
block|}
name|v
operator|->
name|ignore
operator|=
literal|1
expr_stmt|;
name|bl
operator|->
name|all_reduced
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Generate a version of VALUE in a mode appropriate for initializing V.  */
end_comment

begin_function
name|rtx
name|extend_value_for_giv
parameter_list|(
name|v
parameter_list|,
name|value
parameter_list|)
name|struct
name|induction
modifier|*
name|v
decl_stmt|;
name|rtx
name|value
decl_stmt|;
block|{
name|rtx
name|ext_dep
init|=
name|v
operator|->
name|ext_dependent
decl_stmt|;
if|if
condition|(
operator|!
name|ext_dep
condition|)
return|return
name|value
return|;
comment|/* Recall that check_ext_dependent_givs verified that the known bounds      of a biv did not overflow or wrap with respect to the extension for      the giv.  Therefore, constants need no additional adjustment.  */
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|value
argument_list|)
operator|&&
name|GET_MODE
argument_list|(
name|value
argument_list|)
operator|==
name|VOIDmode
condition|)
return|return
name|value
return|;
comment|/* Otherwise, we must adjust the value to compensate for the      differing modes of the biv and the giv.  */
return|return
name|gen_rtx_fmt_e
argument_list|(
name|GET_CODE
argument_list|(
name|ext_dep
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|ext_dep
argument_list|)
argument_list|,
name|value
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_struct
struct|struct
name|combine_givs_stats
block|{
name|int
name|giv_number
decl_stmt|;
name|int
name|total_benefit
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|cmp_combine_givs_stats
parameter_list|(
name|xp
parameter_list|,
name|yp
parameter_list|)
specifier|const
name|PTR
name|xp
decl_stmt|;
specifier|const
name|PTR
name|yp
decl_stmt|;
block|{
specifier|const
name|struct
name|combine_givs_stats
modifier|*
specifier|const
name|x
init|=
operator|(
specifier|const
expr|struct
name|combine_givs_stats
operator|*
operator|)
name|xp
decl_stmt|;
specifier|const
name|struct
name|combine_givs_stats
modifier|*
specifier|const
name|y
init|=
operator|(
specifier|const
expr|struct
name|combine_givs_stats
operator|*
operator|)
name|yp
decl_stmt|;
name|int
name|d
decl_stmt|;
name|d
operator|=
name|y
operator|->
name|total_benefit
operator|-
name|x
operator|->
name|total_benefit
expr_stmt|;
comment|/* Stabilize the sort.  */
if|if
condition|(
operator|!
name|d
condition|)
name|d
operator|=
name|x
operator|->
name|giv_number
operator|-
name|y
operator|->
name|giv_number
expr_stmt|;
return|return
name|d
return|;
block|}
end_function

begin_comment
comment|/* Check all pairs of givs for iv_class BL and see if any can be combined with    any other.  If so, point SAME to the giv combined with and set NEW_REG to    be an expression (in terms of the other giv's DEST_REG) equivalent to the    giv.  Also, update BENEFIT and related fields for cost/benefit analysis.  */
end_comment

begin_function
specifier|static
name|void
name|combine_givs
parameter_list|(
name|regs
parameter_list|,
name|bl
parameter_list|)
name|struct
name|loop_regs
modifier|*
name|regs
decl_stmt|;
name|struct
name|iv_class
modifier|*
name|bl
decl_stmt|;
block|{
comment|/* Additional benefit to add for being combined multiple times.  */
specifier|const
name|int
name|extra_benefit
init|=
literal|3
decl_stmt|;
name|struct
name|induction
modifier|*
name|g1
decl_stmt|,
modifier|*
name|g2
decl_stmt|,
modifier|*
modifier|*
name|giv_array
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|giv_count
decl_stmt|;
name|struct
name|combine_givs_stats
modifier|*
name|stats
decl_stmt|;
name|rtx
modifier|*
name|can_combine
decl_stmt|;
comment|/* Count givs, because bl->giv_count is incorrect here.  */
name|giv_count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|g1
operator|=
name|bl
operator|->
name|giv
init|;
name|g1
condition|;
name|g1
operator|=
name|g1
operator|->
name|next_iv
control|)
if|if
condition|(
operator|!
name|g1
operator|->
name|ignore
condition|)
name|giv_count
operator|++
expr_stmt|;
name|giv_array
operator|=
operator|(
expr|struct
name|induction
operator|*
operator|*
operator|)
name|alloca
argument_list|(
name|giv_count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|induction
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|g1
operator|=
name|bl
operator|->
name|giv
init|;
name|g1
condition|;
name|g1
operator|=
name|g1
operator|->
name|next_iv
control|)
if|if
condition|(
operator|!
name|g1
operator|->
name|ignore
condition|)
name|giv_array
index|[
name|i
operator|++
index|]
operator|=
name|g1
expr_stmt|;
name|stats
operator|=
operator|(
expr|struct
name|combine_givs_stats
operator|*
operator|)
name|xcalloc
argument_list|(
name|giv_count
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|stats
argument_list|)
argument_list|)
expr_stmt|;
name|can_combine
operator|=
operator|(
name|rtx
operator|*
operator|)
name|xcalloc
argument_list|(
name|giv_count
argument_list|,
name|giv_count
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|giv_count
condition|;
name|i
operator|++
control|)
block|{
name|int
name|this_benefit
decl_stmt|;
name|rtx
name|single_use
decl_stmt|;
name|g1
operator|=
name|giv_array
index|[
name|i
index|]
expr_stmt|;
name|stats
index|[
name|i
index|]
operator|.
name|giv_number
operator|=
name|i
expr_stmt|;
comment|/* If a DEST_REG GIV is used only once, do not allow it to combine 	 with anything, for in doing so we will gain nothing that cannot 	 be had by simply letting the GIV with which we would have combined 	 to be reduced on its own.  The losage shows up in particular with 	 DEST_ADDR targets on hosts with reg+reg addressing, though it can 	 be seen elsewhere as well.  */
if|if
condition|(
name|g1
operator|->
name|giv_type
operator|==
name|DEST_REG
operator|&&
operator|(
name|single_use
operator|=
name|regs
operator|->
name|array
index|[
name|REGNO
argument_list|(
name|g1
operator|->
name|dest_reg
argument_list|)
index|]
operator|.
name|single_usage
operator|)
operator|&&
name|single_use
operator|!=
name|const0_rtx
condition|)
continue|continue;
name|this_benefit
operator|=
name|g1
operator|->
name|benefit
expr_stmt|;
comment|/* Add an additional weight for zero addends.  */
if|if
condition|(
name|g1
operator|->
name|no_const_addval
condition|)
name|this_benefit
operator|+=
literal|1
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|giv_count
condition|;
name|j
operator|++
control|)
block|{
name|rtx
name|this_combine
decl_stmt|;
name|g2
operator|=
name|giv_array
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|g1
operator|!=
name|g2
operator|&&
operator|(
name|this_combine
operator|=
name|combine_givs_p
argument_list|(
name|g1
argument_list|,
name|g2
argument_list|)
operator|)
operator|!=
name|NULL_RTX
condition|)
block|{
name|can_combine
index|[
name|i
operator|*
name|giv_count
operator|+
name|j
index|]
operator|=
name|this_combine
expr_stmt|;
name|this_benefit
operator|+=
name|g2
operator|->
name|benefit
operator|+
name|extra_benefit
expr_stmt|;
block|}
block|}
name|stats
index|[
name|i
index|]
operator|.
name|total_benefit
operator|=
name|this_benefit
expr_stmt|;
block|}
comment|/* Iterate, combining until we can't.  */
name|restart
label|:
name|qsort
argument_list|(
name|stats
argument_list|,
name|giv_count
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|stats
argument_list|)
argument_list|,
name|cmp_combine_givs_stats
argument_list|)
expr_stmt|;
if|if
condition|(
name|loop_dump_stream
condition|)
block|{
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Sorted combine statistics:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|giv_count
condition|;
name|k
operator|++
control|)
block|{
name|g1
operator|=
name|giv_array
index|[
name|stats
index|[
name|k
index|]
operator|.
name|giv_number
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|g1
operator|->
name|combined_with
operator|&&
operator|!
name|g1
operator|->
name|same
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|" {%d, %d}"
argument_list|,
name|INSN_UID
argument_list|(
name|giv_array
index|[
name|stats
index|[
name|k
index|]
operator|.
name|giv_number
index|]
operator|->
name|insn
argument_list|)
argument_list|,
name|stats
index|[
name|k
index|]
operator|.
name|total_benefit
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|loop_dump_stream
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|giv_count
condition|;
name|k
operator|++
control|)
block|{
name|int
name|g1_add_benefit
init|=
literal|0
decl_stmt|;
name|i
operator|=
name|stats
index|[
name|k
index|]
operator|.
name|giv_number
expr_stmt|;
name|g1
operator|=
name|giv_array
index|[
name|i
index|]
expr_stmt|;
comment|/* If it has already been combined, skip.  */
if|if
condition|(
name|g1
operator|->
name|combined_with
operator|||
name|g1
operator|->
name|same
condition|)
continue|continue;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|giv_count
condition|;
name|j
operator|++
control|)
block|{
name|g2
operator|=
name|giv_array
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|g1
operator|!=
name|g2
operator|&&
name|can_combine
index|[
name|i
operator|*
name|giv_count
operator|+
name|j
index|]
comment|/* If it has already been combined, skip.  */
operator|&&
operator|!
name|g2
operator|->
name|same
operator|&&
operator|!
name|g2
operator|->
name|combined_with
condition|)
block|{
name|int
name|l
decl_stmt|;
name|g2
operator|->
name|new_reg
operator|=
name|can_combine
index|[
name|i
operator|*
name|giv_count
operator|+
name|j
index|]
expr_stmt|;
name|g2
operator|->
name|same
operator|=
name|g1
expr_stmt|;
comment|/* For destination, we now may replace by mem expression instead 		 of register.  This changes the costs considerably, so add the 		 compensation.  */
if|if
condition|(
name|g2
operator|->
name|giv_type
operator|==
name|DEST_ADDR
condition|)
name|g2
operator|->
name|benefit
operator|=
operator|(
name|g2
operator|->
name|benefit
operator|+
name|reg_address_cost
operator|-
name|address_cost
argument_list|(
name|g2
operator|->
name|new_reg
argument_list|,
name|GET_MODE
argument_list|(
name|g2
operator|->
name|mem
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|g1
operator|->
name|combined_with
operator|++
expr_stmt|;
name|g1
operator|->
name|lifetime
operator|+=
name|g2
operator|->
name|lifetime
expr_stmt|;
name|g1_add_benefit
operator|+=
name|g2
operator|->
name|benefit
expr_stmt|;
comment|/* ??? The new final_[bg]iv_value code does a much better job 		 of finding replaceable giv's, and hence this code may no 		 longer be necessary.  */
if|if
condition|(
operator|!
name|g2
operator|->
name|replaceable
operator|&&
name|REG_USERVAR_P
argument_list|(
name|g2
operator|->
name|dest_reg
argument_list|)
condition|)
name|g1_add_benefit
operator|-=
name|copy_cost
expr_stmt|;
comment|/* To help optimize the next set of combinations, remove 		 this giv from the benefits of other potential mates.  */
for|for
control|(
name|l
operator|=
literal|0
init|;
name|l
operator|<
name|giv_count
condition|;
operator|++
name|l
control|)
block|{
name|int
name|m
init|=
name|stats
index|[
name|l
index|]
operator|.
name|giv_number
decl_stmt|;
if|if
condition|(
name|can_combine
index|[
name|m
operator|*
name|giv_count
operator|+
name|j
index|]
condition|)
name|stats
index|[
name|l
index|]
operator|.
name|total_benefit
operator|-=
name|g2
operator|->
name|benefit
operator|+
name|extra_benefit
expr_stmt|;
block|}
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"giv at %d combined with giv at %d; new benefit %d + %d, lifetime %d\n"
argument_list|,
name|INSN_UID
argument_list|(
name|g2
operator|->
name|insn
argument_list|)
argument_list|,
name|INSN_UID
argument_list|(
name|g1
operator|->
name|insn
argument_list|)
argument_list|,
name|g1
operator|->
name|benefit
argument_list|,
name|g1_add_benefit
argument_list|,
name|g1
operator|->
name|lifetime
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* To help optimize the next set of combinations, remove 	 this giv from the benefits of other potential mates.  */
if|if
condition|(
name|g1
operator|->
name|combined_with
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|giv_count
condition|;
operator|++
name|j
control|)
block|{
name|int
name|m
init|=
name|stats
index|[
name|j
index|]
operator|.
name|giv_number
decl_stmt|;
if|if
condition|(
name|can_combine
index|[
name|m
operator|*
name|giv_count
operator|+
name|i
index|]
condition|)
name|stats
index|[
name|j
index|]
operator|.
name|total_benefit
operator|-=
name|g1
operator|->
name|benefit
operator|+
name|extra_benefit
expr_stmt|;
block|}
name|g1
operator|->
name|benefit
operator|+=
name|g1_add_benefit
expr_stmt|;
comment|/* We've finished with this giv, and everything it touched. 	     Restart the combination so that proper weights for the 	     rest of the givs are properly taken into account.  */
comment|/* ??? Ideally we would compact the arrays at this point, so 	     as to not cover old ground.  But sanely compacting 	     can_combine is tricky.  */
goto|goto
name|restart
goto|;
block|}
block|}
comment|/* Clean up.  */
name|free
argument_list|(
name|stats
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|can_combine
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate sequence for REG = B * M + A.  */
end_comment

begin_function
specifier|static
name|rtx
name|gen_add_mult
parameter_list|(
name|b
parameter_list|,
name|m
parameter_list|,
name|a
parameter_list|,
name|reg
parameter_list|)
name|rtx
name|b
decl_stmt|;
comment|/* initial value of basic induction variable */
name|rtx
name|m
decl_stmt|;
comment|/* multiplicative constant */
name|rtx
name|a
decl_stmt|;
comment|/* additive constant */
name|rtx
name|reg
decl_stmt|;
comment|/* destination register */
block|{
name|rtx
name|seq
decl_stmt|;
name|rtx
name|result
decl_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
comment|/* Use unsigned arithmetic.  */
name|result
operator|=
name|expand_mult_add
argument_list|(
name|b
argument_list|,
name|reg
argument_list|,
name|m
argument_list|,
name|a
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|!=
name|result
condition|)
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
return|return
name|seq
return|;
block|}
end_function

begin_comment
comment|/* Update registers created in insn sequence SEQ.  */
end_comment

begin_function
specifier|static
name|void
name|loop_regs_update
parameter_list|(
name|loop
parameter_list|,
name|seq
parameter_list|)
specifier|const
name|struct
name|loop
modifier|*
name|loop
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|rtx
name|seq
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|;
comment|/* Update register info for alias analysis.  */
if|if
condition|(
name|seq
operator|==
name|NULL_RTX
condition|)
return|return;
if|if
condition|(
name|INSN_P
argument_list|(
name|seq
argument_list|)
condition|)
block|{
name|insn
operator|=
name|seq
expr_stmt|;
while|while
condition|(
name|insn
operator|!=
name|NULL_RTX
condition|)
block|{
name|rtx
name|set
init|=
name|single_set
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|set
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
name|record_base_value
argument_list|(
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
argument_list|,
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|seq
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|seq
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
name|record_base_value
argument_list|(
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|seq
argument_list|)
argument_list|)
argument_list|,
name|SET_SRC
argument_list|(
name|seq
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* EMIT code before BEFORE_BB/BEFORE_INSN to set REG = B * M + A.  */
end_comment

begin_function
name|void
name|loop_iv_add_mult_emit_before
parameter_list|(
name|loop
parameter_list|,
name|b
parameter_list|,
name|m
parameter_list|,
name|a
parameter_list|,
name|reg
parameter_list|,
name|before_bb
parameter_list|,
name|before_insn
parameter_list|)
specifier|const
name|struct
name|loop
modifier|*
name|loop
decl_stmt|;
name|rtx
name|b
decl_stmt|;
comment|/* initial value of basic induction variable */
name|rtx
name|m
decl_stmt|;
comment|/* multiplicative constant */
name|rtx
name|a
decl_stmt|;
comment|/* additive constant */
name|rtx
name|reg
decl_stmt|;
comment|/* destination register */
name|basic_block
name|before_bb
decl_stmt|;
name|rtx
name|before_insn
decl_stmt|;
block|{
name|rtx
name|seq
decl_stmt|;
if|if
condition|(
operator|!
name|before_insn
condition|)
block|{
name|loop_iv_add_mult_hoist
argument_list|(
name|loop
argument_list|,
name|b
argument_list|,
name|m
argument_list|,
name|a
argument_list|,
name|reg
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Use copy_rtx to prevent unexpected sharing of these rtx.  */
name|seq
operator|=
name|gen_add_mult
argument_list|(
name|copy_rtx
argument_list|(
name|b
argument_list|)
argument_list|,
name|copy_rtx
argument_list|(
name|m
argument_list|)
argument_list|,
name|copy_rtx
argument_list|(
name|a
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* Increase the lifetime of any invariants moved further in code.  */
name|update_reg_last_use
argument_list|(
name|a
argument_list|,
name|before_insn
argument_list|)
expr_stmt|;
name|update_reg_last_use
argument_list|(
name|b
argument_list|,
name|before_insn
argument_list|)
expr_stmt|;
name|update_reg_last_use
argument_list|(
name|m
argument_list|,
name|before_insn
argument_list|)
expr_stmt|;
comment|/* It is possible that the expansion created lots of new registers.      Iterate over the sequence we just created and record them all.  We      must do this before inserting the sequence.  */
name|loop_regs_update
argument_list|(
name|loop
argument_list|,
name|seq
argument_list|)
expr_stmt|;
name|loop_insn_emit_before
argument_list|(
name|loop
argument_list|,
name|before_bb
argument_list|,
name|before_insn
argument_list|,
name|seq
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit insns in loop pre-header to set REG = B * M + A.  */
end_comment

begin_function
name|void
name|loop_iv_add_mult_sink
parameter_list|(
name|loop
parameter_list|,
name|b
parameter_list|,
name|m
parameter_list|,
name|a
parameter_list|,
name|reg
parameter_list|)
specifier|const
name|struct
name|loop
modifier|*
name|loop
decl_stmt|;
name|rtx
name|b
decl_stmt|;
comment|/* initial value of basic induction variable */
name|rtx
name|m
decl_stmt|;
comment|/* multiplicative constant */
name|rtx
name|a
decl_stmt|;
comment|/* additive constant */
name|rtx
name|reg
decl_stmt|;
comment|/* destination register */
block|{
name|rtx
name|seq
decl_stmt|;
comment|/* Use copy_rtx to prevent unexpected sharing of these rtx.  */
name|seq
operator|=
name|gen_add_mult
argument_list|(
name|copy_rtx
argument_list|(
name|b
argument_list|)
argument_list|,
name|copy_rtx
argument_list|(
name|m
argument_list|)
argument_list|,
name|copy_rtx
argument_list|(
name|a
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* Increase the lifetime of any invariants moved further in code.      ???? Is this really necessary?  */
name|update_reg_last_use
argument_list|(
name|a
argument_list|,
name|loop
operator|->
name|sink
argument_list|)
expr_stmt|;
name|update_reg_last_use
argument_list|(
name|b
argument_list|,
name|loop
operator|->
name|sink
argument_list|)
expr_stmt|;
name|update_reg_last_use
argument_list|(
name|m
argument_list|,
name|loop
operator|->
name|sink
argument_list|)
expr_stmt|;
comment|/* It is possible that the expansion created lots of new registers.      Iterate over the sequence we just created and record them all.  We      must do this before inserting the sequence.  */
name|loop_regs_update
argument_list|(
name|loop
argument_list|,
name|seq
argument_list|)
expr_stmt|;
name|loop_insn_sink
argument_list|(
name|loop
argument_list|,
name|seq
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit insns after loop to set REG = B * M + A.  */
end_comment

begin_function
name|void
name|loop_iv_add_mult_hoist
parameter_list|(
name|loop
parameter_list|,
name|b
parameter_list|,
name|m
parameter_list|,
name|a
parameter_list|,
name|reg
parameter_list|)
specifier|const
name|struct
name|loop
modifier|*
name|loop
decl_stmt|;
name|rtx
name|b
decl_stmt|;
comment|/* initial value of basic induction variable */
name|rtx
name|m
decl_stmt|;
comment|/* multiplicative constant */
name|rtx
name|a
decl_stmt|;
comment|/* additive constant */
name|rtx
name|reg
decl_stmt|;
comment|/* destination register */
block|{
name|rtx
name|seq
decl_stmt|;
comment|/* Use copy_rtx to prevent unexpected sharing of these rtx.  */
name|seq
operator|=
name|gen_add_mult
argument_list|(
name|copy_rtx
argument_list|(
name|b
argument_list|)
argument_list|,
name|copy_rtx
argument_list|(
name|m
argument_list|)
argument_list|,
name|copy_rtx
argument_list|(
name|a
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* It is possible that the expansion created lots of new registers.      Iterate over the sequence we just created and record them all.  We      must do this before inserting the sequence.  */
name|loop_regs_update
argument_list|(
name|loop
argument_list|,
name|seq
argument_list|)
expr_stmt|;
name|loop_insn_hoist
argument_list|(
name|loop
argument_list|,
name|seq
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Similar to gen_add_mult, but compute cost rather than generating    sequence.  */
end_comment

begin_function
specifier|static
name|int
name|iv_add_mult_cost
parameter_list|(
name|b
parameter_list|,
name|m
parameter_list|,
name|a
parameter_list|,
name|reg
parameter_list|)
name|rtx
name|b
decl_stmt|;
comment|/* initial value of basic induction variable */
name|rtx
name|m
decl_stmt|;
comment|/* multiplicative constant */
name|rtx
name|a
decl_stmt|;
comment|/* additive constant */
name|rtx
name|reg
decl_stmt|;
comment|/* destination register */
block|{
name|int
name|cost
init|=
literal|0
decl_stmt|;
name|rtx
name|last
decl_stmt|,
name|result
decl_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|result
operator|=
name|expand_mult_add
argument_list|(
name|b
argument_list|,
name|reg
argument_list|,
name|m
argument_list|,
name|a
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|!=
name|result
condition|)
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|last
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
while|while
condition|(
name|last
condition|)
block|{
name|rtx
name|t
init|=
name|single_set
argument_list|(
name|last
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
condition|)
name|cost
operator|+=
name|rtx_cost
argument_list|(
name|SET_SRC
argument_list|(
name|t
argument_list|)
argument_list|,
name|SET
argument_list|)
expr_stmt|;
name|last
operator|=
name|PREV_INSN
argument_list|(
name|last
argument_list|)
expr_stmt|;
block|}
name|end_sequence
argument_list|()
expr_stmt|;
return|return
name|cost
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Test whether A * B can be computed without    an actual multiply insn.  Value is 1 if so.    ??? This function stinks because it generates a ton of wasted RTL   ??? and as a result fragments GC memory to no end.  There are other   ??? places in the compiler which are invoked a lot and do the same   ??? thing, generate wasted RTL just to see if something is possible.  */
end_comment

begin_function
specifier|static
name|int
name|product_cheap_p
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
name|rtx
name|a
decl_stmt|;
name|rtx
name|b
decl_stmt|;
block|{
name|rtx
name|tmp
decl_stmt|;
name|int
name|win
decl_stmt|,
name|n_insns
decl_stmt|;
comment|/* If only one is constant, make it B.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|a
argument_list|)
operator|==
name|CONST_INT
condition|)
name|tmp
operator|=
name|a
operator|,
name|a
operator|=
name|b
operator|,
name|b
operator|=
name|tmp
expr_stmt|;
comment|/* If first constant, both constant, so don't need multiply.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|a
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
literal|1
return|;
comment|/* If second not constant, neither is constant, so would need multiply.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|b
argument_list|)
operator|!=
name|CONST_INT
condition|)
return|return
literal|0
return|;
comment|/* One operand is constant, so might not need multiply insn.  Generate the      code for the multiply and see if a call or multiply, or long sequence      of insns is generated.  */
name|start_sequence
argument_list|()
expr_stmt|;
name|expand_mult
argument_list|(
name|GET_MODE
argument_list|(
name|a
argument_list|)
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|win
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|INSN_P
argument_list|(
name|tmp
argument_list|)
condition|)
block|{
name|n_insns
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|tmp
operator|!=
name|NULL_RTX
condition|)
block|{
name|rtx
name|next
init|=
name|NEXT_INSN
argument_list|(
name|tmp
argument_list|)
decl_stmt|;
if|if
condition|(
operator|++
name|n_insns
operator|>
literal|3
operator|||
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|!=
name|INSN
operator|||
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|tmp
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|tmp
argument_list|)
argument_list|)
argument_list|)
operator|==
name|MULT
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|tmp
argument_list|)
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|tmp
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|tmp
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|MULT
operator|)
condition|)
block|{
name|win
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|tmp
operator|=
name|next
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|tmp
argument_list|)
argument_list|)
operator|==
name|MULT
condition|)
name|win
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|MULT
condition|)
name|win
operator|=
literal|0
expr_stmt|;
return|return
name|win
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Check to see if loop can be terminated by a "decrement and branch until    zero" instruction.  If so, add a REG_NONNEG note to the branch insn if so.    Also try reversing an increment loop to a decrement loop    to see if the optimization can be performed.    Value is nonzero if optimization was performed.  */
end_comment

begin_comment
comment|/* This is useful even if the architecture doesn't have such an insn,    because it might change a loops which increments from 0 to n to a loop    which decrements from n to 0.  A loop that decrements to zero is usually    faster than one that increments from zero.  */
end_comment

begin_comment
comment|/* ??? This could be rewritten to use some of the loop unrolling procedures,    such as approx_final_value, biv_total_increment, loop_iterations, and    final_[bg]iv_value.  */
end_comment

begin_function
specifier|static
name|int
name|check_dbra_loop
parameter_list|(
name|loop
parameter_list|,
name|insn_count
parameter_list|)
name|struct
name|loop
modifier|*
name|loop
decl_stmt|;
name|int
name|insn_count
decl_stmt|;
block|{
name|struct
name|loop_info
modifier|*
name|loop_info
init|=
name|LOOP_INFO
argument_list|(
name|loop
argument_list|)
decl_stmt|;
name|struct
name|loop_regs
modifier|*
name|regs
init|=
name|LOOP_REGS
argument_list|(
name|loop
argument_list|)
decl_stmt|;
name|struct
name|loop_ivs
modifier|*
name|ivs
init|=
name|LOOP_IVS
argument_list|(
name|loop
argument_list|)
decl_stmt|;
name|struct
name|iv_class
modifier|*
name|bl
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
name|rtx
name|jump_label
decl_stmt|;
name|rtx
name|final_value
decl_stmt|;
name|rtx
name|start_value
decl_stmt|;
name|rtx
name|new_add_val
decl_stmt|;
name|rtx
name|comparison
decl_stmt|;
name|rtx
name|before_comparison
decl_stmt|;
name|rtx
name|p
decl_stmt|;
name|rtx
name|jump
decl_stmt|;
name|rtx
name|first_compare
decl_stmt|;
name|int
name|compare_and_branch
decl_stmt|;
name|rtx
name|loop_start
init|=
name|loop
operator|->
name|start
decl_stmt|;
name|rtx
name|loop_end
init|=
name|loop
operator|->
name|end
decl_stmt|;
comment|/* If last insn is a conditional branch, and the insn before tests a      register value, try to optimize it.  Otherwise, we can't do anything.  */
name|jump
operator|=
name|PREV_INSN
argument_list|(
name|loop_end
argument_list|)
expr_stmt|;
name|comparison
operator|=
name|get_condition_for_loop
argument_list|(
name|loop
argument_list|,
name|jump
argument_list|)
expr_stmt|;
if|if
condition|(
name|comparison
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|onlyjump_p
argument_list|(
name|jump
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Try to compute whether the compare/branch at the loop end is one or      two instructions.  */
name|get_condition
argument_list|(
name|jump
argument_list|,
operator|&
name|first_compare
argument_list|)
expr_stmt|;
if|if
condition|(
name|first_compare
operator|==
name|jump
condition|)
name|compare_and_branch
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|first_compare
operator|==
name|prev_nonnote_insn
argument_list|(
name|jump
argument_list|)
condition|)
name|compare_and_branch
operator|=
literal|2
expr_stmt|;
else|else
return|return
literal|0
return|;
block|{
comment|/* If more than one condition is present to control the loop, then        do not proceed, as this function does not know how to rewrite        loop tests with more than one condition.         Look backwards from the first insn in the last comparison        sequence and see if we've got another comparison sequence.  */
name|rtx
name|jump1
decl_stmt|;
if|if
condition|(
operator|(
name|jump1
operator|=
name|prev_nonnote_insn
argument_list|(
name|first_compare
argument_list|)
operator|)
operator|!=
name|loop
operator|->
name|cont
condition|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|jump1
argument_list|)
operator|==
name|JUMP_INSN
condition|)
return|return
literal|0
return|;
block|}
comment|/* Check all of the bivs to see if the compare uses one of them.      Skip biv's set more than once because we can't guarantee that      it will be zero on the last iteration.  Also skip if the biv is      used between its update and the test insn.  */
for|for
control|(
name|bl
operator|=
name|ivs
operator|->
name|list
init|;
name|bl
condition|;
name|bl
operator|=
name|bl
operator|->
name|next
control|)
block|{
if|if
condition|(
name|bl
operator|->
name|biv_count
operator|==
literal|1
operator|&&
operator|!
name|bl
operator|->
name|biv
operator|->
name|maybe_multiple
operator|&&
name|bl
operator|->
name|biv
operator|->
name|dest_reg
operator|==
name|XEXP
argument_list|(
name|comparison
argument_list|,
literal|0
argument_list|)
operator|&&
operator|!
name|reg_used_between_p
argument_list|(
name|regno_reg_rtx
index|[
name|bl
operator|->
name|regno
index|]
argument_list|,
name|bl
operator|->
name|biv
operator|->
name|insn
argument_list|,
name|first_compare
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|bl
condition|)
return|return
literal|0
return|;
comment|/* Look for the case where the basic induction variable is always      nonnegative, and equals zero on the last iteration.      In this case, add a reg_note REG_NONNEG, which allows the      m68k DBRA instruction to be used.  */
if|if
condition|(
operator|(
operator|(
name|GET_CODE
argument_list|(
name|comparison
argument_list|)
operator|==
name|GT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|comparison
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|comparison
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|comparison
argument_list|)
operator|==
name|NE
operator|&&
name|XEXP
argument_list|(
name|comparison
argument_list|,
literal|1
argument_list|)
operator|==
name|const0_rtx
operator|)
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|bl
operator|->
name|biv
operator|->
name|add_val
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|bl
operator|->
name|biv
operator|->
name|add_val
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* Initial value must be greater than 0, 	 init_val % -dec_value == 0 to ensure that it equals zero on 	 the last iteration */
if|if
condition|(
name|GET_CODE
argument_list|(
name|bl
operator|->
name|initial_value
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|bl
operator|->
name|initial_value
argument_list|)
operator|>
literal|0
operator|&&
operator|(
name|INTVAL
argument_list|(
name|bl
operator|->
name|initial_value
argument_list|)
operator|%
operator|(
operator|-
name|INTVAL
argument_list|(
name|bl
operator|->
name|biv
operator|->
name|add_val
argument_list|)
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* register always nonnegative, add REG_NOTE to branch */
if|if
condition|(
operator|!
name|find_reg_note
argument_list|(
name|jump
argument_list|,
name|REG_NONNEG
argument_list|,
name|NULL_RTX
argument_list|)
condition|)
name|REG_NOTES
argument_list|(
name|jump
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_NONNEG
argument_list|,
name|bl
operator|->
name|biv
operator|->
name|dest_reg
argument_list|,
name|REG_NOTES
argument_list|(
name|jump
argument_list|)
argument_list|)
expr_stmt|;
name|bl
operator|->
name|nonneg
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* If the decrement is 1 and the value was tested as>= 0 before 	 the loop, then we can safely optimize.  */
for|for
control|(
name|p
operator|=
name|loop_start
init|;
name|p
condition|;
name|p
operator|=
name|PREV_INSN
argument_list|(
name|p
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|CODE_LABEL
condition|)
break|break;
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|!=
name|JUMP_INSN
condition|)
continue|continue;
name|before_comparison
operator|=
name|get_condition_for_loop
argument_list|(
name|loop
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|before_comparison
operator|&&
name|XEXP
argument_list|(
name|before_comparison
argument_list|,
literal|0
argument_list|)
operator|==
name|bl
operator|->
name|biv
operator|->
name|dest_reg
operator|&&
name|GET_CODE
argument_list|(
name|before_comparison
argument_list|)
operator|==
name|LT
operator|&&
name|XEXP
argument_list|(
name|before_comparison
argument_list|,
literal|1
argument_list|)
operator|==
name|const0_rtx
operator|&&
operator|!
name|reg_set_between_p
argument_list|(
name|bl
operator|->
name|biv
operator|->
name|dest_reg
argument_list|,
name|p
argument_list|,
name|loop_start
argument_list|)
operator|&&
name|INTVAL
argument_list|(
name|bl
operator|->
name|biv
operator|->
name|add_val
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|find_reg_note
argument_list|(
name|jump
argument_list|,
name|REG_NONNEG
argument_list|,
name|NULL_RTX
argument_list|)
condition|)
name|REG_NOTES
argument_list|(
name|jump
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_NONNEG
argument_list|,
name|bl
operator|->
name|biv
operator|->
name|dest_reg
argument_list|,
name|REG_NOTES
argument_list|(
name|jump
argument_list|)
argument_list|)
expr_stmt|;
name|bl
operator|->
name|nonneg
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|bl
operator|->
name|biv
operator|->
name|add_val
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|bl
operator|->
name|biv
operator|->
name|add_val
argument_list|)
operator|>
literal|0
condition|)
block|{
comment|/* Try to change inc to dec, so can apply above optimization.  */
comment|/* Can do this if: 	 all registers modified are induction variables or invariant, 	 all memory references have non-overlapping addresses 	 (obviously true if only one write) 	 allow 2 insns for the compare/jump at the end of the loop.  */
comment|/* Also, we must avoid any instructions which use both the reversed 	 biv and another biv.  Such instructions will fail if the loop is 	 reversed.  We meet this condition by requiring that either 	 no_use_except_counting is true, or else that there is only 	 one biv.  */
name|int
name|num_nonfixed_reads
init|=
literal|0
decl_stmt|;
comment|/* 1 if the iteration var is used only to count iterations.  */
name|int
name|no_use_except_counting
init|=
literal|0
decl_stmt|;
comment|/* 1 if the loop has no memory store, or it has a single memory store 	 which is reversible.  */
name|int
name|reversible_mem_store
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|bl
operator|->
name|giv_count
operator|==
literal|0
operator|&&
operator|!
name|loop
operator|->
name|exit_count
operator|&&
operator|!
name|loop_info
operator|->
name|has_multiple_exit_targets
condition|)
block|{
name|rtx
name|bivreg
init|=
name|regno_reg_rtx
index|[
name|bl
operator|->
name|regno
index|]
decl_stmt|;
name|struct
name|iv_class
modifier|*
name|blt
decl_stmt|;
comment|/* If there are no givs for this biv, and the only exit is the 	     fall through at the end of the loop, then 	     see if perhaps there are no uses except to count.  */
name|no_use_except_counting
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|p
operator|=
name|loop_start
init|;
name|p
operator|!=
name|loop_end
condition|;
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|rtx
name|set
init|=
name|single_set
argument_list|(
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
name|set
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|bl
operator|->
name|regno
condition|)
comment|/* An insn that sets the biv is okay.  */
empty_stmt|;
elseif|else
if|if
condition|(
operator|(
name|p
operator|==
name|prev_nonnote_insn
argument_list|(
name|prev_nonnote_insn
argument_list|(
name|loop_end
argument_list|)
argument_list|)
operator|||
name|p
operator|==
name|prev_nonnote_insn
argument_list|(
name|loop_end
argument_list|)
operator|)
operator|&&
name|reg_mentioned_p
argument_list|(
name|bivreg
argument_list|,
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
condition|)
block|{
comment|/* If either of these insns uses the biv and sets a pseudo 		       that has more than one usage, then the biv has uses 		       other than counting since it's used to derive a value 		       that is used more than one time.  */
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|,
name|note_set_pseudo_multiple_uses
argument_list|,
name|regs
argument_list|)
expr_stmt|;
if|if
condition|(
name|regs
operator|->
name|multiple_uses
condition|)
block|{
name|no_use_except_counting
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|reg_mentioned_p
argument_list|(
name|bivreg
argument_list|,
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
condition|)
block|{
name|no_use_except_counting
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
comment|/* A biv has uses besides counting if it is used to set 	     another biv.  */
for|for
control|(
name|blt
operator|=
name|ivs
operator|->
name|list
init|;
name|blt
condition|;
name|blt
operator|=
name|blt
operator|->
name|next
control|)
if|if
condition|(
name|blt
operator|->
name|init_set
operator|&&
name|reg_mentioned_p
argument_list|(
name|bivreg
argument_list|,
name|SET_SRC
argument_list|(
name|blt
operator|->
name|init_set
argument_list|)
argument_list|)
condition|)
block|{
name|no_use_except_counting
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|no_use_except_counting
condition|)
comment|/* No need to worry about MEMs.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|loop_info
operator|->
name|num_mem_sets
operator|<=
literal|1
condition|)
block|{
for|for
control|(
name|p
operator|=
name|loop_start
init|;
name|p
operator|!=
name|loop_end
condition|;
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|p
argument_list|)
condition|)
name|num_nonfixed_reads
operator|+=
name|count_nonfixed_reads
argument_list|(
name|loop
argument_list|,
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the loop has a single store, and the destination address is 	     invariant, then we can't reverse the loop, because this address 	     might then have the wrong value at loop exit. 	     This would work if the source was invariant also, however, in that 	     case, the insn should have been moved out of the loop.  */
if|if
condition|(
name|loop_info
operator|->
name|num_mem_sets
operator|==
literal|1
condition|)
block|{
name|struct
name|induction
modifier|*
name|v
decl_stmt|;
comment|/* If we could prove that each of the memory locations 		 written to was different, then we could reverse the 		 store -- but we don't presently have any way of 		 knowing that.  */
name|reversible_mem_store
operator|=
literal|0
expr_stmt|;
comment|/* If the store depends on a register that is set after the 		 store, it depends on the initial value, and is thus not 		 reversible.  */
for|for
control|(
name|v
operator|=
name|bl
operator|->
name|giv
init|;
name|reversible_mem_store
operator|&&
name|v
condition|;
name|v
operator|=
name|v
operator|->
name|next_iv
control|)
block|{
if|if
condition|(
name|v
operator|->
name|giv_type
operator|==
name|DEST_REG
operator|&&
name|reg_mentioned_p
argument_list|(
name|v
operator|->
name|dest_reg
argument_list|,
name|PATTERN
argument_list|(
name|loop_info
operator|->
name|first_loop_store_insn
argument_list|)
argument_list|)
operator|&&
name|loop_insn_first_p
argument_list|(
name|loop_info
operator|->
name|first_loop_store_insn
argument_list|,
name|v
operator|->
name|insn
argument_list|)
condition|)
name|reversible_mem_store
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
else|else
return|return
literal|0
return|;
comment|/* This code only acts for innermost loops.  Also it simplifies 	 the memory address check by only reversing loops with 	 zero or one memory access. 	 Two memory accesses could involve parts of the same array, 	 and that can't be reversed. 	 If the biv is used only for counting, than we don't need to worry 	 about all these things.  */
if|if
condition|(
operator|(
name|num_nonfixed_reads
operator|<=
literal|1
operator|&&
operator|!
name|loop_info
operator|->
name|has_nonconst_call
operator|&&
operator|!
name|loop_info
operator|->
name|has_prefetch
operator|&&
operator|!
name|loop_info
operator|->
name|has_volatile
operator|&&
name|reversible_mem_store
operator|&&
operator|(
name|bl
operator|->
name|giv_count
operator|+
name|bl
operator|->
name|biv_count
operator|+
name|loop_info
operator|->
name|num_mem_sets
operator|+
name|num_unmoved_movables
argument_list|(
name|loop
argument_list|)
operator|+
name|compare_and_branch
operator|==
name|insn_count
operator|)
operator|&&
operator|(
name|bl
operator|==
name|ivs
operator|->
name|list
operator|&&
name|bl
operator|->
name|next
operator|==
literal|0
operator|)
operator|)
operator|||
operator|(
name|no_use_except_counting
operator|&&
operator|!
name|loop_info
operator|->
name|has_prefetch
operator|)
condition|)
block|{
name|rtx
name|tem
decl_stmt|;
comment|/* Loop can be reversed.  */
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Can reverse loop\n"
argument_list|)
expr_stmt|;
comment|/* Now check other conditions:  	     The increment must be a constant, as must the initial value, 	     and the comparison code must be LT.  	     This test can probably be improved since +/- 1 in the constant 	     can be obtained by changing LT to LE and vice versa; this is 	     confusing.  */
if|if
condition|(
name|comparison
comment|/* for constants, LE gets turned into LT */
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|comparison
argument_list|)
operator|==
name|LT
operator|||
operator|(
name|GET_CODE
argument_list|(
name|comparison
argument_list|)
operator|==
name|LE
operator|&&
name|no_use_except_counting
operator|)
operator|)
condition|)
block|{
name|HOST_WIDE_INT
name|add_val
decl_stmt|,
name|add_adjust
decl_stmt|,
name|comparison_val
init|=
literal|0
decl_stmt|;
name|rtx
name|initial_value
decl_stmt|,
name|comparison_value
decl_stmt|;
name|int
name|nonneg
init|=
literal|0
decl_stmt|;
name|enum
name|rtx_code
name|cmp_code
decl_stmt|;
name|int
name|comparison_const_width
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|comparison_sign_mask
decl_stmt|;
name|add_val
operator|=
name|INTVAL
argument_list|(
name|bl
operator|->
name|biv
operator|->
name|add_val
argument_list|)
expr_stmt|;
name|comparison_value
operator|=
name|XEXP
argument_list|(
name|comparison
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|comparison_value
argument_list|)
operator|==
name|VOIDmode
condition|)
name|comparison_const_width
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|comparison
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|comparison_const_width
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|comparison_value
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|comparison_const_width
operator|>
name|HOST_BITS_PER_WIDE_INT
condition|)
name|comparison_const_width
operator|=
name|HOST_BITS_PER_WIDE_INT
expr_stmt|;
name|comparison_sign_mask
operator|=
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|comparison_const_width
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* If the comparison value is not a loop invariant, then we 		 can not reverse this loop.  		 ??? If the insns which initialize the comparison value as 		 a whole compute an invariant result, then we could move 		 them out of the loop and proceed with loop reversal.  */
if|if
condition|(
operator|!
name|loop_invariant_p
argument_list|(
name|loop
argument_list|,
name|comparison_value
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|comparison_value
argument_list|)
operator|==
name|CONST_INT
condition|)
name|comparison_val
operator|=
name|INTVAL
argument_list|(
name|comparison_value
argument_list|)
expr_stmt|;
name|initial_value
operator|=
name|bl
operator|->
name|initial_value
expr_stmt|;
comment|/* Normalize the initial value if it is an integer and 		 has no other use except as a counter.  This will allow 		 a few more loops to be reversed.  */
if|if
condition|(
name|no_use_except_counting
operator|&&
name|GET_CODE
argument_list|(
name|comparison_value
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|initial_value
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|comparison_val
operator|=
name|comparison_val
operator|-
name|INTVAL
argument_list|(
name|bl
operator|->
name|initial_value
argument_list|)
expr_stmt|;
comment|/* The code below requires comparison_val to be a multiple 		     of add_val in order to do the loop reversal, so 		     round up comparison_val to a multiple of add_val. 		     Since comparison_value is constant, we know that the 		     current comparison code is LT.  */
name|comparison_val
operator|=
name|comparison_val
operator|+
name|add_val
operator|-
literal|1
expr_stmt|;
name|comparison_val
operator|-=
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|comparison_val
operator|%
name|add_val
expr_stmt|;
comment|/* We postpone overflow checks for COMPARISON_VAL here; 		     even if there is an overflow, we might still be able to 		     reverse the loop, if converting the loop exit test to 		     NE is possible.  */
name|initial_value
operator|=
name|const0_rtx
expr_stmt|;
block|}
comment|/* First check if we can do a vanilla loop reversal.  */
if|if
condition|(
name|initial_value
operator|==
name|const0_rtx
comment|/* If we have a decrement_and_branch_on_count, 		     prefer the NE test, since this will allow that 		     instruction to be generated.  Note that we must 		     use a vanilla loop reversal if the biv is used to 		     calculate a giv or has a non-counting use.  */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAVE_decrement_and_branch_until_zero
argument_list|)
expr|\
operator|&&
name|defined
argument_list|(
name|HAVE_decrement_and_branch_on_count
argument_list|)
operator|&&
operator|(
operator|!
operator|(
name|add_val
operator|==
literal|1
operator|&&
name|loop
operator|->
name|vtop
operator|&&
operator|(
name|bl
operator|->
name|biv_count
operator|==
literal|0
operator|||
name|no_use_except_counting
operator|)
operator|)
operator|)
endif|#
directive|endif
operator|&&
name|GET_CODE
argument_list|(
name|comparison_value
argument_list|)
operator|==
name|CONST_INT
comment|/* Now do postponed overflow checks on COMPARISON_VAL.  */
operator|&&
operator|!
operator|(
operator|(
operator|(
name|comparison_val
operator|-
name|add_val
operator|)
operator|^
name|INTVAL
argument_list|(
name|comparison_value
argument_list|)
operator|)
operator|&
name|comparison_sign_mask
operator|)
condition|)
block|{
comment|/* Register will always be nonnegative, with value 		     0 on last iteration */
name|add_adjust
operator|=
name|add_val
expr_stmt|;
name|nonneg
operator|=
literal|1
expr_stmt|;
name|cmp_code
operator|=
name|GE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|add_val
operator|==
literal|1
operator|&&
name|loop
operator|->
name|vtop
operator|&&
operator|(
name|bl
operator|->
name|biv_count
operator|==
literal|0
operator|||
name|no_use_except_counting
operator|)
condition|)
block|{
name|add_adjust
operator|=
literal|0
expr_stmt|;
name|cmp_code
operator|=
name|NE
expr_stmt|;
block|}
else|else
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|comparison
argument_list|)
operator|==
name|LE
condition|)
name|add_adjust
operator|-=
name|add_val
expr_stmt|;
comment|/* If the initial value is not zero, or if the comparison 		 value is not an exact multiple of the increment, then we 		 can not reverse this loop.  */
if|if
condition|(
name|initial_value
operator|==
name|const0_rtx
operator|&&
name|GET_CODE
argument_list|(
name|comparison_value
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|comparison_val
operator|%
name|add_val
operator|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|no_use_except_counting
operator|||
name|add_val
operator|!=
literal|1
condition|)
return|return
literal|0
return|;
block|}
name|final_value
operator|=
name|comparison_value
expr_stmt|;
comment|/* Reset these in case we normalized the initial value 		 and comparison value above.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|comparison_value
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|initial_value
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|comparison_value
operator|=
name|GEN_INT
argument_list|(
name|comparison_val
argument_list|)
expr_stmt|;
name|final_value
operator|=
name|GEN_INT
argument_list|(
name|comparison_val
operator|+
name|INTVAL
argument_list|(
name|bl
operator|->
name|initial_value
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|bl
operator|->
name|initial_value
operator|=
name|initial_value
expr_stmt|;
comment|/* Save some info needed to produce the new insns.  */
name|reg
operator|=
name|bl
operator|->
name|biv
operator|->
name|dest_reg
expr_stmt|;
name|jump_label
operator|=
name|condjump_label
argument_list|(
name|PREV_INSN
argument_list|(
name|loop_end
argument_list|)
argument_list|)
expr_stmt|;
name|new_add_val
operator|=
name|GEN_INT
argument_list|(
operator|-
name|INTVAL
argument_list|(
name|bl
operator|->
name|biv
operator|->
name|add_val
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set start_value; if this is not a CONST_INT, we need 		 to generate a SUB. 		 Initialize biv to start_value before loop start. 		 The old initializing insn will be deleted as a 		 dead store by flow.c.  */
if|if
condition|(
name|initial_value
operator|==
name|const0_rtx
operator|&&
name|GET_CODE
argument_list|(
name|comparison_value
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|start_value
operator|=
name|GEN_INT
argument_list|(
name|comparison_val
operator|-
name|add_adjust
argument_list|)
expr_stmt|;
name|loop_insn_hoist
argument_list|(
name|loop
argument_list|,
name|gen_move_insn
argument_list|(
name|reg
argument_list|,
name|start_value
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|initial_value
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|reg
argument_list|)
decl_stmt|;
name|rtx
name|offset
init|=
name|GEN_INT
argument_list|(
operator|-
name|INTVAL
argument_list|(
name|initial_value
argument_list|)
operator|-
name|add_adjust
argument_list|)
decl_stmt|;
name|rtx
name|add_insn
init|=
name|gen_add3_insn
argument_list|(
name|reg
argument_list|,
name|comparison_value
argument_list|,
name|offset
argument_list|)
decl_stmt|;
if|if
condition|(
name|add_insn
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|start_value
operator|=
name|gen_rtx_PLUS
argument_list|(
name|mode
argument_list|,
name|comparison_value
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|loop_insn_hoist
argument_list|(
name|loop
argument_list|,
name|add_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|comparison
argument_list|)
operator|==
name|LE
condition|)
name|final_value
operator|=
name|gen_rtx_PLUS
argument_list|(
name|mode
argument_list|,
name|comparison_value
argument_list|,
name|GEN_INT
argument_list|(
name|add_val
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|add_adjust
condition|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|reg
argument_list|)
decl_stmt|;
name|rtx
name|sub_insn
init|=
name|gen_sub3_insn
argument_list|(
name|reg
argument_list|,
name|comparison_value
argument_list|,
name|initial_value
argument_list|)
decl_stmt|;
if|if
condition|(
name|sub_insn
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|start_value
operator|=
name|gen_rtx_MINUS
argument_list|(
name|mode
argument_list|,
name|comparison_value
argument_list|,
name|initial_value
argument_list|)
expr_stmt|;
name|loop_insn_hoist
argument_list|(
name|loop
argument_list|,
name|sub_insn
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* We could handle the other cases too, but it'll be 		   better to have a testcase first.  */
return|return
literal|0
return|;
comment|/* We may not have a single insn which can increment a reg, so 		 create a sequence to hold all the insns from expand_inc.  */
name|start_sequence
argument_list|()
expr_stmt|;
name|expand_inc
argument_list|(
name|reg
argument_list|,
name|new_add_val
argument_list|)
expr_stmt|;
name|tem
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|p
operator|=
name|loop_insn_emit_before
argument_list|(
name|loop
argument_list|,
literal|0
argument_list|,
name|bl
operator|->
name|biv
operator|->
name|insn
argument_list|,
name|tem
argument_list|)
expr_stmt|;
name|delete_insn
argument_list|(
name|bl
operator|->
name|biv
operator|->
name|insn
argument_list|)
expr_stmt|;
comment|/* Update biv info to reflect its new status.  */
name|bl
operator|->
name|biv
operator|->
name|insn
operator|=
name|p
expr_stmt|;
name|bl
operator|->
name|initial_value
operator|=
name|start_value
expr_stmt|;
name|bl
operator|->
name|biv
operator|->
name|add_val
operator|=
name|new_add_val
expr_stmt|;
comment|/* Update loop info.  */
name|loop_info
operator|->
name|initial_value
operator|=
name|reg
expr_stmt|;
name|loop_info
operator|->
name|initial_equiv_value
operator|=
name|reg
expr_stmt|;
name|loop_info
operator|->
name|final_value
operator|=
name|const0_rtx
expr_stmt|;
name|loop_info
operator|->
name|final_equiv_value
operator|=
name|const0_rtx
expr_stmt|;
name|loop_info
operator|->
name|comparison_value
operator|=
name|const0_rtx
expr_stmt|;
name|loop_info
operator|->
name|comparison_code
operator|=
name|cmp_code
expr_stmt|;
name|loop_info
operator|->
name|increment
operator|=
name|new_add_val
expr_stmt|;
comment|/* Inc LABEL_NUSES so that delete_insn will 		 not delete the label.  */
name|LABEL_NUSES
argument_list|(
name|XEXP
argument_list|(
name|jump_label
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|++
expr_stmt|;
comment|/* Emit an insn after the end of the loop to set the biv's 		 proper exit value if it is used anywhere outside the loop.  */
if|if
condition|(
operator|(
name|REGNO_LAST_UID
argument_list|(
name|bl
operator|->
name|regno
argument_list|)
operator|!=
name|INSN_UID
argument_list|(
name|first_compare
argument_list|)
operator|)
operator|||
operator|!
name|bl
operator|->
name|init_insn
operator|||
name|REGNO_FIRST_UID
argument_list|(
name|bl
operator|->
name|regno
argument_list|)
operator|!=
name|INSN_UID
argument_list|(
name|bl
operator|->
name|init_insn
argument_list|)
condition|)
name|loop_insn_sink
argument_list|(
name|loop
argument_list|,
name|gen_load_of_final_value
argument_list|(
name|reg
argument_list|,
name|final_value
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Delete compare/branch at end of loop.  */
name|delete_related_insns
argument_list|(
name|PREV_INSN
argument_list|(
name|loop_end
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|compare_and_branch
operator|==
literal|2
condition|)
name|delete_related_insns
argument_list|(
name|first_compare
argument_list|)
expr_stmt|;
comment|/* Add new compare/branch insn at end of loop.  */
name|start_sequence
argument_list|()
expr_stmt|;
name|emit_cmp_and_jump_insns
argument_list|(
name|reg
argument_list|,
name|const0_rtx
argument_list|,
name|cmp_code
argument_list|,
name|NULL_RTX
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|,
literal|0
argument_list|,
name|XEXP
argument_list|(
name|jump_label
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|tem
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_jump_insn_before
argument_list|(
name|tem
argument_list|,
name|loop_end
argument_list|)
expr_stmt|;
for|for
control|(
name|tem
operator|=
name|PREV_INSN
argument_list|(
name|loop_end
argument_list|)
init|;
name|tem
operator|&&
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|!=
name|JUMP_INSN
condition|;
name|tem
operator|=
name|PREV_INSN
argument_list|(
name|tem
argument_list|)
control|)
empty_stmt|;
if|if
condition|(
name|tem
condition|)
name|JUMP_LABEL
argument_list|(
name|tem
argument_list|)
operator|=
name|XEXP
argument_list|(
name|jump_label
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nonneg
condition|)
block|{
if|if
condition|(
name|tem
condition|)
block|{
comment|/* Increment of LABEL_NUSES done above.  */
comment|/* Register is now always nonnegative, 			 so add REG_NONNEG note to the branch.  */
name|REG_NOTES
argument_list|(
name|tem
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_NONNEG
argument_list|,
name|reg
argument_list|,
name|REG_NOTES
argument_list|(
name|tem
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|bl
operator|->
name|nonneg
operator|=
literal|1
expr_stmt|;
block|}
comment|/* No insn may reference both the reversed and another biv or it 		 will fail (see comment near the top of the loop reversal 		 code). 		 Earlier on, we have verified that the biv has no use except 		 counting, or it is the only biv in this function. 		 However, the code that computes no_use_except_counting does 		 not verify reg notes.  It's possible to have an insn that 		 references another biv, and has a REG_EQUAL note with an 		 expression based on the reversed biv.  To avoid this case, 		 remove all REG_EQUAL notes based on the reversed biv 		 here.  */
for|for
control|(
name|p
operator|=
name|loop_start
init|;
name|p
operator|!=
name|loop_end
condition|;
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|rtx
modifier|*
name|pnote
decl_stmt|;
name|rtx
name|set
init|=
name|single_set
argument_list|(
name|p
argument_list|)
decl_stmt|;
comment|/* If this is a set of a GIV based on the reversed biv, any 		       REG_EQUAL notes should still be correct.  */
if|if
condition|(
operator|!
name|set
operator|||
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
operator|(
name|size_t
operator|)
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|>=
name|ivs
operator|->
name|n_regs
operator|||
name|REG_IV_TYPE
argument_list|(
name|ivs
argument_list|,
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|GENERAL_INDUCT
operator|||
name|REG_IV_INFO
argument_list|(
name|ivs
argument_list|,
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
argument_list|)
operator|->
name|src_reg
operator|!=
name|bl
operator|->
name|biv
operator|->
name|src_reg
condition|)
for|for
control|(
name|pnote
operator|=
operator|&
name|REG_NOTES
argument_list|(
name|p
argument_list|)
init|;
operator|*
name|pnote
condition|;
control|)
block|{
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
operator|*
name|pnote
argument_list|)
operator|==
name|REG_EQUAL
operator|&&
name|reg_mentioned_p
argument_list|(
name|regno_reg_rtx
index|[
name|bl
operator|->
name|regno
index|]
argument_list|,
name|XEXP
argument_list|(
operator|*
name|pnote
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
operator|*
name|pnote
operator|=
name|XEXP
argument_list|(
operator|*
name|pnote
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|pnote
operator|=
operator|&
name|XEXP
argument_list|(
operator|*
name|pnote
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Mark that this biv has been reversed.  Each giv which depends 		 on this biv, and which is also live past the end of the loop 		 will have to be fixed up.  */
name|bl
operator|->
name|reversed
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|loop_dump_stream
condition|)
block|{
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Reversed loop"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bl
operator|->
name|nonneg
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|" and added reg_nonneg\n"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Verify whether the biv BL appears to be eliminable,    based on the insns in the loop that refer to it.     If ELIMINATE_P is nonzero, actually do the elimination.     THRESHOLD and INSN_COUNT are from loop_optimize and are used to    determine whether invariant insns should be placed inside or at the    start of the loop.  */
end_comment

begin_function
specifier|static
name|int
name|maybe_eliminate_biv
parameter_list|(
name|loop
parameter_list|,
name|bl
parameter_list|,
name|eliminate_p
parameter_list|,
name|threshold
parameter_list|,
name|insn_count
parameter_list|)
specifier|const
name|struct
name|loop
modifier|*
name|loop
decl_stmt|;
name|struct
name|iv_class
modifier|*
name|bl
decl_stmt|;
name|int
name|eliminate_p
decl_stmt|;
name|int
name|threshold
decl_stmt|,
name|insn_count
decl_stmt|;
block|{
name|struct
name|loop_ivs
modifier|*
name|ivs
init|=
name|LOOP_IVS
argument_list|(
name|loop
argument_list|)
decl_stmt|;
name|rtx
name|reg
init|=
name|bl
operator|->
name|biv
operator|->
name|dest_reg
decl_stmt|;
name|rtx
name|p
decl_stmt|;
comment|/* Scan all insns in the loop, stopping if we find one that uses the      biv in a way that we cannot eliminate.  */
for|for
control|(
name|p
operator|=
name|loop
operator|->
name|start
init|;
name|p
operator|!=
name|loop
operator|->
name|end
condition|;
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
control|)
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|basic_block
name|where_bb
init|=
literal|0
decl_stmt|;
name|rtx
name|where_insn
init|=
name|threshold
operator|>=
name|insn_count
condition|?
literal|0
else|:
name|p
decl_stmt|;
name|rtx
name|note
decl_stmt|;
comment|/* If this is a libcall that sets a giv, skip ahead to its end.  */
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'i'
condition|)
block|{
name|note
operator|=
name|find_reg_note
argument_list|(
name|p
argument_list|,
name|REG_LIBCALL
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
if|if
condition|(
name|note
condition|)
block|{
name|rtx
name|last
init|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|set
init|=
name|single_set
argument_list|(
name|last
argument_list|)
decl_stmt|;
if|if
condition|(
name|set
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|unsigned
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|regno
operator|<
name|ivs
operator|->
name|n_regs
operator|&&
name|REG_IV_TYPE
argument_list|(
name|ivs
argument_list|,
name|regno
argument_list|)
operator|==
name|GENERAL_INDUCT
operator|&&
name|REG_IV_INFO
argument_list|(
name|ivs
argument_list|,
name|regno
argument_list|)
operator|->
name|src_reg
operator|==
name|bl
operator|->
name|biv
operator|->
name|src_reg
condition|)
name|p
operator|=
name|last
expr_stmt|;
block|}
block|}
block|}
comment|/* Closely examine the insn if the biv is mentioned.  */
if|if
condition|(
operator|(
name|code
operator|==
name|INSN
operator|||
name|code
operator|==
name|JUMP_INSN
operator|||
name|code
operator|==
name|CALL_INSN
operator|)
operator|&&
name|reg_mentioned_p
argument_list|(
name|reg
argument_list|,
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
operator|&&
operator|!
name|maybe_eliminate_biv_1
argument_list|(
name|loop
argument_list|,
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|,
name|p
argument_list|,
name|bl
argument_list|,
name|eliminate_p
argument_list|,
name|where_bb
argument_list|,
name|where_insn
argument_list|)
condition|)
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Cannot eliminate biv %d: biv used in insn %d.\n"
argument_list|,
name|bl
operator|->
name|regno
argument_list|,
name|INSN_UID
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* If we are eliminating, kill REG_EQUAL notes mentioning the biv.  */
if|if
condition|(
name|eliminate_p
operator|&&
operator|(
name|note
operator|=
name|find_reg_note
argument_list|(
name|p
argument_list|,
name|REG_EQUAL
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
operator|!=
name|NULL_RTX
operator|&&
name|reg_mentioned_p
argument_list|(
name|reg
argument_list|,
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|remove_note
argument_list|(
name|p
argument_list|,
name|note
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|==
name|loop
operator|->
name|end
condition|)
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"biv %d %s eliminated.\n"
argument_list|,
name|bl
operator|->
name|regno
argument_list|,
name|eliminate_p
condition|?
literal|"was"
else|:
literal|"can be"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* INSN and REFERENCE are instructions in the same insn chain.    Return nonzero if INSN is first.  */
end_comment

begin_function
name|int
name|loop_insn_first_p
parameter_list|(
name|insn
parameter_list|,
name|reference
parameter_list|)
name|rtx
name|insn
decl_stmt|,
name|reference
decl_stmt|;
block|{
name|rtx
name|p
decl_stmt|,
name|q
decl_stmt|;
for|for
control|(
name|p
operator|=
name|insn
operator|,
name|q
operator|=
name|reference
init|;
condition|;
control|)
block|{
comment|/* Start with test for not first so that INSN == REFERENCE yields not          first.  */
if|if
condition|(
name|q
operator|==
name|insn
operator|||
operator|!
name|p
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|p
operator|==
name|reference
operator|||
operator|!
name|q
condition|)
return|return
literal|1
return|;
comment|/* Either of P or Q might be a NOTE.  Notes have the same LUID as the          previous insn, hence the<= comparison below does not work if 	 P is a note.  */
if|if
condition|(
name|INSN_UID
argument_list|(
name|p
argument_list|)
operator|<
name|max_uid_for_loop
operator|&&
name|INSN_UID
argument_list|(
name|q
argument_list|)
operator|<
name|max_uid_for_loop
operator|&&
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|!=
name|NOTE
condition|)
return|return
name|INSN_LUID
argument_list|(
name|p
argument_list|)
operator|<=
name|INSN_LUID
argument_list|(
name|q
argument_list|)
return|;
if|if
condition|(
name|INSN_UID
argument_list|(
name|p
argument_list|)
operator|>=
name|max_uid_for_loop
operator|||
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|NOTE
condition|)
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|INSN_UID
argument_list|(
name|q
argument_list|)
operator|>=
name|max_uid_for_loop
condition|)
name|q
operator|=
name|NEXT_INSN
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* We are trying to eliminate BIV in INSN using GIV.  Return nonzero if    the offset that we have to take into account due to auto-increment /    div derivation is zero.  */
end_comment

begin_function
specifier|static
name|int
name|biv_elimination_giv_has_0_offset
parameter_list|(
name|biv
parameter_list|,
name|giv
parameter_list|,
name|insn
parameter_list|)
name|struct
name|induction
modifier|*
name|biv
decl_stmt|,
decl|*
name|giv
decl_stmt|;
end_function

begin_decl_stmt
name|rtx
name|insn
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* If the giv V had the auto-inc address optimization applied      to it, and INSN occurs between the giv insn and the biv      insn, then we'd have to adjust the value used here.      This is rare, so we don't bother to make this possible.  */
if|if
condition|(
name|giv
operator|->
name|auto_inc_opt
operator|&&
operator|(
operator|(
name|loop_insn_first_p
argument_list|(
name|giv
operator|->
name|insn
argument_list|,
name|insn
argument_list|)
operator|&&
name|loop_insn_first_p
argument_list|(
name|insn
argument_list|,
name|biv
operator|->
name|insn
argument_list|)
operator|)
operator|||
operator|(
name|loop_insn_first_p
argument_list|(
name|biv
operator|->
name|insn
argument_list|,
name|insn
argument_list|)
operator|&&
name|loop_insn_first_p
argument_list|(
name|insn
argument_list|,
name|giv
operator|->
name|insn
argument_list|)
operator|)
operator|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_block

begin_comment
comment|/* If BL appears in X (part of the pattern of INSN), see if we can    eliminate its use.  If so, return 1.  If not, return 0.     If BIV does not appear in X, return 1.     If ELIMINATE_P is nonzero, actually do the elimination.    WHERE_INSN/WHERE_BB indicate where extra insns should be added.    Depending on how many items have been moved out of the loop, it    will either be before INSN (when WHERE_INSN is nonzero) or at the    start of the loop (when WHERE_INSN is zero).  */
end_comment

begin_function
specifier|static
name|int
name|maybe_eliminate_biv_1
parameter_list|(
name|loop
parameter_list|,
name|x
parameter_list|,
name|insn
parameter_list|,
name|bl
parameter_list|,
name|eliminate_p
parameter_list|,
name|where_bb
parameter_list|,
name|where_insn
parameter_list|)
specifier|const
name|struct
name|loop
modifier|*
name|loop
decl_stmt|;
name|rtx
name|x
decl_stmt|,
name|insn
decl_stmt|;
name|struct
name|iv_class
modifier|*
name|bl
decl_stmt|;
name|int
name|eliminate_p
decl_stmt|;
name|basic_block
name|where_bb
decl_stmt|;
name|rtx
name|where_insn
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|rtx
name|reg
init|=
name|bl
operator|->
name|biv
operator|->
name|dest_reg
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|reg
argument_list|)
decl_stmt|;
name|struct
name|induction
modifier|*
name|v
decl_stmt|;
name|rtx
name|arg
decl_stmt|,
name|tem
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_cc0
name|rtx
name|new
decl_stmt|;
endif|#
directive|endif
name|int
name|arg_operand
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|REG
case|:
comment|/* If we haven't already been able to do something with this BIV, 	 we can't eliminate it.  */
if|if
condition|(
name|x
operator|==
name|reg
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
case|case
name|SET
case|:
comment|/* If this sets the BIV, it is not a problem.  */
if|if
condition|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
operator|==
name|reg
condition|)
return|return
literal|1
return|;
comment|/* If this is an insn that defines a giv, it is also ok because 	 it will go away when the giv is reduced.  */
for|for
control|(
name|v
operator|=
name|bl
operator|->
name|giv
init|;
name|v
condition|;
name|v
operator|=
name|v
operator|->
name|next_iv
control|)
if|if
condition|(
name|v
operator|->
name|giv_type
operator|==
name|DEST_REG
operator|&&
name|SET_DEST
argument_list|(
name|x
argument_list|)
operator|==
name|v
operator|->
name|dest_reg
condition|)
return|return
literal|1
return|;
ifdef|#
directive|ifdef
name|HAVE_cc0
if|if
condition|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
operator|==
name|cc0_rtx
operator|&&
name|SET_SRC
argument_list|(
name|x
argument_list|)
operator|==
name|reg
condition|)
block|{
comment|/* Can replace with any giv that was reduced and 	     that has (MULT_VAL != 0) and (ADD_VAL == 0). 	     Require a constant for MULT_VAL, so we know it's nonzero. 	     ??? We disable this optimization to avoid potential 	     overflows.  */
for|for
control|(
name|v
operator|=
name|bl
operator|->
name|giv
init|;
name|v
condition|;
name|v
operator|=
name|v
operator|->
name|next_iv
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|v
operator|->
name|mult_val
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|v
operator|->
name|mult_val
operator|!=
name|const0_rtx
operator|&&
name|v
operator|->
name|add_val
operator|==
name|const0_rtx
operator|&&
operator|!
name|v
operator|->
name|ignore
operator|&&
operator|!
name|v
operator|->
name|maybe_dead
operator|&&
name|v
operator|->
name|always_computable
operator|&&
name|v
operator|->
name|mode
operator|==
name|mode
operator|&&
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|biv_elimination_giv_has_0_offset
argument_list|(
name|bl
operator|->
name|biv
argument_list|,
name|v
argument_list|,
name|insn
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|eliminate_p
condition|)
return|return
literal|1
return|;
comment|/* If the giv has the opposite direction of change, 		   then reverse the comparison.  */
if|if
condition|(
name|INTVAL
argument_list|(
name|v
operator|->
name|mult_val
argument_list|)
operator|<
literal|0
condition|)
name|new
operator|=
name|gen_rtx_COMPARE
argument_list|(
name|GET_MODE
argument_list|(
name|v
operator|->
name|new_reg
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
name|v
operator|->
name|new_reg
argument_list|)
expr_stmt|;
else|else
name|new
operator|=
name|v
operator|->
name|new_reg
expr_stmt|;
comment|/* We can probably test that giv's reduced reg.  */
if|if
condition|(
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|new
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
comment|/* Look for a giv with (MULT_VAL != 0) and (ADD_VAL != 0); 	     replace test insn with a compare insn (cmp REDUCED_GIV ADD_VAL). 	     Require a constant for MULT_VAL, so we know it's nonzero. 	     ??? Do this only if ADD_VAL is a pointer to avoid a potential 	     overflow problem.  */
for|for
control|(
name|v
operator|=
name|bl
operator|->
name|giv
init|;
name|v
condition|;
name|v
operator|=
name|v
operator|->
name|next_iv
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|v
operator|->
name|mult_val
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|v
operator|->
name|mult_val
operator|!=
name|const0_rtx
operator|&&
operator|!
name|v
operator|->
name|ignore
operator|&&
operator|!
name|v
operator|->
name|maybe_dead
operator|&&
name|v
operator|->
name|always_computable
operator|&&
name|v
operator|->
name|mode
operator|==
name|mode
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|v
operator|->
name|add_val
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|v
operator|->
name|add_val
argument_list|)
operator|==
name|LABEL_REF
operator|||
name|GET_CODE
argument_list|(
name|v
operator|->
name|add_val
argument_list|)
operator|==
name|CONST
operator|||
operator|(
name|GET_CODE
argument_list|(
name|v
operator|->
name|add_val
argument_list|)
operator|==
name|REG
operator|&&
name|REG_POINTER
argument_list|(
name|v
operator|->
name|add_val
argument_list|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|biv_elimination_giv_has_0_offset
argument_list|(
name|bl
operator|->
name|biv
argument_list|,
name|v
argument_list|,
name|insn
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|eliminate_p
condition|)
return|return
literal|1
return|;
comment|/* If the giv has the opposite direction of change, 		   then reverse the comparison.  */
if|if
condition|(
name|INTVAL
argument_list|(
name|v
operator|->
name|mult_val
argument_list|)
operator|<
literal|0
condition|)
name|new
operator|=
name|gen_rtx_COMPARE
argument_list|(
name|VOIDmode
argument_list|,
name|copy_rtx
argument_list|(
name|v
operator|->
name|add_val
argument_list|)
argument_list|,
name|v
operator|->
name|new_reg
argument_list|)
expr_stmt|;
else|else
name|new
operator|=
name|gen_rtx_COMPARE
argument_list|(
name|VOIDmode
argument_list|,
name|v
operator|->
name|new_reg
argument_list|,
name|copy_rtx
argument_list|(
name|v
operator|->
name|add_val
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Replace biv with the giv's reduced register.  */
name|update_reg_last_use
argument_list|(
name|v
operator|->
name|add_val
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|,
name|new
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Insn doesn't support that constant or invariant.  Copy it 		   into a register (it will be a loop invariant.)  */
name|tem
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|v
operator|->
name|new_reg
argument_list|)
argument_list|)
expr_stmt|;
name|loop_insn_emit_before
argument_list|(
name|loop
argument_list|,
literal|0
argument_list|,
name|where_insn
argument_list|,
name|gen_move_insn
argument_list|(
name|tem
argument_list|,
name|copy_rtx
argument_list|(
name|v
operator|->
name|add_val
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Substitute the new register for its invariant value in 		   the compare expression.  */
name|XEXP
argument_list|(
name|new
argument_list|,
operator|(
name|INTVAL
argument_list|(
name|v
operator|->
name|mult_val
argument_list|)
operator|<
literal|0
operator|)
condition|?
literal|0
else|:
literal|1
argument_list|)
operator|=
name|tem
expr_stmt|;
if|if
condition|(
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|,
name|new
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
block|}
endif|#
directive|endif
break|break;
case|case
name|COMPARE
case|:
case|case
name|EQ
case|:
case|case
name|NE
case|:
case|case
name|GT
case|:
case|case
name|GE
case|:
case|case
name|GTU
case|:
case|case
name|GEU
case|:
case|case
name|LT
case|:
case|case
name|LE
case|:
case|case
name|LTU
case|:
case|case
name|LEU
case|:
comment|/* See if either argument is the biv.  */
if|if
condition|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|reg
condition|)
name|arg
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|,
name|arg_operand
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|==
name|reg
condition|)
name|arg
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|,
name|arg_operand
operator|=
literal|0
expr_stmt|;
else|else
break|break;
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|arg
argument_list|)
condition|)
block|{
comment|/* First try to replace with any giv that has constant positive 	     mult_val and constant add_val.  We might be able to support 	     negative mult_val, but it seems complex to do it in general.  */
for|for
control|(
name|v
operator|=
name|bl
operator|->
name|giv
init|;
name|v
condition|;
name|v
operator|=
name|v
operator|->
name|next_iv
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|v
operator|->
name|mult_val
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|v
operator|->
name|mult_val
argument_list|)
operator|>
literal|0
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|v
operator|->
name|add_val
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|v
operator|->
name|add_val
argument_list|)
operator|==
name|LABEL_REF
operator|||
name|GET_CODE
argument_list|(
name|v
operator|->
name|add_val
argument_list|)
operator|==
name|CONST
operator|||
operator|(
name|GET_CODE
argument_list|(
name|v
operator|->
name|add_val
argument_list|)
operator|==
name|REG
operator|&&
name|REG_POINTER
argument_list|(
name|v
operator|->
name|add_val
argument_list|)
operator|)
operator|)
operator|&&
operator|!
name|v
operator|->
name|ignore
operator|&&
operator|!
name|v
operator|->
name|maybe_dead
operator|&&
name|v
operator|->
name|always_computable
operator|&&
name|v
operator|->
name|mode
operator|==
name|mode
condition|)
block|{
if|if
condition|(
operator|!
name|biv_elimination_giv_has_0_offset
argument_list|(
name|bl
operator|->
name|biv
argument_list|,
name|v
argument_list|,
name|insn
argument_list|)
condition|)
continue|continue;
comment|/* Don't eliminate if the linear combination that makes up 		   the giv overflows when it is applied to ARG.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|rtx
name|add_val
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|v
operator|->
name|add_val
argument_list|)
operator|==
name|CONST_INT
condition|)
name|add_val
operator|=
name|v
operator|->
name|add_val
expr_stmt|;
else|else
name|add_val
operator|=
name|const0_rtx
expr_stmt|;
if|if
condition|(
name|const_mult_add_overflow_p
argument_list|(
name|arg
argument_list|,
name|v
operator|->
name|mult_val
argument_list|,
name|add_val
argument_list|,
name|mode
argument_list|,
literal|1
argument_list|)
condition|)
continue|continue;
block|}
if|if
condition|(
operator|!
name|eliminate_p
condition|)
return|return
literal|1
return|;
comment|/* Replace biv with the giv's reduced reg.  */
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
operator|-
name|arg_operand
argument_list|)
argument_list|,
name|v
operator|->
name|new_reg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* If all constants are actually constant integers and 		   the derived constant can be directly placed in the COMPARE, 		   do so.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|v
operator|->
name|add_val
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|tem
operator|=
name|expand_mult_add
argument_list|(
name|arg
argument_list|,
name|NULL_RTX
argument_list|,
name|v
operator|->
name|mult_val
argument_list|,
name|v
operator|->
name|add_val
argument_list|,
name|mode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Otherwise, load it into a register.  */
name|tem
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|loop_iv_add_mult_emit_before
argument_list|(
name|loop
argument_list|,
name|arg
argument_list|,
name|v
operator|->
name|mult_val
argument_list|,
name|v
operator|->
name|add_val
argument_list|,
name|tem
argument_list|,
name|where_bb
argument_list|,
name|where_insn
argument_list|)
expr_stmt|;
block|}
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
name|arg_operand
argument_list|)
argument_list|,
name|tem
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|apply_change_group
argument_list|()
condition|)
return|return
literal|1
return|;
block|}
comment|/* Look for giv with positive constant mult_val and nonconst add_val. 	     Insert insns to calculate new compare value. 	     ??? Turn this off due to possible overflow.  */
for|for
control|(
name|v
operator|=
name|bl
operator|->
name|giv
init|;
name|v
condition|;
name|v
operator|=
name|v
operator|->
name|next_iv
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|v
operator|->
name|mult_val
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|v
operator|->
name|mult_val
argument_list|)
operator|>
literal|0
operator|&&
operator|!
name|v
operator|->
name|ignore
operator|&&
operator|!
name|v
operator|->
name|maybe_dead
operator|&&
name|v
operator|->
name|always_computable
operator|&&
name|v
operator|->
name|mode
operator|==
name|mode
operator|&&
literal|0
condition|)
block|{
name|rtx
name|tem
decl_stmt|;
if|if
condition|(
operator|!
name|biv_elimination_giv_has_0_offset
argument_list|(
name|bl
operator|->
name|biv
argument_list|,
name|v
argument_list|,
name|insn
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|eliminate_p
condition|)
return|return
literal|1
return|;
name|tem
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
comment|/* Replace biv with giv's reduced register.  */
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
operator|-
name|arg_operand
argument_list|)
argument_list|,
name|v
operator|->
name|new_reg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Compute value to compare against.  */
name|loop_iv_add_mult_emit_before
argument_list|(
name|loop
argument_list|,
name|arg
argument_list|,
name|v
operator|->
name|mult_val
argument_list|,
name|v
operator|->
name|add_val
argument_list|,
name|tem
argument_list|,
name|where_bb
argument_list|,
name|where_insn
argument_list|)
expr_stmt|;
comment|/* Use it in this insn.  */
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
name|arg_operand
argument_list|)
argument_list|,
name|tem
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|apply_change_group
argument_list|()
condition|)
return|return
literal|1
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|MEM
condition|)
block|{
if|if
condition|(
name|loop_invariant_p
argument_list|(
name|loop
argument_list|,
name|arg
argument_list|)
operator|==
literal|1
condition|)
block|{
comment|/* Look for giv with constant positive mult_val and nonconst 		 add_val. Insert insns to compute new compare value. 		 ??? Turn this off due to possible overflow.  */
for|for
control|(
name|v
operator|=
name|bl
operator|->
name|giv
init|;
name|v
condition|;
name|v
operator|=
name|v
operator|->
name|next_iv
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|v
operator|->
name|mult_val
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|v
operator|->
name|mult_val
argument_list|)
operator|>
literal|0
operator|&&
operator|!
name|v
operator|->
name|ignore
operator|&&
operator|!
name|v
operator|->
name|maybe_dead
operator|&&
name|v
operator|->
name|always_computable
operator|&&
name|v
operator|->
name|mode
operator|==
name|mode
operator|&&
literal|0
condition|)
block|{
name|rtx
name|tem
decl_stmt|;
if|if
condition|(
operator|!
name|biv_elimination_giv_has_0_offset
argument_list|(
name|bl
operator|->
name|biv
argument_list|,
name|v
argument_list|,
name|insn
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|eliminate_p
condition|)
return|return
literal|1
return|;
name|tem
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
comment|/* Replace biv with giv's reduced register.  */
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
operator|-
name|arg_operand
argument_list|)
argument_list|,
name|v
operator|->
name|new_reg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Compute value to compare against.  */
name|loop_iv_add_mult_emit_before
argument_list|(
name|loop
argument_list|,
name|arg
argument_list|,
name|v
operator|->
name|mult_val
argument_list|,
name|v
operator|->
name|add_val
argument_list|,
name|tem
argument_list|,
name|where_bb
argument_list|,
name|where_insn
argument_list|)
expr_stmt|;
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
name|arg_operand
argument_list|)
argument_list|,
name|tem
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|apply_change_group
argument_list|()
condition|)
return|return
literal|1
return|;
block|}
block|}
comment|/* This code has problems.  Basically, you can't know when 	     seeing if we will eliminate BL, whether a particular giv 	     of ARG will be reduced.  If it isn't going to be reduced, 	     we can't eliminate BL.  We can try forcing it to be reduced, 	     but that can generate poor code.  	     The problem is that the benefit of reducing TV, below should 	     be increased if BL can actually be eliminated, but this means 	     we might have to do a topological sort of the order in which 	     we try to process biv.  It doesn't seem worthwhile to do 	     this sort of thing now.  */
if|#
directive|if
literal|0
comment|/* Otherwise the reg compared with had better be a biv.  */
block|if (GET_CODE (arg) != REG 	      || REG_IV_TYPE (ivs, REGNO (arg)) != BASIC_INDUCT) 	    return 0;
comment|/* Look for a pair of givs, one for each biv, 	     with identical coefficients.  */
block|for (v = bl->giv; v; v = v->next_iv) 	    { 	      struct induction *tv;  	      if (v->ignore || v->maybe_dead || v->mode != mode) 		continue;  	      for (tv = REG_IV_CLASS (ivs, REGNO (arg))->giv; tv; 		   tv = tv->next_iv) 		if (! tv->ignore&& ! tv->maybe_dead&& rtx_equal_p (tv->mult_val, v->mult_val)&& rtx_equal_p (tv->add_val, v->add_val)&& tv->mode == mode) 		  { 		    if (! biv_elimination_giv_has_0_offset (bl->biv, v, insn)) 		      continue;  		    if (! eliminate_p) 		      return 1;
comment|/* Replace biv with its giv's reduced reg.  */
block|XEXP (x, 1 - arg_operand) = v->new_reg;
comment|/* Replace other operand with the other giv's 		       reduced reg.  */
block|XEXP (x, arg_operand) = tv->new_reg; 		    return 1; 		  } 	    }
endif|#
directive|endif
block|}
comment|/* If we get here, the biv can't be eliminated.  */
return|return
literal|0
return|;
case|case
name|MEM
case|:
comment|/* If this address is a DEST_ADDR giv, it doesn't matter if the 	 biv is used in it, since it will be replaced.  */
for|for
control|(
name|v
operator|=
name|bl
operator|->
name|giv
init|;
name|v
condition|;
name|v
operator|=
name|v
operator|->
name|next_iv
control|)
if|if
condition|(
name|v
operator|->
name|giv_type
operator|==
name|DEST_ADDR
operator|&&
name|v
operator|->
name|location
operator|==
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|1
return|;
break|break;
default|default:
break|break;
block|}
comment|/* See if any subexpression fails elimination.  */
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
switch|switch
condition|(
name|fmt
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'e'
case|:
if|if
condition|(
operator|!
name|maybe_eliminate_biv_1
argument_list|(
name|loop
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|insn
argument_list|,
name|bl
argument_list|,
name|eliminate_p
argument_list|,
name|where_bb
argument_list|,
name|where_insn
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'E'
case|:
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
operator|!
name|maybe_eliminate_biv_1
argument_list|(
name|loop
argument_list|,
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|insn
argument_list|,
name|bl
argument_list|,
name|eliminate_p
argument_list|,
name|where_bb
argument_list|,
name|where_insn
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return nonzero if the last use of REG    is in an insn following INSN in the same basic block.  */
end_comment

begin_function
specifier|static
name|int
name|last_use_this_basic_block
parameter_list|(
name|reg
parameter_list|,
name|insn
parameter_list|)
name|rtx
name|reg
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
name|rtx
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
name|insn
init|;
name|n
operator|&&
name|GET_CODE
argument_list|(
name|n
argument_list|)
operator|!=
name|CODE_LABEL
operator|&&
name|GET_CODE
argument_list|(
name|n
argument_list|)
operator|!=
name|JUMP_INSN
condition|;
name|n
operator|=
name|NEXT_INSN
argument_list|(
name|n
argument_list|)
control|)
block|{
if|if
condition|(
name|REGNO_LAST_UID
argument_list|(
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|)
operator|==
name|INSN_UID
argument_list|(
name|n
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Called via `note_stores' to record the initial value of a biv.  Here we    just record the location of the set and process it later.  */
end_comment

begin_function
specifier|static
name|void
name|record_initial
parameter_list|(
name|dest
parameter_list|,
name|set
parameter_list|,
name|data
parameter_list|)
name|rtx
name|dest
decl_stmt|;
name|rtx
name|set
decl_stmt|;
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|struct
name|loop_ivs
modifier|*
name|ivs
init|=
operator|(
expr|struct
name|loop_ivs
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|iv_class
modifier|*
name|bl
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO
argument_list|(
name|dest
argument_list|)
operator|>=
name|ivs
operator|->
name|n_regs
operator|||
name|REG_IV_TYPE
argument_list|(
name|ivs
argument_list|,
name|REGNO
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|!=
name|BASIC_INDUCT
condition|)
return|return;
name|bl
operator|=
name|REG_IV_CLASS
argument_list|(
name|ivs
argument_list|,
name|REGNO
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If this is the first set found, record it.  */
if|if
condition|(
name|bl
operator|->
name|init_insn
operator|==
literal|0
condition|)
block|{
name|bl
operator|->
name|init_insn
operator|=
name|note_insn
expr_stmt|;
name|bl
operator|->
name|init_set
operator|=
name|set
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If any of the registers in X are "old" and currently have a last use earlier    than INSN, update them to have a last use of INSN.  Their actual last use    will be the previous insn but it will not have a valid uid_luid so we can't    use it.  X must be a source expression only.  */
end_comment

begin_function
specifier|static
name|void
name|update_reg_last_use
parameter_list|(
name|x
parameter_list|,
name|insn
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
comment|/* Check for the case where INSN does not have a valid luid.  In this case,      there is no need to modify the regno_last_uid, as this can only happen      when code is inserted after the loop_end to set a pseudo's final value,      and hence this insn will never be the last use of x.      ???? This comment is not correct.  See for example loop_givs_reduce.      This may insert an insn before another new insn.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|x
argument_list|)
operator|<
name|max_reg_before_loop
operator|&&
name|INSN_UID
argument_list|(
name|insn
argument_list|)
operator|<
name|max_uid_for_loop
operator|&&
name|REGNO_LAST_LUID
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
operator|<
name|INSN_LUID
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|REGNO_LAST_UID
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
operator|=
name|INSN_UID
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
init|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|update_reg_last_use
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
name|update_reg_last_use
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given an insn INSN and condition COND, return the condition in a    canonical form to simplify testing by callers.  Specifically:     (1) The code will always be a comparison operation (EQ, NE, GT, etc.).    (2) Both operands will be machine operands; (cc0) will have been replaced.    (3) If an operand is a constant, it will be the second operand.    (4) (LE x const) will be replaced with (LT x<const+1>) and similarly        for GE, GEU, and LEU.     If the condition cannot be understood, or is an inequality floating-point    comparison which needs to be reversed, 0 will be returned.     If REVERSE is nonzero, then reverse the condition prior to canonizing it.     If EARLIEST is nonzero, it is a pointer to a place where the earliest    insn used in locating the condition was found.  If a replacement test    of the condition is desired, it should be placed in front of that    insn and we will be sure that the inputs are still valid.     If WANT_REG is nonzero, we wish the condition to be relative to that    register, if possible.  Therefore, do not canonicalize the condition    further.  */
end_comment

begin_function
name|rtx
name|canonicalize_condition
parameter_list|(
name|insn
parameter_list|,
name|cond
parameter_list|,
name|reverse
parameter_list|,
name|earliest
parameter_list|,
name|want_reg
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|rtx
name|cond
decl_stmt|;
name|int
name|reverse
decl_stmt|;
name|rtx
modifier|*
name|earliest
decl_stmt|;
name|rtx
name|want_reg
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
decl_stmt|;
name|rtx
name|prev
init|=
name|insn
decl_stmt|;
name|rtx
name|set
decl_stmt|;
name|rtx
name|tem
decl_stmt|;
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|;
name|int
name|reverse_code
init|=
literal|0
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|cond
argument_list|)
expr_stmt|;
name|mode
operator|=
name|GET_MODE
argument_list|(
name|cond
argument_list|)
expr_stmt|;
name|op0
operator|=
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|reverse
condition|)
name|code
operator|=
name|reversed_comparison_code
argument_list|(
name|cond
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|UNKNOWN
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|earliest
condition|)
operator|*
name|earliest
operator|=
name|insn
expr_stmt|;
comment|/* If we are comparing a register with zero, see if the register is set      in the previous insn to a COMPARE or a comparison operation.  Perform      the same tests as a function of STORE_FLAG_VALUE as find_comparison_args      in cse.c  */
while|while
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'<'
operator|&&
name|op1
operator|==
name|CONST0_RTX
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|&&
name|op0
operator|!=
name|want_reg
condition|)
block|{
comment|/* Set nonzero when we find something of interest.  */
name|rtx
name|x
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_cc0
comment|/* If comparison with cc0, import actual comparison from compare 	 insn.  */
if|if
condition|(
name|op0
operator|==
name|cc0_rtx
condition|)
block|{
if|if
condition|(
operator|(
name|prev
operator|=
name|prev_nonnote_insn
argument_list|(
name|prev
argument_list|)
operator|)
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|prev
argument_list|)
operator|!=
name|INSN
operator|||
operator|(
name|set
operator|=
name|single_set
argument_list|(
name|prev
argument_list|)
operator|)
operator|==
literal|0
operator|||
name|SET_DEST
argument_list|(
name|set
argument_list|)
operator|!=
name|cc0_rtx
condition|)
return|return
literal|0
return|;
name|op0
operator|=
name|SET_SRC
argument_list|(
name|set
argument_list|)
expr_stmt|;
name|op1
operator|=
name|CONST0_RTX
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|earliest
condition|)
operator|*
name|earliest
operator|=
name|prev
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* If this is a COMPARE, pick up the two things being compared.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|COMPARE
condition|)
block|{
name|op1
operator|=
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|op0
operator|=
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|REG
condition|)
break|break;
comment|/* Go back to the previous insn.  Stop if it is not an INSN.  We also 	 stop if it isn't a single set or if it has a REG_INC note because 	 we don't want to bother dealing with it.  */
if|if
condition|(
operator|(
name|prev
operator|=
name|prev_nonnote_insn
argument_list|(
name|prev
argument_list|)
operator|)
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|prev
argument_list|)
operator|!=
name|INSN
operator|||
name|FIND_REG_INC_NOTE
argument_list|(
name|prev
argument_list|,
name|NULL_RTX
argument_list|)
condition|)
break|break;
name|set
operator|=
name|set_of
argument_list|(
name|op0
argument_list|,
name|prev
argument_list|)
expr_stmt|;
if|if
condition|(
name|set
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|set
argument_list|)
operator|!=
name|SET
operator|||
operator|!
name|rtx_equal_p
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|,
name|op0
argument_list|)
operator|)
condition|)
break|break;
comment|/* If this is setting OP0, get what it sets it to if it looks 	 relevant.  */
if|if
condition|(
name|set
condition|)
block|{
name|enum
name|machine_mode
name|inner_mode
init|=
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|FLOAT_STORE_FLAG_VALUE
name|REAL_VALUE_TYPE
name|fsfv
decl_stmt|;
endif|#
directive|endif
comment|/* ??? We may not combine comparisons done in a CCmode with 	     comparisons not done in a CCmode.  This is to aid targets 	     like Alpha that have an IEEE compliant EQ instruction, and 	     a non-IEEE compliant BEQ instruction.  The use of CCmode is 	     actually artificial, simply to prevent the combination, but 	     should not affect other platforms.  	     However, we must allow VOIDmode comparisons to match either 	     CCmode or non-CCmode comparison, because some ports have 	     modeless comparisons inside branch patterns.  	     ??? This mode check should perhaps look more like the mode check 	     in simplify_comparison in combine.  */
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|COMPARE
operator|||
operator|(
operator|(
operator|(
name|code
operator|==
name|NE
operator|||
operator|(
name|code
operator|==
name|LT
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|inner_mode
argument_list|)
operator|==
name|MODE_INT
operator|&&
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|inner_mode
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|)
operator|&&
operator|(
name|STORE_FLAG_VALUE
operator|&
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|inner_mode
argument_list|)
operator|-
literal|1
operator|)
operator|)
operator|)
operator|)
ifdef|#
directive|ifdef
name|FLOAT_STORE_FLAG_VALUE
operator|||
operator|(
name|code
operator|==
name|LT
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|inner_mode
argument_list|)
operator|==
name|MODE_FLOAT
operator|&&
operator|(
name|fsfv
operator|=
name|FLOAT_STORE_FLAG_VALUE
argument_list|(
name|inner_mode
argument_list|)
operator|,
name|REAL_VALUE_NEGATIVE
argument_list|(
name|fsfv
argument_list|)
operator|)
operator|)
endif|#
directive|endif
operator|)
operator|)
operator|&&
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|'<'
operator|)
operator|)
operator|&&
operator|(
operator|(
operator|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_CC
operator|)
operator|==
operator|(
name|GET_MODE_CLASS
argument_list|(
name|inner_mode
argument_list|)
operator|==
name|MODE_CC
operator|)
operator|)
operator|||
name|mode
operator|==
name|VOIDmode
operator|||
name|inner_mode
operator|==
name|VOIDmode
operator|)
condition|)
name|x
operator|=
name|SET_SRC
argument_list|(
name|set
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
operator|(
name|code
operator|==
name|EQ
operator|||
operator|(
name|code
operator|==
name|GE
operator|&&
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|inner_mode
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|)
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|inner_mode
argument_list|)
operator|==
name|MODE_INT
operator|&&
operator|(
name|STORE_FLAG_VALUE
operator|&
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|inner_mode
argument_list|)
operator|-
literal|1
operator|)
operator|)
operator|)
operator|)
ifdef|#
directive|ifdef
name|FLOAT_STORE_FLAG_VALUE
operator|||
operator|(
name|code
operator|==
name|GE
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|inner_mode
argument_list|)
operator|==
name|MODE_FLOAT
operator|&&
operator|(
name|fsfv
operator|=
name|FLOAT_STORE_FLAG_VALUE
argument_list|(
name|inner_mode
argument_list|)
operator|,
name|REAL_VALUE_NEGATIVE
argument_list|(
name|fsfv
argument_list|)
operator|)
operator|)
endif|#
directive|endif
operator|)
operator|)
operator|&&
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|'<'
operator|&&
operator|(
operator|(
operator|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_CC
operator|)
operator|==
operator|(
name|GET_MODE_CLASS
argument_list|(
name|inner_mode
argument_list|)
operator|==
name|MODE_CC
operator|)
operator|)
operator|||
name|mode
operator|==
name|VOIDmode
operator|||
name|inner_mode
operator|==
name|VOIDmode
operator|)
condition|)
block|{
name|reverse_code
operator|=
literal|1
expr_stmt|;
name|x
operator|=
name|SET_SRC
argument_list|(
name|set
argument_list|)
expr_stmt|;
block|}
else|else
break|break;
block|}
elseif|else
if|if
condition|(
name|reg_set_p
argument_list|(
name|op0
argument_list|,
name|prev
argument_list|)
condition|)
comment|/* If this sets OP0, but not directly, we have to give up.  */
break|break;
if|if
condition|(
name|x
condition|)
block|{
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
literal|'<'
condition|)
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|reverse_code
condition|)
block|{
name|code
operator|=
name|reversed_comparison_code
argument_list|(
name|x
argument_list|,
name|prev
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|UNKNOWN
condition|)
return|return
literal|0
return|;
name|reverse_code
operator|=
literal|0
expr_stmt|;
block|}
name|op0
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|,
name|op1
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|earliest
condition|)
operator|*
name|earliest
operator|=
name|prev
expr_stmt|;
block|}
block|}
comment|/* If constant is first, put it last.  */
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|op0
argument_list|)
condition|)
name|code
operator|=
name|swap_condition
argument_list|(
name|code
argument_list|)
operator|,
name|tem
operator|=
name|op0
operator|,
name|op0
operator|=
name|op1
operator|,
name|op1
operator|=
name|tem
expr_stmt|;
comment|/* If OP0 is the result of a comparison, we weren't able to find what      was really being compared, so fail.  */
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|==
name|MODE_CC
condition|)
return|return
literal|0
return|;
comment|/* Canonicalize any ordered comparison with integers involving equality      if we can do computations in the relevant mode and we do not      overflow.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
name|HOST_WIDE_INT
name|const_val
init|=
name|INTVAL
argument_list|(
name|op1
argument_list|)
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|uconst_val
init|=
name|const_val
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|max_val
init|=
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|GET_MODE_MASK
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|LE
case|:
if|if
condition|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|const_val
operator|!=
name|max_val
operator|>>
literal|1
condition|)
name|code
operator|=
name|LT
operator|,
name|op1
operator|=
name|gen_int_mode
argument_list|(
name|const_val
operator|+
literal|1
argument_list|,
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
comment|/* When cross-compiling, const_val might be sign-extended from 	   BITS_PER_WORD to HOST_BITS_PER_WIDE_INT */
case|case
name|GE
case|:
if|if
condition|(
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
name|const_val
operator|&
name|max_val
argument_list|)
operator|!=
operator|(
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|-
literal|1
operator|)
operator|)
operator|)
condition|)
name|code
operator|=
name|GT
operator|,
name|op1
operator|=
name|gen_int_mode
argument_list|(
name|const_val
operator|-
literal|1
argument_list|,
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LEU
case|:
if|if
condition|(
name|uconst_val
operator|<
name|max_val
condition|)
name|code
operator|=
name|LTU
operator|,
name|op1
operator|=
name|gen_int_mode
argument_list|(
name|uconst_val
operator|+
literal|1
argument_list|,
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|GEU
case|:
if|if
condition|(
name|uconst_val
operator|!=
literal|0
condition|)
name|code
operator|=
name|GTU
operator|,
name|op1
operator|=
name|gen_int_mode
argument_list|(
name|uconst_val
operator|-
literal|1
argument_list|,
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
ifdef|#
directive|ifdef
name|HAVE_cc0
comment|/* Never return CC0; return zero instead.  */
if|if
condition|(
name|op0
operator|==
name|cc0_rtx
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
return|return
name|gen_rtx_fmt_ee
argument_list|(
name|code
argument_list|,
name|VOIDmode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Given a jump insn JUMP, return the condition that will cause it to branch    to its JUMP_LABEL.  If the condition cannot be understood, or is an    inequality floating-point comparison which needs to be reversed, 0 will    be returned.     If EARLIEST is nonzero, it is a pointer to a place where the earliest    insn used in locating the condition was found.  If a replacement test    of the condition is desired, it should be placed in front of that    insn and we will be sure that the inputs are still valid.  */
end_comment

begin_function
name|rtx
name|get_condition
parameter_list|(
name|jump
parameter_list|,
name|earliest
parameter_list|)
name|rtx
name|jump
decl_stmt|;
name|rtx
modifier|*
name|earliest
decl_stmt|;
block|{
name|rtx
name|cond
decl_stmt|;
name|int
name|reverse
decl_stmt|;
name|rtx
name|set
decl_stmt|;
comment|/* If this is not a standard conditional jump, we can't parse it.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|jump
argument_list|)
operator|!=
name|JUMP_INSN
operator|||
operator|!
name|any_condjump_p
argument_list|(
name|jump
argument_list|)
condition|)
return|return
literal|0
return|;
name|set
operator|=
name|pc_set
argument_list|(
name|jump
argument_list|)
expr_stmt|;
name|cond
operator|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If this branches to JUMP_LABEL when the condition is false, reverse      the condition.  */
name|reverse
operator|=
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|&&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|2
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|JUMP_LABEL
argument_list|(
name|jump
argument_list|)
expr_stmt|;
return|return
name|canonicalize_condition
argument_list|(
name|jump
argument_list|,
name|cond
argument_list|,
name|reverse
argument_list|,
name|earliest
argument_list|,
name|NULL_RTX
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Similar to above routine, except that we also put an invariant last    unless both operands are invariants.  */
end_comment

begin_function
name|rtx
name|get_condition_for_loop
parameter_list|(
name|loop
parameter_list|,
name|x
parameter_list|)
specifier|const
name|struct
name|loop
modifier|*
name|loop
decl_stmt|;
name|rtx
name|x
decl_stmt|;
block|{
name|rtx
name|comparison
init|=
name|get_condition
argument_list|(
name|x
argument_list|,
operator|(
name|rtx
operator|*
operator|)
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|comparison
operator|==
literal|0
operator|||
operator|!
name|loop_invariant_p
argument_list|(
name|loop
argument_list|,
name|XEXP
argument_list|(
name|comparison
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
name|loop_invariant_p
argument_list|(
name|loop
argument_list|,
name|XEXP
argument_list|(
name|comparison
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
return|return
name|comparison
return|;
return|return
name|gen_rtx_fmt_ee
argument_list|(
name|swap_condition
argument_list|(
name|GET_CODE
argument_list|(
name|comparison
argument_list|)
argument_list|)
argument_list|,
name|VOIDmode
argument_list|,
name|XEXP
argument_list|(
name|comparison
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|comparison
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Scan the function and determine whether it has indirect (computed) jumps.     This is taken mostly from flow.c; similar code exists elsewhere    in the compiler.  It may be useful to put this into rtlanal.c.  */
end_comment

begin_function
specifier|static
name|int
name|indirect_jump_in_function_p
parameter_list|(
name|start
parameter_list|)
name|rtx
name|start
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|start
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|computed_jump_p
argument_list|(
name|insn
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Add MEM to the LOOP_MEMS array, if appropriate.  See the    documentation for LOOP_MEMS for the definition of `appropriate'.    This function is called from prescan_loop via for_each_rtx.  */
end_comment

begin_function
specifier|static
name|int
name|insert_loop_mem
parameter_list|(
name|mem
parameter_list|,
name|data
parameter_list|)
name|rtx
modifier|*
name|mem
decl_stmt|;
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|struct
name|loop_info
modifier|*
name|loop_info
init|=
name|data
decl_stmt|;
name|int
name|i
decl_stmt|;
name|rtx
name|m
init|=
operator|*
name|mem
decl_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL_RTX
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|m
argument_list|)
condition|)
block|{
case|case
name|MEM
case|:
break|break;
case|case
name|CLOBBER
case|:
comment|/* We're not interested in MEMs that are only clobbered.  */
return|return
operator|-
literal|1
return|;
case|case
name|CONST_DOUBLE
case|:
comment|/* We're not interested in the MEM associated with a 	 CONST_DOUBLE, so there's no need to traverse into this.  */
return|return
operator|-
literal|1
return|;
case|case
name|EXPR_LIST
case|:
comment|/* We're not interested in any MEMs that only appear in notes.  */
return|return
operator|-
literal|1
return|;
default|default:
comment|/* This is not a MEM.  */
return|return
literal|0
return|;
block|}
comment|/* See if we've already seen this MEM.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|loop_info
operator|->
name|mems_idx
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|m
argument_list|,
name|loop_info
operator|->
name|mems
index|[
name|i
index|]
operator|.
name|mem
argument_list|)
condition|)
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|m
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|loop_info
operator|->
name|mems
index|[
name|i
index|]
operator|.
name|mem
argument_list|)
condition|)
comment|/* The modes of the two memory accesses are different.  If 	     this happens, something tricky is going on, and we just 	     don't optimize accesses to this MEM.  */
name|loop_info
operator|->
name|mems
index|[
name|i
index|]
operator|.
name|optimize
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Resize the array, if necessary.  */
if|if
condition|(
name|loop_info
operator|->
name|mems_idx
operator|==
name|loop_info
operator|->
name|mems_allocated
condition|)
block|{
if|if
condition|(
name|loop_info
operator|->
name|mems_allocated
operator|!=
literal|0
condition|)
name|loop_info
operator|->
name|mems_allocated
operator|*=
literal|2
expr_stmt|;
else|else
name|loop_info
operator|->
name|mems_allocated
operator|=
literal|32
expr_stmt|;
name|loop_info
operator|->
name|mems
operator|=
operator|(
name|loop_mem_info
operator|*
operator|)
name|xrealloc
argument_list|(
name|loop_info
operator|->
name|mems
argument_list|,
name|loop_info
operator|->
name|mems_allocated
operator|*
sizeof|sizeof
argument_list|(
name|loop_mem_info
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Actually insert the MEM.  */
name|loop_info
operator|->
name|mems
index|[
name|loop_info
operator|->
name|mems_idx
index|]
operator|.
name|mem
operator|=
name|m
expr_stmt|;
comment|/* We can't hoist this MEM out of the loop if it's a BLKmode MEM      because we can't put it in a register.  We still store it in the      table, though, so that if we see the same address later, but in a      non-BLK mode, we'll not think we can optimize it at that point.  */
name|loop_info
operator|->
name|mems
index|[
name|loop_info
operator|->
name|mems_idx
index|]
operator|.
name|optimize
operator|=
operator|(
name|GET_MODE
argument_list|(
name|m
argument_list|)
operator|!=
name|BLKmode
operator|)
expr_stmt|;
name|loop_info
operator|->
name|mems
index|[
name|loop_info
operator|->
name|mems_idx
index|]
operator|.
name|reg
operator|=
name|NULL_RTX
expr_stmt|;
operator|++
name|loop_info
operator|->
name|mems_idx
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Allocate REGS->ARRAY or reallocate it if it is too small.     Increment REGS->ARRAY[I].SET_IN_LOOP at the index I of each    register that is modified by an insn between FROM and TO.  If the    value of an element of REGS->array[I].SET_IN_LOOP becomes 127 or    more, stop incrementing it, to avoid overflow.     Store in REGS->ARRAY[I].SINGLE_USAGE the single insn in which    register I is used, if it is only used once.  Otherwise, it is set    to 0 (for no uses) or const0_rtx for more than one use.  This    parameter may be zero, in which case this processing is not done.     Set REGS->ARRAY[I].MAY_NOT_OPTIMIZE nonzero if we should not    optimize register I.  */
end_comment

begin_function
specifier|static
name|void
name|loop_regs_scan
parameter_list|(
name|loop
parameter_list|,
name|extra_size
parameter_list|)
specifier|const
name|struct
name|loop
modifier|*
name|loop
decl_stmt|;
name|int
name|extra_size
decl_stmt|;
block|{
name|struct
name|loop_regs
modifier|*
name|regs
init|=
name|LOOP_REGS
argument_list|(
name|loop
argument_list|)
decl_stmt|;
name|int
name|old_nregs
decl_stmt|;
comment|/* last_set[n] is nonzero iff reg n has been set in the current    basic block.  In that case, it is the insn that last set reg n.  */
name|rtx
modifier|*
name|last_set
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|int
name|i
decl_stmt|;
name|old_nregs
operator|=
name|regs
operator|->
name|num
expr_stmt|;
name|regs
operator|->
name|num
operator|=
name|max_reg_num
argument_list|()
expr_stmt|;
comment|/* Grow the regs array if not allocated or too small.  */
if|if
condition|(
name|regs
operator|->
name|num
operator|>=
name|regs
operator|->
name|size
condition|)
block|{
name|regs
operator|->
name|size
operator|=
name|regs
operator|->
name|num
operator|+
name|extra_size
expr_stmt|;
name|regs
operator|->
name|array
operator|=
operator|(
expr|struct
name|loop_reg
operator|*
operator|)
name|xrealloc
argument_list|(
name|regs
operator|->
name|array
argument_list|,
name|regs
operator|->
name|size
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|regs
operator|->
name|array
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Zero the new elements.  */
name|memset
argument_list|(
name|regs
operator|->
name|array
operator|+
name|old_nregs
argument_list|,
literal|0
argument_list|,
operator|(
name|regs
operator|->
name|size
operator|-
name|old_nregs
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|regs
operator|->
name|array
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Clear previously scanned fields but do not clear n_times_set.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|old_nregs
condition|;
name|i
operator|++
control|)
block|{
name|regs
operator|->
name|array
index|[
name|i
index|]
operator|.
name|set_in_loop
operator|=
literal|0
expr_stmt|;
name|regs
operator|->
name|array
index|[
name|i
index|]
operator|.
name|may_not_optimize
operator|=
literal|0
expr_stmt|;
name|regs
operator|->
name|array
index|[
name|i
index|]
operator|.
name|single_usage
operator|=
name|NULL_RTX
expr_stmt|;
block|}
name|last_set
operator|=
operator|(
name|rtx
operator|*
operator|)
name|xcalloc
argument_list|(
name|regs
operator|->
name|num
argument_list|,
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Scan the loop, recording register usage.  */
for|for
control|(
name|insn
operator|=
name|loop
operator|->
name|top
condition|?
name|loop
operator|->
name|top
else|:
name|loop
operator|->
name|start
init|;
name|insn
operator|!=
name|loop
operator|->
name|end
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
comment|/* Record registers that have exactly one use.  */
name|find_single_use_in_loop
argument_list|(
name|regs
argument_list|,
name|insn
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Include uses in REG_EQUAL notes.  */
if|if
condition|(
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
condition|)
name|find_single_use_in_loop
argument_list|(
name|regs
argument_list|,
name|insn
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|CLOBBER
condition|)
name|count_one_set
argument_list|(
name|regs
argument_list|,
name|insn
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|last_set
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|count_one_set
argument_list|(
name|regs
argument_list|,
name|insn
argument_list|,
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|last_set
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
name|memset
argument_list|(
name|last_set
argument_list|,
literal|0
argument_list|,
name|regs
operator|->
name|num
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Invalidate all registers used for function argument passing. 	 We check rtx_varies_p for the same reason as below, to allow 	 optimizing PIC calculations.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
name|rtx
name|link
decl_stmt|;
for|for
control|(
name|link
operator|=
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|rtx
name|op
decl_stmt|,
name|reg
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|USE
operator|&&
name|GET_CODE
argument_list|(
name|reg
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|rtx_varies_p
argument_list|(
name|reg
argument_list|,
literal|1
argument_list|)
condition|)
name|regs
operator|->
name|array
index|[
name|REGNO
argument_list|(
name|reg
argument_list|)
index|]
operator|.
name|may_not_optimize
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
comment|/* Invalidate all hard registers clobbered by calls.  With one exception:      a call-clobbered PIC register is still function-invariant for our      purposes, since we can hoist any PIC calculations out of the loop.      Thus the call to rtx_varies_p.  */
if|if
condition|(
name|LOOP_INFO
argument_list|(
name|loop
argument_list|)
operator|->
name|has_call
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|regs_invalidated_by_call
argument_list|,
name|i
argument_list|)
operator|&&
name|rtx_varies_p
argument_list|(
name|regno_reg_rtx
index|[
name|i
index|]
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|regs
operator|->
name|array
index|[
name|i
index|]
operator|.
name|may_not_optimize
operator|=
literal|1
expr_stmt|;
name|regs
operator|->
name|array
index|[
name|i
index|]
operator|.
name|set_in_loop
operator|=
literal|1
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|AVOID_CCMODE_COPIES
comment|/* Don't try to move insns which set CC registers if we should not      create CCmode register copies.  */
for|for
control|(
name|i
operator|=
name|regs
operator|->
name|num
operator|-
literal|1
init|;
name|i
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|regno_reg_rtx
index|[
name|i
index|]
argument_list|)
argument_list|)
operator|==
name|MODE_CC
condition|)
name|regs
operator|->
name|array
index|[
name|i
index|]
operator|.
name|may_not_optimize
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* Set regs->array[I].n_times_set for the new registers.  */
for|for
control|(
name|i
operator|=
name|old_nregs
init|;
name|i
operator|<
name|regs
operator|->
name|num
condition|;
name|i
operator|++
control|)
name|regs
operator|->
name|array
index|[
name|i
index|]
operator|.
name|n_times_set
operator|=
name|regs
operator|->
name|array
index|[
name|i
index|]
operator|.
name|set_in_loop
expr_stmt|;
name|free
argument_list|(
name|last_set
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns the number of real INSNs in the LOOP.  */
end_comment

begin_function
specifier|static
name|int
name|count_insns_in_loop
parameter_list|(
name|loop
parameter_list|)
specifier|const
name|struct
name|loop
modifier|*
name|loop
decl_stmt|;
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|loop
operator|->
name|top
condition|?
name|loop
operator|->
name|top
else|:
name|loop
operator|->
name|start
init|;
name|insn
operator|!=
name|loop
operator|->
name|end
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
operator|++
name|count
expr_stmt|;
return|return
name|count
return|;
block|}
end_function

begin_comment
comment|/* Move MEMs into registers for the duration of the loop.  */
end_comment

begin_function
specifier|static
name|void
name|load_mems
parameter_list|(
name|loop
parameter_list|)
specifier|const
name|struct
name|loop
modifier|*
name|loop
decl_stmt|;
block|{
name|struct
name|loop_info
modifier|*
name|loop_info
init|=
name|LOOP_INFO
argument_list|(
name|loop
argument_list|)
decl_stmt|;
name|struct
name|loop_regs
modifier|*
name|regs
init|=
name|LOOP_REGS
argument_list|(
name|loop
argument_list|)
decl_stmt|;
name|int
name|maybe_never
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|rtx
name|p
decl_stmt|,
name|prev_ebb_head
decl_stmt|;
name|rtx
name|label
init|=
name|NULL_RTX
decl_stmt|;
name|rtx
name|end_label
decl_stmt|;
comment|/* Nonzero if the next instruction may never be executed.  */
name|int
name|next_maybe_never
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|last_max_reg
init|=
name|max_reg_num
argument_list|()
decl_stmt|;
if|if
condition|(
name|loop_info
operator|->
name|mems_idx
operator|==
literal|0
condition|)
return|return;
comment|/* We cannot use next_label here because it skips over normal insns.  */
name|end_label
operator|=
name|next_nonnote_insn
argument_list|(
name|loop
operator|->
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|end_label
operator|&&
name|GET_CODE
argument_list|(
name|end_label
argument_list|)
operator|!=
name|CODE_LABEL
condition|)
name|end_label
operator|=
name|NULL_RTX
expr_stmt|;
comment|/* Check to see if it's possible that some instructions in the loop are      never executed.  Also check if there is a goto out of the loop other      than right after the end of the loop.  */
for|for
control|(
name|p
operator|=
name|next_insn_in_loop
argument_list|(
name|loop
argument_list|,
name|loop
operator|->
name|scan_start
argument_list|)
init|;
name|p
operator|!=
name|NULL_RTX
condition|;
name|p
operator|=
name|next_insn_in_loop
argument_list|(
name|loop
argument_list|,
name|p
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|CODE_LABEL
condition|)
name|maybe_never
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|JUMP_INSN
comment|/* If we enter the loop in the middle, and scan 		  around to the beginning, don't set maybe_never 		  for that.  This must be an unconditional jump, 		  otherwise the code at the top of the loop might 		  never be executed.  Unconditional jumps are 		  followed a by barrier then loop end.  */
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|JUMP_LABEL
argument_list|(
name|p
argument_list|)
operator|==
name|loop
operator|->
name|top
operator|&&
name|NEXT_INSN
argument_list|(
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
argument_list|)
operator|==
name|loop
operator|->
name|end
operator|&&
name|any_uncondjump_p
argument_list|(
name|p
argument_list|)
operator|)
condition|)
block|{
comment|/* If this is a jump outside of the loop but not right 	     after the end of the loop, we would have to emit new fixup 	     sequences for each such label.  */
if|if
condition|(
comment|/* If we can't tell where control might go when this 		 JUMP_INSN is executed, we must be conservative.  */
operator|!
name|JUMP_LABEL
argument_list|(
name|p
argument_list|)
operator|||
operator|(
name|JUMP_LABEL
argument_list|(
name|p
argument_list|)
operator|!=
name|end_label
operator|&&
operator|(
name|INSN_UID
argument_list|(
name|JUMP_LABEL
argument_list|(
name|p
argument_list|)
argument_list|)
operator|>=
name|max_uid_for_loop
operator|||
name|INSN_LUID
argument_list|(
name|JUMP_LABEL
argument_list|(
name|p
argument_list|)
argument_list|)
operator|<
name|INSN_LUID
argument_list|(
name|loop
operator|->
name|start
argument_list|)
operator|||
name|INSN_LUID
argument_list|(
name|JUMP_LABEL
argument_list|(
name|p
argument_list|)
argument_list|)
operator|>
name|INSN_LUID
argument_list|(
name|loop
operator|->
name|end
argument_list|)
operator|)
operator|)
condition|)
return|return;
if|if
condition|(
operator|!
name|any_condjump_p
argument_list|(
name|p
argument_list|)
condition|)
comment|/* Something complicated.  */
name|maybe_never
operator|=
literal|1
expr_stmt|;
else|else
comment|/* If there are any more instructions in the loop, they 	       might not be reached.  */
name|next_maybe_never
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|next_maybe_never
condition|)
name|maybe_never
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Find start of the extended basic block that enters the loop.  */
for|for
control|(
name|p
operator|=
name|loop
operator|->
name|start
init|;
name|PREV_INSN
argument_list|(
name|p
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|!=
name|CODE_LABEL
condition|;
name|p
operator|=
name|PREV_INSN
argument_list|(
name|p
argument_list|)
control|)
empty_stmt|;
name|prev_ebb_head
operator|=
name|p
expr_stmt|;
name|cselib_init
argument_list|()
expr_stmt|;
comment|/* Build table of mems that get set to constant values before the      loop.  */
for|for
control|(
init|;
name|p
operator|!=
name|loop
operator|->
name|start
condition|;
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
control|)
name|cselib_process_insn
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* Actually move the MEMs.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|loop_info
operator|->
name|mems_idx
condition|;
operator|++
name|i
control|)
block|{
name|regset_head
name|load_copies
decl_stmt|;
name|regset_head
name|store_copies
decl_stmt|;
name|int
name|written
init|=
literal|0
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
name|rtx
name|mem
init|=
name|loop_info
operator|->
name|mems
index|[
name|i
index|]
operator|.
name|mem
decl_stmt|;
name|rtx
name|mem_list_entry
decl_stmt|;
if|if
condition|(
name|MEM_VOLATILE_P
argument_list|(
name|mem
argument_list|)
operator|||
name|loop_invariant_p
argument_list|(
name|loop
argument_list|,
name|XEXP
argument_list|(
name|mem
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
literal|1
condition|)
comment|/* There's no telling whether or not MEM is modified.  */
name|loop_info
operator|->
name|mems
index|[
name|i
index|]
operator|.
name|optimize
operator|=
literal|0
expr_stmt|;
comment|/* Go through the MEMs written to in the loop to see if this 	 one is aliased by one of them.  */
name|mem_list_entry
operator|=
name|loop_info
operator|->
name|store_mems
expr_stmt|;
while|while
condition|(
name|mem_list_entry
condition|)
block|{
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|mem
argument_list|,
name|XEXP
argument_list|(
name|mem_list_entry
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|written
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|true_dependence
argument_list|(
name|XEXP
argument_list|(
name|mem_list_entry
argument_list|,
literal|0
argument_list|)
argument_list|,
name|VOIDmode
argument_list|,
name|mem
argument_list|,
name|rtx_varies_p
argument_list|)
condition|)
block|{
comment|/* MEM is indeed aliased by this store.  */
name|loop_info
operator|->
name|mems
index|[
name|i
index|]
operator|.
name|optimize
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|mem_list_entry
operator|=
name|XEXP
argument_list|(
name|mem_list_entry
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag_float_store
operator|&&
name|written
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|mem
argument_list|)
argument_list|)
operator|==
name|MODE_FLOAT
condition|)
name|loop_info
operator|->
name|mems
index|[
name|i
index|]
operator|.
name|optimize
operator|=
literal|0
expr_stmt|;
comment|/* If this MEM is written to, we must be sure that there 	 are no reads from another MEM that aliases this one.  */
if|if
condition|(
name|loop_info
operator|->
name|mems
index|[
name|i
index|]
operator|.
name|optimize
operator|&&
name|written
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|loop_info
operator|->
name|mems_idx
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
name|j
operator|==
name|i
condition|)
continue|continue;
elseif|else
if|if
condition|(
name|true_dependence
argument_list|(
name|mem
argument_list|,
name|VOIDmode
argument_list|,
name|loop_info
operator|->
name|mems
index|[
name|j
index|]
operator|.
name|mem
argument_list|,
name|rtx_varies_p
argument_list|)
condition|)
block|{
comment|/* It's not safe to hoist loop_info->mems[i] out of 		     the loop because writes to it might not be 		     seen by reads from loop_info->mems[j].  */
name|loop_info
operator|->
name|mems
index|[
name|i
index|]
operator|.
name|optimize
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|maybe_never
operator|&&
name|may_trap_p
argument_list|(
name|mem
argument_list|)
condition|)
comment|/* We can't access the MEM outside the loop; it might 	   cause a trap that wouldn't have happened otherwise.  */
name|loop_info
operator|->
name|mems
index|[
name|i
index|]
operator|.
name|optimize
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|loop_info
operator|->
name|mems
index|[
name|i
index|]
operator|.
name|optimize
condition|)
comment|/* We thought we were going to lift this MEM out of the 	   loop, but later discovered that we could not.  */
continue|continue;
name|INIT_REG_SET
argument_list|(
operator|&
name|load_copies
argument_list|)
expr_stmt|;
name|INIT_REG_SET
argument_list|(
operator|&
name|store_copies
argument_list|)
expr_stmt|;
comment|/* Allocate a pseudo for this MEM.  We set REG_USERVAR_P in 	 order to keep scan_loop from moving stores to this MEM 	 out of the loop just because this REG is neither a 	 user-variable nor used in the loop test.  */
name|reg
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|mem
argument_list|)
argument_list|)
expr_stmt|;
name|REG_USERVAR_P
argument_list|(
name|reg
argument_list|)
operator|=
literal|1
expr_stmt|;
name|loop_info
operator|->
name|mems
index|[
name|i
index|]
operator|.
name|reg
operator|=
name|reg
expr_stmt|;
comment|/* Now, replace all references to the MEM with the 	 corresponding pseudos.  */
name|maybe_never
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|next_insn_in_loop
argument_list|(
name|loop
argument_list|,
name|loop
operator|->
name|scan_start
argument_list|)
init|;
name|p
operator|!=
name|NULL_RTX
condition|;
name|p
operator|=
name|next_insn_in_loop
argument_list|(
name|loop
argument_list|,
name|p
argument_list|)
control|)
block|{
if|if
condition|(
name|INSN_P
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|rtx
name|set
decl_stmt|;
name|set
operator|=
name|single_set
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* See if this copies the mem into a register that isn't 		 modified afterwards.  We'll try to do copy propagation 		 a little further on.  */
if|if
condition|(
name|set
comment|/* @@@ This test is _way_ too conservative.  */
operator|&&
operator|!
name|maybe_never
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|<
name|last_max_reg
operator|&&
name|regs
operator|->
name|array
index|[
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
index|]
operator|.
name|n_times_set
operator|==
literal|1
operator|&&
name|rtx_equal_p
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
name|mem
argument_list|)
condition|)
name|SET_REGNO_REG_SET
argument_list|(
operator|&
name|load_copies
argument_list|,
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* See if this copies the mem from a register that isn't 		 modified afterwards.  We'll try to remove the 		 redundant copy later on by doing a little register 		 renaming and copy propagation.   This will help 		 to untangle things for the BIV detection code.  */
if|if
condition|(
name|set
operator|&&
operator|!
name|maybe_never
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|REGNO
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|<
name|last_max_reg
operator|&&
name|regs
operator|->
name|array
index|[
name|REGNO
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
index|]
operator|.
name|n_times_set
operator|==
literal|1
operator|&&
name|rtx_equal_p
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|,
name|mem
argument_list|)
condition|)
name|SET_REGNO_REG_SET
argument_list|(
operator|&
name|store_copies
argument_list|,
name|REGNO
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If this is a call which uses / clobbers this memory 		 location, we must not change the interface here.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|CALL_INSN
operator|&&
name|reg_mentioned_p
argument_list|(
name|loop_info
operator|->
name|mems
index|[
name|i
index|]
operator|.
name|mem
argument_list|,
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|p
argument_list|)
argument_list|)
condition|)
block|{
name|cancel_changes
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|loop_info
operator|->
name|mems
index|[
name|i
index|]
operator|.
name|optimize
operator|=
literal|0
expr_stmt|;
break|break;
block|}
else|else
comment|/* Replace the memory reference with the shadow register.  */
name|replace_loop_mems
argument_list|(
name|p
argument_list|,
name|loop_info
operator|->
name|mems
index|[
name|i
index|]
operator|.
name|mem
argument_list|,
name|loop_info
operator|->
name|mems
index|[
name|i
index|]
operator|.
name|reg
argument_list|,
name|written
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|CODE_LABEL
operator|||
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|JUMP_INSN
condition|)
name|maybe_never
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|loop_info
operator|->
name|mems
index|[
name|i
index|]
operator|.
name|optimize
condition|)
empty_stmt|;
comment|/* We found we couldn't do the replacement, so do nothing.  */
elseif|else
if|if
condition|(
operator|!
name|apply_change_group
argument_list|()
condition|)
comment|/* We couldn't replace all occurrences of the MEM.  */
name|loop_info
operator|->
name|mems
index|[
name|i
index|]
operator|.
name|optimize
operator|=
literal|0
expr_stmt|;
else|else
block|{
comment|/* Load the memory immediately before LOOP->START, which is 	     the NOTE_LOOP_BEG.  */
name|cselib_val
modifier|*
name|e
init|=
name|cselib_lookup
argument_list|(
name|mem
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|set
decl_stmt|;
name|rtx
name|best
init|=
name|mem
decl_stmt|;
name|int
name|j
decl_stmt|;
name|struct
name|elt_loc_list
modifier|*
name|const_equiv
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|e
condition|)
block|{
name|struct
name|elt_loc_list
modifier|*
name|equiv
decl_stmt|;
name|struct
name|elt_loc_list
modifier|*
name|best_equiv
init|=
literal|0
decl_stmt|;
for|for
control|(
name|equiv
operator|=
name|e
operator|->
name|locs
init|;
name|equiv
condition|;
name|equiv
operator|=
name|equiv
operator|->
name|next
control|)
block|{
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|equiv
operator|->
name|loc
argument_list|)
condition|)
name|const_equiv
operator|=
name|equiv
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|equiv
operator|->
name|loc
argument_list|)
operator|==
name|REG
comment|/* Extending hard register lifetimes causes crash 			      on SRC targets.  Doing so on non-SRC is 			      probably also not good idea, since we most 			      probably have pseudoregister equivalence as 			      well.  */
operator|&&
name|REGNO
argument_list|(
name|equiv
operator|->
name|loc
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
name|best_equiv
operator|=
name|equiv
expr_stmt|;
block|}
comment|/* Use the constant equivalence if that is cheap enough.  */
if|if
condition|(
operator|!
name|best_equiv
condition|)
name|best_equiv
operator|=
name|const_equiv
expr_stmt|;
elseif|else
if|if
condition|(
name|const_equiv
operator|&&
operator|(
name|rtx_cost
argument_list|(
name|const_equiv
operator|->
name|loc
argument_list|,
name|SET
argument_list|)
operator|<=
name|rtx_cost
argument_list|(
name|best_equiv
operator|->
name|loc
argument_list|,
name|SET
argument_list|)
operator|)
condition|)
block|{
name|best_equiv
operator|=
name|const_equiv
expr_stmt|;
name|const_equiv
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If best_equiv is nonzero, we know that MEM is set to a 		 constant or register before the loop.  We will use this 		 knowledge to initialize the shadow register with that 		 constant or reg rather than by loading from MEM.  */
if|if
condition|(
name|best_equiv
condition|)
name|best
operator|=
name|copy_rtx
argument_list|(
name|best_equiv
operator|->
name|loc
argument_list|)
expr_stmt|;
block|}
name|set
operator|=
name|gen_move_insn
argument_list|(
name|reg
argument_list|,
name|best
argument_list|)
expr_stmt|;
name|set
operator|=
name|loop_insn_hoist
argument_list|(
name|loop
argument_list|,
name|set
argument_list|)
expr_stmt|;
if|if
condition|(
name|REG_P
argument_list|(
name|best
argument_list|)
condition|)
block|{
for|for
control|(
name|p
operator|=
name|prev_ebb_head
init|;
name|p
operator|!=
name|loop
operator|->
name|start
condition|;
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
control|)
if|if
condition|(
name|REGNO_LAST_UID
argument_list|(
name|REGNO
argument_list|(
name|best
argument_list|)
argument_list|)
operator|==
name|INSN_UID
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|REGNO_LAST_UID
argument_list|(
name|REGNO
argument_list|(
name|best
argument_list|)
argument_list|)
operator|=
name|INSN_UID
argument_list|(
name|set
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|const_equiv
condition|)
name|set_unique_reg_note
argument_list|(
name|set
argument_list|,
name|REG_EQUAL
argument_list|,
name|copy_rtx
argument_list|(
name|const_equiv
operator|->
name|loc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|written
condition|)
block|{
if|if
condition|(
name|label
operator|==
name|NULL_RTX
condition|)
block|{
name|label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|emit_label_after
argument_list|(
name|label
argument_list|,
name|loop
operator|->
name|end
argument_list|)
expr_stmt|;
block|}
comment|/* Store the memory immediately after END, which is 		 the NOTE_LOOP_END.  */
name|set
operator|=
name|gen_move_insn
argument_list|(
name|copy_rtx
argument_list|(
name|mem
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|loop_insn_emit_after
argument_list|(
name|loop
argument_list|,
literal|0
argument_list|,
name|label
argument_list|,
name|set
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|loop_dump_stream
condition|)
block|{
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Hoisted regno %d %s from "
argument_list|,
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|,
operator|(
name|written
condition|?
literal|"r/w"
else|:
literal|"r/o"
operator|)
argument_list|)
expr_stmt|;
name|print_rtl
argument_list|(
name|loop_dump_stream
argument_list|,
name|mem
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|loop_dump_stream
argument_list|)
expr_stmt|;
block|}
comment|/* Attempt a bit of copy propagation.  This helps untangle the 	     data flow, and enables {basic,general}_induction_var to find 	     more bivs/givs.  */
name|EXECUTE_IF_SET_IN_REG_SET
argument_list|(
argument|&load_copies
argument_list|,
argument|FIRST_PSEUDO_REGISTER
argument_list|,
argument|j
argument_list|,
argument|{ 	       try_copy_prop (loop, reg, j); 	     }
argument_list|)
empty_stmt|;
name|CLEAR_REG_SET
argument_list|(
operator|&
name|load_copies
argument_list|)
expr_stmt|;
name|EXECUTE_IF_SET_IN_REG_SET
argument_list|(
argument|&store_copies
argument_list|,
argument|FIRST_PSEUDO_REGISTER
argument_list|,
argument|j
argument_list|,
argument|{ 	       try_swap_copy_prop (loop, reg, j); 	     }
argument_list|)
empty_stmt|;
name|CLEAR_REG_SET
argument_list|(
operator|&
name|store_copies
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|label
operator|!=
name|NULL_RTX
operator|&&
name|end_label
operator|!=
name|NULL_RTX
condition|)
block|{
comment|/* Now, we need to replace all references to the previous exit 	 label with the new one.  */
name|rtx_pair
name|rr
decl_stmt|;
name|rr
operator|.
name|r1
operator|=
name|end_label
expr_stmt|;
name|rr
operator|.
name|r2
operator|=
name|label
expr_stmt|;
for|for
control|(
name|p
operator|=
name|loop
operator|->
name|start
init|;
name|p
operator|!=
name|loop
operator|->
name|end
condition|;
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
control|)
block|{
name|for_each_rtx
argument_list|(
operator|&
name|p
argument_list|,
name|replace_label
argument_list|,
operator|&
name|rr
argument_list|)
expr_stmt|;
comment|/* If this is a JUMP_INSN, then we also need to fix the JUMP_LABEL 	     field.  This is not handled by for_each_rtx because it doesn't 	     handle unprinted ('0') fields.  We need to update JUMP_LABEL 	     because the immediately following unroll pass will use it. 	     replace_label would not work anyways, because that only handles 	     LABEL_REFs.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|JUMP_LABEL
argument_list|(
name|p
argument_list|)
operator|==
name|end_label
condition|)
name|JUMP_LABEL
argument_list|(
name|p
argument_list|)
operator|=
name|label
expr_stmt|;
block|}
block|}
name|cselib_finish
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* For communication between note_reg_stored and its caller.  */
end_comment

begin_struct
struct|struct
name|note_reg_stored_arg
block|{
name|int
name|set_seen
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Called via note_stores, record in SET_SEEN whether X, which is written,    is equal to ARG.  */
end_comment

begin_function
specifier|static
name|void
name|note_reg_stored
parameter_list|(
name|x
parameter_list|,
name|setter
parameter_list|,
name|arg
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|setter
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|struct
name|note_reg_stored_arg
modifier|*
name|t
init|=
operator|(
expr|struct
name|note_reg_stored_arg
operator|*
operator|)
name|arg
decl_stmt|;
if|if
condition|(
name|t
operator|->
name|reg
operator|==
name|x
condition|)
name|t
operator|->
name|set_seen
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Try to replace every occurrence of pseudo REGNO with REPLACEMENT.    There must be exactly one insn that sets this pseudo; it will be    deleted if all replacements succeed and we can prove that the register    is not used after the loop.  */
end_comment

begin_function
specifier|static
name|void
name|try_copy_prop
parameter_list|(
name|loop
parameter_list|,
name|replacement
parameter_list|,
name|regno
parameter_list|)
specifier|const
name|struct
name|loop
modifier|*
name|loop
decl_stmt|;
name|rtx
name|replacement
decl_stmt|;
name|unsigned
name|int
name|regno
decl_stmt|;
block|{
comment|/* This is the reg that we are copying from.  */
name|rtx
name|reg_rtx
init|=
name|regno_reg_rtx
index|[
name|regno
index|]
decl_stmt|;
name|rtx
name|init_insn
init|=
literal|0
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
comment|/* These help keep track of whether we replaced all uses of the reg.  */
name|int
name|replaced_last
init|=
literal|0
decl_stmt|;
name|int
name|store_is_first
init|=
literal|0
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|next_insn_in_loop
argument_list|(
name|loop
argument_list|,
name|loop
operator|->
name|scan_start
argument_list|)
init|;
name|insn
operator|!=
name|NULL_RTX
condition|;
name|insn
operator|=
name|next_insn_in_loop
argument_list|(
name|loop
argument_list|,
name|insn
argument_list|)
control|)
block|{
name|rtx
name|set
decl_stmt|;
comment|/* Only substitute within one extended basic block from the initializing          insn.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
operator|&&
name|init_insn
condition|)
break|break;
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
continue|continue;
comment|/* Is this the initializing insn?  */
name|set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|set
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|regno
condition|)
block|{
if|if
condition|(
name|init_insn
condition|)
name|abort
argument_list|()
expr_stmt|;
name|init_insn
operator|=
name|insn
expr_stmt|;
if|if
condition|(
name|REGNO_FIRST_UID
argument_list|(
name|regno
argument_list|)
operator|==
name|INSN_UID
argument_list|(
name|insn
argument_list|)
condition|)
name|store_is_first
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Only substitute after seeing the initializing insn.  */
if|if
condition|(
name|init_insn
operator|&&
name|insn
operator|!=
name|init_insn
condition|)
block|{
name|struct
name|note_reg_stored_arg
name|arg
decl_stmt|;
name|replace_loop_regs
argument_list|(
name|insn
argument_list|,
name|reg_rtx
argument_list|,
name|replacement
argument_list|)
expr_stmt|;
if|if
condition|(
name|REGNO_LAST_UID
argument_list|(
name|regno
argument_list|)
operator|==
name|INSN_UID
argument_list|(
name|insn
argument_list|)
condition|)
name|replaced_last
operator|=
literal|1
expr_stmt|;
comment|/* Stop replacing when REPLACEMENT is modified.  */
name|arg
operator|.
name|reg
operator|=
name|replacement
expr_stmt|;
name|arg
operator|.
name|set_seen
operator|=
literal|0
expr_stmt|;
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|note_reg_stored
argument_list|,
operator|&
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|.
name|set_seen
condition|)
block|{
name|rtx
name|note
init|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_EQUAL
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
comment|/* It is possible that we've turned previously valid REG_EQUAL to 	         invalid, as we change the REGNO to REPLACEMENT and unlike REGNO, 	         REPLACEMENT is modified, we get different meaning.  */
if|if
condition|(
name|note
operator|&&
name|reg_mentioned_p
argument_list|(
name|replacement
argument_list|,
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|remove_note
argument_list|(
name|insn
argument_list|,
name|note
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|init_insn
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|apply_change_group
argument_list|()
condition|)
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"  Replaced reg %d"
argument_list|,
name|regno
argument_list|)
expr_stmt|;
if|if
condition|(
name|store_is_first
operator|&&
name|replaced_last
condition|)
block|{
name|rtx
name|first
decl_stmt|;
name|rtx
name|retval_note
decl_stmt|;
comment|/* Assume we're just deleting INIT_INSN.  */
name|first
operator|=
name|init_insn
expr_stmt|;
comment|/* Look for REG_RETVAL note.  If we're deleting the end of 	     the libcall sequence, the whole sequence can go.  */
name|retval_note
operator|=
name|find_reg_note
argument_list|(
name|init_insn
argument_list|,
name|REG_RETVAL
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
comment|/* If we found a REG_RETVAL note, find the first instruction 	     in the sequence.  */
if|if
condition|(
name|retval_note
condition|)
name|first
operator|=
name|XEXP
argument_list|(
name|retval_note
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Delete the instructions.  */
name|loop_delete_insns
argument_list|(
name|first
argument_list|,
name|init_insn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|".\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Replace all the instructions from FIRST up to and including LAST    with NOTE_INSN_DELETED notes.  */
end_comment

begin_function
specifier|static
name|void
name|loop_delete_insns
parameter_list|(
name|first
parameter_list|,
name|last
parameter_list|)
name|rtx
name|first
decl_stmt|;
name|rtx
name|last
decl_stmt|;
block|{
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|", deleting init_insn (%d)"
argument_list|,
name|INSN_UID
argument_list|(
name|first
argument_list|)
argument_list|)
expr_stmt|;
name|delete_insn
argument_list|(
name|first
argument_list|)
expr_stmt|;
comment|/* If this was the LAST instructions we're supposed to delete, 	 we're done.  */
if|if
condition|(
name|first
operator|==
name|last
condition|)
break|break;
name|first
operator|=
name|NEXT_INSN
argument_list|(
name|first
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Try to replace occurrences of pseudo REGNO with REPLACEMENT within    loop LOOP if the order of the sets of these registers can be    swapped.  There must be exactly one insn within the loop that sets    this pseudo followed immediately by a move insn that sets    REPLACEMENT with REGNO.  */
end_comment

begin_function
specifier|static
name|void
name|try_swap_copy_prop
parameter_list|(
name|loop
parameter_list|,
name|replacement
parameter_list|,
name|regno
parameter_list|)
specifier|const
name|struct
name|loop
modifier|*
name|loop
decl_stmt|;
name|rtx
name|replacement
decl_stmt|;
name|unsigned
name|int
name|regno
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|;
name|rtx
name|set
init|=
name|NULL_RTX
decl_stmt|;
name|unsigned
name|int
name|new_regno
decl_stmt|;
name|new_regno
operator|=
name|REGNO
argument_list|(
name|replacement
argument_list|)
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|next_insn_in_loop
argument_list|(
name|loop
argument_list|,
name|loop
operator|->
name|scan_start
argument_list|)
init|;
name|insn
operator|!=
name|NULL_RTX
condition|;
name|insn
operator|=
name|next_insn_in_loop
argument_list|(
name|loop
argument_list|,
name|insn
argument_list|)
control|)
block|{
comment|/* Search for the insn that copies REGNO to NEW_REGNO?  */
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
operator|(
name|set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|new_regno
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|regno
condition|)
break|break;
block|}
if|if
condition|(
name|insn
operator|!=
name|NULL_RTX
condition|)
block|{
name|rtx
name|prev_insn
decl_stmt|;
name|rtx
name|prev_set
decl_stmt|;
comment|/* Some DEF-USE info would come in handy here to make this 	 function more general.  For now, just check the previous insn 	 which is the most likely candidate for setting REGNO.  */
name|prev_insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
operator|(
name|prev_set
operator|=
name|single_set
argument_list|(
name|prev_insn
argument_list|)
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|prev_set
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|prev_set
argument_list|)
argument_list|)
operator|==
name|regno
condition|)
block|{
comment|/* We have: 	     (set (reg regno) (expr)) 	     (set (reg new_regno) (reg regno))  	     so try converting this to: 	     (set (reg new_regno) (expr)) 	     (set (reg regno) (reg new_regno))  	     The former construct is often generated when a global 	     variable used for an induction variable is shadowed by a 	     register (NEW_REGNO).  The latter construct improves the 	     chances of GIV replacement and BIV elimination.  */
name|validate_change
argument_list|(
name|prev_insn
argument_list|,
operator|&
name|SET_DEST
argument_list|(
name|prev_set
argument_list|)
argument_list|,
name|replacement
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|,
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
name|replacement
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|apply_change_group
argument_list|()
condition|)
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"  Swapped set of reg %d at %d with reg %d at %d.\n"
argument_list|,
name|regno
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|,
name|new_regno
argument_list|,
name|INSN_UID
argument_list|(
name|prev_insn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Update first use of REGNO.  */
if|if
condition|(
name|REGNO_FIRST_UID
argument_list|(
name|regno
argument_list|)
operator|==
name|INSN_UID
argument_list|(
name|prev_insn
argument_list|)
condition|)
name|REGNO_FIRST_UID
argument_list|(
name|regno
argument_list|)
operator|=
name|INSN_UID
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Now perform copy propagation to hopefully 		 remove all uses of REGNO within the loop.  */
name|try_copy_prop
argument_list|(
name|loop
argument_list|,
name|replacement
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Worker function for find_mem_in_note, called via for_each_rtx.  */
end_comment

begin_function
specifier|static
name|int
name|find_mem_in_note_1
parameter_list|(
name|x
parameter_list|,
name|data
parameter_list|)
name|rtx
modifier|*
name|x
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
if|if
condition|(
operator|*
name|x
operator|!=
name|NULL_RTX
operator|&&
name|GET_CODE
argument_list|(
operator|*
name|x
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|rtx
modifier|*
name|res
init|=
operator|(
name|rtx
operator|*
operator|)
name|data
decl_stmt|;
operator|*
name|res
operator|=
operator|*
name|x
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Returns the first MEM found in NOTE by depth-first search.  */
end_comment

begin_function
specifier|static
name|rtx
name|find_mem_in_note
parameter_list|(
name|note
parameter_list|)
name|rtx
name|note
decl_stmt|;
block|{
if|if
condition|(
name|note
operator|&&
name|for_each_rtx
argument_list|(
operator|&
name|note
argument_list|,
name|find_mem_in_note_1
argument_list|,
operator|&
name|note
argument_list|)
condition|)
return|return
name|note
return|;
return|return
name|NULL_RTX
return|;
block|}
end_function

begin_comment
comment|/* Replace MEM with its associated pseudo register.  This function is    called from load_mems via for_each_rtx.  DATA is actually a pointer    to a structure describing the instruction currently being scanned    and the MEM we are currently replacing.  */
end_comment

begin_function
specifier|static
name|int
name|replace_loop_mem
parameter_list|(
name|mem
parameter_list|,
name|data
parameter_list|)
name|rtx
modifier|*
name|mem
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
name|loop_replace_args
modifier|*
name|args
init|=
operator|(
name|loop_replace_args
operator|*
operator|)
name|data
decl_stmt|;
name|rtx
name|m
init|=
operator|*
name|mem
decl_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL_RTX
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|m
argument_list|)
condition|)
block|{
case|case
name|MEM
case|:
break|break;
case|case
name|CONST_DOUBLE
case|:
comment|/* We're not interested in the MEM associated with a 	 CONST_DOUBLE, so there's no need to traverse into one.  */
return|return
operator|-
literal|1
return|;
default|default:
comment|/* This is not a MEM.  */
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|rtx_equal_p
argument_list|(
name|args
operator|->
name|match
argument_list|,
name|m
argument_list|)
condition|)
comment|/* This is not the MEM we are currently replacing.  */
return|return
literal|0
return|;
comment|/* Actually replace the MEM.  */
name|validate_change
argument_list|(
name|args
operator|->
name|insn
argument_list|,
name|mem
argument_list|,
name|args
operator|->
name|replacement
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|replace_loop_mems
parameter_list|(
name|insn
parameter_list|,
name|mem
parameter_list|,
name|reg
parameter_list|,
name|written
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|rtx
name|mem
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
name|int
name|written
decl_stmt|;
block|{
name|loop_replace_args
name|args
decl_stmt|;
name|args
operator|.
name|insn
operator|=
name|insn
expr_stmt|;
name|args
operator|.
name|match
operator|=
name|mem
expr_stmt|;
name|args
operator|.
name|replacement
operator|=
name|reg
expr_stmt|;
name|for_each_rtx
argument_list|(
operator|&
name|insn
argument_list|,
name|replace_loop_mem
argument_list|,
operator|&
name|args
argument_list|)
expr_stmt|;
comment|/* If we hoist a mem write out of the loop, then REG_EQUAL      notes referring to the mem are no longer valid.  */
if|if
condition|(
name|written
condition|)
block|{
name|rtx
name|note
decl_stmt|,
name|sub
decl_stmt|;
name|rtx
modifier|*
name|link
decl_stmt|;
for|for
control|(
name|link
operator|=
operator|&
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
operator|(
name|note
operator|=
operator|*
name|link
operator|)
condition|;
name|link
operator|=
operator|&
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
control|)
block|{
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
operator|==
name|REG_EQUAL
operator|&&
operator|(
name|sub
operator|=
name|find_mem_in_note
argument_list|(
name|note
argument_list|)
operator|)
operator|&&
name|true_dependence
argument_list|(
name|mem
argument_list|,
name|VOIDmode
argument_list|,
name|sub
argument_list|,
name|rtx_varies_p
argument_list|)
condition|)
block|{
comment|/* Remove the note.  */
name|validate_change
argument_list|(
name|NULL_RTX
argument_list|,
name|link
argument_list|,
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Replace one register with another.  Called through for_each_rtx; PX points    to the rtx being scanned.  DATA is actually a pointer to    a structure of arguments.  */
end_comment

begin_function
specifier|static
name|int
name|replace_loop_reg
parameter_list|(
name|px
parameter_list|,
name|data
parameter_list|)
name|rtx
modifier|*
name|px
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
name|rtx
name|x
init|=
operator|*
name|px
decl_stmt|;
name|loop_replace_args
modifier|*
name|args
init|=
operator|(
name|loop_replace_args
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
name|x
operator|==
name|NULL_RTX
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|x
operator|==
name|args
operator|->
name|match
condition|)
name|validate_change
argument_list|(
name|args
operator|->
name|insn
argument_list|,
name|px
argument_list|,
name|args
operator|->
name|replacement
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|replace_loop_regs
parameter_list|(
name|insn
parameter_list|,
name|reg
parameter_list|,
name|replacement
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
name|rtx
name|replacement
decl_stmt|;
block|{
name|loop_replace_args
name|args
decl_stmt|;
name|args
operator|.
name|insn
operator|=
name|insn
expr_stmt|;
name|args
operator|.
name|match
operator|=
name|reg
expr_stmt|;
name|args
operator|.
name|replacement
operator|=
name|replacement
expr_stmt|;
name|for_each_rtx
argument_list|(
operator|&
name|insn
argument_list|,
name|replace_loop_reg
argument_list|,
operator|&
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Replace occurrences of the old exit label for the loop with the new    one.  DATA is an rtx_pair containing the old and new labels,    respectively.  */
end_comment

begin_function
specifier|static
name|int
name|replace_label
parameter_list|(
name|x
parameter_list|,
name|data
parameter_list|)
name|rtx
modifier|*
name|x
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
name|rtx
name|l
init|=
operator|*
name|x
decl_stmt|;
name|rtx
name|old_label
init|=
operator|(
operator|(
name|rtx_pair
operator|*
operator|)
name|data
operator|)
operator|->
name|r1
decl_stmt|;
name|rtx
name|new_label
init|=
operator|(
operator|(
name|rtx_pair
operator|*
operator|)
name|data
operator|)
operator|->
name|r2
decl_stmt|;
if|if
condition|(
name|l
operator|==
name|NULL_RTX
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|l
argument_list|)
operator|!=
name|LABEL_REF
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|XEXP
argument_list|(
name|l
argument_list|,
literal|0
argument_list|)
operator|!=
name|old_label
condition|)
return|return
literal|0
return|;
name|XEXP
argument_list|(
name|l
argument_list|,
literal|0
argument_list|)
operator|=
name|new_label
expr_stmt|;
operator|++
name|LABEL_NUSES
argument_list|(
name|new_label
argument_list|)
expr_stmt|;
operator|--
name|LABEL_NUSES
argument_list|(
name|old_label
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Emit insn for PATTERN after WHERE_INSN in basic block WHERE_BB    (ignored in the interim).  */
end_comment

begin_function
specifier|static
name|rtx
name|loop_insn_emit_after
parameter_list|(
name|loop
parameter_list|,
name|where_bb
parameter_list|,
name|where_insn
parameter_list|,
name|pattern
parameter_list|)
specifier|const
name|struct
name|loop
modifier|*
name|loop
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|basic_block
name|where_bb
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|rtx
name|where_insn
decl_stmt|;
name|rtx
name|pattern
decl_stmt|;
block|{
return|return
name|emit_insn_after
argument_list|(
name|pattern
argument_list|,
name|where_insn
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* If WHERE_INSN is nonzero emit insn for PATTERN before WHERE_INSN    in basic block WHERE_BB (ignored in the interim) within the loop    otherwise hoist PATTERN into the loop pre-header.  */
end_comment

begin_function
name|rtx
name|loop_insn_emit_before
parameter_list|(
name|loop
parameter_list|,
name|where_bb
parameter_list|,
name|where_insn
parameter_list|,
name|pattern
parameter_list|)
specifier|const
name|struct
name|loop
modifier|*
name|loop
decl_stmt|;
name|basic_block
name|where_bb
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|rtx
name|where_insn
decl_stmt|;
name|rtx
name|pattern
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|where_insn
condition|)
return|return
name|loop_insn_hoist
argument_list|(
name|loop
argument_list|,
name|pattern
argument_list|)
return|;
return|return
name|emit_insn_before
argument_list|(
name|pattern
argument_list|,
name|where_insn
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Emit call insn for PATTERN before WHERE_INSN in basic block    WHERE_BB (ignored in the interim) within the loop.  */
end_comment

begin_function
specifier|static
name|rtx
name|loop_call_insn_emit_before
parameter_list|(
name|loop
parameter_list|,
name|where_bb
parameter_list|,
name|where_insn
parameter_list|,
name|pattern
parameter_list|)
specifier|const
name|struct
name|loop
modifier|*
name|loop
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|basic_block
name|where_bb
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|rtx
name|where_insn
decl_stmt|;
name|rtx
name|pattern
decl_stmt|;
block|{
return|return
name|emit_call_insn_before
argument_list|(
name|pattern
argument_list|,
name|where_insn
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Hoist insn for PATTERN into the loop pre-header.  */
end_comment

begin_function
name|rtx
name|loop_insn_hoist
parameter_list|(
name|loop
parameter_list|,
name|pattern
parameter_list|)
specifier|const
name|struct
name|loop
modifier|*
name|loop
decl_stmt|;
name|rtx
name|pattern
decl_stmt|;
block|{
return|return
name|loop_insn_emit_before
argument_list|(
name|loop
argument_list|,
literal|0
argument_list|,
name|loop
operator|->
name|start
argument_list|,
name|pattern
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Hoist call insn for PATTERN into the loop pre-header.  */
end_comment

begin_function
specifier|static
name|rtx
name|loop_call_insn_hoist
parameter_list|(
name|loop
parameter_list|,
name|pattern
parameter_list|)
specifier|const
name|struct
name|loop
modifier|*
name|loop
decl_stmt|;
name|rtx
name|pattern
decl_stmt|;
block|{
return|return
name|loop_call_insn_emit_before
argument_list|(
name|loop
argument_list|,
literal|0
argument_list|,
name|loop
operator|->
name|start
argument_list|,
name|pattern
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Sink insn for PATTERN after the loop end.  */
end_comment

begin_function
name|rtx
name|loop_insn_sink
parameter_list|(
name|loop
parameter_list|,
name|pattern
parameter_list|)
specifier|const
name|struct
name|loop
modifier|*
name|loop
decl_stmt|;
name|rtx
name|pattern
decl_stmt|;
block|{
return|return
name|loop_insn_emit_before
argument_list|(
name|loop
argument_list|,
literal|0
argument_list|,
name|loop
operator|->
name|sink
argument_list|,
name|pattern
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* bl->final_value can be eighter general_operand or PLUS of general_operand    and constant.  Emit sequence of intructions to load it into REG  */
end_comment

begin_function
specifier|static
name|rtx
name|gen_load_of_final_value
parameter_list|(
name|reg
parameter_list|,
name|final_value
parameter_list|)
name|rtx
name|reg
decl_stmt|,
name|final_value
decl_stmt|;
block|{
name|rtx
name|seq
decl_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|final_value
operator|=
name|force_operand
argument_list|(
name|final_value
argument_list|,
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|final_value
operator|!=
name|reg
condition|)
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|final_value
argument_list|)
expr_stmt|;
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
return|return
name|seq
return|;
block|}
end_function

begin_comment
comment|/* If the loop has multiple exits, emit insn for PATTERN before the    loop to ensure that it will always be executed no matter how the    loop exits.  Otherwise, emit the insn for PATTERN after the loop,    since this is slightly more efficient.  */
end_comment

begin_function
specifier|static
name|rtx
name|loop_insn_sink_or_swim
parameter_list|(
name|loop
parameter_list|,
name|pattern
parameter_list|)
specifier|const
name|struct
name|loop
modifier|*
name|loop
decl_stmt|;
name|rtx
name|pattern
decl_stmt|;
block|{
if|if
condition|(
name|loop
operator|->
name|exit_count
condition|)
return|return
name|loop_insn_hoist
argument_list|(
name|loop
argument_list|,
name|pattern
argument_list|)
return|;
else|else
return|return
name|loop_insn_sink
argument_list|(
name|loop
argument_list|,
name|pattern
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|loop_ivs_dump
parameter_list|(
name|loop
parameter_list|,
name|file
parameter_list|,
name|verbose
parameter_list|)
specifier|const
name|struct
name|loop
modifier|*
name|loop
decl_stmt|;
name|FILE
modifier|*
name|file
decl_stmt|;
name|int
name|verbose
decl_stmt|;
block|{
name|struct
name|iv_class
modifier|*
name|bl
decl_stmt|;
name|int
name|iv_num
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|loop
operator|||
operator|!
name|file
condition|)
return|return;
for|for
control|(
name|bl
operator|=
name|LOOP_IVS
argument_list|(
name|loop
argument_list|)
operator|->
name|list
init|;
name|bl
condition|;
name|bl
operator|=
name|bl
operator|->
name|next
control|)
name|iv_num
operator|++
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"Loop %d: %d IV classes\n"
argument_list|,
name|loop
operator|->
name|num
argument_list|,
name|iv_num
argument_list|)
expr_stmt|;
for|for
control|(
name|bl
operator|=
name|LOOP_IVS
argument_list|(
name|loop
argument_list|)
operator|->
name|list
init|;
name|bl
condition|;
name|bl
operator|=
name|bl
operator|->
name|next
control|)
block|{
name|loop_iv_class_dump
argument_list|(
name|bl
argument_list|,
name|file
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|loop_iv_class_dump
parameter_list|(
name|bl
parameter_list|,
name|file
parameter_list|,
name|verbose
parameter_list|)
specifier|const
name|struct
name|iv_class
modifier|*
name|bl
decl_stmt|;
name|FILE
modifier|*
name|file
decl_stmt|;
name|int
name|verbose
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|struct
name|induction
modifier|*
name|v
decl_stmt|;
name|rtx
name|incr
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|bl
operator|||
operator|!
name|file
condition|)
return|return;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"IV class for reg %d, benefit %d\n"
argument_list|,
name|bl
operator|->
name|regno
argument_list|,
name|bl
operator|->
name|total_benefit
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" Init insn %d"
argument_list|,
name|INSN_UID
argument_list|(
name|bl
operator|->
name|init_insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bl
operator|->
name|initial_value
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|", init val: "
argument_list|)
expr_stmt|;
name|print_simple_rtl
argument_list|(
name|file
argument_list|,
name|bl
operator|->
name|initial_value
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bl
operator|->
name|initial_test
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|", init test: "
argument_list|)
expr_stmt|;
name|print_simple_rtl
argument_list|(
name|file
argument_list|,
name|bl
operator|->
name|initial_test
argument_list|)
expr_stmt|;
block|}
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|bl
operator|->
name|final_value
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" Final val: "
argument_list|)
expr_stmt|;
name|print_simple_rtl
argument_list|(
name|file
argument_list|,
name|bl
operator|->
name|final_value
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|incr
operator|=
name|biv_total_increment
argument_list|(
name|bl
argument_list|)
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" Total increment: "
argument_list|)
expr_stmt|;
name|print_simple_rtl
argument_list|(
name|file
argument_list|,
name|incr
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
comment|/* List the increments.  */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|v
operator|=
name|bl
operator|->
name|biv
init|;
name|v
condition|;
name|v
operator|=
name|v
operator|->
name|next_iv
operator|,
name|i
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" Inc%d: insn %d, incr: "
argument_list|,
name|i
argument_list|,
name|INSN_UID
argument_list|(
name|v
operator|->
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|print_simple_rtl
argument_list|(
name|file
argument_list|,
name|v
operator|->
name|add_val
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
comment|/* List the givs.  */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|v
operator|=
name|bl
operator|->
name|giv
init|;
name|v
condition|;
name|v
operator|=
name|v
operator|->
name|next_iv
operator|,
name|i
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" Giv%d: insn %d, benefit %d, "
argument_list|,
name|i
argument_list|,
name|INSN_UID
argument_list|(
name|v
operator|->
name|insn
argument_list|)
argument_list|,
name|v
operator|->
name|benefit
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|giv_type
operator|==
name|DEST_ADDR
condition|)
name|print_simple_rtl
argument_list|(
name|file
argument_list|,
name|v
operator|->
name|mem
argument_list|)
expr_stmt|;
else|else
name|print_simple_rtl
argument_list|(
name|file
argument_list|,
name|single_set
argument_list|(
name|v
operator|->
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|loop_biv_dump
parameter_list|(
name|v
parameter_list|,
name|file
parameter_list|,
name|verbose
parameter_list|)
specifier|const
name|struct
name|induction
modifier|*
name|v
decl_stmt|;
name|FILE
modifier|*
name|file
decl_stmt|;
name|int
name|verbose
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|v
operator|||
operator|!
name|file
condition|)
return|return;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"Biv %d: insn %d"
argument_list|,
name|REGNO
argument_list|(
name|v
operator|->
name|dest_reg
argument_list|)
argument_list|,
name|INSN_UID
argument_list|(
name|v
operator|->
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" const "
argument_list|)
expr_stmt|;
name|print_simple_rtl
argument_list|(
name|file
argument_list|,
name|v
operator|->
name|add_val
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
operator|&&
name|v
operator|->
name|final_value
condition|)
block|{
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" final "
argument_list|)
expr_stmt|;
name|print_simple_rtl
argument_list|(
name|file
argument_list|,
name|v
operator|->
name|final_value
argument_list|)
expr_stmt|;
block|}
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|loop_giv_dump
parameter_list|(
name|v
parameter_list|,
name|file
parameter_list|,
name|verbose
parameter_list|)
specifier|const
name|struct
name|induction
modifier|*
name|v
decl_stmt|;
name|FILE
modifier|*
name|file
decl_stmt|;
name|int
name|verbose
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|v
operator|||
operator|!
name|file
condition|)
return|return;
if|if
condition|(
name|v
operator|->
name|giv_type
operator|==
name|DEST_REG
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"Giv %d: insn %d"
argument_list|,
name|REGNO
argument_list|(
name|v
operator|->
name|dest_reg
argument_list|)
argument_list|,
name|INSN_UID
argument_list|(
name|v
operator|->
name|insn
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"Dest address: insn %d"
argument_list|,
name|INSN_UID
argument_list|(
name|v
operator|->
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" src reg %d benefit %d"
argument_list|,
name|REGNO
argument_list|(
name|v
operator|->
name|src_reg
argument_list|)
argument_list|,
name|v
operator|->
name|benefit
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" lifetime %d"
argument_list|,
name|v
operator|->
name|lifetime
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|replaceable
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" replaceable"
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|no_const_addval
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" ncav"
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|ext_dependent
condition|)
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|v
operator|->
name|ext_dependent
argument_list|)
condition|)
block|{
case|case
name|SIGN_EXTEND
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" ext se"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZERO_EXTEND
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" ext ze"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TRUNCATE
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" ext tr"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" mult "
argument_list|)
expr_stmt|;
name|print_simple_rtl
argument_list|(
name|file
argument_list|,
name|v
operator|->
name|mult_val
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" add  "
argument_list|)
expr_stmt|;
name|print_simple_rtl
argument_list|(
name|file
argument_list|,
name|v
operator|->
name|add_val
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
operator|&&
name|v
operator|->
name|final_value
condition|)
block|{
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" final "
argument_list|)
expr_stmt|;
name|print_simple_rtl
argument_list|(
name|file
argument_list|,
name|v
operator|->
name|final_value
argument_list|)
expr_stmt|;
block|}
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|debug_ivs
parameter_list|(
name|loop
parameter_list|)
specifier|const
name|struct
name|loop
modifier|*
name|loop
decl_stmt|;
block|{
name|loop_ivs_dump
argument_list|(
name|loop
argument_list|,
name|stderr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|debug_iv_class
parameter_list|(
name|bl
parameter_list|)
specifier|const
name|struct
name|iv_class
modifier|*
name|bl
decl_stmt|;
block|{
name|loop_iv_class_dump
argument_list|(
name|bl
argument_list|,
name|stderr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|debug_biv
parameter_list|(
name|v
parameter_list|)
specifier|const
name|struct
name|induction
modifier|*
name|v
decl_stmt|;
block|{
name|loop_biv_dump
argument_list|(
name|v
argument_list|,
name|stderr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|debug_giv
parameter_list|(
name|v
parameter_list|)
specifier|const
name|struct
name|induction
modifier|*
name|v
decl_stmt|;
block|{
name|loop_giv_dump
argument_list|(
name|v
argument_list|,
name|stderr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|LOOP_BLOCK_NUM_1
parameter_list|(
name|INSN
parameter_list|)
define|\
value|((INSN) ? (BLOCK_FOR_INSN (INSN) ? BLOCK_NUM (INSN) : - 1) : -1)
end_define

begin_comment
comment|/* The notes do not have an assigned block, so look at the next insn.  */
end_comment

begin_define
define|#
directive|define
name|LOOP_BLOCK_NUM
parameter_list|(
name|INSN
parameter_list|)
define|\
value|((INSN) ? (GET_CODE (INSN) == NOTE \             ? LOOP_BLOCK_NUM_1 (next_nonnote_insn (INSN)) \             : LOOP_BLOCK_NUM_1 (INSN)) \         : -1)
end_define

begin_define
define|#
directive|define
name|LOOP_INSN_UID
parameter_list|(
name|INSN
parameter_list|)
value|((INSN) ? INSN_UID (INSN) : -1)
end_define

begin_function
specifier|static
name|void
name|loop_dump_aux
parameter_list|(
name|loop
parameter_list|,
name|file
parameter_list|,
name|verbose
parameter_list|)
specifier|const
name|struct
name|loop
modifier|*
name|loop
decl_stmt|;
name|FILE
modifier|*
name|file
decl_stmt|;
name|int
name|verbose
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|rtx
name|label
decl_stmt|;
if|if
condition|(
operator|!
name|loop
operator|||
operator|!
name|file
condition|)
return|return;
comment|/* Print diagnostics to compare our concept of a loop with      what the loop notes say.  */
if|if
condition|(
operator|!
name|PREV_INSN
argument_list|(
name|loop
operator|->
name|first
operator|->
name|head
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|PREV_INSN
argument_list|(
name|loop
operator|->
name|first
operator|->
name|head
argument_list|)
argument_list|)
operator|!=
name|NOTE
operator|||
name|NOTE_LINE_NUMBER
argument_list|(
name|PREV_INSN
argument_list|(
name|loop
operator|->
name|first
operator|->
name|head
argument_list|)
argument_list|)
operator|!=
name|NOTE_INSN_LOOP_BEG
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|";;  No NOTE_INSN_LOOP_BEG at %d\n"
argument_list|,
name|INSN_UID
argument_list|(
name|PREV_INSN
argument_list|(
name|loop
operator|->
name|first
operator|->
name|head
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NEXT_INSN
argument_list|(
name|loop
operator|->
name|last
operator|->
name|end
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|NEXT_INSN
argument_list|(
name|loop
operator|->
name|last
operator|->
name|end
argument_list|)
argument_list|)
operator|!=
name|NOTE
operator|||
name|NOTE_LINE_NUMBER
argument_list|(
name|NEXT_INSN
argument_list|(
name|loop
operator|->
name|last
operator|->
name|end
argument_list|)
argument_list|)
operator|!=
name|NOTE_INSN_LOOP_END
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|";;  No NOTE_INSN_LOOP_END at %d\n"
argument_list|,
name|INSN_UID
argument_list|(
name|NEXT_INSN
argument_list|(
name|loop
operator|->
name|last
operator|->
name|end
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|loop
operator|->
name|start
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|";;  start %d (%d), cont dom %d (%d), cont %d (%d), vtop %d (%d), end %d (%d)\n"
argument_list|,
name|LOOP_BLOCK_NUM
argument_list|(
name|loop
operator|->
name|start
argument_list|)
argument_list|,
name|LOOP_INSN_UID
argument_list|(
name|loop
operator|->
name|start
argument_list|)
argument_list|,
name|LOOP_BLOCK_NUM
argument_list|(
name|loop
operator|->
name|cont
argument_list|)
argument_list|,
name|LOOP_INSN_UID
argument_list|(
name|loop
operator|->
name|cont
argument_list|)
argument_list|,
name|LOOP_BLOCK_NUM
argument_list|(
name|loop
operator|->
name|cont
argument_list|)
argument_list|,
name|LOOP_INSN_UID
argument_list|(
name|loop
operator|->
name|cont
argument_list|)
argument_list|,
name|LOOP_BLOCK_NUM
argument_list|(
name|loop
operator|->
name|vtop
argument_list|)
argument_list|,
name|LOOP_INSN_UID
argument_list|(
name|loop
operator|->
name|vtop
argument_list|)
argument_list|,
name|LOOP_BLOCK_NUM
argument_list|(
name|loop
operator|->
name|end
argument_list|)
argument_list|,
name|LOOP_INSN_UID
argument_list|(
name|loop
operator|->
name|end
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|";;  top %d (%d), scan start %d (%d)\n"
argument_list|,
name|LOOP_BLOCK_NUM
argument_list|(
name|loop
operator|->
name|top
argument_list|)
argument_list|,
name|LOOP_INSN_UID
argument_list|(
name|loop
operator|->
name|top
argument_list|)
argument_list|,
name|LOOP_BLOCK_NUM
argument_list|(
name|loop
operator|->
name|scan_start
argument_list|)
argument_list|,
name|LOOP_INSN_UID
argument_list|(
name|loop
operator|->
name|scan_start
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|";;  exit_count %d"
argument_list|,
name|loop
operator|->
name|exit_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|loop
operator|->
name|exit_count
condition|)
block|{
name|fputs
argument_list|(
literal|", labels:"
argument_list|,
name|file
argument_list|)
expr_stmt|;
for|for
control|(
name|label
operator|=
name|loop
operator|->
name|exit_labels
init|;
name|label
condition|;
name|label
operator|=
name|LABEL_NEXTREF
argument_list|(
name|label
argument_list|)
control|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %d "
argument_list|,
name|LOOP_INSN_UID
argument_list|(
name|XEXP
argument_list|(
name|label
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|fputs
argument_list|(
literal|"\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
comment|/* This can happen when a marked loop appears as two nested loops, 	 say from while (a || b) {}.  The inner loop won't match 	 the loop markers but the outer one will.  */
if|if
condition|(
name|LOOP_BLOCK_NUM
argument_list|(
name|loop
operator|->
name|cont
argument_list|)
operator|!=
name|loop
operator|->
name|latch
operator|->
name|index
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|";;  NOTE_INSN_LOOP_CONT not in loop latch\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Call this function from the debugger to dump LOOP.  */
end_comment

begin_function
name|void
name|debug_loop
parameter_list|(
name|loop
parameter_list|)
specifier|const
name|struct
name|loop
modifier|*
name|loop
decl_stmt|;
block|{
name|flow_loop_dump
argument_list|(
name|loop
argument_list|,
name|stderr
argument_list|,
name|loop_dump_aux
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Call this function from the debugger to dump LOOPS.  */
end_comment

begin_function
name|void
name|debug_loops
parameter_list|(
name|loops
parameter_list|)
specifier|const
name|struct
name|loops
modifier|*
name|loops
decl_stmt|;
block|{
name|flow_loops_dump
argument_list|(
name|loops
argument_list|,
name|stderr
argument_list|,
name|loop_dump_aux
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

