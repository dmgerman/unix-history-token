begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Perform various loop optimizations, including strength reduction.    Copyright (C) 1987, 88, 89, 91-97, 1998 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* This is the loop optimization pass of the compiler.    It finds invariant computations within loops and moves them    to the beginning of the loop.  Then it identifies basic and     general induction variables.  Strength reduction is applied to the general    induction variables, and induction variable elimination is applied to    the basic induction variables.     It also finds cases where    a register is set within the loop by zero-extending a narrower value    and changes these to zero the entire register once before the loop    and merely copy the low part within the loop.     Most of the complexity is in heuristics to decide when it is worth    while to do these things.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"insn-flags.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"loop.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_comment
comment|/* Vector mapping INSN_UIDs to luids.    The luids are like uids but increase monotonically always.    We use them to see whether a jump comes from outside a given loop.  */
end_comment

begin_decl_stmt
name|int
modifier|*
name|uid_luid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by INSN_UID, contains the ordinal giving the (innermost) loop    number the insn is contained in.  */
end_comment

begin_decl_stmt
name|int
modifier|*
name|uid_loop_num
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 + largest uid of any insn.  */
end_comment

begin_decl_stmt
name|int
name|max_uid_for_loop
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 + luid of last insn.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|max_luid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of loops detected in current function.  Used as index to the    next few tables.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|max_loop_num
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by loop number, contains the first and last insn of each loop.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
modifier|*
name|loop_number_loop_starts
decl_stmt|,
modifier|*
name|loop_number_loop_ends
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For each loop, gives the containing loop number, -1 if none.  */
end_comment

begin_decl_stmt
name|int
modifier|*
name|loop_outer_loop
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|HAIFA
end_ifdef

begin_comment
comment|/* The main output of analyze_loop_iterations is placed here */
end_comment

begin_decl_stmt
name|int
modifier|*
name|loop_can_insert_bct
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For each loop, determines whether some of its inner loops has used    count register */
end_comment

begin_decl_stmt
name|int
modifier|*
name|loop_used_count_register
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* loop parameters for arithmetic loops. These loops have a loop variable    which is initialized to loop_start_value, incremented in each iteration    by "loop_increment".  At the end of the iteration the loop variable is    compared to the loop_comparison_value (using loop_comparison_code).  */
end_comment

begin_decl_stmt
name|rtx
modifier|*
name|loop_increment
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
modifier|*
name|loop_comparison_value
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
modifier|*
name|loop_start_value
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|rtx_code
modifier|*
name|loop_comparison_code
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAIFA */
end_comment

begin_comment
comment|/* For each loop, keep track of its unrolling factor.    Potential values:       0: unrolled       1: not unrolled.      -1: completely unrolled>0: holds the unroll exact factor.  */
end_comment

begin_decl_stmt
name|int
modifier|*
name|loop_unroll_factor
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by loop number, contains a nonzero value if the "loop" isn't    really a loop (an insn outside the loop branches into it).  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|loop_invalid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by loop number, links together all LABEL_REFs which refer to    code labels outside the loop.  Used by routines that need to know all    loop exits, such as final_biv_value and final_giv_value.     This does not include loop exits due to return instructions.  This is    because all bivs and givs are pseudos, and hence must be dead after a    return, so the presense of a return does not affect any of the    optimizations that use this info.  It is simpler to just not include return    instructions on this list.  */
end_comment

begin_decl_stmt
name|rtx
modifier|*
name|loop_number_exit_labels
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by loop number, counts the number of LABEL_REFs on    loop_number_exit_labels for this loop and all loops nested inside it.  */
end_comment

begin_decl_stmt
name|int
modifier|*
name|loop_number_exit_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Holds the number of loop iterations.  It is zero if the number could not be    calculated.  Must be unsigned since the number of iterations can    be as high as 2^wordsize-1.  For loops with a wider iterator, this number    will be zero if the number of loop iterations is too large for an    unsigned integer to hold.  */
end_comment

begin_decl_stmt
name|unsigned
name|HOST_WIDE_INT
name|loop_n_iterations
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if there is a subroutine call in the current loop.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|loop_has_call
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if there is a volatile memory reference in the current    loop.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|loop_has_volatile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Added loop_continue which is the NOTE_INSN_LOOP_CONT of the    current loop.  A continue statement will generate a branch to    NEXT_INSN (loop_continue).  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|loop_continue
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by register number, contains the number of times the reg    is set during the loop being scanned.    During code motion, a negative value indicates a reg that has been    made a candidate; in particular -2 means that it is an candidate that    we know is equal to a constant and -1 means that it is an candidate    not known equal to a constant.    After code motion, regs moved have 0 (which is accurate now)    while the failed candidates have the original number of times set.     Therefore, at all times, == 0 indicates an invariant register;< 0 a conditionally invariant one.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|n_times_set
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Original value of n_times_set; same except that this value    is not set negative for a reg whose sets have been made candidates    and not set to 0 for a reg that is moved.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|n_times_used
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Index by register number, 1 indicates that the register    cannot be moved or strength reduced.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|may_not_optimize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means reg N has already been moved out of one loop.    This reduces the desire to move it out of another.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|moved_once
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Array of MEMs that are stored in this loop. If there are too many to fit    here, we just turn on unknown_address_altered.  */
end_comment

begin_define
define|#
directive|define
name|NUM_STORES
value|30
end_define

begin_decl_stmt
specifier|static
name|rtx
name|loop_store_mems
index|[
name|NUM_STORES
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Index of first available slot in above array.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|loop_store_mems_idx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The insn where the first of these was found.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|first_loop_store_insn
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if we don't know what MEMs were changed in the current loop.    This happens if the loop contains a call (in which case `loop_has_call'    will also be set) or if we store into more than NUM_STORES MEMs.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|unknown_address_altered
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Count of movable (i.e. invariant) instructions discovered in the loop.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|num_movables
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Count of memory write instructions discovered in the loop.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|num_mem_sets
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of loops contained within the current one, including itself.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|loops_enclosed
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Bound on pseudo register number before loop optimization.    A pseudo has valid regscan info if its number is< max_reg_before_loop.  */
end_comment

begin_decl_stmt
name|int
name|max_reg_before_loop
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This obstack is used in product_cheap_p to allocate its rtl.  It    may call gen_reg_rtx which, in turn, may reallocate regno_reg_rtx.    If we used the same obstack that it did, we would be deallocating    that array.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|temp_obstack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is where the pointer to the obstack being used for RTL is stored.  */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|obstack
modifier|*
name|rtl_obstack
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|obstack_chunk_alloc
value|xmalloc
end_define

begin_define
define|#
directive|define
name|obstack_chunk_free
value|free
end_define

begin_escape
end_escape

begin_comment
comment|/* During the analysis of a loop, a chain of `struct movable's    is made to record all the movable insns found.    Then the entire chain can be scanned to decide which to move.  */
end_comment

begin_struct
struct|struct
name|movable
block|{
name|rtx
name|insn
decl_stmt|;
comment|/* A movable insn */
name|rtx
name|set_src
decl_stmt|;
comment|/* The expression this reg is set from.  */
name|rtx
name|set_dest
decl_stmt|;
comment|/* The destination of this SET.  */
name|rtx
name|dependencies
decl_stmt|;
comment|/* When INSN is libcall, this is an EXPR_LIST 				   of any registers used within the LIBCALL.  */
name|int
name|consec
decl_stmt|;
comment|/* Number of consecutive following insns  				   that must be moved with this one.  */
name|int
name|regno
decl_stmt|;
comment|/* The register it sets */
name|short
name|lifetime
decl_stmt|;
comment|/* lifetime of that register; 				   may be adjusted when matching movables 				   that load the same value are found.  */
name|short
name|savings
decl_stmt|;
comment|/* Number of insns we can move for this reg, 				   including other movables that force this 				   or match this one.  */
name|unsigned
name|int
name|cond
range|:
literal|1
decl_stmt|;
comment|/* 1 if only conditionally movable */
name|unsigned
name|int
name|force
range|:
literal|1
decl_stmt|;
comment|/* 1 means MUST move this insn */
name|unsigned
name|int
name|global
range|:
literal|1
decl_stmt|;
comment|/* 1 means reg is live outside this loop */
comment|/* If PARTIAL is 1, GLOBAL means something different: 		   that the reg is live outside the range from where it is set 		   to the following label.  */
name|unsigned
name|int
name|done
range|:
literal|1
decl_stmt|;
comment|/* 1 inhibits further processing of this */
name|unsigned
name|int
name|partial
range|:
literal|1
decl_stmt|;
comment|/* 1 means this reg is used for zero-extending. 				   In particular, moving it does not make it 				   invariant.  */
name|unsigned
name|int
name|move_insn
range|:
literal|1
decl_stmt|;
comment|/* 1 means that we call emit_move_insn to 				   load SRC, rather than copying INSN.  */
name|unsigned
name|int
name|move_insn_first
range|:
literal|1
decl_stmt|;
comment|/* Same as above, if this is necessary for the 				    first insn of a consecutive sets group.  */
name|unsigned
name|int
name|is_equiv
range|:
literal|1
decl_stmt|;
comment|/* 1 means a REG_EQUIV is present on INSN.  */
name|enum
name|machine_mode
name|savemode
decl_stmt|;
comment|/* Nonzero means it is a mode for a low part 				   that we should avoid changing when clearing 				   the rest of the reg.  */
name|struct
name|movable
modifier|*
name|match
decl_stmt|;
comment|/* First entry for same value */
name|struct
name|movable
modifier|*
name|forces
decl_stmt|;
comment|/* An insn that must be moved if this is */
name|struct
name|movable
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|FILE
modifier|*
name|loop_dump_stream
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forward declarations.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|find_and_verify_loops
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mark_loop_jump
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|prescan_loop
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|reg_in_basic_block_p
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|consec_sets_invariant_p
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|libcall_other_reg
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|labels_in_range_p
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|count_loop_regs_set
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|char
operator|*
operator|,
name|rtx
operator|*
operator|,
name|int
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|note_addr_stored
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|loop_reg_used_before_p
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|scan_loop
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static void replace_call_address PROTO((rtx, rtx, rtx));
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|rtx
name|skip_consec_insns
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|libcall_benefit
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ignore_some_movables
name|PROTO
argument_list|(
operator|(
expr|struct
name|movable
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|force_movables
name|PROTO
argument_list|(
operator|(
expr|struct
name|movable
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|combine_movables
name|PROTO
argument_list|(
operator|(
expr|struct
name|movable
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|regs_match_p
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
expr|struct
name|movable
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|rtx_equal_for_loop_p
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
expr|struct
name|movable
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_label_notes
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|move_movables
name|PROTO
argument_list|(
operator|(
expr|struct
name|movable
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|count_nonfixed_reads
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|strength_reduce
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|int
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|find_single_use_in_loop
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|valid_initial_value_p
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|int
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|find_mem_givs
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|int
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|record_biv
name|PROTO
argument_list|(
operator|(
expr|struct
name|induction
operator|*
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|check_final_value
name|PROTO
argument_list|(
operator|(
expr|struct
name|induction
operator|*
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|record_giv
name|PROTO
argument_list|(
operator|(
expr|struct
name|induction
operator|*
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|int
operator|,
expr|enum
name|g_types
operator|,
name|int
operator|,
name|rtx
operator|*
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|update_giv_derive
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|basic_induction_var
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
expr|enum
name|machine_mode
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|*
operator|,
name|rtx
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|simplify_giv_expr
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|general_induction_var
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|*
operator|,
name|rtx
operator|*
operator|,
name|rtx
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|consec_sets_giv
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|*
operator|,
name|rtx
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|check_dbra_loop
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|ADDRESS_COST
end_ifdef

begin_decl_stmt
specifier|static
name|rtx
name|express_from
name|PROTO
argument_list|(
operator|(
expr|struct
name|induction
operator|*
operator|,
expr|struct
name|induction
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|combine_givs_p
name|PROTO
argument_list|(
operator|(
expr|struct
name|induction
operator|*
operator|,
expr|struct
name|induction
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|GIV_SORT_CRITERION
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|giv_sort
name|PROTO
argument_list|(
operator|(
expr|struct
name|induction
operator|*
operator|*
operator|,
expr|struct
name|induction
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|combine_givs
name|PROTO
argument_list|(
operator|(
expr|struct
name|iv_class
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|product_cheap_p
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|maybe_eliminate_biv
name|PROTO
argument_list|(
operator|(
expr|struct
name|iv_class
operator|*
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|maybe_eliminate_biv_1
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
expr|struct
name|iv_class
operator|*
operator|,
name|int
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|last_use_this_basic_block
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|record_initial
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|update_reg_last_use
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|HAIFA
end_ifdef

begin_comment
comment|/* This is extern from unroll.c */
end_comment

begin_decl_stmt
specifier|extern
name|void
name|iteration_info
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|*
operator|,
name|rtx
operator|*
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Two main functions for implementing bct:    first - to be called before loop unrolling, and the second - after */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_decrement_and_branch_on_count
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|analyze_loop_iterations
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|insert_bct
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Auxiliary function that inserts the bct pattern into the loop */
end_comment

begin_decl_stmt
specifier|static
name|void
name|instrument_loop_bct
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_decrement_and_branch_on_count */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAIFA */
end_comment

begin_comment
comment|/* Indirect_jump_in_function is computed once per function.  */
end_comment

begin_decl_stmt
name|int
name|indirect_jump_in_function
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|indirect_jump_in_function_p
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Relative gain of eliminating various kinds of operations.  */
end_comment

begin_decl_stmt
name|int
name|add_cost
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|int shift_cost; int mult_cost;
endif|#
directive|endif
end_endif

begin_comment
comment|/* Benefit penalty, if a giv is not replaceable, i.e. must emit an insn to    copy the value of the strength reduced giv to its original register.  */
end_comment

begin_decl_stmt
name|int
name|copy_cost
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|init_loop
parameter_list|()
block|{
name|char
modifier|*
name|free_point
init|=
operator|(
name|char
operator|*
operator|)
name|oballoc
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|rtx
name|reg
init|=
name|gen_rtx_REG
argument_list|(
name|word_mode
argument_list|,
name|LAST_VIRTUAL_REGISTER
operator|+
literal|1
argument_list|)
decl_stmt|;
name|add_cost
operator|=
name|rtx_cost
argument_list|(
name|gen_rtx_PLUS
argument_list|(
name|word_mode
argument_list|,
name|reg
argument_list|,
name|reg
argument_list|)
argument_list|,
name|SET
argument_list|)
expr_stmt|;
comment|/* We multiply by 2 to reconcile the difference in scale between      these two ways of computing costs.  Otherwise the cost of a copy      will be far less than the cost of an add.  */
name|copy_cost
operator|=
literal|2
operator|*
literal|2
expr_stmt|;
comment|/* Free the objects we just allocated.  */
name|obfree
argument_list|(
name|free_point
argument_list|)
expr_stmt|;
comment|/* Initialize the obstack used for rtl in product_cheap_p.  */
name|gcc_obstack_init
argument_list|(
operator|&
name|temp_obstack
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Entry point of this file.  Perform loop optimization    on the current function.  F is the first insn of the function    and DUMPFILE is a stream for output of a trace of actions taken    (or 0 if none should be output).  */
end_comment

begin_function
name|void
name|loop_optimize
parameter_list|(
name|f
parameter_list|,
name|dumpfile
parameter_list|,
name|unroll_p
parameter_list|)
comment|/* f is the first instruction of a chain of insns for one function */
name|rtx
name|f
decl_stmt|;
name|FILE
modifier|*
name|dumpfile
decl_stmt|;
name|int
name|unroll_p
decl_stmt|;
block|{
specifier|register
name|rtx
name|insn
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|rtx
name|last_insn
decl_stmt|;
name|loop_dump_stream
operator|=
name|dumpfile
expr_stmt|;
name|init_recog_no_volatile
argument_list|()
expr_stmt|;
name|max_reg_before_loop
operator|=
name|max_reg_num
argument_list|()
expr_stmt|;
name|moved_once
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|max_reg_before_loop
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|moved_once
argument_list|,
name|max_reg_before_loop
argument_list|)
expr_stmt|;
name|regs_may_share
operator|=
literal|0
expr_stmt|;
comment|/* Count the number of loops.  */
name|max_loop_num
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|f
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_LOOP_BEG
condition|)
name|max_loop_num
operator|++
expr_stmt|;
block|}
comment|/* Don't waste time if no loops.  */
if|if
condition|(
name|max_loop_num
operator|==
literal|0
condition|)
return|return;
comment|/* Get size to use for tables indexed by uids.      Leave some space for labels allocated by find_and_verify_loops.  */
name|max_uid_for_loop
operator|=
name|get_max_uid
argument_list|()
operator|+
literal|1
operator|+
name|max_loop_num
operator|*
literal|32
expr_stmt|;
name|uid_luid
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|max_uid_for_loop
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|uid_loop_num
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|max_uid_for_loop
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|uid_luid
argument_list|,
name|max_uid_for_loop
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|uid_loop_num
argument_list|,
name|max_uid_for_loop
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Allocate tables for recording each loop.  We set each entry, so they need      not be zeroed.  */
name|loop_number_loop_starts
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|max_loop_num
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|loop_number_loop_ends
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|max_loop_num
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|loop_outer_loop
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|max_loop_num
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|loop_invalid
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|max_loop_num
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
name|loop_number_exit_labels
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|max_loop_num
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|loop_number_exit_count
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|max_loop_num
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
comment|/* This is initialized by the unrolling code, so we go ahead      and clear them just in case we are not performing loop      unrolling.  */
name|loop_unroll_factor
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|max_loop_num
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|loop_unroll_factor
argument_list|,
name|max_loop_num
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAIFA
comment|/* Allocate for BCT optimization */
name|loop_can_insert_bct
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|max_loop_num
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|loop_can_insert_bct
argument_list|,
name|max_loop_num
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|loop_used_count_register
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|max_loop_num
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|loop_used_count_register
argument_list|,
name|max_loop_num
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|loop_increment
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|max_loop_num
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|loop_comparison_value
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|max_loop_num
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|loop_start_value
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|max_loop_num
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|loop_increment
argument_list|,
name|max_loop_num
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|loop_comparison_value
argument_list|,
name|max_loop_num
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|loop_start_value
argument_list|,
name|max_loop_num
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|loop_comparison_code
operator|=
operator|(
expr|enum
name|rtx_code
operator|*
operator|)
name|alloca
argument_list|(
name|max_loop_num
operator|*
sizeof|sizeof
argument_list|(
expr|enum
name|rtx_code
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|loop_comparison_code
argument_list|,
name|max_loop_num
operator|*
sizeof|sizeof
argument_list|(
expr|enum
name|rtx_code
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAIFA */
comment|/* Find and process each loop.      First, find them, and record them in order of their beginnings.  */
name|find_and_verify_loops
argument_list|(
name|f
argument_list|)
expr_stmt|;
comment|/* Now find all register lifetimes.  This must be done after      find_and_verify_loops, because it might reorder the insns in the      function.  */
name|reg_scan
argument_list|(
name|f
argument_list|,
name|max_reg_num
argument_list|()
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* This must occur after reg_scan so that registers created by gcse      will have entries in the register tables.       We could have added a call to reg_scan after gcse_main in toplev.c,      but moving this call to init_alias_analysis is more efficient.  */
name|init_alias_analysis
argument_list|()
expr_stmt|;
comment|/* See if we went too far.  */
if|if
condition|(
name|get_max_uid
argument_list|()
operator|>
name|max_uid_for_loop
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Now reset it to the actual size we need.  See above.  */
name|max_uid_for_loop
operator|=
name|get_max_uid
argument_list|()
operator|+
literal|1
expr_stmt|;
comment|/* Compute the mapping from uids to luids.      LUIDs are numbers assigned to insns, like uids,      except that luids increase monotonically through the code.      Don't assign luids to line-number NOTEs, so that the distance in luids      between two insns is not affected by -g.  */
for|for
control|(
name|insn
operator|=
name|f
operator|,
name|i
operator|=
literal|0
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|last_insn
operator|=
name|insn
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE
operator|||
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|<=
literal|0
condition|)
name|uid_luid
index|[
name|INSN_UID
argument_list|(
name|insn
argument_list|)
index|]
operator|=
operator|++
name|i
expr_stmt|;
else|else
comment|/* Give a line number note the same luid as preceding insn.  */
name|uid_luid
index|[
name|INSN_UID
argument_list|(
name|insn
argument_list|)
index|]
operator|=
name|i
expr_stmt|;
block|}
name|max_luid
operator|=
name|i
operator|+
literal|1
expr_stmt|;
comment|/* Don't leave gaps in uid_luid for insns that have been      deleted.  It is possible that the first or last insn      using some register has been deleted by cross-jumping.      Make sure that uid_luid for that former insn's uid      points to the general area where that insn used to be.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_uid_for_loop
condition|;
name|i
operator|++
control|)
block|{
name|uid_luid
index|[
literal|0
index|]
operator|=
name|uid_luid
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|uid_luid
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
break|break;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_uid_for_loop
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|uid_luid
index|[
name|i
index|]
operator|==
literal|0
condition|)
name|uid_luid
index|[
name|i
index|]
operator|=
name|uid_luid
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
comment|/* Create a mapping from loops to BLOCK tree nodes.  */
if|if
condition|(
name|unroll_p
operator|&&
name|write_symbols
operator|!=
name|NO_DEBUG
condition|)
name|find_loop_tree_blocks
argument_list|()
expr_stmt|;
comment|/* Determine if the function has indirect jump.  On some systems      this prevents low overhead loop instructions from being used.  */
name|indirect_jump_in_function
operator|=
name|indirect_jump_in_function_p
argument_list|(
name|f
argument_list|)
expr_stmt|;
comment|/* Now scan the loops, last ones first, since this means inner ones are done      before outer ones.  */
for|for
control|(
name|i
operator|=
name|max_loop_num
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
operator|!
name|loop_invalid
index|[
name|i
index|]
operator|&&
name|loop_number_loop_ends
index|[
name|i
index|]
condition|)
name|scan_loop
argument_list|(
name|loop_number_loop_starts
index|[
name|i
index|]
argument_list|,
name|loop_number_loop_ends
index|[
name|i
index|]
argument_list|,
name|max_reg_num
argument_list|()
argument_list|,
name|unroll_p
argument_list|)
expr_stmt|;
comment|/* If debugging and unrolling loops, we must replicate the tree nodes      corresponding to the blocks inside the loop, so that the original one      to one mapping will remain.  */
if|if
condition|(
name|unroll_p
operator|&&
name|write_symbols
operator|!=
name|NO_DEBUG
condition|)
name|unroll_block_trees
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Optimize one loop whose start is LOOP_START and end is END.    LOOP_START is the NOTE_INSN_LOOP_BEG and END is the matching    NOTE_INSN_LOOP_END.  */
end_comment

begin_comment
comment|/* ??? Could also move memory writes out of loops if the destination address    is invariant, the source is invariant, the memory write is not volatile,    and if we can prove that no read inside the loop can read this address    before the write occurs.  If there is a read of this address after the    write, then we can also mark the memory read as invariant.  */
end_comment

begin_function
specifier|static
name|void
name|scan_loop
parameter_list|(
name|loop_start
parameter_list|,
name|end
parameter_list|,
name|nregs
parameter_list|,
name|unroll_p
parameter_list|)
name|rtx
name|loop_start
decl_stmt|,
name|end
decl_stmt|;
name|int
name|nregs
decl_stmt|;
name|int
name|unroll_p
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|rtx
name|p
decl_stmt|;
comment|/* 1 if we are scanning insns that could be executed zero times.  */
name|int
name|maybe_never
init|=
literal|0
decl_stmt|;
comment|/* 1 if we are scanning insns that might never be executed      due to a subroutine call which might exit before they are reached.  */
name|int
name|call_passed
init|=
literal|0
decl_stmt|;
comment|/* For a rotated loop that is entered near the bottom,      this is the label at the top.  Otherwise it is zero.  */
name|rtx
name|loop_top
init|=
literal|0
decl_stmt|;
comment|/* Jump insn that enters the loop, or 0 if control drops in.  */
name|rtx
name|loop_entry_jump
init|=
literal|0
decl_stmt|;
comment|/* Place in the loop where control enters.  */
name|rtx
name|scan_start
decl_stmt|;
comment|/* Number of insns in the loop.  */
name|int
name|insn_count
decl_stmt|;
name|int
name|in_libcall
init|=
literal|0
decl_stmt|;
name|int
name|tem
decl_stmt|;
name|rtx
name|temp
decl_stmt|;
comment|/* The SET from an insn, if it is the only SET in the insn.  */
name|rtx
name|set
decl_stmt|,
name|set1
decl_stmt|;
comment|/* Chain describing insns movable in current loop.  */
name|struct
name|movable
modifier|*
name|movables
init|=
literal|0
decl_stmt|;
comment|/* Last element in `movables' -- so we can add elements at the end.  */
name|struct
name|movable
modifier|*
name|last_movable
init|=
literal|0
decl_stmt|;
comment|/* Ratio of extra register life span we can justify      for saving an instruction.  More if loop doesn't call subroutines      since in that case saving an insn makes more difference      and more registers are available.  */
name|int
name|threshold
decl_stmt|;
comment|/* If we have calls, contains the insn in which a register was used      if it was used exactly once; contains const0_rtx if it was used more      than once.  */
name|rtx
modifier|*
name|reg_single_usage
init|=
literal|0
decl_stmt|;
comment|/* Nonzero if we are scanning instructions in a sub-loop.  */
name|int
name|loop_depth
init|=
literal|0
decl_stmt|;
name|n_times_set
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|nregs
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|n_times_used
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|nregs
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|may_not_optimize
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|nregs
argument_list|)
expr_stmt|;
comment|/* Determine whether this loop starts with a jump down to a test at      the end.  This will occur for a small number of loops with a test      that is too complex to duplicate in front of the loop.       We search for the first insn or label in the loop, skipping NOTEs.      However, we must be careful not to skip past a NOTE_INSN_LOOP_BEG      (because we might have a loop executed only once that contains a      loop which starts with a jump to its exit test) or a NOTE_INSN_LOOP_END      (in case we have a degenerate loop).       Note that if we mistakenly think that a loop is entered at the top      when, in fact, it is entered at the exit test, the only effect will be      slightly poorer optimization.  Making the opposite error can generate      incorrect code.  Since very few loops now start with a jump to the       exit test, the code here to detect that case is very conservative.  */
for|for
control|(
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|loop_start
argument_list|)
init|;
name|p
operator|!=
name|end
operator|&&
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|!=
name|CODE_LABEL
operator|&&
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
argument_list|)
operator|!=
literal|'i'
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|!=
name|NOTE
operator|||
operator|(
name|NOTE_LINE_NUMBER
argument_list|(
name|p
argument_list|)
operator|!=
name|NOTE_INSN_LOOP_BEG
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|p
argument_list|)
operator|!=
name|NOTE_INSN_LOOP_END
operator|)
operator|)
condition|;
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
control|)
empty_stmt|;
name|scan_start
operator|=
name|p
expr_stmt|;
comment|/* Set up variables describing this loop.  */
name|prescan_loop
argument_list|(
name|loop_start
argument_list|,
name|end
argument_list|)
expr_stmt|;
name|threshold
operator|=
operator|(
name|loop_has_call
condition|?
literal|1
else|:
literal|2
operator|)
operator|*
operator|(
literal|1
operator|+
name|n_non_fixed_regs
operator|)
expr_stmt|;
comment|/* If loop has a jump before the first label,      the true entry is the target of that jump.      Start scan from there.      But record in LOOP_TOP the place where the end-test jumps      back to so we can scan that after the end of the loop.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|JUMP_INSN
condition|)
block|{
name|loop_entry_jump
operator|=
name|p
expr_stmt|;
comment|/* Loop entry must be unconditional jump (and not a RETURN)  */
if|if
condition|(
name|simplejump_p
argument_list|(
name|p
argument_list|)
operator|&&
name|JUMP_LABEL
argument_list|(
name|p
argument_list|)
operator|!=
literal|0
comment|/* Check to see whether the jump actually 	     jumps out of the loop (meaning it's no loop). 	     This case can happen for things like 	     do {..} while (0).  If this label was generated previously 	     by loop, we can't tell anything about it and have to reject 	     the loop.  */
operator|&&
name|INSN_UID
argument_list|(
name|JUMP_LABEL
argument_list|(
name|p
argument_list|)
argument_list|)
operator|<
name|max_uid_for_loop
operator|&&
name|INSN_LUID
argument_list|(
name|JUMP_LABEL
argument_list|(
name|p
argument_list|)
argument_list|)
operator|>=
name|INSN_LUID
argument_list|(
name|loop_start
argument_list|)
operator|&&
name|INSN_LUID
argument_list|(
name|JUMP_LABEL
argument_list|(
name|p
argument_list|)
argument_list|)
operator|<
name|INSN_LUID
argument_list|(
name|end
argument_list|)
condition|)
block|{
name|loop_top
operator|=
name|next_label
argument_list|(
name|scan_start
argument_list|)
expr_stmt|;
name|scan_start
operator|=
name|JUMP_LABEL
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If SCAN_START was an insn created by loop, we don't know its luid      as required by loop_reg_used_before_p.  So skip such loops.  (This      test may never be true, but it's best to play it safe.)        Also, skip loops where we do not start scanning at a label.  This      test also rejects loops starting with a JUMP_INSN that failed the      test above.  */
if|if
condition|(
name|INSN_UID
argument_list|(
name|scan_start
argument_list|)
operator|>=
name|max_uid_for_loop
operator|||
name|GET_CODE
argument_list|(
name|scan_start
argument_list|)
operator|!=
name|CODE_LABEL
condition|)
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"\nLoop from %d to %d is phony.\n\n"
argument_list|,
name|INSN_UID
argument_list|(
name|loop_start
argument_list|)
argument_list|,
name|INSN_UID
argument_list|(
name|end
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Count number of times each reg is set during this loop.      Set may_not_optimize[I] if it is not safe to move out      the setting of register I.  If this loop has calls, set      reg_single_usage[I].  */
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|n_times_set
argument_list|,
name|nregs
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|may_not_optimize
argument_list|,
name|nregs
argument_list|)
expr_stmt|;
if|if
condition|(
name|loop_has_call
condition|)
block|{
name|reg_single_usage
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|nregs
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|reg_single_usage
argument_list|,
name|nregs
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|count_loop_regs_set
argument_list|(
name|loop_top
condition|?
name|loop_top
else|:
name|loop_start
argument_list|,
name|end
argument_list|,
name|may_not_optimize
argument_list|,
name|reg_single_usage
argument_list|,
operator|&
name|insn_count
argument_list|,
name|nregs
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
name|may_not_optimize
index|[
name|i
index|]
operator|=
literal|1
operator|,
name|n_times_set
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|n_times_set
argument_list|,
operator|(
name|char
operator|*
operator|)
name|n_times_used
argument_list|,
name|nregs
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|loop_dump_stream
condition|)
block|{
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"\nLoop from %d to %d: %d real insns.\n"
argument_list|,
name|INSN_UID
argument_list|(
name|loop_start
argument_list|)
argument_list|,
name|INSN_UID
argument_list|(
name|end
argument_list|)
argument_list|,
name|insn_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|loop_continue
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Continue at insn %d.\n"
argument_list|,
name|INSN_UID
argument_list|(
name|loop_continue
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Scan through the loop finding insns that are safe to move.      Set n_times_set negative for the reg being set, so that      this reg will be considered invariant for subsequent insns.      We consider whether subsequent insns use the reg      in deciding whether it is worth actually moving.       MAYBE_NEVER is nonzero if we have passed a conditional jump insn      and therefore it is possible that the insns we are scanning      would never be executed.  At such times, we must make sure      that it is safe to execute the insn once instead of zero times.      When MAYBE_NEVER is 0, all insns will be executed at least once      so that is not a problem.  */
name|p
operator|=
name|scan_start
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* At end of a straight-in loop, we are done. 	 At end of a loop entered at the bottom, scan the top.  */
if|if
condition|(
name|p
operator|==
name|scan_start
condition|)
break|break;
if|if
condition|(
name|p
operator|==
name|end
condition|)
block|{
if|if
condition|(
name|loop_top
operator|!=
literal|0
condition|)
name|p
operator|=
name|loop_top
expr_stmt|;
else|else
break|break;
if|if
condition|(
name|p
operator|==
name|scan_start
condition|)
break|break;
block|}
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
argument_list|)
operator|==
literal|'i'
operator|&&
name|find_reg_note
argument_list|(
name|p
argument_list|,
name|REG_LIBCALL
argument_list|,
name|NULL_RTX
argument_list|)
condition|)
name|in_libcall
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
argument_list|)
operator|==
literal|'i'
operator|&&
name|find_reg_note
argument_list|(
name|p
argument_list|,
name|REG_RETVAL
argument_list|,
name|NULL_RTX
argument_list|)
condition|)
name|in_libcall
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|INSN
operator|&&
operator|(
name|set
operator|=
name|single_set
argument_list|(
name|p
argument_list|)
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
operator|!
name|may_not_optimize
index|[
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
index|]
condition|)
block|{
name|int
name|tem1
init|=
literal|0
decl_stmt|;
name|int
name|tem2
init|=
literal|0
decl_stmt|;
name|int
name|move_insn
init|=
literal|0
decl_stmt|;
name|rtx
name|src
init|=
name|SET_SRC
argument_list|(
name|set
argument_list|)
decl_stmt|;
name|rtx
name|dependencies
init|=
literal|0
decl_stmt|;
comment|/* Figure out what to use as a source of this insn.  If a REG_EQUIV 	     note is given or if a REG_EQUAL note with a constant operand is 	     specified, use it as the source and mark that we should move 	     this insn by calling emit_move_insn rather that duplicating the 	     insn.  	     Otherwise, only use the REG_EQUAL contents if a REG_RETVAL note 	     is present.  */
name|temp
operator|=
name|find_reg_note
argument_list|(
name|p
argument_list|,
name|REG_EQUIV
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
condition|)
name|src
operator|=
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
operator|,
name|move_insn
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|temp
operator|=
name|find_reg_note
argument_list|(
name|p
argument_list|,
name|REG_EQUAL
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|&&
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|src
operator|=
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
operator|,
name|move_insn
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|temp
operator|&&
name|find_reg_note
argument_list|(
name|p
argument_list|,
name|REG_RETVAL
argument_list|,
name|NULL_RTX
argument_list|)
condition|)
block|{
name|src
operator|=
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* A libcall block can use regs that don't appear in 		     the equivalent expression.  To move the libcall, 		     we must move those regs too.  */
name|dependencies
operator|=
name|libcall_other_reg
argument_list|(
name|p
argument_list|,
name|src
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Don't try to optimize a register that was made 	     by loop-optimization for an inner loop. 	     We don't know its life-span, so we can't compute the benefit.  */
if|if
condition|(
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|>=
name|max_reg_before_loop
condition|)
empty_stmt|;
comment|/* In order to move a register, we need to have either: 	     (1) it is used only in the same basic block as the set 	     (2) the set is guaranteed to be executed once the loop starts, 	         and the reg is not used until after that.  */
elseif|else
if|if
condition|(
operator|!
operator|(
name|reg_in_basic_block_p
argument_list|(
name|p
argument_list|,
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|||
operator|(
operator|!
name|maybe_never
operator|&&
operator|!
name|loop_reg_used_before_p
argument_list|(
name|set
argument_list|,
name|p
argument_list|,
name|loop_start
argument_list|,
name|scan_start
argument_list|,
name|end
argument_list|)
operator|)
operator|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
operator|(
name|tem
operator|=
name|invariant_p
argument_list|(
name|src
argument_list|)
operator|)
operator|&&
operator|(
name|dependencies
operator|==
literal|0
operator|||
operator|(
name|tem2
operator|=
name|invariant_p
argument_list|(
name|dependencies
argument_list|)
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|n_times_set
index|[
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
index|]
operator|==
literal|1
operator|||
operator|(
name|tem1
operator|=
name|consec_sets_invariant_p
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|,
name|n_times_set
index|[
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
index|]
argument_list|,
name|p
argument_list|)
operator|)
operator|)
comment|/* If the insn can cause a trap (such as divide by zero), 		      can't move it unless it's guaranteed to be executed 		      once loop is entered.  Even a function call might 		      prevent the trap insn from being reached 		      (since it might exit!)  */
operator|&&
operator|!
operator|(
operator|(
name|maybe_never
operator|||
name|call_passed
operator|)
operator|&&
name|may_trap_p
argument_list|(
name|src
argument_list|)
operator|)
condition|)
block|{
specifier|register
name|struct
name|movable
modifier|*
name|m
decl_stmt|;
specifier|register
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
decl_stmt|;
comment|/* A potential lossage is where we have a case where two insns 		 can be combined as long as they are both in the loop, but 		 we move one of them outside the loop.  For large loops, 		 this can lose.  The most common case of this is the address 		 of a function being called.    		 Therefore, if this register is marked as being used exactly 		 once if we are in a loop with calls (a "large loop"), see if 		 we can replace the usage of this register with the source 		 of this SET.  If we can, delete this insn.   		 Don't do this if P has a REG_RETVAL note or if we have 		 SMALL_REGISTER_CLASSES and SET_SRC is a hard register.  */
if|if
condition|(
name|reg_single_usage
operator|&&
name|reg_single_usage
index|[
name|regno
index|]
operator|!=
literal|0
operator|&&
name|reg_single_usage
index|[
name|regno
index|]
operator|!=
name|const0_rtx
operator|&&
name|REGNO_FIRST_UID
argument_list|(
name|regno
argument_list|)
operator|==
name|INSN_UID
argument_list|(
name|p
argument_list|)
operator|&&
operator|(
name|REGNO_LAST_UID
argument_list|(
name|regno
argument_list|)
operator|==
name|INSN_UID
argument_list|(
name|reg_single_usage
index|[
name|regno
index|]
argument_list|)
operator|)
operator|&&
name|n_times_set
index|[
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
index|]
operator|==
literal|1
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|&&
operator|!
name|find_reg_note
argument_list|(
name|p
argument_list|,
name|REG_RETVAL
argument_list|,
name|NULL_RTX
argument_list|)
operator|&&
operator|(
operator|!
name|SMALL_REGISTER_CLASSES
operator|||
operator|(
operator|!
operator|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|)
operator|)
operator|)
comment|/* This test is not redundant; SET_SRC (set) might be 		     a call-clobbered register and the life of REGNO 		     might span a call.  */
operator|&&
operator|!
name|modified_between_p
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
name|p
argument_list|,
name|reg_single_usage
index|[
name|regno
index|]
argument_list|)
operator|&&
name|no_labels_between_p
argument_list|(
name|p
argument_list|,
name|reg_single_usage
index|[
name|regno
index|]
argument_list|)
operator|&&
name|validate_replace_rtx
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|,
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
name|reg_single_usage
index|[
name|regno
index|]
argument_list|)
condition|)
block|{
comment|/* Replace any usage in a REG_EQUAL note.  Must copy the 		     new source, so that we don't get rtx sharing between the 		     SET_SOURCE and REG_NOTES of insn p.  */
name|REG_NOTES
argument_list|(
name|reg_single_usage
index|[
name|regno
index|]
argument_list|)
operator|=
name|replace_rtx
argument_list|(
name|REG_NOTES
argument_list|(
name|reg_single_usage
index|[
name|regno
index|]
argument_list|)
argument_list|,
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|,
name|copy_rtx
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|PUT_CODE
argument_list|(
name|p
argument_list|,
name|NOTE
argument_list|)
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|p
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|p
argument_list|)
operator|=
literal|0
expr_stmt|;
name|n_times_set
index|[
name|regno
index|]
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
name|m
operator|=
operator|(
expr|struct
name|movable
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|movable
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|->
name|next
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|insn
operator|=
name|p
expr_stmt|;
name|m
operator|->
name|set_src
operator|=
name|src
expr_stmt|;
name|m
operator|->
name|dependencies
operator|=
name|dependencies
expr_stmt|;
name|m
operator|->
name|set_dest
operator|=
name|SET_DEST
argument_list|(
name|set
argument_list|)
expr_stmt|;
name|m
operator|->
name|force
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|consec
operator|=
name|n_times_set
index|[
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
index|]
operator|-
literal|1
expr_stmt|;
name|m
operator|->
name|done
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|forces
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|partial
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|move_insn
operator|=
name|move_insn
expr_stmt|;
name|m
operator|->
name|move_insn_first
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|is_equiv
operator|=
operator|(
name|find_reg_note
argument_list|(
name|p
argument_list|,
name|REG_EQUIV
argument_list|,
name|NULL_RTX
argument_list|)
operator|!=
literal|0
operator|)
expr_stmt|;
name|m
operator|->
name|savemode
operator|=
name|VOIDmode
expr_stmt|;
name|m
operator|->
name|regno
operator|=
name|regno
expr_stmt|;
comment|/* Set M->cond if either invariant_p or consec_sets_invariant_p 		 returned 2 (only conditionally invariant).  */
name|m
operator|->
name|cond
operator|=
operator|(
operator|(
name|tem
operator||
name|tem1
operator||
name|tem2
operator|)
operator|>
literal|1
operator|)
expr_stmt|;
name|m
operator|->
name|global
operator|=
operator|(
name|uid_luid
index|[
name|REGNO_LAST_UID
argument_list|(
name|regno
argument_list|)
index|]
operator|>
name|INSN_LUID
argument_list|(
name|end
argument_list|)
operator|||
name|uid_luid
index|[
name|REGNO_FIRST_UID
argument_list|(
name|regno
argument_list|)
index|]
operator|<
name|INSN_LUID
argument_list|(
name|loop_start
argument_list|)
operator|)
expr_stmt|;
name|m
operator|->
name|match
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|lifetime
operator|=
operator|(
name|uid_luid
index|[
name|REGNO_LAST_UID
argument_list|(
name|regno
argument_list|)
index|]
operator|-
name|uid_luid
index|[
name|REGNO_FIRST_UID
argument_list|(
name|regno
argument_list|)
index|]
operator|)
expr_stmt|;
name|m
operator|->
name|savings
operator|=
name|n_times_used
index|[
name|regno
index|]
expr_stmt|;
if|if
condition|(
name|find_reg_note
argument_list|(
name|p
argument_list|,
name|REG_RETVAL
argument_list|,
name|NULL_RTX
argument_list|)
condition|)
name|m
operator|->
name|savings
operator|+=
name|libcall_benefit
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|n_times_set
index|[
name|regno
index|]
operator|=
name|move_insn
condition|?
operator|-
literal|2
else|:
operator|-
literal|1
expr_stmt|;
comment|/* Add M to the end of the chain MOVABLES.  */
if|if
condition|(
name|movables
operator|==
literal|0
condition|)
name|movables
operator|=
name|m
expr_stmt|;
else|else
name|last_movable
operator|->
name|next
operator|=
name|m
expr_stmt|;
name|last_movable
operator|=
name|m
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|consec
operator|>
literal|0
condition|)
block|{
comment|/* It is possible for the first instruction to have a 		     REG_EQUAL note but a non-invariant SET_SRC, so we must 		     remember the status of the first instruction in case 		     the last instruction doesn't have a REG_EQUAL note.  */
name|m
operator|->
name|move_insn_first
operator|=
name|m
operator|->
name|move_insn
expr_stmt|;
comment|/* Skip this insn, not checking REG_LIBCALL notes.  */
name|p
operator|=
name|next_nonnote_insn
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* Skip the consecutive insns, if there are any.  */
name|p
operator|=
name|skip_consec_insns
argument_list|(
name|p
argument_list|,
name|m
operator|->
name|consec
argument_list|)
expr_stmt|;
comment|/* Back up to the last insn of the consecutive group.  */
name|p
operator|=
name|prev_nonnote_insn
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* We must now reset m->move_insn, m->is_equiv, and possibly 		     m->set_src to correspond to the effects of all the 		     insns.  */
name|temp
operator|=
name|find_reg_note
argument_list|(
name|p
argument_list|,
name|REG_EQUIV
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
condition|)
name|m
operator|->
name|set_src
operator|=
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
operator|,
name|m
operator|->
name|move_insn
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|temp
operator|=
name|find_reg_note
argument_list|(
name|p
argument_list|,
name|REG_EQUAL
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|&&
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|m
operator|->
name|set_src
operator|=
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
operator|,
name|m
operator|->
name|move_insn
operator|=
literal|1
expr_stmt|;
else|else
name|m
operator|->
name|move_insn
operator|=
literal|0
expr_stmt|;
block|}
name|m
operator|->
name|is_equiv
operator|=
operator|(
name|find_reg_note
argument_list|(
name|p
argument_list|,
name|REG_EQUIV
argument_list|,
name|NULL_RTX
argument_list|)
operator|!=
literal|0
operator|)
expr_stmt|;
block|}
block|}
comment|/* If this register is always set within a STRICT_LOW_PART 	     or set to zero, then its high bytes are constant. 	     So clear them outside the loop and within the loop 	     just load the low bytes. 	     We must check that the machine has an instruction to do so. 	     Also, if the value loaded into the register 	     depends on the same register, this cannot be done.  */
elseif|else
if|if
condition|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
operator|==
name|const0_rtx
operator|&&
name|GET_CODE
argument_list|(
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
argument_list|)
operator|==
name|INSN
operator|&&
operator|(
name|set1
operator|=
name|single_set
argument_list|(
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
argument_list|)
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|set1
argument_list|)
operator|==
name|SET
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set1
argument_list|)
argument_list|)
operator|==
name|STRICT_LOW_PART
operator|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|set1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|)
operator|&&
operator|(
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|set1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SET_DEST
argument_list|(
name|set
argument_list|)
operator|)
operator|&&
operator|!
name|reg_mentioned_p
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|,
name|SET_SRC
argument_list|(
name|set1
argument_list|)
argument_list|)
condition|)
block|{
specifier|register
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|n_times_set
index|[
name|regno
index|]
operator|==
literal|2
condition|)
block|{
specifier|register
name|struct
name|movable
modifier|*
name|m
decl_stmt|;
name|m
operator|=
operator|(
expr|struct
name|movable
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|movable
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|->
name|next
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|insn
operator|=
name|p
expr_stmt|;
name|m
operator|->
name|set_dest
operator|=
name|SET_DEST
argument_list|(
name|set
argument_list|)
expr_stmt|;
name|m
operator|->
name|dependencies
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|force
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|consec
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|done
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|forces
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|move_insn
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|move_insn_first
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|partial
operator|=
literal|1
expr_stmt|;
comment|/* If the insn may not be executed on some cycles, 		     we can't clear the whole reg; clear just high part. 		     Not even if the reg is used only within this loop. 		     Consider this: 		     while (1) 		       while (s != t) { 		         if (foo ()) x = *s; 			 use (x); 		       } 		     Clearing x before the inner loop could clobber a value 		     being saved from the last time around the outer loop. 		     However, if the reg is not used outside this loop 		     and all uses of the register are in the same 		     basic block as the store, there is no problem.  		     If this insn was made by loop, we don't know its 		     INSN_LUID and hence must make a conservative 		     assumption.  */
name|m
operator|->
name|global
operator|=
operator|(
name|INSN_UID
argument_list|(
name|p
argument_list|)
operator|>=
name|max_uid_for_loop
operator|||
operator|(
name|uid_luid
index|[
name|REGNO_LAST_UID
argument_list|(
name|regno
argument_list|)
index|]
operator|>
name|INSN_LUID
argument_list|(
name|end
argument_list|)
operator|)
operator|||
operator|(
name|uid_luid
index|[
name|REGNO_FIRST_UID
argument_list|(
name|regno
argument_list|)
index|]
operator|<
name|INSN_LUID
argument_list|(
name|p
argument_list|)
operator|)
operator|||
operator|(
name|labels_in_range_p
argument_list|(
name|p
argument_list|,
name|uid_luid
index|[
name|REGNO_FIRST_UID
argument_list|(
name|regno
argument_list|)
index|]
argument_list|)
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|maybe_never
operator|&&
name|m
operator|->
name|global
condition|)
name|m
operator|->
name|savemode
operator|=
name|GET_MODE
argument_list|(
name|SET_SRC
argument_list|(
name|set1
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|m
operator|->
name|savemode
operator|=
name|VOIDmode
expr_stmt|;
name|m
operator|->
name|regno
operator|=
name|regno
expr_stmt|;
name|m
operator|->
name|cond
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|match
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|lifetime
operator|=
operator|(
name|uid_luid
index|[
name|REGNO_LAST_UID
argument_list|(
name|regno
argument_list|)
index|]
operator|-
name|uid_luid
index|[
name|REGNO_FIRST_UID
argument_list|(
name|regno
argument_list|)
index|]
operator|)
expr_stmt|;
name|m
operator|->
name|savings
operator|=
literal|1
expr_stmt|;
name|n_times_set
index|[
name|regno
index|]
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Add M to the end of the chain MOVABLES.  */
if|if
condition|(
name|movables
operator|==
literal|0
condition|)
name|movables
operator|=
name|m
expr_stmt|;
else|else
name|last_movable
operator|->
name|next
operator|=
name|m
expr_stmt|;
name|last_movable
operator|=
name|m
expr_stmt|;
block|}
block|}
block|}
comment|/* Past a call insn, we get to insns which might not be executed 	 because the call might exit.  This matters for insns that trap. 	 Call insns inside a REG_LIBCALL/REG_RETVAL block always return, 	 so they don't count.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|CALL_INSN
operator|&&
operator|!
name|in_libcall
condition|)
name|call_passed
operator|=
literal|1
expr_stmt|;
comment|/* Past a label or a jump, we get to insns for which we 	 can't count on whether or how many times they will be 	 executed during each iteration.  Therefore, we can 	 only move out sets of trivial variables 	 (those not used after the loop).  */
comment|/* Similar code appears twice in strength_reduce.  */
elseif|else
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|CODE_LABEL
operator|||
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|JUMP_INSN
operator|)
comment|/* If we enter the loop in the middle, and scan around to the 		  beginning, don't set maybe_never for that.  This must be an 		  unconditional jump, otherwise the code at the top of the 		  loop might never be executed.  Unconditional jumps are 		  followed a by barrier then loop end.  */
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|JUMP_LABEL
argument_list|(
name|p
argument_list|)
operator|==
name|loop_top
operator|&&
name|NEXT_INSN
argument_list|(
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
argument_list|)
operator|==
name|end
operator|&&
name|simplejump_p
argument_list|(
name|p
argument_list|)
operator|)
condition|)
name|maybe_never
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|NOTE
condition|)
block|{
comment|/* At the virtual top of a converted loop, insns are again known to 	     be executed: logically, the loop begins here even though the exit 	     code has been duplicated.  */
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|p
argument_list|)
operator|==
name|NOTE_INSN_LOOP_VTOP
operator|&&
name|loop_depth
operator|==
literal|0
condition|)
name|maybe_never
operator|=
name|call_passed
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|p
argument_list|)
operator|==
name|NOTE_INSN_LOOP_BEG
condition|)
name|loop_depth
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|p
argument_list|)
operator|==
name|NOTE_INSN_LOOP_END
condition|)
name|loop_depth
operator|--
expr_stmt|;
block|}
block|}
comment|/* If one movable subsumes another, ignore that other.  */
name|ignore_some_movables
argument_list|(
name|movables
argument_list|)
expr_stmt|;
comment|/* For each movable insn, see if the reg that it loads      leads when it dies right into another conditionally movable insn.      If so, record that the second insn "forces" the first one,      since the second can be moved only if the first is.  */
name|force_movables
argument_list|(
name|movables
argument_list|)
expr_stmt|;
comment|/* See if there are multiple movable insns that load the same value.      If there are, make all but the first point at the first one      through the `match' field, and add the priorities of them      all together as the priority of the first.  */
name|combine_movables
argument_list|(
name|movables
argument_list|,
name|nregs
argument_list|)
expr_stmt|;
comment|/* Now consider each movable insn to decide whether it is worth moving.      Store 0 in n_times_set for each reg that is moved.       Generally this increases code size, so do not move moveables when      optimizing for code size.  */
if|if
condition|(
operator|!
name|optimize_size
condition|)
name|move_movables
argument_list|(
name|movables
argument_list|,
name|threshold
argument_list|,
name|insn_count
argument_list|,
name|loop_start
argument_list|,
name|end
argument_list|,
name|nregs
argument_list|)
expr_stmt|;
comment|/* Now candidates that still are negative are those not moved.      Change n_times_set to indicate that those are not actually invariant.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nregs
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|n_times_set
index|[
name|i
index|]
operator|<
literal|0
condition|)
name|n_times_set
index|[
name|i
index|]
operator|=
name|n_times_used
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|flag_strength_reduce
condition|)
name|strength_reduce
argument_list|(
name|scan_start
argument_list|,
name|end
argument_list|,
name|loop_top
argument_list|,
name|insn_count
argument_list|,
name|loop_start
argument_list|,
name|end
argument_list|,
name|unroll_p
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Add elements to *OUTPUT to record all the pseudo-regs    mentioned in IN_THIS but not mentioned in NOT_IN_THIS.  */
end_comment

begin_function
name|void
name|record_excess_regs
parameter_list|(
name|in_this
parameter_list|,
name|not_in_this
parameter_list|,
name|output
parameter_list|)
name|rtx
name|in_this
decl_stmt|,
name|not_in_this
decl_stmt|;
name|rtx
modifier|*
name|output
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
decl_stmt|;
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|i
decl_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|in_this
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PC
case|:
case|case
name|CC0
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CONST
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
return|return;
case|case
name|REG
case|:
if|if
condition|(
name|REGNO
argument_list|(
name|in_this
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
operator|!
name|reg_mentioned_p
argument_list|(
name|in_this
argument_list|,
name|not_in_this
argument_list|)
condition|)
operator|*
name|output
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|in_this
argument_list|,
operator|*
name|output
argument_list|)
expr_stmt|;
return|return;
default|default:
break|break;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|int
name|j
decl_stmt|;
switch|switch
condition|(
name|fmt
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'E'
case|:
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|in_this
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|record_excess_regs
argument_list|(
name|XVECEXP
argument_list|(
name|in_this
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|not_in_this
argument_list|,
name|output
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|record_excess_regs
argument_list|(
name|XEXP
argument_list|(
name|in_this
argument_list|,
name|i
argument_list|)
argument_list|,
name|not_in_this
argument_list|,
name|output
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Check what regs are referred to in the libcall block ending with INSN,    aside from those mentioned in the equivalent value.    If there are none, return 0.    If there are one or more, return an EXPR_LIST containing all of them.  */
end_comment

begin_function
specifier|static
name|rtx
name|libcall_other_reg
parameter_list|(
name|insn
parameter_list|,
name|equiv
parameter_list|)
name|rtx
name|insn
decl_stmt|,
name|equiv
decl_stmt|;
block|{
name|rtx
name|note
init|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_RETVAL
argument_list|,
name|NULL_RTX
argument_list|)
decl_stmt|;
name|rtx
name|p
init|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|output
init|=
literal|0
decl_stmt|;
comment|/* First, find all the regs used in the libcall block      that are not mentioned as inputs to the result.  */
while|while
condition|(
name|p
operator|!=
name|insn
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|JUMP_INSN
operator|||
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|CALL_INSN
condition|)
name|record_excess_regs
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|,
name|equiv
argument_list|,
operator|&
name|output
argument_list|)
expr_stmt|;
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
return|return
name|output
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if all uses of REG    are between INSN and the end of the basic block.  */
end_comment

begin_function
specifier|static
name|int
name|reg_in_basic_block_p
parameter_list|(
name|insn
parameter_list|,
name|reg
parameter_list|)
name|rtx
name|insn
decl_stmt|,
name|reg
decl_stmt|;
block|{
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|reg
argument_list|)
decl_stmt|;
name|rtx
name|p
decl_stmt|;
if|if
condition|(
name|REGNO_FIRST_UID
argument_list|(
name|regno
argument_list|)
operator|!=
name|INSN_UID
argument_list|(
name|insn
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Search this basic block for the already recorded last use of the reg.  */
for|for
control|(
name|p
operator|=
name|insn
init|;
name|p
condition|;
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
control|)
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
condition|)
block|{
case|case
name|NOTE
case|:
break|break;
case|case
name|INSN
case|:
case|case
name|CALL_INSN
case|:
comment|/* Ordinary insn: if this is the last use, we win.  */
if|if
condition|(
name|REGNO_LAST_UID
argument_list|(
name|regno
argument_list|)
operator|==
name|INSN_UID
argument_list|(
name|p
argument_list|)
condition|)
return|return
literal|1
return|;
break|break;
case|case
name|JUMP_INSN
case|:
comment|/* Jump insn: if this is the last use, we win.  */
if|if
condition|(
name|REGNO_LAST_UID
argument_list|(
name|regno
argument_list|)
operator|==
name|INSN_UID
argument_list|(
name|p
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Otherwise, it's the end of the basic block, so we lose.  */
return|return
literal|0
return|;
case|case
name|CODE_LABEL
case|:
case|case
name|BARRIER
case|:
comment|/* It's the end of the basic block, so we lose.  */
return|return
literal|0
return|;
default|default:
break|break;
block|}
block|}
comment|/* The "last use" doesn't follow the "first use"??  */
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Compute the benefit of eliminating the insns in the block whose    last insn is LAST.  This may be a group of insns used to compute a    value directly or can contain a library call.  */
end_comment

begin_function
specifier|static
name|int
name|libcall_benefit
parameter_list|(
name|last
parameter_list|)
name|rtx
name|last
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|;
name|int
name|benefit
init|=
literal|0
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|XEXP
argument_list|(
name|find_reg_note
argument_list|(
name|last
argument_list|,
name|REG_RETVAL
argument_list|,
name|NULL_RTX
argument_list|)
argument_list|,
literal|0
argument_list|)
init|;
name|insn
operator|!=
name|last
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
name|benefit
operator|+=
literal|10
expr_stmt|;
comment|/* Assume at least this many insns in a library 				   routine.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|USE
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|CLOBBER
condition|)
name|benefit
operator|++
expr_stmt|;
block|}
return|return
name|benefit
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Skip COUNT insns from INSN, counting library calls as 1 insn.  */
end_comment

begin_function
specifier|static
name|rtx
name|skip_consec_insns
parameter_list|(
name|insn
parameter_list|,
name|count
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|int
name|count
decl_stmt|;
block|{
for|for
control|(
init|;
name|count
operator|>
literal|0
condition|;
name|count
operator|--
control|)
block|{
name|rtx
name|temp
decl_stmt|;
comment|/* If first insn of libcall sequence, skip to end.  */
comment|/* Do this at start of loop, since INSN is guaranteed to  	 be an insn here.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE
operator|&&
operator|(
name|temp
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_LIBCALL
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
condition|)
name|insn
operator|=
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
do|do
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
do|while
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
do|;
block|}
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Ignore any movable whose insn falls within a libcall    which is part of another movable.    We make use of the fact that the movable for the libcall value    was made later and so appears later on the chain.  */
end_comment

begin_function
specifier|static
name|void
name|ignore_some_movables
parameter_list|(
name|movables
parameter_list|)
name|struct
name|movable
modifier|*
name|movables
decl_stmt|;
block|{
specifier|register
name|struct
name|movable
modifier|*
name|m
decl_stmt|,
modifier|*
name|m1
decl_stmt|;
for|for
control|(
name|m
operator|=
name|movables
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|next
control|)
block|{
comment|/* Is this a movable for the value of a libcall?  */
name|rtx
name|note
init|=
name|find_reg_note
argument_list|(
name|m
operator|->
name|insn
argument_list|,
name|REG_RETVAL
argument_list|,
name|NULL_RTX
argument_list|)
decl_stmt|;
if|if
condition|(
name|note
condition|)
block|{
name|rtx
name|insn
decl_stmt|;
comment|/* Check for earlier movables inside that range, 	     and mark them invalid.  We cannot use LUIDs here because 	     insns created by loop.c for prior loops don't have LUIDs. 	     Rather than reject all such insns from movables, we just 	     explicitly check each insn in the libcall (since invariant 	     libcalls aren't that common).  */
for|for
control|(
name|insn
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
init|;
name|insn
operator|!=
name|m
operator|->
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
for|for
control|(
name|m1
operator|=
name|movables
init|;
name|m1
operator|!=
name|m
condition|;
name|m1
operator|=
name|m1
operator|->
name|next
control|)
if|if
condition|(
name|m1
operator|->
name|insn
operator|==
name|insn
condition|)
name|m1
operator|->
name|done
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* For each movable insn, see if the reg that it loads    leads when it dies right into another conditionally movable insn.    If so, record that the second insn "forces" the first one,    since the second can be moved only if the first is.  */
end_comment

begin_function
specifier|static
name|void
name|force_movables
parameter_list|(
name|movables
parameter_list|)
name|struct
name|movable
modifier|*
name|movables
decl_stmt|;
block|{
specifier|register
name|struct
name|movable
modifier|*
name|m
decl_stmt|,
modifier|*
name|m1
decl_stmt|;
for|for
control|(
name|m1
operator|=
name|movables
init|;
name|m1
condition|;
name|m1
operator|=
name|m1
operator|->
name|next
control|)
comment|/* Omit this if moving just the (SET (REG) 0) of a zero-extend.  */
if|if
condition|(
operator|!
name|m1
operator|->
name|partial
operator|&&
operator|!
name|m1
operator|->
name|done
condition|)
block|{
name|int
name|regno
init|=
name|m1
operator|->
name|regno
decl_stmt|;
for|for
control|(
name|m
operator|=
name|m1
operator|->
name|next
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|next
control|)
comment|/* ??? Could this be a bug?  What if CSE caused the 	     register of M1 to be used after this insn? 	     Since CSE does not update regno_last_uid, 	     this insn M->insn might not be where it dies. 	     But very likely this doesn't matter; what matters is 	     that M's reg is computed from M1's reg.  */
if|if
condition|(
name|INSN_UID
argument_list|(
name|m
operator|->
name|insn
argument_list|)
operator|==
name|REGNO_LAST_UID
argument_list|(
name|regno
argument_list|)
operator|&&
operator|!
name|m
operator|->
name|done
condition|)
break|break;
if|if
condition|(
name|m
operator|!=
literal|0
operator|&&
name|m
operator|->
name|set_src
operator|==
name|m1
operator|->
name|set_dest
comment|/* If m->consec, m->set_src isn't valid.  */
operator|&&
name|m
operator|->
name|consec
operator|==
literal|0
condition|)
name|m
operator|=
literal|0
expr_stmt|;
comment|/* Increase the priority of the moving the first insn 	   since it permits the second to be moved as well.  */
if|if
condition|(
name|m
operator|!=
literal|0
condition|)
block|{
name|m
operator|->
name|forces
operator|=
name|m1
expr_stmt|;
name|m1
operator|->
name|lifetime
operator|+=
name|m
operator|->
name|lifetime
expr_stmt|;
name|m1
operator|->
name|savings
operator|+=
name|m
operator|->
name|savings
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Find invariant expressions that are equal and can be combined into    one register.  */
end_comment

begin_function
specifier|static
name|void
name|combine_movables
parameter_list|(
name|movables
parameter_list|,
name|nregs
parameter_list|)
name|struct
name|movable
modifier|*
name|movables
decl_stmt|;
name|int
name|nregs
decl_stmt|;
block|{
specifier|register
name|struct
name|movable
modifier|*
name|m
decl_stmt|;
name|char
modifier|*
name|matched_regs
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|nregs
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
comment|/* Regs that are set more than once are not allowed to match      or be matched.  I'm no longer sure why not.  */
comment|/* Perhaps testing m->consec_sets would be more appropriate here?  */
for|for
control|(
name|m
operator|=
name|movables
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|next
control|)
if|if
condition|(
name|m
operator|->
name|match
operator|==
literal|0
operator|&&
name|n_times_used
index|[
name|m
operator|->
name|regno
index|]
operator|==
literal|1
operator|&&
operator|!
name|m
operator|->
name|partial
condition|)
block|{
specifier|register
name|struct
name|movable
modifier|*
name|m1
decl_stmt|;
name|int
name|regno
init|=
name|m
operator|->
name|regno
decl_stmt|;
name|bzero
argument_list|(
name|matched_regs
argument_list|,
name|nregs
argument_list|)
expr_stmt|;
name|matched_regs
index|[
name|regno
index|]
operator|=
literal|1
expr_stmt|;
comment|/* We want later insns to match the first one.  Don't make the first 	   one match any later ones.  So start this loop at m->next.  */
for|for
control|(
name|m1
operator|=
name|m
operator|->
name|next
init|;
name|m1
condition|;
name|m1
operator|=
name|m1
operator|->
name|next
control|)
if|if
condition|(
name|m
operator|!=
name|m1
operator|&&
name|m1
operator|->
name|match
operator|==
literal|0
operator|&&
name|n_times_used
index|[
name|m1
operator|->
name|regno
index|]
operator|==
literal|1
comment|/* A reg used outside the loop mustn't be eliminated.  */
operator|&&
operator|!
name|m1
operator|->
name|global
comment|/* A reg used for zero-extending mustn't be eliminated.  */
operator|&&
operator|!
name|m1
operator|->
name|partial
operator|&&
operator|(
name|matched_regs
index|[
name|m1
operator|->
name|regno
index|]
operator|||
operator|(
comment|/* Can combine regs with different modes loaded from the 		      same constant only if the modes are the same or 		      if both are integer modes with M wider or the same 		      width as M1.  The check for integer is redundant, but 		      safe, since the only case of differing destination 		      modes with equal sources is when both sources are 		      VOIDmode, i.e., CONST_INT.  */
operator|(
name|GET_MODE
argument_list|(
name|m
operator|->
name|set_dest
argument_list|)
operator|==
name|GET_MODE
argument_list|(
name|m1
operator|->
name|set_dest
argument_list|)
operator|||
operator|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|m
operator|->
name|set_dest
argument_list|)
argument_list|)
operator|==
name|MODE_INT
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|m1
operator|->
name|set_dest
argument_list|)
argument_list|)
operator|==
name|MODE_INT
operator|&&
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|m
operator|->
name|set_dest
argument_list|)
argument_list|)
operator|>=
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|m1
operator|->
name|set_dest
argument_list|)
argument_list|)
operator|)
operator|)
operator|)
comment|/* See if the source of M1 says it matches M.  */
operator|&&
operator|(
operator|(
name|GET_CODE
argument_list|(
name|m1
operator|->
name|set_src
argument_list|)
operator|==
name|REG
operator|&&
name|matched_regs
index|[
name|REGNO
argument_list|(
name|m1
operator|->
name|set_src
argument_list|)
index|]
operator|)
operator|||
name|rtx_equal_for_loop_p
argument_list|(
name|m
operator|->
name|set_src
argument_list|,
name|m1
operator|->
name|set_src
argument_list|,
name|movables
argument_list|)
operator|)
operator|)
operator|)
operator|&&
operator|(
operator|(
name|m
operator|->
name|dependencies
operator|==
name|m1
operator|->
name|dependencies
operator|)
operator|||
name|rtx_equal_p
argument_list|(
name|m
operator|->
name|dependencies
argument_list|,
name|m1
operator|->
name|dependencies
argument_list|)
operator|)
condition|)
block|{
name|m
operator|->
name|lifetime
operator|+=
name|m1
operator|->
name|lifetime
expr_stmt|;
name|m
operator|->
name|savings
operator|+=
name|m1
operator|->
name|savings
expr_stmt|;
name|m1
operator|->
name|done
operator|=
literal|1
expr_stmt|;
name|m1
operator|->
name|match
operator|=
name|m
expr_stmt|;
name|matched_regs
index|[
name|m1
operator|->
name|regno
index|]
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* Now combine the regs used for zero-extension.      This can be done for those not marked `global'      provided their lives don't overlap.  */
for|for
control|(
name|mode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_INT
argument_list|)
init|;
name|mode
operator|!=
name|VOIDmode
condition|;
name|mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
control|)
block|{
specifier|register
name|struct
name|movable
modifier|*
name|m0
init|=
literal|0
decl_stmt|;
comment|/* Combine all the registers for extension from mode MODE. 	 Don't combine any that are used outside this loop.  */
for|for
control|(
name|m
operator|=
name|movables
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|next
control|)
if|if
condition|(
name|m
operator|->
name|partial
operator|&&
operator|!
name|m
operator|->
name|global
operator|&&
name|mode
operator|==
name|GET_MODE
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|NEXT_INSN
argument_list|(
name|m
operator|->
name|insn
argument_list|)
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
specifier|register
name|struct
name|movable
modifier|*
name|m1
decl_stmt|;
name|int
name|first
init|=
name|uid_luid
index|[
name|REGNO_FIRST_UID
argument_list|(
name|m
operator|->
name|regno
argument_list|)
index|]
decl_stmt|;
name|int
name|last
init|=
name|uid_luid
index|[
name|REGNO_LAST_UID
argument_list|(
name|m
operator|->
name|regno
argument_list|)
index|]
decl_stmt|;
if|if
condition|(
name|m0
operator|==
literal|0
condition|)
block|{
comment|/* First one: don't check for overlap, just record it.  */
name|m0
operator|=
name|m
expr_stmt|;
continue|continue;
block|}
comment|/* Make sure they extend to the same mode. 	       (Almost always true.)  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|m
operator|->
name|set_dest
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|m0
operator|->
name|set_dest
argument_list|)
condition|)
continue|continue;
comment|/* We already have one: check for overlap with those 	       already combined together.  */
for|for
control|(
name|m1
operator|=
name|movables
init|;
name|m1
operator|!=
name|m
condition|;
name|m1
operator|=
name|m1
operator|->
name|next
control|)
if|if
condition|(
name|m1
operator|==
name|m0
operator|||
operator|(
name|m1
operator|->
name|partial
operator|&&
name|m1
operator|->
name|match
operator|==
name|m0
operator|)
condition|)
if|if
condition|(
operator|!
operator|(
name|uid_luid
index|[
name|REGNO_FIRST_UID
argument_list|(
name|m1
operator|->
name|regno
argument_list|)
index|]
operator|>
name|last
operator|||
name|uid_luid
index|[
name|REGNO_LAST_UID
argument_list|(
name|m1
operator|->
name|regno
argument_list|)
index|]
operator|<
name|first
operator|)
condition|)
goto|goto
name|overlap
goto|;
comment|/* No overlap: we can combine this with the others.  */
name|m0
operator|->
name|lifetime
operator|+=
name|m
operator|->
name|lifetime
expr_stmt|;
name|m0
operator|->
name|savings
operator|+=
name|m
operator|->
name|savings
expr_stmt|;
name|m
operator|->
name|done
operator|=
literal|1
expr_stmt|;
name|m
operator|->
name|match
operator|=
name|m0
expr_stmt|;
name|overlap
label|:
empty_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if regs X and Y will become the same if moved.  */
end_comment

begin_function
specifier|static
name|int
name|regs_match_p
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|movables
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|y
decl_stmt|;
name|struct
name|movable
modifier|*
name|movables
decl_stmt|;
block|{
name|int
name|xn
init|=
name|REGNO
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|int
name|yn
init|=
name|REGNO
argument_list|(
name|y
argument_list|)
decl_stmt|;
name|struct
name|movable
modifier|*
name|mx
decl_stmt|,
modifier|*
name|my
decl_stmt|;
for|for
control|(
name|mx
operator|=
name|movables
init|;
name|mx
condition|;
name|mx
operator|=
name|mx
operator|->
name|next
control|)
if|if
condition|(
name|mx
operator|->
name|regno
operator|==
name|xn
condition|)
break|break;
for|for
control|(
name|my
operator|=
name|movables
init|;
name|my
condition|;
name|my
operator|=
name|my
operator|->
name|next
control|)
if|if
condition|(
name|my
operator|->
name|regno
operator|==
name|yn
condition|)
break|break;
return|return
operator|(
name|mx
operator|&&
name|my
operator|&&
operator|(
operator|(
name|mx
operator|->
name|match
operator|==
name|my
operator|->
name|match
operator|&&
name|mx
operator|->
name|match
operator|!=
literal|0
operator|)
operator|||
name|mx
operator|->
name|match
operator|==
name|my
operator|||
name|mx
operator|==
name|my
operator|->
name|match
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if X and Y are identical-looking rtx's.    This is the Lisp function EQUAL for rtx arguments.     If two registers are matching movables or a movable register and an    equivalent constant, consider them equal.  */
end_comment

begin_function
specifier|static
name|int
name|rtx_equal_for_loop_p
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|movables
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|y
decl_stmt|;
name|struct
name|movable
modifier|*
name|movables
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
specifier|register
name|struct
name|movable
modifier|*
name|m
decl_stmt|;
specifier|register
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|x
operator|==
name|y
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|x
operator|==
literal|0
operator|||
name|y
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* If we have a register and a constant, they may sometimes be      equal.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
operator|&&
name|n_times_set
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
operator|==
operator|-
literal|2
operator|&&
name|CONSTANT_P
argument_list|(
name|y
argument_list|)
condition|)
block|{
for|for
control|(
name|m
operator|=
name|movables
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|next
control|)
if|if
condition|(
name|m
operator|->
name|move_insn
operator|&&
name|m
operator|->
name|regno
operator|==
name|REGNO
argument_list|(
name|x
argument_list|)
operator|&&
name|rtx_equal_p
argument_list|(
name|m
operator|->
name|set_src
argument_list|,
name|y
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|REG
operator|&&
name|n_times_set
index|[
name|REGNO
argument_list|(
name|y
argument_list|)
index|]
operator|==
operator|-
literal|2
operator|&&
name|CONSTANT_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
for|for
control|(
name|m
operator|=
name|movables
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|next
control|)
if|if
condition|(
name|m
operator|->
name|move_insn
operator|&&
name|m
operator|->
name|regno
operator|==
name|REGNO
argument_list|(
name|y
argument_list|)
operator|&&
name|rtx_equal_p
argument_list|(
name|m
operator|->
name|set_src
argument_list|,
name|x
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
comment|/* Otherwise, rtx's of different codes cannot be equal.  */
if|if
condition|(
name|code
operator|!=
name|GET_CODE
argument_list|(
name|y
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* (MULT:SI x y) and (MULT:HI x y) are NOT equivalent.      (REG:SI x) and (REG:HI x) are NOT equivalent.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|y
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* These three types of rtx's can be compared nonrecursively.  */
if|if
condition|(
name|code
operator|==
name|REG
condition|)
return|return
operator|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|==
name|REGNO
argument_list|(
name|y
argument_list|)
operator|||
name|regs_match_p
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|movables
argument_list|)
operator|)
return|;
if|if
condition|(
name|code
operator|==
name|LABEL_REF
condition|)
return|return
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|SYMBOL_REF
condition|)
return|return
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|XSTR
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
return|;
comment|/* Compare the elements.  If any pair of corresponding elements      fail to match, return 0 for the whole things.  */
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
switch|switch
condition|(
name|fmt
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'w'
case|:
if|if
condition|(
name|XWINT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
name|XWINT
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'i'
case|:
if|if
condition|(
name|XINT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
name|XINT
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'E'
case|:
comment|/* Two vectors must have the same length.  */
if|if
condition|(
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
name|XVECLEN
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* And the corresponding elements must match.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|rtx_equal_for_loop_p
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|XVECEXP
argument_list|(
name|y
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|movables
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'e'
case|:
if|if
condition|(
name|rtx_equal_for_loop_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
argument_list|,
name|movables
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'s'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|XSTR
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|XSTR
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'u'
case|:
comment|/* These are just backpointers, so they don't matter.  */
break|break;
case|case
literal|'0'
case|:
break|break;
comment|/* It is believed that rtx's at this level will never 	     contain anything but integers and other rtx's, 	     except for within LABEL_REFs and SYMBOL_REFs.  */
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If X contains any LABEL_REF's, add REG_LABEL notes for them to all   insns in INSNS which use thet reference.  */
end_comment

begin_function
specifier|static
name|void
name|add_label_notes
parameter_list|(
name|x
parameter_list|,
name|insns
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|rtx
name|insns
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|char
modifier|*
name|fmt
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|LABEL_REF
operator|&&
operator|!
name|LABEL_REF_NONLOCAL_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
comment|/* This code used to ignore labels that referred to dispatch tables to          avoid flow generating (slighly) worse code.           We no longer ignore such label references (see LABEL_REF handling in          mark_jump_label for additional information).  */
for|for
control|(
name|insn
operator|=
name|insns
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|reg_mentioned_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn
argument_list|)
condition|)
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_LABEL
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|add_label_notes
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|insns
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
name|add_label_notes
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|insns
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Scan MOVABLES, and move the insns that deserve to be moved.    If two matching movables are combined, replace one reg with the    other throughout.  */
end_comment

begin_function
specifier|static
name|void
name|move_movables
parameter_list|(
name|movables
parameter_list|,
name|threshold
parameter_list|,
name|insn_count
parameter_list|,
name|loop_start
parameter_list|,
name|end
parameter_list|,
name|nregs
parameter_list|)
name|struct
name|movable
modifier|*
name|movables
decl_stmt|;
name|int
name|threshold
decl_stmt|;
name|int
name|insn_count
decl_stmt|;
name|rtx
name|loop_start
decl_stmt|;
name|rtx
name|end
decl_stmt|;
name|int
name|nregs
decl_stmt|;
block|{
name|rtx
name|new_start
init|=
literal|0
decl_stmt|;
specifier|register
name|struct
name|movable
modifier|*
name|m
decl_stmt|;
specifier|register
name|rtx
name|p
decl_stmt|;
comment|/* Map of pseudo-register replacements to handle combining      when we move several insns that load the same value      into different pseudo-registers.  */
name|rtx
modifier|*
name|reg_map
init|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|nregs
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
decl_stmt|;
name|char
modifier|*
name|already_moved
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|nregs
argument_list|)
decl_stmt|;
name|bzero
argument_list|(
name|already_moved
argument_list|,
name|nregs
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|reg_map
argument_list|,
name|nregs
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|num_movables
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|m
operator|=
name|movables
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|next
control|)
block|{
comment|/* Describe this movable insn.  */
if|if
condition|(
name|loop_dump_stream
condition|)
block|{
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Insn %d: regno %d (life %d), "
argument_list|,
name|INSN_UID
argument_list|(
name|m
operator|->
name|insn
argument_list|)
argument_list|,
name|m
operator|->
name|regno
argument_list|,
name|m
operator|->
name|lifetime
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|consec
operator|>
literal|0
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"consec %d, "
argument_list|,
name|m
operator|->
name|consec
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|cond
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"cond "
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|force
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"force "
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|global
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"global "
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|done
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"done "
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|move_insn
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"move-insn "
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|match
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"matches %d "
argument_list|,
name|INSN_UID
argument_list|(
name|m
operator|->
name|match
operator|->
name|insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|forces
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"forces %d "
argument_list|,
name|INSN_UID
argument_list|(
name|m
operator|->
name|forces
operator|->
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Count movables.  Value used in heuristics in strength_reduce.  */
name|num_movables
operator|++
expr_stmt|;
comment|/* Ignore the insn if it's already done (it matched something else). 	 Otherwise, see if it is now safe to move.  */
if|if
condition|(
operator|!
name|m
operator|->
name|done
operator|&&
operator|(
operator|!
name|m
operator|->
name|cond
operator|||
operator|(
literal|1
operator|==
name|invariant_p
argument_list|(
name|m
operator|->
name|set_src
argument_list|)
operator|&&
operator|(
name|m
operator|->
name|dependencies
operator|==
literal|0
operator|||
literal|1
operator|==
name|invariant_p
argument_list|(
name|m
operator|->
name|dependencies
argument_list|)
operator|)
operator|&&
operator|(
name|m
operator|->
name|consec
operator|==
literal|0
operator|||
literal|1
operator|==
name|consec_sets_invariant_p
argument_list|(
name|m
operator|->
name|set_dest
argument_list|,
name|m
operator|->
name|consec
operator|+
literal|1
argument_list|,
name|m
operator|->
name|insn
argument_list|)
operator|)
operator|)
operator|)
operator|&&
operator|(
operator|!
name|m
operator|->
name|forces
operator|||
name|m
operator|->
name|forces
operator|->
name|done
operator|)
condition|)
block|{
specifier|register
name|int
name|regno
decl_stmt|;
specifier|register
name|rtx
name|p
decl_stmt|;
name|int
name|savings
init|=
name|m
operator|->
name|savings
decl_stmt|;
comment|/* We have an insn that is safe to move. 	     Compute its desirability.  */
name|p
operator|=
name|m
operator|->
name|insn
expr_stmt|;
name|regno
operator|=
name|m
operator|->
name|regno
expr_stmt|;
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"savings %d "
argument_list|,
name|savings
argument_list|)
expr_stmt|;
if|if
condition|(
name|moved_once
index|[
name|regno
index|]
condition|)
block|{
name|insn_count
operator|*=
literal|2
expr_stmt|;
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"halved since already moved "
argument_list|)
expr_stmt|;
block|}
comment|/* An insn MUST be moved if we already moved something else 	     which is safe only if this one is moved too: that is, 	     if already_moved[REGNO] is nonzero.  */
comment|/* An insn is desirable to move if the new lifetime of the 	     register is no more than THRESHOLD times the old lifetime. 	     If it's not desirable, it means the loop is so big 	     that moving won't speed things up much, 	     and it is liable to make register usage worse.  */
comment|/* It is also desirable to move if it can be moved at no 	     extra cost because something else was already moved.  */
if|if
condition|(
name|already_moved
index|[
name|regno
index|]
operator|||
name|flag_move_all_movables
operator|||
operator|(
name|threshold
operator|*
name|savings
operator|*
name|m
operator|->
name|lifetime
operator|)
operator|>=
name|insn_count
operator|||
operator|(
name|m
operator|->
name|forces
operator|&&
name|m
operator|->
name|forces
operator|->
name|done
operator|&&
name|n_times_used
index|[
name|m
operator|->
name|forces
operator|->
name|regno
index|]
operator|==
literal|1
operator|)
condition|)
block|{
name|int
name|count
decl_stmt|;
specifier|register
name|struct
name|movable
modifier|*
name|m1
decl_stmt|;
name|rtx
name|first
decl_stmt|;
comment|/* Now move the insns that set the reg.  */
if|if
condition|(
name|m
operator|->
name|partial
operator|&&
name|m
operator|->
name|match
condition|)
block|{
name|rtx
name|newpat
decl_stmt|,
name|i1
decl_stmt|;
name|rtx
name|r1
decl_stmt|,
name|r2
decl_stmt|;
comment|/* Find the end of this chain of matching regs. 		     Thus, we load each reg in the chain from that one reg. 		     And that reg is loaded with 0 directly, 		     since it has ->match == 0.  */
for|for
control|(
name|m1
operator|=
name|m
init|;
name|m1
operator|->
name|match
condition|;
name|m1
operator|=
name|m1
operator|->
name|match
control|)
empty_stmt|;
name|newpat
operator|=
name|gen_move_insn
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|m
operator|->
name|insn
argument_list|)
argument_list|)
argument_list|,
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|m1
operator|->
name|insn
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|i1
operator|=
name|emit_insn_before
argument_list|(
name|newpat
argument_list|,
name|loop_start
argument_list|)
expr_stmt|;
comment|/* Mark the moved, invariant reg as being allowed to 		     share a hard reg with the other matching invariant.  */
name|REG_NOTES
argument_list|(
name|i1
argument_list|)
operator|=
name|REG_NOTES
argument_list|(
name|m
operator|->
name|insn
argument_list|)
expr_stmt|;
name|r1
operator|=
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|m
operator|->
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|r2
operator|=
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|m1
operator|->
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|regs_may_share
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|r1
argument_list|,
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|r2
argument_list|,
name|regs_may_share
argument_list|)
argument_list|)
expr_stmt|;
name|delete_insn
argument_list|(
name|m
operator|->
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_start
operator|==
literal|0
condition|)
name|new_start
operator|=
name|i1
expr_stmt|;
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|" moved to %d"
argument_list|,
name|INSN_UID
argument_list|(
name|i1
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If we are to re-generate the item being moved with a 		 new move insn, first delete what we have and then emit 		 the move insn before the loop.  */
elseif|else
if|if
condition|(
name|m
operator|->
name|move_insn
condition|)
block|{
name|rtx
name|i1
decl_stmt|,
name|temp
decl_stmt|;
for|for
control|(
name|count
operator|=
name|m
operator|->
name|consec
init|;
name|count
operator|>=
literal|0
condition|;
name|count
operator|--
control|)
block|{
comment|/* If this is the first insn of a library call sequence, 			 skip to the end.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|!=
name|NOTE
operator|&&
operator|(
name|temp
operator|=
name|find_reg_note
argument_list|(
name|p
argument_list|,
name|REG_LIBCALL
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
condition|)
name|p
operator|=
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If this is the last insn of a libcall sequence, then 			 delete every insn in the sequence except the last. 			 The last insn is handled in the normal manner.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|!=
name|NOTE
operator|&&
operator|(
name|temp
operator|=
name|find_reg_note
argument_list|(
name|p
argument_list|,
name|REG_RETVAL
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
condition|)
block|{
name|temp
operator|=
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|temp
operator|!=
name|p
condition|)
name|temp
operator|=
name|delete_insn
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|delete_insn
argument_list|(
name|p
argument_list|)
expr_stmt|;
while|while
condition|(
name|p
operator|&&
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|NOTE
condition|)
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|start_sequence
argument_list|()
expr_stmt|;
name|emit_move_insn
argument_list|(
name|m
operator|->
name|set_dest
argument_list|,
name|m
operator|->
name|set_src
argument_list|)
expr_stmt|;
name|temp
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|add_label_notes
argument_list|(
name|m
operator|->
name|set_src
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|i1
operator|=
name|emit_insns_before
argument_list|(
name|temp
argument_list|,
name|loop_start
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|find_reg_note
argument_list|(
name|i1
argument_list|,
name|REG_EQUAL
argument_list|,
name|NULL_RTX
argument_list|)
condition|)
name|REG_NOTES
argument_list|(
name|i1
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|m
operator|->
name|is_equiv
condition|?
name|REG_EQUIV
else|:
name|REG_EQUAL
argument_list|,
name|m
operator|->
name|set_src
argument_list|,
name|REG_NOTES
argument_list|(
name|i1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|" moved to %d"
argument_list|,
name|INSN_UID
argument_list|(
name|i1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The more regs we move, the less we like moving them.  */
name|threshold
operator|-=
literal|3
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|count
operator|=
name|m
operator|->
name|consec
init|;
name|count
operator|>=
literal|0
condition|;
name|count
operator|--
control|)
block|{
name|rtx
name|i1
decl_stmt|,
name|temp
decl_stmt|;
comment|/* If first insn of libcall sequence, skip to end.  */
comment|/* Do this at start of loop, since p is guaranteed to  			 be an insn here.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|!=
name|NOTE
operator|&&
operator|(
name|temp
operator|=
name|find_reg_note
argument_list|(
name|p
argument_list|,
name|REG_LIBCALL
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
condition|)
name|p
operator|=
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If last insn of libcall sequence, move all 			 insns except the last before the loop.  The last 			 insn is handled in the normal manner.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|!=
name|NOTE
operator|&&
operator|(
name|temp
operator|=
name|find_reg_note
argument_list|(
name|p
argument_list|,
name|REG_RETVAL
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
condition|)
block|{
name|rtx
name|fn_address
init|=
literal|0
decl_stmt|;
name|rtx
name|fn_reg
init|=
literal|0
decl_stmt|;
name|rtx
name|fn_address_insn
init|=
literal|0
decl_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|temp
operator|=
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
init|;
name|temp
operator|!=
name|p
condition|;
name|temp
operator|=
name|NEXT_INSN
argument_list|(
name|temp
argument_list|)
control|)
block|{
name|rtx
name|body
decl_stmt|;
name|rtx
name|n
decl_stmt|;
name|rtx
name|next
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|==
name|NOTE
condition|)
continue|continue;
name|body
operator|=
name|PATTERN
argument_list|(
name|temp
argument_list|)
expr_stmt|;
comment|/* Find the next insn after TEMP, 				 not counting USE or NOTE insns.  */
for|for
control|(
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|temp
argument_list|)
init|;
name|next
operator|!=
name|p
condition|;
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|next
argument_list|)
control|)
if|if
condition|(
operator|!
operator|(
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|next
argument_list|)
argument_list|)
operator|==
name|USE
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|!=
name|NOTE
condition|)
break|break;
comment|/* If that is the call, this may be the insn 				 that loads the function address.  				 Extract the function address from the insn 				 that loads it into a register. 				 If this insn was cse'd, we get incorrect code.  				 So emit a new move insn that copies the 				 function address into the register that the 				 call insn will use.  flow.c will delete any 				 redundant stores that we have created.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|CALL_INSN
operator|&&
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|body
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|n
operator|=
name|find_reg_note
argument_list|(
name|temp
argument_list|,
name|REG_EQUAL
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
condition|)
block|{
name|fn_reg
operator|=
name|SET_SRC
argument_list|(
name|body
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|fn_reg
argument_list|)
operator|!=
name|REG
condition|)
name|fn_reg
operator|=
name|SET_DEST
argument_list|(
name|body
argument_list|)
expr_stmt|;
name|fn_address
operator|=
name|XEXP
argument_list|(
name|n
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fn_address_insn
operator|=
name|temp
expr_stmt|;
block|}
comment|/* We have the call insn. 				 If it uses the register we suspect it might, 				 load it with the correct address directly.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|==
name|CALL_INSN
operator|&&
name|fn_address
operator|!=
literal|0
operator|&&
name|reg_referenced_p
argument_list|(
name|fn_reg
argument_list|,
name|body
argument_list|)
condition|)
name|emit_insn_after
argument_list|(
name|gen_move_insn
argument_list|(
name|fn_reg
argument_list|,
name|fn_address
argument_list|)
argument_list|,
name|fn_address_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
name|i1
operator|=
name|emit_call_insn_before
argument_list|(
name|body
argument_list|,
name|loop_start
argument_list|)
expr_stmt|;
comment|/* Because the USAGE information potentially 				     contains objects other than hard registers 				     we need to copy it.  */
if|if
condition|(
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|temp
argument_list|)
condition|)
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|i1
argument_list|)
operator|=
name|copy_rtx
argument_list|(
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|temp
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|i1
operator|=
name|emit_insn_before
argument_list|(
name|body
argument_list|,
name|loop_start
argument_list|)
expr_stmt|;
if|if
condition|(
name|first
operator|==
literal|0
condition|)
name|first
operator|=
name|i1
expr_stmt|;
if|if
condition|(
name|temp
operator|==
name|fn_address_insn
condition|)
name|fn_address_insn
operator|=
name|i1
expr_stmt|;
name|REG_NOTES
argument_list|(
name|i1
argument_list|)
operator|=
name|REG_NOTES
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|delete_insn
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|m
operator|->
name|savemode
operator|!=
name|VOIDmode
condition|)
block|{
comment|/* P sets REG to zero; but we should clear only 			     the bits that are not covered by the mode 			     m->savemode.  */
name|rtx
name|reg
init|=
name|m
operator|->
name|set_dest
decl_stmt|;
name|rtx
name|sequence
decl_stmt|;
name|rtx
name|tem
decl_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|tem
operator|=
name|expand_binop
argument_list|(
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|,
name|and_optab
argument_list|,
name|reg
argument_list|,
name|GEN_INT
argument_list|(
operator|(
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|GET_MODE_BITSIZE
argument_list|(
name|m
operator|->
name|savemode
argument_list|)
operator|)
operator|)
operator|-
literal|1
argument_list|)
argument_list|,
name|reg
argument_list|,
literal|1
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|tem
operator|!=
name|reg
condition|)
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|tem
argument_list|)
expr_stmt|;
name|sequence
operator|=
name|gen_sequence
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|i1
operator|=
name|emit_insn_before
argument_list|(
name|sequence
argument_list|,
name|loop_start
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
name|i1
operator|=
name|emit_call_insn_before
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|,
name|loop_start
argument_list|)
expr_stmt|;
comment|/* Because the USAGE information potentially 			     contains objects other than hard registers 			     we need to copy it.  */
if|if
condition|(
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|p
argument_list|)
condition|)
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|i1
argument_list|)
operator|=
name|copy_rtx
argument_list|(
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|count
operator|==
name|m
operator|->
name|consec
operator|&&
name|m
operator|->
name|move_insn_first
condition|)
block|{
comment|/* The SET_SRC might not be invariant, so we must 			     use the REG_EQUAL note.  */
name|start_sequence
argument_list|()
expr_stmt|;
name|emit_move_insn
argument_list|(
name|m
operator|->
name|set_dest
argument_list|,
name|m
operator|->
name|set_src
argument_list|)
expr_stmt|;
name|temp
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|add_label_notes
argument_list|(
name|m
operator|->
name|set_src
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|i1
operator|=
name|emit_insns_before
argument_list|(
name|temp
argument_list|,
name|loop_start
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|find_reg_note
argument_list|(
name|i1
argument_list|,
name|REG_EQUAL
argument_list|,
name|NULL_RTX
argument_list|)
condition|)
name|REG_NOTES
argument_list|(
name|i1
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
operator|(
name|m
operator|->
name|is_equiv
condition|?
name|REG_EQUIV
else|:
name|REG_EQUAL
operator|)
argument_list|,
name|m
operator|->
name|set_src
argument_list|,
name|REG_NOTES
argument_list|(
name|i1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|i1
operator|=
name|emit_insn_before
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|,
name|loop_start
argument_list|)
expr_stmt|;
if|if
condition|(
name|REG_NOTES
argument_list|(
name|i1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|REG_NOTES
argument_list|(
name|i1
argument_list|)
operator|=
name|REG_NOTES
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* If there is a REG_EQUAL note present whose value 			     is not loop invariant, then delete it, since it 			     may cause problems with later optimization passes. 			     It is possible for cse to create such notes 			     like this as a result of record_jump_cond.  */
if|if
condition|(
operator|(
name|temp
operator|=
name|find_reg_note
argument_list|(
name|i1
argument_list|,
name|REG_EQUAL
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
operator|&&
operator|!
name|invariant_p
argument_list|(
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|remove_note
argument_list|(
name|i1
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|new_start
operator|==
literal|0
condition|)
name|new_start
operator|=
name|i1
expr_stmt|;
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|" moved to %d"
argument_list|,
name|INSN_UID
argument_list|(
name|i1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If library call, now fix the REG_NOTES that contain 			 insn pointers, namely REG_LIBCALL on FIRST 			 and REG_RETVAL on I1.  */
if|if
condition|(
operator|(
name|temp
operator|=
name|find_reg_note
argument_list|(
name|i1
argument_list|,
name|REG_RETVAL
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
condition|)
block|{
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
operator|=
name|first
expr_stmt|;
name|temp
operator|=
name|find_reg_note
argument_list|(
name|first
argument_list|,
name|REG_LIBCALL
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
operator|=
name|i1
expr_stmt|;
block|}
name|delete_insn
argument_list|(
name|p
argument_list|)
expr_stmt|;
do|do
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
expr_stmt|;
do|while
condition|(
name|p
operator|&&
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|NOTE
condition|)
do|;
block|}
comment|/* The more regs we move, the less we like moving them.  */
name|threshold
operator|-=
literal|3
expr_stmt|;
block|}
comment|/* Any other movable that loads the same register 		 MUST be moved.  */
name|already_moved
index|[
name|regno
index|]
operator|=
literal|1
expr_stmt|;
comment|/* This reg has been moved out of one loop.  */
name|moved_once
index|[
name|regno
index|]
operator|=
literal|1
expr_stmt|;
comment|/* The reg set here is now invariant.  */
if|if
condition|(
operator|!
name|m
operator|->
name|partial
condition|)
name|n_times_set
index|[
name|regno
index|]
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|done
operator|=
literal|1
expr_stmt|;
comment|/* Change the length-of-life info for the register 		 to say it lives at least the full length of this loop. 		 This will help guide optimizations in outer loops.  */
if|if
condition|(
name|uid_luid
index|[
name|REGNO_FIRST_UID
argument_list|(
name|regno
argument_list|)
index|]
operator|>
name|INSN_LUID
argument_list|(
name|loop_start
argument_list|)
condition|)
comment|/* This is the old insn before all the moved insns. 		   We can't use the moved insn because it is out of range 		   in uid_luid.  Only the old insns have luids.  */
name|REGNO_FIRST_UID
argument_list|(
name|regno
argument_list|)
operator|=
name|INSN_UID
argument_list|(
name|loop_start
argument_list|)
expr_stmt|;
if|if
condition|(
name|uid_luid
index|[
name|REGNO_LAST_UID
argument_list|(
name|regno
argument_list|)
index|]
operator|<
name|INSN_LUID
argument_list|(
name|end
argument_list|)
condition|)
name|REGNO_LAST_UID
argument_list|(
name|regno
argument_list|)
operator|=
name|INSN_UID
argument_list|(
name|end
argument_list|)
expr_stmt|;
comment|/* Combine with this moved insn any other matching movables.  */
if|if
condition|(
operator|!
name|m
operator|->
name|partial
condition|)
for|for
control|(
name|m1
operator|=
name|movables
init|;
name|m1
condition|;
name|m1
operator|=
name|m1
operator|->
name|next
control|)
if|if
condition|(
name|m1
operator|->
name|match
operator|==
name|m
condition|)
block|{
name|rtx
name|temp
decl_stmt|;
comment|/* Schedule the reg loaded by M1 			 for replacement so that shares the reg of M. 			 If the modes differ (only possible in restricted 			 circumstances, make a SUBREG.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|m
operator|->
name|set_dest
argument_list|)
operator|==
name|GET_MODE
argument_list|(
name|m1
operator|->
name|set_dest
argument_list|)
condition|)
name|reg_map
index|[
name|m1
operator|->
name|regno
index|]
operator|=
name|m
operator|->
name|set_dest
expr_stmt|;
else|else
name|reg_map
index|[
name|m1
operator|->
name|regno
index|]
operator|=
name|gen_lowpart_common
argument_list|(
name|GET_MODE
argument_list|(
name|m1
operator|->
name|set_dest
argument_list|)
argument_list|,
name|m
operator|->
name|set_dest
argument_list|)
expr_stmt|;
comment|/* Get rid of the matching insn 			 and prevent further processing of it.  */
name|m1
operator|->
name|done
operator|=
literal|1
expr_stmt|;
comment|/* if library call, delete all insn except last, which 			 is deleted below */
if|if
condition|(
operator|(
name|temp
operator|=
name|find_reg_note
argument_list|(
name|m1
operator|->
name|insn
argument_list|,
name|REG_RETVAL
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
condition|)
block|{
for|for
control|(
name|temp
operator|=
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
init|;
name|temp
operator|!=
name|m1
operator|->
name|insn
condition|;
name|temp
operator|=
name|NEXT_INSN
argument_list|(
name|temp
argument_list|)
control|)
name|delete_insn
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
name|delete_insn
argument_list|(
name|m1
operator|->
name|insn
argument_list|)
expr_stmt|;
comment|/* Any other movable that loads the same register 			 MUST be moved.  */
name|already_moved
index|[
name|m1
operator|->
name|regno
index|]
operator|=
literal|1
expr_stmt|;
comment|/* The reg merged here is now invariant, 			 if the reg it matches is invariant.  */
if|if
condition|(
operator|!
name|m
operator|->
name|partial
condition|)
name|n_times_set
index|[
name|m1
operator|->
name|regno
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"not desirable"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|loop_dump_stream
operator|&&
operator|!
name|m
operator|->
name|match
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"not safe"
argument_list|)
expr_stmt|;
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|new_start
operator|==
literal|0
condition|)
name|new_start
operator|=
name|loop_start
expr_stmt|;
comment|/* Go through all the instructions in the loop, making      all the register substitutions scheduled in REG_MAP.  */
for|for
control|(
name|p
operator|=
name|new_start
init|;
name|p
operator|!=
name|end
condition|;
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|JUMP_INSN
operator|||
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
name|replace_regs
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|,
name|reg_map
argument_list|,
name|nregs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|replace_regs
argument_list|(
name|REG_NOTES
argument_list|(
name|p
argument_list|)
argument_list|,
name|reg_map
argument_list|,
name|nregs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|INSN_CODE
argument_list|(
name|p
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Scan X and replace the address of any MEM in it with ADDR.    REG is the address that MEM should have before the replacement.  */
end_comment

begin_comment
unit|static void replace_call_address (x, reg, addr)      rtx x, reg, addr; {   register enum rtx_code code;   register int i;   register char *fmt;    if (x == 0)     return;   code = GET_CODE (x);   switch (code)     {     case PC:     case CC0:     case CONST_INT:     case CONST_DOUBLE:     case CONST:     case SYMBOL_REF:     case LABEL_REF:     case REG:       return;      case SET:
comment|/* Short cut for very common case.  */
end_comment

begin_comment
unit|replace_call_address (XEXP (x, 1), reg, addr);       return;      case CALL:
comment|/* Short cut for very common case.  */
end_comment

begin_comment
unit|replace_call_address (XEXP (x, 0), reg, addr);       return;      case MEM:
comment|/* If this MEM uses a reg other than the one we expected, 	 something is wrong.  */
end_comment

begin_endif
unit|if (XEXP (x, 0) != reg) 	abort ();       XEXP (x, 0) = addr;       return;            default:       break;     }    fmt = GET_RTX_FORMAT (code);   for (i = GET_RTX_LENGTH (code) - 1; i>= 0; i--)     {       if (fmt[i] == 'e') 	replace_call_address (XEXP (x, i), reg, addr);       if (fmt[i] == 'E') 	{ 	  register int j; 	  for (j = 0; j< XVECLEN (x, i); j++) 	    replace_call_address (XVECEXP (x, i, j), reg, addr); 	}     } }
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Return the number of memory refs to addresses that vary    in the rtx X.  */
end_comment

begin_function
specifier|static
name|int
name|count_nonfixed_reads
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
specifier|register
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|value
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PC
case|:
case|case
name|CC0
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CONST
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
case|case
name|REG
case|:
return|return
literal|0
return|;
case|case
name|MEM
case|:
return|return
operator|(
operator|(
name|invariant_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
literal|1
operator|)
operator|+
name|count_nonfixed_reads
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
return|;
default|default:
break|break;
block|}
name|value
operator|=
literal|0
expr_stmt|;
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|value
operator|+=
name|count_nonfixed_reads
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|value
operator|+=
name|count_nonfixed_reads
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|value
return|;
block|}
end_function

begin_escape
end_escape

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* P is an instruction that sets a register to the result of a ZERO_EXTEND.    Replace it with an instruction to load just the low bytes    if the machine supports such an instruction,    and insert above LOOP_START an instruction to clear the register.  */
end_comment

begin_comment
unit|static void constant_high_bytes (p, loop_start)      rtx p, loop_start; {   register rtx new;   register int insn_code_number;
comment|/* Try to change (SET (REG ...) (ZERO_EXTEND (..:B ...)))      to (SET (STRICT_LOW_PART (SUBREG:B (REG...))) ...).  */
end_comment

begin_comment
unit|new = gen_rtx_SET (VOIDmode, 		     gen_rtx_STRICT_LOW_PART (VOIDmode, 					      gen_rtx_SUBREG (GET_MODE (XEXP (SET_SRC (PATTERN (p)), 0)), 				   SET_DEST (PATTERN (p)), 				   0)), 		 XEXP (SET_SRC (PATTERN (p)), 0));   insn_code_number = recog (new, p);    if (insn_code_number)     {       register int i;
comment|/* Clear destination register before the loop.  */
end_comment

begin_comment
unit|emit_insn_before (gen_rtx_SET (VOIDmode, SET_DEST (PATTERN (p)), 				     const0_rtx), 			loop_start);
comment|/* Inside the loop, just load the low part.  */
end_comment

begin_endif
unit|PATTERN (p) = new;     } }
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Scan a loop setting the variables `unknown_address_altered',    `num_mem_sets', `loop_continue', loops_enclosed', `loop_has_call',    and `loop_has_volatile'.    Also, fill in the array `loop_store_mems'.  */
end_comment

begin_function
specifier|static
name|void
name|prescan_loop
parameter_list|(
name|start
parameter_list|,
name|end
parameter_list|)
name|rtx
name|start
decl_stmt|,
name|end
decl_stmt|;
block|{
specifier|register
name|int
name|level
init|=
literal|1
decl_stmt|;
specifier|register
name|rtx
name|insn
decl_stmt|;
name|unknown_address_altered
operator|=
literal|0
expr_stmt|;
name|loop_has_call
operator|=
literal|0
expr_stmt|;
name|loop_has_volatile
operator|=
literal|0
expr_stmt|;
name|first_loop_store_insn
operator|=
name|NULL_RTX
expr_stmt|;
name|loop_store_mems_idx
operator|=
literal|0
expr_stmt|;
name|num_mem_sets
operator|=
literal|0
expr_stmt|;
name|loops_enclosed
operator|=
literal|1
expr_stmt|;
name|loop_continue
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|start
argument_list|)
init|;
name|insn
operator|!=
name|NEXT_INSN
argument_list|(
name|end
argument_list|)
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
block|{
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_LOOP_BEG
condition|)
block|{
operator|++
name|level
expr_stmt|;
comment|/* Count number of loops contained in this one.  */
name|loops_enclosed
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_LOOP_END
condition|)
block|{
operator|--
name|level
expr_stmt|;
if|if
condition|(
name|level
operator|==
literal|0
condition|)
block|{
name|end
operator|=
name|insn
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_LOOP_CONT
condition|)
block|{
if|if
condition|(
name|level
operator|==
literal|1
condition|)
name|loop_continue
operator|=
name|insn
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
if|if
condition|(
operator|!
name|CONST_CALL_P
argument_list|(
name|insn
argument_list|)
condition|)
name|unknown_address_altered
operator|=
literal|1
expr_stmt|;
name|loop_has_call
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
block|{
if|if
condition|(
name|volatile_refs_p
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
name|loop_has_volatile
operator|=
literal|1
expr_stmt|;
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|note_addr_stored
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|first_loop_store_insn
operator|&&
name|loop_store_mems_idx
operator|!=
literal|0
condition|)
name|first_loop_store_insn
operator|=
name|insn
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Scan the function looking for loops.  Record the start and end of each loop.    Also mark as invalid loops any loops that contain a setjmp or are branched    to from outside the loop.  */
end_comment

begin_function
specifier|static
name|void
name|find_and_verify_loops
parameter_list|(
name|f
parameter_list|)
name|rtx
name|f
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|,
name|label
decl_stmt|;
name|int
name|current_loop
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|next_loop
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|loop
decl_stmt|;
comment|/* If there are jumps to undefined labels,      treat them as jumps out of any/all loops.      This also avoids writing past end of tables when there are no loops.  */
name|uid_loop_num
index|[
literal|0
index|]
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Find boundaries of loops, mark which loops are contained within      loops, and invalidate loops that have setjmp.  */
for|for
control|(
name|insn
operator|=
name|f
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
switch|switch
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
condition|)
block|{
case|case
name|NOTE_INSN_LOOP_BEG
case|:
name|loop_number_loop_starts
index|[
operator|++
name|next_loop
index|]
operator|=
name|insn
expr_stmt|;
name|loop_number_loop_ends
index|[
name|next_loop
index|]
operator|=
literal|0
expr_stmt|;
name|loop_outer_loop
index|[
name|next_loop
index|]
operator|=
name|current_loop
expr_stmt|;
name|loop_invalid
index|[
name|next_loop
index|]
operator|=
literal|0
expr_stmt|;
name|loop_number_exit_labels
index|[
name|next_loop
index|]
operator|=
literal|0
expr_stmt|;
name|loop_number_exit_count
index|[
name|next_loop
index|]
operator|=
literal|0
expr_stmt|;
name|current_loop
operator|=
name|next_loop
expr_stmt|;
break|break;
case|case
name|NOTE_INSN_SETJMP
case|:
comment|/* In this case, we must invalidate our current loop and any 	       enclosing loop.  */
for|for
control|(
name|loop
operator|=
name|current_loop
init|;
name|loop
operator|!=
operator|-
literal|1
condition|;
name|loop
operator|=
name|loop_outer_loop
index|[
name|loop
index|]
control|)
block|{
name|loop_invalid
index|[
name|loop
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"\nLoop at %d ignored due to setjmp.\n"
argument_list|,
name|INSN_UID
argument_list|(
name|loop_number_loop_starts
index|[
name|loop
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|NOTE_INSN_LOOP_END
case|:
if|if
condition|(
name|current_loop
operator|==
operator|-
literal|1
condition|)
name|abort
argument_list|()
expr_stmt|;
name|loop_number_loop_ends
index|[
name|current_loop
index|]
operator|=
name|insn
expr_stmt|;
name|current_loop
operator|=
name|loop_outer_loop
index|[
name|current_loop
index|]
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* Note that this will mark the NOTE_INSN_LOOP_END note as being in the 	 enclosing loop, but this doesn't matter.  */
name|uid_loop_num
index|[
name|INSN_UID
argument_list|(
name|insn
argument_list|)
index|]
operator|=
name|current_loop
expr_stmt|;
block|}
comment|/* Any loop containing a label used in an initializer must be invalidated,      because it can be jumped into from anywhere.  */
for|for
control|(
name|label
operator|=
name|forced_labels
init|;
name|label
condition|;
name|label
operator|=
name|XEXP
argument_list|(
name|label
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|int
name|loop_num
decl_stmt|;
for|for
control|(
name|loop_num
operator|=
name|uid_loop_num
index|[
name|INSN_UID
argument_list|(
name|XEXP
argument_list|(
name|label
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
init|;
name|loop_num
operator|!=
operator|-
literal|1
condition|;
name|loop_num
operator|=
name|loop_outer_loop
index|[
name|loop_num
index|]
control|)
name|loop_invalid
index|[
name|loop_num
index|]
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Any loop containing a label used for an exception handler must be      invalidated, because it can be jumped into from anywhere.  */
for|for
control|(
name|label
operator|=
name|exception_handler_labels
init|;
name|label
condition|;
name|label
operator|=
name|XEXP
argument_list|(
name|label
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|int
name|loop_num
decl_stmt|;
for|for
control|(
name|loop_num
operator|=
name|uid_loop_num
index|[
name|INSN_UID
argument_list|(
name|XEXP
argument_list|(
name|label
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
init|;
name|loop_num
operator|!=
operator|-
literal|1
condition|;
name|loop_num
operator|=
name|loop_outer_loop
index|[
name|loop_num
index|]
control|)
name|loop_invalid
index|[
name|loop_num
index|]
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Now scan all insn's in the function.  If any JUMP_INSN branches into a      loop that it is not contained within, that loop is marked invalid.      If any INSN or CALL_INSN uses a label's address, then the loop containing      that label is marked invalid, because it could be jumped into from      anywhere.       Also look for blocks of code ending in an unconditional branch that      exits the loop.  If such a block is surrounded by a conditional       branch around the block, move the block elsewhere (see below) and      invert the jump to point to the code block.  This may eliminate a      label in our loop and will simplify processing by both us and a      possible second cse pass.  */
for|for
control|(
name|insn
operator|=
name|f
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
literal|'i'
condition|)
block|{
name|int
name|this_loop_num
init|=
name|uid_loop_num
index|[
name|INSN_UID
argument_list|(
name|insn
argument_list|)
index|]
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
name|rtx
name|note
init|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_LABEL
argument_list|,
name|NULL_RTX
argument_list|)
decl_stmt|;
if|if
condition|(
name|note
condition|)
block|{
name|int
name|loop_num
decl_stmt|;
for|for
control|(
name|loop_num
operator|=
name|uid_loop_num
index|[
name|INSN_UID
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
init|;
name|loop_num
operator|!=
operator|-
literal|1
condition|;
name|loop_num
operator|=
name|loop_outer_loop
index|[
name|loop_num
index|]
control|)
name|loop_invalid
index|[
name|loop_num
index|]
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|JUMP_INSN
condition|)
continue|continue;
name|mark_loop_jump
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|this_loop_num
argument_list|)
expr_stmt|;
comment|/* See if this is an unconditional branch outside the loop.  */
if|if
condition|(
name|this_loop_num
operator|!=
operator|-
literal|1
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|RETURN
operator|||
operator|(
name|simplejump_p
argument_list|(
name|insn
argument_list|)
operator|&&
operator|(
name|uid_loop_num
index|[
name|INSN_UID
argument_list|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
argument_list|)
index|]
operator|!=
name|this_loop_num
operator|)
operator|)
operator|)
operator|&&
name|get_max_uid
argument_list|()
operator|<
name|max_uid_for_loop
condition|)
block|{
name|rtx
name|p
decl_stmt|;
name|rtx
name|our_next
init|=
name|next_real_insn
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|int
name|dest_loop
decl_stmt|;
name|int
name|outer_loop
init|=
operator|-
literal|1
decl_stmt|;
comment|/* Go backwards until we reach the start of the loop, a label, 	       or a JUMP_INSN.  */
for|for
control|(
name|p
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
init|;
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|!=
name|CODE_LABEL
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|p
argument_list|)
operator|==
name|NOTE_INSN_LOOP_BEG
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|!=
name|JUMP_INSN
condition|;
name|p
operator|=
name|PREV_INSN
argument_list|(
name|p
argument_list|)
control|)
empty_stmt|;
comment|/* Check for the case where we have a jump to an inner nested 	       loop, and do not perform the optimization in that case.  */
if|if
condition|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|dest_loop
operator|=
name|uid_loop_num
index|[
name|INSN_UID
argument_list|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|dest_loop
operator|!=
operator|-
literal|1
condition|)
block|{
for|for
control|(
name|outer_loop
operator|=
name|dest_loop
init|;
name|outer_loop
operator|!=
operator|-
literal|1
condition|;
name|outer_loop
operator|=
name|loop_outer_loop
index|[
name|outer_loop
index|]
control|)
if|if
condition|(
name|outer_loop
operator|==
name|this_loop_num
condition|)
break|break;
block|}
block|}
comment|/* Make sure that the target of P is within the current loop.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|JUMP_LABEL
argument_list|(
name|p
argument_list|)
operator|&&
name|uid_loop_num
index|[
name|INSN_UID
argument_list|(
name|JUMP_LABEL
argument_list|(
name|p
argument_list|)
argument_list|)
index|]
operator|!=
name|this_loop_num
condition|)
name|outer_loop
operator|=
name|this_loop_num
expr_stmt|;
comment|/* If we stopped on a JUMP_INSN to the next insn after INSN, 	       we have a block of code to try to move.  	       We look backward and then forward from the target of INSN 	       to find a BARRIER at the same loop depth as the target. 	       If we find such a BARRIER, we make a new label for the start 	       of the block, invert the jump in P and point it to that label, 	       and move the block of code to the spot we found.  */
if|if
condition|(
name|outer_loop
operator|==
operator|-
literal|1
operator|&&
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|JUMP_LABEL
argument_list|(
name|p
argument_list|)
operator|!=
literal|0
comment|/* Just ignore jumps to labels that were never emitted. 		   These always indicate compilation errors.  */
operator|&&
name|INSN_UID
argument_list|(
name|JUMP_LABEL
argument_list|(
name|p
argument_list|)
argument_list|)
operator|!=
literal|0
operator|&&
name|condjump_p
argument_list|(
name|p
argument_list|)
operator|&&
operator|!
name|simplejump_p
argument_list|(
name|p
argument_list|)
operator|&&
name|next_real_insn
argument_list|(
name|JUMP_LABEL
argument_list|(
name|p
argument_list|)
argument_list|)
operator|==
name|our_next
condition|)
block|{
name|rtx
name|target
init|=
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
condition|?
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
else|:
name|get_last_insn
argument_list|()
decl_stmt|;
name|int
name|target_loop_num
init|=
name|uid_loop_num
index|[
name|INSN_UID
argument_list|(
name|target
argument_list|)
index|]
decl_stmt|;
name|rtx
name|loc
decl_stmt|;
for|for
control|(
name|loc
operator|=
name|target
init|;
name|loc
condition|;
name|loc
operator|=
name|PREV_INSN
argument_list|(
name|loc
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|loc
argument_list|)
operator|==
name|BARRIER
operator|&&
name|uid_loop_num
index|[
name|INSN_UID
argument_list|(
name|loc
argument_list|)
index|]
operator|==
name|target_loop_num
condition|)
break|break;
if|if
condition|(
name|loc
operator|==
literal|0
condition|)
for|for
control|(
name|loc
operator|=
name|target
init|;
name|loc
condition|;
name|loc
operator|=
name|NEXT_INSN
argument_list|(
name|loc
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|loc
argument_list|)
operator|==
name|BARRIER
operator|&&
name|uid_loop_num
index|[
name|INSN_UID
argument_list|(
name|loc
argument_list|)
index|]
operator|==
name|target_loop_num
condition|)
break|break;
if|if
condition|(
name|loc
condition|)
block|{
name|rtx
name|cond_label
init|=
name|JUMP_LABEL
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|rtx
name|new_label
init|=
name|get_label_after
argument_list|(
name|p
argument_list|)
decl_stmt|;
comment|/* Ensure our label doesn't go away.  */
name|LABEL_NUSES
argument_list|(
name|cond_label
argument_list|)
operator|++
expr_stmt|;
comment|/* Verify that uid_loop_num is large enough and that 		       we can invert P.  */
if|if
condition|(
name|invert_jump
argument_list|(
name|p
argument_list|,
name|new_label
argument_list|)
condition|)
block|{
name|rtx
name|q
decl_stmt|,
name|r
decl_stmt|;
comment|/* If no suitable BARRIER was found, create a suitable 			  one before TARGET.  Since TARGET is a fall through 			  path, we'll need to insert an jump around our block 			  and a add a BARRIER before TARGET.  			  This creates an extra unconditional jump outside 			  the loop.  However, the benefits of removing rarely 			  executed instructions from inside the loop usually 			  outweighs the cost of the extra unconditional jump 			  outside the loop.  */
if|if
condition|(
name|loc
operator|==
literal|0
condition|)
block|{
name|rtx
name|temp
decl_stmt|;
name|temp
operator|=
name|gen_jump
argument_list|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|=
name|emit_jump_insn_before
argument_list|(
name|temp
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|JUMP_LABEL
argument_list|(
name|temp
argument_list|)
operator|=
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|LABEL_NUSES
argument_list|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|++
expr_stmt|;
name|loc
operator|=
name|emit_barrier_before
argument_list|(
name|target
argument_list|)
expr_stmt|;
block|}
comment|/* Include the BARRIER after INSN and copy the 			  block after LOC.  */
name|new_label
operator|=
name|squeeze_notes
argument_list|(
name|new_label
argument_list|,
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|reorder_insns
argument_list|(
name|new_label
argument_list|,
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|loc
argument_list|)
expr_stmt|;
comment|/* All those insns are now in TARGET_LOOP_NUM.  */
for|for
control|(
name|q
operator|=
name|new_label
init|;
name|q
operator|!=
name|NEXT_INSN
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|;
name|q
operator|=
name|NEXT_INSN
argument_list|(
name|q
argument_list|)
control|)
name|uid_loop_num
index|[
name|INSN_UID
argument_list|(
name|q
argument_list|)
index|]
operator|=
name|target_loop_num
expr_stmt|;
comment|/* The label jumped to by INSN is no longer a loop exit. 			  Unless INSN does not have a label (e.g., it is a 			  RETURN insn), search loop_number_exit_labels to find 			  its label_ref, and remove it.  Also turn off 			  LABEL_OUTSIDE_LOOP_P bit.  */
if|if
condition|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|int
name|loop_num
decl_stmt|;
for|for
control|(
name|q
operator|=
literal|0
operator|,
name|r
operator|=
name|loop_number_exit_labels
index|[
name|this_loop_num
index|]
init|;
name|r
condition|;
name|q
operator|=
name|r
operator|,
name|r
operator|=
name|LABEL_NEXTREF
argument_list|(
name|r
argument_list|)
control|)
if|if
condition|(
name|XEXP
argument_list|(
name|r
argument_list|,
literal|0
argument_list|)
operator|==
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|LABEL_OUTSIDE_LOOP_P
argument_list|(
name|r
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|q
condition|)
name|LABEL_NEXTREF
argument_list|(
name|q
argument_list|)
operator|=
name|LABEL_NEXTREF
argument_list|(
name|r
argument_list|)
expr_stmt|;
else|else
name|loop_number_exit_labels
index|[
name|this_loop_num
index|]
operator|=
name|LABEL_NEXTREF
argument_list|(
name|r
argument_list|)
expr_stmt|;
break|break;
block|}
for|for
control|(
name|loop_num
operator|=
name|this_loop_num
init|;
name|loop_num
operator|!=
operator|-
literal|1
operator|&&
name|loop_num
operator|!=
name|target_loop_num
condition|;
name|loop_num
operator|=
name|loop_outer_loop
index|[
name|loop_num
index|]
control|)
name|loop_number_exit_count
index|[
name|loop_num
index|]
operator|--
expr_stmt|;
comment|/* If we didn't find it, then something is wrong.  */
if|if
condition|(
operator|!
name|r
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* P is now a jump outside the loop, so it must be put 			  in loop_number_exit_labels, and marked as such. 			  The easiest way to do this is to just call 			  mark_loop_jump again for P.  */
name|mark_loop_jump
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|,
name|this_loop_num
argument_list|)
expr_stmt|;
comment|/* If INSN now jumps to the insn after it, 			  delete INSN.  */
if|if
condition|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
operator|!=
literal|0
operator|&&
operator|(
name|next_real_insn
argument_list|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|next_real_insn
argument_list|(
name|insn
argument_list|)
operator|)
condition|)
name|delete_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
comment|/* Continue the loop after where the conditional 		       branch used to jump, since the only branch insn 		       in the block (if it still remains) is an inter-loop 		       branch and hence needs no processing.  */
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|cond_label
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|LABEL_NUSES
argument_list|(
name|cond_label
argument_list|)
operator|==
literal|0
condition|)
name|delete_insn
argument_list|(
name|cond_label
argument_list|)
expr_stmt|;
comment|/* This loop will be continued with NEXT_INSN (insn).  */
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* If any label in X jumps to a loop different from LOOP_NUM and any of the    loops it is contained in, mark the target loop invalid.     For speed, we assume that X is part of a pattern of a JUMP_INSN.  */
end_comment

begin_function
specifier|static
name|void
name|mark_loop_jump
parameter_list|(
name|x
parameter_list|,
name|loop_num
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|int
name|loop_num
decl_stmt|;
block|{
name|int
name|dest_loop
decl_stmt|;
name|int
name|outer_loop
decl_stmt|;
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|PC
case|:
case|case
name|USE
case|:
case|case
name|CLOBBER
case|:
case|case
name|REG
case|:
case|case
name|MEM
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|RETURN
case|:
return|return;
case|case
name|CONST
case|:
comment|/* There could be a label reference in here.  */
name|mark_loop_jump
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|loop_num
argument_list|)
expr_stmt|;
return|return;
case|case
name|PLUS
case|:
case|case
name|MINUS
case|:
case|case
name|MULT
case|:
name|mark_loop_jump
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|loop_num
argument_list|)
expr_stmt|;
name|mark_loop_jump
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|loop_num
argument_list|)
expr_stmt|;
return|return;
case|case
name|LO_SUM
case|:
comment|/* This may refer to a LABEL_REF or SYMBOL_REF.  */
name|mark_loop_jump
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|loop_num
argument_list|)
expr_stmt|;
return|return;
case|case
name|SIGN_EXTEND
case|:
case|case
name|ZERO_EXTEND
case|:
name|mark_loop_jump
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|loop_num
argument_list|)
expr_stmt|;
return|return;
case|case
name|LABEL_REF
case|:
name|dest_loop
operator|=
name|uid_loop_num
index|[
name|INSN_UID
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
expr_stmt|;
comment|/* Link together all labels that branch outside the loop.  This 	 is used by final_[bg]iv_value and the loop unrolling code.  Also 	 mark this LABEL_REF so we know that this branch should predict 	 false.  */
comment|/* A check to make sure the label is not in an inner nested loop, 	 since this does not count as a loop exit.  */
if|if
condition|(
name|dest_loop
operator|!=
operator|-
literal|1
condition|)
block|{
for|for
control|(
name|outer_loop
operator|=
name|dest_loop
init|;
name|outer_loop
operator|!=
operator|-
literal|1
condition|;
name|outer_loop
operator|=
name|loop_outer_loop
index|[
name|outer_loop
index|]
control|)
if|if
condition|(
name|outer_loop
operator|==
name|loop_num
condition|)
break|break;
block|}
else|else
name|outer_loop
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|loop_num
operator|!=
operator|-
literal|1
operator|&&
name|outer_loop
operator|==
operator|-
literal|1
condition|)
block|{
name|LABEL_OUTSIDE_LOOP_P
argument_list|(
name|x
argument_list|)
operator|=
literal|1
expr_stmt|;
name|LABEL_NEXTREF
argument_list|(
name|x
argument_list|)
operator|=
name|loop_number_exit_labels
index|[
name|loop_num
index|]
expr_stmt|;
name|loop_number_exit_labels
index|[
name|loop_num
index|]
operator|=
name|x
expr_stmt|;
for|for
control|(
name|outer_loop
operator|=
name|loop_num
init|;
name|outer_loop
operator|!=
operator|-
literal|1
operator|&&
name|outer_loop
operator|!=
name|dest_loop
condition|;
name|outer_loop
operator|=
name|loop_outer_loop
index|[
name|outer_loop
index|]
control|)
name|loop_number_exit_count
index|[
name|outer_loop
index|]
operator|++
expr_stmt|;
block|}
comment|/* If this is inside a loop, but not in the current loop or one enclosed 	 by it, it invalidates at least one loop.  */
if|if
condition|(
name|dest_loop
operator|==
operator|-
literal|1
condition|)
return|return;
comment|/* We must invalidate every nested loop containing the target of this 	 label, except those that also contain the jump insn.  */
for|for
control|(
init|;
name|dest_loop
operator|!=
operator|-
literal|1
condition|;
name|dest_loop
operator|=
name|loop_outer_loop
index|[
name|dest_loop
index|]
control|)
block|{
comment|/* Stop when we reach a loop that also contains the jump insn.  */
for|for
control|(
name|outer_loop
operator|=
name|loop_num
init|;
name|outer_loop
operator|!=
operator|-
literal|1
condition|;
name|outer_loop
operator|=
name|loop_outer_loop
index|[
name|outer_loop
index|]
control|)
if|if
condition|(
name|dest_loop
operator|==
name|outer_loop
condition|)
return|return;
comment|/* If we get here, we know we need to invalidate a loop.  */
if|if
condition|(
name|loop_dump_stream
operator|&&
operator|!
name|loop_invalid
index|[
name|dest_loop
index|]
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"\nLoop at %d ignored due to multiple entry points.\n"
argument_list|,
name|INSN_UID
argument_list|(
name|loop_number_loop_starts
index|[
name|dest_loop
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|loop_invalid
index|[
name|dest_loop
index|]
operator|=
literal|1
expr_stmt|;
block|}
return|return;
case|case
name|SET
case|:
comment|/* If this is not setting pc, ignore.  */
if|if
condition|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
operator|==
name|pc_rtx
condition|)
name|mark_loop_jump
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|loop_num
argument_list|)
expr_stmt|;
return|return;
case|case
name|IF_THEN_ELSE
case|:
name|mark_loop_jump
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|loop_num
argument_list|)
expr_stmt|;
name|mark_loop_jump
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
argument_list|,
name|loop_num
argument_list|)
expr_stmt|;
return|return;
case|case
name|PARALLEL
case|:
case|case
name|ADDR_VEC
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
name|mark_loop_jump
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|loop_num
argument_list|)
expr_stmt|;
return|return;
case|case
name|ADDR_DIFF_VEC
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
condition|;
name|i
operator|++
control|)
name|mark_loop_jump
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|,
name|i
argument_list|)
argument_list|,
name|loop_num
argument_list|)
expr_stmt|;
return|return;
default|default:
comment|/* Strictly speaking this is not a jump into the loop, only a possible 	 jump out of the loop.  However, we have no way to link the destination 	 of this jump onto the list of exit labels.  To be safe we mark this 	 loop and any containing loops as invalid.  */
if|if
condition|(
name|loop_num
operator|!=
operator|-
literal|1
condition|)
block|{
for|for
control|(
name|outer_loop
operator|=
name|loop_num
init|;
name|outer_loop
operator|!=
operator|-
literal|1
condition|;
name|outer_loop
operator|=
name|loop_outer_loop
index|[
name|outer_loop
index|]
control|)
block|{
if|if
condition|(
name|loop_dump_stream
operator|&&
operator|!
name|loop_invalid
index|[
name|outer_loop
index|]
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"\nLoop at %d ignored due to unknown exit jump.\n"
argument_list|,
name|INSN_UID
argument_list|(
name|loop_number_loop_starts
index|[
name|outer_loop
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|loop_invalid
index|[
name|outer_loop
index|]
operator|=
literal|1
expr_stmt|;
block|}
block|}
return|return;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return nonzero if there is a label in the range from    insn INSN to and including the insn whose luid is END    INSN must have an assigned luid (i.e., it must not have    been previously created by loop.c).  */
end_comment

begin_function
specifier|static
name|int
name|labels_in_range_p
parameter_list|(
name|insn
parameter_list|,
name|end
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|int
name|end
decl_stmt|;
block|{
while|while
condition|(
name|insn
operator|&&
name|INSN_LUID
argument_list|(
name|insn
argument_list|)
operator|<=
name|end
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
condition|)
return|return
literal|1
return|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Record that a memory reference X is being set.  */
end_comment

begin_function
specifier|static
name|void
name|note_addr_stored
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|rtx
name|y
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|MEM
condition|)
return|return;
comment|/* Count number of memory writes.      This affects heuristics in strength_reduce.  */
name|num_mem_sets
operator|++
expr_stmt|;
comment|/* BLKmode MEM means all memory is clobbered.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|BLKmode
condition|)
name|unknown_address_altered
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|unknown_address_altered
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|loop_store_mems_idx
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|loop_store_mems
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|MEM_IN_STRUCT_P
argument_list|(
name|x
argument_list|)
operator|==
name|MEM_IN_STRUCT_P
argument_list|(
name|loop_store_mems
index|[
name|i
index|]
argument_list|)
condition|)
block|{
comment|/* We are storing at the same address as previously noted.  Save the 	   wider reference.  */
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|loop_store_mems
index|[
name|i
index|]
argument_list|)
argument_list|)
condition|)
name|loop_store_mems
index|[
name|i
index|]
operator|=
name|x
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|NUM_STORES
condition|)
name|unknown_address_altered
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|==
name|loop_store_mems_idx
condition|)
name|loop_store_mems
index|[
name|loop_store_mems_idx
operator|++
index|]
operator|=
name|x
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return nonzero if the rtx X is invariant over the current loop.     The value is 2 if we refer to something only conditionally invariant.     If `unknown_address_altered' is nonzero, no memory ref is invariant.    Otherwise, a memory ref is invariant if it does not conflict with    anything stored in `loop_store_mems'.  */
end_comment

begin_function
name|int
name|invariant_p
parameter_list|(
name|x
parameter_list|)
specifier|register
name|rtx
name|x
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|conditional
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return
literal|1
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|CONST
case|:
return|return
literal|1
return|;
case|case
name|LABEL_REF
case|:
comment|/* A LABEL_REF is normally invariant, however, if we are unrolling 	 loops, and this label is inside the loop, then it isn't invariant. 	 This is because each unrolled copy of the loop body will have 	 a copy of this label.  If this was invariant, then an insn loading 	 the address of this label into a register might get moved outside 	 the loop, and then each loop body would end up using the same label.  	 We don't know the loop bounds here though, so just fail for all 	 labels.  */
if|if
condition|(
name|flag_unroll_loops
condition|)
return|return
literal|0
return|;
else|else
return|return
literal|1
return|;
case|case
name|PC
case|:
case|case
name|CC0
case|:
case|case
name|UNSPEC_VOLATILE
case|:
return|return
literal|0
return|;
case|case
name|REG
case|:
comment|/* We used to check RTX_UNCHANGING_P (x) here, but that is invalid 	 since the reg might be set by initialization within the loop.  */
if|if
condition|(
operator|(
name|x
operator|==
name|frame_pointer_rtx
operator|||
name|x
operator|==
name|hard_frame_pointer_rtx
operator|||
name|x
operator|==
name|arg_pointer_rtx
operator|)
operator|&&
operator|!
name|current_function_has_nonlocal_goto
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|loop_has_call
operator|&&
name|REGNO
argument_list|(
name|x
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|call_used_regs
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|n_times_set
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
operator|<
literal|0
condition|)
return|return
literal|2
return|;
return|return
name|n_times_set
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
operator|==
literal|0
return|;
case|case
name|MEM
case|:
comment|/* Volatile memory references must be rejected.  Do this before 	 checking for read-only items, so that volatile read-only items 	 will be rejected also.  */
if|if
condition|(
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Read-only items (such as constants in a constant pool) are 	 invariant if their address is.  */
if|if
condition|(
name|RTX_UNCHANGING_P
argument_list|(
name|x
argument_list|)
condition|)
break|break;
comment|/* If we filled the table (or had a subroutine call), any location 	 in memory could have been clobbered.  */
if|if
condition|(
name|unknown_address_altered
condition|)
return|return
literal|0
return|;
comment|/* See if there is any dependence between a store and this load.  */
for|for
control|(
name|i
operator|=
name|loop_store_mems_idx
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|true_dependence
argument_list|(
name|loop_store_mems
index|[
name|i
index|]
argument_list|,
name|VOIDmode
argument_list|,
name|x
argument_list|,
name|rtx_varies_p
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* It's not invalidated by a store in memory 	 but we must still verify the address is invariant.  */
break|break;
case|case
name|ASM_OPERANDS
case|:
comment|/* Don't mess with insns declared volatile.  */
if|if
condition|(
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
default|default:
break|break;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
name|int
name|tem
init|=
name|invariant_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|tem
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|tem
operator|==
literal|2
condition|)
name|conditional
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
name|int
name|tem
init|=
name|invariant_p
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|tem
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|tem
operator|==
literal|2
condition|)
name|conditional
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
return|return
literal|1
operator|+
name|conditional
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return nonzero if all the insns in the loop that set REG    are INSN and the immediately following insns,    and if each of those insns sets REG in an invariant way    (not counting uses of REG in them).     The value is 2 if some of these insns are only conditionally invariant.     We assume that INSN itself is the first set of REG    and that its source is invariant.  */
end_comment

begin_function
specifier|static
name|int
name|consec_sets_invariant_p
parameter_list|(
name|reg
parameter_list|,
name|n_sets
parameter_list|,
name|insn
parameter_list|)
name|int
name|n_sets
decl_stmt|;
name|rtx
name|reg
decl_stmt|,
name|insn
decl_stmt|;
block|{
specifier|register
name|rtx
name|p
init|=
name|insn
decl_stmt|;
specifier|register
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|reg
argument_list|)
decl_stmt|;
name|rtx
name|temp
decl_stmt|;
comment|/* Number of sets we have to insist on finding after INSN.  */
name|int
name|count
init|=
name|n_sets
operator|-
literal|1
decl_stmt|;
name|int
name|old
init|=
name|n_times_set
index|[
name|regno
index|]
decl_stmt|;
name|int
name|value
init|=
literal|0
decl_stmt|;
name|int
name|this
decl_stmt|;
comment|/* If N_SETS hit the limit, we can't rely on its value.  */
if|if
condition|(
name|n_sets
operator|==
literal|127
condition|)
return|return
literal|0
return|;
name|n_times_set
index|[
name|regno
index|]
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|count
operator|>
literal|0
condition|)
block|{
specifier|register
name|enum
name|rtx_code
name|code
decl_stmt|;
name|rtx
name|set
decl_stmt|;
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* If library call, skip to end of it.  */
if|if
condition|(
name|code
operator|==
name|INSN
operator|&&
operator|(
name|temp
operator|=
name|find_reg_note
argument_list|(
name|p
argument_list|,
name|REG_LIBCALL
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
condition|)
name|p
operator|=
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|this
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|INSN
operator|&&
operator|(
name|set
operator|=
name|single_set
argument_list|(
name|p
argument_list|)
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|regno
condition|)
block|{
name|this
operator|=
name|invariant_p
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|!=
literal|0
condition|)
name|value
operator||=
name|this
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|temp
operator|=
name|find_reg_note
argument_list|(
name|p
argument_list|,
name|REG_EQUAL
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
condition|)
block|{
comment|/* If this is a libcall, then any invariant REG_EQUAL note is OK. 		 If this is an ordinary insn, then only CONSTANT_P REG_EQUAL 		 notes are OK.  */
name|this
operator|=
operator|(
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
operator|(
name|find_reg_note
argument_list|(
name|p
argument_list|,
name|REG_RETVAL
argument_list|,
name|NULL_RTX
argument_list|)
operator|&&
name|invariant_p
argument_list|(
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|this
operator|!=
literal|0
condition|)
name|value
operator||=
name|this
expr_stmt|;
block|}
block|}
if|if
condition|(
name|this
operator|!=
literal|0
condition|)
name|count
operator|--
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|!=
name|NOTE
condition|)
block|{
name|n_times_set
index|[
name|regno
index|]
operator|=
name|old
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|n_times_set
index|[
name|regno
index|]
operator|=
name|old
expr_stmt|;
comment|/* If invariant_p ever returned 2, we return 2.  */
return|return
literal|1
operator|+
operator|(
name|value
operator|&
literal|2
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* I don't think this condition is sufficient to allow INSN    to be moved, so we no longer test it.  */
end_comment

begin_comment
comment|/* Return 1 if all insns in the basic block of INSN and following INSN    that set REG are invariant according to TABLE.  */
end_comment

begin_endif
unit|static int all_sets_invariant_p (reg, insn, table)      rtx reg, insn;      short *table; {   register rtx p = insn;   register int regno = REGNO (reg);    while (1)     {       register enum rtx_code code;       p = NEXT_INSN (p);       code = GET_CODE (p);       if (code == CODE_LABEL || code == JUMP_INSN) 	return 1;       if (code == INSN&& GET_CODE (PATTERN (p)) == SET&& GET_CODE (SET_DEST (PATTERN (p))) == REG&& REGNO (SET_DEST (PATTERN (p))) == regno) 	{ 	  if (!invariant_p (SET_SRC (PATTERN (p)), table)) 	    return 0; 	}     } }
endif|#
directive|endif
end_endif

begin_comment
comment|/* 0 */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Look at all uses (not sets) of registers in X.  For each, if it is    the single use, set USAGE[REGNO] to INSN; if there was a previous use in    a different insn, set USAGE[REGNO] to const0_rtx.  */
end_comment

begin_function
specifier|static
name|void
name|find_single_use_in_loop
parameter_list|(
name|insn
parameter_list|,
name|x
parameter_list|,
name|usage
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|rtx
modifier|*
name|usage
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|char
modifier|*
name|fmt
init|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|REG
condition|)
name|usage
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
operator|=
operator|(
name|usage
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
operator|!=
literal|0
operator|&&
name|usage
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
operator|!=
name|insn
operator|)
condition|?
name|const0_rtx
else|:
name|insn
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|SET
condition|)
block|{
comment|/* Don't count SET_DEST if it is a REG; otherwise count things 	 in SET_DEST because if a register is partially modified, it won't 	 show up as a potential movable so we don't care how USAGE is set  	 for it.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|REG
condition|)
name|find_single_use_in_loop
argument_list|(
name|insn
argument_list|,
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
name|usage
argument_list|)
expr_stmt|;
name|find_single_use_in_loop
argument_list|(
name|insn
argument_list|,
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|usage
argument_list|)
expr_stmt|;
block|}
else|else
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
operator|&&
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
literal|0
condition|)
name|find_single_use_in_loop
argument_list|(
name|insn
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|usage
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
name|find_single_use_in_loop
argument_list|(
name|insn
argument_list|,
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|usage
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Increment N_TIMES_SET at the index of each register    that is modified by an insn between FROM and TO.    If the value of an element of N_TIMES_SET becomes 127 or more,    stop incrementing it, to avoid overflow.     Store in SINGLE_USAGE[I] the single insn in which register I is    used, if it is only used once.  Otherwise, it is set to 0 (for no    uses) or const0_rtx for more than one use.  This parameter may be zero,    in which case this processing is not done.     Store in *COUNT_PTR the number of actual instruction    in the loop.  We use this to decide what is worth moving out.  */
end_comment

begin_comment
comment|/* last_set[n] is nonzero iff reg n has been set in the current basic block.    In that case, it is the insn that last set reg n.  */
end_comment

begin_function
specifier|static
name|void
name|count_loop_regs_set
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|,
name|may_not_move
parameter_list|,
name|single_usage
parameter_list|,
name|count_ptr
parameter_list|,
name|nregs
parameter_list|)
specifier|register
name|rtx
name|from
decl_stmt|,
name|to
decl_stmt|;
name|char
modifier|*
name|may_not_move
decl_stmt|;
name|rtx
modifier|*
name|single_usage
decl_stmt|;
name|int
modifier|*
name|count_ptr
decl_stmt|;
name|int
name|nregs
decl_stmt|;
block|{
specifier|register
name|rtx
modifier|*
name|last_set
init|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|nregs
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
decl_stmt|;
specifier|register
name|rtx
name|insn
decl_stmt|;
specifier|register
name|int
name|count
init|=
literal|0
decl_stmt|;
specifier|register
name|rtx
name|dest
decl_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|last_set
argument_list|,
name|nregs
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|from
init|;
name|insn
operator|!=
name|to
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
literal|'i'
condition|)
block|{
operator|++
name|count
expr_stmt|;
comment|/* If requested, record registers that have exactly one use.  */
if|if
condition|(
name|single_usage
condition|)
block|{
name|find_single_use_in_loop
argument_list|(
name|insn
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|single_usage
argument_list|)
expr_stmt|;
comment|/* Include uses in REG_EQUAL notes.  */
if|if
condition|(
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
condition|)
name|find_single_use_in_loop
argument_list|(
name|insn
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|,
name|single_usage
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|CLOBBER
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
comment|/* Don't move a reg that has an explicit clobber. 	       We might do so sometimes, but it's not worth the pain.  */
name|may_not_move
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|CLOBBER
condition|)
block|{
name|dest
operator|=
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SIGN_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|STRICT_LOW_PART
condition|)
name|dest
operator|=
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
condition|)
block|{
specifier|register
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|dest
argument_list|)
decl_stmt|;
comment|/* If this is the first setting of this reg 		     in current basic block, and it was set before, 		     it must be set in two basic blocks, so it cannot 		     be moved out of the loop.  */
if|if
condition|(
name|n_times_set
index|[
name|regno
index|]
operator|>
literal|0
operator|&&
name|last_set
index|[
name|regno
index|]
operator|==
literal|0
condition|)
name|may_not_move
index|[
name|regno
index|]
operator|=
literal|1
expr_stmt|;
comment|/* If this is not first setting in current basic block, 		     see if reg was used in between previous one and this. 		     If so, neither one can be moved.  */
if|if
condition|(
name|last_set
index|[
name|regno
index|]
operator|!=
literal|0
operator|&&
name|reg_used_between_p
argument_list|(
name|dest
argument_list|,
name|last_set
index|[
name|regno
index|]
argument_list|,
name|insn
argument_list|)
condition|)
name|may_not_move
index|[
name|regno
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|n_times_set
index|[
name|regno
index|]
operator|<
literal|127
condition|)
operator|++
name|n_times_set
index|[
name|regno
index|]
expr_stmt|;
name|last_set
index|[
name|regno
index|]
operator|=
name|insn
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
specifier|register
name|rtx
name|x
init|=
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CLOBBER
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
comment|/* Don't move a reg that has an explicit clobber. 		       It's not worth the pain to try to do it correctly.  */
name|may_not_move
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SET
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CLOBBER
condition|)
block|{
name|dest
operator|=
name|SET_DEST
argument_list|(
name|x
argument_list|)
expr_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SIGN_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|STRICT_LOW_PART
condition|)
name|dest
operator|=
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
condition|)
block|{
specifier|register
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|dest
argument_list|)
decl_stmt|;
if|if
condition|(
name|n_times_set
index|[
name|regno
index|]
operator|>
literal|0
operator|&&
name|last_set
index|[
name|regno
index|]
operator|==
literal|0
condition|)
name|may_not_move
index|[
name|regno
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|last_set
index|[
name|regno
index|]
operator|!=
literal|0
operator|&&
name|reg_used_between_p
argument_list|(
name|dest
argument_list|,
name|last_set
index|[
name|regno
index|]
argument_list|,
name|insn
argument_list|)
condition|)
name|may_not_move
index|[
name|regno
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|n_times_set
index|[
name|regno
index|]
operator|<
literal|127
condition|)
operator|++
name|n_times_set
index|[
name|regno
index|]
expr_stmt|;
name|last_set
index|[
name|regno
index|]
operator|=
name|insn
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|last_set
argument_list|,
name|nregs
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|*
name|count_ptr
operator|=
name|count
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a loop that is bounded by LOOP_START and LOOP_END    and that is entered at SCAN_START,    return 1 if the register set in SET contained in insn INSN is used by    any insn that precedes INSN in cyclic order starting    from the loop entry point.     We don't want to use INSN_LUID here because if we restrict INSN to those    that have a valid INSN_LUID, it means we cannot move an invariant out    from an inner loop past two loops.  */
end_comment

begin_function
specifier|static
name|int
name|loop_reg_used_before_p
parameter_list|(
name|set
parameter_list|,
name|insn
parameter_list|,
name|loop_start
parameter_list|,
name|scan_start
parameter_list|,
name|loop_end
parameter_list|)
name|rtx
name|set
decl_stmt|,
name|insn
decl_stmt|,
name|loop_start
decl_stmt|,
name|scan_start
decl_stmt|,
name|loop_end
decl_stmt|;
block|{
name|rtx
name|reg
init|=
name|SET_DEST
argument_list|(
name|set
argument_list|)
decl_stmt|;
name|rtx
name|p
decl_stmt|;
comment|/* Scan forward checking for register usage.  If we hit INSN, we      are done.  Otherwise, if we hit LOOP_END, wrap around to LOOP_START.  */
for|for
control|(
name|p
operator|=
name|scan_start
init|;
name|p
operator|!=
name|insn
condition|;
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
argument_list|)
operator|==
literal|'i'
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|reg
argument_list|,
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|p
operator|==
name|loop_end
condition|)
name|p
operator|=
name|loop_start
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* A "basic induction variable" or biv is a pseudo reg that is set    (within this loop) only by incrementing or decrementing it.  */
end_comment

begin_comment
comment|/* A "general induction variable" or giv is a pseudo reg whose    value is a linear function of a biv.  */
end_comment

begin_comment
comment|/* Bivs are recognized by `basic_induction_var';    Givs by `general_induct_var'.  */
end_comment

begin_comment
comment|/* Indexed by register number, indicates whether or not register is an    induction variable, and if so what type.  */
end_comment

begin_decl_stmt
name|enum
name|iv_mode
modifier|*
name|reg_iv_type
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by register number, contains pointer to `struct induction'    if register is an induction variable.  This holds general info for    all induction variables.  */
end_comment

begin_decl_stmt
name|struct
name|induction
modifier|*
modifier|*
name|reg_iv_info
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by register number, contains pointer to `struct iv_class'    if register is a basic induction variable.  This holds info describing    the class (a related group) of induction variables that the biv belongs    to.  */
end_comment

begin_decl_stmt
name|struct
name|iv_class
modifier|*
modifier|*
name|reg_biv_class
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The head of a list which links together (via the next field)    every iv class for the current loop.  */
end_comment

begin_decl_stmt
name|struct
name|iv_class
modifier|*
name|loop_iv_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Communication with routines called via `note_stores'.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|note_insn
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Dummy register to have non-zero DEST_REG for DEST_ADDR type givs.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|addr_placeholder
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ??? Unfinished optimizations, and possible future optimizations,    for the strength reduction code.  */
end_comment

begin_comment
comment|/* ??? There is one more optimization you might be interested in doing: to    allocate pseudo registers for frequently-accessed memory locations.    If the same memory location is referenced each time around, it might    be possible to copy it into a register before and out after.    This is especially useful when the memory location is a variable which    is in a stack slot because somewhere its address is taken.  If the    loop doesn't contain a function call and the variable isn't volatile,    it is safe to keep the value in a register for the duration of the    loop. One tricky thing is that the copying of the value back from the    register has to be done on all exits from the loop.  You need to check that    all the exits from the loop go to the same place.  */
end_comment

begin_comment
comment|/* ??? The interaction of biv elimination, and recognition of 'constant'    bivs, may cause problems.  */
end_comment

begin_comment
comment|/* ??? Add heuristics so that DEST_ADDR strength reduction does not cause    performance problems.     Perhaps don't eliminate things that can be combined with an addressing    mode.  Find all givs that have the same biv, mult_val, and add_val;    then for each giv, check to see if its only use dies in a following    memory address.  If so, generate a new memory address and check to see    if it is valid.   If it is valid, then store the modified memory address,    otherwise, mark the giv as not done so that it will get its own iv.  */
end_comment

begin_comment
comment|/* ??? Could try to optimize branches when it is known that a biv is always    positive.  */
end_comment

begin_comment
comment|/* ??? When replace a biv in a compare insn, we should replace with closest    giv so that an optimized branch can still be recognized by the combiner,    e.g. the VAX acb insn.  */
end_comment

begin_comment
comment|/* ??? Many of the checks involving uid_luid could be simplified if regscan    was rerun in loop_optimize whenever a register was added or moved.    Also, some of the optimizations could be a little less conservative.  */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Perform strength reduction and induction variable elimination.  */
end_comment

begin_comment
comment|/* Pseudo registers created during this function will be beyond the last    valid index in several tables including n_times_set and regno_last_uid.    This does not cause a problem here, because the added registers cannot be    givs outside of their loop, and hence will never be reconsidered.    But scan_loop must check regnos to make sure they are in bounds.  */
end_comment

begin_function
specifier|static
name|void
name|strength_reduce
parameter_list|(
name|scan_start
parameter_list|,
name|end
parameter_list|,
name|loop_top
parameter_list|,
name|insn_count
parameter_list|,
name|loop_start
parameter_list|,
name|loop_end
parameter_list|,
name|unroll_p
parameter_list|)
name|rtx
name|scan_start
decl_stmt|;
name|rtx
name|end
decl_stmt|;
name|rtx
name|loop_top
decl_stmt|;
name|int
name|insn_count
decl_stmt|;
name|rtx
name|loop_start
decl_stmt|;
name|rtx
name|loop_end
decl_stmt|;
name|int
name|unroll_p
decl_stmt|;
block|{
name|rtx
name|p
decl_stmt|;
name|rtx
name|set
decl_stmt|;
name|rtx
name|inc_val
decl_stmt|;
name|rtx
name|mult_val
decl_stmt|;
name|rtx
name|dest_reg
decl_stmt|;
comment|/* This is 1 if current insn is not executed at least once for every loop      iteration.  */
name|int
name|not_every_iteration
init|=
literal|0
decl_stmt|;
comment|/* This is 1 if current insn may be executed more than once for every      loop iteration.  */
name|int
name|maybe_multiple
init|=
literal|0
decl_stmt|;
comment|/* Temporary list pointers for traversing loop_iv_list.  */
name|struct
name|iv_class
modifier|*
name|bl
decl_stmt|,
modifier|*
modifier|*
name|backbl
decl_stmt|;
comment|/* Ratio of extra register life span we can justify      for saving an instruction.  More if loop doesn't call subroutines      since in that case saving an insn makes more difference      and more registers are available.  */
comment|/* ??? could set this to last value of threshold in move_movables */
name|int
name|threshold
init|=
operator|(
name|loop_has_call
condition|?
literal|1
else|:
literal|2
operator|)
operator|*
operator|(
literal|3
operator|+
name|n_non_fixed_regs
operator|)
decl_stmt|;
comment|/* Map of pseudo-register replacements.  */
name|rtx
modifier|*
name|reg_map
decl_stmt|;
name|int
name|call_seen
decl_stmt|;
name|rtx
name|test
decl_stmt|;
name|rtx
name|end_insert_before
decl_stmt|;
name|int
name|loop_depth
init|=
literal|0
decl_stmt|;
name|reg_iv_type
operator|=
operator|(
expr|enum
name|iv_mode
operator|*
operator|)
name|alloca
argument_list|(
name|max_reg_before_loop
operator|*
sizeof|sizeof
argument_list|(
expr|enum
name|iv_mode
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|reg_iv_type
argument_list|,
name|max_reg_before_loop
operator|*
sizeof|sizeof
argument_list|(
expr|enum
name|iv_mode
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|reg_iv_info
operator|=
operator|(
expr|struct
name|induction
operator|*
operator|*
operator|)
name|alloca
argument_list|(
name|max_reg_before_loop
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|induction
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|reg_iv_info
argument_list|,
operator|(
name|max_reg_before_loop
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|induction
operator|*
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|reg_biv_class
operator|=
operator|(
expr|struct
name|iv_class
operator|*
operator|*
operator|)
name|alloca
argument_list|(
name|max_reg_before_loop
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|iv_class
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|reg_biv_class
argument_list|,
operator|(
name|max_reg_before_loop
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|iv_class
operator|*
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|loop_iv_list
operator|=
literal|0
expr_stmt|;
name|addr_placeholder
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
comment|/* Save insn immediately after the loop_end.  Insns inserted after loop_end      must be put before this insn, so that they will appear in the right      order (i.e. loop order).        If loop_end is the end of the current function, then emit a       NOTE_INSN_DELETED after loop_end and set end_insert_before to the      dummy note insn.  */
if|if
condition|(
name|NEXT_INSN
argument_list|(
name|loop_end
argument_list|)
operator|!=
literal|0
condition|)
name|end_insert_before
operator|=
name|NEXT_INSN
argument_list|(
name|loop_end
argument_list|)
expr_stmt|;
else|else
name|end_insert_before
operator|=
name|emit_note_after
argument_list|(
name|NOTE_INSN_DELETED
argument_list|,
name|loop_end
argument_list|)
expr_stmt|;
comment|/* Scan through loop to find all possible bivs.  */
name|p
operator|=
name|scan_start
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* At end of a straight-in loop, we are done. 	 At end of a loop entered at the bottom, scan the top.  */
if|if
condition|(
name|p
operator|==
name|scan_start
condition|)
break|break;
if|if
condition|(
name|p
operator|==
name|end
condition|)
block|{
if|if
condition|(
name|loop_top
operator|!=
literal|0
condition|)
name|p
operator|=
name|loop_top
expr_stmt|;
else|else
break|break;
if|if
condition|(
name|p
operator|==
name|scan_start
condition|)
break|break;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|INSN
operator|&&
operator|(
name|set
operator|=
name|single_set
argument_list|(
name|p
argument_list|)
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|dest_reg
operator|=
name|SET_DEST
argument_list|(
name|set
argument_list|)
expr_stmt|;
if|if
condition|(
name|REGNO
argument_list|(
name|dest_reg
argument_list|)
operator|<
name|max_reg_before_loop
operator|&&
name|REGNO
argument_list|(
name|dest_reg
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|reg_iv_type
index|[
name|REGNO
argument_list|(
name|dest_reg
argument_list|)
index|]
operator|!=
name|NOT_BASIC_INDUCT
condition|)
block|{
if|if
condition|(
name|basic_induction_var
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
argument_list|,
name|dest_reg
argument_list|,
name|p
argument_list|,
operator|&
name|inc_val
argument_list|,
operator|&
name|mult_val
argument_list|)
condition|)
block|{
comment|/* It is a possible basic induction variable. 		     Create and initialize an induction structure for it.  */
name|struct
name|induction
modifier|*
name|v
init|=
operator|(
expr|struct
name|induction
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|induction
argument_list|)
argument_list|)
decl_stmt|;
name|record_biv
argument_list|(
name|v
argument_list|,
name|p
argument_list|,
name|dest_reg
argument_list|,
name|inc_val
argument_list|,
name|mult_val
argument_list|,
name|not_every_iteration
argument_list|,
name|maybe_multiple
argument_list|)
expr_stmt|;
name|reg_iv_type
index|[
name|REGNO
argument_list|(
name|dest_reg
argument_list|)
index|]
operator|=
name|BASIC_INDUCT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|REGNO
argument_list|(
name|dest_reg
argument_list|)
operator|<
name|max_reg_before_loop
condition|)
name|reg_iv_type
index|[
name|REGNO
argument_list|(
name|dest_reg
argument_list|)
index|]
operator|=
name|NOT_BASIC_INDUCT
expr_stmt|;
block|}
block|}
comment|/* Past CODE_LABEL, we get to insns that may be executed multiple 	 times.  The only way we can be sure that they can't is if every 	 jump insn between here and the end of the loop either 	 returns, exits the loop, is a forward jump, or is a jump 	 to the loop start.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|CODE_LABEL
condition|)
block|{
name|rtx
name|insn
init|=
name|p
decl_stmt|;
name|maybe_multiple
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|==
name|scan_start
condition|)
break|break;
if|if
condition|(
name|insn
operator|==
name|end
condition|)
block|{
if|if
condition|(
name|loop_top
operator|!=
literal|0
condition|)
name|insn
operator|=
name|loop_top
expr_stmt|;
else|else
break|break;
if|if
condition|(
name|insn
operator|==
name|scan_start
condition|)
break|break;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|RETURN
operator|&&
operator|(
operator|!
name|condjump_p
argument_list|(
name|insn
argument_list|)
operator|||
operator|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
operator|!=
literal|0
operator|&&
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
operator|!=
name|scan_start
operator|&&
operator|(
name|INSN_UID
argument_list|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|>=
name|max_uid_for_loop
operator|||
name|INSN_UID
argument_list|(
name|insn
argument_list|)
operator|>=
name|max_uid_for_loop
operator|||
operator|(
name|INSN_LUID
argument_list|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|<
name|INSN_LUID
argument_list|(
name|insn
argument_list|)
operator|)
operator|)
operator|)
operator|)
condition|)
block|{
name|maybe_multiple
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* Past a jump, we get to insns for which we can't count 	 on whether they will be executed during each iteration.  */
comment|/* This code appears twice in strength_reduce.  There is also similar 	 code in scan_loop.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|JUMP_INSN
comment|/* If we enter the loop in the middle, and scan around to the 	     beginning, don't set not_every_iteration for that. 	     This can be any kind of jump, since we want to know if insns 	     will be executed if the loop is executed.  */
operator|&&
operator|!
operator|(
name|JUMP_LABEL
argument_list|(
name|p
argument_list|)
operator|==
name|loop_top
operator|&&
operator|(
operator|(
name|NEXT_INSN
argument_list|(
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
argument_list|)
operator|==
name|loop_end
operator|&&
name|simplejump_p
argument_list|(
name|p
argument_list|)
operator|)
operator|||
operator|(
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
operator|==
name|loop_end
operator|&&
name|condjump_p
argument_list|(
name|p
argument_list|)
operator|)
operator|)
operator|)
condition|)
block|{
name|rtx
name|label
init|=
literal|0
decl_stmt|;
comment|/* If this is a jump outside the loop, then it also doesn't 	     matter.  Check to see if the target of this branch is on the 	     loop_number_exits_labels list.  */
for|for
control|(
name|label
operator|=
name|loop_number_exit_labels
index|[
name|uid_loop_num
index|[
name|INSN_UID
argument_list|(
name|loop_start
argument_list|)
index|]
index|]
init|;
name|label
condition|;
name|label
operator|=
name|LABEL_NEXTREF
argument_list|(
name|label
argument_list|)
control|)
if|if
condition|(
name|XEXP
argument_list|(
name|label
argument_list|,
literal|0
argument_list|)
operator|==
name|JUMP_LABEL
argument_list|(
name|p
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|!
name|label
condition|)
name|not_every_iteration
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|NOTE
condition|)
block|{
comment|/* At the virtual top of a converted loop, insns are again known to 	     be executed each iteration: logically, the loop begins here 	     even though the exit code has been duplicated.  */
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|p
argument_list|)
operator|==
name|NOTE_INSN_LOOP_VTOP
operator|&&
name|loop_depth
operator|==
literal|0
condition|)
name|not_every_iteration
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|p
argument_list|)
operator|==
name|NOTE_INSN_LOOP_BEG
condition|)
name|loop_depth
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|p
argument_list|)
operator|==
name|NOTE_INSN_LOOP_END
condition|)
name|loop_depth
operator|--
expr_stmt|;
block|}
comment|/* Unlike in the code motion pass where MAYBE_NEVER indicates that 	 an insn may never be executed, NOT_EVERY_ITERATION indicates whether 	 or not an insn is known to be executed each iteration of the 	 loop, whether or not any iterations are known to occur.  	 Therefore, if we have just passed a label and have no more labels 	 between here and the test insn of the loop, we know these insns 	 will be executed each iteration.  */
if|if
condition|(
name|not_every_iteration
operator|&&
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|CODE_LABEL
operator|&&
name|no_labels_between_p
argument_list|(
name|p
argument_list|,
name|loop_end
argument_list|)
condition|)
name|not_every_iteration
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Scan loop_iv_list to remove all regs that proved not to be bivs.      Make a sanity check against n_times_set.  */
for|for
control|(
name|backbl
operator|=
operator|&
name|loop_iv_list
operator|,
name|bl
operator|=
operator|*
name|backbl
init|;
name|bl
condition|;
name|bl
operator|=
name|bl
operator|->
name|next
control|)
block|{
if|if
condition|(
name|reg_iv_type
index|[
name|bl
operator|->
name|regno
index|]
operator|!=
name|BASIC_INDUCT
comment|/* Above happens if register modified by subreg, etc.  */
comment|/* Make sure it is not recognized as a basic induction var: */
operator|||
name|n_times_set
index|[
name|bl
operator|->
name|regno
index|]
operator|!=
name|bl
operator|->
name|biv_count
comment|/* If never incremented, it is invariant that we decided not to 	     move.  So leave it alone.  */
operator|||
operator|!
name|bl
operator|->
name|incremented
condition|)
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Reg %d: biv discarded, %s\n"
argument_list|,
name|bl
operator|->
name|regno
argument_list|,
operator|(
name|reg_iv_type
index|[
name|bl
operator|->
name|regno
index|]
operator|!=
name|BASIC_INDUCT
condition|?
literal|"not induction variable"
else|:
operator|(
operator|!
name|bl
operator|->
name|incremented
condition|?
literal|"never incremented"
else|:
literal|"count error"
operator|)
operator|)
argument_list|)
expr_stmt|;
name|reg_iv_type
index|[
name|bl
operator|->
name|regno
index|]
operator|=
name|NOT_BASIC_INDUCT
expr_stmt|;
operator|*
name|backbl
operator|=
name|bl
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
name|backbl
operator|=
operator|&
name|bl
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Reg %d: biv verified\n"
argument_list|,
name|bl
operator|->
name|regno
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Exit if there are no bivs.  */
if|if
condition|(
operator|!
name|loop_iv_list
condition|)
block|{
comment|/* Can still unroll the loop anyways, but indicate that there is no 	 strength reduction info available.  */
if|if
condition|(
name|unroll_p
condition|)
name|unroll_loop
argument_list|(
name|loop_end
argument_list|,
name|insn_count
argument_list|,
name|loop_start
argument_list|,
name|end_insert_before
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Find initial value for each biv by searching backwards from loop_start,      halting at first label.  Also record any test condition.  */
name|call_seen
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|loop_start
init|;
name|p
operator|&&
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|!=
name|CODE_LABEL
condition|;
name|p
operator|=
name|PREV_INSN
argument_list|(
name|p
argument_list|)
control|)
block|{
name|note_insn
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|CALL_INSN
condition|)
name|call_seen
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|JUMP_INSN
operator|||
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|CALL_INSN
condition|)
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|,
name|record_initial
argument_list|)
expr_stmt|;
comment|/* Record any test of a biv that branches around the loop if no store 	 between it and the start of loop.  We only care about tests with 	 constants and registers and only certain of those.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|JUMP_LABEL
argument_list|(
name|p
argument_list|)
operator|!=
literal|0
operator|&&
name|next_real_insn
argument_list|(
name|JUMP_LABEL
argument_list|(
name|p
argument_list|)
argument_list|)
operator|==
name|next_real_insn
argument_list|(
name|loop_end
argument_list|)
operator|&&
operator|(
name|test
operator|=
name|get_condition_for_loop
argument_list|(
name|p
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|test
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|test
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|<
name|max_reg_before_loop
operator|&&
operator|(
name|bl
operator|=
name|reg_biv_class
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|test
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
operator|)
operator|!=
literal|0
operator|&&
name|valid_initial_value_p
argument_list|(
name|XEXP
argument_list|(
name|test
argument_list|,
literal|1
argument_list|)
argument_list|,
name|p
argument_list|,
name|call_seen
argument_list|,
name|loop_start
argument_list|)
operator|&&
name|bl
operator|->
name|init_insn
operator|==
literal|0
condition|)
block|{
comment|/* If an NE test, we have an initial value!  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|test
argument_list|)
operator|==
name|NE
condition|)
block|{
name|bl
operator|->
name|init_insn
operator|=
name|p
expr_stmt|;
name|bl
operator|->
name|init_set
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|XEXP
argument_list|(
name|test
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|test
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|bl
operator|->
name|initial_test
operator|=
name|test
expr_stmt|;
block|}
block|}
comment|/* Look at the each biv and see if we can say anything better about its      initial value from any initializing insns set up above.  (This is done      in two passes to avoid missing SETs in a PARALLEL.)  */
for|for
control|(
name|bl
operator|=
name|loop_iv_list
init|;
name|bl
condition|;
name|bl
operator|=
name|bl
operator|->
name|next
control|)
block|{
name|rtx
name|src
decl_stmt|;
name|rtx
name|note
decl_stmt|;
if|if
condition|(
operator|!
name|bl
operator|->
name|init_insn
condition|)
continue|continue;
comment|/* IF INIT_INSN has a REG_EQUAL or REG_EQUIV note and the value 	 is a constant, use the value of that.  */
if|if
condition|(
operator|(
operator|(
name|note
operator|=
name|find_reg_note
argument_list|(
name|bl
operator|->
name|init_insn
argument_list|,
name|REG_EQUAL
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
operator|(
name|note
operator|=
name|find_reg_note
argument_list|(
name|bl
operator|->
name|init_insn
argument_list|,
name|REG_EQUIV
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
condition|)
name|src
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|src
operator|=
name|SET_SRC
argument_list|(
name|bl
operator|->
name|init_set
argument_list|)
expr_stmt|;
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Biv %d initialized at insn %d: initial value "
argument_list|,
name|bl
operator|->
name|regno
argument_list|,
name|INSN_UID
argument_list|(
name|bl
operator|->
name|init_insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|GET_MODE
argument_list|(
name|src
argument_list|)
operator|==
name|GET_MODE
argument_list|(
name|regno_reg_rtx
index|[
name|bl
operator|->
name|regno
index|]
argument_list|)
operator|||
name|GET_MODE
argument_list|(
name|src
argument_list|)
operator|==
name|VOIDmode
operator|)
operator|&&
name|valid_initial_value_p
argument_list|(
name|src
argument_list|,
name|bl
operator|->
name|init_insn
argument_list|,
name|call_seen
argument_list|,
name|loop_start
argument_list|)
condition|)
block|{
name|bl
operator|->
name|initial_value
operator|=
name|src
expr_stmt|;
if|if
condition|(
name|loop_dump_stream
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|INTVAL
argument_list|(
name|src
argument_list|)
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|loop_dump_stream
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|print_rtl
argument_list|(
name|loop_dump_stream
argument_list|,
name|src
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* Biv initial value is not simple move, 	     so let it keep initial value of "itself".  */
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"is complex\n"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Search the loop for general induction variables.  */
comment|/* A register is a giv if: it is only set once, it is a function of a      biv and a constant (or invariant), and it is not a biv.  */
name|not_every_iteration
operator|=
literal|0
expr_stmt|;
name|loop_depth
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|scan_start
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* At end of a straight-in loop, we are done. 	 At end of a loop entered at the bottom, scan the top.  */
if|if
condition|(
name|p
operator|==
name|scan_start
condition|)
break|break;
if|if
condition|(
name|p
operator|==
name|end
condition|)
block|{
if|if
condition|(
name|loop_top
operator|!=
literal|0
condition|)
name|p
operator|=
name|loop_top
expr_stmt|;
else|else
break|break;
if|if
condition|(
name|p
operator|==
name|scan_start
condition|)
break|break;
block|}
comment|/* Look for a general induction variable in a register.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|INSN
operator|&&
operator|(
name|set
operator|=
name|single_set
argument_list|(
name|p
argument_list|)
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
operator|!
name|may_not_optimize
index|[
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
index|]
condition|)
block|{
name|rtx
name|src_reg
decl_stmt|;
name|rtx
name|add_val
decl_stmt|;
name|rtx
name|mult_val
decl_stmt|;
name|int
name|benefit
decl_stmt|;
name|rtx
name|regnote
init|=
literal|0
decl_stmt|;
name|dest_reg
operator|=
name|SET_DEST
argument_list|(
name|set
argument_list|)
expr_stmt|;
if|if
condition|(
name|REGNO
argument_list|(
name|dest_reg
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
continue|continue;
if|if
condition|(
comment|/* SET_SRC is a giv.  */
operator|(
operator|(
name|benefit
operator|=
name|general_induction_var
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
operator|&
name|src_reg
argument_list|,
operator|&
name|add_val
argument_list|,
operator|&
name|mult_val
argument_list|)
operator|)
comment|/* Equivalent expression is a giv.  */
operator|||
operator|(
operator|(
name|regnote
operator|=
name|find_reg_note
argument_list|(
name|p
argument_list|,
name|REG_EQUAL
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
operator|&&
operator|(
name|benefit
operator|=
name|general_induction_var
argument_list|(
name|XEXP
argument_list|(
name|regnote
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|src_reg
argument_list|,
operator|&
name|add_val
argument_list|,
operator|&
name|mult_val
argument_list|)
operator|)
operator|)
operator|)
comment|/* Don't try to handle any regs made by loop optimization. 		 We have nothing on them in regno_first_uid, etc.  */
operator|&&
name|REGNO
argument_list|(
name|dest_reg
argument_list|)
operator|<
name|max_reg_before_loop
comment|/* Don't recognize a BASIC_INDUCT_VAR here.  */
operator|&&
name|dest_reg
operator|!=
name|src_reg
comment|/* This must be the only place where the register is set.  */
operator|&&
operator|(
name|n_times_set
index|[
name|REGNO
argument_list|(
name|dest_reg
argument_list|)
index|]
operator|==
literal|1
comment|/* or all sets must be consecutive and make a giv.  */
operator|||
operator|(
name|benefit
operator|=
name|consec_sets_giv
argument_list|(
name|benefit
argument_list|,
name|p
argument_list|,
name|src_reg
argument_list|,
name|dest_reg
argument_list|,
operator|&
name|add_val
argument_list|,
operator|&
name|mult_val
argument_list|)
operator|)
operator|)
condition|)
block|{
name|int
name|count
decl_stmt|;
name|struct
name|induction
modifier|*
name|v
init|=
operator|(
expr|struct
name|induction
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|induction
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|temp
decl_stmt|;
comment|/* If this is a library call, increase benefit.  */
if|if
condition|(
name|find_reg_note
argument_list|(
name|p
argument_list|,
name|REG_RETVAL
argument_list|,
name|NULL_RTX
argument_list|)
condition|)
name|benefit
operator|+=
name|libcall_benefit
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* Skip the consecutive insns, if there are any.  */
for|for
control|(
name|count
operator|=
name|n_times_set
index|[
name|REGNO
argument_list|(
name|dest_reg
argument_list|)
index|]
operator|-
literal|1
init|;
name|count
operator|>
literal|0
condition|;
name|count
operator|--
control|)
block|{
comment|/* If first insn of libcall sequence, skip to end. 		     Do this at start of loop, since INSN is guaranteed to 		     be an insn here.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|!=
name|NOTE
operator|&&
operator|(
name|temp
operator|=
name|find_reg_note
argument_list|(
name|p
argument_list|,
name|REG_LIBCALL
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
condition|)
name|p
operator|=
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
do|do
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
expr_stmt|;
do|while
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|NOTE
condition|)
do|;
block|}
name|record_giv
argument_list|(
name|v
argument_list|,
name|p
argument_list|,
name|src_reg
argument_list|,
name|dest_reg
argument_list|,
name|mult_val
argument_list|,
name|add_val
argument_list|,
name|benefit
argument_list|,
name|DEST_REG
argument_list|,
name|not_every_iteration
argument_list|,
name|NULL_PTR
argument_list|,
name|loop_start
argument_list|,
name|loop_end
argument_list|)
expr_stmt|;
block|}
block|}
ifndef|#
directive|ifndef
name|DONT_REDUCE_ADDR
comment|/* Look for givs which are memory addresses.  */
comment|/* This resulted in worse code on a VAX 8600.  I wonder if it 	 still does.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|INSN
condition|)
name|find_mem_givs
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|,
name|p
argument_list|,
name|not_every_iteration
argument_list|,
name|loop_start
argument_list|,
name|loop_end
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Update the status of whether giv can derive other givs.  This can 	 change when we pass a label or an insn that updates a biv.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|JUMP_INSN
operator|||
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|CODE_LABEL
condition|)
name|update_giv_derive
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* Past a jump, we get to insns for which we can't count 	 on whether they will be executed during each iteration.  */
comment|/* This code appears twice in strength_reduce.  There is also similar 	 code in scan_loop.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|JUMP_INSN
comment|/* If we enter the loop in the middle, and scan around to the 	     beginning, don't set not_every_iteration for that. 	     This can be any kind of jump, since we want to know if insns 	     will be executed if the loop is executed.  */
operator|&&
operator|!
operator|(
name|JUMP_LABEL
argument_list|(
name|p
argument_list|)
operator|==
name|loop_top
operator|&&
operator|(
operator|(
name|NEXT_INSN
argument_list|(
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
argument_list|)
operator|==
name|loop_end
operator|&&
name|simplejump_p
argument_list|(
name|p
argument_list|)
operator|)
operator|||
operator|(
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
operator|==
name|loop_end
operator|&&
name|condjump_p
argument_list|(
name|p
argument_list|)
operator|)
operator|)
operator|)
condition|)
block|{
name|rtx
name|label
init|=
literal|0
decl_stmt|;
comment|/* If this is a jump outside the loop, then it also doesn't 	     matter.  Check to see if the target of this branch is on the 	     loop_number_exits_labels list.  */
for|for
control|(
name|label
operator|=
name|loop_number_exit_labels
index|[
name|uid_loop_num
index|[
name|INSN_UID
argument_list|(
name|loop_start
argument_list|)
index|]
index|]
init|;
name|label
condition|;
name|label
operator|=
name|LABEL_NEXTREF
argument_list|(
name|label
argument_list|)
control|)
if|if
condition|(
name|XEXP
argument_list|(
name|label
argument_list|,
literal|0
argument_list|)
operator|==
name|JUMP_LABEL
argument_list|(
name|p
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|!
name|label
condition|)
name|not_every_iteration
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|NOTE
condition|)
block|{
comment|/* At the virtual top of a converted loop, insns are again known to 	     be executed each iteration: logically, the loop begins here 	     even though the exit code has been duplicated.  */
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|p
argument_list|)
operator|==
name|NOTE_INSN_LOOP_VTOP
operator|&&
name|loop_depth
operator|==
literal|0
condition|)
name|not_every_iteration
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|p
argument_list|)
operator|==
name|NOTE_INSN_LOOP_BEG
condition|)
name|loop_depth
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|p
argument_list|)
operator|==
name|NOTE_INSN_LOOP_END
condition|)
name|loop_depth
operator|--
expr_stmt|;
block|}
comment|/* Unlike in the code motion pass where MAYBE_NEVER indicates that 	 an insn may never be executed, NOT_EVERY_ITERATION indicates whether 	 or not an insn is known to be executed each iteration of the 	 loop, whether or not any iterations are known to occur.  	 Therefore, if we have just passed a label and have no more labels 	 between here and the test insn of the loop, we know these insns 	 will be executed each iteration.  */
if|if
condition|(
name|not_every_iteration
operator|&&
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|CODE_LABEL
operator|&&
name|no_labels_between_p
argument_list|(
name|p
argument_list|,
name|loop_end
argument_list|)
condition|)
name|not_every_iteration
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Try to calculate and save the number of loop iterations.  This is      set to zero if the actual number can not be calculated.  This must      be called after all giv's have been identified, since otherwise it may      fail if the iteration variable is a giv.  */
name|loop_n_iterations
operator|=
name|loop_iterations
argument_list|(
name|loop_start
argument_list|,
name|loop_end
argument_list|)
expr_stmt|;
comment|/* Now for each giv for which we still don't know whether or not it is      replaceable, check to see if it is replaceable because its final value      can be calculated.  This must be done after loop_iterations is called,      so that final_giv_value will work correctly.  */
for|for
control|(
name|bl
operator|=
name|loop_iv_list
init|;
name|bl
condition|;
name|bl
operator|=
name|bl
operator|->
name|next
control|)
block|{
name|struct
name|induction
modifier|*
name|v
decl_stmt|;
for|for
control|(
name|v
operator|=
name|bl
operator|->
name|giv
init|;
name|v
condition|;
name|v
operator|=
name|v
operator|->
name|next_iv
control|)
if|if
condition|(
operator|!
name|v
operator|->
name|replaceable
operator|&&
operator|!
name|v
operator|->
name|not_replaceable
condition|)
name|check_final_value
argument_list|(
name|v
argument_list|,
name|loop_start
argument_list|,
name|loop_end
argument_list|)
expr_stmt|;
block|}
comment|/* Try to prove that the loop counter variable (if any) is always      nonnegative; if so, record that fact with a REG_NONNEG note      so that "decrement and branch until zero" insn can be used.  */
name|check_dbra_loop
argument_list|(
name|loop_end
argument_list|,
name|insn_count
argument_list|,
name|loop_start
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAIFA
comment|/* record loop-variables relevant for BCT optimization before unrolling      the loop.  Unrolling may update part of this information, and the      correct data will be used for generating the BCT.  */
ifdef|#
directive|ifdef
name|HAVE_decrement_and_branch_on_count
if|if
condition|(
name|HAVE_decrement_and_branch_on_count
condition|)
name|analyze_loop_iterations
argument_list|(
name|loop_start
argument_list|,
name|loop_end
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* HAIFA */
comment|/* Create reg_map to hold substitutions for replaceable giv regs.  */
name|reg_map
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|max_reg_before_loop
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|reg_map
argument_list|,
name|max_reg_before_loop
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Examine each iv class for feasibility of strength reduction/induction      variable elimination.  */
for|for
control|(
name|bl
operator|=
name|loop_iv_list
init|;
name|bl
condition|;
name|bl
operator|=
name|bl
operator|->
name|next
control|)
block|{
name|struct
name|induction
modifier|*
name|v
decl_stmt|;
name|int
name|benefit
decl_stmt|;
name|int
name|all_reduced
decl_stmt|;
name|rtx
name|final_value
init|=
literal|0
decl_stmt|;
comment|/* Test whether it will be possible to eliminate this biv 	 provided all givs are reduced.  This is possible if either 	 the reg is not used outside the loop, or we can compute 	 what its final value will be.  	 For architectures with a decrement_and_branch_until_zero insn, 	 don't do this if we put a REG_NONNEG note on the endtest for 	 this biv.  */
comment|/* Compare against bl->init_insn rather than loop_start. 	 We aren't concerned with any uses of the biv between 	 init_insn and loop_start since these won't be affected 	 by the value of the biv elsewhere in the function, so 	 long as init_insn doesn't use the biv itself. 	 March 14, 1989 -- self@bayes.arc.nasa.gov */
if|if
condition|(
operator|(
name|uid_luid
index|[
name|REGNO_LAST_UID
argument_list|(
name|bl
operator|->
name|regno
argument_list|)
index|]
operator|<
name|INSN_LUID
argument_list|(
name|loop_end
argument_list|)
operator|&&
name|bl
operator|->
name|init_insn
operator|&&
name|INSN_UID
argument_list|(
name|bl
operator|->
name|init_insn
argument_list|)
operator|<
name|max_uid_for_loop
operator|&&
name|uid_luid
index|[
name|REGNO_FIRST_UID
argument_list|(
name|bl
operator|->
name|regno
argument_list|)
index|]
operator|>=
name|INSN_LUID
argument_list|(
name|bl
operator|->
name|init_insn
argument_list|)
ifdef|#
directive|ifdef
name|HAVE_decrement_and_branch_until_zero
operator|&&
operator|!
name|bl
operator|->
name|nonneg
endif|#
directive|endif
operator|&&
operator|!
name|reg_mentioned_p
argument_list|(
name|bl
operator|->
name|biv
operator|->
name|dest_reg
argument_list|,
name|SET_SRC
argument_list|(
name|bl
operator|->
name|init_set
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
operator|(
name|final_value
operator|=
name|final_biv_value
argument_list|(
name|bl
argument_list|,
name|loop_start
argument_list|,
name|loop_end
argument_list|)
operator|)
ifdef|#
directive|ifdef
name|HAVE_decrement_and_branch_until_zero
operator|&&
operator|!
name|bl
operator|->
name|nonneg
endif|#
directive|endif
operator|)
condition|)
name|bl
operator|->
name|eliminable
operator|=
name|maybe_eliminate_biv
argument_list|(
name|bl
argument_list|,
name|loop_start
argument_list|,
name|end
argument_list|,
literal|0
argument_list|,
name|threshold
argument_list|,
name|insn_count
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
block|{
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Cannot eliminate biv %d.\n"
argument_list|,
name|bl
operator|->
name|regno
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"First use: insn %d, last use: insn %d.\n"
argument_list|,
name|REGNO_FIRST_UID
argument_list|(
name|bl
operator|->
name|regno
argument_list|)
argument_list|,
name|REGNO_LAST_UID
argument_list|(
name|bl
operator|->
name|regno
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Combine all giv's for this iv_class.  */
name|combine_givs
argument_list|(
name|bl
argument_list|)
expr_stmt|;
comment|/* This will be true at the end, if all givs which depend on this 	 biv have been strength reduced. 	 We can't (currently) eliminate the biv unless this is so.  */
name|all_reduced
operator|=
literal|1
expr_stmt|;
comment|/* Check each giv in this class to see if we will benefit by reducing 	 it.  Skip giv's combined with others.  */
for|for
control|(
name|v
operator|=
name|bl
operator|->
name|giv
init|;
name|v
condition|;
name|v
operator|=
name|v
operator|->
name|next_iv
control|)
block|{
name|struct
name|induction
modifier|*
name|tv
decl_stmt|;
if|if
condition|(
name|v
operator|->
name|ignore
operator|||
name|v
operator|->
name|same
condition|)
continue|continue;
name|benefit
operator|=
name|v
operator|->
name|benefit
expr_stmt|;
comment|/* Reduce benefit if not replaceable, since we will insert 	     a move-insn to replace the insn that calculates this giv. 	     Don't do this unless the giv is a user variable, since it 	     will often be marked non-replaceable because of the duplication 	     of the exit code outside the loop.  In such a case, the copies 	     we insert are dead and will be deleted.  So they don't have 	     a cost.  Similar situations exist.  */
comment|/* ??? The new final_[bg]iv_value code does a much better job 	     of finding replaceable giv's, and hence this code may no longer 	     be necessary.  */
if|if
condition|(
operator|!
name|v
operator|->
name|replaceable
operator|&&
operator|!
name|bl
operator|->
name|eliminable
operator|&&
name|REG_USERVAR_P
argument_list|(
name|v
operator|->
name|dest_reg
argument_list|)
condition|)
name|benefit
operator|-=
name|copy_cost
expr_stmt|;
comment|/* Decrease the benefit to count the add-insns that we will 	     insert to increment the reduced reg for the giv.  */
name|benefit
operator|-=
name|add_cost
operator|*
name|bl
operator|->
name|biv_count
expr_stmt|;
comment|/* Decide whether to strength-reduce this giv or to leave the code 	     unchanged (recompute it from the biv each time it is used). 	     This decision can be made independently for each giv.  */
ifdef|#
directive|ifdef
name|AUTO_INC_DEC
comment|/* Attempt to guess whether autoincrement will handle some of the 	     new add insns; if so, increase BENEFIT (undo the subtraction of 	     add_cost that was done above).  */
if|if
condition|(
name|v
operator|->
name|giv_type
operator|==
name|DEST_ADDR
operator|&&
name|GET_CODE
argument_list|(
name|v
operator|->
name|mult_val
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|HAVE_POST_INCREMENT
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_PRE_INCREMENT
argument_list|)
if|if
condition|(
name|INTVAL
argument_list|(
name|v
operator|->
name|mult_val
argument_list|)
operator|==
name|GET_MODE_SIZE
argument_list|(
name|v
operator|->
name|mem_mode
argument_list|)
condition|)
name|benefit
operator|+=
name|add_cost
operator|*
name|bl
operator|->
name|biv_count
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|HAVE_POST_DECREMENT
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_PRE_DECREMENT
argument_list|)
if|if
condition|(
operator|-
name|INTVAL
argument_list|(
name|v
operator|->
name|mult_val
argument_list|)
operator|==
name|GET_MODE_SIZE
argument_list|(
name|v
operator|->
name|mem_mode
argument_list|)
condition|)
name|benefit
operator|+=
name|add_cost
operator|*
name|bl
operator|->
name|biv_count
expr_stmt|;
endif|#
directive|endif
block|}
endif|#
directive|endif
comment|/* If an insn is not to be strength reduced, then set its ignore 	     flag, and clear all_reduced.  */
comment|/* A giv that depends on a reversed biv must be reduced if it is 	     used after the loop exit, otherwise, it would have the wrong 	     value after the loop exit.  To make it simple, just reduce all 	     of such giv's whether or not we know they are used after the loop 	     exit.  */
if|if
condition|(
operator|!
name|flag_reduce_all_givs
operator|&&
name|v
operator|->
name|lifetime
operator|*
name|threshold
operator|*
name|benefit
operator|<
name|insn_count
operator|&&
operator|!
name|bl
operator|->
name|reversed
condition|)
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"giv of insn %d not worth while, %d vs %d.\n"
argument_list|,
name|INSN_UID
argument_list|(
name|v
operator|->
name|insn
argument_list|)
argument_list|,
name|v
operator|->
name|lifetime
operator|*
name|threshold
operator|*
name|benefit
argument_list|,
name|insn_count
argument_list|)
expr_stmt|;
name|v
operator|->
name|ignore
operator|=
literal|1
expr_stmt|;
name|all_reduced
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* Check that we can increment the reduced giv without a 		 multiply insn.  If not, reject it.  */
for|for
control|(
name|tv
operator|=
name|bl
operator|->
name|biv
init|;
name|tv
condition|;
name|tv
operator|=
name|tv
operator|->
name|next_iv
control|)
if|if
condition|(
name|tv
operator|->
name|mult_val
operator|==
name|const1_rtx
operator|&&
operator|!
name|product_cheap_p
argument_list|(
name|tv
operator|->
name|add_val
argument_list|,
name|v
operator|->
name|mult_val
argument_list|)
condition|)
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"giv of insn %d: would need a multiply.\n"
argument_list|,
name|INSN_UID
argument_list|(
name|v
operator|->
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|v
operator|->
name|ignore
operator|=
literal|1
expr_stmt|;
name|all_reduced
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* Reduce each giv that we decided to reduce.  */
for|for
control|(
name|v
operator|=
name|bl
operator|->
name|giv
init|;
name|v
condition|;
name|v
operator|=
name|v
operator|->
name|next_iv
control|)
block|{
name|struct
name|induction
modifier|*
name|tv
decl_stmt|;
if|if
condition|(
operator|!
name|v
operator|->
name|ignore
operator|&&
name|v
operator|->
name|same
operator|==
literal|0
condition|)
block|{
name|int
name|auto_inc_opt
init|=
literal|0
decl_stmt|;
name|v
operator|->
name|new_reg
operator|=
name|gen_reg_rtx
argument_list|(
name|v
operator|->
name|mode
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AUTO_INC_DEC
comment|/* If the target has auto-increment addressing modes, and 		 this is an address giv, then try to put the increment 		 immediately after its use, so that flow can create an 		 auto-increment addressing mode.  */
if|if
condition|(
name|v
operator|->
name|giv_type
operator|==
name|DEST_ADDR
operator|&&
name|bl
operator|->
name|biv_count
operator|==
literal|1
operator|&&
name|bl
operator|->
name|biv
operator|->
name|always_executed
operator|&&
operator|!
name|bl
operator|->
name|biv
operator|->
name|maybe_multiple
comment|/* We don't handle reversed biv's because bl->biv->insn 		     does not have a valid INSN_LUID.  */
operator|&&
operator|!
name|bl
operator|->
name|reversed
operator|&&
name|v
operator|->
name|always_executed
operator|&&
operator|!
name|v
operator|->
name|maybe_multiple
operator|&&
name|INSN_UID
argument_list|(
name|v
operator|->
name|insn
argument_list|)
operator|<
name|max_uid_for_loop
condition|)
block|{
comment|/* If other giv's have been combined with this one, then 		     this will work only if all uses of the other giv's occur 		     before this giv's insn.  This is difficult to check.  		     We simplify this by looking for the common case where 		     there is one DEST_REG giv, and this giv's insn is the 		     last use of the dest_reg of that DEST_REG giv.  If the 		     increment occurs after the address giv, then we can 		     perform the optimization.  (Otherwise, the increment 		     would have to go before other_giv, and we would not be 		     able to combine it with the address giv to get an 		     auto-inc address.)  */
if|if
condition|(
name|v
operator|->
name|combined_with
condition|)
block|{
name|struct
name|induction
modifier|*
name|other_giv
init|=
literal|0
decl_stmt|;
for|for
control|(
name|tv
operator|=
name|bl
operator|->
name|giv
init|;
name|tv
condition|;
name|tv
operator|=
name|tv
operator|->
name|next_iv
control|)
if|if
condition|(
name|tv
operator|->
name|same
operator|==
name|v
condition|)
block|{
if|if
condition|(
name|other_giv
condition|)
break|break;
else|else
name|other_giv
operator|=
name|tv
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|tv
operator|&&
name|other_giv
operator|&&
name|REGNO
argument_list|(
name|other_giv
operator|->
name|dest_reg
argument_list|)
operator|<
name|max_reg_before_loop
operator|&&
operator|(
name|REGNO_LAST_UID
argument_list|(
name|REGNO
argument_list|(
name|other_giv
operator|->
name|dest_reg
argument_list|)
argument_list|)
operator|==
name|INSN_UID
argument_list|(
name|v
operator|->
name|insn
argument_list|)
operator|)
operator|&&
name|INSN_LUID
argument_list|(
name|v
operator|->
name|insn
argument_list|)
operator|<
name|INSN_LUID
argument_list|(
name|bl
operator|->
name|biv
operator|->
name|insn
argument_list|)
condition|)
name|auto_inc_opt
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Check for case where increment is before the address 		     giv.  Do this test in "loop order".  */
elseif|else
if|if
condition|(
operator|(
name|INSN_LUID
argument_list|(
name|v
operator|->
name|insn
argument_list|)
operator|>
name|INSN_LUID
argument_list|(
name|bl
operator|->
name|biv
operator|->
name|insn
argument_list|)
operator|&&
operator|(
name|INSN_LUID
argument_list|(
name|v
operator|->
name|insn
argument_list|)
operator|<
name|INSN_LUID
argument_list|(
name|scan_start
argument_list|)
operator|||
operator|(
name|INSN_LUID
argument_list|(
name|bl
operator|->
name|biv
operator|->
name|insn
argument_list|)
operator|>
name|INSN_LUID
argument_list|(
name|scan_start
argument_list|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|INSN_LUID
argument_list|(
name|v
operator|->
name|insn
argument_list|)
operator|<
name|INSN_LUID
argument_list|(
name|scan_start
argument_list|)
operator|&&
operator|(
name|INSN_LUID
argument_list|(
name|scan_start
argument_list|)
operator|<
name|INSN_LUID
argument_list|(
name|bl
operator|->
name|biv
operator|->
name|insn
argument_list|)
operator|)
operator|)
condition|)
name|auto_inc_opt
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|auto_inc_opt
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_cc0
block|{
name|rtx
name|prev
decl_stmt|;
comment|/* We can't put an insn immediately after one setting 		       cc0, or immediately before one using cc0.  */
if|if
condition|(
operator|(
name|auto_inc_opt
operator|==
literal|1
operator|&&
name|sets_cc0_p
argument_list|(
name|PATTERN
argument_list|(
name|v
operator|->
name|insn
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|auto_inc_opt
operator|==
operator|-
literal|1
operator|&&
operator|(
name|prev
operator|=
name|prev_nonnote_insn
argument_list|(
name|v
operator|->
name|insn
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|prev
argument_list|)
argument_list|)
operator|==
literal|'i'
operator|&&
name|sets_cc0_p
argument_list|(
name|PATTERN
argument_list|(
name|prev
argument_list|)
argument_list|)
operator|)
condition|)
name|auto_inc_opt
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|auto_inc_opt
condition|)
name|v
operator|->
name|auto_inc_opt
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* For each place where the biv is incremented, add an insn 		 to increment the new, reduced reg for the giv.  */
for|for
control|(
name|tv
operator|=
name|bl
operator|->
name|biv
init|;
name|tv
condition|;
name|tv
operator|=
name|tv
operator|->
name|next_iv
control|)
block|{
name|rtx
name|insert_before
decl_stmt|;
if|if
condition|(
operator|!
name|auto_inc_opt
condition|)
name|insert_before
operator|=
name|tv
operator|->
name|insn
expr_stmt|;
elseif|else
if|if
condition|(
name|auto_inc_opt
operator|==
literal|1
condition|)
name|insert_before
operator|=
name|NEXT_INSN
argument_list|(
name|v
operator|->
name|insn
argument_list|)
expr_stmt|;
else|else
name|insert_before
operator|=
name|v
operator|->
name|insn
expr_stmt|;
if|if
condition|(
name|tv
operator|->
name|mult_val
operator|==
name|const1_rtx
condition|)
name|emit_iv_add_mult
argument_list|(
name|tv
operator|->
name|add_val
argument_list|,
name|v
operator|->
name|mult_val
argument_list|,
name|v
operator|->
name|new_reg
argument_list|,
name|v
operator|->
name|new_reg
argument_list|,
name|insert_before
argument_list|)
expr_stmt|;
else|else
comment|/* tv->mult_val == const0_rtx */
comment|/* A multiply is acceptable here 		       since this is presumed to be seldom executed.  */
name|emit_iv_add_mult
argument_list|(
name|tv
operator|->
name|add_val
argument_list|,
name|v
operator|->
name|mult_val
argument_list|,
name|v
operator|->
name|add_val
argument_list|,
name|v
operator|->
name|new_reg
argument_list|,
name|insert_before
argument_list|)
expr_stmt|;
block|}
comment|/* Add code at loop start to initialize giv's reduced reg.  */
name|emit_iv_add_mult
argument_list|(
name|bl
operator|->
name|initial_value
argument_list|,
name|v
operator|->
name|mult_val
argument_list|,
name|v
operator|->
name|add_val
argument_list|,
name|v
operator|->
name|new_reg
argument_list|,
name|loop_start
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Rescan all givs.  If a giv is the same as a giv not reduced, mark it 	 as not reduced. 	  	 For each giv register that can be reduced now: if replaceable, 	 substitute reduced reg wherever the old giv occurs; 	 else add new move insn "giv_reg = reduced_reg".  	 Also check for givs whose first use is their definition and whose 	 last use is the definition of another giv.  If so, it is likely 	 dead and should not be used to eliminate a biv.  */
for|for
control|(
name|v
operator|=
name|bl
operator|->
name|giv
init|;
name|v
condition|;
name|v
operator|=
name|v
operator|->
name|next_iv
control|)
block|{
if|if
condition|(
name|v
operator|->
name|same
operator|&&
name|v
operator|->
name|same
operator|->
name|ignore
condition|)
name|v
operator|->
name|ignore
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|ignore
condition|)
continue|continue;
if|if
condition|(
name|v
operator|->
name|giv_type
operator|==
name|DEST_REG
operator|&&
name|REGNO_FIRST_UID
argument_list|(
name|REGNO
argument_list|(
name|v
operator|->
name|dest_reg
argument_list|)
argument_list|)
operator|==
name|INSN_UID
argument_list|(
name|v
operator|->
name|insn
argument_list|)
condition|)
block|{
name|struct
name|induction
modifier|*
name|v1
decl_stmt|;
for|for
control|(
name|v1
operator|=
name|bl
operator|->
name|giv
init|;
name|v1
condition|;
name|v1
operator|=
name|v1
operator|->
name|next_iv
control|)
if|if
condition|(
name|REGNO_LAST_UID
argument_list|(
name|REGNO
argument_list|(
name|v
operator|->
name|dest_reg
argument_list|)
argument_list|)
operator|==
name|INSN_UID
argument_list|(
name|v1
operator|->
name|insn
argument_list|)
condition|)
name|v
operator|->
name|maybe_dead
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Update expression if this was combined, in case other giv was 	     replaced.  */
if|if
condition|(
name|v
operator|->
name|same
condition|)
name|v
operator|->
name|new_reg
operator|=
name|replace_rtx
argument_list|(
name|v
operator|->
name|new_reg
argument_list|,
name|v
operator|->
name|same
operator|->
name|dest_reg
argument_list|,
name|v
operator|->
name|same
operator|->
name|new_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|giv_type
operator|==
name|DEST_ADDR
condition|)
comment|/* Store reduced reg as the address in the memref where we found 	       this giv.  */
name|validate_change
argument_list|(
name|v
operator|->
name|insn
argument_list|,
name|v
operator|->
name|location
argument_list|,
name|v
operator|->
name|new_reg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|v
operator|->
name|replaceable
condition|)
block|{
name|reg_map
index|[
name|REGNO
argument_list|(
name|v
operator|->
name|dest_reg
argument_list|)
index|]
operator|=
name|v
operator|->
name|new_reg
expr_stmt|;
if|#
directive|if
literal|0
comment|/* I can no longer duplicate the original problem.  Perhaps 		 this is unnecessary now?  */
comment|/* Replaceable; it isn't strictly necessary to delete the old 		 insn and emit a new one, because v->dest_reg is now dead.  		 However, especially when unrolling loops, the special 		 handling for (set REG0 REG1) in the second cse pass may 		 make v->dest_reg live again.  To avoid this problem, emit 		 an insn to set the original giv reg from the reduced giv. 		 We can not delete the original insn, since it may be part 		 of a LIBCALL, and the code in flow that eliminates dead 		 libcalls will fail if it is deleted.  */
block|emit_insn_after (gen_move_insn (v->dest_reg, v->new_reg), 			       v->insn);
endif|#
directive|endif
block|}
else|else
block|{
comment|/* Not replaceable; emit an insn to set the original giv reg from 		 the reduced giv, same as above.  */
name|emit_insn_after
argument_list|(
name|gen_move_insn
argument_list|(
name|v
operator|->
name|dest_reg
argument_list|,
name|v
operator|->
name|new_reg
argument_list|)
argument_list|,
name|v
operator|->
name|insn
argument_list|)
expr_stmt|;
block|}
comment|/* When a loop is reversed, givs which depend on the reversed 	     biv, and which are live outside the loop, must be set to their 	     correct final value.  This insn is only needed if the giv is 	     not replaceable.  The correct final value is the same as the 	     value that the giv starts the reversed loop with.  */
if|if
condition|(
name|bl
operator|->
name|reversed
operator|&&
operator|!
name|v
operator|->
name|replaceable
condition|)
name|emit_iv_add_mult
argument_list|(
name|bl
operator|->
name|initial_value
argument_list|,
name|v
operator|->
name|mult_val
argument_list|,
name|v
operator|->
name|add_val
argument_list|,
name|v
operator|->
name|dest_reg
argument_list|,
name|end_insert_before
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|v
operator|->
name|final_value
condition|)
block|{
name|rtx
name|insert_before
decl_stmt|;
comment|/* If the loop has multiple exits, emit the insn before the 		 loop to ensure that it will always be executed no matter 		 how the loop exits.  Otherwise, emit the insn after the loop, 		 since this is slightly more efficient.  */
if|if
condition|(
name|loop_number_exit_count
index|[
name|uid_loop_num
index|[
name|INSN_UID
argument_list|(
name|loop_start
argument_list|)
index|]
index|]
condition|)
name|insert_before
operator|=
name|loop_start
expr_stmt|;
else|else
name|insert_before
operator|=
name|end_insert_before
expr_stmt|;
name|emit_insn_before
argument_list|(
name|gen_move_insn
argument_list|(
name|v
operator|->
name|dest_reg
argument_list|,
name|v
operator|->
name|final_value
argument_list|)
argument_list|,
name|insert_before
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* If the insn to set the final value of the giv was emitted 		 before the loop, then we must delete the insn inside the loop 		 that sets it.  If this is a LIBCALL, then we must delete 		 every insn in the libcall.  Note, however, that 		 final_giv_value will only succeed when there are multiple 		 exits if the giv is dead at each exit, hence it does not 		 matter that the original insn remains because it is dead 		 anyways.  */
comment|/* Delete the insn inside the loop that sets the giv since 		 the giv is now set before (or after) the loop.  */
block|delete_insn (v->insn);
endif|#
directive|endif
block|}
if|if
condition|(
name|loop_dump_stream
condition|)
block|{
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"giv at %d reduced to "
argument_list|,
name|INSN_UID
argument_list|(
name|v
operator|->
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|print_rtl
argument_list|(
name|loop_dump_stream
argument_list|,
name|v
operator|->
name|new_reg
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* All the givs based on the biv bl have been reduced if they 	 merit it.  */
comment|/* For each giv not marked as maybe dead that has been combined with a 	 second giv, clear any "maybe dead" mark on that second giv. 	 v->new_reg will either be or refer to the register of the giv it 	 combined with.  	 Doing this clearing avoids problems in biv elimination where a 	 giv's new_reg is a complex value that can't be put in the insn but 	 the giv combined with (with a reg as new_reg) is marked maybe_dead. 	 Since the register will be used in either case, we'd prefer it be 	 used from the simpler giv.  */
for|for
control|(
name|v
operator|=
name|bl
operator|->
name|giv
init|;
name|v
condition|;
name|v
operator|=
name|v
operator|->
name|next_iv
control|)
if|if
condition|(
operator|!
name|v
operator|->
name|maybe_dead
operator|&&
name|v
operator|->
name|same
condition|)
name|v
operator|->
name|same
operator|->
name|maybe_dead
operator|=
literal|0
expr_stmt|;
comment|/* Try to eliminate the biv, if it is a candidate. 	 This won't work if ! all_reduced, 	 since the givs we planned to use might not have been reduced.  	 We have to be careful that we didn't initially think we could eliminate 	 this biv because of a giv that we now think may be dead and shouldn't 	 be used as a biv replacement.    	 Also, there is the possibility that we may have a giv that looks 	 like it can be used to eliminate a biv, but the resulting insn 	 isn't valid.  This can happen, for example, on the 88k, where a  	 JUMP_INSN can compare a register only with zero.  Attempts to 	 replace it with a compare with a constant will fail.  	 Note that in cases where this call fails, we may have replaced some 	 of the occurrences of the biv with a giv, but no harm was done in 	 doing so in the rare cases where it can occur.  */
if|if
condition|(
name|all_reduced
operator|==
literal|1
operator|&&
name|bl
operator|->
name|eliminable
operator|&&
name|maybe_eliminate_biv
argument_list|(
name|bl
argument_list|,
name|loop_start
argument_list|,
name|end
argument_list|,
literal|1
argument_list|,
name|threshold
argument_list|,
name|insn_count
argument_list|)
condition|)
block|{
comment|/* ?? If we created a new test to bypass the loop entirely, 	     or otherwise drop straight in, based on this test, then 	     we might want to rewrite it also.  This way some later 	     pass has more hope of removing the initialization of this 	     biv entirely.  */
comment|/* If final_value != 0, then the biv may be used after loop end 	     and we must emit an insn to set it just in case.  	     Reversed bivs already have an insn after the loop setting their 	     value, so we don't need another one.  We can't calculate the 	     proper final value for such a biv here anyways.  */
if|if
condition|(
name|final_value
operator|!=
literal|0
operator|&&
operator|!
name|bl
operator|->
name|reversed
condition|)
block|{
name|rtx
name|insert_before
decl_stmt|;
comment|/* If the loop has multiple exits, emit the insn before the 		 loop to ensure that it will always be executed no matter 		 how the loop exits.  Otherwise, emit the insn after the 		 loop, since this is slightly more efficient.  */
if|if
condition|(
name|loop_number_exit_count
index|[
name|uid_loop_num
index|[
name|INSN_UID
argument_list|(
name|loop_start
argument_list|)
index|]
index|]
condition|)
name|insert_before
operator|=
name|loop_start
expr_stmt|;
else|else
name|insert_before
operator|=
name|end_insert_before
expr_stmt|;
name|emit_insn_before
argument_list|(
name|gen_move_insn
argument_list|(
name|bl
operator|->
name|biv
operator|->
name|dest_reg
argument_list|,
name|final_value
argument_list|)
argument_list|,
name|end_insert_before
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* Delete all of the instructions inside the loop which set 	     the biv, as they are all dead.  If is safe to delete them, 	     because an insn setting a biv will never be part of a libcall.  */
comment|/* However, deleting them will invalidate the regno_last_uid info, 	     so keeping them around is more convenient.  Final_biv_value 	     will only succeed when there are multiple exits if the biv 	     is dead at each exit, hence it does not matter that the original 	     insn remains, because it is dead anyways.  */
block|for (v = bl->biv; v; v = v->next_iv) 	    delete_insn (v->insn);
endif|#
directive|endif
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Reg %d: biv eliminated\n"
argument_list|,
name|bl
operator|->
name|regno
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Go through all the instructions in the loop, making all the      register substitutions scheduled in REG_MAP.  */
for|for
control|(
name|p
operator|=
name|loop_start
init|;
name|p
operator|!=
name|end
condition|;
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|JUMP_INSN
operator|||
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
name|replace_regs
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|,
name|reg_map
argument_list|,
name|max_reg_before_loop
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|replace_regs
argument_list|(
name|REG_NOTES
argument_list|(
name|p
argument_list|)
argument_list|,
name|reg_map
argument_list|,
name|max_reg_before_loop
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|INSN_CODE
argument_list|(
name|p
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* Unroll loops from within strength reduction so that we can use the      induction variable information that strength_reduce has already      collected.  */
if|if
condition|(
name|unroll_p
condition|)
name|unroll_loop
argument_list|(
name|loop_end
argument_list|,
name|insn_count
argument_list|,
name|loop_start
argument_list|,
name|end_insert_before
argument_list|,
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAIFA
comment|/* instrument the loop with bct insn */
ifdef|#
directive|ifdef
name|HAVE_decrement_and_branch_on_count
if|if
condition|(
name|HAVE_decrement_and_branch_on_count
condition|)
name|insert_bct
argument_list|(
name|loop_start
argument_list|,
name|loop_end
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* HAIFA */
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if X is a valid source for an initial value (or as value being    compared against in an initial test).     X must be either a register or constant and must not be clobbered between    the current insn and the start of the loop.     INSN is the insn containing X.  */
end_comment

begin_function
specifier|static
name|int
name|valid_initial_value_p
parameter_list|(
name|x
parameter_list|,
name|insn
parameter_list|,
name|call_seen
parameter_list|,
name|loop_start
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|int
name|call_seen
decl_stmt|;
name|rtx
name|loop_start
decl_stmt|;
block|{
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|x
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Only consider pseudos we know about initialized in insns whose luids      we know.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO
argument_list|(
name|x
argument_list|)
operator|>=
name|max_reg_before_loop
condition|)
return|return
literal|0
return|;
comment|/* Don't use call-clobbered registers across a call which clobbers it.  On      some machines, don't use any hard registers at all.  */
if|if
condition|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
operator|(
name|SMALL_REGISTER_CLASSES
operator|||
operator|(
name|call_used_regs
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
operator|&&
name|call_seen
operator|)
operator|)
condition|)
return|return
literal|0
return|;
comment|/* Don't use registers that have been clobbered before the start of the      loop.  */
if|if
condition|(
name|reg_set_between_p
argument_list|(
name|x
argument_list|,
name|insn
argument_list|,
name|loop_start
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Scan X for memory refs and check each memory address    as a possible giv.  INSN is the insn whose pattern X comes from.    NOT_EVERY_ITERATION is 1 if the insn might not be executed during    every loop iteration.  */
end_comment

begin_function
specifier|static
name|void
name|find_mem_givs
parameter_list|(
name|x
parameter_list|,
name|insn
parameter_list|,
name|not_every_iteration
parameter_list|,
name|loop_start
parameter_list|,
name|loop_end
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|int
name|not_every_iteration
decl_stmt|;
name|rtx
name|loop_start
decl_stmt|,
name|loop_end
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|register
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|REG
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
case|case
name|PC
case|:
case|case
name|CC0
case|:
case|case
name|ADDR_VEC
case|:
case|case
name|ADDR_DIFF_VEC
case|:
case|case
name|USE
case|:
case|case
name|CLOBBER
case|:
return|return;
case|case
name|MEM
case|:
block|{
name|rtx
name|src_reg
decl_stmt|;
name|rtx
name|add_val
decl_stmt|;
name|rtx
name|mult_val
decl_stmt|;
name|int
name|benefit
decl_stmt|;
name|benefit
operator|=
name|general_induction_var
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|src_reg
argument_list|,
operator|&
name|add_val
argument_list|,
operator|&
name|mult_val
argument_list|)
expr_stmt|;
comment|/* Don't make a DEST_ADDR giv with mult_val == 1&& add_val == 0. 	   Such a giv isn't useful.  */
if|if
condition|(
name|benefit
operator|>
literal|0
operator|&&
operator|(
name|mult_val
operator|!=
name|const1_rtx
operator|||
name|add_val
operator|!=
name|const0_rtx
operator|)
condition|)
block|{
comment|/* Found one; record it.  */
name|struct
name|induction
modifier|*
name|v
init|=
operator|(
expr|struct
name|induction
operator|*
operator|)
name|oballoc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|induction
argument_list|)
argument_list|)
decl_stmt|;
name|record_giv
argument_list|(
name|v
argument_list|,
name|insn
argument_list|,
name|src_reg
argument_list|,
name|addr_placeholder
argument_list|,
name|mult_val
argument_list|,
name|add_val
argument_list|,
name|benefit
argument_list|,
name|DEST_ADDR
argument_list|,
name|not_every_iteration
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|loop_start
argument_list|,
name|loop_end
argument_list|)
expr_stmt|;
name|v
operator|->
name|mem_mode
operator|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
default|default:
break|break;
block|}
comment|/* Recursively scan the subexpressions for other mem refs.  */
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|find_mem_givs
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|insn
argument_list|,
name|not_every_iteration
argument_list|,
name|loop_start
argument_list|,
name|loop_end
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|find_mem_givs
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|insn
argument_list|,
name|not_every_iteration
argument_list|,
name|loop_start
argument_list|,
name|loop_end
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Fill in the data about one biv update.    V is the `struct induction' in which we record the biv.  (It is    allocated by the caller, with alloca.)    INSN is the insn that sets it.    DEST_REG is the biv's reg.     MULT_VAL is const1_rtx if the biv is being incremented here, in which case    INC_VAL is the increment.  Otherwise, MULT_VAL is const0_rtx and the biv is    being set to INC_VAL.     NOT_EVERY_ITERATION is nonzero if this biv update is not know to be    executed every iteration; MAYBE_MULTIPLE is nonzero if this biv update    can be executed more than once per iteration.  If MAYBE_MULTIPLE    and NOT_EVERY_ITERATION are both zero, we know that the biv update is    executed exactly once per iteration.  */
end_comment

begin_function
specifier|static
name|void
name|record_biv
parameter_list|(
name|v
parameter_list|,
name|insn
parameter_list|,
name|dest_reg
parameter_list|,
name|inc_val
parameter_list|,
name|mult_val
parameter_list|,
name|not_every_iteration
parameter_list|,
name|maybe_multiple
parameter_list|)
name|struct
name|induction
modifier|*
name|v
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|rtx
name|dest_reg
decl_stmt|;
name|rtx
name|inc_val
decl_stmt|;
name|rtx
name|mult_val
decl_stmt|;
name|int
name|not_every_iteration
decl_stmt|;
name|int
name|maybe_multiple
decl_stmt|;
block|{
name|struct
name|iv_class
modifier|*
name|bl
decl_stmt|;
name|v
operator|->
name|insn
operator|=
name|insn
expr_stmt|;
name|v
operator|->
name|src_reg
operator|=
name|dest_reg
expr_stmt|;
name|v
operator|->
name|dest_reg
operator|=
name|dest_reg
expr_stmt|;
name|v
operator|->
name|mult_val
operator|=
name|mult_val
expr_stmt|;
name|v
operator|->
name|add_val
operator|=
name|inc_val
expr_stmt|;
name|v
operator|->
name|mode
operator|=
name|GET_MODE
argument_list|(
name|dest_reg
argument_list|)
expr_stmt|;
name|v
operator|->
name|always_computable
operator|=
operator|!
name|not_every_iteration
expr_stmt|;
name|v
operator|->
name|always_executed
operator|=
operator|!
name|not_every_iteration
expr_stmt|;
name|v
operator|->
name|maybe_multiple
operator|=
name|maybe_multiple
expr_stmt|;
comment|/* Add this to the reg's iv_class, creating a class      if this is the first incrementation of the reg.  */
name|bl
operator|=
name|reg_biv_class
index|[
name|REGNO
argument_list|(
name|dest_reg
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|bl
operator|==
literal|0
condition|)
block|{
comment|/* Create and initialize new iv_class.  */
name|bl
operator|=
operator|(
expr|struct
name|iv_class
operator|*
operator|)
name|oballoc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|iv_class
argument_list|)
argument_list|)
expr_stmt|;
name|bl
operator|->
name|regno
operator|=
name|REGNO
argument_list|(
name|dest_reg
argument_list|)
expr_stmt|;
name|bl
operator|->
name|biv
operator|=
literal|0
expr_stmt|;
name|bl
operator|->
name|giv
operator|=
literal|0
expr_stmt|;
name|bl
operator|->
name|biv_count
operator|=
literal|0
expr_stmt|;
name|bl
operator|->
name|giv_count
operator|=
literal|0
expr_stmt|;
comment|/* Set initial value to the reg itself.  */
name|bl
operator|->
name|initial_value
operator|=
name|dest_reg
expr_stmt|;
comment|/* We haven't seen the initializing insn yet */
name|bl
operator|->
name|init_insn
operator|=
literal|0
expr_stmt|;
name|bl
operator|->
name|init_set
operator|=
literal|0
expr_stmt|;
name|bl
operator|->
name|initial_test
operator|=
literal|0
expr_stmt|;
name|bl
operator|->
name|incremented
operator|=
literal|0
expr_stmt|;
name|bl
operator|->
name|eliminable
operator|=
literal|0
expr_stmt|;
name|bl
operator|->
name|nonneg
operator|=
literal|0
expr_stmt|;
name|bl
operator|->
name|reversed
operator|=
literal|0
expr_stmt|;
name|bl
operator|->
name|total_benefit
operator|=
literal|0
expr_stmt|;
comment|/* Add this class to loop_iv_list.  */
name|bl
operator|->
name|next
operator|=
name|loop_iv_list
expr_stmt|;
name|loop_iv_list
operator|=
name|bl
expr_stmt|;
comment|/* Put it in the array of biv register classes.  */
name|reg_biv_class
index|[
name|REGNO
argument_list|(
name|dest_reg
argument_list|)
index|]
operator|=
name|bl
expr_stmt|;
block|}
comment|/* Update IV_CLASS entry for this biv.  */
name|v
operator|->
name|next_iv
operator|=
name|bl
operator|->
name|biv
expr_stmt|;
name|bl
operator|->
name|biv
operator|=
name|v
expr_stmt|;
name|bl
operator|->
name|biv_count
operator|++
expr_stmt|;
if|if
condition|(
name|mult_val
operator|==
name|const1_rtx
condition|)
name|bl
operator|->
name|incremented
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|loop_dump_stream
condition|)
block|{
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Insn %d: possible biv, reg %d,"
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|,
name|REGNO
argument_list|(
name|dest_reg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|inc_val
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|" const ="
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|INTVAL
argument_list|(
name|inc_val
argument_list|)
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|loop_dump_stream
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|" const = "
argument_list|)
expr_stmt|;
name|print_rtl
argument_list|(
name|loop_dump_stream
argument_list|,
name|inc_val
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Fill in the data about one giv.    V is the `struct induction' in which we record the giv.  (It is    allocated by the caller, with alloca.)    INSN is the insn that sets it.    BENEFIT estimates the savings from deleting this insn.    TYPE is DEST_REG or DEST_ADDR; it says whether the giv is computed    into a register or is used as a memory address.     SRC_REG is the biv reg which the giv is computed from.    DEST_REG is the giv's reg (if the giv is stored in a reg).    MULT_VAL and ADD_VAL are the coefficients used to compute the giv.    LOCATION points to the place where this giv's value appears in INSN.  */
end_comment

begin_function
specifier|static
name|void
name|record_giv
parameter_list|(
name|v
parameter_list|,
name|insn
parameter_list|,
name|src_reg
parameter_list|,
name|dest_reg
parameter_list|,
name|mult_val
parameter_list|,
name|add_val
parameter_list|,
name|benefit
parameter_list|,
name|type
parameter_list|,
name|not_every_iteration
parameter_list|,
name|location
parameter_list|,
name|loop_start
parameter_list|,
name|loop_end
parameter_list|)
name|struct
name|induction
modifier|*
name|v
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|rtx
name|src_reg
decl_stmt|;
name|rtx
name|dest_reg
decl_stmt|;
name|rtx
name|mult_val
decl_stmt|,
name|add_val
decl_stmt|;
name|int
name|benefit
decl_stmt|;
name|enum
name|g_types
name|type
decl_stmt|;
name|int
name|not_every_iteration
decl_stmt|;
name|rtx
modifier|*
name|location
decl_stmt|;
name|rtx
name|loop_start
decl_stmt|,
name|loop_end
decl_stmt|;
block|{
name|struct
name|induction
modifier|*
name|b
decl_stmt|;
name|struct
name|iv_class
modifier|*
name|bl
decl_stmt|;
name|rtx
name|set
init|=
name|single_set
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|v
operator|->
name|insn
operator|=
name|insn
expr_stmt|;
name|v
operator|->
name|src_reg
operator|=
name|src_reg
expr_stmt|;
name|v
operator|->
name|giv_type
operator|=
name|type
expr_stmt|;
name|v
operator|->
name|dest_reg
operator|=
name|dest_reg
expr_stmt|;
name|v
operator|->
name|mult_val
operator|=
name|mult_val
expr_stmt|;
name|v
operator|->
name|add_val
operator|=
name|add_val
expr_stmt|;
name|v
operator|->
name|benefit
operator|=
name|benefit
expr_stmt|;
name|v
operator|->
name|location
operator|=
name|location
expr_stmt|;
name|v
operator|->
name|cant_derive
operator|=
literal|0
expr_stmt|;
name|v
operator|->
name|combined_with
operator|=
literal|0
expr_stmt|;
name|v
operator|->
name|maybe_multiple
operator|=
literal|0
expr_stmt|;
name|v
operator|->
name|maybe_dead
operator|=
literal|0
expr_stmt|;
name|v
operator|->
name|derive_adjustment
operator|=
literal|0
expr_stmt|;
name|v
operator|->
name|same
operator|=
literal|0
expr_stmt|;
name|v
operator|->
name|ignore
operator|=
literal|0
expr_stmt|;
name|v
operator|->
name|new_reg
operator|=
literal|0
expr_stmt|;
name|v
operator|->
name|final_value
operator|=
literal|0
expr_stmt|;
name|v
operator|->
name|same_insn
operator|=
literal|0
expr_stmt|;
name|v
operator|->
name|auto_inc_opt
operator|=
literal|0
expr_stmt|;
name|v
operator|->
name|unrolled
operator|=
literal|0
expr_stmt|;
name|v
operator|->
name|shared
operator|=
literal|0
expr_stmt|;
comment|/* The v->always_computable field is used in update_giv_derive, to      determine whether a giv can be used to derive another giv.  For a      DEST_REG giv, INSN computes a new value for the giv, so its value      isn't computable if INSN insn't executed every iteration.      However, for a DEST_ADDR giv, INSN merely uses the value of the giv;      it does not compute a new value.  Hence the value is always computable      regardless of whether INSN is executed each iteration.  */
if|if
condition|(
name|type
operator|==
name|DEST_ADDR
condition|)
name|v
operator|->
name|always_computable
operator|=
literal|1
expr_stmt|;
else|else
name|v
operator|->
name|always_computable
operator|=
operator|!
name|not_every_iteration
expr_stmt|;
name|v
operator|->
name|always_executed
operator|=
operator|!
name|not_every_iteration
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|DEST_ADDR
condition|)
block|{
name|v
operator|->
name|mode
operator|=
name|GET_MODE
argument_list|(
operator|*
name|location
argument_list|)
expr_stmt|;
name|v
operator|->
name|lifetime
operator|=
literal|1
expr_stmt|;
name|v
operator|->
name|times_used
operator|=
literal|1
expr_stmt|;
block|}
else|else
comment|/* type == DEST_REG */
block|{
name|v
operator|->
name|mode
operator|=
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
expr_stmt|;
name|v
operator|->
name|lifetime
operator|=
operator|(
name|uid_luid
index|[
name|REGNO_LAST_UID
argument_list|(
name|REGNO
argument_list|(
name|dest_reg
argument_list|)
argument_list|)
index|]
operator|-
name|uid_luid
index|[
name|REGNO_FIRST_UID
argument_list|(
name|REGNO
argument_list|(
name|dest_reg
argument_list|)
argument_list|)
index|]
operator|)
expr_stmt|;
name|v
operator|->
name|times_used
operator|=
name|n_times_used
index|[
name|REGNO
argument_list|(
name|dest_reg
argument_list|)
index|]
expr_stmt|;
comment|/* If the lifetime is zero, it means that this register is 	 really a dead store.  So mark this as a giv that can be 	 ignored.  This will not prevent the biv from being eliminated.  */
if|if
condition|(
name|v
operator|->
name|lifetime
operator|==
literal|0
condition|)
name|v
operator|->
name|ignore
operator|=
literal|1
expr_stmt|;
name|reg_iv_type
index|[
name|REGNO
argument_list|(
name|dest_reg
argument_list|)
index|]
operator|=
name|GENERAL_INDUCT
expr_stmt|;
name|reg_iv_info
index|[
name|REGNO
argument_list|(
name|dest_reg
argument_list|)
index|]
operator|=
name|v
expr_stmt|;
block|}
comment|/* Add the giv to the class of givs computed from one biv.  */
name|bl
operator|=
name|reg_biv_class
index|[
name|REGNO
argument_list|(
name|src_reg
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|bl
condition|)
block|{
name|v
operator|->
name|next_iv
operator|=
name|bl
operator|->
name|giv
expr_stmt|;
name|bl
operator|->
name|giv
operator|=
name|v
expr_stmt|;
comment|/* Don't count DEST_ADDR.  This is supposed to count the number of 	 insns that calculate givs.  */
if|if
condition|(
name|type
operator|==
name|DEST_REG
condition|)
name|bl
operator|->
name|giv_count
operator|++
expr_stmt|;
name|bl
operator|->
name|total_benefit
operator|+=
name|benefit
expr_stmt|;
block|}
else|else
comment|/* Fatal error, biv missing for this giv?  */
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|DEST_ADDR
condition|)
name|v
operator|->
name|replaceable
operator|=
literal|1
expr_stmt|;
else|else
block|{
comment|/* The giv can be replaced outright by the reduced register only if all 	 of the following conditions are true:  	 - the insn that sets the giv is always executed on any iteration 	   on which the giv is used at all 	   (there are two ways to deduce this: 	    either the insn is executed on every iteration, 	    or all uses follow that insn in the same basic block),  	 - the giv is not used outside the loop 	 - no assignments to the biv occur during the giv's lifetime.  */
if|if
condition|(
name|REGNO_FIRST_UID
argument_list|(
name|REGNO
argument_list|(
name|dest_reg
argument_list|)
argument_list|)
operator|==
name|INSN_UID
argument_list|(
name|insn
argument_list|)
comment|/* Previous line always fails if INSN was moved by loop opt.  */
operator|&&
name|uid_luid
index|[
name|REGNO_LAST_UID
argument_list|(
name|REGNO
argument_list|(
name|dest_reg
argument_list|)
argument_list|)
index|]
operator|<
name|INSN_LUID
argument_list|(
name|loop_end
argument_list|)
operator|&&
operator|(
operator|!
name|not_every_iteration
operator|||
name|last_use_this_basic_block
argument_list|(
name|dest_reg
argument_list|,
name|insn
argument_list|)
operator|)
condition|)
block|{
comment|/* Now check that there are no assignments to the biv within the 	     giv's lifetime.  This requires two separate checks.  */
comment|/* Check each biv update, and fail if any are between the first 	     and last use of the giv. 	      	     If this loop contains an inner loop that was unrolled, then 	     the insn modifying the biv may have been emitted by the loop 	     unrolling code, and hence does not have a valid luid.  Just 	     mark the biv as not replaceable in this case.  It is not very 	     useful as a biv, because it is used in two different loops. 	     It is very unlikely that we would be able to optimize the giv 	     using this biv anyways.  */
name|v
operator|->
name|replaceable
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|b
operator|=
name|bl
operator|->
name|biv
init|;
name|b
condition|;
name|b
operator|=
name|b
operator|->
name|next_iv
control|)
block|{
if|if
condition|(
name|INSN_UID
argument_list|(
name|b
operator|->
name|insn
argument_list|)
operator|>=
name|max_uid_for_loop
operator|||
operator|(
operator|(
name|uid_luid
index|[
name|INSN_UID
argument_list|(
name|b
operator|->
name|insn
argument_list|)
index|]
operator|>=
name|uid_luid
index|[
name|REGNO_FIRST_UID
argument_list|(
name|REGNO
argument_list|(
name|dest_reg
argument_list|)
argument_list|)
index|]
operator|)
operator|&&
operator|(
name|uid_luid
index|[
name|INSN_UID
argument_list|(
name|b
operator|->
name|insn
argument_list|)
index|]
operator|<=
name|uid_luid
index|[
name|REGNO_LAST_UID
argument_list|(
name|REGNO
argument_list|(
name|dest_reg
argument_list|)
argument_list|)
index|]
operator|)
operator|)
condition|)
block|{
name|v
operator|->
name|replaceable
operator|=
literal|0
expr_stmt|;
name|v
operator|->
name|not_replaceable
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
comment|/* If there are any backwards branches that go from after the 	     biv update to before it, then this giv is not replaceable.  */
if|if
condition|(
name|v
operator|->
name|replaceable
condition|)
for|for
control|(
name|b
operator|=
name|bl
operator|->
name|biv
init|;
name|b
condition|;
name|b
operator|=
name|b
operator|->
name|next_iv
control|)
if|if
condition|(
name|back_branch_in_range_p
argument_list|(
name|b
operator|->
name|insn
argument_list|,
name|loop_start
argument_list|,
name|loop_end
argument_list|)
condition|)
block|{
name|v
operator|->
name|replaceable
operator|=
literal|0
expr_stmt|;
name|v
operator|->
name|not_replaceable
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
comment|/* May still be replaceable, we don't have enough info here to 	     decide.  */
name|v
operator|->
name|replaceable
operator|=
literal|0
expr_stmt|;
name|v
operator|->
name|not_replaceable
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|loop_dump_stream
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|DEST_REG
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Insn %d: giv reg %d"
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|,
name|REGNO
argument_list|(
name|dest_reg
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Insn %d: dest address"
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|" src reg %d benefit %d"
argument_list|,
name|REGNO
argument_list|(
name|src_reg
argument_list|)
argument_list|,
name|v
operator|->
name|benefit
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|" used %d lifetime %d"
argument_list|,
name|v
operator|->
name|times_used
argument_list|,
name|v
operator|->
name|lifetime
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|replaceable
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|" replaceable"
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|mult_val
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|" mult "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|INTVAL
argument_list|(
name|mult_val
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|" mult "
argument_list|)
expr_stmt|;
name|print_rtl
argument_list|(
name|loop_dump_stream
argument_list|,
name|mult_val
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|add_val
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|" add "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|INTVAL
argument_list|(
name|add_val
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|" add "
argument_list|)
expr_stmt|;
name|print_rtl
argument_list|(
name|loop_dump_stream
argument_list|,
name|add_val
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* All this does is determine whether a giv can be made replaceable because    its final value can be calculated.  This code can not be part of record_giv    above, because final_giv_value requires that the number of loop iterations    be known, and that can not be accurately calculated until after all givs    have been identified.  */
end_comment

begin_function
specifier|static
name|void
name|check_final_value
parameter_list|(
name|v
parameter_list|,
name|loop_start
parameter_list|,
name|loop_end
parameter_list|)
name|struct
name|induction
modifier|*
name|v
decl_stmt|;
name|rtx
name|loop_start
decl_stmt|,
name|loop_end
decl_stmt|;
block|{
name|struct
name|iv_class
modifier|*
name|bl
decl_stmt|;
name|rtx
name|final_value
init|=
literal|0
decl_stmt|;
name|bl
operator|=
name|reg_biv_class
index|[
name|REGNO
argument_list|(
name|v
operator|->
name|src_reg
argument_list|)
index|]
expr_stmt|;
comment|/* DEST_ADDR givs will never reach here, because they are always marked      replaceable above in record_giv.  */
comment|/* The giv can be replaced outright by the reduced register only if all      of the following conditions are true:      - the insn that sets the giv is always executed on any iteration        on which the giv is used at all        (there are two ways to deduce this:         either the insn is executed on every iteration,         or all uses follow that insn in the same basic block),      - its final value can be calculated (this condition is different        than the one above in record_giv)      - no assignments to the biv occur during the giv's lifetime.  */
if|#
directive|if
literal|0
comment|/* This is only called now when replaceable is known to be false.  */
comment|/* Clear replaceable, so that it won't confuse final_giv_value.  */
block|v->replaceable = 0;
endif|#
directive|endif
if|if
condition|(
operator|(
name|final_value
operator|=
name|final_giv_value
argument_list|(
name|v
argument_list|,
name|loop_start
argument_list|,
name|loop_end
argument_list|)
operator|)
operator|&&
operator|(
name|v
operator|->
name|always_computable
operator|||
name|last_use_this_basic_block
argument_list|(
name|v
operator|->
name|dest_reg
argument_list|,
name|v
operator|->
name|insn
argument_list|)
operator|)
condition|)
block|{
name|int
name|biv_increment_seen
init|=
literal|0
decl_stmt|;
name|rtx
name|p
init|=
name|v
operator|->
name|insn
decl_stmt|;
name|rtx
name|last_giv_use
decl_stmt|;
name|v
operator|->
name|replaceable
operator|=
literal|1
expr_stmt|;
comment|/* When trying to determine whether or not a biv increment occurs 	 during the lifetime of the giv, we can ignore uses of the variable 	 outside the loop because final_value is true.  Hence we can not 	 use regno_last_uid and regno_first_uid as above in record_giv.  */
comment|/* Search the loop to determine whether any assignments to the 	 biv occur during the giv's lifetime.  Start with the insn 	 that sets the giv, and search around the loop until we come 	 back to that insn again.  	 Also fail if there is a jump within the giv's lifetime that jumps 	 to somewhere outside the lifetime but still within the loop.  This 	 catches spaghetti code where the execution order is not linear, and 	 hence the above test fails.  Here we assume that the giv lifetime 	 does not extend from one iteration of the loop to the next, so as 	 to make the test easier.  Since the lifetime isn't known yet, 	 this requires two loops.  See also record_giv above.  */
name|last_giv_use
operator|=
name|v
operator|->
name|insn
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|loop_end
condition|)
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|loop_start
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|v
operator|->
name|insn
condition|)
break|break;
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|JUMP_INSN
operator|||
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
if|if
condition|(
name|biv_increment_seen
condition|)
block|{
if|if
condition|(
name|reg_mentioned_p
argument_list|(
name|v
operator|->
name|dest_reg
argument_list|,
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
condition|)
block|{
name|v
operator|->
name|replaceable
operator|=
literal|0
expr_stmt|;
name|v
operator|->
name|not_replaceable
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|reg_set_p
argument_list|(
name|v
operator|->
name|src_reg
argument_list|,
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
condition|)
name|biv_increment_seen
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|reg_mentioned_p
argument_list|(
name|v
operator|->
name|dest_reg
argument_list|,
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
condition|)
name|last_giv_use
operator|=
name|p
expr_stmt|;
block|}
block|}
comment|/* Now that the lifetime of the giv is known, check for branches 	 from within the lifetime to outside the lifetime if it is still 	 replaceable.  */
if|if
condition|(
name|v
operator|->
name|replaceable
condition|)
block|{
name|p
operator|=
name|v
operator|->
name|insn
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|loop_end
condition|)
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|loop_start
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|last_giv_use
condition|)
break|break;
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|JUMP_LABEL
argument_list|(
name|p
argument_list|)
operator|&&
name|LABEL_NAME
argument_list|(
name|JUMP_LABEL
argument_list|(
name|p
argument_list|)
argument_list|)
operator|&&
operator|(
operator|(
name|INSN_UID
argument_list|(
name|JUMP_LABEL
argument_list|(
name|p
argument_list|)
argument_list|)
operator|>=
name|max_uid_for_loop
operator|)
operator|||
operator|(
name|INSN_UID
argument_list|(
name|v
operator|->
name|insn
argument_list|)
operator|>=
name|max_uid_for_loop
operator|)
operator|||
operator|(
name|INSN_UID
argument_list|(
name|last_giv_use
argument_list|)
operator|>=
name|max_uid_for_loop
operator|)
operator|||
operator|(
name|INSN_LUID
argument_list|(
name|JUMP_LABEL
argument_list|(
name|p
argument_list|)
argument_list|)
operator|<
name|INSN_LUID
argument_list|(
name|v
operator|->
name|insn
argument_list|)
operator|&&
name|INSN_LUID
argument_list|(
name|JUMP_LABEL
argument_list|(
name|p
argument_list|)
argument_list|)
operator|>
name|INSN_LUID
argument_list|(
name|loop_start
argument_list|)
operator|)
operator|||
operator|(
name|INSN_LUID
argument_list|(
name|JUMP_LABEL
argument_list|(
name|p
argument_list|)
argument_list|)
operator|>
name|INSN_LUID
argument_list|(
name|last_giv_use
argument_list|)
operator|&&
name|INSN_LUID
argument_list|(
name|JUMP_LABEL
argument_list|(
name|p
argument_list|)
argument_list|)
operator|<
name|INSN_LUID
argument_list|(
name|loop_end
argument_list|)
operator|)
operator|)
condition|)
block|{
name|v
operator|->
name|replaceable
operator|=
literal|0
expr_stmt|;
name|v
operator|->
name|not_replaceable
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Found branch outside giv lifetime.\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* If it is replaceable, then save the final value.  */
if|if
condition|(
name|v
operator|->
name|replaceable
condition|)
name|v
operator|->
name|final_value
operator|=
name|final_value
expr_stmt|;
block|}
if|if
condition|(
name|loop_dump_stream
operator|&&
name|v
operator|->
name|replaceable
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Insn %d: giv reg %d final_value replaceable\n"
argument_list|,
name|INSN_UID
argument_list|(
name|v
operator|->
name|insn
argument_list|)
argument_list|,
name|REGNO
argument_list|(
name|v
operator|->
name|dest_reg
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Update the status of whether a giv can derive other givs.     We need to do something special if there is or may be an update to the biv    between the time the giv is defined and the time it is used to derive    another giv.     In addition, a giv that is only conditionally set is not allowed to    derive another giv once a label has been passed.     The cases we look at are when a label or an update to a biv is passed.  */
end_comment

begin_function
specifier|static
name|void
name|update_giv_derive
parameter_list|(
name|p
parameter_list|)
name|rtx
name|p
decl_stmt|;
block|{
name|struct
name|iv_class
modifier|*
name|bl
decl_stmt|;
name|struct
name|induction
modifier|*
name|biv
decl_stmt|,
modifier|*
name|giv
decl_stmt|;
name|rtx
name|tem
decl_stmt|;
name|int
name|dummy
decl_stmt|;
comment|/* Search all IV classes, then all bivs, and finally all givs.       There are three cases we are concerned with.  First we have the situation      of a giv that is only updated conditionally.  In that case, it may not      derive any givs after a label is passed.       The second case is when a biv update occurs, or may occur, after the      definition of a giv.  For certain biv updates (see below) that are      known to occur between the giv definition and use, we can adjust the      giv definition.  For others, or when the biv update is conditional,      we must prevent the giv from deriving any other givs.  There are two      sub-cases within this case.       If this is a label, we are concerned with any biv update that is done      conditionally, since it may be done after the giv is defined followed by      a branch here (actually, we need to pass both a jump and a label, but      this extra tracking doesn't seem worth it).       If this is a jump, we are concerned about any biv update that may be      executed multiple times.  We are actually only concerned about      backward jumps, but it is probably not worth performing the test      on the jump again here.       If this is a biv update, we must adjust the giv status to show that a      subsequent biv update was performed.  If this adjustment cannot be done,      the giv cannot derive further givs.  */
for|for
control|(
name|bl
operator|=
name|loop_iv_list
init|;
name|bl
condition|;
name|bl
operator|=
name|bl
operator|->
name|next
control|)
for|for
control|(
name|biv
operator|=
name|bl
operator|->
name|biv
init|;
name|biv
condition|;
name|biv
operator|=
name|biv
operator|->
name|next_iv
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|CODE_LABEL
operator|||
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|JUMP_INSN
operator|||
name|biv
operator|->
name|insn
operator|==
name|p
condition|)
block|{
for|for
control|(
name|giv
operator|=
name|bl
operator|->
name|giv
init|;
name|giv
condition|;
name|giv
operator|=
name|giv
operator|->
name|next_iv
control|)
block|{
comment|/* If cant_derive is already true, there is no point in 		 checking all of these conditions again.  */
if|if
condition|(
name|giv
operator|->
name|cant_derive
condition|)
continue|continue;
comment|/* If this giv is conditionally set and we have passed a label, 		 it cannot derive anything.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|CODE_LABEL
operator|&&
operator|!
name|giv
operator|->
name|always_computable
condition|)
name|giv
operator|->
name|cant_derive
operator|=
literal|1
expr_stmt|;
comment|/* Skip givs that have mult_val == 0, since 		 they are really invariants.  Also skip those that are 		 replaceable, since we know their lifetime doesn't contain 		 any biv update.  */
elseif|else
if|if
condition|(
name|giv
operator|->
name|mult_val
operator|==
name|const0_rtx
operator|||
name|giv
operator|->
name|replaceable
condition|)
continue|continue;
comment|/* The only way we can allow this giv to derive another 		 is if this is a biv increment and we can form the product 		 of biv->add_val and giv->mult_val.  In this case, we will 		 be able to compute a compensation.  */
elseif|else
if|if
condition|(
name|biv
operator|->
name|insn
operator|==
name|p
condition|)
block|{
name|tem
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|biv
operator|->
name|mult_val
operator|==
name|const1_rtx
condition|)
name|tem
operator|=
name|simplify_giv_expr
argument_list|(
name|gen_rtx_MULT
argument_list|(
name|giv
operator|->
name|mode
argument_list|,
name|biv
operator|->
name|add_val
argument_list|,
name|giv
operator|->
name|mult_val
argument_list|)
argument_list|,
operator|&
name|dummy
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
operator|&&
name|giv
operator|->
name|derive_adjustment
condition|)
name|tem
operator|=
name|simplify_giv_expr
argument_list|(
name|gen_rtx_PLUS
argument_list|(
name|giv
operator|->
name|mode
argument_list|,
name|tem
argument_list|,
name|giv
operator|->
name|derive_adjustment
argument_list|)
argument_list|,
operator|&
name|dummy
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
condition|)
name|giv
operator|->
name|derive_adjustment
operator|=
name|tem
expr_stmt|;
else|else
name|giv
operator|->
name|cant_derive
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|CODE_LABEL
operator|&&
operator|!
name|biv
operator|->
name|always_computable
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|biv
operator|->
name|maybe_multiple
operator|)
condition|)
name|giv
operator|->
name|cant_derive
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Check whether an insn is an increment legitimate for a basic induction var.    X is the source of insn P, or a part of it.    MODE is the mode in which X should be interpreted.     DEST_REG is the putative biv, also the destination of the insn.    We accept patterns of these forms:      REG = REG + INVARIANT (includes REG = REG - CONSTANT)      REG = INVARIANT + REG     If X is suitable, we return 1, set *MULT_VAL to CONST1_RTX,    and store the additive term into *INC_VAL.     If X is an assignment of an invariant into DEST_REG, we set    *MULT_VAL to CONST0_RTX, and store the invariant into *INC_VAL.     We also want to detect a BIV when it corresponds to a variable    whose mode was promoted via PROMOTED_MODE.  In that case, an increment    of the variable may be a PLUS that adds a SUBREG of that variable to    an invariant and then sign- or zero-extends the result of the PLUS    into the variable.     Most GIVs in such cases will be in the promoted mode, since that is the    probably the natural computation mode (and almost certainly the mode    used for addresses) on the machine.  So we view the pseudo-reg containing    the variable as the BIV, as if it were simply incremented.     Note that treating the entire pseudo as a BIV will result in making    simple increments to any GIVs based on it.  However, if the variable    overflows in its declared mode but not its promoted mode, the result will    be incorrect.  This is acceptable if the variable is signed, since     overflows in such cases are undefined, but not if it is unsigned, since    those overflows are defined.  So we only check for SIGN_EXTEND and    not ZERO_EXTEND.     If we cannot find a biv, we return 0.  */
end_comment

begin_function
specifier|static
name|int
name|basic_induction_var
parameter_list|(
name|x
parameter_list|,
name|mode
parameter_list|,
name|dest_reg
parameter_list|,
name|p
parameter_list|,
name|inc_val
parameter_list|,
name|mult_val
parameter_list|)
specifier|register
name|rtx
name|x
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|p
decl_stmt|;
name|rtx
name|dest_reg
decl_stmt|;
name|rtx
modifier|*
name|inc_val
decl_stmt|;
name|rtx
modifier|*
name|mult_val
decl_stmt|;
block|{
specifier|register
name|enum
name|rtx_code
name|code
decl_stmt|;
name|rtx
name|arg
decl_stmt|;
name|rtx
name|insn
decl_stmt|,
name|set
init|=
literal|0
decl_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PLUS
case|:
if|if
condition|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|dest_reg
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
name|SUBREG_PROMOTED_VAR_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|dest_reg
operator|)
condition|)
name|arg
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|==
name|dest_reg
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
name|SUBREG_PROMOTED_VAR_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|dest_reg
operator|)
condition|)
name|arg
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
return|return
literal|0
return|;
if|if
condition|(
name|invariant_p
argument_list|(
name|arg
argument_list|)
operator|!=
literal|1
condition|)
return|return
literal|0
return|;
operator|*
name|inc_val
operator|=
name|convert_modes
argument_list|(
name|GET_MODE
argument_list|(
name|dest_reg
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|arg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|mult_val
operator|=
name|const1_rtx
expr_stmt|;
return|return
literal|1
return|;
case|case
name|SUBREG
case|:
comment|/* If this is a SUBREG for a promoted variable, check the inner 	 value.  */
if|if
condition|(
name|SUBREG_PROMOTED_VAR_P
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|basic_induction_var
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|dest_reg
argument_list|,
name|p
argument_list|,
name|inc_val
argument_list|,
name|mult_val
argument_list|)
return|;
return|return
literal|0
return|;
case|case
name|REG
case|:
comment|/* If this register is assigned in the previous insn, look at its 	 source, but don't go outside the loop or past a label.  */
for|for
control|(
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|p
argument_list|)
init|;
operator|(
name|insn
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE_INSN_LOOP_BEG
operator|)
condition|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
control|)
empty_stmt|;
if|if
condition|(
name|insn
condition|)
name|set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|set
operator|!=
literal|0
operator|&&
operator|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
operator|==
name|x
operator|||
operator|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
argument_list|)
operator|<=
name|UNITS_PER_WORD
operator|)
operator|&&
name|SUBREG_REG
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|x
operator|)
operator|)
condition|)
return|return
name|basic_induction_var
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
operator|(
name|GET_MODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|VOIDmode
condition|?
name|GET_MODE
argument_list|(
name|x
argument_list|)
else|:
name|GET_MODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|)
argument_list|,
name|dest_reg
argument_list|,
name|insn
argument_list|,
name|inc_val
argument_list|,
name|mult_val
argument_list|)
return|;
comment|/* ... fall through ...  */
comment|/* Can accept constant setting of biv only when inside inner most loop.   	 Otherwise, a biv of an inner loop may be incorrectly recognized 	 as a biv of the outer loop, 	 causing code to be moved INTO the inner loop.  */
case|case
name|MEM
case|:
if|if
condition|(
name|invariant_p
argument_list|(
name|x
argument_list|)
operator|!=
literal|1
condition|)
return|return
literal|0
return|;
case|case
name|CONST_INT
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|CONST
case|:
comment|/* convert_modes aborts if we try to convert to or from CCmode, so just          exclude that case.  It is very unlikely that a condition code value 	 would be a useful iterator anyways.  */
if|if
condition|(
name|loops_enclosed
operator|==
literal|1
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|!=
name|MODE_CC
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|dest_reg
argument_list|)
argument_list|)
operator|!=
name|MODE_CC
condition|)
block|{
comment|/* Possible bug here?  Perhaps we don't know the mode of X.  */
operator|*
name|inc_val
operator|=
name|convert_modes
argument_list|(
name|GET_MODE
argument_list|(
name|dest_reg
argument_list|)
argument_list|,
name|mode
argument_list|,
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|mult_val
operator|=
name|const0_rtx
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
return|return
literal|0
return|;
case|case
name|SIGN_EXTEND
case|:
return|return
name|basic_induction_var
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|dest_reg
argument_list|,
name|p
argument_list|,
name|inc_val
argument_list|,
name|mult_val
argument_list|)
return|;
case|case
name|ASHIFTRT
case|:
comment|/* Similar, since this can be a sign extension.  */
for|for
control|(
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|p
argument_list|)
init|;
operator|(
name|insn
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE_INSN_LOOP_BEG
operator|)
condition|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
control|)
empty_stmt|;
if|if
condition|(
name|insn
condition|)
name|set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|set
operator|&&
name|SET_DEST
argument_list|(
name|set
argument_list|)
operator|==
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|>=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|ASHIFT
operator|&&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|==
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|basic_induction_var
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|dest_reg
argument_list|,
name|insn
argument_list|,
name|inc_val
argument_list|,
name|mult_val
argument_list|)
return|;
return|return
literal|0
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* A general induction variable (giv) is any quantity that is a linear    function   of a basic induction variable,    i.e. giv = biv * mult_val + add_val.    The coefficients can be any loop invariant quantity.    A giv need not be computed directly from the biv;    it can be computed by way of other givs.  */
end_comment

begin_comment
comment|/* Determine whether X computes a giv.    If it does, return a nonzero value      which is the benefit from eliminating the computation of X;    set *SRC_REG to the register of the biv that it is computed from;    set *ADD_VAL and *MULT_VAL to the coefficients,      such that the value of X is biv * mult + add;  */
end_comment

begin_function
specifier|static
name|int
name|general_induction_var
parameter_list|(
name|x
parameter_list|,
name|src_reg
parameter_list|,
name|add_val
parameter_list|,
name|mult_val
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|rtx
modifier|*
name|src_reg
decl_stmt|;
name|rtx
modifier|*
name|add_val
decl_stmt|;
name|rtx
modifier|*
name|mult_val
decl_stmt|;
block|{
name|rtx
name|orig_x
init|=
name|x
decl_stmt|;
name|int
name|benefit
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|storage
decl_stmt|;
comment|/* If this is an invariant, forget it, it isn't a giv.  */
if|if
condition|(
name|invariant_p
argument_list|(
name|x
argument_list|)
operator|==
literal|1
condition|)
return|return
literal|0
return|;
comment|/* See if the expression could be a giv and get its form.      Mark our place on the obstack in case we don't find a giv.  */
name|storage
operator|=
operator|(
name|char
operator|*
operator|)
name|oballoc
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|x
operator|=
name|simplify_giv_expr
argument_list|(
name|x
argument_list|,
operator|&
name|benefit
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
block|{
name|obfree
argument_list|(
name|storage
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|USE
case|:
case|case
name|CONST_INT
case|:
comment|/* Since this is now an invariant and wasn't before, it must be a giv 	 with MULT_VAL == 0.  It doesn't matter which BIV we associate this 	 with.  */
operator|*
name|src_reg
operator|=
name|loop_iv_list
operator|->
name|biv
operator|->
name|dest_reg
expr_stmt|;
operator|*
name|mult_val
operator|=
name|const0_rtx
expr_stmt|;
operator|*
name|add_val
operator|=
name|x
expr_stmt|;
break|break;
case|case
name|REG
case|:
comment|/* This is equivalent to a BIV.  */
operator|*
name|src_reg
operator|=
name|x
expr_stmt|;
operator|*
name|mult_val
operator|=
name|const1_rtx
expr_stmt|;
operator|*
name|add_val
operator|=
name|const0_rtx
expr_stmt|;
break|break;
case|case
name|PLUS
case|:
comment|/* Either (plus (biv) (invar)) or 	 (plus (mult (biv) (invar_1)) (invar_2)).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MULT
condition|)
block|{
operator|*
name|src_reg
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|mult_val
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|src_reg
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|mult_val
operator|=
name|const1_rtx
expr_stmt|;
block|}
operator|*
name|add_val
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|MULT
case|:
comment|/* ADD_VAL is zero.  */
operator|*
name|src_reg
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|mult_val
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|*
name|add_val
operator|=
name|const0_rtx
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Remove any enclosing USE from ADD_VAL and MULT_VAL (there will be      unless they are CONST_INT).  */
if|if
condition|(
name|GET_CODE
argument_list|(
operator|*
name|add_val
argument_list|)
operator|==
name|USE
condition|)
operator|*
name|add_val
operator|=
name|XEXP
argument_list|(
operator|*
name|add_val
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
operator|*
name|mult_val
argument_list|)
operator|==
name|USE
condition|)
operator|*
name|mult_val
operator|=
name|XEXP
argument_list|(
operator|*
name|mult_val
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|benefit
operator|+=
name|rtx_cost
argument_list|(
name|orig_x
argument_list|,
name|SET
argument_list|)
expr_stmt|;
comment|/* Always return some benefit if this is a giv so it will be detected      as such.  This allows elimination of bivs that might otherwise      not be eliminated.  */
return|return
name|benefit
operator|==
literal|0
condition|?
literal|1
else|:
name|benefit
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given an expression, X, try to form it as a linear function of a biv.    We will canonicalize it to be of the form    	(plus (mult (BIV) (invar_1)) 	      (invar_2))    with possible degeneracies.     The invariant expressions must each be of a form that can be used as a    machine operand.  We surround then with a USE rtx (a hack, but localized    and certainly unambiguous!) if not a CONST_INT for simplicity in this    routine; it is the caller's responsibility to strip them.     If no such canonicalization is possible (i.e., two biv's are used or an    expression that is neither invariant nor a biv or giv), this routine    returns 0.     For a non-zero return, the result will have a code of CONST_INT, USE,    REG (for a BIV), PLUS, or MULT.  No other codes will occur.       *BENEFIT will be incremented by the benefit of any sub-giv encountered.  */
end_comment

begin_function
specifier|static
name|rtx
name|simplify_giv_expr
parameter_list|(
name|x
parameter_list|,
name|benefit
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|int
modifier|*
name|benefit
decl_stmt|;
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|rtx
name|arg0
decl_stmt|,
name|arg1
decl_stmt|;
name|rtx
name|tem
decl_stmt|;
comment|/* If this is not an integer mode, or if we cannot do arithmetic in this      mode, this can't be a giv.  */
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
operator|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|!=
name|MODE_INT
operator|||
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|>
name|HOST_BITS_PER_WIDE_INT
operator|)
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|PLUS
case|:
name|arg0
operator|=
name|simplify_giv_expr
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|benefit
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|simplify_giv_expr
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|benefit
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg0
operator|==
literal|0
operator|||
name|arg1
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Put constant last, CONST_INT last if both constant.  */
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|USE
operator|||
name|GET_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|CONST_INT
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|arg1
argument_list|)
operator|!=
name|CONST_INT
condition|)
name|tem
operator|=
name|arg0
operator|,
name|arg0
operator|=
name|arg1
operator|,
name|arg1
operator|=
name|tem
expr_stmt|;
comment|/* Handle addition of zero, then addition of an invariant.  */
if|if
condition|(
name|arg1
operator|==
name|const0_rtx
condition|)
return|return
name|arg0
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|CONST_INT
operator|||
name|GET_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|USE
condition|)
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|arg0
argument_list|)
condition|)
block|{
case|case
name|CONST_INT
case|:
case|case
name|USE
case|:
comment|/* Both invariant.  Only valid if sum is machine operand. 	       First strip off possible USE on the operands.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|USE
condition|)
name|arg0
operator|=
name|XEXP
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|USE
condition|)
name|arg1
operator|=
name|XEXP
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tem
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|arg0
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|tem
operator|=
name|plus_constant
argument_list|(
name|arg0
argument_list|,
name|INTVAL
argument_list|(
name|arg1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|!=
name|CONST_INT
condition|)
name|tem
operator|=
name|gen_rtx_USE
argument_list|(
name|mode
argument_list|,
name|tem
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Adding two invariants must result in an invariant, 		   so enclose addition operation inside a USE and 		   return it.  */
name|tem
operator|=
name|gen_rtx_USE
argument_list|(
name|mode
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|mode
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|tem
return|;
case|case
name|REG
case|:
case|case
name|MULT
case|:
comment|/* biv + invar or mult + invar.  Return sum.  */
return|return
name|gen_rtx_PLUS
argument_list|(
name|mode
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
return|;
case|case
name|PLUS
case|:
comment|/* (a + invar_1) + invar_2.  Associate.  */
return|return
name|simplify_giv_expr
argument_list|(
name|gen_rtx_PLUS
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|arg1
argument_list|)
argument_list|)
argument_list|,
name|benefit
argument_list|)
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Each argument must be either REG, PLUS, or MULT.  Convert REG to 	 MULT to reduce cases.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|REG
condition|)
name|arg0
operator|=
name|gen_rtx_MULT
argument_list|(
name|mode
argument_list|,
name|arg0
argument_list|,
name|const1_rtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|REG
condition|)
name|arg1
operator|=
name|gen_rtx_MULT
argument_list|(
name|mode
argument_list|,
name|arg1
argument_list|,
name|const1_rtx
argument_list|)
expr_stmt|;
comment|/* Now have PLUS + PLUS, PLUS + MULT, MULT + PLUS, or MULT + MULT. 	 Put a MULT first, leaving PLUS + PLUS, MULT + PLUS, or MULT + MULT. 	 Recurse to associate the second PLUS.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|MULT
condition|)
name|tem
operator|=
name|arg0
operator|,
name|arg0
operator|=
name|arg1
operator|,
name|arg1
operator|=
name|tem
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|PLUS
condition|)
return|return
name|simplify_giv_expr
argument_list|(
name|gen_rtx_PLUS
argument_list|(
name|mode
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|mode
argument_list|,
name|arg0
argument_list|,
name|XEXP
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|benefit
argument_list|)
return|;
comment|/* Now must have MULT + MULT.  Distribute if same biv, else not giv.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|arg0
argument_list|)
operator|!=
name|MULT
operator|||
name|GET_CODE
argument_list|(
name|arg1
argument_list|)
operator|!=
name|MULT
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|XEXP
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
operator|!=
name|XEXP
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|simplify_giv_expr
argument_list|(
name|gen_rtx_MULT
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|benefit
argument_list|)
return|;
case|case
name|MINUS
case|:
comment|/* Handle "a - b" as "a + b * (-1)".  */
return|return
name|simplify_giv_expr
argument_list|(
name|gen_rtx_PLUS
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|gen_rtx_MULT
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|constm1_rtx
argument_list|)
argument_list|)
argument_list|,
name|benefit
argument_list|)
return|;
case|case
name|MULT
case|:
name|arg0
operator|=
name|simplify_giv_expr
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|benefit
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|simplify_giv_expr
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|benefit
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg0
operator|==
literal|0
operator|||
name|arg1
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Put constant last, CONST_INT last if both constant.  */
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|USE
operator|||
name|GET_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|CONST_INT
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|arg1
argument_list|)
operator|!=
name|CONST_INT
condition|)
name|tem
operator|=
name|arg0
operator|,
name|arg0
operator|=
name|arg1
operator|,
name|arg1
operator|=
name|tem
expr_stmt|;
comment|/* If second argument is not now constant, not giv.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|arg1
argument_list|)
operator|!=
name|USE
operator|&&
name|GET_CODE
argument_list|(
name|arg1
argument_list|)
operator|!=
name|CONST_INT
condition|)
return|return
literal|0
return|;
comment|/* Handle multiply by 0 or 1.  */
if|if
condition|(
name|arg1
operator|==
name|const0_rtx
condition|)
return|return
name|const0_rtx
return|;
elseif|else
if|if
condition|(
name|arg1
operator|==
name|const1_rtx
condition|)
return|return
name|arg0
return|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|arg0
argument_list|)
condition|)
block|{
case|case
name|REG
case|:
comment|/* biv * invar.  Done.  */
return|return
name|gen_rtx_MULT
argument_list|(
name|mode
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
return|;
case|case
name|CONST_INT
case|:
comment|/* Product of two constants.  */
return|return
name|GEN_INT
argument_list|(
name|INTVAL
argument_list|(
name|arg0
argument_list|)
operator|*
name|INTVAL
argument_list|(
name|arg1
argument_list|)
argument_list|)
return|;
case|case
name|USE
case|:
comment|/* invar * invar.  Not giv.  */
return|return
literal|0
return|;
case|case
name|MULT
case|:
comment|/* (a * invar_1) * invar_2.  Associate.  */
return|return
name|simplify_giv_expr
argument_list|(
name|gen_rtx_MULT
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|gen_rtx_MULT
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|arg1
argument_list|)
argument_list|)
argument_list|,
name|benefit
argument_list|)
return|;
case|case
name|PLUS
case|:
comment|/* (a + invar_1) * invar_2.  Distribute.  */
return|return
name|simplify_giv_expr
argument_list|(
name|gen_rtx_PLUS
argument_list|(
name|mode
argument_list|,
name|gen_rtx_MULT
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|arg1
argument_list|)
argument_list|,
name|gen_rtx_MULT
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|arg1
argument_list|)
argument_list|)
argument_list|,
name|benefit
argument_list|)
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
case|case
name|ASHIFT
case|:
comment|/* Shift by constant is multiply by power of two.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
condition|)
return|return
literal|0
return|;
return|return
name|simplify_giv_expr
argument_list|(
name|gen_rtx_MULT
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|benefit
argument_list|)
return|;
case|case
name|NEG
case|:
comment|/* "-a" is "a * (-1)" */
return|return
name|simplify_giv_expr
argument_list|(
name|gen_rtx_MULT
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|constm1_rtx
argument_list|)
argument_list|,
name|benefit
argument_list|)
return|;
case|case
name|NOT
case|:
comment|/* "~a" is "-a - 1". Silly, but easy.  */
return|return
name|simplify_giv_expr
argument_list|(
name|gen_rtx_MINUS
argument_list|(
name|mode
argument_list|,
name|gen_rtx_NEG
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|const1_rtx
argument_list|)
argument_list|,
name|benefit
argument_list|)
return|;
case|case
name|USE
case|:
comment|/* Already in proper form for invariant.  */
return|return
name|x
return|;
case|case
name|REG
case|:
comment|/* If this is a new register, we can't deal with it.  */
if|if
condition|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|>=
name|max_reg_before_loop
condition|)
return|return
literal|0
return|;
comment|/* Check for biv or giv.  */
switch|switch
condition|(
name|reg_iv_type
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
condition|)
block|{
case|case
name|BASIC_INDUCT
case|:
return|return
name|x
return|;
case|case
name|GENERAL_INDUCT
case|:
block|{
name|struct
name|induction
modifier|*
name|v
init|=
name|reg_iv_info
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
decl_stmt|;
comment|/* Form expression from giv and add benefit.  Ensure this giv 	       can derive another and subtract any needed adjustment if so.  */
operator|*
name|benefit
operator|+=
name|v
operator|->
name|benefit
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|cant_derive
condition|)
return|return
literal|0
return|;
name|tem
operator|=
name|gen_rtx_PLUS
argument_list|(
name|mode
argument_list|,
name|gen_rtx_MULT
argument_list|(
name|mode
argument_list|,
name|v
operator|->
name|src_reg
argument_list|,
name|v
operator|->
name|mult_val
argument_list|)
argument_list|,
name|v
operator|->
name|add_val
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|derive_adjustment
condition|)
name|tem
operator|=
name|gen_rtx_MINUS
argument_list|(
name|mode
argument_list|,
name|tem
argument_list|,
name|v
operator|->
name|derive_adjustment
argument_list|)
expr_stmt|;
return|return
name|simplify_giv_expr
argument_list|(
name|tem
argument_list|,
name|benefit
argument_list|)
return|;
block|}
default|default:
break|break;
block|}
comment|/* Fall through to general case.  */
default|default:
comment|/* If invariant, return as USE (unless CONST_INT). 	 Otherwise, not giv.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|USE
condition|)
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|invariant_p
argument_list|(
name|x
argument_list|)
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|x
return|;
else|else
return|return
name|gen_rtx_USE
argument_list|(
name|mode
argument_list|,
name|x
argument_list|)
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Help detect a giv that is calculated by several consecutive insns;    for example,       giv = biv * M       giv = giv + A    The caller has already identified the first insn P as having a giv as dest;    we check that all other insns that set the same register follow    immediately after P, that they alter nothing else,    and that the result of the last is still a giv.     The value is 0 if the reg set in P is not really a giv.    Otherwise, the value is the amount gained by eliminating    all the consecutive insns that compute the value.     FIRST_BENEFIT is the amount gained by eliminating the first insn, P.    SRC_REG is the reg of the biv; DEST_REG is the reg of the giv.     The coefficients of the ultimate giv value are stored in    *MULT_VAL and *ADD_VAL.  */
end_comment

begin_function
specifier|static
name|int
name|consec_sets_giv
parameter_list|(
name|first_benefit
parameter_list|,
name|p
parameter_list|,
name|src_reg
parameter_list|,
name|dest_reg
parameter_list|,
name|add_val
parameter_list|,
name|mult_val
parameter_list|)
name|int
name|first_benefit
decl_stmt|;
name|rtx
name|p
decl_stmt|;
name|rtx
name|src_reg
decl_stmt|;
name|rtx
name|dest_reg
decl_stmt|;
name|rtx
modifier|*
name|add_val
decl_stmt|;
name|rtx
modifier|*
name|mult_val
decl_stmt|;
block|{
name|int
name|count
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
name|int
name|benefit
decl_stmt|;
name|rtx
name|temp
decl_stmt|;
name|rtx
name|set
decl_stmt|;
comment|/* Indicate that this is a giv so that we can update the value produced in      each insn of the multi-insn sequence.        This induction structure will be used only by the call to      general_induction_var below, so we can allocate it on our stack.      If this is a giv, our caller will replace the induct var entry with      a new induction structure.  */
name|struct
name|induction
modifier|*
name|v
init|=
operator|(
expr|struct
name|induction
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|induction
argument_list|)
argument_list|)
decl_stmt|;
name|v
operator|->
name|src_reg
operator|=
name|src_reg
expr_stmt|;
name|v
operator|->
name|mult_val
operator|=
operator|*
name|mult_val
expr_stmt|;
name|v
operator|->
name|add_val
operator|=
operator|*
name|add_val
expr_stmt|;
name|v
operator|->
name|benefit
operator|=
name|first_benefit
expr_stmt|;
name|v
operator|->
name|cant_derive
operator|=
literal|0
expr_stmt|;
name|v
operator|->
name|derive_adjustment
operator|=
literal|0
expr_stmt|;
name|reg_iv_type
index|[
name|REGNO
argument_list|(
name|dest_reg
argument_list|)
index|]
operator|=
name|GENERAL_INDUCT
expr_stmt|;
name|reg_iv_info
index|[
name|REGNO
argument_list|(
name|dest_reg
argument_list|)
index|]
operator|=
name|v
expr_stmt|;
name|count
operator|=
name|n_times_set
index|[
name|REGNO
argument_list|(
name|dest_reg
argument_list|)
index|]
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* If libcall, skip to end of call sequence.  */
if|if
condition|(
name|code
operator|==
name|INSN
operator|&&
operator|(
name|temp
operator|=
name|find_reg_note
argument_list|(
name|p
argument_list|,
name|REG_LIBCALL
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
condition|)
name|p
operator|=
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|INSN
operator|&&
operator|(
name|set
operator|=
name|single_set
argument_list|(
name|p
argument_list|)
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|SET_DEST
argument_list|(
name|set
argument_list|)
operator|==
name|dest_reg
operator|&&
operator|(
operator|(
name|benefit
operator|=
name|general_induction_var
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
operator|&
name|src_reg
argument_list|,
name|add_val
argument_list|,
name|mult_val
argument_list|)
operator|)
comment|/* Giv created by equivalent expression.  */
operator|||
operator|(
operator|(
name|temp
operator|=
name|find_reg_note
argument_list|(
name|p
argument_list|,
name|REG_EQUAL
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
operator|&&
operator|(
name|benefit
operator|=
name|general_induction_var
argument_list|(
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|src_reg
argument_list|,
name|add_val
argument_list|,
name|mult_val
argument_list|)
operator|)
operator|)
operator|)
operator|&&
name|src_reg
operator|==
name|v
operator|->
name|src_reg
condition|)
block|{
if|if
condition|(
name|find_reg_note
argument_list|(
name|p
argument_list|,
name|REG_RETVAL
argument_list|,
name|NULL_RTX
argument_list|)
condition|)
name|benefit
operator|+=
name|libcall_benefit
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|count
operator|--
expr_stmt|;
name|v
operator|->
name|mult_val
operator|=
operator|*
name|mult_val
expr_stmt|;
name|v
operator|->
name|add_val
operator|=
operator|*
name|add_val
expr_stmt|;
name|v
operator|->
name|benefit
operator|=
name|benefit
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|!=
name|NOTE
condition|)
block|{
comment|/* Allow insns that set something other than this giv to a 	     constant.  Such insns are needed on machines which cannot 	     include long constants and should not disqualify a giv.  */
if|if
condition|(
name|code
operator|==
name|INSN
operator|&&
operator|(
name|set
operator|=
name|single_set
argument_list|(
name|p
argument_list|)
operator|)
operator|&&
name|SET_DEST
argument_list|(
name|set
argument_list|)
operator|!=
name|dest_reg
operator|&&
name|CONSTANT_P
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
condition|)
continue|continue;
name|reg_iv_type
index|[
name|REGNO
argument_list|(
name|dest_reg
argument_list|)
index|]
operator|=
name|UNKNOWN_INDUCT
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
return|return
name|v
operator|->
name|benefit
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return an rtx, if any, that expresses giv G2 as a function of the register    represented by G1.  If no such expression can be found, or it is clear that    it cannot possibly be a valid address, 0 is returned.      To perform the computation, we note that    	G1 = a * v + b		and 	G2 = c * v + d    where `v' is the biv.     So G2 = (c/a) * G1 + (d - b*c/a)  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|ADDRESS_COST
end_ifdef

begin_function
specifier|static
name|rtx
name|express_from
parameter_list|(
name|g1
parameter_list|,
name|g2
parameter_list|)
name|struct
name|induction
modifier|*
name|g1
decl_stmt|,
decl|*
name|g2
decl_stmt|;
end_function

begin_block
block|{
name|rtx
name|mult
decl_stmt|,
name|add
decl_stmt|;
comment|/* The value that G1 will be multiplied by must be a constant integer.  Also,      the only chance we have of getting a valid address is if b*c/a (see above      for notation) is also an integer.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|g1
operator|->
name|mult_val
argument_list|)
operator|!=
name|CONST_INT
operator|||
name|GET_CODE
argument_list|(
name|g2
operator|->
name|mult_val
argument_list|)
operator|!=
name|CONST_INT
operator|||
name|GET_CODE
argument_list|(
name|g1
operator|->
name|add_val
argument_list|)
operator|!=
name|CONST_INT
operator|||
name|g1
operator|->
name|mult_val
operator|==
name|const0_rtx
operator|||
name|INTVAL
argument_list|(
name|g2
operator|->
name|mult_val
argument_list|)
operator|%
name|INTVAL
argument_list|(
name|g1
operator|->
name|mult_val
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
name|mult
operator|=
name|GEN_INT
argument_list|(
name|INTVAL
argument_list|(
name|g2
operator|->
name|mult_val
argument_list|)
operator|/
name|INTVAL
argument_list|(
name|g1
operator|->
name|mult_val
argument_list|)
argument_list|)
expr_stmt|;
name|add
operator|=
name|plus_constant
argument_list|(
name|g2
operator|->
name|add_val
argument_list|,
operator|-
name|INTVAL
argument_list|(
name|g1
operator|->
name|add_val
argument_list|)
operator|*
name|INTVAL
argument_list|(
name|mult
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Form simplified final result.  */
if|if
condition|(
name|mult
operator|==
name|const0_rtx
condition|)
return|return
name|add
return|;
elseif|else
if|if
condition|(
name|mult
operator|==
name|const1_rtx
condition|)
name|mult
operator|=
name|g1
operator|->
name|dest_reg
expr_stmt|;
else|else
name|mult
operator|=
name|gen_rtx_MULT
argument_list|(
name|g2
operator|->
name|mode
argument_list|,
name|g1
operator|->
name|dest_reg
argument_list|,
name|mult
argument_list|)
expr_stmt|;
if|if
condition|(
name|add
operator|==
name|const0_rtx
condition|)
return|return
name|mult
return|;
else|else
return|return
name|gen_rtx_PLUS
argument_list|(
name|g2
operator|->
name|mode
argument_list|,
name|mult
argument_list|,
name|add
argument_list|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Return 1 if giv G2 can be combined with G1.  This means that G2 can use    (either directly or via an address expression) a register used to represent    G1.  Set g2->new_reg to a represtation of G1 (normally just    g1->dest_reg).  */
end_comment

begin_function
specifier|static
name|int
name|combine_givs_p
parameter_list|(
name|g1
parameter_list|,
name|g2
parameter_list|)
name|struct
name|induction
modifier|*
name|g1
decl_stmt|,
decl|*
name|g2
decl_stmt|;
end_function

begin_block
block|{
ifdef|#
directive|ifdef
name|ADDRESS_COST
name|rtx
name|tem
decl_stmt|;
endif|#
directive|endif
comment|/* If these givs are identical, they can be combined.  */
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|g1
operator|->
name|mult_val
argument_list|,
name|g2
operator|->
name|mult_val
argument_list|)
operator|&&
name|rtx_equal_p
argument_list|(
name|g1
operator|->
name|add_val
argument_list|,
name|g2
operator|->
name|add_val
argument_list|)
condition|)
block|{
name|g2
operator|->
name|new_reg
operator|=
name|g1
operator|->
name|dest_reg
expr_stmt|;
return|return
literal|1
return|;
block|}
ifdef|#
directive|ifdef
name|ADDRESS_COST
comment|/* If G2 can be expressed as a function of G1 and that function is valid      as an address and no more expensive than using a register for G2,      the expression of G2 in terms of G1 can be used.  */
if|if
condition|(
name|g2
operator|->
name|giv_type
operator|==
name|DEST_ADDR
operator|&&
operator|(
name|tem
operator|=
name|express_from
argument_list|(
name|g1
argument_list|,
name|g2
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|memory_address_p
argument_list|(
name|g2
operator|->
name|mem_mode
argument_list|,
name|tem
argument_list|)
operator|&&
name|ADDRESS_COST
argument_list|(
name|tem
argument_list|)
operator|<=
name|ADDRESS_COST
argument_list|(
operator|*
name|g2
operator|->
name|location
argument_list|)
condition|)
block|{
name|g2
operator|->
name|new_reg
operator|=
name|tem
expr_stmt|;
return|return
literal|1
return|;
block|}
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_block

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|GIV_SORT_CRITERION
end_ifdef

begin_comment
comment|/* Compare two givs and sort the most desirable one for combinations first.    This is used only in one qsort call below.  */
end_comment

begin_function
specifier|static
name|int
name|giv_sort
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
name|struct
name|induction
modifier|*
modifier|*
name|x
decl_stmt|,
decl|*
modifier|*
name|y
decl_stmt|;
end_function

begin_block
block|{
name|GIV_SORT_CRITERION
argument_list|(
operator|*
name|x
argument_list|,
operator|*
name|y
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Check all pairs of givs for iv_class BL and see if any can be combined with    any other.  If so, point SAME to the giv combined with and set NEW_REG to    be an expression (in terms of the other giv's DEST_REG) equivalent to the    giv.  Also, update BENEFIT and related fields for cost/benefit analysis.  */
end_comment

begin_function
specifier|static
name|void
name|combine_givs
parameter_list|(
name|bl
parameter_list|)
name|struct
name|iv_class
modifier|*
name|bl
decl_stmt|;
block|{
name|struct
name|induction
modifier|*
name|g1
decl_stmt|,
modifier|*
name|g2
decl_stmt|,
modifier|*
modifier|*
name|giv_array
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|giv_count
decl_stmt|,
name|pass
decl_stmt|;
comment|/* Count givs, because bl->giv_count is incorrect here.  */
name|giv_count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|g1
operator|=
name|bl
operator|->
name|giv
init|;
name|g1
condition|;
name|g1
operator|=
name|g1
operator|->
name|next_iv
control|)
name|giv_count
operator|++
expr_stmt|;
name|giv_array
operator|=
operator|(
expr|struct
name|induction
operator|*
operator|*
operator|)
name|alloca
argument_list|(
name|giv_count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|induction
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|g1
operator|=
name|bl
operator|->
name|giv
init|;
name|g1
condition|;
name|g1
operator|=
name|g1
operator|->
name|next_iv
control|)
name|giv_array
index|[
name|i
operator|++
index|]
operator|=
name|g1
expr_stmt|;
ifdef|#
directive|ifdef
name|GIV_SORT_CRITERION
comment|/* Sort the givs if GIV_SORT_CRITERION is defined.      This is usually defined for processors which lack      negative register offsets so more givs may be combined.  */
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"%d givs counted, sorting...\n"
argument_list|,
name|giv_count
argument_list|)
expr_stmt|;
name|qsort
argument_list|(
name|giv_array
argument_list|,
name|giv_count
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|induction
operator|*
argument_list|)
argument_list|,
name|giv_sort
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|giv_count
condition|;
name|i
operator|++
control|)
block|{
name|g1
operator|=
name|giv_array
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|pass
operator|=
literal|0
init|;
name|pass
operator|<=
literal|1
condition|;
name|pass
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|giv_count
condition|;
name|j
operator|++
control|)
block|{
name|g2
operator|=
name|giv_array
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|g1
operator|!=
name|g2
comment|/* First try to combine with replaceable givs, then all givs.  */
operator|&&
operator|(
name|g1
operator|->
name|replaceable
operator|||
name|pass
operator|==
literal|1
operator|)
comment|/* If either has already been combined or is to be ignored, can't 		   combine.  */
operator|&&
operator|!
name|g1
operator|->
name|ignore
operator|&&
operator|!
name|g2
operator|->
name|ignore
operator|&&
operator|!
name|g1
operator|->
name|same
operator|&&
operator|!
name|g2
operator|->
name|same
comment|/* If something has been based on G2, G2 cannot itself be based 		   on something else.  */
operator|&&
operator|!
name|g2
operator|->
name|combined_with
operator|&&
name|combine_givs_p
argument_list|(
name|g1
argument_list|,
name|g2
argument_list|)
condition|)
block|{
comment|/* g2->new_reg set by `combine_givs_p'  */
name|g2
operator|->
name|same
operator|=
name|g1
expr_stmt|;
name|g1
operator|->
name|combined_with
operator|=
literal|1
expr_stmt|;
comment|/* If one of these givs is a DEST_REG that was only used 		   once, by the other giv, this is actually a single use. 		   The DEST_REG has the correct cost, while the other giv 		   counts the REG use too often.  */
if|if
condition|(
name|g2
operator|->
name|giv_type
operator|==
name|DEST_REG
operator|&&
name|n_times_used
index|[
name|REGNO
argument_list|(
name|g2
operator|->
name|dest_reg
argument_list|)
index|]
operator|==
literal|1
operator|&&
name|reg_mentioned_p
argument_list|(
name|g2
operator|->
name|dest_reg
argument_list|,
name|PATTERN
argument_list|(
name|g1
operator|->
name|insn
argument_list|)
argument_list|)
condition|)
name|g1
operator|->
name|benefit
operator|=
name|g2
operator|->
name|benefit
expr_stmt|;
elseif|else
if|if
condition|(
name|g1
operator|->
name|giv_type
operator|!=
name|DEST_REG
operator|||
name|n_times_used
index|[
name|REGNO
argument_list|(
name|g1
operator|->
name|dest_reg
argument_list|)
index|]
operator|!=
literal|1
operator|||
operator|!
name|reg_mentioned_p
argument_list|(
name|g1
operator|->
name|dest_reg
argument_list|,
name|PATTERN
argument_list|(
name|g2
operator|->
name|insn
argument_list|)
argument_list|)
condition|)
block|{
name|g1
operator|->
name|benefit
operator|+=
name|g2
operator|->
name|benefit
expr_stmt|;
name|g1
operator|->
name|times_used
operator|+=
name|g2
operator|->
name|times_used
expr_stmt|;
block|}
comment|/* ??? The new final_[bg]iv_value code does a much better job 		   of finding replaceable giv's, and hence this code may no 		   longer be necessary.  */
if|if
condition|(
operator|!
name|g2
operator|->
name|replaceable
operator|&&
name|REG_USERVAR_P
argument_list|(
name|g2
operator|->
name|dest_reg
argument_list|)
condition|)
name|g1
operator|->
name|benefit
operator|-=
name|copy_cost
expr_stmt|;
name|g1
operator|->
name|lifetime
operator|+=
name|g2
operator|->
name|lifetime
expr_stmt|;
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"giv at %d combined with giv at %d\n"
argument_list|,
name|INSN_UID
argument_list|(
name|g2
operator|->
name|insn
argument_list|)
argument_list|,
name|INSN_UID
argument_list|(
name|g1
operator|->
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* EMIT code before INSERT_BEFORE to set REG = B * M + A.  */
end_comment

begin_function
name|void
name|emit_iv_add_mult
parameter_list|(
name|b
parameter_list|,
name|m
parameter_list|,
name|a
parameter_list|,
name|reg
parameter_list|,
name|insert_before
parameter_list|)
name|rtx
name|b
decl_stmt|;
comment|/* initial value of basic induction variable */
name|rtx
name|m
decl_stmt|;
comment|/* multiplicative constant */
name|rtx
name|a
decl_stmt|;
comment|/* additive constant */
name|rtx
name|reg
decl_stmt|;
comment|/* destination register */
name|rtx
name|insert_before
decl_stmt|;
block|{
name|rtx
name|seq
decl_stmt|;
name|rtx
name|result
decl_stmt|;
comment|/* Prevent unexpected sharing of these rtx.  */
name|a
operator|=
name|copy_rtx
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|b
operator|=
name|copy_rtx
argument_list|(
name|b
argument_list|)
expr_stmt|;
comment|/* Increase the lifetime of any invariants moved further in code.  */
name|update_reg_last_use
argument_list|(
name|a
argument_list|,
name|insert_before
argument_list|)
expr_stmt|;
name|update_reg_last_use
argument_list|(
name|b
argument_list|,
name|insert_before
argument_list|)
expr_stmt|;
name|update_reg_last_use
argument_list|(
name|m
argument_list|,
name|insert_before
argument_list|)
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|result
operator|=
name|expand_mult_add
argument_list|(
name|b
argument_list|,
name|reg
argument_list|,
name|m
argument_list|,
name|a
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|!=
name|result
condition|)
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|seq
operator|=
name|gen_sequence
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_insn_before
argument_list|(
name|seq
argument_list|,
name|insert_before
argument_list|)
expr_stmt|;
comment|/* It is entirely possible that the expansion created lots of new       registers.  Iterate over the sequence we just created and       record them all.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|seq
argument_list|)
operator|==
name|SEQUENCE
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|seq
argument_list|,
literal|0
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|rtx
name|set
init|=
name|single_set
argument_list|(
name|XVECEXP
argument_list|(
name|seq
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|set
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
name|record_base_value
argument_list|(
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
argument_list|,
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|seq
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|seq
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
name|record_base_value
argument_list|(
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|seq
argument_list|)
argument_list|)
argument_list|,
name|SET_SRC
argument_list|(
name|seq
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Test whether A * B can be computed without    an actual multiply insn.  Value is 1 if so.  */
end_comment

begin_function
specifier|static
name|int
name|product_cheap_p
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
name|rtx
name|a
decl_stmt|;
name|rtx
name|b
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|rtx
name|tmp
decl_stmt|;
name|struct
name|obstack
modifier|*
name|old_rtl_obstack
init|=
name|rtl_obstack
decl_stmt|;
name|char
modifier|*
name|storage
init|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|temp_obstack
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|win
init|=
literal|1
decl_stmt|;
comment|/* If only one is constant, make it B.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|a
argument_list|)
operator|==
name|CONST_INT
condition|)
name|tmp
operator|=
name|a
operator|,
name|a
operator|=
name|b
operator|,
name|b
operator|=
name|tmp
expr_stmt|;
comment|/* If first constant, both constant, so don't need multiply.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|a
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
literal|1
return|;
comment|/* If second not constant, neither is constant, so would need multiply.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|b
argument_list|)
operator|!=
name|CONST_INT
condition|)
return|return
literal|0
return|;
comment|/* One operand is constant, so might not need multiply insn.  Generate the      code for the multiply and see if a call or multiply, or long sequence      of insns is generated.  */
name|rtl_obstack
operator|=
operator|&
name|temp_obstack
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|expand_mult
argument_list|(
name|GET_MODE
argument_list|(
name|a
argument_list|)
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|gen_sequence
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|SEQUENCE
condition|)
block|{
if|if
condition|(
name|XVEC
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
name|win
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|XVECLEN
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
operator|>
literal|3
condition|)
name|win
operator|=
literal|0
expr_stmt|;
else|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|insn
init|=
name|XVECEXP
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|INSN
operator|||
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|MULT
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|MULT
operator|)
condition|)
block|{
name|win
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|tmp
argument_list|)
argument_list|)
operator|==
name|MULT
condition|)
name|win
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|MULT
condition|)
name|win
operator|=
literal|0
expr_stmt|;
comment|/* Free any storage we obtained in generating this multiply and restore rtl      allocation to its normal obstack.  */
name|obstack_free
argument_list|(
operator|&
name|temp_obstack
argument_list|,
name|storage
argument_list|)
expr_stmt|;
name|rtl_obstack
operator|=
name|old_rtl_obstack
expr_stmt|;
return|return
name|win
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Check to see if loop can be terminated by a "decrement and branch until    zero" instruction.  If so, add a REG_NONNEG note to the branch insn if so.    Also try reversing an increment loop to a decrement loop    to see if the optimization can be performed.    Value is nonzero if optimization was performed.  */
end_comment

begin_comment
comment|/* This is useful even if the architecture doesn't have such an insn,    because it might change a loops which increments from 0 to n to a loop    which decrements from n to 0.  A loop that decrements to zero is usually    faster than one that increments from zero.  */
end_comment

begin_comment
comment|/* ??? This could be rewritten to use some of the loop unrolling procedures,    such as approx_final_value, biv_total_increment, loop_iterations, and    final_[bg]iv_value.  */
end_comment

begin_function
specifier|static
name|int
name|check_dbra_loop
parameter_list|(
name|loop_end
parameter_list|,
name|insn_count
parameter_list|,
name|loop_start
parameter_list|)
name|rtx
name|loop_end
decl_stmt|;
name|int
name|insn_count
decl_stmt|;
name|rtx
name|loop_start
decl_stmt|;
block|{
name|struct
name|iv_class
modifier|*
name|bl
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
name|rtx
name|jump_label
decl_stmt|;
name|rtx
name|final_value
decl_stmt|;
name|rtx
name|start_value
decl_stmt|;
name|rtx
name|new_add_val
decl_stmt|;
name|rtx
name|comparison
decl_stmt|;
name|rtx
name|before_comparison
decl_stmt|;
name|rtx
name|p
decl_stmt|;
name|rtx
name|jump
decl_stmt|;
name|rtx
name|first_compare
decl_stmt|;
name|int
name|compare_and_branch
decl_stmt|;
comment|/* If last insn is a conditional branch, and the insn before tests a      register value, try to optimize it.  Otherwise, we can't do anything.  */
name|jump
operator|=
name|PREV_INSN
argument_list|(
name|loop_end
argument_list|)
expr_stmt|;
name|comparison
operator|=
name|get_condition_for_loop
argument_list|(
name|jump
argument_list|)
expr_stmt|;
if|if
condition|(
name|comparison
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Try to compute whether the compare/branch at the loop end is one or      two instructions.  */
name|get_condition
argument_list|(
name|jump
argument_list|,
operator|&
name|first_compare
argument_list|)
expr_stmt|;
if|if
condition|(
name|first_compare
operator|==
name|jump
condition|)
name|compare_and_branch
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|first_compare
operator|==
name|prev_nonnote_insn
argument_list|(
name|jump
argument_list|)
condition|)
name|compare_and_branch
operator|=
literal|2
expr_stmt|;
else|else
return|return
literal|0
return|;
comment|/* Check all of the bivs to see if the compare uses one of them.      Skip biv's set more than once because we can't guarantee that      it will be zero on the last iteration.  Also skip if the biv is      used between its update and the test insn.  */
for|for
control|(
name|bl
operator|=
name|loop_iv_list
init|;
name|bl
condition|;
name|bl
operator|=
name|bl
operator|->
name|next
control|)
block|{
if|if
condition|(
name|bl
operator|->
name|biv_count
operator|==
literal|1
operator|&&
name|bl
operator|->
name|biv
operator|->
name|dest_reg
operator|==
name|XEXP
argument_list|(
name|comparison
argument_list|,
literal|0
argument_list|)
operator|&&
operator|!
name|reg_used_between_p
argument_list|(
name|regno_reg_rtx
index|[
name|bl
operator|->
name|regno
index|]
argument_list|,
name|bl
operator|->
name|biv
operator|->
name|insn
argument_list|,
name|first_compare
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|bl
condition|)
return|return
literal|0
return|;
comment|/* Look for the case where the basic induction variable is always      nonnegative, and equals zero on the last iteration.      In this case, add a reg_note REG_NONNEG, which allows the      m68k DBRA instruction to be used.  */
if|if
condition|(
operator|(
operator|(
name|GET_CODE
argument_list|(
name|comparison
argument_list|)
operator|==
name|GT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|comparison
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|comparison
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|comparison
argument_list|)
operator|==
name|NE
operator|&&
name|XEXP
argument_list|(
name|comparison
argument_list|,
literal|1
argument_list|)
operator|==
name|const0_rtx
operator|)
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|bl
operator|->
name|biv
operator|->
name|add_val
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|bl
operator|->
name|biv
operator|->
name|add_val
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* Initial value must be greater than 0, 	 init_val % -dec_value == 0 to ensure that it equals zero on 	 the last iteration */
if|if
condition|(
name|GET_CODE
argument_list|(
name|bl
operator|->
name|initial_value
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|bl
operator|->
name|initial_value
argument_list|)
operator|>
literal|0
operator|&&
operator|(
name|INTVAL
argument_list|(
name|bl
operator|->
name|initial_value
argument_list|)
operator|%
operator|(
operator|-
name|INTVAL
argument_list|(
name|bl
operator|->
name|biv
operator|->
name|add_val
argument_list|)
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* register always nonnegative, add REG_NOTE to branch */
name|REG_NOTES
argument_list|(
name|PREV_INSN
argument_list|(
name|loop_end
argument_list|)
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_NONNEG
argument_list|,
name|NULL_RTX
argument_list|,
name|REG_NOTES
argument_list|(
name|PREV_INSN
argument_list|(
name|loop_end
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|bl
operator|->
name|nonneg
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* If the decrement is 1 and the value was tested as>= 0 before 	 the loop, then we can safely optimize.  */
for|for
control|(
name|p
operator|=
name|loop_start
init|;
name|p
condition|;
name|p
operator|=
name|PREV_INSN
argument_list|(
name|p
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|CODE_LABEL
condition|)
break|break;
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|!=
name|JUMP_INSN
condition|)
continue|continue;
name|before_comparison
operator|=
name|get_condition_for_loop
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|before_comparison
operator|&&
name|XEXP
argument_list|(
name|before_comparison
argument_list|,
literal|0
argument_list|)
operator|==
name|bl
operator|->
name|biv
operator|->
name|dest_reg
operator|&&
name|GET_CODE
argument_list|(
name|before_comparison
argument_list|)
operator|==
name|LT
operator|&&
name|XEXP
argument_list|(
name|before_comparison
argument_list|,
literal|1
argument_list|)
operator|==
name|const0_rtx
operator|&&
operator|!
name|reg_set_between_p
argument_list|(
name|bl
operator|->
name|biv
operator|->
name|dest_reg
argument_list|,
name|p
argument_list|,
name|loop_start
argument_list|)
operator|&&
name|INTVAL
argument_list|(
name|bl
operator|->
name|biv
operator|->
name|add_val
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|REG_NOTES
argument_list|(
name|PREV_INSN
argument_list|(
name|loop_end
argument_list|)
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_NONNEG
argument_list|,
name|NULL_RTX
argument_list|,
name|REG_NOTES
argument_list|(
name|PREV_INSN
argument_list|(
name|loop_end
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|bl
operator|->
name|nonneg
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|num_mem_sets
operator|<=
literal|1
condition|)
block|{
comment|/* Try to change inc to dec, so can apply above optimization.  */
comment|/* Can do this if: 	 all registers modified are induction variables or invariant, 	 all memory references have non-overlapping addresses 	 (obviously true if only one write) 	 allow 2 insns for the compare/jump at the end of the loop.  */
comment|/* Also, we must avoid any instructions which use both the reversed 	 biv and another biv.  Such instructions will fail if the loop is 	 reversed.  We meet this condition by requiring that either 	 no_use_except_counting is true, or else that there is only 	 one biv.  */
name|int
name|num_nonfixed_reads
init|=
literal|0
decl_stmt|;
comment|/* 1 if the iteration var is used only to count iterations.  */
name|int
name|no_use_except_counting
init|=
literal|0
decl_stmt|;
comment|/* 1 if the loop has no memory store, or it has a single memory store 	 which is reversible.  */
name|int
name|reversible_mem_store
init|=
literal|1
decl_stmt|;
for|for
control|(
name|p
operator|=
name|loop_start
init|;
name|p
operator|!=
name|loop_end
condition|;
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
control|)
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
argument_list|)
operator|==
literal|'i'
condition|)
name|num_nonfixed_reads
operator|+=
name|count_nonfixed_reads
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bl
operator|->
name|giv_count
operator|==
literal|0
operator|&&
operator|!
name|loop_number_exit_count
index|[
name|uid_loop_num
index|[
name|INSN_UID
argument_list|(
name|loop_start
argument_list|)
index|]
index|]
condition|)
block|{
name|rtx
name|bivreg
init|=
name|regno_reg_rtx
index|[
name|bl
operator|->
name|regno
index|]
decl_stmt|;
comment|/* If there are no givs for this biv, and the only exit is the 	     fall through at the end of the loop, then 	     see if perhaps there are no uses except to count.  */
name|no_use_except_counting
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|p
operator|=
name|loop_start
init|;
name|p
operator|!=
name|loop_end
condition|;
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
control|)
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
argument_list|)
operator|==
literal|'i'
condition|)
block|{
name|rtx
name|set
init|=
name|single_set
argument_list|(
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
name|set
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|bl
operator|->
name|regno
condition|)
comment|/* An insn that sets the biv is okay.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|p
operator|==
name|prev_nonnote_insn
argument_list|(
name|prev_nonnote_insn
argument_list|(
name|loop_end
argument_list|)
argument_list|)
operator|||
name|p
operator|==
name|prev_nonnote_insn
argument_list|(
name|loop_end
argument_list|)
condition|)
comment|/* Don't bother about the end test.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|reg_mentioned_p
argument_list|(
name|bivreg
argument_list|,
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
condition|)
comment|/* Any other use of the biv is no good.  */
block|{
name|no_use_except_counting
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* If the loop has a single store, and the destination address is 	 invariant, then we can't reverse the loop, because this address 	 might then have the wrong value at loop exit. 	 This would work if the source was invariant also, however, in that 	 case, the insn should have been moved out of the loop.  */
if|if
condition|(
name|num_mem_sets
operator|==
literal|1
condition|)
block|{
name|struct
name|induction
modifier|*
name|v
decl_stmt|;
name|reversible_mem_store
operator|=
operator|(
operator|!
name|unknown_address_altered
operator|&&
operator|!
name|invariant_p
argument_list|(
name|XEXP
argument_list|(
name|loop_store_mems
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
expr_stmt|;
comment|/* If the store depends on a register that is set after the 	     store, it depends on the initial value, and is thus not 	     reversible.  */
for|for
control|(
name|v
operator|=
name|bl
operator|->
name|giv
init|;
name|reversible_mem_store
operator|&&
name|v
condition|;
name|v
operator|=
name|v
operator|->
name|next_iv
control|)
block|{
if|if
condition|(
name|v
operator|->
name|giv_type
operator|==
name|DEST_REG
operator|&&
name|reg_mentioned_p
argument_list|(
name|v
operator|->
name|dest_reg
argument_list|,
name|loop_store_mems
index|[
literal|0
index|]
argument_list|)
operator|&&
operator|(
name|INSN_UID
argument_list|(
name|v
operator|->
name|insn
argument_list|)
operator|>=
name|max_uid_for_loop
operator|||
operator|(
name|INSN_LUID
argument_list|(
name|v
operator|->
name|insn
argument_list|)
operator|>
name|INSN_LUID
argument_list|(
name|first_loop_store_insn
argument_list|)
operator|)
operator|)
condition|)
name|reversible_mem_store
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* This code only acts for innermost loops.  Also it simplifies 	 the memory address check by only reversing loops with 	 zero or one memory access. 	 Two memory accesses could involve parts of the same array, 	 and that can't be reversed.  */
if|if
condition|(
name|num_nonfixed_reads
operator|<=
literal|1
operator|&&
operator|!
name|loop_has_call
operator|&&
operator|!
name|loop_has_volatile
operator|&&
name|reversible_mem_store
operator|&&
operator|(
name|no_use_except_counting
operator|||
operator|(
operator|(
name|bl
operator|->
name|giv_count
operator|+
name|bl
operator|->
name|biv_count
operator|+
name|num_mem_sets
operator|+
name|num_movables
operator|+
name|compare_and_branch
operator|==
name|insn_count
operator|)
operator|&&
operator|(
name|bl
operator|==
name|loop_iv_list
operator|&&
name|bl
operator|->
name|next
operator|==
literal|0
operator|)
operator|)
operator|)
condition|)
block|{
name|rtx
name|tem
decl_stmt|;
comment|/* Loop can be reversed.  */
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Can reverse loop\n"
argument_list|)
expr_stmt|;
comment|/* Now check other conditions:  	     The increment must be a constant, as must the initial value, 	     and the comparison code must be LT.   	     This test can probably be improved since +/- 1 in the constant 	     can be obtained by changing LT to LE and vice versa; this is 	     confusing.  */
if|if
condition|(
name|comparison
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|comparison
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
comment|/* LE gets turned into LT */
operator|&&
name|GET_CODE
argument_list|(
name|comparison
argument_list|)
operator|==
name|LT
operator|&&
name|GET_CODE
argument_list|(
name|bl
operator|->
name|initial_value
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|HOST_WIDE_INT
name|add_val
decl_stmt|,
name|comparison_val
decl_stmt|;
name|rtx
name|initial_value
decl_stmt|;
name|add_val
operator|=
name|INTVAL
argument_list|(
name|bl
operator|->
name|biv
operator|->
name|add_val
argument_list|)
expr_stmt|;
name|comparison_val
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|comparison
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|final_value
operator|=
name|XEXP
argument_list|(
name|comparison
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|initial_value
operator|=
name|bl
operator|->
name|initial_value
expr_stmt|;
comment|/* Normalize the initial value if it is an integer and  		 has no other use except as a counter.  This will allow 		 a few more loops to be reversed.  */
if|if
condition|(
name|no_use_except_counting
operator|&&
name|GET_CODE
argument_list|(
name|initial_value
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|comparison_val
operator|=
name|comparison_val
operator|-
name|INTVAL
argument_list|(
name|bl
operator|->
name|initial_value
argument_list|)
expr_stmt|;
comment|/* Check for overflow.  If comparison_val ends up as a 		     negative value, then we can't reverse the loop.  */
if|if
condition|(
name|comparison_val
operator|>=
literal|0
condition|)
name|initial_value
operator|=
name|const0_rtx
expr_stmt|;
block|}
comment|/* If the initial value is not zero, or if the comparison 		 value is not an exact multiple of the increment, then we 		 can not reverse this loop.  */
if|if
condition|(
name|initial_value
operator|!=
name|const0_rtx
operator|||
operator|(
name|comparison_val
operator|%
name|add_val
operator|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Reset these in case we normalized the initial value 		 and comparison value above.  */
name|bl
operator|->
name|initial_value
operator|=
name|initial_value
expr_stmt|;
name|XEXP
argument_list|(
name|comparison
argument_list|,
literal|1
argument_list|)
operator|=
name|GEN_INT
argument_list|(
name|comparison_val
argument_list|)
expr_stmt|;
comment|/* Register will always be nonnegative, with value 		 0 on last iteration if loop reversed */
comment|/* Save some info needed to produce the new insns.  */
name|reg
operator|=
name|bl
operator|->
name|biv
operator|->
name|dest_reg
expr_stmt|;
name|jump_label
operator|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|PREV_INSN
argument_list|(
name|loop_end
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|jump_label
operator|==
name|pc_rtx
condition|)
name|jump_label
operator|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|PREV_INSN
argument_list|(
name|loop_end
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|new_add_val
operator|=
name|GEN_INT
argument_list|(
operator|-
name|INTVAL
argument_list|(
name|bl
operator|->
name|biv
operator|->
name|add_val
argument_list|)
argument_list|)
expr_stmt|;
name|start_value
operator|=
name|GEN_INT
argument_list|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|comparison
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|-
name|INTVAL
argument_list|(
name|bl
operator|->
name|biv
operator|->
name|add_val
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Initialize biv to start_value before loop start. 		 The old initializing insn will be deleted as a 		 dead store by flow.c.  */
name|emit_insn_before
argument_list|(
name|gen_move_insn
argument_list|(
name|reg
argument_list|,
name|start_value
argument_list|)
argument_list|,
name|loop_start
argument_list|)
expr_stmt|;
comment|/* Add insn to decrement register, and delete insn 		 that incremented the register.  */
name|p
operator|=
name|emit_insn_before
argument_list|(
name|gen_add2_insn
argument_list|(
name|reg
argument_list|,
name|new_add_val
argument_list|)
argument_list|,
name|bl
operator|->
name|biv
operator|->
name|insn
argument_list|)
expr_stmt|;
name|delete_insn
argument_list|(
name|bl
operator|->
name|biv
operator|->
name|insn
argument_list|)
expr_stmt|;
comment|/* Update biv info to reflect its new status.  */
name|bl
operator|->
name|biv
operator|->
name|insn
operator|=
name|p
expr_stmt|;
name|bl
operator|->
name|initial_value
operator|=
name|start_value
expr_stmt|;
name|bl
operator|->
name|biv
operator|->
name|add_val
operator|=
name|new_add_val
expr_stmt|;
comment|/* Inc LABEL_NUSES so that delete_insn will 		 not delete the label.  */
name|LABEL_NUSES
argument_list|(
name|XEXP
argument_list|(
name|jump_label
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|++
expr_stmt|;
comment|/* Emit an insn after the end of the loop to set the biv's 		 proper exit value if it is used anywhere outside the loop.  */
if|if
condition|(
operator|(
name|REGNO_LAST_UID
argument_list|(
name|bl
operator|->
name|regno
argument_list|)
operator|!=
name|INSN_UID
argument_list|(
name|first_compare
argument_list|)
operator|)
operator|||
operator|!
name|bl
operator|->
name|init_insn
operator|||
name|REGNO_FIRST_UID
argument_list|(
name|bl
operator|->
name|regno
argument_list|)
operator|!=
name|INSN_UID
argument_list|(
name|bl
operator|->
name|init_insn
argument_list|)
condition|)
name|emit_insn_after
argument_list|(
name|gen_move_insn
argument_list|(
name|reg
argument_list|,
name|final_value
argument_list|)
argument_list|,
name|loop_end
argument_list|)
expr_stmt|;
comment|/* Delete compare/branch at end of loop.  */
name|delete_insn
argument_list|(
name|PREV_INSN
argument_list|(
name|loop_end
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|compare_and_branch
operator|==
literal|2
condition|)
name|delete_insn
argument_list|(
name|first_compare
argument_list|)
expr_stmt|;
comment|/* Add new compare/branch insn at end of loop.  */
name|start_sequence
argument_list|()
expr_stmt|;
name|emit_cmp_insn
argument_list|(
name|reg
argument_list|,
name|const0_rtx
argument_list|,
name|GE
argument_list|,
name|NULL_RTX
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_bge
argument_list|(
name|XEXP
argument_list|(
name|jump_label
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|tem
operator|=
name|gen_sequence
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_jump_insn_before
argument_list|(
name|tem
argument_list|,
name|loop_end
argument_list|)
expr_stmt|;
for|for
control|(
name|tem
operator|=
name|PREV_INSN
argument_list|(
name|loop_end
argument_list|)
init|;
name|tem
operator|&&
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|!=
name|JUMP_INSN
condition|;
name|tem
operator|=
name|PREV_INSN
argument_list|(
name|tem
argument_list|)
control|)
empty_stmt|;
if|if
condition|(
name|tem
condition|)
block|{
name|JUMP_LABEL
argument_list|(
name|tem
argument_list|)
operator|=
name|XEXP
argument_list|(
name|jump_label
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Increment of LABEL_NUSES done above.  */
comment|/* Register is now always nonnegative, 		     so add REG_NONNEG note to the branch.  */
name|REG_NOTES
argument_list|(
name|tem
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_NONNEG
argument_list|,
name|NULL_RTX
argument_list|,
name|REG_NOTES
argument_list|(
name|tem
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|bl
operator|->
name|nonneg
operator|=
literal|1
expr_stmt|;
comment|/* Mark that this biv has been reversed.  Each giv which depends 		 on this biv, and which is also live past the end of the loop 		 will have to be fixed up.  */
name|bl
operator|->
name|reversed
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Reversed loop and added reg_nonneg\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Verify whether the biv BL appears to be eliminable,    based on the insns in the loop that refer to it.    LOOP_START is the first insn of the loop, and END is the end insn.     If ELIMINATE_P is non-zero, actually do the elimination.     THRESHOLD and INSN_COUNT are from loop_optimize and are used to    determine whether invariant insns should be placed inside or at the    start of the loop.  */
end_comment

begin_function
specifier|static
name|int
name|maybe_eliminate_biv
parameter_list|(
name|bl
parameter_list|,
name|loop_start
parameter_list|,
name|end
parameter_list|,
name|eliminate_p
parameter_list|,
name|threshold
parameter_list|,
name|insn_count
parameter_list|)
name|struct
name|iv_class
modifier|*
name|bl
decl_stmt|;
name|rtx
name|loop_start
decl_stmt|;
name|rtx
name|end
decl_stmt|;
name|int
name|eliminate_p
decl_stmt|;
name|int
name|threshold
decl_stmt|,
name|insn_count
decl_stmt|;
block|{
name|rtx
name|reg
init|=
name|bl
operator|->
name|biv
operator|->
name|dest_reg
decl_stmt|;
name|rtx
name|p
decl_stmt|;
comment|/* Scan all insns in the loop, stopping if we find one that uses the      biv in a way that we cannot eliminate.  */
for|for
control|(
name|p
operator|=
name|loop_start
init|;
name|p
operator|!=
name|end
condition|;
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
control|)
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|rtx
name|where
init|=
name|threshold
operator|>=
name|insn_count
condition|?
name|loop_start
else|:
name|p
decl_stmt|;
if|if
condition|(
operator|(
name|code
operator|==
name|INSN
operator|||
name|code
operator|==
name|JUMP_INSN
operator|||
name|code
operator|==
name|CALL_INSN
operator|)
operator|&&
name|reg_mentioned_p
argument_list|(
name|reg
argument_list|,
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
operator|&&
operator|!
name|maybe_eliminate_biv_1
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|,
name|p
argument_list|,
name|bl
argument_list|,
name|eliminate_p
argument_list|,
name|where
argument_list|)
condition|)
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Cannot eliminate biv %d: biv used in insn %d.\n"
argument_list|,
name|bl
operator|->
name|regno
argument_list|,
name|INSN_UID
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|p
operator|==
name|end
condition|)
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"biv %d %s eliminated.\n"
argument_list|,
name|bl
operator|->
name|regno
argument_list|,
name|eliminate_p
condition|?
literal|"was"
else|:
literal|"can be"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If BL appears in X (part of the pattern of INSN), see if we can    eliminate its use.  If so, return 1.  If not, return 0.     If BIV does not appear in X, return 1.     If ELIMINATE_P is non-zero, actually do the elimination.  WHERE indicates    where extra insns should be added.  Depending on how many items have been    moved out of the loop, it will either be before INSN or at the start of    the loop.  */
end_comment

begin_function
specifier|static
name|int
name|maybe_eliminate_biv_1
parameter_list|(
name|x
parameter_list|,
name|insn
parameter_list|,
name|bl
parameter_list|,
name|eliminate_p
parameter_list|,
name|where
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|insn
decl_stmt|;
name|struct
name|iv_class
modifier|*
name|bl
decl_stmt|;
name|int
name|eliminate_p
decl_stmt|;
name|rtx
name|where
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|rtx
name|reg
init|=
name|bl
operator|->
name|biv
operator|->
name|dest_reg
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|reg
argument_list|)
decl_stmt|;
name|struct
name|induction
modifier|*
name|v
decl_stmt|;
name|rtx
name|arg
decl_stmt|,
name|tem
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_cc0
name|rtx
name|new
decl_stmt|;
endif|#
directive|endif
name|int
name|arg_operand
decl_stmt|;
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|REG
case|:
comment|/* If we haven't already been able to do something with this BIV, 	 we can't eliminate it.  */
if|if
condition|(
name|x
operator|==
name|reg
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
case|case
name|SET
case|:
comment|/* If this sets the BIV, it is not a problem.  */
if|if
condition|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
operator|==
name|reg
condition|)
return|return
literal|1
return|;
comment|/* If this is an insn that defines a giv, it is also ok because 	 it will go away when the giv is reduced.  */
for|for
control|(
name|v
operator|=
name|bl
operator|->
name|giv
init|;
name|v
condition|;
name|v
operator|=
name|v
operator|->
name|next_iv
control|)
if|if
condition|(
name|v
operator|->
name|giv_type
operator|==
name|DEST_REG
operator|&&
name|SET_DEST
argument_list|(
name|x
argument_list|)
operator|==
name|v
operator|->
name|dest_reg
condition|)
return|return
literal|1
return|;
ifdef|#
directive|ifdef
name|HAVE_cc0
comment|/* The idea here is to replace the SET of cc0 by a REG with 	 a comparison involving related induction variables. 	 Unfortunately, however, such a replacement does not work 	 correctly if the REG is being used as signed and the 	 replacement value is unsigned, or vice versa.  For 	 example, in:  	    for (int i = n; i>= 0; --i) 	      s[i] = 3;  	 `s' is an address (an unsigned quantity), while `i' is a 	 signed quantity.  The exit test for the loop might look 	 something like:  	    (SET cc0 i) 	    (JUMP (SET (PC) (IF_THEN_ELSE (LT (CC0) (CONST_INT 0)) 			     (LABEL_REF L) (PC))))  	 If we replace the SET of cc0 with a comparison of the 	 induction variable for `s + i' and the original value of `s', 	 however, we should be change the comparison in the 	 IF_THEN_ELSE to be unsigned.  Otherwise, an array the spans 	 the boundary between "negative" and "positive" addresses will 	 confuse us.  	 There are related problems with overflow.  If an induction 	 variable "wraps around" but the original value doest not, we 	 can get confused when doing the comparison.  	 Pointers can't wrap around, or overflow, in a conformant 	 program.  Therefore, it's safe to do these optimizations if 	 both the original REG and the values in the replacement are 	 pointers.  For now, though, we just disable these 	 optimizations.  */
if|if
condition|(
literal|0
operator|&&
name|SET_DEST
argument_list|(
name|x
argument_list|)
operator|==
name|cc0_rtx
operator|&&
name|SET_SRC
argument_list|(
name|x
argument_list|)
operator|==
name|reg
condition|)
block|{
comment|/* Can replace with any giv that was reduced and 	     that has (MULT_VAL != 0) and (ADD_VAL == 0). 	     Require a constant for MULT_VAL, so we know it's nonzero. 	     ??? We disable this optimization to avoid potential 	     overflows.  */
for|for
control|(
name|v
operator|=
name|bl
operator|->
name|giv
init|;
name|v
condition|;
name|v
operator|=
name|v
operator|->
name|next_iv
control|)
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|v
operator|->
name|mult_val
argument_list|)
operator|&&
name|v
operator|->
name|mult_val
operator|!=
name|const0_rtx
operator|&&
name|v
operator|->
name|add_val
operator|==
name|const0_rtx
operator|&&
operator|!
name|v
operator|->
name|ignore
operator|&&
operator|!
name|v
operator|->
name|maybe_dead
operator|&&
name|v
operator|->
name|always_computable
operator|&&
name|v
operator|->
name|mode
operator|==
name|mode
operator|&&
literal|0
condition|)
block|{
comment|/* If the giv V had the auto-inc address optimization applied 		   to it, and INSN occurs between the giv insn and the biv 		   insn, then we must adjust the value used here. 		   This is rare, so we don't bother to do so.  */
if|if
condition|(
name|v
operator|->
name|auto_inc_opt
operator|&&
operator|(
operator|(
name|INSN_LUID
argument_list|(
name|v
operator|->
name|insn
argument_list|)
operator|<
name|INSN_LUID
argument_list|(
name|insn
argument_list|)
operator|&&
name|INSN_LUID
argument_list|(
name|insn
argument_list|)
operator|<
name|INSN_LUID
argument_list|(
name|bl
operator|->
name|biv
operator|->
name|insn
argument_list|)
operator|)
operator|||
operator|(
name|INSN_LUID
argument_list|(
name|v
operator|->
name|insn
argument_list|)
operator|>
name|INSN_LUID
argument_list|(
name|insn
argument_list|)
operator|&&
name|INSN_LUID
argument_list|(
name|insn
argument_list|)
operator|>
name|INSN_LUID
argument_list|(
name|bl
operator|->
name|biv
operator|->
name|insn
argument_list|)
operator|)
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|eliminate_p
condition|)
return|return
literal|1
return|;
comment|/* If the giv has the opposite direction of change, 		   then reverse the comparison.  */
if|if
condition|(
name|INTVAL
argument_list|(
name|v
operator|->
name|mult_val
argument_list|)
operator|<
literal|0
condition|)
name|new
operator|=
name|gen_rtx_COMPARE
argument_list|(
name|GET_MODE
argument_list|(
name|v
operator|->
name|new_reg
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
name|v
operator|->
name|new_reg
argument_list|)
expr_stmt|;
else|else
name|new
operator|=
name|v
operator|->
name|new_reg
expr_stmt|;
comment|/* We can probably test that giv's reduced reg.  */
if|if
condition|(
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|new
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
comment|/* Look for a giv with (MULT_VAL != 0) and (ADD_VAL != 0); 	     replace test insn with a compare insn (cmp REDUCED_GIV ADD_VAL). 	     Require a constant for MULT_VAL, so we know it's nonzero. 	     ??? Do this only if ADD_VAL is a pointer to avoid a potential 	     overflow problem.  */
for|for
control|(
name|v
operator|=
name|bl
operator|->
name|giv
init|;
name|v
condition|;
name|v
operator|=
name|v
operator|->
name|next_iv
control|)
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|v
operator|->
name|mult_val
argument_list|)
operator|&&
name|v
operator|->
name|mult_val
operator|!=
name|const0_rtx
operator|&&
operator|!
name|v
operator|->
name|ignore
operator|&&
operator|!
name|v
operator|->
name|maybe_dead
operator|&&
name|v
operator|->
name|always_computable
operator|&&
name|v
operator|->
name|mode
operator|==
name|mode
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|v
operator|->
name|add_val
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|v
operator|->
name|add_val
argument_list|)
operator|==
name|LABEL_REF
operator|||
name|GET_CODE
argument_list|(
name|v
operator|->
name|add_val
argument_list|)
operator|==
name|CONST
operator|||
operator|(
name|GET_CODE
argument_list|(
name|v
operator|->
name|add_val
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO_POINTER_FLAG
argument_list|(
name|REGNO
argument_list|(
name|v
operator|->
name|add_val
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
block|{
comment|/* If the giv V had the auto-inc address optimization applied 		   to it, and INSN occurs between the giv insn and the biv 		   insn, then we must adjust the value used here. 		   This is rare, so we don't bother to do so.  */
if|if
condition|(
name|v
operator|->
name|auto_inc_opt
operator|&&
operator|(
operator|(
name|INSN_LUID
argument_list|(
name|v
operator|->
name|insn
argument_list|)
operator|<
name|INSN_LUID
argument_list|(
name|insn
argument_list|)
operator|&&
name|INSN_LUID
argument_list|(
name|insn
argument_list|)
operator|<
name|INSN_LUID
argument_list|(
name|bl
operator|->
name|biv
operator|->
name|insn
argument_list|)
operator|)
operator|||
operator|(
name|INSN_LUID
argument_list|(
name|v
operator|->
name|insn
argument_list|)
operator|>
name|INSN_LUID
argument_list|(
name|insn
argument_list|)
operator|&&
name|INSN_LUID
argument_list|(
name|insn
argument_list|)
operator|>
name|INSN_LUID
argument_list|(
name|bl
operator|->
name|biv
operator|->
name|insn
argument_list|)
operator|)
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|eliminate_p
condition|)
return|return
literal|1
return|;
comment|/* If the giv has the opposite direction of change, 		   then reverse the comparison.  */
if|if
condition|(
name|INTVAL
argument_list|(
name|v
operator|->
name|mult_val
argument_list|)
operator|<
literal|0
condition|)
name|new
operator|=
name|gen_rtx_COMPARE
argument_list|(
name|VOIDmode
argument_list|,
name|copy_rtx
argument_list|(
name|v
operator|->
name|add_val
argument_list|)
argument_list|,
name|v
operator|->
name|new_reg
argument_list|)
expr_stmt|;
else|else
name|new
operator|=
name|gen_rtx_COMPARE
argument_list|(
name|VOIDmode
argument_list|,
name|v
operator|->
name|new_reg
argument_list|,
name|copy_rtx
argument_list|(
name|v
operator|->
name|add_val
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Replace biv with the giv's reduced register.  */
name|update_reg_last_use
argument_list|(
name|v
operator|->
name|add_val
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|,
name|new
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Insn doesn't support that constant or invariant.  Copy it 		   into a register (it will be a loop invariant.)  */
name|tem
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|v
operator|->
name|new_reg
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn_before
argument_list|(
name|gen_move_insn
argument_list|(
name|tem
argument_list|,
name|copy_rtx
argument_list|(
name|v
operator|->
name|add_val
argument_list|)
argument_list|)
argument_list|,
name|where
argument_list|)
expr_stmt|;
comment|/* Substitute the new register for its invariant value in 		   the compare expression. */
name|XEXP
argument_list|(
name|new
argument_list|,
operator|(
name|INTVAL
argument_list|(
name|v
operator|->
name|mult_val
argument_list|)
operator|<
literal|0
operator|)
condition|?
literal|0
else|:
literal|1
argument_list|)
operator|=
name|tem
expr_stmt|;
if|if
condition|(
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|,
name|new
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
block|}
endif|#
directive|endif
break|break;
case|case
name|COMPARE
case|:
case|case
name|EQ
case|:
case|case
name|NE
case|:
case|case
name|GT
case|:
case|case
name|GE
case|:
case|case
name|GTU
case|:
case|case
name|GEU
case|:
case|case
name|LT
case|:
case|case
name|LE
case|:
case|case
name|LTU
case|:
case|case
name|LEU
case|:
comment|/* See if either argument is the biv.  */
if|if
condition|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|reg
condition|)
name|arg
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|,
name|arg_operand
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|==
name|reg
condition|)
name|arg
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|,
name|arg_operand
operator|=
literal|0
expr_stmt|;
else|else
break|break;
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|arg
argument_list|)
condition|)
block|{
comment|/* First try to replace with any giv that has constant positive 	     mult_val and constant add_val.  We might be able to support 	     negative mult_val, but it seems complex to do it in general.  */
for|for
control|(
name|v
operator|=
name|bl
operator|->
name|giv
init|;
name|v
condition|;
name|v
operator|=
name|v
operator|->
name|next_iv
control|)
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|v
operator|->
name|mult_val
argument_list|)
operator|&&
name|INTVAL
argument_list|(
name|v
operator|->
name|mult_val
argument_list|)
operator|>
literal|0
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|v
operator|->
name|add_val
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|v
operator|->
name|add_val
argument_list|)
operator|==
name|LABEL_REF
operator|||
name|GET_CODE
argument_list|(
name|v
operator|->
name|add_val
argument_list|)
operator|==
name|CONST
operator|||
operator|(
name|GET_CODE
argument_list|(
name|v
operator|->
name|add_val
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO_POINTER_FLAG
argument_list|(
name|REGNO
argument_list|(
name|v
operator|->
name|add_val
argument_list|)
argument_list|)
operator|)
operator|)
operator|&&
operator|!
name|v
operator|->
name|ignore
operator|&&
operator|!
name|v
operator|->
name|maybe_dead
operator|&&
name|v
operator|->
name|always_computable
operator|&&
name|v
operator|->
name|mode
operator|==
name|mode
condition|)
block|{
comment|/* If the giv V had the auto-inc address optimization applied 		   to it, and INSN occurs between the giv insn and the biv 		   insn, then we must adjust the value used here. 		   This is rare, so we don't bother to do so.  */
if|if
condition|(
name|v
operator|->
name|auto_inc_opt
operator|&&
operator|(
operator|(
name|INSN_LUID
argument_list|(
name|v
operator|->
name|insn
argument_list|)
operator|<
name|INSN_LUID
argument_list|(
name|insn
argument_list|)
operator|&&
name|INSN_LUID
argument_list|(
name|insn
argument_list|)
operator|<
name|INSN_LUID
argument_list|(
name|bl
operator|->
name|biv
operator|->
name|insn
argument_list|)
operator|)
operator|||
operator|(
name|INSN_LUID
argument_list|(
name|v
operator|->
name|insn
argument_list|)
operator|>
name|INSN_LUID
argument_list|(
name|insn
argument_list|)
operator|&&
name|INSN_LUID
argument_list|(
name|insn
argument_list|)
operator|>
name|INSN_LUID
argument_list|(
name|bl
operator|->
name|biv
operator|->
name|insn
argument_list|)
operator|)
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|eliminate_p
condition|)
return|return
literal|1
return|;
comment|/* Replace biv with the giv's reduced reg.  */
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
operator|-
name|arg_operand
argument_list|)
operator|=
name|v
operator|->
name|new_reg
expr_stmt|;
comment|/* If all constants are actually constant integers and 		   the derived constant can be directly placed in the COMPARE, 		   do so.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|v
operator|->
name|mult_val
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|v
operator|->
name|add_val
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
name|arg_operand
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|INTVAL
argument_list|(
name|arg
argument_list|)
operator|*
name|INTVAL
argument_list|(
name|v
operator|->
name|mult_val
argument_list|)
operator|+
name|INTVAL
argument_list|(
name|v
operator|->
name|add_val
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Otherwise, load it into a register.  */
name|tem
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|emit_iv_add_mult
argument_list|(
name|arg
argument_list|,
name|v
operator|->
name|mult_val
argument_list|,
name|v
operator|->
name|add_val
argument_list|,
name|tem
argument_list|,
name|where
argument_list|)
expr_stmt|;
if|if
condition|(
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
name|arg_operand
argument_list|)
argument_list|,
name|tem
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* If that failed, put back the change we made above.  */
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
operator|-
name|arg_operand
argument_list|)
operator|=
name|reg
expr_stmt|;
block|}
comment|/* Look for giv with positive constant mult_val and nonconst add_val. 	     Insert insns to calculate new compare value.   	     ??? Turn this off due to possible overflow.  */
for|for
control|(
name|v
operator|=
name|bl
operator|->
name|giv
init|;
name|v
condition|;
name|v
operator|=
name|v
operator|->
name|next_iv
control|)
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|v
operator|->
name|mult_val
argument_list|)
operator|&&
name|INTVAL
argument_list|(
name|v
operator|->
name|mult_val
argument_list|)
operator|>
literal|0
operator|&&
operator|!
name|v
operator|->
name|ignore
operator|&&
operator|!
name|v
operator|->
name|maybe_dead
operator|&&
name|v
operator|->
name|always_computable
operator|&&
name|v
operator|->
name|mode
operator|==
name|mode
operator|&&
literal|0
condition|)
block|{
name|rtx
name|tem
decl_stmt|;
comment|/* If the giv V had the auto-inc address optimization applied 		   to it, and INSN occurs between the giv insn and the biv 		   insn, then we must adjust the value used here. 		   This is rare, so we don't bother to do so.  */
if|if
condition|(
name|v
operator|->
name|auto_inc_opt
operator|&&
operator|(
operator|(
name|INSN_LUID
argument_list|(
name|v
operator|->
name|insn
argument_list|)
operator|<
name|INSN_LUID
argument_list|(
name|insn
argument_list|)
operator|&&
name|INSN_LUID
argument_list|(
name|insn
argument_list|)
operator|<
name|INSN_LUID
argument_list|(
name|bl
operator|->
name|biv
operator|->
name|insn
argument_list|)
operator|)
operator|||
operator|(
name|INSN_LUID
argument_list|(
name|v
operator|->
name|insn
argument_list|)
operator|>
name|INSN_LUID
argument_list|(
name|insn
argument_list|)
operator|&&
name|INSN_LUID
argument_list|(
name|insn
argument_list|)
operator|>
name|INSN_LUID
argument_list|(
name|bl
operator|->
name|biv
operator|->
name|insn
argument_list|)
operator|)
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|eliminate_p
condition|)
return|return
literal|1
return|;
name|tem
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
comment|/* Replace biv with giv's reduced register.  */
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
operator|-
name|arg_operand
argument_list|)
argument_list|,
name|v
operator|->
name|new_reg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Compute value to compare against.  */
name|emit_iv_add_mult
argument_list|(
name|arg
argument_list|,
name|v
operator|->
name|mult_val
argument_list|,
name|v
operator|->
name|add_val
argument_list|,
name|tem
argument_list|,
name|where
argument_list|)
expr_stmt|;
comment|/* Use it in this insn.  */
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
name|arg_operand
argument_list|)
argument_list|,
name|tem
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|apply_change_group
argument_list|()
condition|)
return|return
literal|1
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|MEM
condition|)
block|{
if|if
condition|(
name|invariant_p
argument_list|(
name|arg
argument_list|)
operator|==
literal|1
condition|)
block|{
comment|/* Look for giv with constant positive mult_val and nonconst 		 add_val. Insert insns to compute new compare value.  		 ??? Turn this off due to possible overflow.  */
for|for
control|(
name|v
operator|=
name|bl
operator|->
name|giv
init|;
name|v
condition|;
name|v
operator|=
name|v
operator|->
name|next_iv
control|)
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|v
operator|->
name|mult_val
argument_list|)
operator|&&
name|INTVAL
argument_list|(
name|v
operator|->
name|mult_val
argument_list|)
operator|>
literal|0
operator|&&
operator|!
name|v
operator|->
name|ignore
operator|&&
operator|!
name|v
operator|->
name|maybe_dead
operator|&&
name|v
operator|->
name|always_computable
operator|&&
name|v
operator|->
name|mode
operator|==
name|mode
operator|&&
literal|0
condition|)
block|{
name|rtx
name|tem
decl_stmt|;
comment|/* If the giv V had the auto-inc address optimization applied 		       to it, and INSN occurs between the giv insn and the biv 		       insn, then we must adjust the value used here. 		       This is rare, so we don't bother to do so.  */
if|if
condition|(
name|v
operator|->
name|auto_inc_opt
operator|&&
operator|(
operator|(
name|INSN_LUID
argument_list|(
name|v
operator|->
name|insn
argument_list|)
operator|<
name|INSN_LUID
argument_list|(
name|insn
argument_list|)
operator|&&
name|INSN_LUID
argument_list|(
name|insn
argument_list|)
operator|<
name|INSN_LUID
argument_list|(
name|bl
operator|->
name|biv
operator|->
name|insn
argument_list|)
operator|)
operator|||
operator|(
name|INSN_LUID
argument_list|(
name|v
operator|->
name|insn
argument_list|)
operator|>
name|INSN_LUID
argument_list|(
name|insn
argument_list|)
operator|&&
name|INSN_LUID
argument_list|(
name|insn
argument_list|)
operator|>
name|INSN_LUID
argument_list|(
name|bl
operator|->
name|biv
operator|->
name|insn
argument_list|)
operator|)
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|eliminate_p
condition|)
return|return
literal|1
return|;
name|tem
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
comment|/* Replace biv with giv's reduced register.  */
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
operator|-
name|arg_operand
argument_list|)
argument_list|,
name|v
operator|->
name|new_reg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Compute value to compare against.  */
name|emit_iv_add_mult
argument_list|(
name|arg
argument_list|,
name|v
operator|->
name|mult_val
argument_list|,
name|v
operator|->
name|add_val
argument_list|,
name|tem
argument_list|,
name|where
argument_list|)
expr_stmt|;
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
name|arg_operand
argument_list|)
argument_list|,
name|tem
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|apply_change_group
argument_list|()
condition|)
return|return
literal|1
return|;
block|}
block|}
comment|/* This code has problems.  Basically, you can't know when 	     seeing if we will eliminate BL, whether a particular giv 	     of ARG will be reduced.  If it isn't going to be reduced, 	     we can't eliminate BL.  We can try forcing it to be reduced, 	     but that can generate poor code.  	     The problem is that the benefit of reducing TV, below should 	     be increased if BL can actually be eliminated, but this means 	     we might have to do a topological sort of the order in which 	     we try to process biv.  It doesn't seem worthwhile to do 	     this sort of thing now.  */
if|#
directive|if
literal|0
comment|/* Otherwise the reg compared with had better be a biv.  */
block|if (GET_CODE (arg) != REG 	      || reg_iv_type[REGNO (arg)] != BASIC_INDUCT) 	    return 0;
comment|/* Look for a pair of givs, one for each biv, 	     with identical coefficients.  */
block|for (v = bl->giv; v; v = v->next_iv) 	    { 	      struct induction *tv;  	      if (v->ignore || v->maybe_dead || v->mode != mode) 		continue;  	      for (tv = reg_biv_class[REGNO (arg)]->giv; tv; tv = tv->next_iv) 		if (! tv->ignore&& ! tv->maybe_dead&& rtx_equal_p (tv->mult_val, v->mult_val)&& rtx_equal_p (tv->add_val, v->add_val)&& tv->mode == mode) 		  {
comment|/* If the giv V had the auto-inc address optimization applied 		       to it, and INSN occurs between the giv insn and the biv 		       insn, then we must adjust the value used here. 		       This is rare, so we don't bother to do so.  */
block|if (v->auto_inc_opt&& ((INSN_LUID (v->insn)< INSN_LUID (insn)&& INSN_LUID (insn)< INSN_LUID (bl->biv->insn)) 			    || (INSN_LUID (v->insn)> INSN_LUID (insn)&& INSN_LUID (insn)> INSN_LUID (bl->biv->insn)))) 		      continue;  		    if (! eliminate_p) 		      return 1;
comment|/* Replace biv with its giv's reduced reg.  */
block|XEXP (x, 1-arg_operand) = v->new_reg;
comment|/* Replace other operand with the other giv's 		       reduced reg.  */
block|XEXP (x, arg_operand) = tv->new_reg; 		    return 1; 		  } 	    }
endif|#
directive|endif
block|}
comment|/* If we get here, the biv can't be eliminated.  */
return|return
literal|0
return|;
case|case
name|MEM
case|:
comment|/* If this address is a DEST_ADDR giv, it doesn't matter if the 	 biv is used in it, since it will be replaced.  */
for|for
control|(
name|v
operator|=
name|bl
operator|->
name|giv
init|;
name|v
condition|;
name|v
operator|=
name|v
operator|->
name|next_iv
control|)
if|if
condition|(
name|v
operator|->
name|giv_type
operator|==
name|DEST_ADDR
operator|&&
name|v
operator|->
name|location
operator|==
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|1
return|;
break|break;
default|default:
break|break;
block|}
comment|/* See if any subexpression fails elimination.  */
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
switch|switch
condition|(
name|fmt
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'e'
case|:
if|if
condition|(
operator|!
name|maybe_eliminate_biv_1
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|insn
argument_list|,
name|bl
argument_list|,
name|eliminate_p
argument_list|,
name|where
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'E'
case|:
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
operator|!
name|maybe_eliminate_biv_1
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|insn
argument_list|,
name|bl
argument_list|,
name|eliminate_p
argument_list|,
name|where
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return nonzero if the last use of REG    is in an insn following INSN in the same basic block.  */
end_comment

begin_function
specifier|static
name|int
name|last_use_this_basic_block
parameter_list|(
name|reg
parameter_list|,
name|insn
parameter_list|)
name|rtx
name|reg
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
name|rtx
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
name|insn
init|;
name|n
operator|&&
name|GET_CODE
argument_list|(
name|n
argument_list|)
operator|!=
name|CODE_LABEL
operator|&&
name|GET_CODE
argument_list|(
name|n
argument_list|)
operator|!=
name|JUMP_INSN
condition|;
name|n
operator|=
name|NEXT_INSN
argument_list|(
name|n
argument_list|)
control|)
block|{
if|if
condition|(
name|REGNO_LAST_UID
argument_list|(
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|)
operator|==
name|INSN_UID
argument_list|(
name|n
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Called via `note_stores' to record the initial value of a biv.  Here we    just record the location of the set and process it later.  */
end_comment

begin_function
specifier|static
name|void
name|record_initial
parameter_list|(
name|dest
parameter_list|,
name|set
parameter_list|)
name|rtx
name|dest
decl_stmt|;
name|rtx
name|set
decl_stmt|;
block|{
name|struct
name|iv_class
modifier|*
name|bl
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO
argument_list|(
name|dest
argument_list|)
operator|>=
name|max_reg_before_loop
operator|||
name|reg_iv_type
index|[
name|REGNO
argument_list|(
name|dest
argument_list|)
index|]
operator|!=
name|BASIC_INDUCT
condition|)
return|return;
name|bl
operator|=
name|reg_biv_class
index|[
name|REGNO
argument_list|(
name|dest
argument_list|)
index|]
expr_stmt|;
comment|/* If this is the first set found, record it.  */
if|if
condition|(
name|bl
operator|->
name|init_insn
operator|==
literal|0
condition|)
block|{
name|bl
operator|->
name|init_insn
operator|=
name|note_insn
expr_stmt|;
name|bl
operator|->
name|init_set
operator|=
name|set
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If any of the registers in X are "old" and currently have a last use earlier    than INSN, update them to have a last use of INSN.  Their actual last use    will be the previous insn but it will not have a valid uid_luid so we can't    use it.  */
end_comment

begin_function
specifier|static
name|void
name|update_reg_last_use
parameter_list|(
name|x
parameter_list|,
name|insn
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
comment|/* Check for the case where INSN does not have a valid luid.  In this case,      there is no need to modify the regno_last_uid, as this can only happen      when code is inserted after the loop_end to set a pseudo's final value,      and hence this insn will never be the last use of x.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|x
argument_list|)
operator|<
name|max_reg_before_loop
operator|&&
name|INSN_UID
argument_list|(
name|insn
argument_list|)
operator|<
name|max_uid_for_loop
operator|&&
name|uid_luid
index|[
name|REGNO_LAST_UID
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
index|]
operator|<
name|uid_luid
index|[
name|INSN_UID
argument_list|(
name|insn
argument_list|)
index|]
condition|)
name|REGNO_LAST_UID
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
operator|=
name|INSN_UID
argument_list|(
name|insn
argument_list|)
expr_stmt|;
else|else
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
init|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|update_reg_last_use
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
name|update_reg_last_use
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a jump insn JUMP, return the condition that will cause it to branch    to its JUMP_LABEL.  If the condition cannot be understood, or is an    inequality floating-point comparison which needs to be reversed, 0 will    be returned.     If EARLIEST is non-zero, it is a pointer to a place where the earliest    insn used in locating the condition was found.  If a replacement test    of the condition is desired, it should be placed in front of that    insn and we will be sure that the inputs are still valid.     The condition will be returned in a canonical form to simplify testing by    callers.  Specifically:     (1) The code will always be a comparison operation (EQ, NE, GT, etc.).    (2) Both operands will be machine operands; (cc0) will have been replaced.    (3) If an operand is a constant, it will be the second operand.    (4) (LE x const) will be replaced with (LT x<const+1>) and similarly        for GE, GEU, and LEU.  */
end_comment

begin_function
name|rtx
name|get_condition
parameter_list|(
name|jump
parameter_list|,
name|earliest
parameter_list|)
name|rtx
name|jump
decl_stmt|;
name|rtx
modifier|*
name|earliest
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
decl_stmt|;
name|rtx
name|prev
init|=
name|jump
decl_stmt|;
name|rtx
name|set
decl_stmt|;
name|rtx
name|tem
decl_stmt|;
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|;
name|int
name|reverse_code
init|=
literal|0
decl_stmt|;
name|int
name|did_reverse_condition
init|=
literal|0
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
comment|/* If this is not a standard conditional jump, we can't parse it.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|jump
argument_list|)
operator|!=
name|JUMP_INSN
operator|||
operator|!
name|condjump_p
argument_list|(
name|jump
argument_list|)
operator|||
name|simplejump_p
argument_list|(
name|jump
argument_list|)
condition|)
return|return
literal|0
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|jump
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|mode
operator|=
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|jump
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|op0
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|jump
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|jump
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|earliest
condition|)
operator|*
name|earliest
operator|=
name|jump
expr_stmt|;
comment|/* If this branches to JUMP_LABEL when the condition is false, reverse      the condition.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|jump
argument_list|)
argument_list|)
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|&&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|jump
argument_list|)
argument_list|)
argument_list|,
literal|2
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|JUMP_LABEL
argument_list|(
name|jump
argument_list|)
condition|)
name|code
operator|=
name|reverse_condition
argument_list|(
name|code
argument_list|)
operator|,
name|did_reverse_condition
operator|^=
literal|1
expr_stmt|;
comment|/* If we are comparing a register with zero, see if the register is set      in the previous insn to a COMPARE or a comparison operation.  Perform      the same tests as a function of STORE_FLAG_VALUE as find_comparison_args      in cse.c  */
while|while
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'<'
operator|&&
name|op1
operator|==
name|CONST0_RTX
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Set non-zero when we find something of interest.  */
name|rtx
name|x
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_cc0
comment|/* If comparison with cc0, import actual comparison from compare 	 insn.  */
if|if
condition|(
name|op0
operator|==
name|cc0_rtx
condition|)
block|{
if|if
condition|(
operator|(
name|prev
operator|=
name|prev_nonnote_insn
argument_list|(
name|prev
argument_list|)
operator|)
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|prev
argument_list|)
operator|!=
name|INSN
operator|||
operator|(
name|set
operator|=
name|single_set
argument_list|(
name|prev
argument_list|)
operator|)
operator|==
literal|0
operator|||
name|SET_DEST
argument_list|(
name|set
argument_list|)
operator|!=
name|cc0_rtx
condition|)
return|return
literal|0
return|;
name|op0
operator|=
name|SET_SRC
argument_list|(
name|set
argument_list|)
expr_stmt|;
name|op1
operator|=
name|CONST0_RTX
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|earliest
condition|)
operator|*
name|earliest
operator|=
name|prev
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* If this is a COMPARE, pick up the two things being compared.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|COMPARE
condition|)
block|{
name|op1
operator|=
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|op0
operator|=
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|REG
condition|)
break|break;
comment|/* Go back to the previous insn.  Stop if it is not an INSN.  We also 	 stop if it isn't a single set or if it has a REG_INC note because 	 we don't want to bother dealing with it.  */
if|if
condition|(
operator|(
name|prev
operator|=
name|prev_nonnote_insn
argument_list|(
name|prev
argument_list|)
operator|)
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|prev
argument_list|)
operator|!=
name|INSN
operator|||
name|FIND_REG_INC_NOTE
argument_list|(
name|prev
argument_list|,
literal|0
argument_list|)
operator|||
operator|(
name|set
operator|=
name|single_set
argument_list|(
name|prev
argument_list|)
operator|)
operator|==
literal|0
condition|)
break|break;
comment|/* If this is setting OP0, get what it sets it to if it looks 	 relevant.  */
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|,
name|op0
argument_list|)
condition|)
block|{
name|enum
name|machine_mode
name|inner_mode
init|=
name|GET_MODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
decl_stmt|;
comment|/* ??? We may not combine comparisons done in a CCmode with 	     comparisons not done in a CCmode.  This is to aid targets 	     like Alpha that have an IEEE compliant EQ instruction, and 	     a non-IEEE compliant BEQ instruction.  The use of CCmode is 	     actually artificial, simply to prevent the combination, but 	     should not affect other platforms.  */
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|COMPARE
operator|||
operator|(
operator|(
operator|(
name|code
operator|==
name|NE
operator|||
operator|(
name|code
operator|==
name|LT
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|inner_mode
argument_list|)
operator|==
name|MODE_INT
operator|&&
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|inner_mode
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|)
operator|&&
operator|(
name|STORE_FLAG_VALUE
operator|&
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|inner_mode
argument_list|)
operator|-
literal|1
operator|)
operator|)
operator|)
operator|)
ifdef|#
directive|ifdef
name|FLOAT_STORE_FLAG_VALUE
operator|||
operator|(
name|code
operator|==
name|LT
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|inner_mode
argument_list|)
operator|==
name|MODE_FLOAT
operator|&&
name|FLOAT_STORE_FLAG_VALUE
operator|<
literal|0
operator|)
endif|#
directive|endif
operator|)
operator|)
operator|&&
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|'<'
operator|)
operator|)
operator|&&
operator|(
operator|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_CC
operator|)
operator|!=
operator|(
name|GET_MODE_CLASS
argument_list|(
name|inner_mode
argument_list|)
operator|==
name|MODE_CC
operator|)
operator|)
condition|)
name|x
operator|=
name|SET_SRC
argument_list|(
name|set
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
operator|(
name|code
operator|==
name|EQ
operator|||
operator|(
name|code
operator|==
name|GE
operator|&&
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|inner_mode
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|)
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|inner_mode
argument_list|)
operator|==
name|MODE_INT
operator|&&
operator|(
name|STORE_FLAG_VALUE
operator|&
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|inner_mode
argument_list|)
operator|-
literal|1
operator|)
operator|)
operator|)
operator|)
ifdef|#
directive|ifdef
name|FLOAT_STORE_FLAG_VALUE
operator|||
operator|(
name|code
operator|==
name|GE
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|inner_mode
argument_list|)
operator|==
name|MODE_FLOAT
operator|&&
name|FLOAT_STORE_FLAG_VALUE
operator|<
literal|0
operator|)
endif|#
directive|endif
operator|)
operator|)
operator|&&
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|'<'
operator|&&
operator|(
operator|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_CC
operator|)
operator|!=
operator|(
name|GET_MODE_CLASS
argument_list|(
name|inner_mode
argument_list|)
operator|==
name|MODE_CC
operator|)
operator|)
condition|)
block|{
comment|/* We might have reversed a LT to get a GE here.  But this wasn't 		 actually the comparison of data, so we don't flag that we 		 have had to reverse the condition.  */
name|did_reverse_condition
operator|^=
literal|1
expr_stmt|;
name|reverse_code
operator|=
literal|1
expr_stmt|;
name|x
operator|=
name|SET_SRC
argument_list|(
name|set
argument_list|)
expr_stmt|;
block|}
else|else
break|break;
block|}
elseif|else
if|if
condition|(
name|reg_set_p
argument_list|(
name|op0
argument_list|,
name|prev
argument_list|)
condition|)
comment|/* If this sets OP0, but not directly, we have to give up.  */
break|break;
if|if
condition|(
name|x
condition|)
block|{
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
literal|'<'
condition|)
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|reverse_code
condition|)
block|{
name|code
operator|=
name|reverse_condition
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|did_reverse_condition
operator|^=
literal|1
expr_stmt|;
name|reverse_code
operator|=
literal|0
expr_stmt|;
block|}
name|op0
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|,
name|op1
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|earliest
condition|)
operator|*
name|earliest
operator|=
name|prev
expr_stmt|;
block|}
block|}
comment|/* If constant is first, put it last.  */
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|op0
argument_list|)
condition|)
name|code
operator|=
name|swap_condition
argument_list|(
name|code
argument_list|)
operator|,
name|tem
operator|=
name|op0
operator|,
name|op0
operator|=
name|op1
operator|,
name|op1
operator|=
name|tem
expr_stmt|;
comment|/* If OP0 is the result of a comparison, we weren't able to find what      was really being compared, so fail.  */
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|==
name|MODE_CC
condition|)
return|return
literal|0
return|;
comment|/* Canonicalize any ordered comparison with integers involving equality      if we can do computations in the relevant mode and we do not      overflow.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
name|HOST_WIDE_INT
name|const_val
init|=
name|INTVAL
argument_list|(
name|op1
argument_list|)
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|uconst_val
init|=
name|const_val
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|max_val
init|=
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|GET_MODE_MASK
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|LE
case|:
if|if
condition|(
name|const_val
operator|!=
name|max_val
operator|>>
literal|1
condition|)
name|code
operator|=
name|LT
operator|,
name|op1
operator|=
name|GEN_INT
argument_list|(
name|const_val
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
comment|/* When cross-compiling, const_val might be sign-extended from 	   BITS_PER_WORD to HOST_BITS_PER_WIDE_INT */
case|case
name|GE
case|:
if|if
condition|(
operator|(
name|const_val
operator|&
name|max_val
operator|)
operator|!=
operator|(
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|-
literal|1
operator|)
operator|)
operator|)
condition|)
name|code
operator|=
name|GT
operator|,
name|op1
operator|=
name|GEN_INT
argument_list|(
name|const_val
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|LEU
case|:
if|if
condition|(
name|uconst_val
operator|<
name|max_val
condition|)
name|code
operator|=
name|LTU
operator|,
name|op1
operator|=
name|GEN_INT
argument_list|(
name|uconst_val
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|GEU
case|:
if|if
condition|(
name|uconst_val
operator|!=
literal|0
condition|)
name|code
operator|=
name|GTU
operator|,
name|op1
operator|=
name|GEN_INT
argument_list|(
name|uconst_val
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
comment|/* If this was floating-point and we reversed anything other than an      EQ or NE, return zero.  */
if|if
condition|(
name|TARGET_FLOAT_FORMAT
operator|==
name|IEEE_FLOAT_FORMAT
operator|&&
name|did_reverse_condition
operator|&&
name|code
operator|!=
name|NE
operator|&&
name|code
operator|!=
name|EQ
operator|&&
operator|!
name|flag_fast_math
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|==
name|MODE_FLOAT
condition|)
return|return
literal|0
return|;
ifdef|#
directive|ifdef
name|HAVE_cc0
comment|/* Never return CC0; return zero instead.  */
if|if
condition|(
name|op0
operator|==
name|cc0_rtx
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
return|return
name|gen_rtx_fmt_ee
argument_list|(
name|code
argument_list|,
name|VOIDmode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Similar to above routine, except that we also put an invariant last    unless both operands are invariants.  */
end_comment

begin_function
name|rtx
name|get_condition_for_loop
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
name|rtx
name|comparison
init|=
name|get_condition
argument_list|(
name|x
argument_list|,
name|NULL_PTR
argument_list|)
decl_stmt|;
if|if
condition|(
name|comparison
operator|==
literal|0
operator|||
operator|!
name|invariant_p
argument_list|(
name|XEXP
argument_list|(
name|comparison
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
name|invariant_p
argument_list|(
name|XEXP
argument_list|(
name|comparison
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
return|return
name|comparison
return|;
return|return
name|gen_rtx_fmt_ee
argument_list|(
name|swap_condition
argument_list|(
name|GET_CODE
argument_list|(
name|comparison
argument_list|)
argument_list|)
argument_list|,
name|VOIDmode
argument_list|,
name|XEXP
argument_list|(
name|comparison
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|comparison
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|HAIFA
end_ifdef

begin_comment
comment|/* Analyze a loop in order to instrument it with the use of count register.    loop_start and loop_end are the first and last insns of the loop.    This function works in cooperation with insert_bct ().    loop_can_insert_bct[loop_num] is set according to whether the optimization    is applicable to the loop.  When it is applicable, the following variables    are also set:     loop_start_value[loop_num]     loop_comparison_value[loop_num]     loop_increment[loop_num]     loop_comparison_code[loop_num] */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_decrement_and_branch_on_count
end_ifdef

begin_function
specifier|static
name|void
name|analyze_loop_iterations
parameter_list|(
name|loop_start
parameter_list|,
name|loop_end
parameter_list|)
name|rtx
name|loop_start
decl_stmt|,
name|loop_end
decl_stmt|;
block|{
name|rtx
name|comparison
decl_stmt|,
name|comparison_value
decl_stmt|;
name|rtx
name|iteration_var
decl_stmt|,
name|initial_value
decl_stmt|,
name|increment
decl_stmt|;
name|enum
name|rtx_code
name|comparison_code
decl_stmt|;
name|rtx
name|last_loop_insn
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* loop_variable mode */
name|enum
name|machine_mode
name|original_mode
decl_stmt|;
comment|/* find the number of the loop */
name|int
name|loop_num
init|=
name|uid_loop_num
index|[
name|INSN_UID
argument_list|(
name|loop_start
argument_list|)
index|]
decl_stmt|;
comment|/* we change our mind only when we are sure that loop will be instrumented */
name|loop_can_insert_bct
index|[
name|loop_num
index|]
operator|=
literal|0
expr_stmt|;
comment|/* is the optimization suppressed.  */
if|if
condition|(
operator|!
name|flag_branch_on_count_reg
condition|)
return|return;
comment|/* make sure that count-reg is not in use */
if|if
condition|(
name|loop_used_count_register
index|[
name|loop_num
index|]
condition|)
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"analyze_loop_iterations %d: BCT instrumentation failed: count register already in use\n"
argument_list|,
name|loop_num
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* make sure that the function has no indirect jumps.  */
if|if
condition|(
name|indirect_jump_in_function
condition|)
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"analyze_loop_iterations %d: BCT instrumentation failed: indirect jump in function\n"
argument_list|,
name|loop_num
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* make sure that the last loop insn is a conditional jump */
name|last_loop_insn
operator|=
name|PREV_INSN
argument_list|(
name|loop_end
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|last_loop_insn
argument_list|)
operator|!=
name|JUMP_INSN
operator|||
operator|!
name|condjump_p
argument_list|(
name|last_loop_insn
argument_list|)
condition|)
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"analyze_loop_iterations %d: BCT instrumentation failed: invalid jump at loop end\n"
argument_list|,
name|loop_num
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* First find the iteration variable.  If the last insn is a conditional      branch, and the insn preceding it tests a register value, make that      register the iteration variable.  */
comment|/* We used to use prev_nonnote_insn here, but that fails because it might      accidentally get the branch for a contained loop if the branch for this      loop was deleted.  We can only trust branches immediately before the      loop_end.  */
name|comparison
operator|=
name|get_condition_for_loop
argument_list|(
name|last_loop_insn
argument_list|)
expr_stmt|;
comment|/* ??? Get_condition may switch position of induction variable and      invariant register when it canonicalizes the comparison.  */
if|if
condition|(
name|comparison
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"analyze_loop_iterations %d: BCT instrumentation failed: comparison not found\n"
argument_list|,
name|loop_num
argument_list|)
expr_stmt|;
return|return;
block|}
name|comparison_code
operator|=
name|GET_CODE
argument_list|(
name|comparison
argument_list|)
expr_stmt|;
name|iteration_var
operator|=
name|XEXP
argument_list|(
name|comparison
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|comparison_value
operator|=
name|XEXP
argument_list|(
name|comparison
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|original_mode
operator|=
name|GET_MODE
argument_list|(
name|iteration_var
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|original_mode
argument_list|)
operator|!=
name|MODE_INT
operator|||
name|GET_MODE_SIZE
argument_list|(
name|original_mode
argument_list|)
operator|!=
name|UNITS_PER_WORD
condition|)
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"analyze_loop_iterations %d: BCT Instrumentation failed: loop variable not integer\n"
argument_list|,
name|loop_num
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* get info about loop bounds and increment */
name|iteration_info
argument_list|(
name|iteration_var
argument_list|,
operator|&
name|initial_value
argument_list|,
operator|&
name|increment
argument_list|,
name|loop_start
argument_list|,
name|loop_end
argument_list|)
expr_stmt|;
comment|/* make sure that all required loop data were found */
if|if
condition|(
operator|!
operator|(
name|initial_value
operator|&&
name|increment
operator|&&
name|comparison_value
operator|&&
name|invariant_p
argument_list|(
name|comparison_value
argument_list|)
operator|&&
name|invariant_p
argument_list|(
name|increment
argument_list|)
operator|&&
operator|!
name|indirect_jump_in_function
operator|)
condition|)
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
block|{
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"analyze_loop_iterations %d: BCT instrumentation failed because of wrong loop: "
argument_list|,
name|loop_num
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|initial_value
operator|&&
name|increment
operator|&&
name|comparison_value
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"\tbounds not available: "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|initial_value
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"initial "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|increment
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"increment "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|comparison_value
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"comparison "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|invariant_p
argument_list|(
name|comparison_value
argument_list|)
operator|||
operator|!
name|invariant_p
argument_list|(
name|increment
argument_list|)
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"\tloop bounds not invariant\n"
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|/* make sure that the increment is constant */
if|if
condition|(
name|GET_CODE
argument_list|(
name|increment
argument_list|)
operator|!=
name|CONST_INT
condition|)
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"analyze_loop_iterations %d: instrumentation failed: not arithmetic loop\n"
argument_list|,
name|loop_num
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* make sure that the loop contains neither function call, nor jump on table.      (the count register might be altered by the called function, and might      be used for a branch on table).  */
for|for
control|(
name|insn
operator|=
name|loop_start
init|;
name|insn
operator|&&
name|insn
operator|!=
name|loop_end
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"analyze_loop_iterations %d: BCT instrumentation failed: function call in the loop\n"
argument_list|,
name|loop_num
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|ADDR_DIFF_VEC
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|ADDR_VEC
operator|)
condition|)
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"analyze_loop_iterations %d: BCT instrumentation failed: computed branch in the loop\n"
argument_list|,
name|loop_num
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* At this point, we are sure that the loop can be instrumented with BCT.      Some of the loops, however, will not be instrumented - the final decision      is taken by insert_bct () */
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"analyze_loop_iterations: loop (luid =%d) can be BCT instrumented.\n"
argument_list|,
name|loop_num
argument_list|)
expr_stmt|;
comment|/* mark all enclosing loops that they cannot use count register */
comment|/* ???: In fact, since insert_bct may decide not to instrument this loop,      marking here may prevent instrumenting an enclosing loop that could     actually be instrumented.  But since this is rare, it is safer to mark     here in case the order of calling  (analyze/insert)_bct would be changed.  */
for|for
control|(
name|i
operator|=
name|loop_num
init|;
name|i
operator|!=
operator|-
literal|1
condition|;
name|i
operator|=
name|loop_outer_loop
index|[
name|i
index|]
control|)
name|loop_used_count_register
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
comment|/* Set data structures which will be used by the instrumentation phase */
name|loop_start_value
index|[
name|loop_num
index|]
operator|=
name|initial_value
expr_stmt|;
name|loop_comparison_value
index|[
name|loop_num
index|]
operator|=
name|comparison_value
expr_stmt|;
name|loop_increment
index|[
name|loop_num
index|]
operator|=
name|increment
expr_stmt|;
name|loop_comparison_code
index|[
name|loop_num
index|]
operator|=
name|comparison_code
expr_stmt|;
name|loop_can_insert_bct
index|[
name|loop_num
index|]
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* instrument loop for insertion of bct instruction.  We distinguish between  loops with compile-time bounds, to those with run-time bounds.  The loop  behaviour is analized according to the following characteristics/variables:  ; Input variables:  ;   comparison-value: the value to which the iteration counter is compared.  ;   initial-value: iteration-counter initial value.  ;   increment: iteration-counter increment.  ; Computed variables:  ;   increment-direction: the sign of the increment.  ;   compare-direction: '1' for GT, GTE, '-1' for LT, LTE, '0' for NE.  ;   range-direction: sign (comparison-value - initial-value)  We give up on the following cases:  ; loop variable overflow.  ; run-time loop bounds with comparison code NE.  */
end_comment

begin_function
specifier|static
name|void
name|insert_bct
parameter_list|(
name|loop_start
parameter_list|,
name|loop_end
parameter_list|)
name|rtx
name|loop_start
decl_stmt|,
name|loop_end
decl_stmt|;
block|{
name|rtx
name|initial_value
decl_stmt|,
name|comparison_value
decl_stmt|,
name|increment
decl_stmt|;
name|enum
name|rtx_code
name|comparison_code
decl_stmt|;
name|int
name|increment_direction
decl_stmt|,
name|compare_direction
decl_stmt|;
name|int
name|unsigned_p
init|=
literal|0
decl_stmt|;
comment|/* if the loop condition is<= or>=, the number of iteration       is 1 more than the range of the bounds of the loop */
name|int
name|add_iteration
init|=
literal|0
decl_stmt|;
comment|/* the only machine mode we work with - is the integer of the size that the      machine has */
name|enum
name|machine_mode
name|loop_var_mode
init|=
name|SImode
decl_stmt|;
name|int
name|loop_num
init|=
name|uid_loop_num
index|[
name|INSN_UID
argument_list|(
name|loop_start
argument_list|)
index|]
decl_stmt|;
comment|/* get loop-variables. No need to check that these are valid - already      checked in analyze_loop_iterations ().  */
name|comparison_code
operator|=
name|loop_comparison_code
index|[
name|loop_num
index|]
expr_stmt|;
name|initial_value
operator|=
name|loop_start_value
index|[
name|loop_num
index|]
expr_stmt|;
name|comparison_value
operator|=
name|loop_comparison_value
index|[
name|loop_num
index|]
expr_stmt|;
name|increment
operator|=
name|loop_increment
index|[
name|loop_num
index|]
expr_stmt|;
comment|/* check analyze_loop_iterations decision for this loop.  */
if|if
condition|(
operator|!
name|loop_can_insert_bct
index|[
name|loop_num
index|]
condition|)
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"insert_bct: [%d] - was decided not to instrument by analyze_loop_iterations ()\n"
argument_list|,
name|loop_num
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* It's impossible to instrument a competely unrolled loop.  */
if|if
condition|(
name|loop_unroll_factor
index|[
name|loop_num
index|]
operator|==
operator|-
literal|1
condition|)
return|return;
comment|/* make sure that the last loop insn is a conditional jump .      This check is repeated from analyze_loop_iterations (),      because unrolling might have changed that.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|PREV_INSN
argument_list|(
name|loop_end
argument_list|)
argument_list|)
operator|!=
name|JUMP_INSN
operator|||
operator|!
name|condjump_p
argument_list|(
name|PREV_INSN
argument_list|(
name|loop_end
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"insert_bct: not instrumenting BCT because of invalid branch\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* fix increment in case loop was unrolled.  */
if|if
condition|(
name|loop_unroll_factor
index|[
name|loop_num
index|]
operator|>
literal|1
condition|)
name|increment
operator|=
name|GEN_INT
argument_list|(
name|INTVAL
argument_list|(
name|increment
argument_list|)
operator|*
name|loop_unroll_factor
index|[
name|loop_num
index|]
argument_list|)
expr_stmt|;
comment|/* determine properties and directions of the loop */
name|increment_direction
operator|=
operator|(
name|INTVAL
argument_list|(
name|increment
argument_list|)
operator|>
literal|0
operator|)
condition|?
literal|1
else|:
operator|-
literal|1
expr_stmt|;
switch|switch
condition|(
name|comparison_code
condition|)
block|{
case|case
name|LEU
case|:
name|unsigned_p
operator|=
literal|1
expr_stmt|;
comment|/* fallthrough */
case|case
name|LE
case|:
name|compare_direction
operator|=
literal|1
expr_stmt|;
name|add_iteration
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|GEU
case|:
name|unsigned_p
operator|=
literal|1
expr_stmt|;
comment|/* fallthrough */
case|case
name|GE
case|:
name|compare_direction
operator|=
operator|-
literal|1
expr_stmt|;
name|add_iteration
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|EQ
case|:
comment|/* in this case we cannot know the number of iterations */
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"insert_bct: %d: loop cannot be instrumented: == in condition\n"
argument_list|,
name|loop_num
argument_list|)
expr_stmt|;
return|return;
case|case
name|LTU
case|:
name|unsigned_p
operator|=
literal|1
expr_stmt|;
comment|/* fallthrough */
case|case
name|LT
case|:
name|compare_direction
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|GTU
case|:
name|unsigned_p
operator|=
literal|1
expr_stmt|;
comment|/* fallthrough */
case|case
name|GT
case|:
name|compare_direction
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|NE
case|:
name|compare_direction
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* make sure that the loop does not end by an overflow */
if|if
condition|(
name|compare_direction
operator|!=
name|increment_direction
condition|)
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"insert_bct: %d: loop cannot be instrumented: terminated by overflow\n"
argument_list|,
name|loop_num
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* try to instrument the loop.  */
comment|/* Handle the simpler case, where the bounds are known at compile time.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|initial_value
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|comparison_value
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|int
name|n_iterations
decl_stmt|;
name|int
name|increment_value_abs
init|=
name|INTVAL
argument_list|(
name|increment
argument_list|)
operator|*
name|increment_direction
decl_stmt|;
comment|/* check the relation between compare-val and initial-val */
name|int
name|difference
init|=
name|INTVAL
argument_list|(
name|comparison_value
argument_list|)
operator|-
name|INTVAL
argument_list|(
name|initial_value
argument_list|)
decl_stmt|;
name|int
name|range_direction
init|=
operator|(
name|difference
operator|>
literal|0
operator|)
condition|?
literal|1
else|:
operator|-
literal|1
decl_stmt|;
comment|/* make sure the loop executes enough iterations to gain from BCT */
if|if
condition|(
name|difference
operator|>
operator|-
literal|3
operator|&&
name|difference
operator|<
literal|3
condition|)
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"insert_bct: loop %d not BCT instrumented: too small iteration count.\n"
argument_list|,
name|loop_num
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* make sure that the loop executes at least once */
if|if
condition|(
operator|(
name|range_direction
operator|==
literal|1
operator|&&
name|compare_direction
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|range_direction
operator|==
operator|-
literal|1
operator|&&
name|compare_direction
operator|==
literal|1
operator|)
condition|)
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"insert_bct: loop %d: does not iterate even once. Not instrumenting.\n"
argument_list|,
name|loop_num
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* make sure that the loop does not end by an overflow (in compile time          bounds we must have an additional check for overflow, because here          we also support the compare code of 'NE'.  */
if|if
condition|(
name|comparison_code
operator|==
name|NE
operator|&&
name|increment_direction
operator|!=
name|range_direction
condition|)
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"insert_bct (compile time bounds): %d: loop not instrumented: terminated by overflow\n"
argument_list|,
name|loop_num
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Determine the number of iterations by: 	 ;          ;                  compare-val - initial-val + (increment -1) + additional-iteration          ; num_iterations = -----------------------------------------------------------------          ;                                           increment 	 */
name|difference
operator|=
operator|(
name|range_direction
operator|>
literal|0
operator|)
condition|?
name|difference
else|:
operator|-
name|difference
expr_stmt|;
if|#
directive|if
literal|0
block|fprintf (stderr, "difference is: %d\n", difference);
comment|/* @*/
block|fprintf (stderr, "increment_value_abs is: %d\n", increment_value_abs);
comment|/* @*/
block|fprintf (stderr, "add_iteration is: %d\n", add_iteration);
comment|/* @*/
block|fprintf (stderr, "INTVAL (comparison_value) is: %d\n", INTVAL (comparison_value));
comment|/* @*/
block|fprintf (stderr, "INTVAL (initial_value) is: %d\n", INTVAL (initial_value));
comment|/* @*/
endif|#
directive|endif
if|if
condition|(
name|increment_value_abs
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"insert_bct: error: increment == 0 !!!\n"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
name|n_iterations
operator|=
operator|(
name|difference
operator|+
name|increment_value_abs
operator|-
literal|1
operator|+
name|add_iteration
operator|)
operator|/
name|increment_value_abs
expr_stmt|;
if|#
directive|if
literal|0
block|fprintf (stderr, "number of iterations is: %d\n", n_iterations);
comment|/* @*/
endif|#
directive|endif
name|instrument_loop_bct
argument_list|(
name|loop_start
argument_list|,
name|loop_end
argument_list|,
name|GEN_INT
argument_list|(
name|n_iterations
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Done with this loop.  */
return|return;
block|}
comment|/* Handle the more complex case, that the bounds are NOT known at compile time.  */
comment|/* In this case we generate run_time calculation of the number of iterations */
comment|/* With runtime bounds, if the compare is of the form '!=' we give up */
if|if
condition|(
name|comparison_code
operator|==
name|NE
condition|)
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"insert_bct: fail for loop %d: runtime bounds with != comparison\n"
argument_list|,
name|loop_num
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
comment|/* We rely on the existence of run-time guard to ensure that the        loop executes at least once.  */
name|rtx
name|sequence
decl_stmt|;
name|rtx
name|iterations_num_reg
decl_stmt|;
name|int
name|increment_value_abs
init|=
name|INTVAL
argument_list|(
name|increment
argument_list|)
operator|*
name|increment_direction
decl_stmt|;
comment|/* make sure that the increment is a power of two, otherwise (an        expensive) divide is needed.  */
if|if
condition|(
name|exact_log2
argument_list|(
name|increment_value_abs
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"insert_bct: not instrumenting BCT because the increment is not power of 2\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* compute the number of iterations */
name|start_sequence
argument_list|()
expr_stmt|;
block|{
name|rtx
name|temp_reg
decl_stmt|;
comment|/* Again, the number of iterations is calculated by: 	 ;          ;                  compare-val - initial-val + (increment -1) + additional-iteration          ; num_iterations = -----------------------------------------------------------------          ;                                           increment 	 */
comment|/* ??? Do we have to call copy_rtx here before passing rtx to 	 expand_binop?  */
if|if
condition|(
name|compare_direction
operator|>
literal|0
condition|)
block|{
comment|/*<,<= :the loop variable is increasing */
name|temp_reg
operator|=
name|expand_binop
argument_list|(
name|loop_var_mode
argument_list|,
name|sub_optab
argument_list|,
name|comparison_value
argument_list|,
name|initial_value
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|temp_reg
operator|=
name|expand_binop
argument_list|(
name|loop_var_mode
argument_list|,
name|sub_optab
argument_list|,
name|initial_value
argument_list|,
name|comparison_value
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|increment_value_abs
operator|-
literal|1
operator|+
name|add_iteration
operator|!=
literal|0
condition|)
name|temp_reg
operator|=
name|expand_binop
argument_list|(
name|loop_var_mode
argument_list|,
name|add_optab
argument_list|,
name|temp_reg
argument_list|,
name|GEN_INT
argument_list|(
name|increment_value_abs
operator|-
literal|1
operator|+
name|add_iteration
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|increment_value_abs
operator|!=
literal|1
condition|)
block|{
comment|/* ??? This will generate an expensive divide instruction for 	     most targets.  The original authors apparently expected this 	     to be a shift, since they test for power-of-2 divisors above, 	     but just naively generating a divide instruction will not give  	     a shift.  It happens to work for the PowerPC target because 	     the rs6000.md file has a divide pattern that emits shifts. 	     It will probably not work for any other target.  */
name|iterations_num_reg
operator|=
name|expand_binop
argument_list|(
name|loop_var_mode
argument_list|,
name|sdiv_optab
argument_list|,
name|temp_reg
argument_list|,
name|GEN_INT
argument_list|(
name|increment_value_abs
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
block|}
else|else
name|iterations_num_reg
operator|=
name|temp_reg
expr_stmt|;
block|}
name|sequence
operator|=
name|gen_sequence
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_insn_before
argument_list|(
name|sequence
argument_list|,
name|loop_start
argument_list|)
expr_stmt|;
name|instrument_loop_bct
argument_list|(
name|loop_start
argument_list|,
name|loop_end
argument_list|,
name|iterations_num_reg
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* instrument loop by inserting a bct in it. This is done in the following way:    1. A new register is created and assigned the hard register number of the count     register.    2. In the head of the loop the new variable is initialized by the value passed in the     loop_num_iterations parameter.    3. At the end of the loop, comparison of the register with 0 is generated.     The created comparison follows the pattern defined for the     decrement_and_branch_on_count insn, so this insn will be generated in assembly     generation phase.    4. The compare&branch on the old variable is deleted. So, if the loop-variable was     not used elsewhere, it will be eliminated by data-flow analisys.  */
end_comment

begin_function
specifier|static
name|void
name|instrument_loop_bct
parameter_list|(
name|loop_start
parameter_list|,
name|loop_end
parameter_list|,
name|loop_num_iterations
parameter_list|)
name|rtx
name|loop_start
decl_stmt|,
name|loop_end
decl_stmt|;
name|rtx
name|loop_num_iterations
decl_stmt|;
block|{
name|rtx
name|temp_reg1
decl_stmt|,
name|temp_reg2
decl_stmt|;
name|rtx
name|start_label
decl_stmt|;
name|rtx
name|sequence
decl_stmt|;
name|enum
name|machine_mode
name|loop_var_mode
init|=
name|SImode
decl_stmt|;
if|if
condition|(
name|HAVE_decrement_and_branch_on_count
condition|)
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Loop: Inserting BCT\n"
argument_list|)
expr_stmt|;
comment|/* eliminate the check on the old variable */
name|delete_insn
argument_list|(
name|PREV_INSN
argument_list|(
name|loop_end
argument_list|)
argument_list|)
expr_stmt|;
name|delete_insn
argument_list|(
name|PREV_INSN
argument_list|(
name|loop_end
argument_list|)
argument_list|)
expr_stmt|;
comment|/* insert the label which will delimit the start of the loop */
name|start_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|emit_label_after
argument_list|(
name|start_label
argument_list|,
name|loop_start
argument_list|)
expr_stmt|;
comment|/* insert initialization of the count register into the loop header */
name|start_sequence
argument_list|()
expr_stmt|;
name|temp_reg1
operator|=
name|gen_reg_rtx
argument_list|(
name|loop_var_mode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_move_insn
argument_list|(
name|temp_reg1
argument_list|,
name|loop_num_iterations
argument_list|)
argument_list|)
expr_stmt|;
comment|/* this will be count register */
name|temp_reg2
operator|=
name|gen_rtx_REG
argument_list|(
name|loop_var_mode
argument_list|,
name|COUNT_REGISTER_REGNUM
argument_list|)
expr_stmt|;
comment|/* we have to move the value to the count register from an GPR 	 because rtx pointed to by loop_num_iterations could contain 	 expression which cannot be moved into count register */
name|emit_insn
argument_list|(
name|gen_move_insn
argument_list|(
name|temp_reg2
argument_list|,
name|temp_reg1
argument_list|)
argument_list|)
expr_stmt|;
name|sequence
operator|=
name|gen_sequence
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_insn_after
argument_list|(
name|sequence
argument_list|,
name|loop_start
argument_list|)
expr_stmt|;
comment|/* insert new comparison on the count register instead of the 	 old one, generating the needed BCT pattern (that will be 	 later recognized by assembly generation phase).  */
name|emit_jump_insn_before
argument_list|(
name|gen_decrement_and_branch_on_count
argument_list|(
name|temp_reg2
argument_list|,
name|start_label
argument_list|)
argument_list|,
name|loop_end
argument_list|)
expr_stmt|;
name|LABEL_NUSES
argument_list|(
name|start_label
argument_list|)
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_decrement_and_branch_on_count */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAIFA */
end_comment

begin_comment
comment|/* Scan the function and determine whether it has indirect (computed) jumps.     This is taken mostly from flow.c; similar code exists elsewhere    in the compiler.  It may be useful to put this into rtlanal.c.  */
end_comment

begin_function
specifier|static
name|int
name|indirect_jump_in_function_p
parameter_list|(
name|start
parameter_list|)
name|rtx
name|start
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|start
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|computed_jump_p
argument_list|(
name|insn
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

end_unit

