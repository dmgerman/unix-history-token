begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Perform various loop optimizations, including strength reduction.    Copyright (C) 1987, 88, 89, 91-98, 1999 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* This is the loop optimization pass of the compiler.    It finds invariant computations within loops and moves them    to the beginning of the loop.  Then it identifies basic and     general induction variables.  Strength reduction is applied to the general    induction variables, and induction variable elimination is applied to    the basic induction variables.     It also finds cases where    a register is set within the loop by zero-extending a narrower value    and changes these to zero the entire register once before the loop    and merely copy the low part within the loop.     Most of the complexity is in heuristics to decide when it is worth    while to do these things.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"insn-flags.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"loop.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_comment
comment|/* Vector mapping INSN_UIDs to luids.    The luids are like uids but increase monotonically always.    We use them to see whether a jump comes from outside a given loop.  */
end_comment

begin_decl_stmt
name|int
modifier|*
name|uid_luid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by INSN_UID, contains the ordinal giving the (innermost) loop    number the insn is contained in.  */
end_comment

begin_decl_stmt
name|int
modifier|*
name|uid_loop_num
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 + largest uid of any insn.  */
end_comment

begin_decl_stmt
name|int
name|max_uid_for_loop
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 + luid of last insn.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|max_luid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of loops detected in current function.  Used as index to the    next few tables.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|max_loop_num
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by loop number, contains the first and last insn of each loop.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
modifier|*
name|loop_number_loop_starts
decl_stmt|,
modifier|*
name|loop_number_loop_ends
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Likewise for the continue insn */
end_comment

begin_decl_stmt
specifier|static
name|rtx
modifier|*
name|loop_number_loop_cont
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The first code_label that is reached in every loop iteration.    0 when not computed yet, initially const0_rtx if a jump couldn't be    followed.    Also set to 0 when there is no such label before the NOTE_INSN_LOOP_CONT    of this loop, or in verify_dominator, if a jump couldn't be followed.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
modifier|*
name|loop_number_cont_dominator
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For each loop, gives the containing loop number, -1 if none.  */
end_comment

begin_decl_stmt
name|int
modifier|*
name|loop_outer_loop
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_decrement_and_branch_on_count
end_ifdef

begin_comment
comment|/* Records whether resource in use by inner loop.  */
end_comment

begin_decl_stmt
name|int
modifier|*
name|loop_used_count_register
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_decrement_and_branch_on_count */
end_comment

begin_comment
comment|/* Indexed by loop number, contains a nonzero value if the "loop" isn't    really a loop (an insn outside the loop branches into it).  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|loop_invalid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by loop number, links together all LABEL_REFs which refer to    code labels outside the loop.  Used by routines that need to know all    loop exits, such as final_biv_value and final_giv_value.     This does not include loop exits due to return instructions.  This is    because all bivs and givs are pseudos, and hence must be dead after a    return, so the presense of a return does not affect any of the    optimizations that use this info.  It is simpler to just not include return    instructions on this list.  */
end_comment

begin_decl_stmt
name|rtx
modifier|*
name|loop_number_exit_labels
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by loop number, counts the number of LABEL_REFs on    loop_number_exit_labels for this loop and all loops nested inside it.  */
end_comment

begin_decl_stmt
name|int
modifier|*
name|loop_number_exit_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if there is a subroutine call in the current loop.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|loop_has_call
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if there is a volatile memory reference in the current    loop.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|loop_has_volatile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if there is a tablejump in the current loop.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|loop_has_tablejump
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Added loop_continue which is the NOTE_INSN_LOOP_CONT of the    current loop.  A continue statement will generate a branch to    NEXT_INSN (loop_continue).  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|loop_continue
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by register number, contains the number of times the reg    is set during the loop being scanned.    During code motion, a negative value indicates a reg that has been    made a candidate; in particular -2 means that it is an candidate that    we know is equal to a constant and -1 means that it is an candidate    not known equal to a constant.    After code motion, regs moved have 0 (which is accurate now)    while the failed candidates have the original number of times set.     Therefore, at all times, == 0 indicates an invariant register;< 0 a conditionally invariant one.  */
end_comment

begin_decl_stmt
specifier|static
name|varray_type
name|set_in_loop
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Original value of set_in_loop; same except that this value    is not set negative for a reg whose sets have been made candidates    and not set to 0 for a reg that is moved.  */
end_comment

begin_decl_stmt
specifier|static
name|varray_type
name|n_times_set
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Index by register number, 1 indicates that the register    cannot be moved or strength reduced.  */
end_comment

begin_decl_stmt
specifier|static
name|varray_type
name|may_not_optimize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Contains the insn in which a register was used if it was used    exactly once; contains const0_rtx if it was used more than once.  */
end_comment

begin_decl_stmt
specifier|static
name|varray_type
name|reg_single_usage
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means reg N has already been moved out of one loop.    This reduces the desire to move it out of another.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|moved_once
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List of MEMs that are stored in this loop.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|loop_store_mems
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The insn where the first of these was found.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|first_loop_store_insn
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
name|loop_mem_info
block|{
name|rtx
name|mem
decl_stmt|;
comment|/* The MEM itself.  */
name|rtx
name|reg
decl_stmt|;
comment|/* Corresponding pseudo, if any.  */
name|int
name|optimize
decl_stmt|;
comment|/* Nonzero if we can optimize access to this MEM.  */
block|}
name|loop_mem_info
typedef|;
end_typedef

begin_comment
comment|/* Array of MEMs that are used (read or written) in this loop, but    cannot be aliased by anything in this loop, except perhaps    themselves.  In other words, if loop_mems[i] is altered during the    loop, it is altered by an expression that is rtx_equal_p to it.  */
end_comment

begin_decl_stmt
specifier|static
name|loop_mem_info
modifier|*
name|loop_mems
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The index of the next available slot in LOOP_MEMS.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|loop_mems_idx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of elements allocated in LOOP_MEMs.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|loop_mems_allocated
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if we don't know what MEMs were changed in the current loop.    This happens if the loop contains a call (in which case `loop_has_call'    will also be set) or if we store into more than NUM_STORES MEMs.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|unknown_address_altered
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Count of movable (i.e. invariant) instructions discovered in the loop.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|num_movables
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Count of memory write instructions discovered in the loop.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|num_mem_sets
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of loops contained within the current one, including itself.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|loops_enclosed
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Bound on pseudo register number before loop optimization.    A pseudo has valid regscan info if its number is< max_reg_before_loop.  */
end_comment

begin_decl_stmt
name|int
name|max_reg_before_loop
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This obstack is used in product_cheap_p to allocate its rtl.  It    may call gen_reg_rtx which, in turn, may reallocate regno_reg_rtx.    If we used the same obstack that it did, we would be deallocating    that array.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|temp_obstack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is where the pointer to the obstack being used for RTL is stored.  */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|obstack
modifier|*
name|rtl_obstack
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|obstack_chunk_alloc
value|xmalloc
end_define

begin_define
define|#
directive|define
name|obstack_chunk_free
value|free
end_define

begin_escape
end_escape

begin_comment
comment|/* During the analysis of a loop, a chain of `struct movable's    is made to record all the movable insns found.    Then the entire chain can be scanned to decide which to move.  */
end_comment

begin_struct
struct|struct
name|movable
block|{
name|rtx
name|insn
decl_stmt|;
comment|/* A movable insn */
name|rtx
name|set_src
decl_stmt|;
comment|/* The expression this reg is set from.  */
name|rtx
name|set_dest
decl_stmt|;
comment|/* The destination of this SET.  */
name|rtx
name|dependencies
decl_stmt|;
comment|/* When INSN is libcall, this is an EXPR_LIST 				   of any registers used within the LIBCALL.  */
name|int
name|consec
decl_stmt|;
comment|/* Number of consecutive following insns  				   that must be moved with this one.  */
name|int
name|regno
decl_stmt|;
comment|/* The register it sets */
name|short
name|lifetime
decl_stmt|;
comment|/* lifetime of that register; 				   may be adjusted when matching movables 				   that load the same value are found.  */
name|short
name|savings
decl_stmt|;
comment|/* Number of insns we can move for this reg, 				   including other movables that force this 				   or match this one.  */
name|unsigned
name|int
name|cond
range|:
literal|1
decl_stmt|;
comment|/* 1 if only conditionally movable */
name|unsigned
name|int
name|force
range|:
literal|1
decl_stmt|;
comment|/* 1 means MUST move this insn */
name|unsigned
name|int
name|global
range|:
literal|1
decl_stmt|;
comment|/* 1 means reg is live outside this loop */
comment|/* If PARTIAL is 1, GLOBAL means something different: 		   that the reg is live outside the range from where it is set 		   to the following label.  */
name|unsigned
name|int
name|done
range|:
literal|1
decl_stmt|;
comment|/* 1 inhibits further processing of this */
name|unsigned
name|int
name|partial
range|:
literal|1
decl_stmt|;
comment|/* 1 means this reg is used for zero-extending. 				   In particular, moving it does not make it 				   invariant.  */
name|unsigned
name|int
name|move_insn
range|:
literal|1
decl_stmt|;
comment|/* 1 means that we call emit_move_insn to 				   load SRC, rather than copying INSN.  */
name|unsigned
name|int
name|move_insn_first
range|:
literal|1
decl_stmt|;
comment|/* Same as above, if this is necessary for the 				    first insn of a consecutive sets group.  */
name|unsigned
name|int
name|is_equiv
range|:
literal|1
decl_stmt|;
comment|/* 1 means a REG_EQUIV is present on INSN.  */
name|enum
name|machine_mode
name|savemode
decl_stmt|;
comment|/* Nonzero means it is a mode for a low part 				   that we should avoid changing when clearing 				   the rest of the reg.  */
name|struct
name|movable
modifier|*
name|match
decl_stmt|;
comment|/* First entry for same value */
name|struct
name|movable
modifier|*
name|forces
decl_stmt|;
comment|/* An insn that must be moved if this is */
name|struct
name|movable
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|movable
modifier|*
name|the_movables
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|loop_dump_stream
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For communicating return values from note_set_pseudo_multiple_uses.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|note_set_pseudo_multiple_uses_retval
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forward declarations.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|verify_dominator
name|PROTO
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|find_and_verify_loops
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mark_loop_jump
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|prescan_loop
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|reg_in_basic_block_p
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|consec_sets_invariant_p
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|labels_in_range_p
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|count_one_set
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|varray_type
operator|,
name|rtx
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|count_loop_regs_set
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|varray_type
operator|,
name|varray_type
operator|,
name|int
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|note_addr_stored
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|note_set_pseudo_multiple_uses
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|loop_reg_used_before_p
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|scan_loop
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static void replace_call_address PROTO((rtx, rtx, rtx));
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|rtx
name|skip_consec_insns
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|libcall_benefit
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ignore_some_movables
name|PROTO
argument_list|(
operator|(
expr|struct
name|movable
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|force_movables
name|PROTO
argument_list|(
operator|(
expr|struct
name|movable
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|combine_movables
name|PROTO
argument_list|(
operator|(
expr|struct
name|movable
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|regs_match_p
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
expr|struct
name|movable
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|rtx_equal_for_loop_p
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
expr|struct
name|movable
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_label_notes
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|move_movables
name|PROTO
argument_list|(
operator|(
expr|struct
name|movable
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|count_nonfixed_reads
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|strength_reduce
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|int
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|find_single_use_in_loop
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|varray_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|valid_initial_value_p
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|int
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|find_mem_givs
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|int
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|record_biv
name|PROTO
argument_list|(
operator|(
expr|struct
name|induction
operator|*
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|check_final_value
name|PROTO
argument_list|(
operator|(
expr|struct
name|induction
operator|*
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|unsigned
name|HOST_WIDE_INT
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|record_giv
name|PROTO
argument_list|(
operator|(
expr|struct
name|induction
operator|*
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|int
operator|,
expr|enum
name|g_types
operator|,
name|int
operator|,
name|rtx
operator|*
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|update_giv_derive
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|basic_induction_var
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
expr|enum
name|machine_mode
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|*
operator|,
name|rtx
operator|*
operator|,
name|rtx
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|simplify_giv_expr
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|general_induction_var
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|*
operator|,
name|rtx
operator|*
operator|,
name|rtx
operator|*
operator|,
name|int
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|consec_sets_giv
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|*
operator|,
name|rtx
operator|*
operator|,
name|rtx
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|check_dbra_loop
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|,
name|rtx
operator|,
expr|struct
name|loop_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|express_from_1
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|combine_givs_p
name|PROTO
argument_list|(
operator|(
expr|struct
name|induction
operator|*
operator|,
expr|struct
name|induction
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|combine_givs
name|PROTO
argument_list|(
operator|(
expr|struct
name|iv_class
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_struct_decl
struct_decl|struct
name|recombine_givs_stats
struct_decl|;
end_struct_decl

begin_decl_stmt
specifier|static
name|int
name|find_life_end
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
expr|struct
name|recombine_givs_stats
operator|*
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|recombine_givs
name|PROTO
argument_list|(
operator|(
expr|struct
name|iv_class
operator|*
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|product_cheap_p
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|maybe_eliminate_biv
name|PROTO
argument_list|(
operator|(
expr|struct
name|iv_class
operator|*
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|maybe_eliminate_biv_1
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
expr|struct
name|iv_class
operator|*
operator|,
name|int
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|last_use_this_basic_block
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|record_initial
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|update_reg_last_use
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|next_insn_in_loop
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|load_mems_and_recount_loop_regs_set
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|load_mems
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|insert_loop_mem
name|PROTO
argument_list|(
operator|(
name|rtx
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|replace_loop_mem
name|PROTO
argument_list|(
operator|(
name|rtx
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|replace_label
name|PROTO
argument_list|(
operator|(
name|rtx
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
name|rtx_and_int
block|{
name|rtx
name|r
decl_stmt|;
name|int
name|i
decl_stmt|;
block|}
name|rtx_and_int
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|rtx_pair
block|{
name|rtx
name|r1
decl_stmt|;
name|rtx
name|r2
decl_stmt|;
block|}
name|rtx_pair
typedef|;
end_typedef

begin_comment
comment|/* Nonzero iff INSN is between START and END, inclusive.  */
end_comment

begin_define
define|#
directive|define
name|INSN_IN_RANGE_P
parameter_list|(
name|INSN
parameter_list|,
name|START
parameter_list|,
name|END
parameter_list|)
define|\
value|(INSN_UID (INSN)< max_uid_for_loop 		\&& INSN_LUID (INSN)>= INSN_LUID (START)	\&& INSN_LUID (INSN)<= INSN_LUID (END))
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_decrement_and_branch_on_count
end_ifdef

begin_comment
comment|/* Test whether BCT applicable and safe.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|insert_bct
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
expr|struct
name|loop_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Auxiliary function that inserts the BCT pattern into the loop.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|instrument_loop_bct
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_decrement_and_branch_on_count */
end_comment

begin_comment
comment|/* Indirect_jump_in_function is computed once per function.  */
end_comment

begin_decl_stmt
name|int
name|indirect_jump_in_function
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|indirect_jump_in_function_p
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|compute_luids
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|biv_elimination_giv_has_0_offset
name|PROTO
argument_list|(
operator|(
expr|struct
name|induction
operator|*
operator|,
expr|struct
name|induction
operator|*
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Relative gain of eliminating various kinds of operations.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|add_cost
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static int shift_cost; static int mult_cost;
endif|#
directive|endif
end_endif

begin_comment
comment|/* Benefit penalty, if a giv is not replaceable, i.e. must emit an insn to    copy the value of the strength reduced giv to its original register.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|copy_cost
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Cost of using a register, to normalize the benefits of a giv.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|reg_address_cost
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|init_loop
parameter_list|()
block|{
name|char
modifier|*
name|free_point
init|=
operator|(
name|char
operator|*
operator|)
name|oballoc
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|rtx
name|reg
init|=
name|gen_rtx_REG
argument_list|(
name|word_mode
argument_list|,
name|LAST_VIRTUAL_REGISTER
operator|+
literal|1
argument_list|)
decl_stmt|;
name|add_cost
operator|=
name|rtx_cost
argument_list|(
name|gen_rtx_PLUS
argument_list|(
name|word_mode
argument_list|,
name|reg
argument_list|,
name|reg
argument_list|)
argument_list|,
name|SET
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ADDRESS_COST
name|reg_address_cost
operator|=
name|ADDRESS_COST
argument_list|(
name|reg
argument_list|)
expr_stmt|;
else|#
directive|else
name|reg_address_cost
operator|=
name|rtx_cost
argument_list|(
name|reg
argument_list|,
name|MEM
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* We multiply by 2 to reconcile the difference in scale between      these two ways of computing costs.  Otherwise the cost of a copy      will be far less than the cost of an add.  */
name|copy_cost
operator|=
literal|2
operator|*
literal|2
expr_stmt|;
comment|/* Free the objects we just allocated.  */
name|obfree
argument_list|(
name|free_point
argument_list|)
expr_stmt|;
comment|/* Initialize the obstack used for rtl in product_cheap_p.  */
name|gcc_obstack_init
argument_list|(
operator|&
name|temp_obstack
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Compute the mapping from uids to luids.    LUIDs are numbers assigned to insns, like uids,    except that luids increase monotonically through the code.    Start at insn START and stop just before END.  Assign LUIDs    starting with PREV_LUID + 1.  Return the last assigned LUID + 1.  */
end_comment

begin_function
specifier|static
name|int
name|compute_luids
parameter_list|(
name|start
parameter_list|,
name|end
parameter_list|,
name|prev_luid
parameter_list|)
name|rtx
name|start
decl_stmt|,
name|end
decl_stmt|;
name|int
name|prev_luid
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|start
operator|,
name|i
operator|=
name|prev_luid
init|;
name|insn
operator|!=
name|end
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|INSN_UID
argument_list|(
name|insn
argument_list|)
operator|>=
name|max_uid_for_loop
condition|)
continue|continue;
comment|/* Don't assign luids to line-number NOTEs, so that the distance in 	 luids between two insns is not affected by -g.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE
operator|||
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|<=
literal|0
condition|)
name|uid_luid
index|[
name|INSN_UID
argument_list|(
name|insn
argument_list|)
index|]
operator|=
operator|++
name|i
expr_stmt|;
else|else
comment|/* Give a line number note the same luid as preceding insn.  */
name|uid_luid
index|[
name|INSN_UID
argument_list|(
name|insn
argument_list|)
index|]
operator|=
name|i
expr_stmt|;
block|}
return|return
name|i
operator|+
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Entry point of this file.  Perform loop optimization    on the current function.  F is the first insn of the function    and DUMPFILE is a stream for output of a trace of actions taken    (or 0 if none should be output).  */
end_comment

begin_function
name|void
name|loop_optimize
parameter_list|(
name|f
parameter_list|,
name|dumpfile
parameter_list|,
name|unroll_p
parameter_list|,
name|bct_p
parameter_list|)
comment|/* f is the first instruction of a chain of insns for one function */
name|rtx
name|f
decl_stmt|;
name|FILE
modifier|*
name|dumpfile
decl_stmt|;
name|int
name|unroll_p
decl_stmt|,
name|bct_p
decl_stmt|;
block|{
specifier|register
name|rtx
name|insn
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|loop_dump_stream
operator|=
name|dumpfile
expr_stmt|;
name|init_recog_no_volatile
argument_list|()
expr_stmt|;
name|max_reg_before_loop
operator|=
name|max_reg_num
argument_list|()
expr_stmt|;
name|moved_once
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|max_reg_before_loop
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|moved_once
argument_list|,
name|max_reg_before_loop
argument_list|)
expr_stmt|;
name|regs_may_share
operator|=
literal|0
expr_stmt|;
comment|/* Count the number of loops.  */
name|max_loop_num
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|f
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_LOOP_BEG
condition|)
name|max_loop_num
operator|++
expr_stmt|;
block|}
comment|/* Don't waste time if no loops.  */
if|if
condition|(
name|max_loop_num
operator|==
literal|0
condition|)
return|return;
comment|/* Get size to use for tables indexed by uids.      Leave some space for labels allocated by find_and_verify_loops.  */
name|max_uid_for_loop
operator|=
name|get_max_uid
argument_list|()
operator|+
literal|1
operator|+
name|max_loop_num
operator|*
literal|32
expr_stmt|;
name|uid_luid
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|max_uid_for_loop
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|uid_loop_num
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|max_uid_for_loop
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|uid_luid
argument_list|,
name|max_uid_for_loop
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|uid_loop_num
argument_list|,
name|max_uid_for_loop
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Allocate tables for recording each loop.  We set each entry, so they need      not be zeroed.  */
name|loop_number_loop_starts
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|max_loop_num
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|loop_number_loop_ends
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|max_loop_num
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|loop_number_loop_cont
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|max_loop_num
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|loop_number_cont_dominator
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|max_loop_num
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|loop_outer_loop
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|max_loop_num
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|loop_invalid
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|max_loop_num
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
name|loop_number_exit_labels
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|max_loop_num
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|loop_number_exit_count
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|max_loop_num
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_decrement_and_branch_on_count
comment|/* Allocate for BCT optimization */
name|loop_used_count_register
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|max_loop_num
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|loop_used_count_register
argument_list|,
name|max_loop_num
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_decrement_and_branch_on_count */
comment|/* Find and process each loop.      First, find them, and record them in order of their beginnings.  */
name|find_and_verify_loops
argument_list|(
name|f
argument_list|)
expr_stmt|;
comment|/* Now find all register lifetimes.  This must be done after      find_and_verify_loops, because it might reorder the insns in the      function.  */
name|reg_scan
argument_list|(
name|f
argument_list|,
name|max_reg_num
argument_list|()
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* This must occur after reg_scan so that registers created by gcse      will have entries in the register tables.       We could have added a call to reg_scan after gcse_main in toplev.c,      but moving this call to init_alias_analysis is more efficient.  */
name|init_alias_analysis
argument_list|()
expr_stmt|;
comment|/* See if we went too far.  Note that get_max_uid already returns      one more that the maximum uid of all insn.  */
if|if
condition|(
name|get_max_uid
argument_list|()
operator|>
name|max_uid_for_loop
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Now reset it to the actual size we need.  See above.  */
name|max_uid_for_loop
operator|=
name|get_max_uid
argument_list|()
expr_stmt|;
comment|/* find_and_verify_loops has already called compute_luids, but it might      have rearranged code afterwards, so we need to recompute the luids now.  */
name|max_luid
operator|=
name|compute_luids
argument_list|(
name|f
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Don't leave gaps in uid_luid for insns that have been      deleted.  It is possible that the first or last insn      using some register has been deleted by cross-jumping.      Make sure that uid_luid for that former insn's uid      points to the general area where that insn used to be.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_uid_for_loop
condition|;
name|i
operator|++
control|)
block|{
name|uid_luid
index|[
literal|0
index|]
operator|=
name|uid_luid
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|uid_luid
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
break|break;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_uid_for_loop
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|uid_luid
index|[
name|i
index|]
operator|==
literal|0
condition|)
name|uid_luid
index|[
name|i
index|]
operator|=
name|uid_luid
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
comment|/* Create a mapping from loops to BLOCK tree nodes.  */
if|if
condition|(
name|unroll_p
operator|&&
name|write_symbols
operator|!=
name|NO_DEBUG
condition|)
name|find_loop_tree_blocks
argument_list|()
expr_stmt|;
comment|/* Determine if the function has indirect jump.  On some systems      this prevents low overhead loop instructions from being used.  */
name|indirect_jump_in_function
operator|=
name|indirect_jump_in_function_p
argument_list|(
name|f
argument_list|)
expr_stmt|;
comment|/* Now scan the loops, last ones first, since this means inner ones are done      before outer ones.  */
for|for
control|(
name|i
operator|=
name|max_loop_num
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
operator|!
name|loop_invalid
index|[
name|i
index|]
operator|&&
name|loop_number_loop_ends
index|[
name|i
index|]
condition|)
name|scan_loop
argument_list|(
name|loop_number_loop_starts
index|[
name|i
index|]
argument_list|,
name|loop_number_loop_ends
index|[
name|i
index|]
argument_list|,
name|loop_number_loop_cont
index|[
name|i
index|]
argument_list|,
name|unroll_p
argument_list|,
name|bct_p
argument_list|)
expr_stmt|;
comment|/* If debugging and unrolling loops, we must replicate the tree nodes      corresponding to the blocks inside the loop, so that the original one      to one mapping will remain.  */
if|if
condition|(
name|unroll_p
operator|&&
name|write_symbols
operator|!=
name|NO_DEBUG
condition|)
name|unroll_block_trees
argument_list|()
expr_stmt|;
name|end_alias_analysis
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Returns the next insn, in execution order, after INSN.  START and    END are the NOTE_INSN_LOOP_BEG and NOTE_INSN_LOOP_END for the loop,    respectively.  LOOP_TOP, if non-NULL, is the top of the loop in the    insn-stream; it is used with loops that are entered near the    bottom.  */
end_comment

begin_function
specifier|static
name|rtx
name|next_insn_in_loop
parameter_list|(
name|insn
parameter_list|,
name|start
parameter_list|,
name|end
parameter_list|,
name|loop_top
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|rtx
name|start
decl_stmt|;
name|rtx
name|end
decl_stmt|;
name|rtx
name|loop_top
decl_stmt|;
block|{
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|==
name|end
condition|)
block|{
if|if
condition|(
name|loop_top
condition|)
comment|/* Go to the top of the loop, and continue there.  */
name|insn
operator|=
name|loop_top
expr_stmt|;
else|else
comment|/* We're done.  */
name|insn
operator|=
name|NULL_RTX
expr_stmt|;
block|}
if|if
condition|(
name|insn
operator|==
name|start
condition|)
comment|/* We're done.  */
name|insn
operator|=
name|NULL_RTX
expr_stmt|;
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Optimize one loop whose start is LOOP_START and end is END.    LOOP_START is the NOTE_INSN_LOOP_BEG and END is the matching    NOTE_INSN_LOOP_END.    LOOP_CONT is the NOTE_INSN_LOOP_CONT.  */
end_comment

begin_comment
comment|/* ??? Could also move memory writes out of loops if the destination address    is invariant, the source is invariant, the memory write is not volatile,    and if we can prove that no read inside the loop can read this address    before the write occurs.  If there is a read of this address after the    write, then we can also mark the memory read as invariant.  */
end_comment

begin_function
specifier|static
name|void
name|scan_loop
parameter_list|(
name|loop_start
parameter_list|,
name|end
parameter_list|,
name|loop_cont
parameter_list|,
name|unroll_p
parameter_list|,
name|bct_p
parameter_list|)
name|rtx
name|loop_start
decl_stmt|,
name|end
decl_stmt|,
name|loop_cont
decl_stmt|;
name|int
name|unroll_p
decl_stmt|,
name|bct_p
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|rtx
name|p
decl_stmt|;
comment|/* 1 if we are scanning insns that could be executed zero times.  */
name|int
name|maybe_never
init|=
literal|0
decl_stmt|;
comment|/* 1 if we are scanning insns that might never be executed      due to a subroutine call which might exit before they are reached.  */
name|int
name|call_passed
init|=
literal|0
decl_stmt|;
comment|/* For a rotated loop that is entered near the bottom,      this is the label at the top.  Otherwise it is zero.  */
name|rtx
name|loop_top
init|=
literal|0
decl_stmt|;
comment|/* Jump insn that enters the loop, or 0 if control drops in.  */
name|rtx
name|loop_entry_jump
init|=
literal|0
decl_stmt|;
comment|/* Place in the loop where control enters.  */
name|rtx
name|scan_start
decl_stmt|;
comment|/* Number of insns in the loop.  */
name|int
name|insn_count
decl_stmt|;
name|int
name|in_libcall
init|=
literal|0
decl_stmt|;
name|int
name|tem
decl_stmt|;
name|rtx
name|temp
decl_stmt|;
comment|/* The SET from an insn, if it is the only SET in the insn.  */
name|rtx
name|set
decl_stmt|,
name|set1
decl_stmt|;
comment|/* Chain describing insns movable in current loop.  */
name|struct
name|movable
modifier|*
name|movables
init|=
literal|0
decl_stmt|;
comment|/* Last element in `movables' -- so we can add elements at the end.  */
name|struct
name|movable
modifier|*
name|last_movable
init|=
literal|0
decl_stmt|;
comment|/* Ratio of extra register life span we can justify      for saving an instruction.  More if loop doesn't call subroutines      since in that case saving an insn makes more difference      and more registers are available.  */
name|int
name|threshold
decl_stmt|;
comment|/* Nonzero if we are scanning instructions in a sub-loop.  */
name|int
name|loop_depth
init|=
literal|0
decl_stmt|;
name|int
name|nregs
decl_stmt|;
comment|/* Determine whether this loop starts with a jump down to a test at      the end.  This will occur for a small number of loops with a test      that is too complex to duplicate in front of the loop.       We search for the first insn or label in the loop, skipping NOTEs.      However, we must be careful not to skip past a NOTE_INSN_LOOP_BEG      (because we might have a loop executed only once that contains a      loop which starts with a jump to its exit test) or a NOTE_INSN_LOOP_END      (in case we have a degenerate loop).       Note that if we mistakenly think that a loop is entered at the top      when, in fact, it is entered at the exit test, the only effect will be      slightly poorer optimization.  Making the opposite error can generate      incorrect code.  Since very few loops now start with a jump to the       exit test, the code here to detect that case is very conservative.  */
for|for
control|(
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|loop_start
argument_list|)
init|;
name|p
operator|!=
name|end
operator|&&
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|!=
name|CODE_LABEL
operator|&&
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
argument_list|)
operator|!=
literal|'i'
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|!=
name|NOTE
operator|||
operator|(
name|NOTE_LINE_NUMBER
argument_list|(
name|p
argument_list|)
operator|!=
name|NOTE_INSN_LOOP_BEG
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|p
argument_list|)
operator|!=
name|NOTE_INSN_LOOP_END
operator|)
operator|)
condition|;
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
control|)
empty_stmt|;
name|scan_start
operator|=
name|p
expr_stmt|;
comment|/* Set up variables describing this loop.  */
name|prescan_loop
argument_list|(
name|loop_start
argument_list|,
name|end
argument_list|)
expr_stmt|;
name|threshold
operator|=
operator|(
name|loop_has_call
condition|?
literal|1
else|:
literal|2
operator|)
operator|*
operator|(
literal|1
operator|+
name|n_non_fixed_regs
operator|)
expr_stmt|;
comment|/* If loop has a jump before the first label,      the true entry is the target of that jump.      Start scan from there.      But record in LOOP_TOP the place where the end-test jumps      back to so we can scan that after the end of the loop.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|JUMP_INSN
condition|)
block|{
name|loop_entry_jump
operator|=
name|p
expr_stmt|;
comment|/* Loop entry must be unconditional jump (and not a RETURN)  */
if|if
condition|(
name|simplejump_p
argument_list|(
name|p
argument_list|)
operator|&&
name|JUMP_LABEL
argument_list|(
name|p
argument_list|)
operator|!=
literal|0
comment|/* Check to see whether the jump actually 	     jumps out of the loop (meaning it's no loop). 	     This case can happen for things like 	     do {..} while (0).  If this label was generated previously 	     by loop, we can't tell anything about it and have to reject 	     the loop.  */
operator|&&
name|INSN_IN_RANGE_P
argument_list|(
name|JUMP_LABEL
argument_list|(
name|p
argument_list|)
argument_list|,
name|loop_start
argument_list|,
name|end
argument_list|)
condition|)
block|{
name|loop_top
operator|=
name|next_label
argument_list|(
name|scan_start
argument_list|)
expr_stmt|;
name|scan_start
operator|=
name|JUMP_LABEL
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If SCAN_START was an insn created by loop, we don't know its luid      as required by loop_reg_used_before_p.  So skip such loops.  (This      test may never be true, but it's best to play it safe.)        Also, skip loops where we do not start scanning at a label.  This      test also rejects loops starting with a JUMP_INSN that failed the      test above.  */
if|if
condition|(
name|INSN_UID
argument_list|(
name|scan_start
argument_list|)
operator|>=
name|max_uid_for_loop
operator|||
name|GET_CODE
argument_list|(
name|scan_start
argument_list|)
operator|!=
name|CODE_LABEL
condition|)
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"\nLoop from %d to %d is phony.\n\n"
argument_list|,
name|INSN_UID
argument_list|(
name|loop_start
argument_list|)
argument_list|,
name|INSN_UID
argument_list|(
name|end
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Count number of times each reg is set during this loop.      Set VARRAY_CHAR (may_not_optimize, I) if it is not safe to move out      the setting of register I.  Set VARRAY_RTX (reg_single_usage, I).  */
comment|/* Allocate extra space for REGS that might be created by      load_mems.  We allocate a little extra slop as well, in the hopes      that even after the moving of movables creates some new registers      we won't have to reallocate these arrays.  However, we do grow      the arrays, if necessary, in load_mems_recount_loop_regs_set.  */
name|nregs
operator|=
name|max_reg_num
argument_list|()
operator|+
name|loop_mems_idx
operator|+
literal|16
expr_stmt|;
name|VARRAY_INT_INIT
argument_list|(
name|set_in_loop
argument_list|,
name|nregs
argument_list|,
literal|"set_in_loop"
argument_list|)
expr_stmt|;
name|VARRAY_INT_INIT
argument_list|(
name|n_times_set
argument_list|,
name|nregs
argument_list|,
literal|"n_times_set"
argument_list|)
expr_stmt|;
name|VARRAY_CHAR_INIT
argument_list|(
name|may_not_optimize
argument_list|,
name|nregs
argument_list|,
literal|"may_not_optimize"
argument_list|)
expr_stmt|;
name|VARRAY_RTX_INIT
argument_list|(
name|reg_single_usage
argument_list|,
name|nregs
argument_list|,
literal|"reg_single_usage"
argument_list|)
expr_stmt|;
name|count_loop_regs_set
argument_list|(
name|loop_top
condition|?
name|loop_top
else|:
name|loop_start
argument_list|,
name|end
argument_list|,
name|may_not_optimize
argument_list|,
name|reg_single_usage
argument_list|,
operator|&
name|insn_count
argument_list|,
name|nregs
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
block|{
name|VARRAY_CHAR
argument_list|(
name|may_not_optimize
argument_list|,
name|i
argument_list|)
operator|=
literal|1
expr_stmt|;
name|VARRAY_INT
argument_list|(
name|set_in_loop
argument_list|,
name|i
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|AVOID_CCMODE_COPIES
comment|/* Don't try to move insns which set CC registers if we should not      create CCmode register copies.  */
for|for
control|(
name|i
operator|=
name|max_reg_num
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|regno_reg_rtx
index|[
name|i
index|]
argument_list|)
argument_list|)
operator|==
name|MODE_CC
condition|)
name|VARRAY_CHAR
argument_list|(
name|may_not_optimize
argument_list|,
name|i
argument_list|)
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|set_in_loop
operator|->
name|data
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|n_times_set
operator|->
name|data
argument_list|,
name|nregs
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|loop_dump_stream
condition|)
block|{
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"\nLoop from %d to %d: %d real insns.\n"
argument_list|,
name|INSN_UID
argument_list|(
name|loop_start
argument_list|)
argument_list|,
name|INSN_UID
argument_list|(
name|end
argument_list|)
argument_list|,
name|insn_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|loop_continue
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Continue at insn %d.\n"
argument_list|,
name|INSN_UID
argument_list|(
name|loop_continue
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Scan through the loop finding insns that are safe to move.      Set set_in_loop negative for the reg being set, so that      this reg will be considered invariant for subsequent insns.      We consider whether subsequent insns use the reg      in deciding whether it is worth actually moving.       MAYBE_NEVER is nonzero if we have passed a conditional jump insn      and therefore it is possible that the insns we are scanning      would never be executed.  At such times, we must make sure      that it is safe to execute the insn once instead of zero times.      When MAYBE_NEVER is 0, all insns will be executed at least once      so that is not a problem.  */
for|for
control|(
name|p
operator|=
name|next_insn_in_loop
argument_list|(
name|scan_start
argument_list|,
name|scan_start
argument_list|,
name|end
argument_list|,
name|loop_top
argument_list|)
init|;
name|p
operator|!=
name|NULL_RTX
condition|;
name|p
operator|=
name|next_insn_in_loop
argument_list|(
name|p
argument_list|,
name|scan_start
argument_list|,
name|end
argument_list|,
name|loop_top
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
argument_list|)
operator|==
literal|'i'
operator|&&
name|find_reg_note
argument_list|(
name|p
argument_list|,
name|REG_LIBCALL
argument_list|,
name|NULL_RTX
argument_list|)
condition|)
name|in_libcall
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
argument_list|)
operator|==
literal|'i'
operator|&&
name|find_reg_note
argument_list|(
name|p
argument_list|,
name|REG_RETVAL
argument_list|,
name|NULL_RTX
argument_list|)
condition|)
name|in_libcall
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|INSN
operator|&&
operator|(
name|set
operator|=
name|single_set
argument_list|(
name|p
argument_list|)
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
operator|!
name|VARRAY_CHAR
argument_list|(
name|may_not_optimize
argument_list|,
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|int
name|tem1
init|=
literal|0
decl_stmt|;
name|int
name|tem2
init|=
literal|0
decl_stmt|;
name|int
name|move_insn
init|=
literal|0
decl_stmt|;
name|rtx
name|src
init|=
name|SET_SRC
argument_list|(
name|set
argument_list|)
decl_stmt|;
name|rtx
name|dependencies
init|=
literal|0
decl_stmt|;
comment|/* Figure out what to use as a source of this insn.  If a REG_EQUIV 	     note is given or if a REG_EQUAL note with a constant operand is 	     specified, use it as the source and mark that we should move 	     this insn by calling emit_move_insn rather that duplicating the 	     insn.  	     Otherwise, only use the REG_EQUAL contents if a REG_RETVAL note 	     is present.  */
name|temp
operator|=
name|find_reg_note
argument_list|(
name|p
argument_list|,
name|REG_EQUIV
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
condition|)
name|src
operator|=
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
operator|,
name|move_insn
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|temp
operator|=
name|find_reg_note
argument_list|(
name|p
argument_list|,
name|REG_EQUAL
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|&&
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|src
operator|=
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
operator|,
name|move_insn
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|temp
operator|&&
name|find_reg_note
argument_list|(
name|p
argument_list|,
name|REG_RETVAL
argument_list|,
name|NULL_RTX
argument_list|)
condition|)
block|{
name|src
operator|=
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* A libcall block can use regs that don't appear in 		     the equivalent expression.  To move the libcall, 		     we must move those regs too.  */
name|dependencies
operator|=
name|libcall_other_reg
argument_list|(
name|p
argument_list|,
name|src
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Don't try to optimize a register that was made 	     by loop-optimization for an inner loop. 	     We don't know its life-span, so we can't compute the benefit.  */
if|if
condition|(
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|>=
name|max_reg_before_loop
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
comment|/* The register is used in basic blocks other 		      than the one where it is set (meaning that 		      something after this point in the loop might 		      depend on its value before the set).  */
operator|!
name|reg_in_basic_block_p
argument_list|(
name|p
argument_list|,
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
comment|/* And the set is not guaranteed to be executed one 		      the loop starts, or the value before the set is 		      needed before the set occurs...   		      ??? Note we have quadratic behaviour here, mitigated 		      by the fact that the previous test will often fail for 		      large loops.  Rather than re-scanning the entire loop 		      each time for register usage, we should build tables 		      of the register usage and use them here instead.  */
operator|&&
operator|(
name|maybe_never
operator|||
name|loop_reg_used_before_p
argument_list|(
name|set
argument_list|,
name|p
argument_list|,
name|loop_start
argument_list|,
name|scan_start
argument_list|,
name|end
argument_list|)
operator|)
condition|)
comment|/* It is unsafe to move the set.    	       This code used to consider it OK to move a set of a variable 	       which was not created by the user and not used in an exit test. 	       That behavior is incorrect and was removed.  */
empty_stmt|;
elseif|else
if|if
condition|(
operator|(
name|tem
operator|=
name|invariant_p
argument_list|(
name|src
argument_list|)
operator|)
operator|&&
operator|(
name|dependencies
operator|==
literal|0
operator|||
operator|(
name|tem2
operator|=
name|invariant_p
argument_list|(
name|dependencies
argument_list|)
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|VARRAY_INT
argument_list|(
name|set_in_loop
argument_list|,
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|1
operator|||
operator|(
name|tem1
operator|=
name|consec_sets_invariant_p
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|,
name|VARRAY_INT
argument_list|(
name|set_in_loop
argument_list|,
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|p
argument_list|)
operator|)
operator|)
comment|/* If the insn can cause a trap (such as divide by zero), 		      can't move it unless it's guaranteed to be executed 		      once loop is entered.  Even a function call might 		      prevent the trap insn from being reached 		      (since it might exit!)  */
operator|&&
operator|!
operator|(
operator|(
name|maybe_never
operator|||
name|call_passed
operator|)
operator|&&
name|may_trap_p
argument_list|(
name|src
argument_list|)
operator|)
condition|)
block|{
specifier|register
name|struct
name|movable
modifier|*
name|m
decl_stmt|;
specifier|register
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
decl_stmt|;
comment|/* A potential lossage is where we have a case where two insns 		 can be combined as long as they are both in the loop, but 		 we move one of them outside the loop.  For large loops, 		 this can lose.  The most common case of this is the address 		 of a function being called.    		 Therefore, if this register is marked as being used exactly 		 once if we are in a loop with calls (a "large loop"), see if 		 we can replace the usage of this register with the source 		 of this SET.  If we can, delete this insn.   		 Don't do this if P has a REG_RETVAL note or if we have 		 SMALL_REGISTER_CLASSES and SET_SRC is a hard register.  */
if|if
condition|(
name|loop_has_call
operator|&&
name|VARRAY_RTX
argument_list|(
name|reg_single_usage
argument_list|,
name|regno
argument_list|)
operator|!=
literal|0
operator|&&
name|VARRAY_RTX
argument_list|(
name|reg_single_usage
argument_list|,
name|regno
argument_list|)
operator|!=
name|const0_rtx
operator|&&
name|REGNO_FIRST_UID
argument_list|(
name|regno
argument_list|)
operator|==
name|INSN_UID
argument_list|(
name|p
argument_list|)
operator|&&
operator|(
name|REGNO_LAST_UID
argument_list|(
name|regno
argument_list|)
operator|==
name|INSN_UID
argument_list|(
name|VARRAY_RTX
argument_list|(
name|reg_single_usage
argument_list|,
name|regno
argument_list|)
argument_list|)
operator|)
operator|&&
name|VARRAY_INT
argument_list|(
name|set_in_loop
argument_list|,
name|regno
argument_list|)
operator|==
literal|1
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|&&
operator|!
name|find_reg_note
argument_list|(
name|p
argument_list|,
name|REG_RETVAL
argument_list|,
name|NULL_RTX
argument_list|)
operator|&&
operator|(
operator|!
name|SMALL_REGISTER_CLASSES
operator|||
operator|(
operator|!
operator|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|)
operator|)
operator|)
comment|/* This test is not redundant; SET_SRC (set) might be 		     a call-clobbered register and the life of REGNO 		     might span a call.  */
operator|&&
operator|!
name|modified_between_p
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
name|p
argument_list|,
name|VARRAY_RTX
argument_list|(
name|reg_single_usage
argument_list|,
name|regno
argument_list|)
argument_list|)
operator|&&
name|no_labels_between_p
argument_list|(
name|p
argument_list|,
name|VARRAY_RTX
argument_list|(
name|reg_single_usage
argument_list|,
name|regno
argument_list|)
argument_list|)
operator|&&
name|validate_replace_rtx
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|,
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
name|VARRAY_RTX
argument_list|(
name|reg_single_usage
argument_list|,
name|regno
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Replace any usage in a REG_EQUAL note.  Must copy the 		     new source, so that we don't get rtx sharing between the 		     SET_SOURCE and REG_NOTES of insn p.  */
name|REG_NOTES
argument_list|(
name|VARRAY_RTX
argument_list|(
name|reg_single_usage
argument_list|,
name|regno
argument_list|)
argument_list|)
operator|=
name|replace_rtx
argument_list|(
name|REG_NOTES
argument_list|(
name|VARRAY_RTX
argument_list|(
name|reg_single_usage
argument_list|,
name|regno
argument_list|)
argument_list|)
argument_list|,
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|,
name|copy_rtx
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|PUT_CODE
argument_list|(
name|p
argument_list|,
name|NOTE
argument_list|)
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|p
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|p
argument_list|)
operator|=
literal|0
expr_stmt|;
name|VARRAY_INT
argument_list|(
name|set_in_loop
argument_list|,
name|regno
argument_list|)
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
name|m
operator|=
operator|(
expr|struct
name|movable
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|movable
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|->
name|next
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|insn
operator|=
name|p
expr_stmt|;
name|m
operator|->
name|set_src
operator|=
name|src
expr_stmt|;
name|m
operator|->
name|dependencies
operator|=
name|dependencies
expr_stmt|;
name|m
operator|->
name|set_dest
operator|=
name|SET_DEST
argument_list|(
name|set
argument_list|)
expr_stmt|;
name|m
operator|->
name|force
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|consec
operator|=
name|VARRAY_INT
argument_list|(
name|set_in_loop
argument_list|,
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
argument_list|)
operator|-
literal|1
expr_stmt|;
name|m
operator|->
name|done
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|forces
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|partial
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|move_insn
operator|=
name|move_insn
expr_stmt|;
name|m
operator|->
name|move_insn_first
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|is_equiv
operator|=
operator|(
name|find_reg_note
argument_list|(
name|p
argument_list|,
name|REG_EQUIV
argument_list|,
name|NULL_RTX
argument_list|)
operator|!=
literal|0
operator|)
expr_stmt|;
name|m
operator|->
name|savemode
operator|=
name|VOIDmode
expr_stmt|;
name|m
operator|->
name|regno
operator|=
name|regno
expr_stmt|;
comment|/* Set M->cond if either invariant_p or consec_sets_invariant_p 		 returned 2 (only conditionally invariant).  */
name|m
operator|->
name|cond
operator|=
operator|(
operator|(
name|tem
operator||
name|tem1
operator||
name|tem2
operator|)
operator|>
literal|1
operator|)
expr_stmt|;
name|m
operator|->
name|global
operator|=
operator|(
name|uid_luid
index|[
name|REGNO_LAST_UID
argument_list|(
name|regno
argument_list|)
index|]
operator|>
name|INSN_LUID
argument_list|(
name|end
argument_list|)
operator|||
name|uid_luid
index|[
name|REGNO_FIRST_UID
argument_list|(
name|regno
argument_list|)
index|]
operator|<
name|INSN_LUID
argument_list|(
name|loop_start
argument_list|)
operator|)
expr_stmt|;
name|m
operator|->
name|match
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|lifetime
operator|=
operator|(
name|uid_luid
index|[
name|REGNO_LAST_UID
argument_list|(
name|regno
argument_list|)
index|]
operator|-
name|uid_luid
index|[
name|REGNO_FIRST_UID
argument_list|(
name|regno
argument_list|)
index|]
operator|)
expr_stmt|;
name|m
operator|->
name|savings
operator|=
name|VARRAY_INT
argument_list|(
name|n_times_set
argument_list|,
name|regno
argument_list|)
expr_stmt|;
if|if
condition|(
name|find_reg_note
argument_list|(
name|p
argument_list|,
name|REG_RETVAL
argument_list|,
name|NULL_RTX
argument_list|)
condition|)
name|m
operator|->
name|savings
operator|+=
name|libcall_benefit
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|VARRAY_INT
argument_list|(
name|set_in_loop
argument_list|,
name|regno
argument_list|)
operator|=
name|move_insn
condition|?
operator|-
literal|2
else|:
operator|-
literal|1
expr_stmt|;
comment|/* Add M to the end of the chain MOVABLES.  */
if|if
condition|(
name|movables
operator|==
literal|0
condition|)
name|movables
operator|=
name|m
expr_stmt|;
else|else
name|last_movable
operator|->
name|next
operator|=
name|m
expr_stmt|;
name|last_movable
operator|=
name|m
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|consec
operator|>
literal|0
condition|)
block|{
comment|/* It is possible for the first instruction to have a 		     REG_EQUAL note but a non-invariant SET_SRC, so we must 		     remember the status of the first instruction in case 		     the last instruction doesn't have a REG_EQUAL note.  */
name|m
operator|->
name|move_insn_first
operator|=
name|m
operator|->
name|move_insn
expr_stmt|;
comment|/* Skip this insn, not checking REG_LIBCALL notes.  */
name|p
operator|=
name|next_nonnote_insn
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* Skip the consecutive insns, if there are any.  */
name|p
operator|=
name|skip_consec_insns
argument_list|(
name|p
argument_list|,
name|m
operator|->
name|consec
argument_list|)
expr_stmt|;
comment|/* Back up to the last insn of the consecutive group.  */
name|p
operator|=
name|prev_nonnote_insn
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* We must now reset m->move_insn, m->is_equiv, and possibly 		     m->set_src to correspond to the effects of all the 		     insns.  */
name|temp
operator|=
name|find_reg_note
argument_list|(
name|p
argument_list|,
name|REG_EQUIV
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
condition|)
name|m
operator|->
name|set_src
operator|=
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
operator|,
name|m
operator|->
name|move_insn
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|temp
operator|=
name|find_reg_note
argument_list|(
name|p
argument_list|,
name|REG_EQUAL
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|&&
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|m
operator|->
name|set_src
operator|=
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
operator|,
name|m
operator|->
name|move_insn
operator|=
literal|1
expr_stmt|;
else|else
name|m
operator|->
name|move_insn
operator|=
literal|0
expr_stmt|;
block|}
name|m
operator|->
name|is_equiv
operator|=
operator|(
name|find_reg_note
argument_list|(
name|p
argument_list|,
name|REG_EQUIV
argument_list|,
name|NULL_RTX
argument_list|)
operator|!=
literal|0
operator|)
expr_stmt|;
block|}
block|}
comment|/* If this register is always set within a STRICT_LOW_PART 	     or set to zero, then its high bytes are constant. 	     So clear them outside the loop and within the loop 	     just load the low bytes. 	     We must check that the machine has an instruction to do so. 	     Also, if the value loaded into the register 	     depends on the same register, this cannot be done.  */
elseif|else
if|if
condition|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
operator|==
name|const0_rtx
operator|&&
name|GET_CODE
argument_list|(
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
argument_list|)
operator|==
name|INSN
operator|&&
operator|(
name|set1
operator|=
name|single_set
argument_list|(
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
argument_list|)
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|set1
argument_list|)
operator|==
name|SET
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set1
argument_list|)
argument_list|)
operator|==
name|STRICT_LOW_PART
operator|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|set1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|)
operator|&&
operator|(
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|set1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SET_DEST
argument_list|(
name|set
argument_list|)
operator|)
operator|&&
operator|!
name|reg_mentioned_p
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|,
name|SET_SRC
argument_list|(
name|set1
argument_list|)
argument_list|)
condition|)
block|{
specifier|register
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|VARRAY_INT
argument_list|(
name|set_in_loop
argument_list|,
name|regno
argument_list|)
operator|==
literal|2
condition|)
block|{
specifier|register
name|struct
name|movable
modifier|*
name|m
decl_stmt|;
name|m
operator|=
operator|(
expr|struct
name|movable
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|movable
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|->
name|next
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|insn
operator|=
name|p
expr_stmt|;
name|m
operator|->
name|set_dest
operator|=
name|SET_DEST
argument_list|(
name|set
argument_list|)
expr_stmt|;
name|m
operator|->
name|dependencies
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|force
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|consec
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|done
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|forces
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|move_insn
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|move_insn_first
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|partial
operator|=
literal|1
expr_stmt|;
comment|/* If the insn may not be executed on some cycles, 		     we can't clear the whole reg; clear just high part. 		     Not even if the reg is used only within this loop. 		     Consider this: 		     while (1) 		       while (s != t) { 		         if (foo ()) x = *s; 			 use (x); 		       } 		     Clearing x before the inner loop could clobber a value 		     being saved from the last time around the outer loop. 		     However, if the reg is not used outside this loop 		     and all uses of the register are in the same 		     basic block as the store, there is no problem.  		     If this insn was made by loop, we don't know its 		     INSN_LUID and hence must make a conservative 		     assumption.  */
name|m
operator|->
name|global
operator|=
operator|(
name|INSN_UID
argument_list|(
name|p
argument_list|)
operator|>=
name|max_uid_for_loop
operator|||
operator|(
name|uid_luid
index|[
name|REGNO_LAST_UID
argument_list|(
name|regno
argument_list|)
index|]
operator|>
name|INSN_LUID
argument_list|(
name|end
argument_list|)
operator|)
operator|||
operator|(
name|uid_luid
index|[
name|REGNO_FIRST_UID
argument_list|(
name|regno
argument_list|)
index|]
operator|<
name|INSN_LUID
argument_list|(
name|p
argument_list|)
operator|)
operator|||
operator|(
name|labels_in_range_p
argument_list|(
name|p
argument_list|,
name|uid_luid
index|[
name|REGNO_FIRST_UID
argument_list|(
name|regno
argument_list|)
index|]
argument_list|)
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|maybe_never
operator|&&
name|m
operator|->
name|global
condition|)
name|m
operator|->
name|savemode
operator|=
name|GET_MODE
argument_list|(
name|SET_SRC
argument_list|(
name|set1
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|m
operator|->
name|savemode
operator|=
name|VOIDmode
expr_stmt|;
name|m
operator|->
name|regno
operator|=
name|regno
expr_stmt|;
name|m
operator|->
name|cond
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|match
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|lifetime
operator|=
operator|(
name|uid_luid
index|[
name|REGNO_LAST_UID
argument_list|(
name|regno
argument_list|)
index|]
operator|-
name|uid_luid
index|[
name|REGNO_FIRST_UID
argument_list|(
name|regno
argument_list|)
index|]
operator|)
expr_stmt|;
name|m
operator|->
name|savings
operator|=
literal|1
expr_stmt|;
name|VARRAY_INT
argument_list|(
name|set_in_loop
argument_list|,
name|regno
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Add M to the end of the chain MOVABLES.  */
if|if
condition|(
name|movables
operator|==
literal|0
condition|)
name|movables
operator|=
name|m
expr_stmt|;
else|else
name|last_movable
operator|->
name|next
operator|=
name|m
expr_stmt|;
name|last_movable
operator|=
name|m
expr_stmt|;
block|}
block|}
block|}
comment|/* Past a call insn, we get to insns which might not be executed 	 because the call might exit.  This matters for insns that trap. 	 Call insns inside a REG_LIBCALL/REG_RETVAL block always return, 	 so they don't count.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|CALL_INSN
operator|&&
operator|!
name|in_libcall
condition|)
name|call_passed
operator|=
literal|1
expr_stmt|;
comment|/* Past a label or a jump, we get to insns for which we 	 can't count on whether or how many times they will be 	 executed during each iteration.  Therefore, we can 	 only move out sets of trivial variables 	 (those not used after the loop).  */
comment|/* Similar code appears twice in strength_reduce.  */
elseif|else
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|CODE_LABEL
operator|||
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|JUMP_INSN
operator|)
comment|/* If we enter the loop in the middle, and scan around to the 		  beginning, don't set maybe_never for that.  This must be an 		  unconditional jump, otherwise the code at the top of the 		  loop might never be executed.  Unconditional jumps are 		  followed a by barrier then loop end.  */
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|JUMP_LABEL
argument_list|(
name|p
argument_list|)
operator|==
name|loop_top
operator|&&
name|NEXT_INSN
argument_list|(
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
argument_list|)
operator|==
name|end
operator|&&
name|simplejump_p
argument_list|(
name|p
argument_list|)
operator|)
condition|)
name|maybe_never
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|NOTE
condition|)
block|{
comment|/* At the virtual top of a converted loop, insns are again known to 	     be executed: logically, the loop begins here even though the exit 	     code has been duplicated.  */
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|p
argument_list|)
operator|==
name|NOTE_INSN_LOOP_VTOP
operator|&&
name|loop_depth
operator|==
literal|0
condition|)
name|maybe_never
operator|=
name|call_passed
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|p
argument_list|)
operator|==
name|NOTE_INSN_LOOP_BEG
condition|)
name|loop_depth
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|p
argument_list|)
operator|==
name|NOTE_INSN_LOOP_END
condition|)
name|loop_depth
operator|--
expr_stmt|;
block|}
block|}
comment|/* If one movable subsumes another, ignore that other.  */
name|ignore_some_movables
argument_list|(
name|movables
argument_list|)
expr_stmt|;
comment|/* For each movable insn, see if the reg that it loads      leads when it dies right into another conditionally movable insn.      If so, record that the second insn "forces" the first one,      since the second can be moved only if the first is.  */
name|force_movables
argument_list|(
name|movables
argument_list|)
expr_stmt|;
comment|/* See if there are multiple movable insns that load the same value.      If there are, make all but the first point at the first one      through the `match' field, and add the priorities of them      all together as the priority of the first.  */
name|combine_movables
argument_list|(
name|movables
argument_list|,
name|nregs
argument_list|)
expr_stmt|;
comment|/* Now consider each movable insn to decide whether it is worth moving.      Store 0 in set_in_loop for each reg that is moved.       Generally this increases code size, so do not move moveables when      optimizing for code size.  */
if|if
condition|(
operator|!
name|optimize_size
condition|)
name|move_movables
argument_list|(
name|movables
argument_list|,
name|threshold
argument_list|,
name|insn_count
argument_list|,
name|loop_start
argument_list|,
name|end
argument_list|,
name|nregs
argument_list|)
expr_stmt|;
comment|/* Now candidates that still are negative are those not moved.      Change set_in_loop to indicate that those are not actually invariant.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nregs
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|VARRAY_INT
argument_list|(
name|set_in_loop
argument_list|,
name|i
argument_list|)
operator|<
literal|0
condition|)
name|VARRAY_INT
argument_list|(
name|set_in_loop
argument_list|,
name|i
argument_list|)
operator|=
name|VARRAY_INT
argument_list|(
name|n_times_set
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* Now that we've moved some things out of the loop, we might be able to      hoist even more memory references.  */
name|load_mems_and_recount_loop_regs_set
argument_list|(
name|scan_start
argument_list|,
name|end
argument_list|,
name|loop_top
argument_list|,
name|loop_start
argument_list|,
operator|&
name|insn_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_strength_reduce
condition|)
block|{
name|the_movables
operator|=
name|movables
expr_stmt|;
name|strength_reduce
argument_list|(
name|scan_start
argument_list|,
name|end
argument_list|,
name|loop_top
argument_list|,
name|insn_count
argument_list|,
name|loop_start
argument_list|,
name|end
argument_list|,
name|loop_cont
argument_list|,
name|unroll_p
argument_list|,
name|bct_p
argument_list|)
expr_stmt|;
block|}
name|VARRAY_FREE
argument_list|(
name|reg_single_usage
argument_list|)
expr_stmt|;
name|VARRAY_FREE
argument_list|(
name|set_in_loop
argument_list|)
expr_stmt|;
name|VARRAY_FREE
argument_list|(
name|n_times_set
argument_list|)
expr_stmt|;
name|VARRAY_FREE
argument_list|(
name|may_not_optimize
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Add elements to *OUTPUT to record all the pseudo-regs    mentioned in IN_THIS but not mentioned in NOT_IN_THIS.  */
end_comment

begin_function
name|void
name|record_excess_regs
parameter_list|(
name|in_this
parameter_list|,
name|not_in_this
parameter_list|,
name|output
parameter_list|)
name|rtx
name|in_this
decl_stmt|,
name|not_in_this
decl_stmt|;
name|rtx
modifier|*
name|output
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
decl_stmt|;
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|i
decl_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|in_this
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PC
case|:
case|case
name|CC0
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CONST
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
return|return;
case|case
name|REG
case|:
if|if
condition|(
name|REGNO
argument_list|(
name|in_this
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
operator|!
name|reg_mentioned_p
argument_list|(
name|in_this
argument_list|,
name|not_in_this
argument_list|)
condition|)
operator|*
name|output
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|in_this
argument_list|,
operator|*
name|output
argument_list|)
expr_stmt|;
return|return;
default|default:
break|break;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|int
name|j
decl_stmt|;
switch|switch
condition|(
name|fmt
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'E'
case|:
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|in_this
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|record_excess_regs
argument_list|(
name|XVECEXP
argument_list|(
name|in_this
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|not_in_this
argument_list|,
name|output
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|record_excess_regs
argument_list|(
name|XEXP
argument_list|(
name|in_this
argument_list|,
name|i
argument_list|)
argument_list|,
name|not_in_this
argument_list|,
name|output
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Check what regs are referred to in the libcall block ending with INSN,    aside from those mentioned in the equivalent value.    If there are none, return 0.    If there are one or more, return an EXPR_LIST containing all of them.  */
end_comment

begin_function
name|rtx
name|libcall_other_reg
parameter_list|(
name|insn
parameter_list|,
name|equiv
parameter_list|)
name|rtx
name|insn
decl_stmt|,
name|equiv
decl_stmt|;
block|{
name|rtx
name|note
init|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_RETVAL
argument_list|,
name|NULL_RTX
argument_list|)
decl_stmt|;
name|rtx
name|p
init|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|output
init|=
literal|0
decl_stmt|;
comment|/* First, find all the regs used in the libcall block      that are not mentioned as inputs to the result.  */
while|while
condition|(
name|p
operator|!=
name|insn
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|JUMP_INSN
operator|||
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|CALL_INSN
condition|)
name|record_excess_regs
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|,
name|equiv
argument_list|,
operator|&
name|output
argument_list|)
expr_stmt|;
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
return|return
name|output
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if all uses of REG    are between INSN and the end of the basic block.  */
end_comment

begin_function
specifier|static
name|int
name|reg_in_basic_block_p
parameter_list|(
name|insn
parameter_list|,
name|reg
parameter_list|)
name|rtx
name|insn
decl_stmt|,
name|reg
decl_stmt|;
block|{
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|reg
argument_list|)
decl_stmt|;
name|rtx
name|p
decl_stmt|;
if|if
condition|(
name|REGNO_FIRST_UID
argument_list|(
name|regno
argument_list|)
operator|!=
name|INSN_UID
argument_list|(
name|insn
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Search this basic block for the already recorded last use of the reg.  */
for|for
control|(
name|p
operator|=
name|insn
init|;
name|p
condition|;
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
control|)
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
condition|)
block|{
case|case
name|NOTE
case|:
break|break;
case|case
name|INSN
case|:
case|case
name|CALL_INSN
case|:
comment|/* Ordinary insn: if this is the last use, we win.  */
if|if
condition|(
name|REGNO_LAST_UID
argument_list|(
name|regno
argument_list|)
operator|==
name|INSN_UID
argument_list|(
name|p
argument_list|)
condition|)
return|return
literal|1
return|;
break|break;
case|case
name|JUMP_INSN
case|:
comment|/* Jump insn: if this is the last use, we win.  */
if|if
condition|(
name|REGNO_LAST_UID
argument_list|(
name|regno
argument_list|)
operator|==
name|INSN_UID
argument_list|(
name|p
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Otherwise, it's the end of the basic block, so we lose.  */
return|return
literal|0
return|;
case|case
name|CODE_LABEL
case|:
case|case
name|BARRIER
case|:
comment|/* It's the end of the basic block, so we lose.  */
return|return
literal|0
return|;
default|default:
break|break;
block|}
block|}
comment|/* The "last use" doesn't follow the "first use"??  */
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Compute the benefit of eliminating the insns in the block whose    last insn is LAST.  This may be a group of insns used to compute a    value directly or can contain a library call.  */
end_comment

begin_function
specifier|static
name|int
name|libcall_benefit
parameter_list|(
name|last
parameter_list|)
name|rtx
name|last
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|;
name|int
name|benefit
init|=
literal|0
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|XEXP
argument_list|(
name|find_reg_note
argument_list|(
name|last
argument_list|,
name|REG_RETVAL
argument_list|,
name|NULL_RTX
argument_list|)
argument_list|,
literal|0
argument_list|)
init|;
name|insn
operator|!=
name|last
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
name|benefit
operator|+=
literal|10
expr_stmt|;
comment|/* Assume at least this many insns in a library 				   routine.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|USE
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|CLOBBER
condition|)
name|benefit
operator|++
expr_stmt|;
block|}
return|return
name|benefit
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Skip COUNT insns from INSN, counting library calls as 1 insn.  */
end_comment

begin_function
specifier|static
name|rtx
name|skip_consec_insns
parameter_list|(
name|insn
parameter_list|,
name|count
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|int
name|count
decl_stmt|;
block|{
for|for
control|(
init|;
name|count
operator|>
literal|0
condition|;
name|count
operator|--
control|)
block|{
name|rtx
name|temp
decl_stmt|;
comment|/* If first insn of libcall sequence, skip to end.  */
comment|/* Do this at start of loop, since INSN is guaranteed to  	 be an insn here.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE
operator|&&
operator|(
name|temp
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_LIBCALL
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
condition|)
name|insn
operator|=
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
do|do
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
do|while
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
do|;
block|}
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Ignore any movable whose insn falls within a libcall    which is part of another movable.    We make use of the fact that the movable for the libcall value    was made later and so appears later on the chain.  */
end_comment

begin_function
specifier|static
name|void
name|ignore_some_movables
parameter_list|(
name|movables
parameter_list|)
name|struct
name|movable
modifier|*
name|movables
decl_stmt|;
block|{
specifier|register
name|struct
name|movable
modifier|*
name|m
decl_stmt|,
modifier|*
name|m1
decl_stmt|;
for|for
control|(
name|m
operator|=
name|movables
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|next
control|)
block|{
comment|/* Is this a movable for the value of a libcall?  */
name|rtx
name|note
init|=
name|find_reg_note
argument_list|(
name|m
operator|->
name|insn
argument_list|,
name|REG_RETVAL
argument_list|,
name|NULL_RTX
argument_list|)
decl_stmt|;
if|if
condition|(
name|note
condition|)
block|{
name|rtx
name|insn
decl_stmt|;
comment|/* Check for earlier movables inside that range, 	     and mark them invalid.  We cannot use LUIDs here because 	     insns created by loop.c for prior loops don't have LUIDs. 	     Rather than reject all such insns from movables, we just 	     explicitly check each insn in the libcall (since invariant 	     libcalls aren't that common).  */
for|for
control|(
name|insn
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
init|;
name|insn
operator|!=
name|m
operator|->
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
for|for
control|(
name|m1
operator|=
name|movables
init|;
name|m1
operator|!=
name|m
condition|;
name|m1
operator|=
name|m1
operator|->
name|next
control|)
if|if
condition|(
name|m1
operator|->
name|insn
operator|==
name|insn
condition|)
name|m1
operator|->
name|done
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* For each movable insn, see if the reg that it loads    leads when it dies right into another conditionally movable insn.    If so, record that the second insn "forces" the first one,    since the second can be moved only if the first is.  */
end_comment

begin_function
specifier|static
name|void
name|force_movables
parameter_list|(
name|movables
parameter_list|)
name|struct
name|movable
modifier|*
name|movables
decl_stmt|;
block|{
specifier|register
name|struct
name|movable
modifier|*
name|m
decl_stmt|,
modifier|*
name|m1
decl_stmt|;
for|for
control|(
name|m1
operator|=
name|movables
init|;
name|m1
condition|;
name|m1
operator|=
name|m1
operator|->
name|next
control|)
comment|/* Omit this if moving just the (SET (REG) 0) of a zero-extend.  */
if|if
condition|(
operator|!
name|m1
operator|->
name|partial
operator|&&
operator|!
name|m1
operator|->
name|done
condition|)
block|{
name|int
name|regno
init|=
name|m1
operator|->
name|regno
decl_stmt|;
for|for
control|(
name|m
operator|=
name|m1
operator|->
name|next
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|next
control|)
comment|/* ??? Could this be a bug?  What if CSE caused the 	     register of M1 to be used after this insn? 	     Since CSE does not update regno_last_uid, 	     this insn M->insn might not be where it dies. 	     But very likely this doesn't matter; what matters is 	     that M's reg is computed from M1's reg.  */
if|if
condition|(
name|INSN_UID
argument_list|(
name|m
operator|->
name|insn
argument_list|)
operator|==
name|REGNO_LAST_UID
argument_list|(
name|regno
argument_list|)
operator|&&
operator|!
name|m
operator|->
name|done
condition|)
break|break;
if|if
condition|(
name|m
operator|!=
literal|0
operator|&&
name|m
operator|->
name|set_src
operator|==
name|m1
operator|->
name|set_dest
comment|/* If m->consec, m->set_src isn't valid.  */
operator|&&
name|m
operator|->
name|consec
operator|==
literal|0
condition|)
name|m
operator|=
literal|0
expr_stmt|;
comment|/* Increase the priority of the moving the first insn 	   since it permits the second to be moved as well.  */
if|if
condition|(
name|m
operator|!=
literal|0
condition|)
block|{
name|m
operator|->
name|forces
operator|=
name|m1
expr_stmt|;
name|m1
operator|->
name|lifetime
operator|+=
name|m
operator|->
name|lifetime
expr_stmt|;
name|m1
operator|->
name|savings
operator|+=
name|m
operator|->
name|savings
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Find invariant expressions that are equal and can be combined into    one register.  */
end_comment

begin_function
specifier|static
name|void
name|combine_movables
parameter_list|(
name|movables
parameter_list|,
name|nregs
parameter_list|)
name|struct
name|movable
modifier|*
name|movables
decl_stmt|;
name|int
name|nregs
decl_stmt|;
block|{
specifier|register
name|struct
name|movable
modifier|*
name|m
decl_stmt|;
name|char
modifier|*
name|matched_regs
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|nregs
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
comment|/* Regs that are set more than once are not allowed to match      or be matched.  I'm no longer sure why not.  */
comment|/* Perhaps testing m->consec_sets would be more appropriate here?  */
for|for
control|(
name|m
operator|=
name|movables
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|next
control|)
if|if
condition|(
name|m
operator|->
name|match
operator|==
literal|0
operator|&&
name|VARRAY_INT
argument_list|(
name|n_times_set
argument_list|,
name|m
operator|->
name|regno
argument_list|)
operator|==
literal|1
operator|&&
operator|!
name|m
operator|->
name|partial
condition|)
block|{
specifier|register
name|struct
name|movable
modifier|*
name|m1
decl_stmt|;
name|int
name|regno
init|=
name|m
operator|->
name|regno
decl_stmt|;
name|bzero
argument_list|(
name|matched_regs
argument_list|,
name|nregs
argument_list|)
expr_stmt|;
name|matched_regs
index|[
name|regno
index|]
operator|=
literal|1
expr_stmt|;
comment|/* We want later insns to match the first one.  Don't make the first 	   one match any later ones.  So start this loop at m->next.  */
for|for
control|(
name|m1
operator|=
name|m
operator|->
name|next
init|;
name|m1
condition|;
name|m1
operator|=
name|m1
operator|->
name|next
control|)
if|if
condition|(
name|m
operator|!=
name|m1
operator|&&
name|m1
operator|->
name|match
operator|==
literal|0
operator|&&
name|VARRAY_INT
argument_list|(
name|n_times_set
argument_list|,
name|m1
operator|->
name|regno
argument_list|)
operator|==
literal|1
comment|/* A reg used outside the loop mustn't be eliminated.  */
operator|&&
operator|!
name|m1
operator|->
name|global
comment|/* A reg used for zero-extending mustn't be eliminated.  */
operator|&&
operator|!
name|m1
operator|->
name|partial
operator|&&
operator|(
name|matched_regs
index|[
name|m1
operator|->
name|regno
index|]
operator|||
operator|(
comment|/* Can combine regs with different modes loaded from the 		      same constant only if the modes are the same or 		      if both are integer modes with M wider or the same 		      width as M1.  The check for integer is redundant, but 		      safe, since the only case of differing destination 		      modes with equal sources is when both sources are 		      VOIDmode, i.e., CONST_INT.  */
operator|(
name|GET_MODE
argument_list|(
name|m
operator|->
name|set_dest
argument_list|)
operator|==
name|GET_MODE
argument_list|(
name|m1
operator|->
name|set_dest
argument_list|)
operator|||
operator|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|m
operator|->
name|set_dest
argument_list|)
argument_list|)
operator|==
name|MODE_INT
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|m1
operator|->
name|set_dest
argument_list|)
argument_list|)
operator|==
name|MODE_INT
operator|&&
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|m
operator|->
name|set_dest
argument_list|)
argument_list|)
operator|>=
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|m1
operator|->
name|set_dest
argument_list|)
argument_list|)
operator|)
operator|)
operator|)
comment|/* See if the source of M1 says it matches M.  */
operator|&&
operator|(
operator|(
name|GET_CODE
argument_list|(
name|m1
operator|->
name|set_src
argument_list|)
operator|==
name|REG
operator|&&
name|matched_regs
index|[
name|REGNO
argument_list|(
name|m1
operator|->
name|set_src
argument_list|)
index|]
operator|)
operator|||
name|rtx_equal_for_loop_p
argument_list|(
name|m
operator|->
name|set_src
argument_list|,
name|m1
operator|->
name|set_src
argument_list|,
name|movables
argument_list|)
operator|)
operator|)
operator|)
operator|&&
operator|(
operator|(
name|m
operator|->
name|dependencies
operator|==
name|m1
operator|->
name|dependencies
operator|)
operator|||
name|rtx_equal_p
argument_list|(
name|m
operator|->
name|dependencies
argument_list|,
name|m1
operator|->
name|dependencies
argument_list|)
operator|)
condition|)
block|{
name|m
operator|->
name|lifetime
operator|+=
name|m1
operator|->
name|lifetime
expr_stmt|;
name|m
operator|->
name|savings
operator|+=
name|m1
operator|->
name|savings
expr_stmt|;
name|m1
operator|->
name|done
operator|=
literal|1
expr_stmt|;
name|m1
operator|->
name|match
operator|=
name|m
expr_stmt|;
name|matched_regs
index|[
name|m1
operator|->
name|regno
index|]
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* Now combine the regs used for zero-extension.      This can be done for those not marked `global'      provided their lives don't overlap.  */
for|for
control|(
name|mode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_INT
argument_list|)
init|;
name|mode
operator|!=
name|VOIDmode
condition|;
name|mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
control|)
block|{
specifier|register
name|struct
name|movable
modifier|*
name|m0
init|=
literal|0
decl_stmt|;
comment|/* Combine all the registers for extension from mode MODE. 	 Don't combine any that are used outside this loop.  */
for|for
control|(
name|m
operator|=
name|movables
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|next
control|)
if|if
condition|(
name|m
operator|->
name|partial
operator|&&
operator|!
name|m
operator|->
name|global
operator|&&
name|mode
operator|==
name|GET_MODE
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|NEXT_INSN
argument_list|(
name|m
operator|->
name|insn
argument_list|)
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
specifier|register
name|struct
name|movable
modifier|*
name|m1
decl_stmt|;
name|int
name|first
init|=
name|uid_luid
index|[
name|REGNO_FIRST_UID
argument_list|(
name|m
operator|->
name|regno
argument_list|)
index|]
decl_stmt|;
name|int
name|last
init|=
name|uid_luid
index|[
name|REGNO_LAST_UID
argument_list|(
name|m
operator|->
name|regno
argument_list|)
index|]
decl_stmt|;
if|if
condition|(
name|m0
operator|==
literal|0
condition|)
block|{
comment|/* First one: don't check for overlap, just record it.  */
name|m0
operator|=
name|m
expr_stmt|;
continue|continue;
block|}
comment|/* Make sure they extend to the same mode. 	       (Almost always true.)  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|m
operator|->
name|set_dest
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|m0
operator|->
name|set_dest
argument_list|)
condition|)
continue|continue;
comment|/* We already have one: check for overlap with those 	       already combined together.  */
for|for
control|(
name|m1
operator|=
name|movables
init|;
name|m1
operator|!=
name|m
condition|;
name|m1
operator|=
name|m1
operator|->
name|next
control|)
if|if
condition|(
name|m1
operator|==
name|m0
operator|||
operator|(
name|m1
operator|->
name|partial
operator|&&
name|m1
operator|->
name|match
operator|==
name|m0
operator|)
condition|)
if|if
condition|(
operator|!
operator|(
name|uid_luid
index|[
name|REGNO_FIRST_UID
argument_list|(
name|m1
operator|->
name|regno
argument_list|)
index|]
operator|>
name|last
operator|||
name|uid_luid
index|[
name|REGNO_LAST_UID
argument_list|(
name|m1
operator|->
name|regno
argument_list|)
index|]
operator|<
name|first
operator|)
condition|)
goto|goto
name|overlap
goto|;
comment|/* No overlap: we can combine this with the others.  */
name|m0
operator|->
name|lifetime
operator|+=
name|m
operator|->
name|lifetime
expr_stmt|;
name|m0
operator|->
name|savings
operator|+=
name|m
operator|->
name|savings
expr_stmt|;
name|m
operator|->
name|done
operator|=
literal|1
expr_stmt|;
name|m
operator|->
name|match
operator|=
name|m0
expr_stmt|;
name|overlap
label|:
empty_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if regs X and Y will become the same if moved.  */
end_comment

begin_function
specifier|static
name|int
name|regs_match_p
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|movables
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|y
decl_stmt|;
name|struct
name|movable
modifier|*
name|movables
decl_stmt|;
block|{
name|int
name|xn
init|=
name|REGNO
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|int
name|yn
init|=
name|REGNO
argument_list|(
name|y
argument_list|)
decl_stmt|;
name|struct
name|movable
modifier|*
name|mx
decl_stmt|,
modifier|*
name|my
decl_stmt|;
for|for
control|(
name|mx
operator|=
name|movables
init|;
name|mx
condition|;
name|mx
operator|=
name|mx
operator|->
name|next
control|)
if|if
condition|(
name|mx
operator|->
name|regno
operator|==
name|xn
condition|)
break|break;
for|for
control|(
name|my
operator|=
name|movables
init|;
name|my
condition|;
name|my
operator|=
name|my
operator|->
name|next
control|)
if|if
condition|(
name|my
operator|->
name|regno
operator|==
name|yn
condition|)
break|break;
return|return
operator|(
name|mx
operator|&&
name|my
operator|&&
operator|(
operator|(
name|mx
operator|->
name|match
operator|==
name|my
operator|->
name|match
operator|&&
name|mx
operator|->
name|match
operator|!=
literal|0
operator|)
operator|||
name|mx
operator|->
name|match
operator|==
name|my
operator|||
name|mx
operator|==
name|my
operator|->
name|match
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if X and Y are identical-looking rtx's.    This is the Lisp function EQUAL for rtx arguments.     If two registers are matching movables or a movable register and an    equivalent constant, consider them equal.  */
end_comment

begin_function
specifier|static
name|int
name|rtx_equal_for_loop_p
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|movables
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|y
decl_stmt|;
name|struct
name|movable
modifier|*
name|movables
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
specifier|register
name|struct
name|movable
modifier|*
name|m
decl_stmt|;
specifier|register
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|x
operator|==
name|y
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|x
operator|==
literal|0
operator|||
name|y
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* If we have a register and a constant, they may sometimes be      equal.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
operator|&&
name|VARRAY_INT
argument_list|(
name|set_in_loop
argument_list|,
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
operator|-
literal|2
operator|&&
name|CONSTANT_P
argument_list|(
name|y
argument_list|)
condition|)
block|{
for|for
control|(
name|m
operator|=
name|movables
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|next
control|)
if|if
condition|(
name|m
operator|->
name|move_insn
operator|&&
name|m
operator|->
name|regno
operator|==
name|REGNO
argument_list|(
name|x
argument_list|)
operator|&&
name|rtx_equal_p
argument_list|(
name|m
operator|->
name|set_src
argument_list|,
name|y
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|REG
operator|&&
name|VARRAY_INT
argument_list|(
name|set_in_loop
argument_list|,
name|REGNO
argument_list|(
name|y
argument_list|)
argument_list|)
operator|==
operator|-
literal|2
operator|&&
name|CONSTANT_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
for|for
control|(
name|m
operator|=
name|movables
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|next
control|)
if|if
condition|(
name|m
operator|->
name|move_insn
operator|&&
name|m
operator|->
name|regno
operator|==
name|REGNO
argument_list|(
name|y
argument_list|)
operator|&&
name|rtx_equal_p
argument_list|(
name|m
operator|->
name|set_src
argument_list|,
name|x
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
comment|/* Otherwise, rtx's of different codes cannot be equal.  */
if|if
condition|(
name|code
operator|!=
name|GET_CODE
argument_list|(
name|y
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* (MULT:SI x y) and (MULT:HI x y) are NOT equivalent.      (REG:SI x) and (REG:HI x) are NOT equivalent.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|y
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* These three types of rtx's can be compared nonrecursively.  */
if|if
condition|(
name|code
operator|==
name|REG
condition|)
return|return
operator|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|==
name|REGNO
argument_list|(
name|y
argument_list|)
operator|||
name|regs_match_p
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|movables
argument_list|)
operator|)
return|;
if|if
condition|(
name|code
operator|==
name|LABEL_REF
condition|)
return|return
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|SYMBOL_REF
condition|)
return|return
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|XSTR
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
return|;
comment|/* Compare the elements.  If any pair of corresponding elements      fail to match, return 0 for the whole things.  */
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
switch|switch
condition|(
name|fmt
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'w'
case|:
if|if
condition|(
name|XWINT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
name|XWINT
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'i'
case|:
if|if
condition|(
name|XINT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
name|XINT
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'E'
case|:
comment|/* Two vectors must have the same length.  */
if|if
condition|(
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
name|XVECLEN
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* And the corresponding elements must match.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|rtx_equal_for_loop_p
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|XVECEXP
argument_list|(
name|y
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|movables
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'e'
case|:
if|if
condition|(
name|rtx_equal_for_loop_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
argument_list|,
name|movables
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'s'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|XSTR
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|XSTR
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'u'
case|:
comment|/* These are just backpointers, so they don't matter.  */
break|break;
case|case
literal|'0'
case|:
break|break;
comment|/* It is believed that rtx's at this level will never 	     contain anything but integers and other rtx's, 	     except for within LABEL_REFs and SYMBOL_REFs.  */
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If X contains any LABEL_REF's, add REG_LABEL notes for them to all   insns in INSNS which use thet reference.  */
end_comment

begin_function
specifier|static
name|void
name|add_label_notes
parameter_list|(
name|x
parameter_list|,
name|insns
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|rtx
name|insns
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|char
modifier|*
name|fmt
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|LABEL_REF
operator|&&
operator|!
name|LABEL_REF_NONLOCAL_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
comment|/* This code used to ignore labels that referred to dispatch tables to          avoid flow generating (slighly) worse code.           We no longer ignore such label references (see LABEL_REF handling in          mark_jump_label for additional information).  */
for|for
control|(
name|insn
operator|=
name|insns
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|reg_mentioned_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn
argument_list|)
condition|)
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_LABEL
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|add_label_notes
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|insns
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
name|add_label_notes
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|insns
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Scan MOVABLES, and move the insns that deserve to be moved.    If two matching movables are combined, replace one reg with the    other throughout.  */
end_comment

begin_function
specifier|static
name|void
name|move_movables
parameter_list|(
name|movables
parameter_list|,
name|threshold
parameter_list|,
name|insn_count
parameter_list|,
name|loop_start
parameter_list|,
name|end
parameter_list|,
name|nregs
parameter_list|)
name|struct
name|movable
modifier|*
name|movables
decl_stmt|;
name|int
name|threshold
decl_stmt|;
name|int
name|insn_count
decl_stmt|;
name|rtx
name|loop_start
decl_stmt|;
name|rtx
name|end
decl_stmt|;
name|int
name|nregs
decl_stmt|;
block|{
name|rtx
name|new_start
init|=
literal|0
decl_stmt|;
specifier|register
name|struct
name|movable
modifier|*
name|m
decl_stmt|;
specifier|register
name|rtx
name|p
decl_stmt|;
comment|/* Map of pseudo-register replacements to handle combining      when we move several insns that load the same value      into different pseudo-registers.  */
name|rtx
modifier|*
name|reg_map
init|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|nregs
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
decl_stmt|;
name|char
modifier|*
name|already_moved
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|nregs
argument_list|)
decl_stmt|;
name|bzero
argument_list|(
name|already_moved
argument_list|,
name|nregs
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|reg_map
argument_list|,
name|nregs
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|num_movables
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|m
operator|=
name|movables
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|next
control|)
block|{
comment|/* Describe this movable insn.  */
if|if
condition|(
name|loop_dump_stream
condition|)
block|{
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Insn %d: regno %d (life %d), "
argument_list|,
name|INSN_UID
argument_list|(
name|m
operator|->
name|insn
argument_list|)
argument_list|,
name|m
operator|->
name|regno
argument_list|,
name|m
operator|->
name|lifetime
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|consec
operator|>
literal|0
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"consec %d, "
argument_list|,
name|m
operator|->
name|consec
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|cond
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"cond "
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|force
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"force "
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|global
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"global "
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|done
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"done "
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|move_insn
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"move-insn "
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|match
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"matches %d "
argument_list|,
name|INSN_UID
argument_list|(
name|m
operator|->
name|match
operator|->
name|insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|forces
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"forces %d "
argument_list|,
name|INSN_UID
argument_list|(
name|m
operator|->
name|forces
operator|->
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Count movables.  Value used in heuristics in strength_reduce.  */
name|num_movables
operator|++
expr_stmt|;
comment|/* Ignore the insn if it's already done (it matched something else). 	 Otherwise, see if it is now safe to move.  */
if|if
condition|(
operator|!
name|m
operator|->
name|done
operator|&&
operator|(
operator|!
name|m
operator|->
name|cond
operator|||
operator|(
literal|1
operator|==
name|invariant_p
argument_list|(
name|m
operator|->
name|set_src
argument_list|)
operator|&&
operator|(
name|m
operator|->
name|dependencies
operator|==
literal|0
operator|||
literal|1
operator|==
name|invariant_p
argument_list|(
name|m
operator|->
name|dependencies
argument_list|)
operator|)
operator|&&
operator|(
name|m
operator|->
name|consec
operator|==
literal|0
operator|||
literal|1
operator|==
name|consec_sets_invariant_p
argument_list|(
name|m
operator|->
name|set_dest
argument_list|,
name|m
operator|->
name|consec
operator|+
literal|1
argument_list|,
name|m
operator|->
name|insn
argument_list|)
operator|)
operator|)
operator|)
operator|&&
operator|(
operator|!
name|m
operator|->
name|forces
operator|||
name|m
operator|->
name|forces
operator|->
name|done
operator|)
condition|)
block|{
specifier|register
name|int
name|regno
decl_stmt|;
specifier|register
name|rtx
name|p
decl_stmt|;
name|int
name|savings
init|=
name|m
operator|->
name|savings
decl_stmt|;
comment|/* We have an insn that is safe to move. 	     Compute its desirability.  */
name|p
operator|=
name|m
operator|->
name|insn
expr_stmt|;
name|regno
operator|=
name|m
operator|->
name|regno
expr_stmt|;
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"savings %d "
argument_list|,
name|savings
argument_list|)
expr_stmt|;
if|if
condition|(
name|moved_once
index|[
name|regno
index|]
operator|&&
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"halved since already moved "
argument_list|)
expr_stmt|;
comment|/* An insn MUST be moved if we already moved something else 	     which is safe only if this one is moved too: that is, 	     if already_moved[REGNO] is nonzero.  */
comment|/* An insn is desirable to move if the new lifetime of the 	     register is no more than THRESHOLD times the old lifetime. 	     If it's not desirable, it means the loop is so big 	     that moving won't speed things up much, 	     and it is liable to make register usage worse.  */
comment|/* It is also desirable to move if it can be moved at no 	     extra cost because something else was already moved.  */
if|if
condition|(
name|already_moved
index|[
name|regno
index|]
operator|||
name|flag_move_all_movables
operator|||
operator|(
name|threshold
operator|*
name|savings
operator|*
name|m
operator|->
name|lifetime
operator|)
operator|>=
operator|(
name|moved_once
index|[
name|regno
index|]
condition|?
name|insn_count
operator|*
literal|2
else|:
name|insn_count
operator|)
operator|||
operator|(
name|m
operator|->
name|forces
operator|&&
name|m
operator|->
name|forces
operator|->
name|done
operator|&&
name|VARRAY_INT
argument_list|(
name|n_times_set
argument_list|,
name|m
operator|->
name|forces
operator|->
name|regno
argument_list|)
operator|==
literal|1
operator|)
condition|)
block|{
name|int
name|count
decl_stmt|;
specifier|register
name|struct
name|movable
modifier|*
name|m1
decl_stmt|;
name|rtx
name|first
decl_stmt|;
comment|/* Now move the insns that set the reg.  */
if|if
condition|(
name|m
operator|->
name|partial
operator|&&
name|m
operator|->
name|match
condition|)
block|{
name|rtx
name|newpat
decl_stmt|,
name|i1
decl_stmt|;
name|rtx
name|r1
decl_stmt|,
name|r2
decl_stmt|;
comment|/* Find the end of this chain of matching regs. 		     Thus, we load each reg in the chain from that one reg. 		     And that reg is loaded with 0 directly, 		     since it has ->match == 0.  */
for|for
control|(
name|m1
operator|=
name|m
init|;
name|m1
operator|->
name|match
condition|;
name|m1
operator|=
name|m1
operator|->
name|match
control|)
empty_stmt|;
name|newpat
operator|=
name|gen_move_insn
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|m
operator|->
name|insn
argument_list|)
argument_list|)
argument_list|,
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|m1
operator|->
name|insn
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|i1
operator|=
name|emit_insn_before
argument_list|(
name|newpat
argument_list|,
name|loop_start
argument_list|)
expr_stmt|;
comment|/* Mark the moved, invariant reg as being allowed to 		     share a hard reg with the other matching invariant.  */
name|REG_NOTES
argument_list|(
name|i1
argument_list|)
operator|=
name|REG_NOTES
argument_list|(
name|m
operator|->
name|insn
argument_list|)
expr_stmt|;
name|r1
operator|=
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|m
operator|->
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|r2
operator|=
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|m1
operator|->
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|regs_may_share
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|r1
argument_list|,
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|r2
argument_list|,
name|regs_may_share
argument_list|)
argument_list|)
expr_stmt|;
name|delete_insn
argument_list|(
name|m
operator|->
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_start
operator|==
literal|0
condition|)
name|new_start
operator|=
name|i1
expr_stmt|;
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|" moved to %d"
argument_list|,
name|INSN_UID
argument_list|(
name|i1
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If we are to re-generate the item being moved with a 		 new move insn, first delete what we have and then emit 		 the move insn before the loop.  */
elseif|else
if|if
condition|(
name|m
operator|->
name|move_insn
condition|)
block|{
name|rtx
name|i1
decl_stmt|,
name|temp
decl_stmt|;
for|for
control|(
name|count
operator|=
name|m
operator|->
name|consec
init|;
name|count
operator|>=
literal|0
condition|;
name|count
operator|--
control|)
block|{
comment|/* If this is the first insn of a library call sequence, 			 skip to the end.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|!=
name|NOTE
operator|&&
operator|(
name|temp
operator|=
name|find_reg_note
argument_list|(
name|p
argument_list|,
name|REG_LIBCALL
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
condition|)
name|p
operator|=
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If this is the last insn of a libcall sequence, then 			 delete every insn in the sequence except the last. 			 The last insn is handled in the normal manner.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|!=
name|NOTE
operator|&&
operator|(
name|temp
operator|=
name|find_reg_note
argument_list|(
name|p
argument_list|,
name|REG_RETVAL
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
condition|)
block|{
name|temp
operator|=
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|temp
operator|!=
name|p
condition|)
name|temp
operator|=
name|delete_insn
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
name|temp
operator|=
name|p
expr_stmt|;
name|p
operator|=
name|delete_insn
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* simplify_giv_expr expects that it can walk the insns 			 at m->insn forwards and see this old sequence we are 			 tossing here.  delete_insn does preserve the next 			 pointers, but when we skip over a NOTE we must fix 			 it up.  Otherwise that code walks into the non-deleted 			 insn stream.  */
while|while
condition|(
name|p
operator|&&
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|NOTE
condition|)
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|temp
argument_list|)
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|start_sequence
argument_list|()
expr_stmt|;
name|emit_move_insn
argument_list|(
name|m
operator|->
name|set_dest
argument_list|,
name|m
operator|->
name|set_src
argument_list|)
expr_stmt|;
name|temp
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|add_label_notes
argument_list|(
name|m
operator|->
name|set_src
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|i1
operator|=
name|emit_insns_before
argument_list|(
name|temp
argument_list|,
name|loop_start
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|find_reg_note
argument_list|(
name|i1
argument_list|,
name|REG_EQUAL
argument_list|,
name|NULL_RTX
argument_list|)
condition|)
name|REG_NOTES
argument_list|(
name|i1
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|m
operator|->
name|is_equiv
condition|?
name|REG_EQUIV
else|:
name|REG_EQUAL
argument_list|,
name|m
operator|->
name|set_src
argument_list|,
name|REG_NOTES
argument_list|(
name|i1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|" moved to %d"
argument_list|,
name|INSN_UID
argument_list|(
name|i1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The more regs we move, the less we like moving them.  */
name|threshold
operator|-=
literal|3
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|count
operator|=
name|m
operator|->
name|consec
init|;
name|count
operator|>=
literal|0
condition|;
name|count
operator|--
control|)
block|{
name|rtx
name|i1
decl_stmt|,
name|temp
decl_stmt|;
comment|/* If first insn of libcall sequence, skip to end.  */
comment|/* Do this at start of loop, since p is guaranteed to  			 be an insn here.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|!=
name|NOTE
operator|&&
operator|(
name|temp
operator|=
name|find_reg_note
argument_list|(
name|p
argument_list|,
name|REG_LIBCALL
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
condition|)
name|p
operator|=
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If last insn of libcall sequence, move all 			 insns except the last before the loop.  The last 			 insn is handled in the normal manner.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|!=
name|NOTE
operator|&&
operator|(
name|temp
operator|=
name|find_reg_note
argument_list|(
name|p
argument_list|,
name|REG_RETVAL
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
condition|)
block|{
name|rtx
name|fn_address
init|=
literal|0
decl_stmt|;
name|rtx
name|fn_reg
init|=
literal|0
decl_stmt|;
name|rtx
name|fn_address_insn
init|=
literal|0
decl_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|temp
operator|=
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
init|;
name|temp
operator|!=
name|p
condition|;
name|temp
operator|=
name|NEXT_INSN
argument_list|(
name|temp
argument_list|)
control|)
block|{
name|rtx
name|body
decl_stmt|;
name|rtx
name|n
decl_stmt|;
name|rtx
name|next
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|==
name|NOTE
condition|)
continue|continue;
name|body
operator|=
name|PATTERN
argument_list|(
name|temp
argument_list|)
expr_stmt|;
comment|/* Find the next insn after TEMP, 				 not counting USE or NOTE insns.  */
for|for
control|(
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|temp
argument_list|)
init|;
name|next
operator|!=
name|p
condition|;
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|next
argument_list|)
control|)
if|if
condition|(
operator|!
operator|(
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|next
argument_list|)
argument_list|)
operator|==
name|USE
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|!=
name|NOTE
condition|)
break|break;
comment|/* If that is the call, this may be the insn 				 that loads the function address.  				 Extract the function address from the insn 				 that loads it into a register. 				 If this insn was cse'd, we get incorrect code.  				 So emit a new move insn that copies the 				 function address into the register that the 				 call insn will use.  flow.c will delete any 				 redundant stores that we have created.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|CALL_INSN
operator|&&
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|body
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|n
operator|=
name|find_reg_note
argument_list|(
name|temp
argument_list|,
name|REG_EQUAL
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
condition|)
block|{
name|fn_reg
operator|=
name|SET_SRC
argument_list|(
name|body
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|fn_reg
argument_list|)
operator|!=
name|REG
condition|)
name|fn_reg
operator|=
name|SET_DEST
argument_list|(
name|body
argument_list|)
expr_stmt|;
name|fn_address
operator|=
name|XEXP
argument_list|(
name|n
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fn_address_insn
operator|=
name|temp
expr_stmt|;
block|}
comment|/* We have the call insn. 				 If it uses the register we suspect it might, 				 load it with the correct address directly.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|==
name|CALL_INSN
operator|&&
name|fn_address
operator|!=
literal|0
operator|&&
name|reg_referenced_p
argument_list|(
name|fn_reg
argument_list|,
name|body
argument_list|)
condition|)
name|emit_insn_after
argument_list|(
name|gen_move_insn
argument_list|(
name|fn_reg
argument_list|,
name|fn_address
argument_list|)
argument_list|,
name|fn_address_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
name|i1
operator|=
name|emit_call_insn_before
argument_list|(
name|body
argument_list|,
name|loop_start
argument_list|)
expr_stmt|;
comment|/* Because the USAGE information potentially 				     contains objects other than hard registers 				     we need to copy it.  */
if|if
condition|(
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|temp
argument_list|)
condition|)
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|i1
argument_list|)
operator|=
name|copy_rtx
argument_list|(
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|temp
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|i1
operator|=
name|emit_insn_before
argument_list|(
name|body
argument_list|,
name|loop_start
argument_list|)
expr_stmt|;
if|if
condition|(
name|first
operator|==
literal|0
condition|)
name|first
operator|=
name|i1
expr_stmt|;
if|if
condition|(
name|temp
operator|==
name|fn_address_insn
condition|)
name|fn_address_insn
operator|=
name|i1
expr_stmt|;
name|REG_NOTES
argument_list|(
name|i1
argument_list|)
operator|=
name|REG_NOTES
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|delete_insn
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|new_start
operator|==
literal|0
condition|)
name|new_start
operator|=
name|first
expr_stmt|;
block|}
if|if
condition|(
name|m
operator|->
name|savemode
operator|!=
name|VOIDmode
condition|)
block|{
comment|/* P sets REG to zero; but we should clear only 			     the bits that are not covered by the mode 			     m->savemode.  */
name|rtx
name|reg
init|=
name|m
operator|->
name|set_dest
decl_stmt|;
name|rtx
name|sequence
decl_stmt|;
name|rtx
name|tem
decl_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|tem
operator|=
name|expand_binop
argument_list|(
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|,
name|and_optab
argument_list|,
name|reg
argument_list|,
name|GEN_INT
argument_list|(
operator|(
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|GET_MODE_BITSIZE
argument_list|(
name|m
operator|->
name|savemode
argument_list|)
operator|)
operator|)
operator|-
literal|1
argument_list|)
argument_list|,
name|reg
argument_list|,
literal|1
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|tem
operator|!=
name|reg
condition|)
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|tem
argument_list|)
expr_stmt|;
name|sequence
operator|=
name|gen_sequence
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|i1
operator|=
name|emit_insn_before
argument_list|(
name|sequence
argument_list|,
name|loop_start
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
name|i1
operator|=
name|emit_call_insn_before
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|,
name|loop_start
argument_list|)
expr_stmt|;
comment|/* Because the USAGE information potentially 			     contains objects other than hard registers 			     we need to copy it.  */
if|if
condition|(
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|p
argument_list|)
condition|)
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|i1
argument_list|)
operator|=
name|copy_rtx
argument_list|(
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|count
operator|==
name|m
operator|->
name|consec
operator|&&
name|m
operator|->
name|move_insn_first
condition|)
block|{
comment|/* The SET_SRC might not be invariant, so we must 			     use the REG_EQUAL note.  */
name|start_sequence
argument_list|()
expr_stmt|;
name|emit_move_insn
argument_list|(
name|m
operator|->
name|set_dest
argument_list|,
name|m
operator|->
name|set_src
argument_list|)
expr_stmt|;
name|temp
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|add_label_notes
argument_list|(
name|m
operator|->
name|set_src
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|i1
operator|=
name|emit_insns_before
argument_list|(
name|temp
argument_list|,
name|loop_start
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|find_reg_note
argument_list|(
name|i1
argument_list|,
name|REG_EQUAL
argument_list|,
name|NULL_RTX
argument_list|)
condition|)
name|REG_NOTES
argument_list|(
name|i1
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
operator|(
name|m
operator|->
name|is_equiv
condition|?
name|REG_EQUIV
else|:
name|REG_EQUAL
operator|)
argument_list|,
name|m
operator|->
name|set_src
argument_list|,
name|REG_NOTES
argument_list|(
name|i1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|i1
operator|=
name|emit_insn_before
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|,
name|loop_start
argument_list|)
expr_stmt|;
if|if
condition|(
name|REG_NOTES
argument_list|(
name|i1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|REG_NOTES
argument_list|(
name|i1
argument_list|)
operator|=
name|REG_NOTES
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* If there is a REG_EQUAL note present whose value 			     is not loop invariant, then delete it, since it 			     may cause problems with later optimization passes. 			     It is possible for cse to create such notes 			     like this as a result of record_jump_cond.  */
if|if
condition|(
operator|(
name|temp
operator|=
name|find_reg_note
argument_list|(
name|i1
argument_list|,
name|REG_EQUAL
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
operator|&&
operator|!
name|invariant_p
argument_list|(
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|remove_note
argument_list|(
name|i1
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|new_start
operator|==
literal|0
condition|)
name|new_start
operator|=
name|i1
expr_stmt|;
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|" moved to %d"
argument_list|,
name|INSN_UID
argument_list|(
name|i1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If library call, now fix the REG_NOTES that contain 			 insn pointers, namely REG_LIBCALL on FIRST 			 and REG_RETVAL on I1.  */
if|if
condition|(
operator|(
name|temp
operator|=
name|find_reg_note
argument_list|(
name|i1
argument_list|,
name|REG_RETVAL
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
condition|)
block|{
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
operator|=
name|first
expr_stmt|;
name|temp
operator|=
name|find_reg_note
argument_list|(
name|first
argument_list|,
name|REG_LIBCALL
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
operator|=
name|i1
expr_stmt|;
block|}
name|temp
operator|=
name|p
expr_stmt|;
name|delete_insn
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* simplify_giv_expr expects that it can walk the insns 			 at m->insn forwards and see this old sequence we are 			 tossing here.  delete_insn does preserve the next 			 pointers, but when we skip over a NOTE we must fix 			 it up.  Otherwise that code walks into the non-deleted 			 insn stream.  */
while|while
condition|(
name|p
operator|&&
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|NOTE
condition|)
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|temp
argument_list|)
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
comment|/* The more regs we move, the less we like moving them.  */
name|threshold
operator|-=
literal|3
expr_stmt|;
block|}
comment|/* Any other movable that loads the same register 		 MUST be moved.  */
name|already_moved
index|[
name|regno
index|]
operator|=
literal|1
expr_stmt|;
comment|/* This reg has been moved out of one loop.  */
name|moved_once
index|[
name|regno
index|]
operator|=
literal|1
expr_stmt|;
comment|/* The reg set here is now invariant.  */
if|if
condition|(
operator|!
name|m
operator|->
name|partial
condition|)
name|VARRAY_INT
argument_list|(
name|set_in_loop
argument_list|,
name|regno
argument_list|)
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|done
operator|=
literal|1
expr_stmt|;
comment|/* Change the length-of-life info for the register 		 to say it lives at least the full length of this loop. 		 This will help guide optimizations in outer loops.  */
if|if
condition|(
name|uid_luid
index|[
name|REGNO_FIRST_UID
argument_list|(
name|regno
argument_list|)
index|]
operator|>
name|INSN_LUID
argument_list|(
name|loop_start
argument_list|)
condition|)
comment|/* This is the old insn before all the moved insns. 		   We can't use the moved insn because it is out of range 		   in uid_luid.  Only the old insns have luids.  */
name|REGNO_FIRST_UID
argument_list|(
name|regno
argument_list|)
operator|=
name|INSN_UID
argument_list|(
name|loop_start
argument_list|)
expr_stmt|;
if|if
condition|(
name|uid_luid
index|[
name|REGNO_LAST_UID
argument_list|(
name|regno
argument_list|)
index|]
operator|<
name|INSN_LUID
argument_list|(
name|end
argument_list|)
condition|)
name|REGNO_LAST_UID
argument_list|(
name|regno
argument_list|)
operator|=
name|INSN_UID
argument_list|(
name|end
argument_list|)
expr_stmt|;
comment|/* Combine with this moved insn any other matching movables.  */
if|if
condition|(
operator|!
name|m
operator|->
name|partial
condition|)
for|for
control|(
name|m1
operator|=
name|movables
init|;
name|m1
condition|;
name|m1
operator|=
name|m1
operator|->
name|next
control|)
if|if
condition|(
name|m1
operator|->
name|match
operator|==
name|m
condition|)
block|{
name|rtx
name|temp
decl_stmt|;
comment|/* Schedule the reg loaded by M1 			 for replacement so that shares the reg of M. 			 If the modes differ (only possible in restricted 			 circumstances, make a SUBREG.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|m
operator|->
name|set_dest
argument_list|)
operator|==
name|GET_MODE
argument_list|(
name|m1
operator|->
name|set_dest
argument_list|)
condition|)
name|reg_map
index|[
name|m1
operator|->
name|regno
index|]
operator|=
name|m
operator|->
name|set_dest
expr_stmt|;
else|else
name|reg_map
index|[
name|m1
operator|->
name|regno
index|]
operator|=
name|gen_lowpart_common
argument_list|(
name|GET_MODE
argument_list|(
name|m1
operator|->
name|set_dest
argument_list|)
argument_list|,
name|m
operator|->
name|set_dest
argument_list|)
expr_stmt|;
comment|/* Get rid of the matching insn 			 and prevent further processing of it.  */
name|m1
operator|->
name|done
operator|=
literal|1
expr_stmt|;
comment|/* if library call, delete all insn except last, which 			 is deleted below */
if|if
condition|(
operator|(
name|temp
operator|=
name|find_reg_note
argument_list|(
name|m1
operator|->
name|insn
argument_list|,
name|REG_RETVAL
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
condition|)
block|{
for|for
control|(
name|temp
operator|=
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
init|;
name|temp
operator|!=
name|m1
operator|->
name|insn
condition|;
name|temp
operator|=
name|NEXT_INSN
argument_list|(
name|temp
argument_list|)
control|)
name|delete_insn
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
name|delete_insn
argument_list|(
name|m1
operator|->
name|insn
argument_list|)
expr_stmt|;
comment|/* Any other movable that loads the same register 			 MUST be moved.  */
name|already_moved
index|[
name|m1
operator|->
name|regno
index|]
operator|=
literal|1
expr_stmt|;
comment|/* The reg merged here is now invariant, 			 if the reg it matches is invariant.  */
if|if
condition|(
operator|!
name|m
operator|->
name|partial
condition|)
name|VARRAY_INT
argument_list|(
name|set_in_loop
argument_list|,
name|m1
operator|->
name|regno
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"not desirable"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|loop_dump_stream
operator|&&
operator|!
name|m
operator|->
name|match
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"not safe"
argument_list|)
expr_stmt|;
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|new_start
operator|==
literal|0
condition|)
name|new_start
operator|=
name|loop_start
expr_stmt|;
comment|/* Go through all the instructions in the loop, making      all the register substitutions scheduled in REG_MAP.  */
for|for
control|(
name|p
operator|=
name|new_start
init|;
name|p
operator|!=
name|end
condition|;
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|JUMP_INSN
operator|||
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
name|replace_regs
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|,
name|reg_map
argument_list|,
name|nregs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|replace_regs
argument_list|(
name|REG_NOTES
argument_list|(
name|p
argument_list|)
argument_list|,
name|reg_map
argument_list|,
name|nregs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|INSN_CODE
argument_list|(
name|p
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Scan X and replace the address of any MEM in it with ADDR.    REG is the address that MEM should have before the replacement.  */
end_comment

begin_comment
unit|static void replace_call_address (x, reg, addr)      rtx x, reg, addr; {   register enum rtx_code code;   register int i;   register char *fmt;    if (x == 0)     return;   code = GET_CODE (x);   switch (code)     {     case PC:     case CC0:     case CONST_INT:     case CONST_DOUBLE:     case CONST:     case SYMBOL_REF:     case LABEL_REF:     case REG:       return;      case SET:
comment|/* Short cut for very common case.  */
end_comment

begin_comment
unit|replace_call_address (XEXP (x, 1), reg, addr);       return;      case CALL:
comment|/* Short cut for very common case.  */
end_comment

begin_comment
unit|replace_call_address (XEXP (x, 0), reg, addr);       return;      case MEM:
comment|/* If this MEM uses a reg other than the one we expected, 	 something is wrong.  */
end_comment

begin_endif
unit|if (XEXP (x, 0) != reg) 	abort ();       XEXP (x, 0) = addr;       return;            default:       break;     }    fmt = GET_RTX_FORMAT (code);   for (i = GET_RTX_LENGTH (code) - 1; i>= 0; i--)     {       if (fmt[i] == 'e') 	replace_call_address (XEXP (x, i), reg, addr);       if (fmt[i] == 'E') 	{ 	  register int j; 	  for (j = 0; j< XVECLEN (x, i); j++) 	    replace_call_address (XVECEXP (x, i, j), reg, addr); 	}     } }
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Return the number of memory refs to addresses that vary    in the rtx X.  */
end_comment

begin_function
specifier|static
name|int
name|count_nonfixed_reads
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
specifier|register
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|value
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PC
case|:
case|case
name|CC0
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CONST
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
case|case
name|REG
case|:
return|return
literal|0
return|;
case|case
name|MEM
case|:
return|return
operator|(
operator|(
name|invariant_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
literal|1
operator|)
operator|+
name|count_nonfixed_reads
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
return|;
default|default:
break|break;
block|}
name|value
operator|=
literal|0
expr_stmt|;
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|value
operator|+=
name|count_nonfixed_reads
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|value
operator|+=
name|count_nonfixed_reads
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|value
return|;
block|}
end_function

begin_escape
end_escape

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* P is an instruction that sets a register to the result of a ZERO_EXTEND.    Replace it with an instruction to load just the low bytes    if the machine supports such an instruction,    and insert above LOOP_START an instruction to clear the register.  */
end_comment

begin_comment
unit|static void constant_high_bytes (p, loop_start)      rtx p, loop_start; {   register rtx new;   register int insn_code_number;
comment|/* Try to change (SET (REG ...) (ZERO_EXTEND (..:B ...)))      to (SET (STRICT_LOW_PART (SUBREG:B (REG...))) ...).  */
end_comment

begin_comment
unit|new = gen_rtx_SET (VOIDmode, 		     gen_rtx_STRICT_LOW_PART (VOIDmode, 					      gen_rtx_SUBREG (GET_MODE (XEXP (SET_SRC (PATTERN (p)), 0)), 				   SET_DEST (PATTERN (p)), 				   0)), 		 XEXP (SET_SRC (PATTERN (p)), 0));   insn_code_number = recog (new, p);    if (insn_code_number)     {       register int i;
comment|/* Clear destination register before the loop.  */
end_comment

begin_comment
unit|emit_insn_before (gen_rtx_SET (VOIDmode, SET_DEST (PATTERN (p)), 				     const0_rtx), 			loop_start);
comment|/* Inside the loop, just load the low part.  */
end_comment

begin_endif
unit|PATTERN (p) = new;     } }
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Scan a loop setting the variables `unknown_address_altered',    `num_mem_sets', `loop_continue', `loops_enclosed', `loop_has_call',    `loop_has_volatile', and `loop_has_tablejump'.    Also, fill in the array `loop_mems' and the list `loop_store_mems'.  */
end_comment

begin_function
specifier|static
name|void
name|prescan_loop
parameter_list|(
name|start
parameter_list|,
name|end
parameter_list|)
name|rtx
name|start
decl_stmt|,
name|end
decl_stmt|;
block|{
specifier|register
name|int
name|level
init|=
literal|1
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|int
name|loop_has_multiple_exit_targets
init|=
literal|0
decl_stmt|;
comment|/* The label after END.  Jumping here is just like falling off the      end of the loop.  We use next_nonnote_insn instead of next_label      as a hedge against the (pathological) case where some actual insn      might end up between the two.  */
name|rtx
name|exit_target
init|=
name|next_nonnote_insn
argument_list|(
name|end
argument_list|)
decl_stmt|;
if|if
condition|(
name|exit_target
operator|==
name|NULL_RTX
operator|||
name|GET_CODE
argument_list|(
name|exit_target
argument_list|)
operator|!=
name|CODE_LABEL
condition|)
name|loop_has_multiple_exit_targets
operator|=
literal|1
expr_stmt|;
name|unknown_address_altered
operator|=
literal|0
expr_stmt|;
name|loop_has_call
operator|=
literal|0
expr_stmt|;
name|loop_has_volatile
operator|=
literal|0
expr_stmt|;
name|loop_has_tablejump
operator|=
literal|0
expr_stmt|;
name|loop_store_mems
operator|=
name|NULL_RTX
expr_stmt|;
name|first_loop_store_insn
operator|=
name|NULL_RTX
expr_stmt|;
name|loop_mems_idx
operator|=
literal|0
expr_stmt|;
name|num_mem_sets
operator|=
literal|0
expr_stmt|;
name|loops_enclosed
operator|=
literal|1
expr_stmt|;
name|loop_continue
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|start
argument_list|)
init|;
name|insn
operator|!=
name|NEXT_INSN
argument_list|(
name|end
argument_list|)
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
block|{
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_LOOP_BEG
condition|)
block|{
operator|++
name|level
expr_stmt|;
comment|/* Count number of loops contained in this one.  */
name|loops_enclosed
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_LOOP_END
condition|)
block|{
operator|--
name|level
expr_stmt|;
if|if
condition|(
name|level
operator|==
literal|0
condition|)
block|{
name|end
operator|=
name|insn
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_LOOP_CONT
condition|)
block|{
if|if
condition|(
name|level
operator|==
literal|1
condition|)
name|loop_continue
operator|=
name|insn
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
if|if
condition|(
operator|!
name|CONST_CALL_P
argument_list|(
name|insn
argument_list|)
condition|)
name|unknown_address_altered
operator|=
literal|1
expr_stmt|;
name|loop_has_call
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
block|{
name|rtx
name|label1
init|=
name|NULL_RTX
decl_stmt|;
name|rtx
name|label2
init|=
name|NULL_RTX
decl_stmt|;
if|if
condition|(
name|volatile_refs_p
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
name|loop_has_volatile
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|ADDR_DIFF_VEC
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|ADDR_VEC
operator|)
condition|)
name|loop_has_tablejump
operator|=
literal|1
expr_stmt|;
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|note_addr_stored
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|first_loop_store_insn
operator|&&
name|loop_store_mems
condition|)
name|first_loop_store_insn
operator|=
name|insn
expr_stmt|;
if|if
condition|(
operator|!
name|loop_has_multiple_exit_targets
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|pc_rtx
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|IF_THEN_ELSE
condition|)
block|{
name|label1
operator|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|label2
operator|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|label1
operator|=
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
do|do
block|{
if|if
condition|(
name|label1
operator|&&
name|label1
operator|!=
name|pc_rtx
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|label1
argument_list|)
operator|!=
name|LABEL_REF
condition|)
block|{
comment|/* Something tricky.  */
name|loop_has_multiple_exit_targets
operator|=
literal|1
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|XEXP
argument_list|(
name|label1
argument_list|,
literal|0
argument_list|)
operator|!=
name|exit_target
operator|&&
name|LABEL_OUTSIDE_LOOP_P
argument_list|(
name|label1
argument_list|)
condition|)
block|{
comment|/* A jump outside the current loop.  */
name|loop_has_multiple_exit_targets
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
name|label1
operator|=
name|label2
expr_stmt|;
name|label2
operator|=
name|NULL_RTX
expr_stmt|;
block|}
do|while
condition|(
name|label1
condition|)
do|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|RETURN
condition|)
name|loop_has_multiple_exit_targets
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Now, rescan the loop, setting up the LOOP_MEMS array.  */
if|if
condition|(
comment|/* We can't tell what MEMs are aliased by what.  */
operator|!
name|unknown_address_altered
comment|/* An exception thrown by a called function might land us 	 anywhere.  */
operator|&&
operator|!
name|loop_has_call
comment|/* We don't want loads for MEMs moved to a location before the 	 one at which their stack memory becomes allocated.  (Note 	 that this is not a problem for malloc, etc., since those 	 require actual function calls.  */
operator|&&
operator|!
name|current_function_calls_alloca
comment|/* There are ways to leave the loop other than falling off the 	 end.  */
operator|&&
operator|!
name|loop_has_multiple_exit_targets
condition|)
for|for
control|(
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|start
argument_list|)
init|;
name|insn
operator|!=
name|NEXT_INSN
argument_list|(
name|end
argument_list|)
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
name|for_each_rtx
argument_list|(
operator|&
name|insn
argument_list|,
name|insert_loop_mem
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* LOOP_NUMBER_CONT_DOMINATOR is now the last label between the loop start    and the continue note that is a the destination of a (cond)jump after    the continue note.  If there is any (cond)jump between the loop start    and what we have so far as LOOP_NUMBER_CONT_DOMINATOR that has a    target between LOOP_DOMINATOR and the continue note, move    LOOP_NUMBER_CONT_DOMINATOR forward to that label; if a jump's    destination cannot be determined, clear LOOP_NUMBER_CONT_DOMINATOR.  */
end_comment

begin_function
specifier|static
name|void
name|verify_dominator
parameter_list|(
name|loop_number
parameter_list|)
name|int
name|loop_number
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|;
if|if
condition|(
operator|!
name|loop_number_cont_dominator
index|[
name|loop_number
index|]
condition|)
comment|/* This can happen for an empty loop, e.g. in        gcc.c-torture/compile/920410-2.c  */
return|return;
if|if
condition|(
name|loop_number_cont_dominator
index|[
name|loop_number
index|]
operator|==
name|const0_rtx
condition|)
block|{
name|loop_number_cont_dominator
index|[
name|loop_number
index|]
operator|=
literal|0
expr_stmt|;
return|return;
block|}
for|for
control|(
name|insn
operator|=
name|loop_number_loop_starts
index|[
name|loop_number
index|]
init|;
name|insn
operator|!=
name|loop_number_cont_dominator
index|[
name|loop_number
index|]
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|RETURN
condition|)
block|{
name|rtx
name|label
init|=
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|int
name|label_luid
decl_stmt|;
comment|/* If it is not a jump we can easily understand or for 	     which we do not have jump target information in the JUMP_LABEL 	     field (consider ADDR_VEC and ADDR_DIFF_VEC insns), then clear 	     LOOP_NUMBER_CONT_DOMINATOR.  */
if|if
condition|(
operator|(
operator|!
name|condjump_p
argument_list|(
name|insn
argument_list|)
operator|&&
operator|!
name|condjump_in_parallel_p
argument_list|(
name|insn
argument_list|)
operator|)
operator|||
name|label
operator|==
name|NULL_RTX
condition|)
block|{
name|loop_number_cont_dominator
index|[
name|loop_number
index|]
operator|=
name|NULL_RTX
expr_stmt|;
return|return;
block|}
name|label_luid
operator|=
name|INSN_LUID
argument_list|(
name|label
argument_list|)
expr_stmt|;
if|if
condition|(
name|label_luid
operator|<
name|INSN_LUID
argument_list|(
name|loop_number_loop_cont
index|[
name|loop_number
index|]
argument_list|)
operator|&&
operator|(
name|label_luid
operator|>
name|INSN_LUID
argument_list|(
name|loop_number_cont_dominator
index|[
name|loop_number
index|]
argument_list|)
operator|)
condition|)
name|loop_number_cont_dominator
index|[
name|loop_number
index|]
operator|=
name|label
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Scan the function looking for loops.  Record the start and end of each loop.    Also mark as invalid loops any loops that contain a setjmp or are branched    to from outside the loop.  */
end_comment

begin_function
specifier|static
name|void
name|find_and_verify_loops
parameter_list|(
name|f
parameter_list|)
name|rtx
name|f
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|,
name|label
decl_stmt|;
name|int
name|current_loop
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|next_loop
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|loop
decl_stmt|;
name|compute_luids
argument_list|(
name|f
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If there are jumps to undefined labels,      treat them as jumps out of any/all loops.      This also avoids writing past end of tables when there are no loops.  */
name|uid_loop_num
index|[
literal|0
index|]
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Find boundaries of loops, mark which loops are contained within      loops, and invalidate loops that have setjmp.  */
for|for
control|(
name|insn
operator|=
name|f
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
switch|switch
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
condition|)
block|{
case|case
name|NOTE_INSN_LOOP_BEG
case|:
name|loop_number_loop_starts
index|[
operator|++
name|next_loop
index|]
operator|=
name|insn
expr_stmt|;
name|loop_number_loop_ends
index|[
name|next_loop
index|]
operator|=
literal|0
expr_stmt|;
name|loop_number_loop_cont
index|[
name|next_loop
index|]
operator|=
literal|0
expr_stmt|;
name|loop_number_cont_dominator
index|[
name|next_loop
index|]
operator|=
literal|0
expr_stmt|;
name|loop_outer_loop
index|[
name|next_loop
index|]
operator|=
name|current_loop
expr_stmt|;
name|loop_invalid
index|[
name|next_loop
index|]
operator|=
literal|0
expr_stmt|;
name|loop_number_exit_labels
index|[
name|next_loop
index|]
operator|=
literal|0
expr_stmt|;
name|loop_number_exit_count
index|[
name|next_loop
index|]
operator|=
literal|0
expr_stmt|;
name|current_loop
operator|=
name|next_loop
expr_stmt|;
break|break;
case|case
name|NOTE_INSN_SETJMP
case|:
comment|/* In this case, we must invalidate our current loop and any 	       enclosing loop.  */
for|for
control|(
name|loop
operator|=
name|current_loop
init|;
name|loop
operator|!=
operator|-
literal|1
condition|;
name|loop
operator|=
name|loop_outer_loop
index|[
name|loop
index|]
control|)
block|{
name|loop_invalid
index|[
name|loop
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"\nLoop at %d ignored due to setjmp.\n"
argument_list|,
name|INSN_UID
argument_list|(
name|loop_number_loop_starts
index|[
name|loop
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|NOTE_INSN_LOOP_CONT
case|:
name|loop_number_loop_cont
index|[
name|current_loop
index|]
operator|=
name|insn
expr_stmt|;
break|break;
case|case
name|NOTE_INSN_LOOP_END
case|:
if|if
condition|(
name|current_loop
operator|==
operator|-
literal|1
condition|)
name|abort
argument_list|()
expr_stmt|;
name|loop_number_loop_ends
index|[
name|current_loop
index|]
operator|=
name|insn
expr_stmt|;
name|verify_dominator
argument_list|(
name|current_loop
argument_list|)
expr_stmt|;
name|current_loop
operator|=
name|loop_outer_loop
index|[
name|current_loop
index|]
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* If for any loop, this is a jump insn between the NOTE_INSN_LOOP_CONT 	 and NOTE_INSN_LOOP_END notes, update loop_number_loop_dominator.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|RETURN
operator|&&
name|current_loop
operator|>=
literal|0
condition|)
block|{
name|int
name|this_loop
decl_stmt|;
name|rtx
name|label
init|=
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|condjump_p
argument_list|(
name|insn
argument_list|)
operator|&&
operator|!
name|condjump_in_parallel_p
argument_list|(
name|insn
argument_list|)
condition|)
name|label
operator|=
name|NULL_RTX
expr_stmt|;
name|this_loop
operator|=
name|current_loop
expr_stmt|;
do|do
block|{
comment|/* First see if we care about this loop.  */
if|if
condition|(
name|loop_number_loop_cont
index|[
name|this_loop
index|]
operator|&&
name|loop_number_cont_dominator
index|[
name|this_loop
index|]
operator|!=
name|const0_rtx
condition|)
block|{
comment|/* If the jump destination is not known, invalidate 		     loop_number_const_dominator.  */
if|if
condition|(
operator|!
name|label
condition|)
name|loop_number_cont_dominator
index|[
name|this_loop
index|]
operator|=
name|const0_rtx
expr_stmt|;
elseif|else
comment|/* Check if the destination is between loop start and 		       cont.  */
if|if
condition|(
operator|(
name|INSN_LUID
argument_list|(
name|label
argument_list|)
operator|<
name|INSN_LUID
argument_list|(
name|loop_number_loop_cont
index|[
name|this_loop
index|]
argument_list|)
operator|)
operator|&&
operator|(
name|INSN_LUID
argument_list|(
name|label
argument_list|)
operator|>
name|INSN_LUID
argument_list|(
name|loop_number_loop_starts
index|[
name|this_loop
index|]
argument_list|)
operator|)
comment|/* And if there is no later destination already 			   recorded.  */
operator|&&
operator|(
operator|!
name|loop_number_cont_dominator
index|[
name|this_loop
index|]
operator|||
operator|(
name|INSN_LUID
argument_list|(
name|label
argument_list|)
operator|>
name|INSN_LUID
argument_list|(
name|loop_number_cont_dominator
index|[
name|this_loop
index|]
argument_list|)
operator|)
operator|)
condition|)
name|loop_number_cont_dominator
index|[
name|this_loop
index|]
operator|=
name|label
expr_stmt|;
block|}
name|this_loop
operator|=
name|loop_outer_loop
index|[
name|this_loop
index|]
expr_stmt|;
block|}
do|while
condition|(
name|this_loop
operator|>=
literal|0
condition|)
do|;
block|}
comment|/* Note that this will mark the NOTE_INSN_LOOP_END note as being in the 	 enclosing loop, but this doesn't matter.  */
name|uid_loop_num
index|[
name|INSN_UID
argument_list|(
name|insn
argument_list|)
index|]
operator|=
name|current_loop
expr_stmt|;
block|}
comment|/* Any loop containing a label used in an initializer must be invalidated,      because it can be jumped into from anywhere.  */
for|for
control|(
name|label
operator|=
name|forced_labels
init|;
name|label
condition|;
name|label
operator|=
name|XEXP
argument_list|(
name|label
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|int
name|loop_num
decl_stmt|;
for|for
control|(
name|loop_num
operator|=
name|uid_loop_num
index|[
name|INSN_UID
argument_list|(
name|XEXP
argument_list|(
name|label
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
init|;
name|loop_num
operator|!=
operator|-
literal|1
condition|;
name|loop_num
operator|=
name|loop_outer_loop
index|[
name|loop_num
index|]
control|)
name|loop_invalid
index|[
name|loop_num
index|]
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Any loop containing a label used for an exception handler must be      invalidated, because it can be jumped into from anywhere.  */
for|for
control|(
name|label
operator|=
name|exception_handler_labels
init|;
name|label
condition|;
name|label
operator|=
name|XEXP
argument_list|(
name|label
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|int
name|loop_num
decl_stmt|;
for|for
control|(
name|loop_num
operator|=
name|uid_loop_num
index|[
name|INSN_UID
argument_list|(
name|XEXP
argument_list|(
name|label
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
init|;
name|loop_num
operator|!=
operator|-
literal|1
condition|;
name|loop_num
operator|=
name|loop_outer_loop
index|[
name|loop_num
index|]
control|)
name|loop_invalid
index|[
name|loop_num
index|]
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Now scan all insn's in the function.  If any JUMP_INSN branches into a      loop that it is not contained within, that loop is marked invalid.      If any INSN or CALL_INSN uses a label's address, then the loop containing      that label is marked invalid, because it could be jumped into from      anywhere.       Also look for blocks of code ending in an unconditional branch that      exits the loop.  If such a block is surrounded by a conditional       branch around the block, move the block elsewhere (see below) and      invert the jump to point to the code block.  This may eliminate a      label in our loop and will simplify processing by both us and a      possible second cse pass.  */
for|for
control|(
name|insn
operator|=
name|f
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
literal|'i'
condition|)
block|{
name|int
name|this_loop_num
init|=
name|uid_loop_num
index|[
name|INSN_UID
argument_list|(
name|insn
argument_list|)
index|]
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
name|rtx
name|note
init|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_LABEL
argument_list|,
name|NULL_RTX
argument_list|)
decl_stmt|;
if|if
condition|(
name|note
condition|)
block|{
name|int
name|loop_num
decl_stmt|;
for|for
control|(
name|loop_num
operator|=
name|uid_loop_num
index|[
name|INSN_UID
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
init|;
name|loop_num
operator|!=
operator|-
literal|1
condition|;
name|loop_num
operator|=
name|loop_outer_loop
index|[
name|loop_num
index|]
control|)
name|loop_invalid
index|[
name|loop_num
index|]
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|JUMP_INSN
condition|)
continue|continue;
name|mark_loop_jump
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|this_loop_num
argument_list|)
expr_stmt|;
comment|/* See if this is an unconditional branch outside the loop.  */
if|if
condition|(
name|this_loop_num
operator|!=
operator|-
literal|1
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|RETURN
operator|||
operator|(
name|simplejump_p
argument_list|(
name|insn
argument_list|)
operator|&&
operator|(
name|uid_loop_num
index|[
name|INSN_UID
argument_list|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
argument_list|)
index|]
operator|!=
name|this_loop_num
operator|)
operator|)
operator|)
operator|&&
name|get_max_uid
argument_list|()
operator|<
name|max_uid_for_loop
condition|)
block|{
name|rtx
name|p
decl_stmt|;
name|rtx
name|our_next
init|=
name|next_real_insn
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|last_insn_to_move
init|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|int
name|dest_loop
decl_stmt|;
name|int
name|outer_loop
init|=
operator|-
literal|1
decl_stmt|;
comment|/* Go backwards until we reach the start of the loop, a label, 	       or a JUMP_INSN.  */
for|for
control|(
name|p
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
init|;
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|!=
name|CODE_LABEL
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|p
argument_list|)
operator|==
name|NOTE_INSN_LOOP_BEG
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|!=
name|JUMP_INSN
condition|;
name|p
operator|=
name|PREV_INSN
argument_list|(
name|p
argument_list|)
control|)
empty_stmt|;
comment|/* Check for the case where we have a jump to an inner nested 	       loop, and do not perform the optimization in that case.  */
if|if
condition|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|dest_loop
operator|=
name|uid_loop_num
index|[
name|INSN_UID
argument_list|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|dest_loop
operator|!=
operator|-
literal|1
condition|)
block|{
for|for
control|(
name|outer_loop
operator|=
name|dest_loop
init|;
name|outer_loop
operator|!=
operator|-
literal|1
condition|;
name|outer_loop
operator|=
name|loop_outer_loop
index|[
name|outer_loop
index|]
control|)
if|if
condition|(
name|outer_loop
operator|==
name|this_loop_num
condition|)
break|break;
block|}
block|}
comment|/* Make sure that the target of P is within the current loop.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|JUMP_LABEL
argument_list|(
name|p
argument_list|)
operator|&&
name|uid_loop_num
index|[
name|INSN_UID
argument_list|(
name|JUMP_LABEL
argument_list|(
name|p
argument_list|)
argument_list|)
index|]
operator|!=
name|this_loop_num
condition|)
name|outer_loop
operator|=
name|this_loop_num
expr_stmt|;
comment|/* If we stopped on a JUMP_INSN to the next insn after INSN, 	       we have a block of code to try to move.  	       We look backward and then forward from the target of INSN 	       to find a BARRIER at the same loop depth as the target. 	       If we find such a BARRIER, we make a new label for the start 	       of the block, invert the jump in P and point it to that label, 	       and move the block of code to the spot we found.  */
if|if
condition|(
name|outer_loop
operator|==
operator|-
literal|1
operator|&&
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|JUMP_LABEL
argument_list|(
name|p
argument_list|)
operator|!=
literal|0
comment|/* Just ignore jumps to labels that were never emitted. 		   These always indicate compilation errors.  */
operator|&&
name|INSN_UID
argument_list|(
name|JUMP_LABEL
argument_list|(
name|p
argument_list|)
argument_list|)
operator|!=
literal|0
operator|&&
name|condjump_p
argument_list|(
name|p
argument_list|)
operator|&&
operator|!
name|simplejump_p
argument_list|(
name|p
argument_list|)
operator|&&
name|next_real_insn
argument_list|(
name|JUMP_LABEL
argument_list|(
name|p
argument_list|)
argument_list|)
operator|==
name|our_next
comment|/* If it's not safe to move the sequence, then we 		   mustn't try.  */
operator|&&
name|insns_safe_to_move_p
argument_list|(
name|p
argument_list|,
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|,
operator|&
name|last_insn_to_move
argument_list|)
condition|)
block|{
name|rtx
name|target
init|=
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
condition|?
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
else|:
name|get_last_insn
argument_list|()
decl_stmt|;
name|int
name|target_loop_num
init|=
name|uid_loop_num
index|[
name|INSN_UID
argument_list|(
name|target
argument_list|)
index|]
decl_stmt|;
name|rtx
name|loc
decl_stmt|,
name|loc2
decl_stmt|;
for|for
control|(
name|loc
operator|=
name|target
init|;
name|loc
condition|;
name|loc
operator|=
name|PREV_INSN
argument_list|(
name|loc
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|loc
argument_list|)
operator|==
name|BARRIER
comment|/* Don't move things inside a tablejump.  */
operator|&&
operator|(
operator|(
name|loc2
operator|=
name|next_nonnote_insn
argument_list|(
name|loc
argument_list|)
operator|)
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|loc2
argument_list|)
operator|!=
name|CODE_LABEL
operator|||
operator|(
name|loc2
operator|=
name|next_nonnote_insn
argument_list|(
name|loc2
argument_list|)
operator|)
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|loc2
argument_list|)
operator|!=
name|JUMP_INSN
operator|||
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|loc2
argument_list|)
argument_list|)
operator|!=
name|ADDR_VEC
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|loc2
argument_list|)
argument_list|)
operator|!=
name|ADDR_DIFF_VEC
operator|)
operator|)
operator|&&
name|uid_loop_num
index|[
name|INSN_UID
argument_list|(
name|loc
argument_list|)
index|]
operator|==
name|target_loop_num
condition|)
break|break;
if|if
condition|(
name|loc
operator|==
literal|0
condition|)
for|for
control|(
name|loc
operator|=
name|target
init|;
name|loc
condition|;
name|loc
operator|=
name|NEXT_INSN
argument_list|(
name|loc
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|loc
argument_list|)
operator|==
name|BARRIER
comment|/* Don't move things inside a tablejump.  */
operator|&&
operator|(
operator|(
name|loc2
operator|=
name|next_nonnote_insn
argument_list|(
name|loc
argument_list|)
operator|)
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|loc2
argument_list|)
operator|!=
name|CODE_LABEL
operator|||
operator|(
name|loc2
operator|=
name|next_nonnote_insn
argument_list|(
name|loc2
argument_list|)
operator|)
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|loc2
argument_list|)
operator|!=
name|JUMP_INSN
operator|||
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|loc2
argument_list|)
argument_list|)
operator|!=
name|ADDR_VEC
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|loc2
argument_list|)
argument_list|)
operator|!=
name|ADDR_DIFF_VEC
operator|)
operator|)
operator|&&
name|uid_loop_num
index|[
name|INSN_UID
argument_list|(
name|loc
argument_list|)
index|]
operator|==
name|target_loop_num
condition|)
break|break;
if|if
condition|(
name|loc
condition|)
block|{
name|rtx
name|cond_label
init|=
name|JUMP_LABEL
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|rtx
name|new_label
init|=
name|get_label_after
argument_list|(
name|p
argument_list|)
decl_stmt|;
comment|/* Ensure our label doesn't go away.  */
name|LABEL_NUSES
argument_list|(
name|cond_label
argument_list|)
operator|++
expr_stmt|;
comment|/* Verify that uid_loop_num is large enough and that 		       we can invert P.  */
if|if
condition|(
name|invert_jump
argument_list|(
name|p
argument_list|,
name|new_label
argument_list|)
condition|)
block|{
name|rtx
name|q
decl_stmt|,
name|r
decl_stmt|;
comment|/* If no suitable BARRIER was found, create a suitable 			  one before TARGET.  Since TARGET is a fall through 			  path, we'll need to insert an jump around our block 			  and a add a BARRIER before TARGET.  			  This creates an extra unconditional jump outside 			  the loop.  However, the benefits of removing rarely 			  executed instructions from inside the loop usually 			  outweighs the cost of the extra unconditional jump 			  outside the loop.  */
if|if
condition|(
name|loc
operator|==
literal|0
condition|)
block|{
name|rtx
name|temp
decl_stmt|;
name|temp
operator|=
name|gen_jump
argument_list|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|=
name|emit_jump_insn_before
argument_list|(
name|temp
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|JUMP_LABEL
argument_list|(
name|temp
argument_list|)
operator|=
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|LABEL_NUSES
argument_list|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|++
expr_stmt|;
name|loc
operator|=
name|emit_barrier_before
argument_list|(
name|target
argument_list|)
expr_stmt|;
block|}
comment|/* Include the BARRIER after INSN and copy the 			  block after LOC.  */
name|new_label
operator|=
name|squeeze_notes
argument_list|(
name|new_label
argument_list|,
name|last_insn_to_move
argument_list|)
expr_stmt|;
name|reorder_insns
argument_list|(
name|new_label
argument_list|,
name|last_insn_to_move
argument_list|,
name|loc
argument_list|)
expr_stmt|;
comment|/* All those insns are now in TARGET_LOOP_NUM.  */
for|for
control|(
name|q
operator|=
name|new_label
init|;
name|q
operator|!=
name|NEXT_INSN
argument_list|(
name|last_insn_to_move
argument_list|)
condition|;
name|q
operator|=
name|NEXT_INSN
argument_list|(
name|q
argument_list|)
control|)
name|uid_loop_num
index|[
name|INSN_UID
argument_list|(
name|q
argument_list|)
index|]
operator|=
name|target_loop_num
expr_stmt|;
comment|/* The label jumped to by INSN is no longer a loop exit. 			  Unless INSN does not have a label (e.g., it is a 			  RETURN insn), search loop_number_exit_labels to find 			  its label_ref, and remove it.  Also turn off 			  LABEL_OUTSIDE_LOOP_P bit.  */
if|if
condition|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|int
name|loop_num
decl_stmt|;
for|for
control|(
name|q
operator|=
literal|0
operator|,
name|r
operator|=
name|loop_number_exit_labels
index|[
name|this_loop_num
index|]
init|;
name|r
condition|;
name|q
operator|=
name|r
operator|,
name|r
operator|=
name|LABEL_NEXTREF
argument_list|(
name|r
argument_list|)
control|)
if|if
condition|(
name|XEXP
argument_list|(
name|r
argument_list|,
literal|0
argument_list|)
operator|==
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|LABEL_OUTSIDE_LOOP_P
argument_list|(
name|r
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|q
condition|)
name|LABEL_NEXTREF
argument_list|(
name|q
argument_list|)
operator|=
name|LABEL_NEXTREF
argument_list|(
name|r
argument_list|)
expr_stmt|;
else|else
name|loop_number_exit_labels
index|[
name|this_loop_num
index|]
operator|=
name|LABEL_NEXTREF
argument_list|(
name|r
argument_list|)
expr_stmt|;
break|break;
block|}
for|for
control|(
name|loop_num
operator|=
name|this_loop_num
init|;
name|loop_num
operator|!=
operator|-
literal|1
operator|&&
name|loop_num
operator|!=
name|target_loop_num
condition|;
name|loop_num
operator|=
name|loop_outer_loop
index|[
name|loop_num
index|]
control|)
name|loop_number_exit_count
index|[
name|loop_num
index|]
operator|--
expr_stmt|;
comment|/* If we didn't find it, then something is wrong.  */
if|if
condition|(
operator|!
name|r
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* P is now a jump outside the loop, so it must be put 			  in loop_number_exit_labels, and marked as such. 			  The easiest way to do this is to just call 			  mark_loop_jump again for P.  */
name|mark_loop_jump
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|,
name|this_loop_num
argument_list|)
expr_stmt|;
comment|/* If INSN now jumps to the insn after it, 			  delete INSN.  */
if|if
condition|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
operator|!=
literal|0
operator|&&
operator|(
name|next_real_insn
argument_list|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|next_real_insn
argument_list|(
name|insn
argument_list|)
operator|)
condition|)
name|delete_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
comment|/* Continue the loop after where the conditional 		       branch used to jump, since the only branch insn 		       in the block (if it still remains) is an inter-loop 		       branch and hence needs no processing.  */
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|cond_label
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|LABEL_NUSES
argument_list|(
name|cond_label
argument_list|)
operator|==
literal|0
condition|)
name|delete_insn
argument_list|(
name|cond_label
argument_list|)
expr_stmt|;
comment|/* This loop will be continued with NEXT_INSN (insn).  */
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* If any label in X jumps to a loop different from LOOP_NUM and any of the    loops it is contained in, mark the target loop invalid.     For speed, we assume that X is part of a pattern of a JUMP_INSN.  */
end_comment

begin_function
specifier|static
name|void
name|mark_loop_jump
parameter_list|(
name|x
parameter_list|,
name|loop_num
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|int
name|loop_num
decl_stmt|;
block|{
name|int
name|dest_loop
decl_stmt|;
name|int
name|outer_loop
decl_stmt|;
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|PC
case|:
case|case
name|USE
case|:
case|case
name|CLOBBER
case|:
case|case
name|REG
case|:
case|case
name|MEM
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|RETURN
case|:
return|return;
case|case
name|CONST
case|:
comment|/* There could be a label reference in here.  */
name|mark_loop_jump
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|loop_num
argument_list|)
expr_stmt|;
return|return;
case|case
name|PLUS
case|:
case|case
name|MINUS
case|:
case|case
name|MULT
case|:
name|mark_loop_jump
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|loop_num
argument_list|)
expr_stmt|;
name|mark_loop_jump
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|loop_num
argument_list|)
expr_stmt|;
return|return;
case|case
name|LO_SUM
case|:
comment|/* This may refer to a LABEL_REF or SYMBOL_REF.  */
name|mark_loop_jump
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|loop_num
argument_list|)
expr_stmt|;
return|return;
case|case
name|SIGN_EXTEND
case|:
case|case
name|ZERO_EXTEND
case|:
name|mark_loop_jump
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|loop_num
argument_list|)
expr_stmt|;
return|return;
case|case
name|LABEL_REF
case|:
name|dest_loop
operator|=
name|uid_loop_num
index|[
name|INSN_UID
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
expr_stmt|;
comment|/* Link together all labels that branch outside the loop.  This 	 is used by final_[bg]iv_value and the loop unrolling code.  Also 	 mark this LABEL_REF so we know that this branch should predict 	 false.  */
comment|/* A check to make sure the label is not in an inner nested loop, 	 since this does not count as a loop exit.  */
if|if
condition|(
name|dest_loop
operator|!=
operator|-
literal|1
condition|)
block|{
for|for
control|(
name|outer_loop
operator|=
name|dest_loop
init|;
name|outer_loop
operator|!=
operator|-
literal|1
condition|;
name|outer_loop
operator|=
name|loop_outer_loop
index|[
name|outer_loop
index|]
control|)
if|if
condition|(
name|outer_loop
operator|==
name|loop_num
condition|)
break|break;
block|}
else|else
name|outer_loop
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|loop_num
operator|!=
operator|-
literal|1
operator|&&
name|outer_loop
operator|==
operator|-
literal|1
condition|)
block|{
name|LABEL_OUTSIDE_LOOP_P
argument_list|(
name|x
argument_list|)
operator|=
literal|1
expr_stmt|;
name|LABEL_NEXTREF
argument_list|(
name|x
argument_list|)
operator|=
name|loop_number_exit_labels
index|[
name|loop_num
index|]
expr_stmt|;
name|loop_number_exit_labels
index|[
name|loop_num
index|]
operator|=
name|x
expr_stmt|;
for|for
control|(
name|outer_loop
operator|=
name|loop_num
init|;
name|outer_loop
operator|!=
operator|-
literal|1
operator|&&
name|outer_loop
operator|!=
name|dest_loop
condition|;
name|outer_loop
operator|=
name|loop_outer_loop
index|[
name|outer_loop
index|]
control|)
name|loop_number_exit_count
index|[
name|outer_loop
index|]
operator|++
expr_stmt|;
block|}
comment|/* If this is inside a loop, but not in the current loop or one enclosed 	 by it, it invalidates at least one loop.  */
if|if
condition|(
name|dest_loop
operator|==
operator|-
literal|1
condition|)
return|return;
comment|/* We must invalidate every nested loop containing the target of this 	 label, except those that also contain the jump insn.  */
for|for
control|(
init|;
name|dest_loop
operator|!=
operator|-
literal|1
condition|;
name|dest_loop
operator|=
name|loop_outer_loop
index|[
name|dest_loop
index|]
control|)
block|{
comment|/* Stop when we reach a loop that also contains the jump insn.  */
for|for
control|(
name|outer_loop
operator|=
name|loop_num
init|;
name|outer_loop
operator|!=
operator|-
literal|1
condition|;
name|outer_loop
operator|=
name|loop_outer_loop
index|[
name|outer_loop
index|]
control|)
if|if
condition|(
name|dest_loop
operator|==
name|outer_loop
condition|)
return|return;
comment|/* If we get here, we know we need to invalidate a loop.  */
if|if
condition|(
name|loop_dump_stream
operator|&&
operator|!
name|loop_invalid
index|[
name|dest_loop
index|]
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"\nLoop at %d ignored due to multiple entry points.\n"
argument_list|,
name|INSN_UID
argument_list|(
name|loop_number_loop_starts
index|[
name|dest_loop
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|loop_invalid
index|[
name|dest_loop
index|]
operator|=
literal|1
expr_stmt|;
block|}
return|return;
case|case
name|SET
case|:
comment|/* If this is not setting pc, ignore.  */
if|if
condition|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
operator|==
name|pc_rtx
condition|)
name|mark_loop_jump
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|loop_num
argument_list|)
expr_stmt|;
return|return;
case|case
name|IF_THEN_ELSE
case|:
name|mark_loop_jump
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|loop_num
argument_list|)
expr_stmt|;
name|mark_loop_jump
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
argument_list|,
name|loop_num
argument_list|)
expr_stmt|;
return|return;
case|case
name|PARALLEL
case|:
case|case
name|ADDR_VEC
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
name|mark_loop_jump
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|loop_num
argument_list|)
expr_stmt|;
return|return;
case|case
name|ADDR_DIFF_VEC
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
condition|;
name|i
operator|++
control|)
name|mark_loop_jump
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|,
name|i
argument_list|)
argument_list|,
name|loop_num
argument_list|)
expr_stmt|;
return|return;
default|default:
comment|/* Strictly speaking this is not a jump into the loop, only a possible 	 jump out of the loop.  However, we have no way to link the destination 	 of this jump onto the list of exit labels.  To be safe we mark this 	 loop and any containing loops as invalid.  */
if|if
condition|(
name|loop_num
operator|!=
operator|-
literal|1
condition|)
block|{
for|for
control|(
name|outer_loop
operator|=
name|loop_num
init|;
name|outer_loop
operator|!=
operator|-
literal|1
condition|;
name|outer_loop
operator|=
name|loop_outer_loop
index|[
name|outer_loop
index|]
control|)
block|{
if|if
condition|(
name|loop_dump_stream
operator|&&
operator|!
name|loop_invalid
index|[
name|outer_loop
index|]
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"\nLoop at %d ignored due to unknown exit jump.\n"
argument_list|,
name|INSN_UID
argument_list|(
name|loop_number_loop_starts
index|[
name|outer_loop
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|loop_invalid
index|[
name|outer_loop
index|]
operator|=
literal|1
expr_stmt|;
block|}
block|}
return|return;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return nonzero if there is a label in the range from    insn INSN to and including the insn whose luid is END    INSN must have an assigned luid (i.e., it must not have    been previously created by loop.c).  */
end_comment

begin_function
specifier|static
name|int
name|labels_in_range_p
parameter_list|(
name|insn
parameter_list|,
name|end
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|int
name|end
decl_stmt|;
block|{
while|while
condition|(
name|insn
operator|&&
name|INSN_LUID
argument_list|(
name|insn
argument_list|)
operator|<=
name|end
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
condition|)
return|return
literal|1
return|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Record that a memory reference X is being set.  */
end_comment

begin_function
specifier|static
name|void
name|note_addr_stored
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|rtx
name|y
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|x
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|MEM
condition|)
return|return;
comment|/* Count number of memory writes.      This affects heuristics in strength_reduce.  */
name|num_mem_sets
operator|++
expr_stmt|;
comment|/* BLKmode MEM means all memory is clobbered.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|BLKmode
condition|)
name|unknown_address_altered
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|unknown_address_altered
condition|)
return|return;
name|loop_store_mems
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|x
argument_list|,
name|loop_store_mems
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* X is a value modified by an INSN that references a biv inside a loop    exit test (ie, X is somehow related to the value of the biv).  If X    is a pseudo that is used more than once, then the biv is (effectively)    used more than once.  */
end_comment

begin_function
specifier|static
name|void
name|note_set_pseudo_multiple_uses
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|rtx
name|y
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return;
while|while
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|STRICT_LOW_PART
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SIGN_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SUBREG
condition|)
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO
argument_list|(
name|x
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
return|return;
comment|/* If we do not have usage information, or if we know the register      is used more than once, note that fact for check_dbra_loop.  */
if|if
condition|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|>=
name|max_reg_before_loop
operator|||
operator|!
name|VARRAY_RTX
argument_list|(
name|reg_single_usage
argument_list|,
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
operator|||
name|VARRAY_RTX
argument_list|(
name|reg_single_usage
argument_list|,
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|const0_rtx
condition|)
name|note_set_pseudo_multiple_uses_retval
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return nonzero if the rtx X is invariant over the current loop.     The value is 2 if we refer to something only conditionally invariant.     If `unknown_address_altered' is nonzero, no memory ref is invariant.    Otherwise, a memory ref is invariant if it does not conflict with    anything stored in `loop_store_mems'.  */
end_comment

begin_function
name|int
name|invariant_p
parameter_list|(
name|x
parameter_list|)
specifier|register
name|rtx
name|x
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|conditional
init|=
literal|0
decl_stmt|;
name|rtx
name|mem_list_entry
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return
literal|1
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|CONST
case|:
return|return
literal|1
return|;
case|case
name|LABEL_REF
case|:
comment|/* A LABEL_REF is normally invariant, however, if we are unrolling 	 loops, and this label is inside the loop, then it isn't invariant. 	 This is because each unrolled copy of the loop body will have 	 a copy of this label.  If this was invariant, then an insn loading 	 the address of this label into a register might get moved outside 	 the loop, and then each loop body would end up using the same label.  	 We don't know the loop bounds here though, so just fail for all 	 labels.  */
if|if
condition|(
name|flag_unroll_loops
condition|)
return|return
literal|0
return|;
else|else
return|return
literal|1
return|;
case|case
name|PC
case|:
case|case
name|CC0
case|:
case|case
name|UNSPEC_VOLATILE
case|:
return|return
literal|0
return|;
case|case
name|REG
case|:
comment|/* We used to check RTX_UNCHANGING_P (x) here, but that is invalid 	 since the reg might be set by initialization within the loop.  */
if|if
condition|(
operator|(
name|x
operator|==
name|frame_pointer_rtx
operator|||
name|x
operator|==
name|hard_frame_pointer_rtx
operator|||
name|x
operator|==
name|arg_pointer_rtx
operator|)
operator|&&
operator|!
name|current_function_has_nonlocal_goto
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|loop_has_call
operator|&&
name|REGNO
argument_list|(
name|x
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|call_used_regs
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|VARRAY_INT
argument_list|(
name|set_in_loop
argument_list|,
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
return|return
literal|2
return|;
return|return
name|VARRAY_INT
argument_list|(
name|set_in_loop
argument_list|,
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
literal|0
return|;
case|case
name|MEM
case|:
comment|/* Volatile memory references must be rejected.  Do this before 	 checking for read-only items, so that volatile read-only items 	 will be rejected also.  */
if|if
condition|(
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Read-only items (such as constants in a constant pool) are 	 invariant if their address is.  */
if|if
condition|(
name|RTX_UNCHANGING_P
argument_list|(
name|x
argument_list|)
condition|)
break|break;
comment|/* If we had a subroutine call, any location in memory could have been 	 clobbered.  */
if|if
condition|(
name|unknown_address_altered
condition|)
return|return
literal|0
return|;
comment|/* See if there is any dependence between a store and this load.  */
name|mem_list_entry
operator|=
name|loop_store_mems
expr_stmt|;
while|while
condition|(
name|mem_list_entry
condition|)
block|{
if|if
condition|(
name|true_dependence
argument_list|(
name|XEXP
argument_list|(
name|mem_list_entry
argument_list|,
literal|0
argument_list|)
argument_list|,
name|VOIDmode
argument_list|,
name|x
argument_list|,
name|rtx_varies_p
argument_list|)
condition|)
return|return
literal|0
return|;
name|mem_list_entry
operator|=
name|XEXP
argument_list|(
name|mem_list_entry
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* It's not invalidated by a store in memory 	 but we must still verify the address is invariant.  */
break|break;
case|case
name|ASM_OPERANDS
case|:
comment|/* Don't mess with insns declared volatile.  */
if|if
condition|(
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
default|default:
break|break;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
name|int
name|tem
init|=
name|invariant_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|tem
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|tem
operator|==
literal|2
condition|)
name|conditional
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
name|int
name|tem
init|=
name|invariant_p
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|tem
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|tem
operator|==
literal|2
condition|)
name|conditional
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
return|return
literal|1
operator|+
name|conditional
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return nonzero if all the insns in the loop that set REG    are INSN and the immediately following insns,    and if each of those insns sets REG in an invariant way    (not counting uses of REG in them).     The value is 2 if some of these insns are only conditionally invariant.     We assume that INSN itself is the first set of REG    and that its source is invariant.  */
end_comment

begin_function
specifier|static
name|int
name|consec_sets_invariant_p
parameter_list|(
name|reg
parameter_list|,
name|n_sets
parameter_list|,
name|insn
parameter_list|)
name|int
name|n_sets
decl_stmt|;
name|rtx
name|reg
decl_stmt|,
name|insn
decl_stmt|;
block|{
specifier|register
name|rtx
name|p
init|=
name|insn
decl_stmt|;
specifier|register
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|reg
argument_list|)
decl_stmt|;
name|rtx
name|temp
decl_stmt|;
comment|/* Number of sets we have to insist on finding after INSN.  */
name|int
name|count
init|=
name|n_sets
operator|-
literal|1
decl_stmt|;
name|int
name|old
init|=
name|VARRAY_INT
argument_list|(
name|set_in_loop
argument_list|,
name|regno
argument_list|)
decl_stmt|;
name|int
name|value
init|=
literal|0
decl_stmt|;
name|int
name|this
decl_stmt|;
comment|/* If N_SETS hit the limit, we can't rely on its value.  */
if|if
condition|(
name|n_sets
operator|==
literal|127
condition|)
return|return
literal|0
return|;
name|VARRAY_INT
argument_list|(
name|set_in_loop
argument_list|,
name|regno
argument_list|)
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|count
operator|>
literal|0
condition|)
block|{
specifier|register
name|enum
name|rtx_code
name|code
decl_stmt|;
name|rtx
name|set
decl_stmt|;
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* If library call, skip to end of it.  */
if|if
condition|(
name|code
operator|==
name|INSN
operator|&&
operator|(
name|temp
operator|=
name|find_reg_note
argument_list|(
name|p
argument_list|,
name|REG_LIBCALL
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
condition|)
name|p
operator|=
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|this
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|INSN
operator|&&
operator|(
name|set
operator|=
name|single_set
argument_list|(
name|p
argument_list|)
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|regno
condition|)
block|{
name|this
operator|=
name|invariant_p
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|!=
literal|0
condition|)
name|value
operator||=
name|this
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|temp
operator|=
name|find_reg_note
argument_list|(
name|p
argument_list|,
name|REG_EQUAL
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
condition|)
block|{
comment|/* If this is a libcall, then any invariant REG_EQUAL note is OK. 		 If this is an ordinary insn, then only CONSTANT_P REG_EQUAL 		 notes are OK.  */
name|this
operator|=
operator|(
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
operator|(
name|find_reg_note
argument_list|(
name|p
argument_list|,
name|REG_RETVAL
argument_list|,
name|NULL_RTX
argument_list|)
operator|&&
name|invariant_p
argument_list|(
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|this
operator|!=
literal|0
condition|)
name|value
operator||=
name|this
expr_stmt|;
block|}
block|}
if|if
condition|(
name|this
operator|!=
literal|0
condition|)
name|count
operator|--
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|!=
name|NOTE
condition|)
block|{
name|VARRAY_INT
argument_list|(
name|set_in_loop
argument_list|,
name|regno
argument_list|)
operator|=
name|old
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|VARRAY_INT
argument_list|(
name|set_in_loop
argument_list|,
name|regno
argument_list|)
operator|=
name|old
expr_stmt|;
comment|/* If invariant_p ever returned 2, we return 2.  */
return|return
literal|1
operator|+
operator|(
name|value
operator|&
literal|2
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* I don't think this condition is sufficient to allow INSN    to be moved, so we no longer test it.  */
end_comment

begin_comment
comment|/* Return 1 if all insns in the basic block of INSN and following INSN    that set REG are invariant according to TABLE.  */
end_comment

begin_endif
unit|static int all_sets_invariant_p (reg, insn, table)      rtx reg, insn;      short *table; {   register rtx p = insn;   register int regno = REGNO (reg);    while (1)     {       register enum rtx_code code;       p = NEXT_INSN (p);       code = GET_CODE (p);       if (code == CODE_LABEL || code == JUMP_INSN) 	return 1;       if (code == INSN&& GET_CODE (PATTERN (p)) == SET&& GET_CODE (SET_DEST (PATTERN (p))) == REG&& REGNO (SET_DEST (PATTERN (p))) == regno) 	{ 	  if (!invariant_p (SET_SRC (PATTERN (p)), table)) 	    return 0; 	}     } }
endif|#
directive|endif
end_endif

begin_comment
comment|/* 0 */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Look at all uses (not sets) of registers in X.  For each, if it is    the single use, set USAGE[REGNO] to INSN; if there was a previous use in    a different insn, set USAGE[REGNO] to const0_rtx.  */
end_comment

begin_function
specifier|static
name|void
name|find_single_use_in_loop
parameter_list|(
name|insn
parameter_list|,
name|x
parameter_list|,
name|usage
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|varray_type
name|usage
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|char
modifier|*
name|fmt
init|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|REG
condition|)
name|VARRAY_RTX
argument_list|(
name|usage
argument_list|,
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
operator|=
operator|(
name|VARRAY_RTX
argument_list|(
name|usage
argument_list|,
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
literal|0
operator|&&
name|VARRAY_RTX
argument_list|(
name|usage
argument_list|,
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|insn
operator|)
condition|?
name|const0_rtx
else|:
name|insn
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|SET
condition|)
block|{
comment|/* Don't count SET_DEST if it is a REG; otherwise count things 	 in SET_DEST because if a register is partially modified, it won't 	 show up as a potential movable so we don't care how USAGE is set  	 for it.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|REG
condition|)
name|find_single_use_in_loop
argument_list|(
name|insn
argument_list|,
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
name|usage
argument_list|)
expr_stmt|;
name|find_single_use_in_loop
argument_list|(
name|insn
argument_list|,
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|usage
argument_list|)
expr_stmt|;
block|}
else|else
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
operator|&&
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
literal|0
condition|)
name|find_single_use_in_loop
argument_list|(
name|insn
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|usage
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
name|find_single_use_in_loop
argument_list|(
name|insn
argument_list|,
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|usage
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Count and record any set in X which is contained in INSN.  Update    MAY_NOT_MOVE and LAST_SET for any register set in X.  */
end_comment

begin_function
specifier|static
name|void
name|count_one_set
parameter_list|(
name|insn
parameter_list|,
name|x
parameter_list|,
name|may_not_move
parameter_list|,
name|last_set
parameter_list|)
name|rtx
name|insn
decl_stmt|,
name|x
decl_stmt|;
name|varray_type
name|may_not_move
decl_stmt|;
name|rtx
modifier|*
name|last_set
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CLOBBER
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
comment|/* Don't move a reg that has an explicit clobber.        It's not worth the pain to try to do it correctly.  */
name|VARRAY_CHAR
argument_list|(
name|may_not_move
argument_list|,
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SET
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CLOBBER
condition|)
block|{
name|rtx
name|dest
init|=
name|SET_DEST
argument_list|(
name|x
argument_list|)
decl_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SIGN_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|STRICT_LOW_PART
condition|)
name|dest
operator|=
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
condition|)
block|{
specifier|register
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|dest
argument_list|)
decl_stmt|;
comment|/* If this is the first setting of this reg 	     in current basic block, and it was set before, 	     it must be set in two basic blocks, so it cannot 	     be moved out of the loop.  */
if|if
condition|(
name|VARRAY_INT
argument_list|(
name|set_in_loop
argument_list|,
name|regno
argument_list|)
operator|>
literal|0
operator|&&
name|last_set
index|[
name|regno
index|]
operator|==
literal|0
condition|)
name|VARRAY_CHAR
argument_list|(
name|may_not_move
argument_list|,
name|regno
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* If this is not first setting in current basic block, 	     see if reg was used in between previous one and this. 	     If so, neither one can be moved.  */
if|if
condition|(
name|last_set
index|[
name|regno
index|]
operator|!=
literal|0
operator|&&
name|reg_used_between_p
argument_list|(
name|dest
argument_list|,
name|last_set
index|[
name|regno
index|]
argument_list|,
name|insn
argument_list|)
condition|)
name|VARRAY_CHAR
argument_list|(
name|may_not_move
argument_list|,
name|regno
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|VARRAY_INT
argument_list|(
name|set_in_loop
argument_list|,
name|regno
argument_list|)
operator|<
literal|127
condition|)
operator|++
name|VARRAY_INT
argument_list|(
name|set_in_loop
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|last_set
index|[
name|regno
index|]
operator|=
name|insn
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Increment SET_IN_LOOP at the index of each register    that is modified by an insn between FROM and TO.    If the value of an element of SET_IN_LOOP becomes 127 or more,    stop incrementing it, to avoid overflow.     Store in SINGLE_USAGE[I] the single insn in which register I is    used, if it is only used once.  Otherwise, it is set to 0 (for no    uses) or const0_rtx for more than one use.  This parameter may be zero,    in which case this processing is not done.     Store in *COUNT_PTR the number of actual instruction    in the loop.  We use this to decide what is worth moving out.  */
end_comment

begin_comment
comment|/* last_set[n] is nonzero iff reg n has been set in the current basic block.    In that case, it is the insn that last set reg n.  */
end_comment

begin_function
specifier|static
name|void
name|count_loop_regs_set
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|,
name|may_not_move
parameter_list|,
name|single_usage
parameter_list|,
name|count_ptr
parameter_list|,
name|nregs
parameter_list|)
specifier|register
name|rtx
name|from
decl_stmt|,
name|to
decl_stmt|;
name|varray_type
name|may_not_move
decl_stmt|;
name|varray_type
name|single_usage
decl_stmt|;
name|int
modifier|*
name|count_ptr
decl_stmt|;
name|int
name|nregs
decl_stmt|;
block|{
specifier|register
name|rtx
modifier|*
name|last_set
init|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|nregs
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
decl_stmt|;
specifier|register
name|rtx
name|insn
decl_stmt|;
specifier|register
name|int
name|count
init|=
literal|0
decl_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|last_set
argument_list|,
name|nregs
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|from
init|;
name|insn
operator|!=
name|to
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
literal|'i'
condition|)
block|{
operator|++
name|count
expr_stmt|;
comment|/* Record registers that have exactly one use.  */
name|find_single_use_in_loop
argument_list|(
name|insn
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|single_usage
argument_list|)
expr_stmt|;
comment|/* Include uses in REG_EQUAL notes.  */
if|if
condition|(
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
condition|)
name|find_single_use_in_loop
argument_list|(
name|insn
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|,
name|single_usage
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|CLOBBER
condition|)
name|count_one_set
argument_list|(
name|insn
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|may_not_move
argument_list|,
name|last_set
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|count_one_set
argument_list|(
name|insn
argument_list|,
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|may_not_move
argument_list|,
name|last_set
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|last_set
argument_list|,
name|nregs
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|*
name|count_ptr
operator|=
name|count
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a loop that is bounded by LOOP_START and LOOP_END    and that is entered at SCAN_START,    return 1 if the register set in SET contained in insn INSN is used by    any insn that precedes INSN in cyclic order starting    from the loop entry point.     We don't want to use INSN_LUID here because if we restrict INSN to those    that have a valid INSN_LUID, it means we cannot move an invariant out    from an inner loop past two loops.  */
end_comment

begin_function
specifier|static
name|int
name|loop_reg_used_before_p
parameter_list|(
name|set
parameter_list|,
name|insn
parameter_list|,
name|loop_start
parameter_list|,
name|scan_start
parameter_list|,
name|loop_end
parameter_list|)
name|rtx
name|set
decl_stmt|,
name|insn
decl_stmt|,
name|loop_start
decl_stmt|,
name|scan_start
decl_stmt|,
name|loop_end
decl_stmt|;
block|{
name|rtx
name|reg
init|=
name|SET_DEST
argument_list|(
name|set
argument_list|)
decl_stmt|;
name|rtx
name|p
decl_stmt|;
comment|/* Scan forward checking for register usage.  If we hit INSN, we      are done.  Otherwise, if we hit LOOP_END, wrap around to LOOP_START.  */
for|for
control|(
name|p
operator|=
name|scan_start
init|;
name|p
operator|!=
name|insn
condition|;
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
argument_list|)
operator|==
literal|'i'
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|reg
argument_list|,
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|p
operator|==
name|loop_end
condition|)
name|p
operator|=
name|loop_start
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* A "basic induction variable" or biv is a pseudo reg that is set    (within this loop) only by incrementing or decrementing it.  */
end_comment

begin_comment
comment|/* A "general induction variable" or giv is a pseudo reg whose    value is a linear function of a biv.  */
end_comment

begin_comment
comment|/* Bivs are recognized by `basic_induction_var';    Givs by `general_induction_var'.  */
end_comment

begin_comment
comment|/* Indexed by register number, indicates whether or not register is an    induction variable, and if so what type.  */
end_comment

begin_decl_stmt
name|varray_type
name|reg_iv_type
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by register number, contains pointer to `struct induction'    if register is an induction variable.  This holds general info for    all induction variables.  */
end_comment

begin_decl_stmt
name|varray_type
name|reg_iv_info
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by register number, contains pointer to `struct iv_class'    if register is a basic induction variable.  This holds info describing    the class (a related group) of induction variables that the biv belongs    to.  */
end_comment

begin_decl_stmt
name|struct
name|iv_class
modifier|*
modifier|*
name|reg_biv_class
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The head of a list which links together (via the next field)    every iv class for the current loop.  */
end_comment

begin_decl_stmt
name|struct
name|iv_class
modifier|*
name|loop_iv_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Givs made from biv increments are always splittable for loop unrolling.    Since there is no regscan info for them, we have to keep track of them    separately.  */
end_comment

begin_decl_stmt
name|int
name|first_increment_giv
decl_stmt|,
name|last_increment_giv
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Communication with routines called via `note_stores'.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|note_insn
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Dummy register to have non-zero DEST_REG for DEST_ADDR type givs.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|addr_placeholder
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ??? Unfinished optimizations, and possible future optimizations,    for the strength reduction code.  */
end_comment

begin_comment
comment|/* ??? The interaction of biv elimination, and recognition of 'constant'    bivs, may cause problems.  */
end_comment

begin_comment
comment|/* ??? Add heuristics so that DEST_ADDR strength reduction does not cause    performance problems.     Perhaps don't eliminate things that can be combined with an addressing    mode.  Find all givs that have the same biv, mult_val, and add_val;    then for each giv, check to see if its only use dies in a following    memory address.  If so, generate a new memory address and check to see    if it is valid.   If it is valid, then store the modified memory address,    otherwise, mark the giv as not done so that it will get its own iv.  */
end_comment

begin_comment
comment|/* ??? Could try to optimize branches when it is known that a biv is always    positive.  */
end_comment

begin_comment
comment|/* ??? When replace a biv in a compare insn, we should replace with closest    giv so that an optimized branch can still be recognized by the combiner,    e.g. the VAX acb insn.  */
end_comment

begin_comment
comment|/* ??? Many of the checks involving uid_luid could be simplified if regscan    was rerun in loop_optimize whenever a register was added or moved.    Also, some of the optimizations could be a little less conservative.  */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Perform strength reduction and induction variable elimination.       Pseudo registers created during this function will be beyond the last    valid index in several tables including n_times_set and regno_last_uid.    This does not cause a problem here, because the added registers cannot be    givs outside of their loop, and hence will never be reconsidered.    But scan_loop must check regnos to make sure they are in bounds.         SCAN_START is the first instruction in the loop, as the loop would    actually be executed.  END is the NOTE_INSN_LOOP_END.  LOOP_TOP is    the first instruction in the loop, as it is layed out in the    instruction stream.  LOOP_START is the NOTE_INSN_LOOP_BEG.    LOOP_CONT is the NOTE_INSN_LOOP_CONT.  */
end_comment

begin_function
specifier|static
name|void
name|strength_reduce
parameter_list|(
name|scan_start
parameter_list|,
name|end
parameter_list|,
name|loop_top
parameter_list|,
name|insn_count
parameter_list|,
name|loop_start
parameter_list|,
name|loop_end
parameter_list|,
name|loop_cont
parameter_list|,
name|unroll_p
parameter_list|,
name|bct_p
parameter_list|)
name|rtx
name|scan_start
decl_stmt|;
name|rtx
name|end
decl_stmt|;
name|rtx
name|loop_top
decl_stmt|;
name|int
name|insn_count
decl_stmt|;
name|rtx
name|loop_start
decl_stmt|;
name|rtx
name|loop_end
decl_stmt|;
name|rtx
name|loop_cont
decl_stmt|;
name|int
name|unroll_p
decl_stmt|,
name|bct_p
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|rtx
name|p
decl_stmt|;
name|rtx
name|set
decl_stmt|;
name|rtx
name|inc_val
decl_stmt|;
name|rtx
name|mult_val
decl_stmt|;
name|rtx
name|dest_reg
decl_stmt|;
name|rtx
modifier|*
name|location
decl_stmt|;
comment|/* This is 1 if current insn is not executed at least once for every loop      iteration.  */
name|int
name|not_every_iteration
init|=
literal|0
decl_stmt|;
comment|/* This is 1 if current insn may be executed more than once for every      loop iteration.  */
name|int
name|maybe_multiple
init|=
literal|0
decl_stmt|;
comment|/* This is 1 if we have past a branch back to the top of the loop      (aka a loop latch).  */
name|int
name|past_loop_latch
init|=
literal|0
decl_stmt|;
comment|/* Temporary list pointers for traversing loop_iv_list.  */
name|struct
name|iv_class
modifier|*
name|bl
decl_stmt|,
modifier|*
modifier|*
name|backbl
decl_stmt|;
comment|/* Ratio of extra register life span we can justify      for saving an instruction.  More if loop doesn't call subroutines      since in that case saving an insn makes more difference      and more registers are available.  */
comment|/* ??? could set this to last value of threshold in move_movables */
name|int
name|threshold
init|=
operator|(
name|loop_has_call
condition|?
literal|1
else|:
literal|2
operator|)
operator|*
operator|(
literal|3
operator|+
name|n_non_fixed_regs
operator|)
decl_stmt|;
comment|/* Map of pseudo-register replacements.  */
name|rtx
modifier|*
name|reg_map
decl_stmt|;
name|int
name|reg_map_size
decl_stmt|;
name|int
name|call_seen
decl_stmt|;
name|rtx
name|test
decl_stmt|;
name|rtx
name|end_insert_before
decl_stmt|;
name|int
name|loop_depth
init|=
literal|0
decl_stmt|;
name|int
name|n_extra_increment
decl_stmt|;
name|struct
name|loop_info
name|loop_iteration_info
decl_stmt|;
name|struct
name|loop_info
modifier|*
name|loop_info
init|=
operator|&
name|loop_iteration_info
decl_stmt|;
comment|/* If scan_start points to the loop exit test, we have to be wary of      subversive use of gotos inside expression statements.  */
if|if
condition|(
name|prev_nonnote_insn
argument_list|(
name|scan_start
argument_list|)
operator|!=
name|prev_nonnote_insn
argument_list|(
name|loop_start
argument_list|)
condition|)
name|maybe_multiple
operator|=
name|back_branch_in_range_p
argument_list|(
name|scan_start
argument_list|,
name|loop_start
argument_list|,
name|loop_end
argument_list|)
expr_stmt|;
name|VARRAY_INT_INIT
argument_list|(
name|reg_iv_type
argument_list|,
name|max_reg_before_loop
argument_list|,
literal|"reg_iv_type"
argument_list|)
expr_stmt|;
name|VARRAY_GENERIC_PTR_INIT
argument_list|(
name|reg_iv_info
argument_list|,
name|max_reg_before_loop
argument_list|,
literal|"reg_iv_info"
argument_list|)
expr_stmt|;
name|reg_biv_class
operator|=
operator|(
expr|struct
name|iv_class
operator|*
operator|*
operator|)
name|alloca
argument_list|(
name|max_reg_before_loop
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|iv_class
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|reg_biv_class
argument_list|,
operator|(
name|max_reg_before_loop
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|iv_class
operator|*
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|loop_iv_list
operator|=
literal|0
expr_stmt|;
name|addr_placeholder
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
comment|/* Save insn immediately after the loop_end.  Insns inserted after loop_end      must be put before this insn, so that they will appear in the right      order (i.e. loop order).        If loop_end is the end of the current function, then emit a       NOTE_INSN_DELETED after loop_end and set end_insert_before to the      dummy note insn.  */
if|if
condition|(
name|NEXT_INSN
argument_list|(
name|loop_end
argument_list|)
operator|!=
literal|0
condition|)
name|end_insert_before
operator|=
name|NEXT_INSN
argument_list|(
name|loop_end
argument_list|)
expr_stmt|;
else|else
name|end_insert_before
operator|=
name|emit_note_after
argument_list|(
name|NOTE_INSN_DELETED
argument_list|,
name|loop_end
argument_list|)
expr_stmt|;
comment|/* Scan through loop to find all possible bivs.  */
for|for
control|(
name|p
operator|=
name|next_insn_in_loop
argument_list|(
name|scan_start
argument_list|,
name|scan_start
argument_list|,
name|end
argument_list|,
name|loop_top
argument_list|)
init|;
name|p
operator|!=
name|NULL_RTX
condition|;
name|p
operator|=
name|next_insn_in_loop
argument_list|(
name|p
argument_list|,
name|scan_start
argument_list|,
name|end
argument_list|,
name|loop_top
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|INSN
operator|&&
operator|(
name|set
operator|=
name|single_set
argument_list|(
name|p
argument_list|)
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|dest_reg
operator|=
name|SET_DEST
argument_list|(
name|set
argument_list|)
expr_stmt|;
if|if
condition|(
name|REGNO
argument_list|(
name|dest_reg
argument_list|)
operator|<
name|max_reg_before_loop
operator|&&
name|REGNO
argument_list|(
name|dest_reg
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|REG_IV_TYPE
argument_list|(
name|REGNO
argument_list|(
name|dest_reg
argument_list|)
argument_list|)
operator|!=
name|NOT_BASIC_INDUCT
condition|)
block|{
if|if
condition|(
name|basic_induction_var
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
argument_list|,
name|dest_reg
argument_list|,
name|p
argument_list|,
operator|&
name|inc_val
argument_list|,
operator|&
name|mult_val
argument_list|,
operator|&
name|location
argument_list|)
condition|)
block|{
comment|/* It is a possible basic induction variable. 		     Create and initialize an induction structure for it.  */
name|struct
name|induction
modifier|*
name|v
init|=
operator|(
expr|struct
name|induction
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|induction
argument_list|)
argument_list|)
decl_stmt|;
name|record_biv
argument_list|(
name|v
argument_list|,
name|p
argument_list|,
name|dest_reg
argument_list|,
name|inc_val
argument_list|,
name|mult_val
argument_list|,
name|location
argument_list|,
name|not_every_iteration
argument_list|,
name|maybe_multiple
argument_list|)
expr_stmt|;
name|REG_IV_TYPE
argument_list|(
name|REGNO
argument_list|(
name|dest_reg
argument_list|)
argument_list|)
operator|=
name|BASIC_INDUCT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|REGNO
argument_list|(
name|dest_reg
argument_list|)
operator|<
name|max_reg_before_loop
condition|)
name|REG_IV_TYPE
argument_list|(
name|REGNO
argument_list|(
name|dest_reg
argument_list|)
argument_list|)
operator|=
name|NOT_BASIC_INDUCT
expr_stmt|;
block|}
block|}
comment|/* Past CODE_LABEL, we get to insns that may be executed multiple 	 times.  The only way we can be sure that they can't is if every 	 jump insn between here and the end of the loop either 	 returns, exits the loop, is a jump to a location that is still 	 behind the label, or is a jump to the loop start.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|CODE_LABEL
condition|)
block|{
name|rtx
name|insn
init|=
name|p
decl_stmt|;
name|maybe_multiple
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|==
name|scan_start
condition|)
break|break;
if|if
condition|(
name|insn
operator|==
name|end
condition|)
block|{
if|if
condition|(
name|loop_top
operator|!=
literal|0
condition|)
name|insn
operator|=
name|loop_top
expr_stmt|;
else|else
break|break;
if|if
condition|(
name|insn
operator|==
name|scan_start
condition|)
break|break;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|RETURN
operator|&&
operator|(
operator|!
name|condjump_p
argument_list|(
name|insn
argument_list|)
operator|||
operator|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
operator|!=
literal|0
operator|&&
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
operator|!=
name|scan_start
operator|&&
operator|!
name|loop_insn_first_p
argument_list|(
name|p
argument_list|,
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
block|{
name|maybe_multiple
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* Past a jump, we get to insns for which we can't count 	 on whether they will be executed during each iteration.  */
comment|/* This code appears twice in strength_reduce.  There is also similar 	 code in scan_loop.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|JUMP_INSN
comment|/* If we enter the loop in the middle, and scan around to the 	     beginning, don't set not_every_iteration for that. 	     This can be any kind of jump, since we want to know if insns 	     will be executed if the loop is executed.  */
operator|&&
operator|!
operator|(
name|JUMP_LABEL
argument_list|(
name|p
argument_list|)
operator|==
name|loop_top
operator|&&
operator|(
operator|(
name|NEXT_INSN
argument_list|(
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
argument_list|)
operator|==
name|loop_end
operator|&&
name|simplejump_p
argument_list|(
name|p
argument_list|)
operator|)
operator|||
operator|(
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
operator|==
name|loop_end
operator|&&
name|condjump_p
argument_list|(
name|p
argument_list|)
operator|)
operator|)
operator|)
condition|)
block|{
name|rtx
name|label
init|=
literal|0
decl_stmt|;
comment|/* If this is a jump outside the loop, then it also doesn't 	     matter.  Check to see if the target of this branch is on the 	     loop_number_exits_labels list.  */
for|for
control|(
name|label
operator|=
name|loop_number_exit_labels
index|[
name|uid_loop_num
index|[
name|INSN_UID
argument_list|(
name|loop_start
argument_list|)
index|]
index|]
init|;
name|label
condition|;
name|label
operator|=
name|LABEL_NEXTREF
argument_list|(
name|label
argument_list|)
control|)
if|if
condition|(
name|XEXP
argument_list|(
name|label
argument_list|,
literal|0
argument_list|)
operator|==
name|JUMP_LABEL
argument_list|(
name|p
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|!
name|label
condition|)
name|not_every_iteration
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|NOTE
condition|)
block|{
comment|/* At the virtual top of a converted loop, insns are again known to 	     be executed each iteration: logically, the loop begins here 	     even though the exit code has been duplicated.  	     Insns are also again known to be executed each iteration at 	     the LOOP_CONT note.  */
if|if
condition|(
operator|(
name|NOTE_LINE_NUMBER
argument_list|(
name|p
argument_list|)
operator|==
name|NOTE_INSN_LOOP_VTOP
operator|||
name|NOTE_LINE_NUMBER
argument_list|(
name|p
argument_list|)
operator|==
name|NOTE_INSN_LOOP_CONT
operator|)
operator|&&
name|loop_depth
operator|==
literal|0
condition|)
name|not_every_iteration
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|p
argument_list|)
operator|==
name|NOTE_INSN_LOOP_BEG
condition|)
name|loop_depth
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|p
argument_list|)
operator|==
name|NOTE_INSN_LOOP_END
condition|)
name|loop_depth
operator|--
expr_stmt|;
block|}
comment|/* Note if we pass a loop latch.  If we do, then we can not clear 	 NOT_EVERY_ITERATION below when we pass the last CODE_LABEL in 	 a loop since a jump before the last CODE_LABEL may have started 	 a new loop iteration.  	 Note that LOOP_TOP is only set for rotated loops and we need 	 this check for all loops, so compare against the CODE_LABEL 	 which immediately follows LOOP_START.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|JUMP_LABEL
argument_list|(
name|p
argument_list|)
operator|==
name|NEXT_INSN
argument_list|(
name|loop_start
argument_list|)
condition|)
name|past_loop_latch
operator|=
literal|1
expr_stmt|;
comment|/* Unlike in the code motion pass where MAYBE_NEVER indicates that 	 an insn may never be executed, NOT_EVERY_ITERATION indicates whether 	 or not an insn is known to be executed each iteration of the 	 loop, whether or not any iterations are known to occur.  	 Therefore, if we have just passed a label and have no more labels 	 between here and the test insn of the loop, and we have not passed 	 a jump to the top of the loop, then we know these insns will be 	 executed each iteration.  */
if|if
condition|(
name|not_every_iteration
operator|&&
operator|!
name|past_loop_latch
operator|&&
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|CODE_LABEL
operator|&&
name|no_labels_between_p
argument_list|(
name|p
argument_list|,
name|loop_end
argument_list|)
operator|&&
name|loop_insn_first_p
argument_list|(
name|p
argument_list|,
name|loop_cont
argument_list|)
condition|)
name|not_every_iteration
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Scan loop_iv_list to remove all regs that proved not to be bivs.      Make a sanity check against n_times_set.  */
for|for
control|(
name|backbl
operator|=
operator|&
name|loop_iv_list
operator|,
name|bl
operator|=
operator|*
name|backbl
init|;
name|bl
condition|;
name|bl
operator|=
name|bl
operator|->
name|next
control|)
block|{
if|if
condition|(
name|REG_IV_TYPE
argument_list|(
name|bl
operator|->
name|regno
argument_list|)
operator|!=
name|BASIC_INDUCT
comment|/* Above happens if register modified by subreg, etc.  */
comment|/* Make sure it is not recognized as a basic induction var: */
operator|||
name|VARRAY_INT
argument_list|(
name|n_times_set
argument_list|,
name|bl
operator|->
name|regno
argument_list|)
operator|!=
name|bl
operator|->
name|biv_count
comment|/* If never incremented, it is invariant that we decided not to 	     move.  So leave it alone.  */
operator|||
operator|!
name|bl
operator|->
name|incremented
condition|)
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Reg %d: biv discarded, %s\n"
argument_list|,
name|bl
operator|->
name|regno
argument_list|,
operator|(
name|REG_IV_TYPE
argument_list|(
name|bl
operator|->
name|regno
argument_list|)
operator|!=
name|BASIC_INDUCT
condition|?
literal|"not induction variable"
else|:
operator|(
operator|!
name|bl
operator|->
name|incremented
condition|?
literal|"never incremented"
else|:
literal|"count error"
operator|)
operator|)
argument_list|)
expr_stmt|;
name|REG_IV_TYPE
argument_list|(
name|bl
operator|->
name|regno
argument_list|)
operator|=
name|NOT_BASIC_INDUCT
expr_stmt|;
operator|*
name|backbl
operator|=
name|bl
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
name|backbl
operator|=
operator|&
name|bl
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Reg %d: biv verified\n"
argument_list|,
name|bl
operator|->
name|regno
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Exit if there are no bivs.  */
if|if
condition|(
operator|!
name|loop_iv_list
condition|)
block|{
comment|/* Can still unroll the loop anyways, but indicate that there is no 	 strength reduction info available.  */
if|if
condition|(
name|unroll_p
condition|)
name|unroll_loop
argument_list|(
name|loop_end
argument_list|,
name|insn_count
argument_list|,
name|loop_start
argument_list|,
name|end_insert_before
argument_list|,
name|loop_info
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Find initial value for each biv by searching backwards from loop_start,      halting at first label.  Also record any test condition.  */
name|call_seen
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|loop_start
init|;
name|p
operator|&&
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|!=
name|CODE_LABEL
condition|;
name|p
operator|=
name|PREV_INSN
argument_list|(
name|p
argument_list|)
control|)
block|{
name|note_insn
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|CALL_INSN
condition|)
name|call_seen
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|JUMP_INSN
operator|||
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|CALL_INSN
condition|)
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|,
name|record_initial
argument_list|)
expr_stmt|;
comment|/* Record any test of a biv that branches around the loop if no store 	 between it and the start of loop.  We only care about tests with 	 constants and registers and only certain of those.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|JUMP_LABEL
argument_list|(
name|p
argument_list|)
operator|!=
literal|0
operator|&&
name|next_real_insn
argument_list|(
name|JUMP_LABEL
argument_list|(
name|p
argument_list|)
argument_list|)
operator|==
name|next_real_insn
argument_list|(
name|loop_end
argument_list|)
operator|&&
operator|(
name|test
operator|=
name|get_condition_for_loop
argument_list|(
name|p
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|test
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|test
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|<
name|max_reg_before_loop
operator|&&
operator|(
name|bl
operator|=
name|reg_biv_class
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|test
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
operator|)
operator|!=
literal|0
operator|&&
name|valid_initial_value_p
argument_list|(
name|XEXP
argument_list|(
name|test
argument_list|,
literal|1
argument_list|)
argument_list|,
name|p
argument_list|,
name|call_seen
argument_list|,
name|loop_start
argument_list|)
operator|&&
name|bl
operator|->
name|init_insn
operator|==
literal|0
condition|)
block|{
comment|/* If an NE test, we have an initial value!  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|test
argument_list|)
operator|==
name|NE
condition|)
block|{
name|bl
operator|->
name|init_insn
operator|=
name|p
expr_stmt|;
name|bl
operator|->
name|init_set
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|XEXP
argument_list|(
name|test
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|test
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|bl
operator|->
name|initial_test
operator|=
name|test
expr_stmt|;
block|}
block|}
comment|/* Look at the each biv and see if we can say anything better about its      initial value from any initializing insns set up above.  (This is done      in two passes to avoid missing SETs in a PARALLEL.)  */
for|for
control|(
name|backbl
operator|=
operator|&
name|loop_iv_list
init|;
operator|(
name|bl
operator|=
operator|*
name|backbl
operator|)
condition|;
name|backbl
operator|=
operator|&
name|bl
operator|->
name|next
control|)
block|{
name|rtx
name|src
decl_stmt|;
name|rtx
name|note
decl_stmt|;
if|if
condition|(
operator|!
name|bl
operator|->
name|init_insn
condition|)
continue|continue;
comment|/* IF INIT_INSN has a REG_EQUAL or REG_EQUIV note and the value 	 is a constant, use the value of that.  */
if|if
condition|(
operator|(
operator|(
name|note
operator|=
name|find_reg_note
argument_list|(
name|bl
operator|->
name|init_insn
argument_list|,
name|REG_EQUAL
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
operator|(
name|note
operator|=
name|find_reg_note
argument_list|(
name|bl
operator|->
name|init_insn
argument_list|,
name|REG_EQUIV
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
condition|)
name|src
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|src
operator|=
name|SET_SRC
argument_list|(
name|bl
operator|->
name|init_set
argument_list|)
expr_stmt|;
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Biv %d initialized at insn %d: initial value "
argument_list|,
name|bl
operator|->
name|regno
argument_list|,
name|INSN_UID
argument_list|(
name|bl
operator|->
name|init_insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|GET_MODE
argument_list|(
name|src
argument_list|)
operator|==
name|GET_MODE
argument_list|(
name|regno_reg_rtx
index|[
name|bl
operator|->
name|regno
index|]
argument_list|)
operator|||
name|GET_MODE
argument_list|(
name|src
argument_list|)
operator|==
name|VOIDmode
operator|)
operator|&&
name|valid_initial_value_p
argument_list|(
name|src
argument_list|,
name|bl
operator|->
name|init_insn
argument_list|,
name|call_seen
argument_list|,
name|loop_start
argument_list|)
condition|)
block|{
name|bl
operator|->
name|initial_value
operator|=
name|src
expr_stmt|;
if|if
condition|(
name|loop_dump_stream
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|INTVAL
argument_list|(
name|src
argument_list|)
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|loop_dump_stream
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|print_rtl
argument_list|(
name|loop_dump_stream
argument_list|,
name|src
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|struct
name|iv_class
modifier|*
name|bl2
init|=
literal|0
decl_stmt|;
name|rtx
name|increment
decl_stmt|;
comment|/* Biv initial value is not a simple move.  If it is the sum of 	     another biv and a constant, check if both bivs are incremented 	     in lockstep.  Then we are actually looking at a giv. 	     For simplicity, we only handle the case where there is but a 	     single increment, and the register is not used elsewhere.  */
if|if
condition|(
name|bl
operator|->
name|biv_count
operator|==
literal|1
operator|&&
name|bl
operator|->
name|regno
operator|<
name|max_reg_before_loop
operator|&&
name|uid_luid
index|[
name|REGNO_LAST_UID
argument_list|(
name|bl
operator|->
name|regno
argument_list|)
index|]
operator|<
name|INSN_LUID
argument_list|(
name|loop_end
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
operator|(
operator|(
name|increment
operator|=
name|biv_total_increment
argument_list|(
name|bl
argument_list|,
name|loop_start
argument_list|,
name|loop_end
argument_list|)
operator|)
operator|!=
name|NULL_RTX
operator|)
condition|)
block|{
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|bl2
operator|=
name|loop_iv_list
init|;
name|bl2
condition|;
name|bl2
operator|=
name|bl2
operator|->
name|next
control|)
if|if
condition|(
name|bl2
operator|->
name|regno
operator|==
name|regno
condition|)
break|break;
block|}
comment|/* Now, can we transform this biv into a giv?  */
if|if
condition|(
name|bl2
operator|&&
name|bl2
operator|->
name|biv_count
operator|==
literal|1
operator|&&
name|rtx_equal_p
argument_list|(
name|increment
argument_list|,
name|biv_total_increment
argument_list|(
name|bl2
argument_list|,
name|loop_start
argument_list|,
name|loop_end
argument_list|)
argument_list|)
comment|/* init_insn is only set to insns that are before loop_start 		 without any intervening labels.  */
operator|&&
operator|!
name|reg_set_between_p
argument_list|(
name|bl2
operator|->
name|biv
operator|->
name|src_reg
argument_list|,
name|PREV_INSN
argument_list|(
name|bl
operator|->
name|init_insn
argument_list|)
argument_list|,
name|loop_start
argument_list|)
comment|/* The register from BL2 must be set before the register from 		 BL is set, or we must be able to move the latter set after 		 the former set.  Currently there can't be any labels 	         in-between when biv_toal_increment returns nonzero both times 		 but we test it here in case some day some real cfg analysis 		 gets used to set always_computable.  */
operator|&&
operator|(
operator|(
name|loop_insn_first_p
argument_list|(
name|bl2
operator|->
name|biv
operator|->
name|insn
argument_list|,
name|bl
operator|->
name|biv
operator|->
name|insn
argument_list|)
operator|&&
name|no_labels_between_p
argument_list|(
name|bl2
operator|->
name|biv
operator|->
name|insn
argument_list|,
name|bl
operator|->
name|biv
operator|->
name|insn
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|reg_used_between_p
argument_list|(
name|bl
operator|->
name|biv
operator|->
name|src_reg
argument_list|,
name|bl
operator|->
name|biv
operator|->
name|insn
argument_list|,
name|bl2
operator|->
name|biv
operator|->
name|insn
argument_list|)
operator|&&
name|no_jumps_between_p
argument_list|(
name|bl
operator|->
name|biv
operator|->
name|insn
argument_list|,
name|bl2
operator|->
name|biv
operator|->
name|insn
argument_list|)
operator|)
operator|)
operator|&&
name|validate_change
argument_list|(
name|bl
operator|->
name|biv
operator|->
name|insn
argument_list|,
operator|&
name|SET_SRC
argument_list|(
name|single_set
argument_list|(
name|bl
operator|->
name|biv
operator|->
name|insn
argument_list|)
argument_list|)
argument_list|,
name|copy_rtx
argument_list|(
name|src
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|int
name|loop_num
init|=
name|uid_loop_num
index|[
name|INSN_UID
argument_list|(
name|loop_start
argument_list|)
index|]
decl_stmt|;
name|rtx
name|dominator
init|=
name|loop_number_cont_dominator
index|[
name|loop_num
index|]
decl_stmt|;
name|rtx
name|giv
init|=
name|bl
operator|->
name|biv
operator|->
name|src_reg
decl_stmt|;
name|rtx
name|giv_insn
init|=
name|bl
operator|->
name|biv
operator|->
name|insn
decl_stmt|;
name|rtx
name|after_giv
init|=
name|NEXT_INSN
argument_list|(
name|giv_insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"is giv of biv %d\n"
argument_list|,
name|bl2
operator|->
name|regno
argument_list|)
expr_stmt|;
comment|/* Let this giv be discovered by the generic code.  */
name|REG_IV_TYPE
argument_list|(
name|bl
operator|->
name|regno
argument_list|)
operator|=
name|UNKNOWN_INDUCT
expr_stmt|;
comment|/* We can get better optimization if we can move the giv setting 		 before the first giv use.  */
if|if
condition|(
name|dominator
operator|&&
operator|!
name|loop_insn_first_p
argument_list|(
name|dominator
argument_list|,
name|scan_start
argument_list|)
operator|&&
operator|!
name|reg_set_between_p
argument_list|(
name|bl2
operator|->
name|biv
operator|->
name|src_reg
argument_list|,
name|loop_start
argument_list|,
name|dominator
argument_list|)
operator|&&
operator|!
name|reg_used_between_p
argument_list|(
name|giv
argument_list|,
name|loop_start
argument_list|,
name|dominator
argument_list|)
operator|&&
operator|!
name|reg_used_between_p
argument_list|(
name|giv
argument_list|,
name|giv_insn
argument_list|,
name|loop_end
argument_list|)
condition|)
block|{
name|rtx
name|p
decl_stmt|;
name|rtx
name|next
decl_stmt|;
for|for
control|(
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|dominator
argument_list|)
init|;
condition|;
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|next
argument_list|)
control|)
block|{
if|if
condition|(
operator|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|next
argument_list|)
argument_list|)
operator|==
literal|'i'
operator|&&
operator|(
name|reg_mentioned_p
argument_list|(
name|giv
argument_list|,
name|PATTERN
argument_list|(
name|next
argument_list|)
argument_list|)
operator|||
name|reg_set_p
argument_list|(
name|bl2
operator|->
name|biv
operator|->
name|src_reg
argument_list|,
name|next
argument_list|)
operator|)
operator|)
operator|||
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|JUMP_INSN
condition|)
break|break;
ifdef|#
directive|ifdef
name|HAVE_cc0
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|next
argument_list|)
argument_list|)
operator|!=
literal|'i'
operator|||
operator|!
name|sets_cc0_p
argument_list|(
name|PATTERN
argument_list|(
name|next
argument_list|)
argument_list|)
condition|)
endif|#
directive|endif
name|dominator
operator|=
name|next
expr_stmt|;
block|}
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"move after insn %d\n"
argument_list|,
name|INSN_UID
argument_list|(
name|dominator
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Avoid problems with luids by actually moving the insn 		     and adjusting all luids in the range.  */
name|reorder_insns
argument_list|(
name|giv_insn
argument_list|,
name|giv_insn
argument_list|,
name|dominator
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|dominator
init|;
name|INSN_UID
argument_list|(
name|p
argument_list|)
operator|>=
name|max_uid_for_loop
condition|;
control|)
name|p
operator|=
name|PREV_INSN
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|compute_luids
argument_list|(
name|giv_insn
argument_list|,
name|after_giv
argument_list|,
name|INSN_LUID
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the only purpose of the init insn is to initialize 		     this giv, delete it.  */
if|if
condition|(
name|single_set
argument_list|(
name|bl
operator|->
name|init_insn
argument_list|)
operator|&&
operator|!
name|reg_used_between_p
argument_list|(
name|giv
argument_list|,
name|bl
operator|->
name|init_insn
argument_list|,
name|loop_start
argument_list|)
condition|)
name|delete_insn
argument_list|(
name|bl
operator|->
name|init_insn
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|loop_insn_first_p
argument_list|(
name|bl2
operator|->
name|biv
operator|->
name|insn
argument_list|,
name|bl
operator|->
name|biv
operator|->
name|insn
argument_list|)
condition|)
block|{
name|rtx
name|p
init|=
name|PREV_INSN
argument_list|(
name|giv_insn
argument_list|)
decl_stmt|;
while|while
condition|(
name|INSN_UID
argument_list|(
name|p
argument_list|)
operator|>=
name|max_uid_for_loop
condition|)
name|p
operator|=
name|PREV_INSN
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|reorder_insns
argument_list|(
name|giv_insn
argument_list|,
name|giv_insn
argument_list|,
name|bl2
operator|->
name|biv
operator|->
name|insn
argument_list|)
expr_stmt|;
name|compute_luids
argument_list|(
name|after_giv
argument_list|,
name|NEXT_INSN
argument_list|(
name|giv_insn
argument_list|)
argument_list|,
name|INSN_LUID
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Remove this biv from the chain.  */
if|if
condition|(
name|bl
operator|->
name|next
condition|)
operator|*
name|bl
operator|=
operator|*
name|bl
operator|->
name|next
expr_stmt|;
else|else
block|{
operator|*
name|backbl
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
comment|/* If we can't make it a giv, 	     let biv keep initial value of "itself".  */
elseif|else
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"is complex\n"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If a biv is unconditionally incremented several times in a row, convert      all but the last increment into a giv.  */
comment|/* Get an upper bound for the number of registers      we might have after all bivs have been processed.  */
name|first_increment_giv
operator|=
name|max_reg_num
argument_list|()
expr_stmt|;
for|for
control|(
name|n_extra_increment
operator|=
literal|0
operator|,
name|bl
operator|=
name|loop_iv_list
init|;
name|bl
condition|;
name|bl
operator|=
name|bl
operator|->
name|next
control|)
name|n_extra_increment
operator|+=
name|bl
operator|->
name|biv_count
operator|-
literal|1
expr_stmt|;
comment|/* If the loop contains volatile memory references do not allow any      replacements to take place, since this could loose the volatile      markers.       Disabled for the gcc-2.95 release.  There are still some problems with      giv recombination.  We have a patch from Joern which should fix those      problems.  But the patch is fairly complex and not really suitable for      the gcc-2.95 branch at this stage.  */
if|if
condition|(
literal|0
operator|&&
name|n_extra_increment
operator|&&
operator|!
name|loop_has_volatile
condition|)
block|{
name|int
name|nregs
init|=
name|first_increment_giv
operator|+
name|n_extra_increment
decl_stmt|;
comment|/* Reallocate reg_iv_type and reg_iv_info.  */
name|VARRAY_GROW
argument_list|(
name|reg_iv_type
argument_list|,
name|nregs
argument_list|)
expr_stmt|;
name|VARRAY_GROW
argument_list|(
name|reg_iv_info
argument_list|,
name|nregs
argument_list|)
expr_stmt|;
for|for
control|(
name|bl
operator|=
name|loop_iv_list
init|;
name|bl
condition|;
name|bl
operator|=
name|bl
operator|->
name|next
control|)
block|{
name|struct
name|induction
modifier|*
modifier|*
name|vp
decl_stmt|,
modifier|*
name|v
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|int
name|biv_dead_after_loop
init|=
literal|0
decl_stmt|;
comment|/* The biv increments lists are in reverse order.  Fix this first.  */
for|for
control|(
name|v
operator|=
name|bl
operator|->
name|biv
operator|,
name|bl
operator|->
name|biv
operator|=
literal|0
init|;
name|v
condition|;
name|v
operator|=
name|next
control|)
block|{
name|next
operator|=
name|v
operator|->
name|next_iv
expr_stmt|;
name|v
operator|->
name|next_iv
operator|=
name|bl
operator|->
name|biv
expr_stmt|;
name|bl
operator|->
name|biv
operator|=
name|v
expr_stmt|;
block|}
comment|/* We must guard against the case that an early exit between v->insn 	     and next->insn leaves the biv live after the loop, since that 	     would mean that we'd be missing an increment for the final 	     value.  The following test to set biv_dead_after_loop is like 	     the first part of the test to set bl->eliminable. 	     We don't check here if we can calculate the final value, since 	     this can't succeed if we already know that there is a jump 	     between v->insn and next->insn, yet next->always_executed is 	     set and next->maybe_multiple is cleared.  Such a combination 	     implies that the jump destination is outside the loop. 	     If we want to make this check more sophisticated, we should 	     check each branch between v->insn and next->insn individually 	     to see if the biv is dead at its destination.  */
if|if
condition|(
name|uid_luid
index|[
name|REGNO_LAST_UID
argument_list|(
name|bl
operator|->
name|regno
argument_list|)
index|]
operator|<
name|INSN_LUID
argument_list|(
name|loop_end
argument_list|)
operator|&&
name|bl
operator|->
name|init_insn
operator|&&
name|INSN_UID
argument_list|(
name|bl
operator|->
name|init_insn
argument_list|)
operator|<
name|max_uid_for_loop
operator|&&
operator|(
name|uid_luid
index|[
name|REGNO_FIRST_UID
argument_list|(
name|bl
operator|->
name|regno
argument_list|)
index|]
operator|>=
name|INSN_LUID
argument_list|(
name|bl
operator|->
name|init_insn
argument_list|)
operator|)
ifdef|#
directive|ifdef
name|HAVE_decrement_and_branch_until_zero
operator|&&
operator|!
name|bl
operator|->
name|nonneg
endif|#
directive|endif
operator|&&
operator|!
name|reg_mentioned_p
argument_list|(
name|bl
operator|->
name|biv
operator|->
name|dest_reg
argument_list|,
name|SET_SRC
argument_list|(
name|bl
operator|->
name|init_set
argument_list|)
argument_list|)
condition|)
name|biv_dead_after_loop
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|vp
operator|=
operator|&
name|bl
operator|->
name|biv
operator|,
name|next
operator|=
operator|*
name|vp
init|;
name|v
operator|=
name|next
operator|,
name|next
operator|=
name|v
operator|->
name|next_iv
condition|;
control|)
block|{
name|HOST_WIDE_INT
name|offset
decl_stmt|;
name|rtx
name|set
decl_stmt|,
name|add_val
decl_stmt|,
name|old_reg
decl_stmt|,
name|dest_reg
decl_stmt|,
name|last_use_insn
decl_stmt|;
name|int
name|old_regno
decl_stmt|,
name|new_regno
decl_stmt|;
if|if
condition|(
operator|!
name|v
operator|->
name|always_executed
operator|||
name|v
operator|->
name|maybe_multiple
operator|||
name|GET_CODE
argument_list|(
name|v
operator|->
name|add_val
argument_list|)
operator|!=
name|CONST_INT
operator|||
operator|!
name|next
operator|->
name|always_executed
operator|||
name|next
operator|->
name|maybe_multiple
operator|||
operator|!
name|CONSTANT_P
argument_list|(
name|next
operator|->
name|add_val
argument_list|)
operator|||
name|v
operator|->
name|mult_val
operator|!=
name|const1_rtx
operator|||
name|next
operator|->
name|mult_val
operator|!=
name|const1_rtx
operator|||
operator|!
operator|(
name|biv_dead_after_loop
operator|||
name|no_jumps_between_p
argument_list|(
name|v
operator|->
name|insn
argument_list|,
name|next
operator|->
name|insn
argument_list|)
operator|)
condition|)
block|{
name|vp
operator|=
operator|&
name|v
operator|->
name|next_iv
expr_stmt|;
continue|continue;
block|}
name|offset
operator|=
name|INTVAL
argument_list|(
name|v
operator|->
name|add_val
argument_list|)
expr_stmt|;
name|set
operator|=
name|single_set
argument_list|(
name|v
operator|->
name|insn
argument_list|)
expr_stmt|;
name|add_val
operator|=
name|plus_constant
argument_list|(
name|next
operator|->
name|add_val
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|old_reg
operator|=
name|v
operator|->
name|dest_reg
expr_stmt|;
name|dest_reg
operator|=
name|gen_reg_rtx
argument_list|(
name|v
operator|->
name|mode
argument_list|)
expr_stmt|;
comment|/* Unlike reg_iv_type / reg_iv_info, the other three arrays 		 have been allocated with some slop space, so we may not 		 actually need to reallocate them.  If we do, the following 		 if statement will be executed just once in this loop.  */
if|if
condition|(
operator|(
name|unsigned
operator|)
name|max_reg_num
argument_list|()
operator|>
name|n_times_set
operator|->
name|num_elements
condition|)
block|{
comment|/* Grow all the remaining arrays.  */
name|VARRAY_GROW
argument_list|(
name|set_in_loop
argument_list|,
name|nregs
argument_list|)
expr_stmt|;
name|VARRAY_GROW
argument_list|(
name|n_times_set
argument_list|,
name|nregs
argument_list|)
expr_stmt|;
name|VARRAY_GROW
argument_list|(
name|may_not_optimize
argument_list|,
name|nregs
argument_list|)
expr_stmt|;
name|VARRAY_GROW
argument_list|(
name|reg_single_usage
argument_list|,
name|nregs
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|validate_change
argument_list|(
name|next
operator|->
name|insn
argument_list|,
name|next
operator|->
name|location
argument_list|,
name|add_val
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|vp
operator|=
operator|&
name|v
operator|->
name|next_iv
expr_stmt|;
continue|continue;
block|}
comment|/* Here we can try to eliminate the increment by combining 		 it into the uses.  */
comment|/* Set last_use_insn so that we can check against it.  */
for|for
control|(
name|last_use_insn
operator|=
name|v
operator|->
name|insn
operator|,
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|v
operator|->
name|insn
argument_list|)
init|;
name|p
operator|!=
name|next
operator|->
name|insn
condition|;
name|p
operator|=
name|next_insn_in_loop
argument_list|(
name|p
argument_list|,
name|scan_start
argument_list|,
name|end
argument_list|,
name|loop_top
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
argument_list|)
operator|!=
literal|'i'
condition|)
continue|continue;
if|if
condition|(
name|reg_mentioned_p
argument_list|(
name|old_reg
argument_list|,
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
condition|)
block|{
name|last_use_insn
operator|=
name|p
expr_stmt|;
block|}
block|}
comment|/* If we can't get the LUIDs for the insns, we can't 		 calculate the lifetime.  This is likely from unrolling 		 of an inner loop, so there is little point in making this 		 a DEST_REG giv anyways.  */
if|if
condition|(
name|INSN_UID
argument_list|(
name|v
operator|->
name|insn
argument_list|)
operator|>=
name|max_uid_for_loop
operator|||
name|INSN_UID
argument_list|(
name|last_use_insn
argument_list|)
operator|>=
name|max_uid_for_loop
operator|||
operator|!
name|validate_change
argument_list|(
name|v
operator|->
name|insn
argument_list|,
operator|&
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|,
name|dest_reg
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|/* Change the increment at NEXT back to what it was.  */
if|if
condition|(
operator|!
name|validate_change
argument_list|(
name|next
operator|->
name|insn
argument_list|,
name|next
operator|->
name|location
argument_list|,
name|next
operator|->
name|add_val
argument_list|,
literal|0
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|vp
operator|=
operator|&
name|v
operator|->
name|next_iv
expr_stmt|;
continue|continue;
block|}
name|next
operator|->
name|add_val
operator|=
name|add_val
expr_stmt|;
name|v
operator|->
name|dest_reg
operator|=
name|dest_reg
expr_stmt|;
name|v
operator|->
name|giv_type
operator|=
name|DEST_REG
expr_stmt|;
name|v
operator|->
name|location
operator|=
operator|&
name|SET_SRC
argument_list|(
name|set
argument_list|)
expr_stmt|;
name|v
operator|->
name|cant_derive
operator|=
literal|0
expr_stmt|;
name|v
operator|->
name|combined_with
operator|=
literal|0
expr_stmt|;
name|v
operator|->
name|maybe_dead
operator|=
literal|0
expr_stmt|;
name|v
operator|->
name|derive_adjustment
operator|=
literal|0
expr_stmt|;
name|v
operator|->
name|same
operator|=
literal|0
expr_stmt|;
name|v
operator|->
name|ignore
operator|=
literal|0
expr_stmt|;
name|v
operator|->
name|new_reg
operator|=
literal|0
expr_stmt|;
name|v
operator|->
name|final_value
operator|=
literal|0
expr_stmt|;
name|v
operator|->
name|same_insn
operator|=
literal|0
expr_stmt|;
name|v
operator|->
name|auto_inc_opt
operator|=
literal|0
expr_stmt|;
name|v
operator|->
name|unrolled
operator|=
literal|0
expr_stmt|;
name|v
operator|->
name|shared
operator|=
literal|0
expr_stmt|;
name|v
operator|->
name|derived_from
operator|=
literal|0
expr_stmt|;
name|v
operator|->
name|always_computable
operator|=
literal|1
expr_stmt|;
name|v
operator|->
name|always_executed
operator|=
literal|1
expr_stmt|;
name|v
operator|->
name|replaceable
operator|=
literal|1
expr_stmt|;
name|v
operator|->
name|no_const_addval
operator|=
literal|0
expr_stmt|;
name|old_regno
operator|=
name|REGNO
argument_list|(
name|old_reg
argument_list|)
expr_stmt|;
name|new_regno
operator|=
name|REGNO
argument_list|(
name|dest_reg
argument_list|)
expr_stmt|;
name|VARRAY_INT
argument_list|(
name|set_in_loop
argument_list|,
name|old_regno
argument_list|)
operator|--
expr_stmt|;
name|VARRAY_INT
argument_list|(
name|set_in_loop
argument_list|,
name|new_regno
argument_list|)
operator|=
literal|1
expr_stmt|;
name|VARRAY_INT
argument_list|(
name|n_times_set
argument_list|,
name|old_regno
argument_list|)
operator|--
expr_stmt|;
name|VARRAY_INT
argument_list|(
name|n_times_set
argument_list|,
name|new_regno
argument_list|)
operator|=
literal|1
expr_stmt|;
name|VARRAY_CHAR
argument_list|(
name|may_not_optimize
argument_list|,
name|new_regno
argument_list|)
operator|=
literal|0
expr_stmt|;
name|REG_IV_TYPE
argument_list|(
name|new_regno
argument_list|)
operator|=
name|GENERAL_INDUCT
expr_stmt|;
name|REG_IV_INFO
argument_list|(
name|new_regno
argument_list|)
operator|=
name|v
expr_stmt|;
comment|/* Remove the increment from the list of biv increments, 		 and record it as a giv.  */
operator|*
name|vp
operator|=
name|next
expr_stmt|;
name|bl
operator|->
name|biv_count
operator|--
expr_stmt|;
name|v
operator|->
name|next_iv
operator|=
name|bl
operator|->
name|giv
expr_stmt|;
name|bl
operator|->
name|giv
operator|=
name|v
expr_stmt|;
name|bl
operator|->
name|giv_count
operator|++
expr_stmt|;
name|v
operator|->
name|benefit
operator|=
name|rtx_cost
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
name|SET
argument_list|)
expr_stmt|;
name|bl
operator|->
name|total_benefit
operator|+=
name|v
operator|->
name|benefit
expr_stmt|;
comment|/* Now replace the biv with DEST_REG in all insns between 		 the replaced increment and the next increment, and 		 remember the last insn that needed a replacement.  */
for|for
control|(
name|last_use_insn
operator|=
name|v
operator|->
name|insn
operator|,
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|v
operator|->
name|insn
argument_list|)
init|;
name|p
operator|!=
name|next
operator|->
name|insn
condition|;
name|p
operator|=
name|next_insn_in_loop
argument_list|(
name|p
argument_list|,
name|scan_start
argument_list|,
name|end
argument_list|,
name|loop_top
argument_list|)
control|)
block|{
name|rtx
name|note
decl_stmt|;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
argument_list|)
operator|!=
literal|'i'
condition|)
continue|continue;
if|if
condition|(
name|reg_mentioned_p
argument_list|(
name|old_reg
argument_list|,
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
condition|)
block|{
name|last_use_insn
operator|=
name|p
expr_stmt|;
if|if
condition|(
operator|!
name|validate_replace_rtx
argument_list|(
name|old_reg
argument_list|,
name|dest_reg
argument_list|,
name|p
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|note
operator|=
name|REG_NOTES
argument_list|(
name|p
argument_list|)
init|;
name|note
condition|;
name|note
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|note
argument_list|)
operator|==
name|EXPR_LIST
condition|)
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
operator|=
name|replace_rtx
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|old_reg
argument_list|,
name|dest_reg
argument_list|)
expr_stmt|;
block|}
block|}
name|v
operator|->
name|last_use
operator|=
name|last_use_insn
expr_stmt|;
name|v
operator|->
name|lifetime
operator|=
name|INSN_LUID
argument_list|(
name|v
operator|->
name|insn
argument_list|)
operator|-
name|INSN_LUID
argument_list|(
name|last_use_insn
argument_list|)
expr_stmt|;
comment|/* If the lifetime is zero, it means that this register is really 		 a dead store.  So mark this as a giv that can be ignored. 		 This will not prevent the biv from being eliminated.  */
if|if
condition|(
name|v
operator|->
name|lifetime
operator|==
literal|0
condition|)
name|v
operator|->
name|ignore
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Increment %d of biv %d converted to giv %d.\n\n"
argument_list|,
name|INSN_UID
argument_list|(
name|v
operator|->
name|insn
argument_list|)
argument_list|,
name|old_regno
argument_list|,
name|new_regno
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|last_increment_giv
operator|=
name|max_reg_num
argument_list|()
operator|-
literal|1
expr_stmt|;
comment|/* Search the loop for general induction variables.  */
comment|/* A register is a giv if: it is only set once, it is a function of a      biv and a constant (or invariant), and it is not a biv.  */
name|not_every_iteration
operator|=
literal|0
expr_stmt|;
name|loop_depth
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|scan_start
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* At end of a straight-in loop, we are done. 	 At end of a loop entered at the bottom, scan the top.  */
if|if
condition|(
name|p
operator|==
name|scan_start
condition|)
break|break;
if|if
condition|(
name|p
operator|==
name|end
condition|)
block|{
if|if
condition|(
name|loop_top
operator|!=
literal|0
condition|)
name|p
operator|=
name|loop_top
expr_stmt|;
else|else
break|break;
if|if
condition|(
name|p
operator|==
name|scan_start
condition|)
break|break;
block|}
comment|/* Look for a general induction variable in a register.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|INSN
operator|&&
operator|(
name|set
operator|=
name|single_set
argument_list|(
name|p
argument_list|)
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
operator|!
name|VARRAY_CHAR
argument_list|(
name|may_not_optimize
argument_list|,
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|src_reg
decl_stmt|;
name|rtx
name|add_val
decl_stmt|;
name|rtx
name|mult_val
decl_stmt|;
name|int
name|benefit
decl_stmt|;
name|rtx
name|regnote
init|=
literal|0
decl_stmt|;
name|rtx
name|last_consec_insn
decl_stmt|;
name|dest_reg
operator|=
name|SET_DEST
argument_list|(
name|set
argument_list|)
expr_stmt|;
if|if
condition|(
name|REGNO
argument_list|(
name|dest_reg
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
continue|continue;
if|if
condition|(
comment|/* SET_SRC is a giv.  */
operator|(
name|general_induction_var
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
operator|&
name|src_reg
argument_list|,
operator|&
name|add_val
argument_list|,
operator|&
name|mult_val
argument_list|,
literal|0
argument_list|,
operator|&
name|benefit
argument_list|)
comment|/* Equivalent expression is a giv.  */
operator|||
operator|(
operator|(
name|regnote
operator|=
name|find_reg_note
argument_list|(
name|p
argument_list|,
name|REG_EQUAL
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
operator|&&
name|general_induction_var
argument_list|(
name|XEXP
argument_list|(
name|regnote
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|src_reg
argument_list|,
operator|&
name|add_val
argument_list|,
operator|&
name|mult_val
argument_list|,
literal|0
argument_list|,
operator|&
name|benefit
argument_list|)
operator|)
operator|)
comment|/* Don't try to handle any regs made by loop optimization. 		 We have nothing on them in regno_first_uid, etc.  */
operator|&&
name|REGNO
argument_list|(
name|dest_reg
argument_list|)
operator|<
name|max_reg_before_loop
comment|/* Don't recognize a BASIC_INDUCT_VAR here.  */
operator|&&
name|dest_reg
operator|!=
name|src_reg
comment|/* This must be the only place where the register is set.  */
operator|&&
operator|(
name|VARRAY_INT
argument_list|(
name|n_times_set
argument_list|,
name|REGNO
argument_list|(
name|dest_reg
argument_list|)
argument_list|)
operator|==
literal|1
comment|/* or all sets must be consecutive and make a giv.  */
operator|||
operator|(
name|benefit
operator|=
name|consec_sets_giv
argument_list|(
name|benefit
argument_list|,
name|p
argument_list|,
name|src_reg
argument_list|,
name|dest_reg
argument_list|,
operator|&
name|add_val
argument_list|,
operator|&
name|mult_val
argument_list|,
operator|&
name|last_consec_insn
argument_list|)
operator|)
operator|)
condition|)
block|{
name|struct
name|induction
modifier|*
name|v
init|=
operator|(
expr|struct
name|induction
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|induction
argument_list|)
argument_list|)
decl_stmt|;
comment|/* If this is a library call, increase benefit.  */
if|if
condition|(
name|find_reg_note
argument_list|(
name|p
argument_list|,
name|REG_RETVAL
argument_list|,
name|NULL_RTX
argument_list|)
condition|)
name|benefit
operator|+=
name|libcall_benefit
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* Skip the consecutive insns, if there are any.  */
if|if
condition|(
name|VARRAY_INT
argument_list|(
name|n_times_set
argument_list|,
name|REGNO
argument_list|(
name|dest_reg
argument_list|)
argument_list|)
operator|!=
literal|1
condition|)
name|p
operator|=
name|last_consec_insn
expr_stmt|;
name|record_giv
argument_list|(
name|v
argument_list|,
name|p
argument_list|,
name|src_reg
argument_list|,
name|dest_reg
argument_list|,
name|mult_val
argument_list|,
name|add_val
argument_list|,
name|benefit
argument_list|,
name|DEST_REG
argument_list|,
name|not_every_iteration
argument_list|,
name|NULL_PTR
argument_list|,
name|loop_start
argument_list|,
name|loop_end
argument_list|)
expr_stmt|;
block|}
block|}
ifndef|#
directive|ifndef
name|DONT_REDUCE_ADDR
comment|/* Look for givs which are memory addresses.  */
comment|/* This resulted in worse code on a VAX 8600.  I wonder if it 	 still does.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|INSN
condition|)
name|find_mem_givs
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|,
name|p
argument_list|,
name|not_every_iteration
argument_list|,
name|loop_start
argument_list|,
name|loop_end
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Update the status of whether giv can derive other givs.  This can 	 change when we pass a label or an insn that updates a biv.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|JUMP_INSN
operator|||
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|CODE_LABEL
condition|)
name|update_giv_derive
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* Past a jump, we get to insns for which we can't count 	 on whether they will be executed during each iteration.  */
comment|/* This code appears twice in strength_reduce.  There is also similar 	 code in scan_loop.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|JUMP_INSN
comment|/* If we enter the loop in the middle, and scan around to the 	     beginning, don't set not_every_iteration for that. 	     This can be any kind of jump, since we want to know if insns 	     will be executed if the loop is executed.  */
operator|&&
operator|!
operator|(
name|JUMP_LABEL
argument_list|(
name|p
argument_list|)
operator|==
name|loop_top
operator|&&
operator|(
operator|(
name|NEXT_INSN
argument_list|(
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
argument_list|)
operator|==
name|loop_end
operator|&&
name|simplejump_p
argument_list|(
name|p
argument_list|)
operator|)
operator|||
operator|(
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
operator|==
name|loop_end
operator|&&
name|condjump_p
argument_list|(
name|p
argument_list|)
operator|)
operator|)
operator|)
condition|)
block|{
name|rtx
name|label
init|=
literal|0
decl_stmt|;
comment|/* If this is a jump outside the loop, then it also doesn't 	     matter.  Check to see if the target of this branch is on the 	     loop_number_exits_labels list.  */
for|for
control|(
name|label
operator|=
name|loop_number_exit_labels
index|[
name|uid_loop_num
index|[
name|INSN_UID
argument_list|(
name|loop_start
argument_list|)
index|]
index|]
init|;
name|label
condition|;
name|label
operator|=
name|LABEL_NEXTREF
argument_list|(
name|label
argument_list|)
control|)
if|if
condition|(
name|XEXP
argument_list|(
name|label
argument_list|,
literal|0
argument_list|)
operator|==
name|JUMP_LABEL
argument_list|(
name|p
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|!
name|label
condition|)
name|not_every_iteration
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|NOTE
condition|)
block|{
comment|/* At the virtual top of a converted loop, insns are again known to 	     be executed each iteration: logically, the loop begins here 	     even though the exit code has been duplicated.  	     Insns are also again known to be executed each iteration at 	     the LOOP_CONT note.  */
if|if
condition|(
operator|(
name|NOTE_LINE_NUMBER
argument_list|(
name|p
argument_list|)
operator|==
name|NOTE_INSN_LOOP_VTOP
operator|||
name|NOTE_LINE_NUMBER
argument_list|(
name|p
argument_list|)
operator|==
name|NOTE_INSN_LOOP_CONT
operator|)
operator|&&
name|loop_depth
operator|==
literal|0
condition|)
name|not_every_iteration
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|p
argument_list|)
operator|==
name|NOTE_INSN_LOOP_BEG
condition|)
name|loop_depth
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|p
argument_list|)
operator|==
name|NOTE_INSN_LOOP_END
condition|)
name|loop_depth
operator|--
expr_stmt|;
block|}
comment|/* Unlike in the code motion pass where MAYBE_NEVER indicates that 	 an insn may never be executed, NOT_EVERY_ITERATION indicates whether 	 or not an insn is known to be executed each iteration of the 	 loop, whether or not any iterations are known to occur.  	 Therefore, if we have just passed a label and have no more labels 	 between here and the test insn of the loop, we know these insns 	 will be executed each iteration.  */
if|if
condition|(
name|not_every_iteration
operator|&&
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|CODE_LABEL
operator|&&
name|no_labels_between_p
argument_list|(
name|p
argument_list|,
name|loop_end
argument_list|)
operator|&&
name|loop_insn_first_p
argument_list|(
name|p
argument_list|,
name|loop_cont
argument_list|)
condition|)
name|not_every_iteration
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Try to calculate and save the number of loop iterations.  This is      set to zero if the actual number can not be calculated.  This must      be called after all giv's have been identified, since otherwise it may      fail if the iteration variable is a giv.  */
name|loop_iterations
argument_list|(
name|loop_start
argument_list|,
name|loop_end
argument_list|,
name|loop_info
argument_list|)
expr_stmt|;
comment|/* Now for each giv for which we still don't know whether or not it is      replaceable, check to see if it is replaceable because its final value      can be calculated.  This must be done after loop_iterations is called,      so that final_giv_value will work correctly.  */
for|for
control|(
name|bl
operator|=
name|loop_iv_list
init|;
name|bl
condition|;
name|bl
operator|=
name|bl
operator|->
name|next
control|)
block|{
name|struct
name|induction
modifier|*
name|v
decl_stmt|;
for|for
control|(
name|v
operator|=
name|bl
operator|->
name|giv
init|;
name|v
condition|;
name|v
operator|=
name|v
operator|->
name|next_iv
control|)
if|if
condition|(
operator|!
name|v
operator|->
name|replaceable
operator|&&
operator|!
name|v
operator|->
name|not_replaceable
condition|)
name|check_final_value
argument_list|(
name|v
argument_list|,
name|loop_start
argument_list|,
name|loop_end
argument_list|,
name|loop_info
operator|->
name|n_iterations
argument_list|)
expr_stmt|;
block|}
comment|/* Try to prove that the loop counter variable (if any) is always      nonnegative; if so, record that fact with a REG_NONNEG note      so that "decrement and branch until zero" insn can be used.  */
name|check_dbra_loop
argument_list|(
name|loop_end
argument_list|,
name|insn_count
argument_list|,
name|loop_start
argument_list|,
name|loop_info
argument_list|)
expr_stmt|;
comment|/* Create reg_map to hold substitutions for replaceable giv regs.      Some givs might have been made from biv increments, so look at      reg_iv_type for a suitable size.  */
name|reg_map_size
operator|=
name|reg_iv_type
operator|->
name|num_elements
expr_stmt|;
name|reg_map
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|reg_map_size
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|reg_map
argument_list|,
name|reg_map_size
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Examine each iv class for feasibility of strength reduction/induction      variable elimination.  */
for|for
control|(
name|bl
operator|=
name|loop_iv_list
init|;
name|bl
condition|;
name|bl
operator|=
name|bl
operator|->
name|next
control|)
block|{
name|struct
name|induction
modifier|*
name|v
decl_stmt|;
name|int
name|benefit
decl_stmt|;
name|int
name|all_reduced
decl_stmt|;
name|rtx
name|final_value
init|=
literal|0
decl_stmt|;
name|unsigned
name|nregs
decl_stmt|;
comment|/* Test whether it will be possible to eliminate this biv 	 provided all givs are reduced.  This is possible if either 	 the reg is not used outside the loop, or we can compute 	 what its final value will be.  	 For architectures with a decrement_and_branch_until_zero insn, 	 don't do this if we put a REG_NONNEG note on the endtest for 	 this biv.  */
comment|/* Compare against bl->init_insn rather than loop_start. 	 We aren't concerned with any uses of the biv between 	 init_insn and loop_start since these won't be affected 	 by the value of the biv elsewhere in the function, so 	 long as init_insn doesn't use the biv itself. 	 March 14, 1989 -- self@bayes.arc.nasa.gov */
if|if
condition|(
operator|(
name|uid_luid
index|[
name|REGNO_LAST_UID
argument_list|(
name|bl
operator|->
name|regno
argument_list|)
index|]
operator|<
name|INSN_LUID
argument_list|(
name|loop_end
argument_list|)
operator|&&
name|bl
operator|->
name|init_insn
operator|&&
name|INSN_UID
argument_list|(
name|bl
operator|->
name|init_insn
argument_list|)
operator|<
name|max_uid_for_loop
operator|&&
name|uid_luid
index|[
name|REGNO_FIRST_UID
argument_list|(
name|bl
operator|->
name|regno
argument_list|)
index|]
operator|>=
name|INSN_LUID
argument_list|(
name|bl
operator|->
name|init_insn
argument_list|)
ifdef|#
directive|ifdef
name|HAVE_decrement_and_branch_until_zero
operator|&&
operator|!
name|bl
operator|->
name|nonneg
endif|#
directive|endif
operator|&&
operator|!
name|reg_mentioned_p
argument_list|(
name|bl
operator|->
name|biv
operator|->
name|dest_reg
argument_list|,
name|SET_SRC
argument_list|(
name|bl
operator|->
name|init_set
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
operator|(
name|final_value
operator|=
name|final_biv_value
argument_list|(
name|bl
argument_list|,
name|loop_start
argument_list|,
name|loop_end
argument_list|,
name|loop_info
operator|->
name|n_iterations
argument_list|)
operator|)
ifdef|#
directive|ifdef
name|HAVE_decrement_and_branch_until_zero
operator|&&
operator|!
name|bl
operator|->
name|nonneg
endif|#
directive|endif
operator|)
condition|)
name|bl
operator|->
name|eliminable
operator|=
name|maybe_eliminate_biv
argument_list|(
name|bl
argument_list|,
name|loop_start
argument_list|,
name|end
argument_list|,
literal|0
argument_list|,
name|threshold
argument_list|,
name|insn_count
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
block|{
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Cannot eliminate biv %d.\n"
argument_list|,
name|bl
operator|->
name|regno
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"First use: insn %d, last use: insn %d.\n"
argument_list|,
name|REGNO_FIRST_UID
argument_list|(
name|bl
operator|->
name|regno
argument_list|)
argument_list|,
name|REGNO_LAST_UID
argument_list|(
name|bl
operator|->
name|regno
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Combine all giv's for this iv_class.  */
name|combine_givs
argument_list|(
name|bl
argument_list|)
expr_stmt|;
comment|/* This will be true at the end, if all givs which depend on this 	 biv have been strength reduced. 	 We can't (currently) eliminate the biv unless this is so.  */
name|all_reduced
operator|=
literal|1
expr_stmt|;
comment|/* Check each giv in this class to see if we will benefit by reducing 	 it.  Skip giv's combined with others.  */
for|for
control|(
name|v
operator|=
name|bl
operator|->
name|giv
init|;
name|v
condition|;
name|v
operator|=
name|v
operator|->
name|next_iv
control|)
block|{
name|struct
name|induction
modifier|*
name|tv
decl_stmt|;
if|if
condition|(
name|v
operator|->
name|ignore
operator|||
name|v
operator|->
name|same
condition|)
continue|continue;
name|benefit
operator|=
name|v
operator|->
name|benefit
expr_stmt|;
comment|/* Reduce benefit if not replaceable, since we will insert 	     a move-insn to replace the insn that calculates this giv. 	     Don't do this unless the giv is a user variable, since it 	     will often be marked non-replaceable because of the duplication 	     of the exit code outside the loop.  In such a case, the copies 	     we insert are dead and will be deleted.  So they don't have 	     a cost.  Similar situations exist.  */
comment|/* ??? The new final_[bg]iv_value code does a much better job 	     of finding replaceable giv's, and hence this code may no longer 	     be necessary.  */
if|if
condition|(
operator|!
name|v
operator|->
name|replaceable
operator|&&
operator|!
name|bl
operator|->
name|eliminable
operator|&&
name|REG_USERVAR_P
argument_list|(
name|v
operator|->
name|dest_reg
argument_list|)
condition|)
name|benefit
operator|-=
name|copy_cost
expr_stmt|;
comment|/* Decrease the benefit to count the add-insns that we will 	     insert to increment the reduced reg for the giv.  */
name|benefit
operator|-=
name|add_cost
operator|*
name|bl
operator|->
name|biv_count
expr_stmt|;
comment|/* Decide whether to strength-reduce this giv or to leave the code 	     unchanged (recompute it from the biv each time it is used). 	     This decision can be made independently for each giv.  */
ifdef|#
directive|ifdef
name|AUTO_INC_DEC
comment|/* Attempt to guess whether autoincrement will handle some of the 	     new add insns; if so, increase BENEFIT (undo the subtraction of 	     add_cost that was done above).  */
if|if
condition|(
name|v
operator|->
name|giv_type
operator|==
name|DEST_ADDR
operator|&&
name|GET_CODE
argument_list|(
name|v
operator|->
name|mult_val
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
if|if
condition|(
name|HAVE_POST_INCREMENT
operator|&&
name|INTVAL
argument_list|(
name|v
operator|->
name|mult_val
argument_list|)
operator|==
name|GET_MODE_SIZE
argument_list|(
name|v
operator|->
name|mem_mode
argument_list|)
condition|)
name|benefit
operator|+=
name|add_cost
operator|*
name|bl
operator|->
name|biv_count
expr_stmt|;
elseif|else
if|if
condition|(
name|HAVE_PRE_INCREMENT
operator|&&
name|INTVAL
argument_list|(
name|v
operator|->
name|mult_val
argument_list|)
operator|==
name|GET_MODE_SIZE
argument_list|(
name|v
operator|->
name|mem_mode
argument_list|)
condition|)
name|benefit
operator|+=
name|add_cost
operator|*
name|bl
operator|->
name|biv_count
expr_stmt|;
elseif|else
if|if
condition|(
name|HAVE_POST_DECREMENT
operator|&&
operator|-
name|INTVAL
argument_list|(
name|v
operator|->
name|mult_val
argument_list|)
operator|==
name|GET_MODE_SIZE
argument_list|(
name|v
operator|->
name|mem_mode
argument_list|)
condition|)
name|benefit
operator|+=
name|add_cost
operator|*
name|bl
operator|->
name|biv_count
expr_stmt|;
elseif|else
if|if
condition|(
name|HAVE_PRE_DECREMENT
operator|&&
operator|-
name|INTVAL
argument_list|(
name|v
operator|->
name|mult_val
argument_list|)
operator|==
name|GET_MODE_SIZE
argument_list|(
name|v
operator|->
name|mem_mode
argument_list|)
condition|)
name|benefit
operator|+=
name|add_cost
operator|*
name|bl
operator|->
name|biv_count
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* If an insn is not to be strength reduced, then set its ignore 	     flag, and clear all_reduced.  */
comment|/* A giv that depends on a reversed biv must be reduced if it is 	     used after the loop exit, otherwise, it would have the wrong 	     value after the loop exit.  To make it simple, just reduce all 	     of such giv's whether or not we know they are used after the loop 	     exit.  */
if|if
condition|(
operator|!
name|flag_reduce_all_givs
operator|&&
name|v
operator|->
name|lifetime
operator|*
name|threshold
operator|*
name|benefit
operator|<
name|insn_count
operator|&&
operator|!
name|bl
operator|->
name|reversed
condition|)
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"giv of insn %d not worth while, %d vs %d.\n"
argument_list|,
name|INSN_UID
argument_list|(
name|v
operator|->
name|insn
argument_list|)
argument_list|,
name|v
operator|->
name|lifetime
operator|*
name|threshold
operator|*
name|benefit
argument_list|,
name|insn_count
argument_list|)
expr_stmt|;
name|v
operator|->
name|ignore
operator|=
literal|1
expr_stmt|;
name|all_reduced
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* Check that we can increment the reduced giv without a 		 multiply insn.  If not, reject it.  */
for|for
control|(
name|tv
operator|=
name|bl
operator|->
name|biv
init|;
name|tv
condition|;
name|tv
operator|=
name|tv
operator|->
name|next_iv
control|)
if|if
condition|(
name|tv
operator|->
name|mult_val
operator|==
name|const1_rtx
operator|&&
operator|!
name|product_cheap_p
argument_list|(
name|tv
operator|->
name|add_val
argument_list|,
name|v
operator|->
name|mult_val
argument_list|)
condition|)
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"giv of insn %d: would need a multiply.\n"
argument_list|,
name|INSN_UID
argument_list|(
name|v
operator|->
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|v
operator|->
name|ignore
operator|=
literal|1
expr_stmt|;
name|all_reduced
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* Check for givs whose first use is their definition and whose 	 last use is the definition of another giv.  If so, it is likely 	 dead and should not be used to derive another giv nor to 	 eliminate a biv.  */
for|for
control|(
name|v
operator|=
name|bl
operator|->
name|giv
init|;
name|v
condition|;
name|v
operator|=
name|v
operator|->
name|next_iv
control|)
block|{
if|if
condition|(
name|v
operator|->
name|ignore
operator|||
operator|(
name|v
operator|->
name|same
operator|&&
name|v
operator|->
name|same
operator|->
name|ignore
operator|)
condition|)
continue|continue;
if|if
condition|(
name|v
operator|->
name|last_use
condition|)
block|{
name|struct
name|induction
modifier|*
name|v1
decl_stmt|;
for|for
control|(
name|v1
operator|=
name|bl
operator|->
name|giv
init|;
name|v1
condition|;
name|v1
operator|=
name|v1
operator|->
name|next_iv
control|)
if|if
condition|(
name|v
operator|->
name|last_use
operator|==
name|v1
operator|->
name|insn
condition|)
name|v
operator|->
name|maybe_dead
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|v
operator|->
name|giv_type
operator|==
name|DEST_REG
operator|&&
name|REGNO_FIRST_UID
argument_list|(
name|REGNO
argument_list|(
name|v
operator|->
name|dest_reg
argument_list|)
argument_list|)
operator|==
name|INSN_UID
argument_list|(
name|v
operator|->
name|insn
argument_list|)
condition|)
block|{
name|struct
name|induction
modifier|*
name|v1
decl_stmt|;
for|for
control|(
name|v1
operator|=
name|bl
operator|->
name|giv
init|;
name|v1
condition|;
name|v1
operator|=
name|v1
operator|->
name|next_iv
control|)
if|if
condition|(
name|REGNO_LAST_UID
argument_list|(
name|REGNO
argument_list|(
name|v
operator|->
name|dest_reg
argument_list|)
argument_list|)
operator|==
name|INSN_UID
argument_list|(
name|v1
operator|->
name|insn
argument_list|)
condition|)
name|v
operator|->
name|maybe_dead
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* Now that we know which givs will be reduced, try to rearrange the          combinations to reduce register pressure.          recombine_givs calls find_life_end, which needs reg_iv_type and 	 reg_iv_info to be valid for all pseudos.  We do the necessary 	 reallocation here since it allows to check if there are still 	 more bivs to process.  */
name|nregs
operator|=
name|max_reg_num
argument_list|()
expr_stmt|;
if|if
condition|(
name|nregs
operator|>
name|reg_iv_type
operator|->
name|num_elements
condition|)
block|{
comment|/* If there are still more bivs to process, allocate some slack 	     space so that we're not constantly reallocating these arrays.  */
if|if
condition|(
name|bl
operator|->
name|next
condition|)
name|nregs
operator|+=
name|nregs
operator|/
literal|4
expr_stmt|;
comment|/* Reallocate reg_iv_type and reg_iv_info.  */
name|VARRAY_GROW
argument_list|(
name|reg_iv_type
argument_list|,
name|nregs
argument_list|)
expr_stmt|;
name|VARRAY_GROW
argument_list|(
name|reg_iv_info
argument_list|,
name|nregs
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* Disabled for the gcc-2.95 release.  There are still some problems with 	 giv recombination.  We have a patch from Joern which should fix those 	 problems.  But the patch is fairly complex and not really suitable for 	 the gcc-2.95 branch at this stage.  */
block|recombine_givs (bl, loop_start, loop_end, unroll_p);
endif|#
directive|endif
comment|/* Reduce each giv that we decided to reduce.  */
for|for
control|(
name|v
operator|=
name|bl
operator|->
name|giv
init|;
name|v
condition|;
name|v
operator|=
name|v
operator|->
name|next_iv
control|)
block|{
name|struct
name|induction
modifier|*
name|tv
decl_stmt|;
if|if
condition|(
operator|!
name|v
operator|->
name|ignore
operator|&&
name|v
operator|->
name|same
operator|==
literal|0
condition|)
block|{
name|int
name|auto_inc_opt
init|=
literal|0
decl_stmt|;
comment|/* If the code for derived givs immediately below has already 		 allocated a new_reg, we must keep it.  */
if|if
condition|(
operator|!
name|v
operator|->
name|new_reg
condition|)
name|v
operator|->
name|new_reg
operator|=
name|gen_reg_rtx
argument_list|(
name|v
operator|->
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|derived_from
condition|)
block|{
name|struct
name|induction
modifier|*
name|d
init|=
name|v
operator|->
name|derived_from
decl_stmt|;
comment|/* In case d->dest_reg is not replaceable, we have 		     to replace it in v->insn now.  */
if|if
condition|(
operator|!
name|d
operator|->
name|new_reg
condition|)
name|d
operator|->
name|new_reg
operator|=
name|gen_reg_rtx
argument_list|(
name|d
operator|->
name|mode
argument_list|)
expr_stmt|;
name|PATTERN
argument_list|(
name|v
operator|->
name|insn
argument_list|)
operator|=
name|replace_rtx
argument_list|(
name|PATTERN
argument_list|(
name|v
operator|->
name|insn
argument_list|)
argument_list|,
name|d
operator|->
name|dest_reg
argument_list|,
name|d
operator|->
name|new_reg
argument_list|)
expr_stmt|;
name|PATTERN
argument_list|(
name|v
operator|->
name|insn
argument_list|)
operator|=
name|replace_rtx
argument_list|(
name|PATTERN
argument_list|(
name|v
operator|->
name|insn
argument_list|)
argument_list|,
name|v
operator|->
name|dest_reg
argument_list|,
name|v
operator|->
name|new_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|bl
operator|->
name|biv_count
operator|!=
literal|1
condition|)
block|{
comment|/* For each place where the biv is incremented, add an 			 insn to set the new, reduced reg for the giv.  */
for|for
control|(
name|tv
operator|=
name|bl
operator|->
name|biv
init|;
name|tv
condition|;
name|tv
operator|=
name|tv
operator|->
name|next_iv
control|)
block|{
comment|/* We always emit reduced giv increments before the 			     biv increment when bl->biv_count != 1.  So by 			     emitting the add insns for derived givs after the 			     biv increment, they pick up the updated value of 			     the reduced giv.  */
name|emit_insn_after
argument_list|(
name|copy_rtx
argument_list|(
name|PATTERN
argument_list|(
name|v
operator|->
name|insn
argument_list|)
argument_list|)
argument_list|,
name|tv
operator|->
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
continue|continue;
block|}
ifdef|#
directive|ifdef
name|AUTO_INC_DEC
comment|/* If the target has auto-increment addressing modes, and 		 this is an address giv, then try to put the increment 		 immediately after its use, so that flow can create an 		 auto-increment addressing mode.  */
if|if
condition|(
name|v
operator|->
name|giv_type
operator|==
name|DEST_ADDR
operator|&&
name|bl
operator|->
name|biv_count
operator|==
literal|1
operator|&&
name|bl
operator|->
name|biv
operator|->
name|always_executed
operator|&&
operator|!
name|bl
operator|->
name|biv
operator|->
name|maybe_multiple
comment|/* We don't handle reversed biv's because bl->biv->insn 		     does not have a valid INSN_LUID.  */
operator|&&
operator|!
name|bl
operator|->
name|reversed
operator|&&
name|v
operator|->
name|always_executed
operator|&&
operator|!
name|v
operator|->
name|maybe_multiple
operator|&&
name|INSN_UID
argument_list|(
name|v
operator|->
name|insn
argument_list|)
operator|<
name|max_uid_for_loop
condition|)
block|{
comment|/* If other giv's have been combined with this one, then 		     this will work only if all uses of the other giv's occur 		     before this giv's insn.  This is difficult to check.  		     We simplify this by looking for the common case where 		     there is one DEST_REG giv, and this giv's insn is the 		     last use of the dest_reg of that DEST_REG giv.  If the 		     increment occurs after the address giv, then we can 		     perform the optimization.  (Otherwise, the increment 		     would have to go before other_giv, and we would not be 		     able to combine it with the address giv to get an 		     auto-inc address.)  */
if|if
condition|(
name|v
operator|->
name|combined_with
condition|)
block|{
name|struct
name|induction
modifier|*
name|other_giv
init|=
literal|0
decl_stmt|;
for|for
control|(
name|tv
operator|=
name|bl
operator|->
name|giv
init|;
name|tv
condition|;
name|tv
operator|=
name|tv
operator|->
name|next_iv
control|)
if|if
condition|(
name|tv
operator|->
name|same
operator|==
name|v
condition|)
block|{
if|if
condition|(
name|other_giv
condition|)
break|break;
else|else
name|other_giv
operator|=
name|tv
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|tv
operator|&&
name|other_giv
operator|&&
name|REGNO
argument_list|(
name|other_giv
operator|->
name|dest_reg
argument_list|)
operator|<
name|max_reg_before_loop
operator|&&
operator|(
name|REGNO_LAST_UID
argument_list|(
name|REGNO
argument_list|(
name|other_giv
operator|->
name|dest_reg
argument_list|)
argument_list|)
operator|==
name|INSN_UID
argument_list|(
name|v
operator|->
name|insn
argument_list|)
operator|)
operator|&&
name|INSN_LUID
argument_list|(
name|v
operator|->
name|insn
argument_list|)
operator|<
name|INSN_LUID
argument_list|(
name|bl
operator|->
name|biv
operator|->
name|insn
argument_list|)
condition|)
name|auto_inc_opt
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Check for case where increment is before the address 		     giv.  Do this test in "loop order".  */
elseif|else
if|if
condition|(
operator|(
name|INSN_LUID
argument_list|(
name|v
operator|->
name|insn
argument_list|)
operator|>
name|INSN_LUID
argument_list|(
name|bl
operator|->
name|biv
operator|->
name|insn
argument_list|)
operator|&&
operator|(
name|INSN_LUID
argument_list|(
name|v
operator|->
name|insn
argument_list|)
operator|<
name|INSN_LUID
argument_list|(
name|scan_start
argument_list|)
operator|||
operator|(
name|INSN_LUID
argument_list|(
name|bl
operator|->
name|biv
operator|->
name|insn
argument_list|)
operator|>
name|INSN_LUID
argument_list|(
name|scan_start
argument_list|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|INSN_LUID
argument_list|(
name|v
operator|->
name|insn
argument_list|)
operator|<
name|INSN_LUID
argument_list|(
name|scan_start
argument_list|)
operator|&&
operator|(
name|INSN_LUID
argument_list|(
name|scan_start
argument_list|)
operator|<
name|INSN_LUID
argument_list|(
name|bl
operator|->
name|biv
operator|->
name|insn
argument_list|)
operator|)
operator|)
condition|)
name|auto_inc_opt
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|auto_inc_opt
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_cc0
block|{
name|rtx
name|prev
decl_stmt|;
comment|/* We can't put an insn immediately after one setting 		       cc0, or immediately before one using cc0.  */
if|if
condition|(
operator|(
name|auto_inc_opt
operator|==
literal|1
operator|&&
name|sets_cc0_p
argument_list|(
name|PATTERN
argument_list|(
name|v
operator|->
name|insn
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|auto_inc_opt
operator|==
operator|-
literal|1
operator|&&
operator|(
name|prev
operator|=
name|prev_nonnote_insn
argument_list|(
name|v
operator|->
name|insn
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|prev
argument_list|)
argument_list|)
operator|==
literal|'i'
operator|&&
name|sets_cc0_p
argument_list|(
name|PATTERN
argument_list|(
name|prev
argument_list|)
argument_list|)
operator|)
condition|)
name|auto_inc_opt
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|auto_inc_opt
condition|)
name|v
operator|->
name|auto_inc_opt
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* For each place where the biv is incremented, add an insn 		 to increment the new, reduced reg for the giv.  */
for|for
control|(
name|tv
operator|=
name|bl
operator|->
name|biv
init|;
name|tv
condition|;
name|tv
operator|=
name|tv
operator|->
name|next_iv
control|)
block|{
name|rtx
name|insert_before
decl_stmt|;
if|if
condition|(
operator|!
name|auto_inc_opt
condition|)
name|insert_before
operator|=
name|tv
operator|->
name|insn
expr_stmt|;
elseif|else
if|if
condition|(
name|auto_inc_opt
operator|==
literal|1
condition|)
name|insert_before
operator|=
name|NEXT_INSN
argument_list|(
name|v
operator|->
name|insn
argument_list|)
expr_stmt|;
else|else
name|insert_before
operator|=
name|v
operator|->
name|insn
expr_stmt|;
if|if
condition|(
name|tv
operator|->
name|mult_val
operator|==
name|const1_rtx
condition|)
name|emit_iv_add_mult
argument_list|(
name|tv
operator|->
name|add_val
argument_list|,
name|v
operator|->
name|mult_val
argument_list|,
name|v
operator|->
name|new_reg
argument_list|,
name|v
operator|->
name|new_reg
argument_list|,
name|insert_before
argument_list|)
expr_stmt|;
else|else
comment|/* tv->mult_val == const0_rtx */
comment|/* A multiply is acceptable here 		       since this is presumed to be seldom executed.  */
name|emit_iv_add_mult
argument_list|(
name|tv
operator|->
name|add_val
argument_list|,
name|v
operator|->
name|mult_val
argument_list|,
name|v
operator|->
name|add_val
argument_list|,
name|v
operator|->
name|new_reg
argument_list|,
name|insert_before
argument_list|)
expr_stmt|;
block|}
comment|/* Add code at loop start to initialize giv's reduced reg.  */
name|emit_iv_add_mult
argument_list|(
name|bl
operator|->
name|initial_value
argument_list|,
name|v
operator|->
name|mult_val
argument_list|,
name|v
operator|->
name|add_val
argument_list|,
name|v
operator|->
name|new_reg
argument_list|,
name|loop_start
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Rescan all givs.  If a giv is the same as a giv not reduced, mark it 	 as not reduced. 	  	 For each giv register that can be reduced now: if replaceable, 	 substitute reduced reg wherever the old giv occurs; 	 else add new move insn "giv_reg = reduced_reg".  */
for|for
control|(
name|v
operator|=
name|bl
operator|->
name|giv
init|;
name|v
condition|;
name|v
operator|=
name|v
operator|->
name|next_iv
control|)
block|{
if|if
condition|(
name|v
operator|->
name|same
operator|&&
name|v
operator|->
name|same
operator|->
name|ignore
condition|)
name|v
operator|->
name|ignore
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|ignore
condition|)
continue|continue;
comment|/* Update expression if this was combined, in case other giv was 	     replaced.  */
if|if
condition|(
name|v
operator|->
name|same
condition|)
name|v
operator|->
name|new_reg
operator|=
name|replace_rtx
argument_list|(
name|v
operator|->
name|new_reg
argument_list|,
name|v
operator|->
name|same
operator|->
name|dest_reg
argument_list|,
name|v
operator|->
name|same
operator|->
name|new_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|giv_type
operator|==
name|DEST_ADDR
condition|)
comment|/* Store reduced reg as the address in the memref where we found 	       this giv.  */
name|validate_change
argument_list|(
name|v
operator|->
name|insn
argument_list|,
name|v
operator|->
name|location
argument_list|,
name|v
operator|->
name|new_reg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|v
operator|->
name|replaceable
condition|)
block|{
name|reg_map
index|[
name|REGNO
argument_list|(
name|v
operator|->
name|dest_reg
argument_list|)
index|]
operator|=
name|v
operator|->
name|new_reg
expr_stmt|;
if|#
directive|if
literal|0
comment|/* I can no longer duplicate the original problem.  Perhaps 		 this is unnecessary now?  */
comment|/* Replaceable; it isn't strictly necessary to delete the old 		 insn and emit a new one, because v->dest_reg is now dead.  		 However, especially when unrolling loops, the special 		 handling for (set REG0 REG1) in the second cse pass may 		 make v->dest_reg live again.  To avoid this problem, emit 		 an insn to set the original giv reg from the reduced giv. 		 We can not delete the original insn, since it may be part 		 of a LIBCALL, and the code in flow that eliminates dead 		 libcalls will fail if it is deleted.  */
block|emit_insn_after (gen_move_insn (v->dest_reg, v->new_reg), 			       v->insn);
endif|#
directive|endif
block|}
else|else
block|{
comment|/* Not replaceable; emit an insn to set the original giv reg from 		 the reduced giv, same as above.  */
name|emit_insn_after
argument_list|(
name|gen_move_insn
argument_list|(
name|v
operator|->
name|dest_reg
argument_list|,
name|v
operator|->
name|new_reg
argument_list|)
argument_list|,
name|v
operator|->
name|insn
argument_list|)
expr_stmt|;
block|}
comment|/* When a loop is reversed, givs which depend on the reversed 	     biv, and which are live outside the loop, must be set to their 	     correct final value.  This insn is only needed if the giv is 	     not replaceable.  The correct final value is the same as the 	     value that the giv starts the reversed loop with.  */
if|if
condition|(
name|bl
operator|->
name|reversed
operator|&&
operator|!
name|v
operator|->
name|replaceable
condition|)
name|emit_iv_add_mult
argument_list|(
name|bl
operator|->
name|initial_value
argument_list|,
name|v
operator|->
name|mult_val
argument_list|,
name|v
operator|->
name|add_val
argument_list|,
name|v
operator|->
name|dest_reg
argument_list|,
name|end_insert_before
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|v
operator|->
name|final_value
condition|)
block|{
name|rtx
name|insert_before
decl_stmt|;
comment|/* If the loop has multiple exits, emit the insn before the 		 loop to ensure that it will always be executed no matter 		 how the loop exits.  Otherwise, emit the insn after the loop, 		 since this is slightly more efficient.  */
if|if
condition|(
name|loop_number_exit_count
index|[
name|uid_loop_num
index|[
name|INSN_UID
argument_list|(
name|loop_start
argument_list|)
index|]
index|]
condition|)
name|insert_before
operator|=
name|loop_start
expr_stmt|;
else|else
name|insert_before
operator|=
name|end_insert_before
expr_stmt|;
name|emit_insn_before
argument_list|(
name|gen_move_insn
argument_list|(
name|v
operator|->
name|dest_reg
argument_list|,
name|v
operator|->
name|final_value
argument_list|)
argument_list|,
name|insert_before
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* If the insn to set the final value of the giv was emitted 		 before the loop, then we must delete the insn inside the loop 		 that sets it.  If this is a LIBCALL, then we must delete 		 every insn in the libcall.  Note, however, that 		 final_giv_value will only succeed when there are multiple 		 exits if the giv is dead at each exit, hence it does not 		 matter that the original insn remains because it is dead 		 anyways.  */
comment|/* Delete the insn inside the loop that sets the giv since 		 the giv is now set before (or after) the loop.  */
block|delete_insn (v->insn);
endif|#
directive|endif
block|}
if|if
condition|(
name|loop_dump_stream
condition|)
block|{
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"giv at %d reduced to "
argument_list|,
name|INSN_UID
argument_list|(
name|v
operator|->
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|print_rtl
argument_list|(
name|loop_dump_stream
argument_list|,
name|v
operator|->
name|new_reg
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* All the givs based on the biv bl have been reduced if they 	 merit it.  */
comment|/* For each giv not marked as maybe dead that has been combined with a 	 second giv, clear any "maybe dead" mark on that second giv. 	 v->new_reg will either be or refer to the register of the giv it 	 combined with.  	 Doing this clearing avoids problems in biv elimination where a 	 giv's new_reg is a complex value that can't be put in the insn but 	 the giv combined with (with a reg as new_reg) is marked maybe_dead. 	 Since the register will be used in either case, we'd prefer it be 	 used from the simpler giv.  */
for|for
control|(
name|v
operator|=
name|bl
operator|->
name|giv
init|;
name|v
condition|;
name|v
operator|=
name|v
operator|->
name|next_iv
control|)
if|if
condition|(
operator|!
name|v
operator|->
name|maybe_dead
operator|&&
name|v
operator|->
name|same
condition|)
name|v
operator|->
name|same
operator|->
name|maybe_dead
operator|=
literal|0
expr_stmt|;
comment|/* Try to eliminate the biv, if it is a candidate. 	 This won't work if ! all_reduced, 	 since the givs we planned to use might not have been reduced.  	 We have to be careful that we didn't initially think we could eliminate 	 this biv because of a giv that we now think may be dead and shouldn't 	 be used as a biv replacement.    	 Also, there is the possibility that we may have a giv that looks 	 like it can be used to eliminate a biv, but the resulting insn 	 isn't valid.  This can happen, for example, on the 88k, where a  	 JUMP_INSN can compare a register only with zero.  Attempts to 	 replace it with a compare with a constant will fail.  	 Note that in cases where this call fails, we may have replaced some 	 of the occurrences of the biv with a giv, but no harm was done in 	 doing so in the rare cases where it can occur.  */
if|if
condition|(
name|all_reduced
operator|==
literal|1
operator|&&
name|bl
operator|->
name|eliminable
operator|&&
name|maybe_eliminate_biv
argument_list|(
name|bl
argument_list|,
name|loop_start
argument_list|,
name|end
argument_list|,
literal|1
argument_list|,
name|threshold
argument_list|,
name|insn_count
argument_list|)
condition|)
block|{
comment|/* ?? If we created a new test to bypass the loop entirely, 	     or otherwise drop straight in, based on this test, then 	     we might want to rewrite it also.  This way some later 	     pass has more hope of removing the initialization of this 	     biv entirely.  */
comment|/* If final_value != 0, then the biv may be used after loop end 	     and we must emit an insn to set it just in case.  	     Reversed bivs already have an insn after the loop setting their 	     value, so we don't need another one.  We can't calculate the 	     proper final value for such a biv here anyways.  */
if|if
condition|(
name|final_value
operator|!=
literal|0
operator|&&
operator|!
name|bl
operator|->
name|reversed
condition|)
block|{
name|rtx
name|insert_before
decl_stmt|;
comment|/* If the loop has multiple exits, emit the insn before the 		 loop to ensure that it will always be executed no matter 		 how the loop exits.  Otherwise, emit the insn after the 		 loop, since this is slightly more efficient.  */
if|if
condition|(
name|loop_number_exit_count
index|[
name|uid_loop_num
index|[
name|INSN_UID
argument_list|(
name|loop_start
argument_list|)
index|]
index|]
condition|)
name|insert_before
operator|=
name|loop_start
expr_stmt|;
else|else
name|insert_before
operator|=
name|end_insert_before
expr_stmt|;
name|emit_insn_before
argument_list|(
name|gen_move_insn
argument_list|(
name|bl
operator|->
name|biv
operator|->
name|dest_reg
argument_list|,
name|final_value
argument_list|)
argument_list|,
name|end_insert_before
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* Delete all of the instructions inside the loop which set 	     the biv, as they are all dead.  If is safe to delete them, 	     because an insn setting a biv will never be part of a libcall.  */
comment|/* However, deleting them will invalidate the regno_last_uid info, 	     so keeping them around is more convenient.  Final_biv_value 	     will only succeed when there are multiple exits if the biv 	     is dead at each exit, hence it does not matter that the original 	     insn remains, because it is dead anyways.  */
block|for (v = bl->biv; v; v = v->next_iv) 	    delete_insn (v->insn);
endif|#
directive|endif
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Reg %d: biv eliminated\n"
argument_list|,
name|bl
operator|->
name|regno
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Go through all the instructions in the loop, making all the      register substitutions scheduled in REG_MAP.  */
for|for
control|(
name|p
operator|=
name|loop_start
init|;
name|p
operator|!=
name|end
condition|;
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|JUMP_INSN
operator|||
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
name|replace_regs
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|,
name|reg_map
argument_list|,
name|reg_map_size
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|replace_regs
argument_list|(
name|REG_NOTES
argument_list|(
name|p
argument_list|)
argument_list|,
name|reg_map
argument_list|,
name|reg_map_size
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|INSN_CODE
argument_list|(
name|p
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* Unroll loops from within strength reduction so that we can use the      induction variable information that strength_reduce has already      collected.  */
if|if
condition|(
name|unroll_p
condition|)
name|unroll_loop
argument_list|(
name|loop_end
argument_list|,
name|insn_count
argument_list|,
name|loop_start
argument_list|,
name|end_insert_before
argument_list|,
name|loop_info
argument_list|,
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_decrement_and_branch_on_count
comment|/* Instrument the loop with BCT insn.  */
if|if
condition|(
name|HAVE_decrement_and_branch_on_count
operator|&&
name|bct_p
operator|&&
name|flag_branch_on_count_reg
condition|)
name|insert_bct
argument_list|(
name|loop_start
argument_list|,
name|loop_end
argument_list|,
name|loop_info
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_decrement_and_branch_on_count */
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|VARRAY_FREE
argument_list|(
name|reg_iv_type
argument_list|)
expr_stmt|;
name|VARRAY_FREE
argument_list|(
name|reg_iv_info
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if X is a valid source for an initial value (or as value being    compared against in an initial test).     X must be either a register or constant and must not be clobbered between    the current insn and the start of the loop.     INSN is the insn containing X.  */
end_comment

begin_function
specifier|static
name|int
name|valid_initial_value_p
parameter_list|(
name|x
parameter_list|,
name|insn
parameter_list|,
name|call_seen
parameter_list|,
name|loop_start
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|int
name|call_seen
decl_stmt|;
name|rtx
name|loop_start
decl_stmt|;
block|{
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|x
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Only consider pseudos we know about initialized in insns whose luids      we know.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO
argument_list|(
name|x
argument_list|)
operator|>=
name|max_reg_before_loop
condition|)
return|return
literal|0
return|;
comment|/* Don't use call-clobbered registers across a call which clobbers it.  On      some machines, don't use any hard registers at all.  */
if|if
condition|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
operator|(
name|SMALL_REGISTER_CLASSES
operator|||
operator|(
name|call_used_regs
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
operator|&&
name|call_seen
operator|)
operator|)
condition|)
return|return
literal|0
return|;
comment|/* Don't use registers that have been clobbered before the start of the      loop.  */
if|if
condition|(
name|reg_set_between_p
argument_list|(
name|x
argument_list|,
name|insn
argument_list|,
name|loop_start
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Scan X for memory refs and check each memory address    as a possible giv.  INSN is the insn whose pattern X comes from.    NOT_EVERY_ITERATION is 1 if the insn might not be executed during    every loop iteration.  */
end_comment

begin_function
specifier|static
name|void
name|find_mem_givs
parameter_list|(
name|x
parameter_list|,
name|insn
parameter_list|,
name|not_every_iteration
parameter_list|,
name|loop_start
parameter_list|,
name|loop_end
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|int
name|not_every_iteration
decl_stmt|;
name|rtx
name|loop_start
decl_stmt|,
name|loop_end
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|register
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|REG
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
case|case
name|PC
case|:
case|case
name|CC0
case|:
case|case
name|ADDR_VEC
case|:
case|case
name|ADDR_DIFF_VEC
case|:
case|case
name|USE
case|:
case|case
name|CLOBBER
case|:
return|return;
case|case
name|MEM
case|:
block|{
name|rtx
name|src_reg
decl_stmt|;
name|rtx
name|add_val
decl_stmt|;
name|rtx
name|mult_val
decl_stmt|;
name|int
name|benefit
decl_stmt|;
comment|/* This code used to disable creating GIVs with mult_val == 1 and 	   add_val == 0.  However, this leads to lost optimizations when  	   it comes time to combine a set of related DEST_ADDR GIVs, since 	   this one would not be seen.   */
if|if
condition|(
name|general_induction_var
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|src_reg
argument_list|,
operator|&
name|add_val
argument_list|,
operator|&
name|mult_val
argument_list|,
literal|1
argument_list|,
operator|&
name|benefit
argument_list|)
condition|)
block|{
comment|/* Found one; record it.  */
name|struct
name|induction
modifier|*
name|v
init|=
operator|(
expr|struct
name|induction
operator|*
operator|)
name|oballoc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|induction
argument_list|)
argument_list|)
decl_stmt|;
name|record_giv
argument_list|(
name|v
argument_list|,
name|insn
argument_list|,
name|src_reg
argument_list|,
name|addr_placeholder
argument_list|,
name|mult_val
argument_list|,
name|add_val
argument_list|,
name|benefit
argument_list|,
name|DEST_ADDR
argument_list|,
name|not_every_iteration
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|loop_start
argument_list|,
name|loop_end
argument_list|)
expr_stmt|;
name|v
operator|->
name|mem_mode
operator|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
default|default:
break|break;
block|}
comment|/* Recursively scan the subexpressions for other mem refs.  */
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|find_mem_givs
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|insn
argument_list|,
name|not_every_iteration
argument_list|,
name|loop_start
argument_list|,
name|loop_end
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|find_mem_givs
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|insn
argument_list|,
name|not_every_iteration
argument_list|,
name|loop_start
argument_list|,
name|loop_end
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Fill in the data about one biv update.    V is the `struct induction' in which we record the biv.  (It is    allocated by the caller, with alloca.)    INSN is the insn that sets it.    DEST_REG is the biv's reg.     MULT_VAL is const1_rtx if the biv is being incremented here, in which case    INC_VAL is the increment.  Otherwise, MULT_VAL is const0_rtx and the biv is    being set to INC_VAL.     NOT_EVERY_ITERATION is nonzero if this biv update is not know to be    executed every iteration; MAYBE_MULTIPLE is nonzero if this biv update    can be executed more than once per iteration.  If MAYBE_MULTIPLE    and NOT_EVERY_ITERATION are both zero, we know that the biv update is    executed exactly once per iteration.  */
end_comment

begin_function
specifier|static
name|void
name|record_biv
parameter_list|(
name|v
parameter_list|,
name|insn
parameter_list|,
name|dest_reg
parameter_list|,
name|inc_val
parameter_list|,
name|mult_val
parameter_list|,
name|location
parameter_list|,
name|not_every_iteration
parameter_list|,
name|maybe_multiple
parameter_list|)
name|struct
name|induction
modifier|*
name|v
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|rtx
name|dest_reg
decl_stmt|;
name|rtx
name|inc_val
decl_stmt|;
name|rtx
name|mult_val
decl_stmt|;
name|rtx
modifier|*
name|location
decl_stmt|;
name|int
name|not_every_iteration
decl_stmt|;
name|int
name|maybe_multiple
decl_stmt|;
block|{
name|struct
name|iv_class
modifier|*
name|bl
decl_stmt|;
name|v
operator|->
name|insn
operator|=
name|insn
expr_stmt|;
name|v
operator|->
name|src_reg
operator|=
name|dest_reg
expr_stmt|;
name|v
operator|->
name|dest_reg
operator|=
name|dest_reg
expr_stmt|;
name|v
operator|->
name|mult_val
operator|=
name|mult_val
expr_stmt|;
name|v
operator|->
name|add_val
operator|=
name|inc_val
expr_stmt|;
name|v
operator|->
name|location
operator|=
name|location
expr_stmt|;
name|v
operator|->
name|mode
operator|=
name|GET_MODE
argument_list|(
name|dest_reg
argument_list|)
expr_stmt|;
name|v
operator|->
name|always_computable
operator|=
operator|!
name|not_every_iteration
expr_stmt|;
name|v
operator|->
name|always_executed
operator|=
operator|!
name|not_every_iteration
expr_stmt|;
name|v
operator|->
name|maybe_multiple
operator|=
name|maybe_multiple
expr_stmt|;
comment|/* Add this to the reg's iv_class, creating a class      if this is the first incrementation of the reg.  */
name|bl
operator|=
name|reg_biv_class
index|[
name|REGNO
argument_list|(
name|dest_reg
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|bl
operator|==
literal|0
condition|)
block|{
comment|/* Create and initialize new iv_class.  */
name|bl
operator|=
operator|(
expr|struct
name|iv_class
operator|*
operator|)
name|oballoc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|iv_class
argument_list|)
argument_list|)
expr_stmt|;
name|bl
operator|->
name|regno
operator|=
name|REGNO
argument_list|(
name|dest_reg
argument_list|)
expr_stmt|;
name|bl
operator|->
name|biv
operator|=
literal|0
expr_stmt|;
name|bl
operator|->
name|giv
operator|=
literal|0
expr_stmt|;
name|bl
operator|->
name|biv_count
operator|=
literal|0
expr_stmt|;
name|bl
operator|->
name|giv_count
operator|=
literal|0
expr_stmt|;
comment|/* Set initial value to the reg itself.  */
name|bl
operator|->
name|initial_value
operator|=
name|dest_reg
expr_stmt|;
comment|/* We haven't seen the initializing insn yet */
name|bl
operator|->
name|init_insn
operator|=
literal|0
expr_stmt|;
name|bl
operator|->
name|init_set
operator|=
literal|0
expr_stmt|;
name|bl
operator|->
name|initial_test
operator|=
literal|0
expr_stmt|;
name|bl
operator|->
name|incremented
operator|=
literal|0
expr_stmt|;
name|bl
operator|->
name|eliminable
operator|=
literal|0
expr_stmt|;
name|bl
operator|->
name|nonneg
operator|=
literal|0
expr_stmt|;
name|bl
operator|->
name|reversed
operator|=
literal|0
expr_stmt|;
name|bl
operator|->
name|total_benefit
operator|=
literal|0
expr_stmt|;
comment|/* Add this class to loop_iv_list.  */
name|bl
operator|->
name|next
operator|=
name|loop_iv_list
expr_stmt|;
name|loop_iv_list
operator|=
name|bl
expr_stmt|;
comment|/* Put it in the array of biv register classes.  */
name|reg_biv_class
index|[
name|REGNO
argument_list|(
name|dest_reg
argument_list|)
index|]
operator|=
name|bl
expr_stmt|;
block|}
comment|/* Update IV_CLASS entry for this biv.  */
name|v
operator|->
name|next_iv
operator|=
name|bl
operator|->
name|biv
expr_stmt|;
name|bl
operator|->
name|biv
operator|=
name|v
expr_stmt|;
name|bl
operator|->
name|biv_count
operator|++
expr_stmt|;
if|if
condition|(
name|mult_val
operator|==
name|const1_rtx
condition|)
name|bl
operator|->
name|incremented
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|loop_dump_stream
condition|)
block|{
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Insn %d: possible biv, reg %d,"
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|,
name|REGNO
argument_list|(
name|dest_reg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|inc_val
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|" const ="
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|INTVAL
argument_list|(
name|inc_val
argument_list|)
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|loop_dump_stream
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|" const = "
argument_list|)
expr_stmt|;
name|print_rtl
argument_list|(
name|loop_dump_stream
argument_list|,
name|inc_val
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Fill in the data about one giv.    V is the `struct induction' in which we record the giv.  (It is    allocated by the caller, with alloca.)    INSN is the insn that sets it.    BENEFIT estimates the savings from deleting this insn.    TYPE is DEST_REG or DEST_ADDR; it says whether the giv is computed    into a register or is used as a memory address.     SRC_REG is the biv reg which the giv is computed from.    DEST_REG is the giv's reg (if the giv is stored in a reg).    MULT_VAL and ADD_VAL are the coefficients used to compute the giv.    LOCATION points to the place where this giv's value appears in INSN.  */
end_comment

begin_function
specifier|static
name|void
name|record_giv
parameter_list|(
name|v
parameter_list|,
name|insn
parameter_list|,
name|src_reg
parameter_list|,
name|dest_reg
parameter_list|,
name|mult_val
parameter_list|,
name|add_val
parameter_list|,
name|benefit
parameter_list|,
name|type
parameter_list|,
name|not_every_iteration
parameter_list|,
name|location
parameter_list|,
name|loop_start
parameter_list|,
name|loop_end
parameter_list|)
name|struct
name|induction
modifier|*
name|v
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|rtx
name|src_reg
decl_stmt|;
name|rtx
name|dest_reg
decl_stmt|;
name|rtx
name|mult_val
decl_stmt|,
name|add_val
decl_stmt|;
name|int
name|benefit
decl_stmt|;
name|enum
name|g_types
name|type
decl_stmt|;
name|int
name|not_every_iteration
decl_stmt|;
name|rtx
modifier|*
name|location
decl_stmt|;
name|rtx
name|loop_start
decl_stmt|,
name|loop_end
decl_stmt|;
block|{
name|struct
name|induction
modifier|*
name|b
decl_stmt|;
name|struct
name|iv_class
modifier|*
name|bl
decl_stmt|;
name|rtx
name|set
init|=
name|single_set
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|v
operator|->
name|insn
operator|=
name|insn
expr_stmt|;
name|v
operator|->
name|src_reg
operator|=
name|src_reg
expr_stmt|;
name|v
operator|->
name|giv_type
operator|=
name|type
expr_stmt|;
name|v
operator|->
name|dest_reg
operator|=
name|dest_reg
expr_stmt|;
name|v
operator|->
name|mult_val
operator|=
name|mult_val
expr_stmt|;
name|v
operator|->
name|add_val
operator|=
name|add_val
expr_stmt|;
name|v
operator|->
name|benefit
operator|=
name|benefit
expr_stmt|;
name|v
operator|->
name|location
operator|=
name|location
expr_stmt|;
name|v
operator|->
name|cant_derive
operator|=
literal|0
expr_stmt|;
name|v
operator|->
name|combined_with
operator|=
literal|0
expr_stmt|;
name|v
operator|->
name|maybe_multiple
operator|=
literal|0
expr_stmt|;
name|v
operator|->
name|maybe_dead
operator|=
literal|0
expr_stmt|;
name|v
operator|->
name|derive_adjustment
operator|=
literal|0
expr_stmt|;
name|v
operator|->
name|same
operator|=
literal|0
expr_stmt|;
name|v
operator|->
name|ignore
operator|=
literal|0
expr_stmt|;
name|v
operator|->
name|new_reg
operator|=
literal|0
expr_stmt|;
name|v
operator|->
name|final_value
operator|=
literal|0
expr_stmt|;
name|v
operator|->
name|same_insn
operator|=
literal|0
expr_stmt|;
name|v
operator|->
name|auto_inc_opt
operator|=
literal|0
expr_stmt|;
name|v
operator|->
name|unrolled
operator|=
literal|0
expr_stmt|;
name|v
operator|->
name|shared
operator|=
literal|0
expr_stmt|;
name|v
operator|->
name|derived_from
operator|=
literal|0
expr_stmt|;
name|v
operator|->
name|last_use
operator|=
literal|0
expr_stmt|;
comment|/* The v->always_computable field is used in update_giv_derive, to      determine whether a giv can be used to derive another giv.  For a      DEST_REG giv, INSN computes a new value for the giv, so its value      isn't computable if INSN insn't executed every iteration.      However, for a DEST_ADDR giv, INSN merely uses the value of the giv;      it does not compute a new value.  Hence the value is always computable      regardless of whether INSN is executed each iteration.  */
if|if
condition|(
name|type
operator|==
name|DEST_ADDR
condition|)
name|v
operator|->
name|always_computable
operator|=
literal|1
expr_stmt|;
else|else
name|v
operator|->
name|always_computable
operator|=
operator|!
name|not_every_iteration
expr_stmt|;
name|v
operator|->
name|always_executed
operator|=
operator|!
name|not_every_iteration
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|DEST_ADDR
condition|)
block|{
name|v
operator|->
name|mode
operator|=
name|GET_MODE
argument_list|(
operator|*
name|location
argument_list|)
expr_stmt|;
name|v
operator|->
name|lifetime
operator|=
literal|1
expr_stmt|;
block|}
else|else
comment|/* type == DEST_REG */
block|{
name|v
operator|->
name|mode
operator|=
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
expr_stmt|;
name|v
operator|->
name|lifetime
operator|=
operator|(
name|uid_luid
index|[
name|REGNO_LAST_UID
argument_list|(
name|REGNO
argument_list|(
name|dest_reg
argument_list|)
argument_list|)
index|]
operator|-
name|uid_luid
index|[
name|REGNO_FIRST_UID
argument_list|(
name|REGNO
argument_list|(
name|dest_reg
argument_list|)
argument_list|)
index|]
operator|)
expr_stmt|;
comment|/* If the lifetime is zero, it means that this register is 	 really a dead store.  So mark this as a giv that can be 	 ignored.  This will not prevent the biv from being eliminated.  */
if|if
condition|(
name|v
operator|->
name|lifetime
operator|==
literal|0
condition|)
name|v
operator|->
name|ignore
operator|=
literal|1
expr_stmt|;
name|REG_IV_TYPE
argument_list|(
name|REGNO
argument_list|(
name|dest_reg
argument_list|)
argument_list|)
operator|=
name|GENERAL_INDUCT
expr_stmt|;
name|REG_IV_INFO
argument_list|(
name|REGNO
argument_list|(
name|dest_reg
argument_list|)
argument_list|)
operator|=
name|v
expr_stmt|;
block|}
comment|/* Add the giv to the class of givs computed from one biv.  */
name|bl
operator|=
name|reg_biv_class
index|[
name|REGNO
argument_list|(
name|src_reg
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|bl
condition|)
block|{
name|v
operator|->
name|next_iv
operator|=
name|bl
operator|->
name|giv
expr_stmt|;
name|bl
operator|->
name|giv
operator|=
name|v
expr_stmt|;
comment|/* Don't count DEST_ADDR.  This is supposed to count the number of 	 insns that calculate givs.  */
if|if
condition|(
name|type
operator|==
name|DEST_REG
condition|)
name|bl
operator|->
name|giv_count
operator|++
expr_stmt|;
name|bl
operator|->
name|total_benefit
operator|+=
name|benefit
expr_stmt|;
block|}
else|else
comment|/* Fatal error, biv missing for this giv?  */
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|DEST_ADDR
condition|)
name|v
operator|->
name|replaceable
operator|=
literal|1
expr_stmt|;
else|else
block|{
comment|/* The giv can be replaced outright by the reduced register only if all 	 of the following conditions are true:  	 - the insn that sets the giv is always executed on any iteration 	   on which the giv is used at all 	   (there are two ways to deduce this: 	    either the insn is executed on every iteration, 	    or all uses follow that insn in the same basic block),  	 - the giv is not used outside the loop 	 - no assignments to the biv occur during the giv's lifetime.  */
if|if
condition|(
name|REGNO_FIRST_UID
argument_list|(
name|REGNO
argument_list|(
name|dest_reg
argument_list|)
argument_list|)
operator|==
name|INSN_UID
argument_list|(
name|insn
argument_list|)
comment|/* Previous line always fails if INSN was moved by loop opt.  */
operator|&&
name|uid_luid
index|[
name|REGNO_LAST_UID
argument_list|(
name|REGNO
argument_list|(
name|dest_reg
argument_list|)
argument_list|)
index|]
operator|<
name|INSN_LUID
argument_list|(
name|loop_end
argument_list|)
operator|&&
operator|(
operator|!
name|not_every_iteration
operator|||
name|last_use_this_basic_block
argument_list|(
name|dest_reg
argument_list|,
name|insn
argument_list|)
operator|)
condition|)
block|{
comment|/* Now check that there are no assignments to the biv within the 	     giv's lifetime.  This requires two separate checks.  */
comment|/* Check each biv update, and fail if any are between the first 	     and last use of the giv. 	      	     If this loop contains an inner loop that was unrolled, then 	     the insn modifying the biv may have been emitted by the loop 	     unrolling code, and hence does not have a valid luid.  Just 	     mark the biv as not replaceable in this case.  It is not very 	     useful as a biv, because it is used in two different loops. 	     It is very unlikely that we would be able to optimize the giv 	     using this biv anyways.  */
name|v
operator|->
name|replaceable
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|b
operator|=
name|bl
operator|->
name|biv
init|;
name|b
condition|;
name|b
operator|=
name|b
operator|->
name|next_iv
control|)
block|{
if|if
condition|(
name|INSN_UID
argument_list|(
name|b
operator|->
name|insn
argument_list|)
operator|>=
name|max_uid_for_loop
operator|||
operator|(
operator|(
name|uid_luid
index|[
name|INSN_UID
argument_list|(
name|b
operator|->
name|insn
argument_list|)
index|]
operator|>=
name|uid_luid
index|[
name|REGNO_FIRST_UID
argument_list|(
name|REGNO
argument_list|(
name|dest_reg
argument_list|)
argument_list|)
index|]
operator|)
operator|&&
operator|(
name|uid_luid
index|[
name|INSN_UID
argument_list|(
name|b
operator|->
name|insn
argument_list|)
index|]
operator|<=
name|uid_luid
index|[
name|REGNO_LAST_UID
argument_list|(
name|REGNO
argument_list|(
name|dest_reg
argument_list|)
argument_list|)
index|]
operator|)
operator|)
condition|)
block|{
name|v
operator|->
name|replaceable
operator|=
literal|0
expr_stmt|;
name|v
operator|->
name|not_replaceable
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
comment|/* If there are any backwards branches that go from after the 	     biv update to before it, then this giv is not replaceable.  */
if|if
condition|(
name|v
operator|->
name|replaceable
condition|)
for|for
control|(
name|b
operator|=
name|bl
operator|->
name|biv
init|;
name|b
condition|;
name|b
operator|=
name|b
operator|->
name|next_iv
control|)
if|if
condition|(
name|back_branch_in_range_p
argument_list|(
name|b
operator|->
name|insn
argument_list|,
name|loop_start
argument_list|,
name|loop_end
argument_list|)
condition|)
block|{
name|v
operator|->
name|replaceable
operator|=
literal|0
expr_stmt|;
name|v
operator|->
name|not_replaceable
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
comment|/* May still be replaceable, we don't have enough info here to 	     decide.  */
name|v
operator|->
name|replaceable
operator|=
literal|0
expr_stmt|;
name|v
operator|->
name|not_replaceable
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Record whether the add_val contains a const_int, for later use by      combine_givs.  */
block|{
name|rtx
name|tem
init|=
name|add_val
decl_stmt|;
name|v
operator|->
name|no_const_addval
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|tem
operator|==
name|const0_rtx
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|CONST_INT
condition|)
name|v
operator|->
name|no_const_addval
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|PLUS
condition|)
block|{
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
condition|)
name|tem
operator|=
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|PLUS
condition|)
name|tem
operator|=
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
break|break;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
name|v
operator|->
name|no_const_addval
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|loop_dump_stream
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|DEST_REG
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Insn %d: giv reg %d"
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|,
name|REGNO
argument_list|(
name|dest_reg
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Insn %d: dest address"
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|" src reg %d benefit %d"
argument_list|,
name|REGNO
argument_list|(
name|src_reg
argument_list|)
argument_list|,
name|v
operator|->
name|benefit
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|" lifetime %d"
argument_list|,
name|v
operator|->
name|lifetime
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|replaceable
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|" replaceable"
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|no_const_addval
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|" ncav"
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|mult_val
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|" mult "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|INTVAL
argument_list|(
name|mult_val
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|" mult "
argument_list|)
expr_stmt|;
name|print_rtl
argument_list|(
name|loop_dump_stream
argument_list|,
name|mult_val
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|add_val
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|" add "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|INTVAL
argument_list|(
name|add_val
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|" add "
argument_list|)
expr_stmt|;
name|print_rtl
argument_list|(
name|loop_dump_stream
argument_list|,
name|add_val
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* All this does is determine whether a giv can be made replaceable because    its final value can be calculated.  This code can not be part of record_giv    above, because final_giv_value requires that the number of loop iterations    be known, and that can not be accurately calculated until after all givs    have been identified.  */
end_comment

begin_function
specifier|static
name|void
name|check_final_value
parameter_list|(
name|v
parameter_list|,
name|loop_start
parameter_list|,
name|loop_end
parameter_list|,
name|n_iterations
parameter_list|)
name|struct
name|induction
modifier|*
name|v
decl_stmt|;
name|rtx
name|loop_start
decl_stmt|,
name|loop_end
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|n_iterations
decl_stmt|;
block|{
name|struct
name|iv_class
modifier|*
name|bl
decl_stmt|;
name|rtx
name|final_value
init|=
literal|0
decl_stmt|;
name|bl
operator|=
name|reg_biv_class
index|[
name|REGNO
argument_list|(
name|v
operator|->
name|src_reg
argument_list|)
index|]
expr_stmt|;
comment|/* DEST_ADDR givs will never reach here, because they are always marked      replaceable above in record_giv.  */
comment|/* The giv can be replaced outright by the reduced register only if all      of the following conditions are true:      - the insn that sets the giv is always executed on any iteration        on which the giv is used at all        (there are two ways to deduce this:         either the insn is executed on every iteration,         or all uses follow that insn in the same basic block),      - its final value can be calculated (this condition is different        than the one above in record_giv)      - it's not used before it's set      - no assignments to the biv occur during the giv's lifetime.  */
if|#
directive|if
literal|0
comment|/* This is only called now when replaceable is known to be false.  */
comment|/* Clear replaceable, so that it won't confuse final_giv_value.  */
block|v->replaceable = 0;
endif|#
directive|endif
if|if
condition|(
operator|(
name|final_value
operator|=
name|final_giv_value
argument_list|(
name|v
argument_list|,
name|loop_start
argument_list|,
name|loop_end
argument_list|,
name|n_iterations
argument_list|)
operator|)
operator|&&
operator|(
name|v
operator|->
name|always_computable
operator|||
name|last_use_this_basic_block
argument_list|(
name|v
operator|->
name|dest_reg
argument_list|,
name|v
operator|->
name|insn
argument_list|)
operator|)
condition|)
block|{
name|int
name|biv_increment_seen
init|=
literal|0
decl_stmt|,
name|before_giv_insn
init|=
literal|0
decl_stmt|;
name|rtx
name|p
init|=
name|v
operator|->
name|insn
decl_stmt|;
name|rtx
name|last_giv_use
decl_stmt|;
name|v
operator|->
name|replaceable
operator|=
literal|1
expr_stmt|;
comment|/* When trying to determine whether or not a biv increment occurs 	 during the lifetime of the giv, we can ignore uses of the variable 	 outside the loop because final_value is true.  Hence we can not 	 use regno_last_uid and regno_first_uid as above in record_giv.  */
comment|/* Search the loop to determine whether any assignments to the 	 biv occur during the giv's lifetime.  Start with the insn 	 that sets the giv, and search around the loop until we come 	 back to that insn again.  	 Also fail if there is a jump within the giv's lifetime that jumps 	 to somewhere outside the lifetime but still within the loop.  This 	 catches spaghetti code where the execution order is not linear, and 	 hence the above test fails.  Here we assume that the giv lifetime 	 does not extend from one iteration of the loop to the next, so as 	 to make the test easier.  Since the lifetime isn't known yet, 	 this requires two loops.  See also record_giv above.  */
name|last_giv_use
operator|=
name|v
operator|->
name|insn
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|loop_end
condition|)
block|{
name|before_giv_insn
operator|=
literal|1
expr_stmt|;
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|loop_start
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|==
name|v
operator|->
name|insn
condition|)
break|break;
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|JUMP_INSN
operator|||
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
comment|/* It is possible for the BIV increment to use the GIV if we 		 have a cycle.  Thus we must be sure to check each insn for 		 both BIV and GIV uses, and we must check for BIV uses 		 first.  */
if|if
condition|(
operator|!
name|biv_increment_seen
operator|&&
name|reg_set_p
argument_list|(
name|v
operator|->
name|src_reg
argument_list|,
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
condition|)
name|biv_increment_seen
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|reg_mentioned_p
argument_list|(
name|v
operator|->
name|dest_reg
argument_list|,
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|biv_increment_seen
operator|||
name|before_giv_insn
condition|)
block|{
name|v
operator|->
name|replaceable
operator|=
literal|0
expr_stmt|;
name|v
operator|->
name|not_replaceable
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|last_giv_use
operator|=
name|p
expr_stmt|;
block|}
block|}
block|}
comment|/* Now that the lifetime of the giv is known, check for branches 	 from within the lifetime to outside the lifetime if it is still 	 replaceable.  */
if|if
condition|(
name|v
operator|->
name|replaceable
condition|)
block|{
name|p
operator|=
name|v
operator|->
name|insn
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|loop_end
condition|)
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|loop_start
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|last_giv_use
condition|)
break|break;
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|JUMP_LABEL
argument_list|(
name|p
argument_list|)
operator|&&
name|LABEL_NAME
argument_list|(
name|JUMP_LABEL
argument_list|(
name|p
argument_list|)
argument_list|)
operator|&&
operator|(
operator|(
name|loop_insn_first_p
argument_list|(
name|JUMP_LABEL
argument_list|(
name|p
argument_list|)
argument_list|,
name|v
operator|->
name|insn
argument_list|)
operator|&&
name|loop_insn_first_p
argument_list|(
name|loop_start
argument_list|,
name|JUMP_LABEL
argument_list|(
name|p
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|loop_insn_first_p
argument_list|(
name|last_giv_use
argument_list|,
name|JUMP_LABEL
argument_list|(
name|p
argument_list|)
argument_list|)
operator|&&
name|loop_insn_first_p
argument_list|(
name|JUMP_LABEL
argument_list|(
name|p
argument_list|)
argument_list|,
name|loop_end
argument_list|)
operator|)
operator|)
condition|)
block|{
name|v
operator|->
name|replaceable
operator|=
literal|0
expr_stmt|;
name|v
operator|->
name|not_replaceable
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Found branch outside giv lifetime.\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* If it is replaceable, then save the final value.  */
if|if
condition|(
name|v
operator|->
name|replaceable
condition|)
name|v
operator|->
name|final_value
operator|=
name|final_value
expr_stmt|;
block|}
if|if
condition|(
name|loop_dump_stream
operator|&&
name|v
operator|->
name|replaceable
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Insn %d: giv reg %d final_value replaceable\n"
argument_list|,
name|INSN_UID
argument_list|(
name|v
operator|->
name|insn
argument_list|)
argument_list|,
name|REGNO
argument_list|(
name|v
operator|->
name|dest_reg
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Update the status of whether a giv can derive other givs.     We need to do something special if there is or may be an update to the biv    between the time the giv is defined and the time it is used to derive    another giv.     In addition, a giv that is only conditionally set is not allowed to    derive another giv once a label has been passed.     The cases we look at are when a label or an update to a biv is passed.  */
end_comment

begin_function
specifier|static
name|void
name|update_giv_derive
parameter_list|(
name|p
parameter_list|)
name|rtx
name|p
decl_stmt|;
block|{
name|struct
name|iv_class
modifier|*
name|bl
decl_stmt|;
name|struct
name|induction
modifier|*
name|biv
decl_stmt|,
modifier|*
name|giv
decl_stmt|;
name|rtx
name|tem
decl_stmt|;
name|int
name|dummy
decl_stmt|;
comment|/* Search all IV classes, then all bivs, and finally all givs.       There are three cases we are concerned with.  First we have the situation      of a giv that is only updated conditionally.  In that case, it may not      derive any givs after a label is passed.       The second case is when a biv update occurs, or may occur, after the      definition of a giv.  For certain biv updates (see below) that are      known to occur between the giv definition and use, we can adjust the      giv definition.  For others, or when the biv update is conditional,      we must prevent the giv from deriving any other givs.  There are two      sub-cases within this case.       If this is a label, we are concerned with any biv update that is done      conditionally, since it may be done after the giv is defined followed by      a branch here (actually, we need to pass both a jump and a label, but      this extra tracking doesn't seem worth it).       If this is a jump, we are concerned about any biv update that may be      executed multiple times.  We are actually only concerned about      backward jumps, but it is probably not worth performing the test      on the jump again here.       If this is a biv update, we must adjust the giv status to show that a      subsequent biv update was performed.  If this adjustment cannot be done,      the giv cannot derive further givs.  */
for|for
control|(
name|bl
operator|=
name|loop_iv_list
init|;
name|bl
condition|;
name|bl
operator|=
name|bl
operator|->
name|next
control|)
for|for
control|(
name|biv
operator|=
name|bl
operator|->
name|biv
init|;
name|biv
condition|;
name|biv
operator|=
name|biv
operator|->
name|next_iv
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|CODE_LABEL
operator|||
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|JUMP_INSN
operator|||
name|biv
operator|->
name|insn
operator|==
name|p
condition|)
block|{
for|for
control|(
name|giv
operator|=
name|bl
operator|->
name|giv
init|;
name|giv
condition|;
name|giv
operator|=
name|giv
operator|->
name|next_iv
control|)
block|{
comment|/* If cant_derive is already true, there is no point in 		 checking all of these conditions again.  */
if|if
condition|(
name|giv
operator|->
name|cant_derive
condition|)
continue|continue;
comment|/* If this giv is conditionally set and we have passed a label, 		 it cannot derive anything.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|CODE_LABEL
operator|&&
operator|!
name|giv
operator|->
name|always_computable
condition|)
name|giv
operator|->
name|cant_derive
operator|=
literal|1
expr_stmt|;
comment|/* Skip givs that have mult_val == 0, since 		 they are really invariants.  Also skip those that are 		 replaceable, since we know their lifetime doesn't contain 		 any biv update.  */
elseif|else
if|if
condition|(
name|giv
operator|->
name|mult_val
operator|==
name|const0_rtx
operator|||
name|giv
operator|->
name|replaceable
condition|)
continue|continue;
comment|/* The only way we can allow this giv to derive another 		 is if this is a biv increment and we can form the product 		 of biv->add_val and giv->mult_val.  In this case, we will 		 be able to compute a compensation.  */
elseif|else
if|if
condition|(
name|biv
operator|->
name|insn
operator|==
name|p
condition|)
block|{
name|tem
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|biv
operator|->
name|mult_val
operator|==
name|const1_rtx
condition|)
name|tem
operator|=
name|simplify_giv_expr
argument_list|(
name|gen_rtx_MULT
argument_list|(
name|giv
operator|->
name|mode
argument_list|,
name|biv
operator|->
name|add_val
argument_list|,
name|giv
operator|->
name|mult_val
argument_list|)
argument_list|,
operator|&
name|dummy
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
operator|&&
name|giv
operator|->
name|derive_adjustment
condition|)
name|tem
operator|=
name|simplify_giv_expr
argument_list|(
name|gen_rtx_PLUS
argument_list|(
name|giv
operator|->
name|mode
argument_list|,
name|tem
argument_list|,
name|giv
operator|->
name|derive_adjustment
argument_list|)
argument_list|,
operator|&
name|dummy
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
condition|)
name|giv
operator|->
name|derive_adjustment
operator|=
name|tem
expr_stmt|;
else|else
name|giv
operator|->
name|cant_derive
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|CODE_LABEL
operator|&&
operator|!
name|biv
operator|->
name|always_computable
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|biv
operator|->
name|maybe_multiple
operator|)
condition|)
name|giv
operator|->
name|cant_derive
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Check whether an insn is an increment legitimate for a basic induction var.    X is the source of insn P, or a part of it.    MODE is the mode in which X should be interpreted.     DEST_REG is the putative biv, also the destination of the insn.    We accept patterns of these forms:      REG = REG + INVARIANT (includes REG = REG - CONSTANT)      REG = INVARIANT + REG     If X is suitable, we return 1, set *MULT_VAL to CONST1_RTX,    store the additive term into *INC_VAL, and store the place where    we found the additive term into *LOCATION.     If X is an assignment of an invariant into DEST_REG, we set    *MULT_VAL to CONST0_RTX, and store the invariant into *INC_VAL.     We also want to detect a BIV when it corresponds to a variable    whose mode was promoted via PROMOTED_MODE.  In that case, an increment    of the variable may be a PLUS that adds a SUBREG of that variable to    an invariant and then sign- or zero-extends the result of the PLUS    into the variable.     Most GIVs in such cases will be in the promoted mode, since that is the    probably the natural computation mode (and almost certainly the mode    used for addresses) on the machine.  So we view the pseudo-reg containing    the variable as the BIV, as if it were simply incremented.     Note that treating the entire pseudo as a BIV will result in making    simple increments to any GIVs based on it.  However, if the variable    overflows in its declared mode but not its promoted mode, the result will    be incorrect.  This is acceptable if the variable is signed, since     overflows in such cases are undefined, but not if it is unsigned, since    those overflows are defined.  So we only check for SIGN_EXTEND and    not ZERO_EXTEND.     If we cannot find a biv, we return 0.  */
end_comment

begin_function
specifier|static
name|int
name|basic_induction_var
parameter_list|(
name|x
parameter_list|,
name|mode
parameter_list|,
name|dest_reg
parameter_list|,
name|p
parameter_list|,
name|inc_val
parameter_list|,
name|mult_val
parameter_list|,
name|location
parameter_list|)
specifier|register
name|rtx
name|x
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|p
decl_stmt|;
name|rtx
name|dest_reg
decl_stmt|;
name|rtx
modifier|*
name|inc_val
decl_stmt|;
name|rtx
modifier|*
name|mult_val
decl_stmt|;
name|rtx
modifier|*
modifier|*
name|location
decl_stmt|;
block|{
specifier|register
name|enum
name|rtx_code
name|code
decl_stmt|;
name|rtx
modifier|*
name|argp
decl_stmt|,
name|arg
decl_stmt|;
name|rtx
name|insn
decl_stmt|,
name|set
init|=
literal|0
decl_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PLUS
case|:
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|dest_reg
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
name|SUBREG_PROMOTED_VAR_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|dest_reg
operator|)
condition|)
block|{
name|argp
operator|=
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|dest_reg
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
name|SUBREG_PROMOTED_VAR_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|dest_reg
operator|)
condition|)
block|{
name|argp
operator|=
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
return|return
literal|0
return|;
name|arg
operator|=
operator|*
name|argp
expr_stmt|;
if|if
condition|(
name|invariant_p
argument_list|(
name|arg
argument_list|)
operator|!=
literal|1
condition|)
return|return
literal|0
return|;
operator|*
name|inc_val
operator|=
name|convert_modes
argument_list|(
name|GET_MODE
argument_list|(
name|dest_reg
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|arg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|mult_val
operator|=
name|const1_rtx
expr_stmt|;
operator|*
name|location
operator|=
name|argp
expr_stmt|;
return|return
literal|1
return|;
case|case
name|SUBREG
case|:
comment|/* If this is a SUBREG for a promoted variable, check the inner 	 value.  */
if|if
condition|(
name|SUBREG_PROMOTED_VAR_P
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|basic_induction_var
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|dest_reg
argument_list|,
name|p
argument_list|,
name|inc_val
argument_list|,
name|mult_val
argument_list|,
name|location
argument_list|)
return|;
return|return
literal|0
return|;
case|case
name|REG
case|:
comment|/* If this register is assigned in a previous insn, look at its 	 source, but don't go outside the loop or past a label.  */
name|insn
operator|=
name|p
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|rtx
name|dest
decl_stmt|;
do|do
block|{
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|insn
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE_INSN_LOOP_BEG
condition|)
do|;
if|if
condition|(
operator|!
name|insn
condition|)
break|break;
name|set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|set
operator|==
literal|0
condition|)
break|break;
name|dest
operator|=
name|SET_DEST
argument_list|(
name|set
argument_list|)
expr_stmt|;
if|if
condition|(
name|dest
operator|==
name|x
operator|||
operator|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|<=
name|UNITS_PER_WORD
operator|)
operator|&&
operator|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|==
name|MODE_INT
operator|)
operator|&&
name|SUBREG_REG
argument_list|(
name|dest
argument_list|)
operator|==
name|x
operator|)
condition|)
return|return
name|basic_induction_var
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
operator|(
name|GET_MODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|VOIDmode
condition|?
name|GET_MODE
argument_list|(
name|x
argument_list|)
else|:
name|GET_MODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|)
argument_list|,
name|dest_reg
argument_list|,
name|insn
argument_list|,
name|inc_val
argument_list|,
name|mult_val
argument_list|,
name|location
argument_list|)
return|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SIGN_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|STRICT_LOW_PART
condition|)
name|dest
operator|=
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|dest
operator|==
name|x
condition|)
break|break;
block|}
comment|/* ... fall through ...  */
comment|/* Can accept constant setting of biv only when inside inner most loop.   	 Otherwise, a biv of an inner loop may be incorrectly recognized 	 as a biv of the outer loop, 	 causing code to be moved INTO the inner loop.  */
case|case
name|MEM
case|:
if|if
condition|(
name|invariant_p
argument_list|(
name|x
argument_list|)
operator|!=
literal|1
condition|)
return|return
literal|0
return|;
case|case
name|CONST_INT
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|CONST
case|:
comment|/* convert_modes aborts if we try to convert to or from CCmode, so just          exclude that case.  It is very unlikely that a condition code value 	 would be a useful iterator anyways.  */
if|if
condition|(
name|loops_enclosed
operator|==
literal|1
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|!=
name|MODE_CC
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|dest_reg
argument_list|)
argument_list|)
operator|!=
name|MODE_CC
condition|)
block|{
comment|/* Possible bug here?  Perhaps we don't know the mode of X.  */
operator|*
name|inc_val
operator|=
name|convert_modes
argument_list|(
name|GET_MODE
argument_list|(
name|dest_reg
argument_list|)
argument_list|,
name|mode
argument_list|,
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|mult_val
operator|=
name|const0_rtx
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
return|return
literal|0
return|;
case|case
name|SIGN_EXTEND
case|:
return|return
name|basic_induction_var
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|dest_reg
argument_list|,
name|p
argument_list|,
name|inc_val
argument_list|,
name|mult_val
argument_list|,
name|location
argument_list|)
return|;
case|case
name|ASHIFTRT
case|:
comment|/* Similar, since this can be a sign extension.  */
for|for
control|(
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|p
argument_list|)
init|;
operator|(
name|insn
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE_INSN_LOOP_BEG
operator|)
condition|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
control|)
empty_stmt|;
if|if
condition|(
name|insn
condition|)
name|set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|set
operator|&&
name|SET_DEST
argument_list|(
name|set
argument_list|)
operator|==
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|>=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|ASHIFT
operator|&&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|==
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|basic_induction_var
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|dest_reg
argument_list|,
name|insn
argument_list|,
name|inc_val
argument_list|,
name|mult_val
argument_list|,
name|location
argument_list|)
return|;
return|return
literal|0
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* A general induction variable (giv) is any quantity that is a linear    function   of a basic induction variable,    i.e. giv = biv * mult_val + add_val.    The coefficients can be any loop invariant quantity.    A giv need not be computed directly from the biv;    it can be computed by way of other givs.  */
end_comment

begin_comment
comment|/* Determine whether X computes a giv.    If it does, return a nonzero value      which is the benefit from eliminating the computation of X;    set *SRC_REG to the register of the biv that it is computed from;    set *ADD_VAL and *MULT_VAL to the coefficients,      such that the value of X is biv * mult + add;  */
end_comment

begin_function
specifier|static
name|int
name|general_induction_var
parameter_list|(
name|x
parameter_list|,
name|src_reg
parameter_list|,
name|add_val
parameter_list|,
name|mult_val
parameter_list|,
name|is_addr
parameter_list|,
name|pbenefit
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|rtx
modifier|*
name|src_reg
decl_stmt|;
name|rtx
modifier|*
name|add_val
decl_stmt|;
name|rtx
modifier|*
name|mult_val
decl_stmt|;
name|int
name|is_addr
decl_stmt|;
name|int
modifier|*
name|pbenefit
decl_stmt|;
block|{
name|rtx
name|orig_x
init|=
name|x
decl_stmt|;
name|char
modifier|*
name|storage
decl_stmt|;
comment|/* If this is an invariant, forget it, it isn't a giv.  */
if|if
condition|(
name|invariant_p
argument_list|(
name|x
argument_list|)
operator|==
literal|1
condition|)
return|return
literal|0
return|;
comment|/* See if the expression could be a giv and get its form.      Mark our place on the obstack in case we don't find a giv.  */
name|storage
operator|=
operator|(
name|char
operator|*
operator|)
name|oballoc
argument_list|(
literal|0
argument_list|)
expr_stmt|;
operator|*
name|pbenefit
operator|=
literal|0
expr_stmt|;
name|x
operator|=
name|simplify_giv_expr
argument_list|(
name|x
argument_list|,
name|pbenefit
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
block|{
name|obfree
argument_list|(
name|storage
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|USE
case|:
case|case
name|CONST_INT
case|:
comment|/* Since this is now an invariant and wasn't before, it must be a giv 	 with MULT_VAL == 0.  It doesn't matter which BIV we associate this 	 with.  */
operator|*
name|src_reg
operator|=
name|loop_iv_list
operator|->
name|biv
operator|->
name|dest_reg
expr_stmt|;
operator|*
name|mult_val
operator|=
name|const0_rtx
expr_stmt|;
operator|*
name|add_val
operator|=
name|x
expr_stmt|;
break|break;
case|case
name|REG
case|:
comment|/* This is equivalent to a BIV.  */
operator|*
name|src_reg
operator|=
name|x
expr_stmt|;
operator|*
name|mult_val
operator|=
name|const1_rtx
expr_stmt|;
operator|*
name|add_val
operator|=
name|const0_rtx
expr_stmt|;
break|break;
case|case
name|PLUS
case|:
comment|/* Either (plus (biv) (invar)) or 	 (plus (mult (biv) (invar_1)) (invar_2)).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MULT
condition|)
block|{
operator|*
name|src_reg
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|mult_val
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|src_reg
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|mult_val
operator|=
name|const1_rtx
expr_stmt|;
block|}
operator|*
name|add_val
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|MULT
case|:
comment|/* ADD_VAL is zero.  */
operator|*
name|src_reg
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|mult_val
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|*
name|add_val
operator|=
name|const0_rtx
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Remove any enclosing USE from ADD_VAL and MULT_VAL (there will be      unless they are CONST_INT).  */
if|if
condition|(
name|GET_CODE
argument_list|(
operator|*
name|add_val
argument_list|)
operator|==
name|USE
condition|)
operator|*
name|add_val
operator|=
name|XEXP
argument_list|(
operator|*
name|add_val
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
operator|*
name|mult_val
argument_list|)
operator|==
name|USE
condition|)
operator|*
name|mult_val
operator|=
name|XEXP
argument_list|(
operator|*
name|mult_val
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_addr
condition|)
block|{
ifdef|#
directive|ifdef
name|ADDRESS_COST
operator|*
name|pbenefit
operator|+=
name|ADDRESS_COST
argument_list|(
name|orig_x
argument_list|)
operator|-
name|reg_address_cost
expr_stmt|;
else|#
directive|else
operator|*
name|pbenefit
operator|+=
name|rtx_cost
argument_list|(
name|orig_x
argument_list|,
name|MEM
argument_list|)
operator|-
name|reg_address_cost
expr_stmt|;
endif|#
directive|endif
block|}
else|else
operator|*
name|pbenefit
operator|+=
name|rtx_cost
argument_list|(
name|orig_x
argument_list|,
name|SET
argument_list|)
expr_stmt|;
comment|/* Always return true if this is a giv so it will be detected as such,      even if the benefit is zero or negative.  This allows elimination        of bivs that might otherwise not be eliminated.  */
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given an expression, X, try to form it as a linear function of a biv.    We will canonicalize it to be of the form    	(plus (mult (BIV) (invar_1)) 	      (invar_2))    with possible degeneracies.     The invariant expressions must each be of a form that can be used as a    machine operand.  We surround then with a USE rtx (a hack, but localized    and certainly unambiguous!) if not a CONST_INT for simplicity in this    routine; it is the caller's responsibility to strip them.     If no such canonicalization is possible (i.e., two biv's are used or an    expression that is neither invariant nor a biv or giv), this routine    returns 0.     For a non-zero return, the result will have a code of CONST_INT, USE,    REG (for a BIV), PLUS, or MULT.  No other codes will occur.       *BENEFIT will be incremented by the benefit of any sub-giv encountered.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|sge_plus
name|PROTO
argument_list|(
operator|(
expr|enum
name|machine_mode
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|sge_plus_constant
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|rtx
name|simplify_giv_expr
parameter_list|(
name|x
parameter_list|,
name|benefit
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|int
modifier|*
name|benefit
decl_stmt|;
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|rtx
name|arg0
decl_stmt|,
name|arg1
decl_stmt|;
name|rtx
name|tem
decl_stmt|;
comment|/* If this is not an integer mode, or if we cannot do arithmetic in this      mode, this can't be a giv.  */
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
operator|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|!=
name|MODE_INT
operator|||
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|>
name|HOST_BITS_PER_WIDE_INT
operator|)
condition|)
return|return
name|NULL_RTX
return|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|PLUS
case|:
name|arg0
operator|=
name|simplify_giv_expr
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|benefit
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|simplify_giv_expr
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|benefit
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg0
operator|==
literal|0
operator|||
name|arg1
operator|==
literal|0
condition|)
return|return
name|NULL_RTX
return|;
comment|/* Put constant last, CONST_INT last if both constant.  */
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|USE
operator|||
name|GET_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|CONST_INT
operator|)
operator|&&
operator|!
operator|(
operator|(
name|GET_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|USE
operator|&&
name|GET_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|USE
operator|)
operator|||
name|GET_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|CONST_INT
operator|)
condition|)
name|tem
operator|=
name|arg0
operator|,
name|arg0
operator|=
name|arg1
operator|,
name|arg1
operator|=
name|tem
expr_stmt|;
comment|/* Handle addition of zero, then addition of an invariant.  */
if|if
condition|(
name|arg1
operator|==
name|const0_rtx
condition|)
return|return
name|arg0
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|CONST_INT
operator|||
name|GET_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|USE
condition|)
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|arg0
argument_list|)
condition|)
block|{
case|case
name|CONST_INT
case|:
case|case
name|USE
case|:
comment|/* Adding two invariants must result in an invariant, so enclose  	       addition operation inside a USE and return it.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|USE
condition|)
name|arg0
operator|=
name|XEXP
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|USE
condition|)
name|arg1
operator|=
name|XEXP
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|CONST_INT
condition|)
name|tem
operator|=
name|arg0
operator|,
name|arg0
operator|=
name|arg1
operator|,
name|arg1
operator|=
name|tem
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|CONST_INT
condition|)
name|tem
operator|=
name|sge_plus_constant
argument_list|(
name|arg0
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
else|else
name|tem
operator|=
name|sge_plus
argument_list|(
name|mode
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|!=
name|CONST_INT
condition|)
name|tem
operator|=
name|gen_rtx_USE
argument_list|(
name|mode
argument_list|,
name|tem
argument_list|)
expr_stmt|;
return|return
name|tem
return|;
case|case
name|REG
case|:
case|case
name|MULT
case|:
comment|/* biv + invar or mult + invar.  Return sum.  */
return|return
name|gen_rtx_PLUS
argument_list|(
name|mode
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
return|;
case|case
name|PLUS
case|:
comment|/* (a + invar_1) + invar_2.  Associate.  */
return|return
name|simplify_giv_expr
argument_list|(
name|gen_rtx_PLUS
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|arg1
argument_list|)
argument_list|)
argument_list|,
name|benefit
argument_list|)
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Each argument must be either REG, PLUS, or MULT.  Convert REG to 	 MULT to reduce cases.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|REG
condition|)
name|arg0
operator|=
name|gen_rtx_MULT
argument_list|(
name|mode
argument_list|,
name|arg0
argument_list|,
name|const1_rtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|REG
condition|)
name|arg1
operator|=
name|gen_rtx_MULT
argument_list|(
name|mode
argument_list|,
name|arg1
argument_list|,
name|const1_rtx
argument_list|)
expr_stmt|;
comment|/* Now have PLUS + PLUS, PLUS + MULT, MULT + PLUS, or MULT + MULT. 	 Put a MULT first, leaving PLUS + PLUS, MULT + PLUS, or MULT + MULT. 	 Recurse to associate the second PLUS.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|MULT
condition|)
name|tem
operator|=
name|arg0
operator|,
name|arg0
operator|=
name|arg1
operator|,
name|arg1
operator|=
name|tem
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|PLUS
condition|)
return|return
name|simplify_giv_expr
argument_list|(
name|gen_rtx_PLUS
argument_list|(
name|mode
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|mode
argument_list|,
name|arg0
argument_list|,
name|XEXP
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|benefit
argument_list|)
return|;
comment|/* Now must have MULT + MULT.  Distribute if same biv, else not giv.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|arg0
argument_list|)
operator|!=
name|MULT
operator|||
name|GET_CODE
argument_list|(
name|arg1
argument_list|)
operator|!=
name|MULT
condition|)
return|return
name|NULL_RTX
return|;
if|if
condition|(
operator|!
name|rtx_equal_p
argument_list|(
name|arg0
argument_list|,
name|arg1
argument_list|)
condition|)
return|return
name|NULL_RTX
return|;
return|return
name|simplify_giv_expr
argument_list|(
name|gen_rtx_MULT
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|benefit
argument_list|)
return|;
case|case
name|MINUS
case|:
comment|/* Handle "a - b" as "a + b * (-1)".  */
return|return
name|simplify_giv_expr
argument_list|(
name|gen_rtx_PLUS
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|gen_rtx_MULT
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|constm1_rtx
argument_list|)
argument_list|)
argument_list|,
name|benefit
argument_list|)
return|;
case|case
name|MULT
case|:
name|arg0
operator|=
name|simplify_giv_expr
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|benefit
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|simplify_giv_expr
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|benefit
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg0
operator|==
literal|0
operator|||
name|arg1
operator|==
literal|0
condition|)
return|return
name|NULL_RTX
return|;
comment|/* Put constant last, CONST_INT last if both constant.  */
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|USE
operator|||
name|GET_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|CONST_INT
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|arg1
argument_list|)
operator|!=
name|CONST_INT
condition|)
name|tem
operator|=
name|arg0
operator|,
name|arg0
operator|=
name|arg1
operator|,
name|arg1
operator|=
name|tem
expr_stmt|;
comment|/* If second argument is not now constant, not giv.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|arg1
argument_list|)
operator|!=
name|USE
operator|&&
name|GET_CODE
argument_list|(
name|arg1
argument_list|)
operator|!=
name|CONST_INT
condition|)
return|return
name|NULL_RTX
return|;
comment|/* Handle multiply by 0 or 1.  */
if|if
condition|(
name|arg1
operator|==
name|const0_rtx
condition|)
return|return
name|const0_rtx
return|;
elseif|else
if|if
condition|(
name|arg1
operator|==
name|const1_rtx
condition|)
return|return
name|arg0
return|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|arg0
argument_list|)
condition|)
block|{
case|case
name|REG
case|:
comment|/* biv * invar.  Done.  */
return|return
name|gen_rtx_MULT
argument_list|(
name|mode
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
return|;
case|case
name|CONST_INT
case|:
comment|/* Product of two constants.  */
return|return
name|GEN_INT
argument_list|(
name|INTVAL
argument_list|(
name|arg0
argument_list|)
operator|*
name|INTVAL
argument_list|(
name|arg1
argument_list|)
argument_list|)
return|;
case|case
name|USE
case|:
comment|/* invar * invar.  It is a giv, but very few of these will  	     actually pay off, so limit to simple registers.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|arg1
argument_list|)
operator|!=
name|CONST_INT
condition|)
return|return
name|NULL_RTX
return|;
name|arg0
operator|=
name|XEXP
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|REG
condition|)
name|tem
operator|=
name|gen_rtx_MULT
argument_list|(
name|mode
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|MULT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|tem
operator|=
name|gen_rtx_MULT
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|*
name|INTVAL
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
return|return
name|NULL_RTX
return|;
return|return
name|gen_rtx_USE
argument_list|(
name|mode
argument_list|,
name|tem
argument_list|)
return|;
case|case
name|MULT
case|:
comment|/* (a * invar_1) * invar_2.  Associate.  */
return|return
name|simplify_giv_expr
argument_list|(
name|gen_rtx_MULT
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|gen_rtx_MULT
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|arg1
argument_list|)
argument_list|)
argument_list|,
name|benefit
argument_list|)
return|;
case|case
name|PLUS
case|:
comment|/* (a + invar_1) * invar_2.  Distribute.  */
return|return
name|simplify_giv_expr
argument_list|(
name|gen_rtx_PLUS
argument_list|(
name|mode
argument_list|,
name|gen_rtx_MULT
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|arg1
argument_list|)
argument_list|,
name|gen_rtx_MULT
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|arg1
argument_list|)
argument_list|)
argument_list|,
name|benefit
argument_list|)
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
case|case
name|ASHIFT
case|:
comment|/* Shift by constant is multiply by power of two.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
condition|)
return|return
literal|0
return|;
return|return
name|simplify_giv_expr
argument_list|(
name|gen_rtx_MULT
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|benefit
argument_list|)
return|;
case|case
name|NEG
case|:
comment|/* "-a" is "a * (-1)" */
return|return
name|simplify_giv_expr
argument_list|(
name|gen_rtx_MULT
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|constm1_rtx
argument_list|)
argument_list|,
name|benefit
argument_list|)
return|;
case|case
name|NOT
case|:
comment|/* "~a" is "-a - 1". Silly, but easy.  */
return|return
name|simplify_giv_expr
argument_list|(
name|gen_rtx_MINUS
argument_list|(
name|mode
argument_list|,
name|gen_rtx_NEG
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|const1_rtx
argument_list|)
argument_list|,
name|benefit
argument_list|)
return|;
case|case
name|USE
case|:
comment|/* Already in proper form for invariant.  */
return|return
name|x
return|;
case|case
name|REG
case|:
comment|/* If this is a new register, we can't deal with it.  */
if|if
condition|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|>=
name|max_reg_before_loop
condition|)
return|return
literal|0
return|;
comment|/* Check for biv or giv.  */
switch|switch
condition|(
name|REG_IV_TYPE
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|BASIC_INDUCT
case|:
return|return
name|x
return|;
case|case
name|GENERAL_INDUCT
case|:
block|{
name|struct
name|induction
modifier|*
name|v
init|=
name|REG_IV_INFO
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Form expression from giv and add benefit.  Ensure this giv 	       can derive another and subtract any needed adjustment if so.  */
operator|*
name|benefit
operator|+=
name|v
operator|->
name|benefit
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|cant_derive
condition|)
return|return
literal|0
return|;
name|tem
operator|=
name|gen_rtx_PLUS
argument_list|(
name|mode
argument_list|,
name|gen_rtx_MULT
argument_list|(
name|mode
argument_list|,
name|v
operator|->
name|src_reg
argument_list|,
name|v
operator|->
name|mult_val
argument_list|)
argument_list|,
name|v
operator|->
name|add_val
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|derive_adjustment
condition|)
name|tem
operator|=
name|gen_rtx_MINUS
argument_list|(
name|mode
argument_list|,
name|tem
argument_list|,
name|v
operator|->
name|derive_adjustment
argument_list|)
expr_stmt|;
return|return
name|simplify_giv_expr
argument_list|(
name|tem
argument_list|,
name|benefit
argument_list|)
return|;
block|}
default|default:
comment|/* If it isn't an induction variable, and it is invariant, we 	     may be able to simplify things further by looking through 	     the bits we just moved outside the loop.  */
if|if
condition|(
name|invariant_p
argument_list|(
name|x
argument_list|)
operator|==
literal|1
condition|)
block|{
name|struct
name|movable
modifier|*
name|m
decl_stmt|;
for|for
control|(
name|m
operator|=
name|the_movables
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|next
control|)
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|x
argument_list|,
name|m
operator|->
name|set_dest
argument_list|)
condition|)
block|{
comment|/* Ok, we found a match.  Substitute and simplify.  */
comment|/* If we match another movable, we must use that, as  		       this one is going away.  */
if|if
condition|(
name|m
operator|->
name|match
condition|)
return|return
name|simplify_giv_expr
argument_list|(
name|m
operator|->
name|match
operator|->
name|set_dest
argument_list|,
name|benefit
argument_list|)
return|;
comment|/* If consec is non-zero, this is a member of a group of 		       instructions that were moved together.  We handle this 		       case only to the point of seeking to the last insn and 		       looking for a REG_EQUAL.  Fail if we don't find one.  */
if|if
condition|(
name|m
operator|->
name|consec
operator|!=
literal|0
condition|)
block|{
name|int
name|i
init|=
name|m
operator|->
name|consec
decl_stmt|;
name|tem
operator|=
name|m
operator|->
name|insn
expr_stmt|;
do|do
block|{
name|tem
operator|=
name|NEXT_INSN
argument_list|(
name|tem
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|i
operator|>
literal|0
condition|)
do|;
name|tem
operator|=
name|find_reg_note
argument_list|(
name|tem
argument_list|,
name|REG_EQUAL
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
condition|)
name|tem
operator|=
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tem
operator|=
name|single_set
argument_list|(
name|m
operator|->
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
condition|)
name|tem
operator|=
name|SET_SRC
argument_list|(
name|tem
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tem
condition|)
block|{
comment|/* What we are most interested in is pointer 			   arithmetic on invariants -- only take 			   patterns we may be able to do something with.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|PLUS
operator|||
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|MULT
operator|||
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|ASHIFT
operator|||
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|CONST_INT
operator|||
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
block|{
name|tem
operator|=
name|simplify_giv_expr
argument_list|(
name|tem
argument_list|,
name|benefit
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
condition|)
return|return
name|tem
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|tem
operator|=
name|simplify_giv_expr
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|,
name|benefit
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
condition|)
return|return
name|tem
return|;
block|}
block|}
break|break;
block|}
block|}
break|break;
block|}
comment|/* Fall through to general case.  */
default|default:
comment|/* If invariant, return as USE (unless CONST_INT). 	 Otherwise, not giv.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|USE
condition|)
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|invariant_p
argument_list|(
name|x
argument_list|)
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|x
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|gen_rtx_USE
argument_list|(
name|mode
argument_list|,
name|x
argument_list|)
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* This routine folds invariants such that there is only ever one    CONST_INT in the summation.  It is only used by simplify_giv_expr.  */
end_comment

begin_function
specifier|static
name|rtx
name|sge_plus_constant
parameter_list|(
name|x
parameter_list|,
name|c
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|c
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|GEN_INT
argument_list|(
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|+
name|INTVAL
argument_list|(
name|c
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|PLUS
condition|)
return|return
name|gen_rtx_PLUS
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|x
argument_list|,
name|c
argument_list|)
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
return|return
name|gen_rtx_PLUS
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|+
name|INTVAL
argument_list|(
name|c
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|PLUS
condition|)
block|{
return|return
name|gen_rtx_PLUS
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|sge_plus_constant
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|c
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|gen_rtx_PLUS
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|sge_plus_constant
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|c
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|rtx
name|sge_plus
parameter_list|(
name|mode
parameter_list|,
name|x
parameter_list|,
name|y
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|x
decl_stmt|,
name|y
decl_stmt|;
block|{
while|while
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|rtx
name|a
init|=
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|a
argument_list|)
operator|==
name|CONST_INT
condition|)
name|x
operator|=
name|sge_plus_constant
argument_list|(
name|x
argument_list|,
name|a
argument_list|)
expr_stmt|;
else|else
name|x
operator|=
name|gen_rtx_PLUS
argument_list|(
name|mode
argument_list|,
name|x
argument_list|,
name|a
argument_list|)
expr_stmt|;
name|y
operator|=
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|CONST_INT
condition|)
name|x
operator|=
name|sge_plus_constant
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
else|else
name|x
operator|=
name|gen_rtx_PLUS
argument_list|(
name|mode
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Help detect a giv that is calculated by several consecutive insns;    for example,       giv = biv * M       giv = giv + A    The caller has already identified the first insn P as having a giv as dest;    we check that all other insns that set the same register follow    immediately after P, that they alter nothing else,    and that the result of the last is still a giv.     The value is 0 if the reg set in P is not really a giv.    Otherwise, the value is the amount gained by eliminating    all the consecutive insns that compute the value.     FIRST_BENEFIT is the amount gained by eliminating the first insn, P.    SRC_REG is the reg of the biv; DEST_REG is the reg of the giv.     The coefficients of the ultimate giv value are stored in    *MULT_VAL and *ADD_VAL.  */
end_comment

begin_function
specifier|static
name|int
name|consec_sets_giv
parameter_list|(
name|first_benefit
parameter_list|,
name|p
parameter_list|,
name|src_reg
parameter_list|,
name|dest_reg
parameter_list|,
name|add_val
parameter_list|,
name|mult_val
parameter_list|,
name|last_consec_insn
parameter_list|)
name|int
name|first_benefit
decl_stmt|;
name|rtx
name|p
decl_stmt|;
name|rtx
name|src_reg
decl_stmt|;
name|rtx
name|dest_reg
decl_stmt|;
name|rtx
modifier|*
name|add_val
decl_stmt|;
name|rtx
modifier|*
name|mult_val
decl_stmt|;
name|rtx
modifier|*
name|last_consec_insn
decl_stmt|;
block|{
name|int
name|count
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
name|int
name|benefit
decl_stmt|;
name|rtx
name|temp
decl_stmt|;
name|rtx
name|set
decl_stmt|;
comment|/* Indicate that this is a giv so that we can update the value produced in      each insn of the multi-insn sequence.        This induction structure will be used only by the call to      general_induction_var below, so we can allocate it on our stack.      If this is a giv, our caller will replace the induct var entry with      a new induction structure.  */
name|struct
name|induction
modifier|*
name|v
init|=
operator|(
expr|struct
name|induction
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|induction
argument_list|)
argument_list|)
decl_stmt|;
name|v
operator|->
name|src_reg
operator|=
name|src_reg
expr_stmt|;
name|v
operator|->
name|mult_val
operator|=
operator|*
name|mult_val
expr_stmt|;
name|v
operator|->
name|add_val
operator|=
operator|*
name|add_val
expr_stmt|;
name|v
operator|->
name|benefit
operator|=
name|first_benefit
expr_stmt|;
name|v
operator|->
name|cant_derive
operator|=
literal|0
expr_stmt|;
name|v
operator|->
name|derive_adjustment
operator|=
literal|0
expr_stmt|;
name|REG_IV_TYPE
argument_list|(
name|REGNO
argument_list|(
name|dest_reg
argument_list|)
argument_list|)
operator|=
name|GENERAL_INDUCT
expr_stmt|;
name|REG_IV_INFO
argument_list|(
name|REGNO
argument_list|(
name|dest_reg
argument_list|)
argument_list|)
operator|=
name|v
expr_stmt|;
name|count
operator|=
name|VARRAY_INT
argument_list|(
name|n_times_set
argument_list|,
name|REGNO
argument_list|(
name|dest_reg
argument_list|)
argument_list|)
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* If libcall, skip to end of call sequence.  */
if|if
condition|(
name|code
operator|==
name|INSN
operator|&&
operator|(
name|temp
operator|=
name|find_reg_note
argument_list|(
name|p
argument_list|,
name|REG_LIBCALL
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
condition|)
name|p
operator|=
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|INSN
operator|&&
operator|(
name|set
operator|=
name|single_set
argument_list|(
name|p
argument_list|)
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|SET_DEST
argument_list|(
name|set
argument_list|)
operator|==
name|dest_reg
operator|&&
operator|(
name|general_induction_var
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
operator|&
name|src_reg
argument_list|,
name|add_val
argument_list|,
name|mult_val
argument_list|,
literal|0
argument_list|,
operator|&
name|benefit
argument_list|)
comment|/* Giv created by equivalent expression.  */
operator|||
operator|(
operator|(
name|temp
operator|=
name|find_reg_note
argument_list|(
name|p
argument_list|,
name|REG_EQUAL
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
operator|&&
name|general_induction_var
argument_list|(
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|src_reg
argument_list|,
name|add_val
argument_list|,
name|mult_val
argument_list|,
literal|0
argument_list|,
operator|&
name|benefit
argument_list|)
operator|)
operator|)
operator|&&
name|src_reg
operator|==
name|v
operator|->
name|src_reg
condition|)
block|{
if|if
condition|(
name|find_reg_note
argument_list|(
name|p
argument_list|,
name|REG_RETVAL
argument_list|,
name|NULL_RTX
argument_list|)
condition|)
name|benefit
operator|+=
name|libcall_benefit
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|count
operator|--
expr_stmt|;
name|v
operator|->
name|mult_val
operator|=
operator|*
name|mult_val
expr_stmt|;
name|v
operator|->
name|add_val
operator|=
operator|*
name|add_val
expr_stmt|;
name|v
operator|->
name|benefit
operator|=
name|benefit
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|!=
name|NOTE
condition|)
block|{
comment|/* Allow insns that set something other than this giv to a 	     constant.  Such insns are needed on machines which cannot 	     include long constants and should not disqualify a giv.  */
if|if
condition|(
name|code
operator|==
name|INSN
operator|&&
operator|(
name|set
operator|=
name|single_set
argument_list|(
name|p
argument_list|)
operator|)
operator|&&
name|SET_DEST
argument_list|(
name|set
argument_list|)
operator|!=
name|dest_reg
operator|&&
name|CONSTANT_P
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
condition|)
continue|continue;
name|REG_IV_TYPE
argument_list|(
name|REGNO
argument_list|(
name|dest_reg
argument_list|)
argument_list|)
operator|=
name|UNKNOWN_INDUCT
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
operator|*
name|last_consec_insn
operator|=
name|p
expr_stmt|;
return|return
name|v
operator|->
name|benefit
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return an rtx, if any, that expresses giv G2 as a function of the register    represented by G1.  If no such expression can be found, or it is clear that    it cannot possibly be a valid address, 0 is returned.      To perform the computation, we note that    	G1 = x * v + a		and 	G2 = y * v + b    where `v' is the biv.     So G2 = (y/b) * G1 + (b - a*y/x).     Note that MULT = y/x.     Update: A and B are now allowed to be additive expressions such that    B contains all variables in A.  That is, computing B-A will not require    subtracting variables.  */
end_comment

begin_function
specifier|static
name|rtx
name|express_from_1
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|mult
parameter_list|)
name|rtx
name|a
decl_stmt|,
name|b
decl_stmt|,
name|mult
decl_stmt|;
block|{
comment|/* If MULT is zero, then A*MULT is zero, and our expression is B.  */
if|if
condition|(
name|mult
operator|==
name|const0_rtx
condition|)
return|return
name|b
return|;
comment|/* If MULT is not 1, we cannot handle A with non-constants, since we      would then be required to subtract multiples of the registers in A.      This is theoretically possible, and may even apply to some Fortran      constructs, but it is a lot of work and we do not attempt it here.  */
if|if
condition|(
name|mult
operator|!=
name|const1_rtx
operator|&&
name|GET_CODE
argument_list|(
name|a
argument_list|)
operator|!=
name|CONST_INT
condition|)
return|return
name|NULL_RTX
return|;
comment|/* In general these structures are sorted top to bottom (down the PLUS      chain), but not left to right across the PLUS.  If B is a higher      order giv than A, we can strip one level and recurse.  If A is higher      order, we'll eventually bail out, but won't know that until the end.      If they are the same, we'll strip one level around this loop.  */
while|while
condition|(
name|GET_CODE
argument_list|(
name|a
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|b
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|rtx
name|ra
decl_stmt|,
name|rb
decl_stmt|,
name|oa
decl_stmt|,
name|ob
decl_stmt|,
name|tmp
decl_stmt|;
name|ra
operator|=
name|XEXP
argument_list|(
name|a
argument_list|,
literal|0
argument_list|)
operator|,
name|oa
operator|=
name|XEXP
argument_list|(
name|a
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|ra
argument_list|)
operator|==
name|PLUS
condition|)
name|tmp
operator|=
name|ra
operator|,
name|ra
operator|=
name|oa
operator|,
name|oa
operator|=
name|tmp
expr_stmt|;
name|rb
operator|=
name|XEXP
argument_list|(
name|b
argument_list|,
literal|0
argument_list|)
operator|,
name|ob
operator|=
name|XEXP
argument_list|(
name|b
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|rb
argument_list|)
operator|==
name|PLUS
condition|)
name|tmp
operator|=
name|rb
operator|,
name|rb
operator|=
name|ob
operator|,
name|ob
operator|=
name|tmp
expr_stmt|;
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|ra
argument_list|,
name|rb
argument_list|)
condition|)
comment|/* We matched: remove one reg completely.  */
name|a
operator|=
name|oa
operator|,
name|b
operator|=
name|ob
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|ob
argument_list|)
operator|!=
name|PLUS
operator|&&
name|rtx_equal_p
argument_list|(
name|ra
argument_list|,
name|ob
argument_list|)
condition|)
comment|/* An alternate match.  */
name|a
operator|=
name|oa
operator|,
name|b
operator|=
name|rb
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|oa
argument_list|)
operator|!=
name|PLUS
operator|&&
name|rtx_equal_p
argument_list|(
name|oa
argument_list|,
name|rb
argument_list|)
condition|)
comment|/* An alternate match.  */
name|a
operator|=
name|ra
operator|,
name|b
operator|=
name|ob
expr_stmt|;
else|else
block|{
comment|/* Indicates an extra register in B.  Strip one level from B and  	     recurse, hoping B was the higher order expression.  */
name|ob
operator|=
name|express_from_1
argument_list|(
name|a
argument_list|,
name|ob
argument_list|,
name|mult
argument_list|)
expr_stmt|;
if|if
condition|(
name|ob
operator|==
name|NULL_RTX
condition|)
return|return
name|NULL_RTX
return|;
return|return
name|gen_rtx_PLUS
argument_list|(
name|GET_MODE
argument_list|(
name|b
argument_list|)
argument_list|,
name|rb
argument_list|,
name|ob
argument_list|)
return|;
block|}
block|}
comment|/* Here we are at the last level of A, go through the cases hoping to      get rid of everything but a constant.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|a
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|rtx
name|ra
decl_stmt|,
name|oa
decl_stmt|;
name|ra
operator|=
name|XEXP
argument_list|(
name|a
argument_list|,
literal|0
argument_list|)
operator|,
name|oa
operator|=
name|XEXP
argument_list|(
name|a
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|oa
argument_list|,
name|b
argument_list|)
condition|)
name|oa
operator|=
name|ra
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|rtx_equal_p
argument_list|(
name|ra
argument_list|,
name|b
argument_list|)
condition|)
return|return
name|NULL_RTX
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|oa
argument_list|)
operator|!=
name|CONST_INT
condition|)
return|return
name|NULL_RTX
return|;
return|return
name|GEN_INT
argument_list|(
operator|-
name|INTVAL
argument_list|(
name|oa
argument_list|)
operator|*
name|INTVAL
argument_list|(
name|mult
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|a
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
return|return
name|plus_constant
argument_list|(
name|b
argument_list|,
operator|-
name|INTVAL
argument_list|(
name|a
argument_list|)
operator|*
name|INTVAL
argument_list|(
name|mult
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|b
argument_list|)
operator|==
name|PLUS
condition|)
block|{
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|a
argument_list|,
name|XEXP
argument_list|(
name|b
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|XEXP
argument_list|(
name|b
argument_list|,
literal|1
argument_list|)
return|;
elseif|else
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|a
argument_list|,
name|XEXP
argument_list|(
name|b
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
return|return
name|XEXP
argument_list|(
name|b
argument_list|,
literal|0
argument_list|)
return|;
else|else
return|return
name|NULL_RTX
return|;
block|}
elseif|else
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
condition|)
return|return
name|const0_rtx
return|;
return|return
name|NULL_RTX
return|;
block|}
end_function

begin_function
name|rtx
name|express_from
parameter_list|(
name|g1
parameter_list|,
name|g2
parameter_list|)
name|struct
name|induction
modifier|*
name|g1
decl_stmt|,
decl|*
name|g2
decl_stmt|;
end_function

begin_block
block|{
name|rtx
name|mult
decl_stmt|,
name|add
decl_stmt|;
comment|/* The value that G1 will be multiplied by must be a constant integer.  Also,      the only chance we have of getting a valid address is if b*c/a (see above      for notation) is also an integer.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|g1
operator|->
name|mult_val
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|g2
operator|->
name|mult_val
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
if|if
condition|(
name|g1
operator|->
name|mult_val
operator|==
name|const0_rtx
operator|||
name|INTVAL
argument_list|(
name|g2
operator|->
name|mult_val
argument_list|)
operator|%
name|INTVAL
argument_list|(
name|g1
operator|->
name|mult_val
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|NULL_RTX
return|;
name|mult
operator|=
name|GEN_INT
argument_list|(
name|INTVAL
argument_list|(
name|g2
operator|->
name|mult_val
argument_list|)
operator|/
name|INTVAL
argument_list|(
name|g1
operator|->
name|mult_val
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|g1
operator|->
name|mult_val
argument_list|,
name|g2
operator|->
name|mult_val
argument_list|)
condition|)
name|mult
operator|=
name|const1_rtx
expr_stmt|;
else|else
block|{
comment|/* ??? Find out if the one is a multiple of the other?  */
return|return
name|NULL_RTX
return|;
block|}
name|add
operator|=
name|express_from_1
argument_list|(
name|g1
operator|->
name|add_val
argument_list|,
name|g2
operator|->
name|add_val
argument_list|,
name|mult
argument_list|)
expr_stmt|;
if|if
condition|(
name|add
operator|==
name|NULL_RTX
condition|)
return|return
name|NULL_RTX
return|;
comment|/* Form simplified final result.  */
if|if
condition|(
name|mult
operator|==
name|const0_rtx
condition|)
return|return
name|add
return|;
elseif|else
if|if
condition|(
name|mult
operator|==
name|const1_rtx
condition|)
name|mult
operator|=
name|g1
operator|->
name|dest_reg
expr_stmt|;
else|else
name|mult
operator|=
name|gen_rtx_MULT
argument_list|(
name|g2
operator|->
name|mode
argument_list|,
name|g1
operator|->
name|dest_reg
argument_list|,
name|mult
argument_list|)
expr_stmt|;
if|if
condition|(
name|add
operator|==
name|const0_rtx
condition|)
return|return
name|mult
return|;
else|else
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|add
argument_list|)
operator|==
name|PLUS
operator|&&
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|add
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|tem
init|=
name|XEXP
argument_list|(
name|add
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|mult
operator|=
name|gen_rtx_PLUS
argument_list|(
name|g2
operator|->
name|mode
argument_list|,
name|mult
argument_list|,
name|XEXP
argument_list|(
name|add
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|add
operator|=
name|tem
expr_stmt|;
block|}
return|return
name|gen_rtx_PLUS
argument_list|(
name|g2
operator|->
name|mode
argument_list|,
name|mult
argument_list|,
name|add
argument_list|)
return|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Return an rtx, if any, that expresses giv G2 as a function of the register    represented by G1.  This indicates that G2 should be combined with G1 and    that G2 can use (either directly or via an address expression) a register    used to represent G1.  */
end_comment

begin_function
specifier|static
name|rtx
name|combine_givs_p
parameter_list|(
name|g1
parameter_list|,
name|g2
parameter_list|)
name|struct
name|induction
modifier|*
name|g1
decl_stmt|,
decl|*
name|g2
decl_stmt|;
end_function

begin_block
block|{
name|rtx
name|tem
init|=
name|express_from
argument_list|(
name|g1
argument_list|,
name|g2
argument_list|)
decl_stmt|;
comment|/* If these givs are identical, they can be combined.  We use the results      of express_from because the addends are not in a canonical form, so      rtx_equal_p is a weaker test.  */
comment|/* But don't combine a DEST_REG giv with a DEST_ADDR giv; we want the      combination to be the other way round.  */
if|if
condition|(
name|tem
operator|==
name|g1
operator|->
name|dest_reg
operator|&&
operator|(
name|g1
operator|->
name|giv_type
operator|==
name|DEST_REG
operator|||
name|g2
operator|->
name|giv_type
operator|==
name|DEST_ADDR
operator|)
condition|)
block|{
return|return
name|g1
operator|->
name|dest_reg
return|;
block|}
comment|/* If G2 can be expressed as a function of G1 and that function is valid      as an address and no more expensive than using a register for G2,      the expression of G2 in terms of G1 can be used.  */
if|if
condition|(
name|tem
operator|!=
name|NULL_RTX
operator|&&
name|g2
operator|->
name|giv_type
operator|==
name|DEST_ADDR
operator|&&
name|memory_address_p
argument_list|(
name|g2
operator|->
name|mem_mode
argument_list|,
name|tem
argument_list|)
comment|/* ??? Looses, especially with -fforce-addr, where *g2->location 	 will always be a register, and so anything more complicated 	 gets discarded.  */
if|#
directive|if
literal|0
ifdef|#
directive|ifdef
name|ADDRESS_COST
condition|&& ADDRESS_COST (tem)<= ADDRESS_COST (*g2->location)
else|#
directive|else
condition|&& rtx_cost (tem, MEM)<= rtx_cost (*g2->location, MEM)
endif|#
directive|endif
endif|#
directive|endif
condition|)
block|{
return|return
name|tem
return|;
block|}
return|return
name|NULL_RTX
return|;
block|}
end_block

begin_escape
end_escape

begin_struct
struct|struct
name|combine_givs_stats
block|{
name|int
name|giv_number
decl_stmt|;
name|int
name|total_benefit
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|cmp_combine_givs_stats
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
name|struct
name|combine_givs_stats
modifier|*
name|x
decl_stmt|,
decl|*
name|y
decl_stmt|;
end_function

begin_block
block|{
name|int
name|d
decl_stmt|;
name|d
operator|=
name|y
operator|->
name|total_benefit
operator|-
name|x
operator|->
name|total_benefit
expr_stmt|;
comment|/* Stabilize the sort.  */
if|if
condition|(
operator|!
name|d
condition|)
name|d
operator|=
name|x
operator|->
name|giv_number
operator|-
name|y
operator|->
name|giv_number
expr_stmt|;
return|return
name|d
return|;
block|}
end_block

begin_comment
comment|/* Check all pairs of givs for iv_class BL and see if any can be combined with    any other.  If so, point SAME to the giv combined with and set NEW_REG to    be an expression (in terms of the other giv's DEST_REG) equivalent to the    giv.  Also, update BENEFIT and related fields for cost/benefit analysis.  */
end_comment

begin_function
specifier|static
name|void
name|combine_givs
parameter_list|(
name|bl
parameter_list|)
name|struct
name|iv_class
modifier|*
name|bl
decl_stmt|;
block|{
comment|/* Additional benefit to add for being combined multiple times.  */
specifier|const
name|int
name|extra_benefit
init|=
literal|3
decl_stmt|;
name|struct
name|induction
modifier|*
name|g1
decl_stmt|,
modifier|*
name|g2
decl_stmt|,
modifier|*
modifier|*
name|giv_array
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|giv_count
decl_stmt|;
name|struct
name|combine_givs_stats
modifier|*
name|stats
decl_stmt|;
name|rtx
modifier|*
name|can_combine
decl_stmt|;
comment|/* Count givs, because bl->giv_count is incorrect here.  */
name|giv_count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|g1
operator|=
name|bl
operator|->
name|giv
init|;
name|g1
condition|;
name|g1
operator|=
name|g1
operator|->
name|next_iv
control|)
if|if
condition|(
operator|!
name|g1
operator|->
name|ignore
condition|)
name|giv_count
operator|++
expr_stmt|;
name|giv_array
operator|=
operator|(
expr|struct
name|induction
operator|*
operator|*
operator|)
name|alloca
argument_list|(
name|giv_count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|induction
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|g1
operator|=
name|bl
operator|->
name|giv
init|;
name|g1
condition|;
name|g1
operator|=
name|g1
operator|->
name|next_iv
control|)
if|if
condition|(
operator|!
name|g1
operator|->
name|ignore
condition|)
name|giv_array
index|[
name|i
operator|++
index|]
operator|=
name|g1
expr_stmt|;
name|stats
operator|=
operator|(
expr|struct
name|combine_givs_stats
operator|*
operator|)
name|alloca
argument_list|(
name|giv_count
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|stats
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|stats
argument_list|,
name|giv_count
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|stats
argument_list|)
argument_list|)
expr_stmt|;
name|can_combine
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|giv_count
operator|*
name|giv_count
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|can_combine
argument_list|,
name|giv_count
operator|*
name|giv_count
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|giv_count
condition|;
name|i
operator|++
control|)
block|{
name|int
name|this_benefit
decl_stmt|;
name|rtx
name|single_use
decl_stmt|;
name|g1
operator|=
name|giv_array
index|[
name|i
index|]
expr_stmt|;
name|stats
index|[
name|i
index|]
operator|.
name|giv_number
operator|=
name|i
expr_stmt|;
comment|/* If a DEST_REG GIV is used only once, do not allow it to combine 	 with anything, for in doing so we will gain nothing that cannot 	 be had by simply letting the GIV with which we would have combined 	 to be reduced on its own.  The losage shows up in particular with  	 DEST_ADDR targets on hosts with reg+reg addressing, though it can 	 be seen elsewhere as well.  */
if|if
condition|(
name|g1
operator|->
name|giv_type
operator|==
name|DEST_REG
operator|&&
operator|(
name|single_use
operator|=
name|VARRAY_RTX
argument_list|(
name|reg_single_usage
argument_list|,
name|REGNO
argument_list|(
name|g1
operator|->
name|dest_reg
argument_list|)
argument_list|)
operator|)
operator|&&
name|single_use
operator|!=
name|const0_rtx
condition|)
continue|continue;
name|this_benefit
operator|=
name|g1
operator|->
name|benefit
expr_stmt|;
comment|/* Add an additional weight for zero addends.  */
if|if
condition|(
name|g1
operator|->
name|no_const_addval
condition|)
name|this_benefit
operator|+=
literal|1
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|giv_count
condition|;
name|j
operator|++
control|)
block|{
name|rtx
name|this_combine
decl_stmt|;
name|g2
operator|=
name|giv_array
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|g1
operator|!=
name|g2
operator|&&
operator|(
name|this_combine
operator|=
name|combine_givs_p
argument_list|(
name|g1
argument_list|,
name|g2
argument_list|)
operator|)
operator|!=
name|NULL_RTX
condition|)
block|{
name|can_combine
index|[
name|i
operator|*
name|giv_count
operator|+
name|j
index|]
operator|=
name|this_combine
expr_stmt|;
name|this_benefit
operator|+=
name|g2
operator|->
name|benefit
operator|+
name|extra_benefit
expr_stmt|;
block|}
block|}
name|stats
index|[
name|i
index|]
operator|.
name|total_benefit
operator|=
name|this_benefit
expr_stmt|;
block|}
comment|/* Iterate, combining until we can't.  */
name|restart
label|:
name|qsort
argument_list|(
name|stats
argument_list|,
name|giv_count
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|stats
argument_list|)
argument_list|,
name|cmp_combine_givs_stats
argument_list|)
expr_stmt|;
if|if
condition|(
name|loop_dump_stream
condition|)
block|{
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Sorted combine statistics:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|giv_count
condition|;
name|k
operator|++
control|)
block|{
name|g1
operator|=
name|giv_array
index|[
name|stats
index|[
name|k
index|]
operator|.
name|giv_number
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|g1
operator|->
name|combined_with
operator|&&
operator|!
name|g1
operator|->
name|same
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|" {%d, %d}"
argument_list|,
name|INSN_UID
argument_list|(
name|giv_array
index|[
name|stats
index|[
name|k
index|]
operator|.
name|giv_number
index|]
operator|->
name|insn
argument_list|)
argument_list|,
name|stats
index|[
name|k
index|]
operator|.
name|total_benefit
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|loop_dump_stream
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|giv_count
condition|;
name|k
operator|++
control|)
block|{
name|int
name|g1_add_benefit
init|=
literal|0
decl_stmt|;
name|i
operator|=
name|stats
index|[
name|k
index|]
operator|.
name|giv_number
expr_stmt|;
name|g1
operator|=
name|giv_array
index|[
name|i
index|]
expr_stmt|;
comment|/* If it has already been combined, skip.  */
if|if
condition|(
name|g1
operator|->
name|combined_with
operator|||
name|g1
operator|->
name|same
condition|)
continue|continue;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|giv_count
condition|;
name|j
operator|++
control|)
block|{
name|g2
operator|=
name|giv_array
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|g1
operator|!=
name|g2
operator|&&
name|can_combine
index|[
name|i
operator|*
name|giv_count
operator|+
name|j
index|]
comment|/* If it has already been combined, skip.  */
operator|&&
operator|!
name|g2
operator|->
name|same
operator|&&
operator|!
name|g2
operator|->
name|combined_with
condition|)
block|{
name|int
name|l
decl_stmt|;
name|g2
operator|->
name|new_reg
operator|=
name|can_combine
index|[
name|i
operator|*
name|giv_count
operator|+
name|j
index|]
expr_stmt|;
name|g2
operator|->
name|same
operator|=
name|g1
expr_stmt|;
name|g1
operator|->
name|combined_with
operator|++
expr_stmt|;
name|g1
operator|->
name|lifetime
operator|+=
name|g2
operator|->
name|lifetime
expr_stmt|;
name|g1_add_benefit
operator|+=
name|g2
operator|->
name|benefit
expr_stmt|;
comment|/* ??? The new final_[bg]iv_value code does a much better job 		 of finding replaceable giv's, and hence this code may no 		 longer be necessary.  */
if|if
condition|(
operator|!
name|g2
operator|->
name|replaceable
operator|&&
name|REG_USERVAR_P
argument_list|(
name|g2
operator|->
name|dest_reg
argument_list|)
condition|)
name|g1_add_benefit
operator|-=
name|copy_cost
expr_stmt|;
comment|/* To help optimize the next set of combinations, remove 		 this giv from the benefits of other potential mates.  */
for|for
control|(
name|l
operator|=
literal|0
init|;
name|l
operator|<
name|giv_count
condition|;
operator|++
name|l
control|)
block|{
name|int
name|m
init|=
name|stats
index|[
name|l
index|]
operator|.
name|giv_number
decl_stmt|;
if|if
condition|(
name|can_combine
index|[
name|m
operator|*
name|giv_count
operator|+
name|j
index|]
condition|)
name|stats
index|[
name|l
index|]
operator|.
name|total_benefit
operator|-=
name|g2
operator|->
name|benefit
operator|+
name|extra_benefit
expr_stmt|;
block|}
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"giv at %d combined with giv at %d\n"
argument_list|,
name|INSN_UID
argument_list|(
name|g2
operator|->
name|insn
argument_list|)
argument_list|,
name|INSN_UID
argument_list|(
name|g1
operator|->
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* To help optimize the next set of combinations, remove 	 this giv from the benefits of other potential mates.  */
if|if
condition|(
name|g1
operator|->
name|combined_with
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|giv_count
condition|;
operator|++
name|j
control|)
block|{
name|int
name|m
init|=
name|stats
index|[
name|j
index|]
operator|.
name|giv_number
decl_stmt|;
if|if
condition|(
name|can_combine
index|[
name|m
operator|*
name|giv_count
operator|+
name|i
index|]
condition|)
name|stats
index|[
name|j
index|]
operator|.
name|total_benefit
operator|-=
name|g1
operator|->
name|benefit
operator|+
name|extra_benefit
expr_stmt|;
block|}
name|g1
operator|->
name|benefit
operator|+=
name|g1_add_benefit
expr_stmt|;
comment|/* We've finished with this giv, and everything it touched. 	     Restart the combination so that proper weights for the  	     rest of the givs are properly taken into account.  */
comment|/* ??? Ideally we would compact the arrays at this point, so 	     as to not cover old ground.  But sanely compacting 	     can_combine is tricky.  */
goto|goto
name|restart
goto|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_struct
struct|struct
name|recombine_givs_stats
block|{
name|int
name|giv_number
decl_stmt|;
name|int
name|start_luid
decl_stmt|,
name|end_luid
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Used below as comparison function for qsort.  We want a ascending luid    when scanning the array starting at the end, thus the arguments are    used in reverse.  */
end_comment

begin_function
specifier|static
name|int
name|cmp_recombine_givs_stats
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
name|struct
name|recombine_givs_stats
modifier|*
name|x
decl_stmt|,
decl|*
name|y
decl_stmt|;
end_function

begin_block
block|{
name|int
name|d
decl_stmt|;
name|d
operator|=
name|y
operator|->
name|start_luid
operator|-
name|x
operator|->
name|start_luid
expr_stmt|;
comment|/* Stabilize the sort.  */
if|if
condition|(
operator|!
name|d
condition|)
name|d
operator|=
name|y
operator|->
name|giv_number
operator|-
name|x
operator|->
name|giv_number
expr_stmt|;
return|return
name|d
return|;
block|}
end_block

begin_comment
comment|/* Scan X, which is a part of INSN, for the end of life of a giv.  Also    look for the start of life of a giv where the start has not been seen    yet to unlock the search for the end of its life.    Only consider givs that belong to BIV.    Return the total number of lifetime ends that have been found.  */
end_comment

begin_function
specifier|static
name|int
name|find_life_end
parameter_list|(
name|x
parameter_list|,
name|stats
parameter_list|,
name|insn
parameter_list|,
name|biv
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|insn
decl_stmt|,
name|biv
decl_stmt|;
name|struct
name|recombine_givs_stats
modifier|*
name|stats
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
decl_stmt|;
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|SET
case|:
block|{
name|rtx
name|reg
init|=
name|SET_DEST
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|REG
condition|)
block|{
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|reg
argument_list|)
decl_stmt|;
name|struct
name|induction
modifier|*
name|v
init|=
name|REG_IV_INFO
argument_list|(
name|regno
argument_list|)
decl_stmt|;
if|if
condition|(
name|REG_IV_TYPE
argument_list|(
name|regno
argument_list|)
operator|==
name|GENERAL_INDUCT
operator|&&
operator|!
name|v
operator|->
name|ignore
operator|&&
name|v
operator|->
name|src_reg
operator|==
name|biv
operator|&&
name|stats
index|[
name|v
operator|->
name|ix
index|]
operator|.
name|end_luid
operator|<=
literal|0
condition|)
block|{
comment|/* If we see a 0 here for end_luid, it means that we have 		   scanned the entire loop without finding any use at all. 		   We must not predicate this code on a start_luid match 		   since that would make the test fail for givs that have 		   been hoisted out of inner loops.  */
if|if
condition|(
name|stats
index|[
name|v
operator|->
name|ix
index|]
operator|.
name|end_luid
operator|==
literal|0
condition|)
block|{
name|stats
index|[
name|v
operator|->
name|ix
index|]
operator|.
name|end_luid
operator|=
name|stats
index|[
name|v
operator|->
name|ix
index|]
operator|.
name|start_luid
expr_stmt|;
return|return
literal|1
operator|+
name|find_life_end
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|stats
argument_list|,
name|insn
argument_list|,
name|biv
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|stats
index|[
name|v
operator|->
name|ix
index|]
operator|.
name|start_luid
operator|==
name|INSN_LUID
argument_list|(
name|insn
argument_list|)
condition|)
name|stats
index|[
name|v
operator|->
name|ix
index|]
operator|.
name|end_luid
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|find_life_end
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|stats
argument_list|,
name|insn
argument_list|,
name|biv
argument_list|)
return|;
block|}
break|break;
block|}
case|case
name|REG
case|:
block|{
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|struct
name|induction
modifier|*
name|v
init|=
name|REG_IV_INFO
argument_list|(
name|regno
argument_list|)
decl_stmt|;
if|if
condition|(
name|REG_IV_TYPE
argument_list|(
name|regno
argument_list|)
operator|==
name|GENERAL_INDUCT
operator|&&
operator|!
name|v
operator|->
name|ignore
operator|&&
name|v
operator|->
name|src_reg
operator|==
name|biv
operator|&&
name|stats
index|[
name|v
operator|->
name|ix
index|]
operator|.
name|end_luid
operator|==
literal|0
condition|)
block|{
while|while
condition|(
name|INSN_UID
argument_list|(
name|insn
argument_list|)
operator|>=
name|max_uid_for_loop
condition|)
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|stats
index|[
name|v
operator|->
name|ix
index|]
operator|.
name|end_luid
operator|=
name|INSN_LUID
argument_list|(
name|insn
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
case|case
name|LABEL_REF
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST
case|:
return|return
literal|0
return|;
default|default:
break|break;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|retval
operator|+=
name|find_life_end
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|stats
argument_list|,
name|insn
argument_list|,
name|biv
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
name|retval
operator|+=
name|find_life_end
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|stats
argument_list|,
name|insn
argument_list|,
name|biv
argument_list|)
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* For each giv that has been combined with another, look if    we can combine it with the most recently used one instead.    This tends to shorten giv lifetimes, and helps the next step:    try to derive givs from other givs.  */
end_comment

begin_function
specifier|static
name|void
name|recombine_givs
parameter_list|(
name|bl
parameter_list|,
name|loop_start
parameter_list|,
name|loop_end
parameter_list|,
name|unroll_p
parameter_list|)
name|struct
name|iv_class
modifier|*
name|bl
decl_stmt|;
name|rtx
name|loop_start
decl_stmt|,
name|loop_end
decl_stmt|;
name|int
name|unroll_p
decl_stmt|;
block|{
name|struct
name|induction
modifier|*
name|v
decl_stmt|,
modifier|*
modifier|*
name|giv_array
decl_stmt|,
modifier|*
name|last_giv
decl_stmt|;
name|struct
name|recombine_givs_stats
modifier|*
name|stats
decl_stmt|;
name|int
name|giv_count
decl_stmt|;
name|int
name|i
decl_stmt|,
name|rescan
decl_stmt|;
name|int
name|ends_need_computing
decl_stmt|;
for|for
control|(
name|giv_count
operator|=
literal|0
operator|,
name|v
operator|=
name|bl
operator|->
name|giv
init|;
name|v
condition|;
name|v
operator|=
name|v
operator|->
name|next_iv
control|)
block|{
if|if
condition|(
operator|!
name|v
operator|->
name|ignore
condition|)
name|giv_count
operator|++
expr_stmt|;
block|}
name|giv_array
operator|=
operator|(
expr|struct
name|induction
operator|*
operator|*
operator|)
name|alloca
argument_list|(
name|giv_count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|induction
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|stats
operator|=
operator|(
expr|struct
name|recombine_givs_stats
operator|*
operator|)
name|alloca
argument_list|(
name|giv_count
operator|*
sizeof|sizeof
expr|*
name|stats
argument_list|)
expr_stmt|;
comment|/* Initialize stats and set up the ix field for each giv in stats to name      the corresponding index into stats.  */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|v
operator|=
name|bl
operator|->
name|giv
init|;
name|v
condition|;
name|v
operator|=
name|v
operator|->
name|next_iv
control|)
block|{
name|rtx
name|p
decl_stmt|;
if|if
condition|(
name|v
operator|->
name|ignore
condition|)
continue|continue;
name|giv_array
index|[
name|i
index|]
operator|=
name|v
expr_stmt|;
name|stats
index|[
name|i
index|]
operator|.
name|giv_number
operator|=
name|i
expr_stmt|;
comment|/* If this giv has been hoisted out of an inner loop, use the luid of 	 the previous insn.  */
for|for
control|(
name|p
operator|=
name|v
operator|->
name|insn
init|;
name|INSN_UID
argument_list|(
name|p
argument_list|)
operator|>=
name|max_uid_for_loop
condition|;
control|)
name|p
operator|=
name|PREV_INSN
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|stats
index|[
name|i
index|]
operator|.
name|start_luid
operator|=
name|INSN_LUID
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|v
operator|->
name|ix
operator|=
name|i
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
name|qsort
argument_list|(
name|stats
argument_list|,
name|giv_count
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|stats
argument_list|)
argument_list|,
name|cmp_recombine_givs_stats
argument_list|)
expr_stmt|;
comment|/* Do the actual most-recently-used recombination.  */
for|for
control|(
name|last_giv
operator|=
literal|0
operator|,
name|i
operator|=
name|giv_count
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|v
operator|=
name|giv_array
index|[
name|stats
index|[
name|i
index|]
operator|.
name|giv_number
index|]
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|same
condition|)
block|{
name|struct
name|induction
modifier|*
name|old_same
init|=
name|v
operator|->
name|same
decl_stmt|;
name|rtx
name|new_combine
decl_stmt|;
comment|/* combine_givs_p actually says if we can make this transformation. 	     The other tests are here only to avoid keeping a giv alive 	     that could otherwise be eliminated.  */
if|if
condition|(
name|last_giv
operator|&&
operator|(
operator|(
name|old_same
operator|->
name|maybe_dead
operator|&&
operator|!
name|old_same
operator|->
name|combined_with
operator|)
operator|||
operator|!
name|last_giv
operator|->
name|maybe_dead
operator|||
name|last_giv
operator|->
name|combined_with
operator|)
operator|&&
operator|(
name|new_combine
operator|=
name|combine_givs_p
argument_list|(
name|last_giv
argument_list|,
name|v
argument_list|)
operator|)
condition|)
block|{
name|old_same
operator|->
name|combined_with
operator|--
expr_stmt|;
name|v
operator|->
name|new_reg
operator|=
name|new_combine
expr_stmt|;
name|v
operator|->
name|same
operator|=
name|last_giv
expr_stmt|;
name|last_giv
operator|->
name|combined_with
operator|++
expr_stmt|;
comment|/* No need to update lifetimes / benefits here since we have 		 already decided what to reduce.  */
if|if
condition|(
name|loop_dump_stream
condition|)
block|{
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"giv at %d recombined with giv at %d as "
argument_list|,
name|INSN_UID
argument_list|(
name|v
operator|->
name|insn
argument_list|)
argument_list|,
name|INSN_UID
argument_list|(
name|last_giv
operator|->
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|print_rtl
argument_list|(
name|loop_dump_stream
argument_list|,
name|v
operator|->
name|new_reg
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|loop_dump_stream
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
name|v
operator|=
name|v
operator|->
name|same
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|v
operator|->
name|giv_type
operator|!=
name|DEST_REG
condition|)
continue|continue;
if|if
condition|(
operator|!
name|last_giv
operator|||
operator|(
name|last_giv
operator|->
name|maybe_dead
operator|&&
operator|!
name|last_giv
operator|->
name|combined_with
operator|)
operator|||
operator|!
name|v
operator|->
name|maybe_dead
operator|||
name|v
operator|->
name|combined_with
condition|)
name|last_giv
operator|=
name|v
expr_stmt|;
block|}
name|ends_need_computing
operator|=
literal|0
expr_stmt|;
comment|/* For each DEST_REG giv, compute lifetime starts, and try to compute      lifetime ends from regscan info.  */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|v
operator|=
name|bl
operator|->
name|giv
init|;
name|v
condition|;
name|v
operator|=
name|v
operator|->
name|next_iv
control|)
block|{
if|if
condition|(
name|v
operator|->
name|ignore
condition|)
continue|continue;
if|if
condition|(
name|v
operator|->
name|giv_type
operator|==
name|DEST_ADDR
condition|)
block|{
comment|/* Loop unrolling of an inner loop can even create new DEST_REG 	     givs.  */
name|rtx
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|v
operator|->
name|insn
init|;
name|INSN_UID
argument_list|(
name|p
argument_list|)
operator|>=
name|max_uid_for_loop
condition|;
control|)
name|p
operator|=
name|PREV_INSN
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|stats
index|[
name|i
index|]
operator|.
name|start_luid
operator|=
name|stats
index|[
name|i
index|]
operator|.
name|end_luid
operator|=
name|INSN_LUID
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|v
operator|->
name|insn
condition|)
name|stats
index|[
name|i
index|]
operator|.
name|end_luid
operator|++
expr_stmt|;
block|}
else|else
comment|/* v->giv_type == DEST_REG */
block|{
if|if
condition|(
name|v
operator|->
name|last_use
condition|)
block|{
name|stats
index|[
name|i
index|]
operator|.
name|start_luid
operator|=
name|INSN_LUID
argument_list|(
name|v
operator|->
name|insn
argument_list|)
expr_stmt|;
name|stats
index|[
name|i
index|]
operator|.
name|end_luid
operator|=
name|INSN_LUID
argument_list|(
name|v
operator|->
name|last_use
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|INSN_UID
argument_list|(
name|v
operator|->
name|insn
argument_list|)
operator|>=
name|max_uid_for_loop
condition|)
block|{
name|rtx
name|p
decl_stmt|;
comment|/* This insn has been created by loop optimization on an inner 		 loop.  We don't have a proper start_luid that will match 		 when we see the first set.  But we do know that there will 		 be no use before the set, so we can set end_luid to 0 so that 		 we'll start looking for the last use right away.  */
for|for
control|(
name|p
operator|=
name|PREV_INSN
argument_list|(
name|v
operator|->
name|insn
argument_list|)
init|;
name|INSN_UID
argument_list|(
name|p
argument_list|)
operator|>=
name|max_uid_for_loop
condition|;
control|)
name|p
operator|=
name|PREV_INSN
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|stats
index|[
name|i
index|]
operator|.
name|start_luid
operator|=
name|INSN_LUID
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|stats
index|[
name|i
index|]
operator|.
name|end_luid
operator|=
literal|0
expr_stmt|;
name|ends_need_computing
operator|++
expr_stmt|;
block|}
else|else
block|{
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|v
operator|->
name|dest_reg
argument_list|)
decl_stmt|;
name|int
name|count
init|=
name|VARRAY_INT
argument_list|(
name|n_times_set
argument_list|,
name|regno
argument_list|)
operator|-
literal|1
decl_stmt|;
name|rtx
name|p
init|=
name|v
operator|->
name|insn
decl_stmt|;
comment|/* Find the first insn that sets the giv, so that we can verify 		 if this giv's lifetime wraps around the loop.  We also need 		 the luid of the first setting insn in order to detect the 		 last use properly.  */
while|while
condition|(
name|count
condition|)
block|{
name|p
operator|=
name|prev_nonnote_insn
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_set_p
argument_list|(
name|v
operator|->
name|dest_reg
argument_list|,
name|p
argument_list|)
condition|)
name|count
operator|--
expr_stmt|;
block|}
name|stats
index|[
name|i
index|]
operator|.
name|start_luid
operator|=
name|INSN_LUID
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|stats
index|[
name|i
index|]
operator|.
name|start_luid
operator|>
name|uid_luid
index|[
name|REGNO_FIRST_UID
argument_list|(
name|regno
argument_list|)
index|]
condition|)
block|{
name|stats
index|[
name|i
index|]
operator|.
name|end_luid
operator|=
operator|-
literal|1
expr_stmt|;
name|ends_need_computing
operator|++
expr_stmt|;
block|}
else|else
block|{
name|stats
index|[
name|i
index|]
operator|.
name|end_luid
operator|=
name|uid_luid
index|[
name|REGNO_LAST_UID
argument_list|(
name|regno
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|stats
index|[
name|i
index|]
operator|.
name|end_luid
operator|>
name|INSN_LUID
argument_list|(
name|loop_end
argument_list|)
condition|)
block|{
name|stats
index|[
name|i
index|]
operator|.
name|end_luid
operator|=
operator|-
literal|1
expr_stmt|;
name|ends_need_computing
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
name|i
operator|++
expr_stmt|;
block|}
comment|/* If the regscan information was unconclusive for one or more DEST_REG      givs, scan the all insn in the loop to find out lifetime ends.  */
if|if
condition|(
name|ends_need_computing
condition|)
block|{
name|rtx
name|biv
init|=
name|bl
operator|->
name|biv
operator|->
name|src_reg
decl_stmt|;
name|rtx
name|p
init|=
name|loop_end
decl_stmt|;
do|do
block|{
if|if
condition|(
name|p
operator|==
name|loop_start
condition|)
name|p
operator|=
name|loop_end
expr_stmt|;
name|p
operator|=
name|PREV_INSN
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
argument_list|)
operator|!=
literal|'i'
condition|)
continue|continue;
name|ends_need_computing
operator|-=
name|find_life_end
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|,
name|stats
argument_list|,
name|p
argument_list|,
name|biv
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|ends_need_computing
condition|)
do|;
block|}
comment|/* Set start_luid back to the last insn that sets the giv.  This allows      more combinations.  */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|v
operator|=
name|bl
operator|->
name|giv
init|;
name|v
condition|;
name|v
operator|=
name|v
operator|->
name|next_iv
control|)
block|{
if|if
condition|(
name|v
operator|->
name|ignore
condition|)
continue|continue;
if|if
condition|(
name|INSN_UID
argument_list|(
name|v
operator|->
name|insn
argument_list|)
operator|<
name|max_uid_for_loop
condition|)
name|stats
index|[
name|i
index|]
operator|.
name|start_luid
operator|=
name|INSN_LUID
argument_list|(
name|v
operator|->
name|insn
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
comment|/* Now adjust lifetime ends by taking combined givs into account.  */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|v
operator|=
name|bl
operator|->
name|giv
init|;
name|v
condition|;
name|v
operator|=
name|v
operator|->
name|next_iv
control|)
block|{
name|unsigned
name|luid
decl_stmt|;
name|int
name|j
decl_stmt|;
if|if
condition|(
name|v
operator|->
name|ignore
condition|)
continue|continue;
if|if
condition|(
name|v
operator|->
name|same
operator|&&
operator|!
name|v
operator|->
name|same
operator|->
name|ignore
condition|)
block|{
name|j
operator|=
name|v
operator|->
name|same
operator|->
name|ix
expr_stmt|;
name|luid
operator|=
name|stats
index|[
name|i
index|]
operator|.
name|start_luid
expr_stmt|;
comment|/* Use unsigned arithmetic to model loop wrap-around.  */
if|if
condition|(
name|luid
operator|-
name|stats
index|[
name|j
index|]
operator|.
name|start_luid
operator|>
operator|(
name|unsigned
operator|)
name|stats
index|[
name|j
index|]
operator|.
name|end_luid
operator|-
name|stats
index|[
name|j
index|]
operator|.
name|start_luid
condition|)
name|stats
index|[
name|j
index|]
operator|.
name|end_luid
operator|=
name|luid
expr_stmt|;
block|}
name|i
operator|++
expr_stmt|;
block|}
name|qsort
argument_list|(
name|stats
argument_list|,
name|giv_count
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|stats
argument_list|)
argument_list|,
name|cmp_recombine_givs_stats
argument_list|)
expr_stmt|;
comment|/* Try to derive DEST_REG givs from previous DEST_REG givs with the      same mult_val and non-overlapping lifetime.  This reduces register      pressure.      Once we find a DEST_REG giv that is suitable to derive others from,      we set last_giv to this giv, and try to derive as many other DEST_REG      givs from it without joining overlapping lifetimes.  If we then      encounter a DEST_REG giv that we can't derive, we set rescan to the      index for this giv (unless rescan is already set).      When we are finished with the current LAST_GIV (i.e. the inner loop      terminates), we start again with rescan, which then becomes the new      LAST_GIV.  */
for|for
control|(
name|i
operator|=
name|giv_count
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|=
name|rescan
control|)
block|{
name|int
name|life_start
decl_stmt|,
name|life_end
decl_stmt|;
for|for
control|(
name|last_giv
operator|=
literal|0
operator|,
name|rescan
operator|=
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|rtx
name|sum
decl_stmt|;
name|v
operator|=
name|giv_array
index|[
name|stats
index|[
name|i
index|]
operator|.
name|giv_number
index|]
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|giv_type
operator|!=
name|DEST_REG
operator|||
name|v
operator|->
name|derived_from
operator|||
name|v
operator|->
name|same
condition|)
continue|continue;
if|if
condition|(
operator|!
name|last_giv
condition|)
block|{
comment|/* Don't use a giv that's likely to be dead to derive 		 others - that would be likely to keep that giv alive.  */
if|if
condition|(
operator|!
name|v
operator|->
name|maybe_dead
operator|||
name|v
operator|->
name|combined_with
condition|)
block|{
name|last_giv
operator|=
name|v
expr_stmt|;
name|life_start
operator|=
name|stats
index|[
name|i
index|]
operator|.
name|start_luid
expr_stmt|;
name|life_end
operator|=
name|stats
index|[
name|i
index|]
operator|.
name|end_luid
expr_stmt|;
block|}
continue|continue;
block|}
comment|/* Use unsigned arithmetic to model loop wrap around.  */
if|if
condition|(
operator|(
operator|(
name|unsigned
operator|)
name|stats
index|[
name|i
index|]
operator|.
name|start_luid
operator|-
name|life_start
operator|>=
operator|(
name|unsigned
operator|)
name|life_end
operator|-
name|life_start
operator|)
operator|&&
operator|(
operator|(
name|unsigned
operator|)
name|stats
index|[
name|i
index|]
operator|.
name|end_luid
operator|-
name|life_start
operator|>
operator|(
name|unsigned
operator|)
name|life_end
operator|-
name|life_start
operator|)
comment|/*  Check that the giv insn we're about to use for deriving 		  precedes all uses of that giv.  Note that initializing the 		  derived giv would defeat the purpose of reducing register 		  pressure. 		  ??? We could arrange to move the insn.  */
operator|&&
operator|(
operator|(
name|unsigned
operator|)
name|stats
index|[
name|i
index|]
operator|.
name|end_luid
operator|-
name|INSN_LUID
argument_list|(
name|loop_start
argument_list|)
operator|>
operator|(
name|unsigned
operator|)
name|stats
index|[
name|i
index|]
operator|.
name|start_luid
operator|-
name|INSN_LUID
argument_list|(
name|loop_start
argument_list|)
operator|)
operator|&&
name|rtx_equal_p
argument_list|(
name|last_giv
operator|->
name|mult_val
argument_list|,
name|v
operator|->
name|mult_val
argument_list|)
comment|/* ??? Could handle libcalls, but would need more logic.  */
operator|&&
operator|!
name|find_reg_note
argument_list|(
name|v
operator|->
name|insn
argument_list|,
name|REG_RETVAL
argument_list|,
name|NULL_RTX
argument_list|)
comment|/* We would really like to know if for any giv that v 		 is combined with, v->insn or any intervening biv increment 		 dominates that combined giv.  However, we 		 don't have this detailed control flow information. 		 N.B. since last_giv will be reduced, it is valid 		 anywhere in the loop, so we don't need to check the 		 validity of last_giv. 		 We rely here on the fact that v->always_executed implies that 		 there is no jump to someplace else in the loop before the 		 giv insn, and hence any insn that is executed before the 		 giv insn in the loop will have a lower luid.  */
operator|&&
operator|(
name|v
operator|->
name|always_executed
operator|||
operator|!
name|v
operator|->
name|combined_with
operator|)
operator|&&
operator|(
name|sum
operator|=
name|express_from
argument_list|(
name|last_giv
argument_list|,
name|v
argument_list|)
operator|)
comment|/* Make sure we don't make the add more expensive.  ADD_COST 		 doesn't take different costs of registers and constants into 		 account, so compare the cost of the actual SET_SRCs.  */
operator|&&
operator|(
name|rtx_cost
argument_list|(
name|sum
argument_list|,
name|SET
argument_list|)
operator|<=
name|rtx_cost
argument_list|(
name|SET_SRC
argument_list|(
name|single_set
argument_list|(
name|v
operator|->
name|insn
argument_list|)
argument_list|)
argument_list|,
name|SET
argument_list|)
operator|)
comment|/* ??? unroll can't understand anything but reg + const_int 		 sums.  It would be cleaner to fix unroll.  */
operator|&&
operator|(
operator|(
name|GET_CODE
argument_list|(
name|sum
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|sum
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|sum
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|)
operator|||
operator|!
name|unroll_p
operator|)
operator|&&
name|validate_change
argument_list|(
name|v
operator|->
name|insn
argument_list|,
operator|&
name|PATTERN
argument_list|(
name|v
operator|->
name|insn
argument_list|)
argument_list|,
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|v
operator|->
name|dest_reg
argument_list|,
name|sum
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|v
operator|->
name|derived_from
operator|=
name|last_giv
expr_stmt|;
name|life_end
operator|=
name|stats
index|[
name|i
index|]
operator|.
name|end_luid
expr_stmt|;
if|if
condition|(
name|loop_dump_stream
condition|)
block|{
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"giv at %d derived from %d as "
argument_list|,
name|INSN_UID
argument_list|(
name|v
operator|->
name|insn
argument_list|)
argument_list|,
name|INSN_UID
argument_list|(
name|last_giv
operator|->
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|print_rtl
argument_list|(
name|loop_dump_stream
argument_list|,
name|sum
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|loop_dump_stream
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|rescan
operator|<
literal|0
condition|)
name|rescan
operator|=
name|i
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* EMIT code before INSERT_BEFORE to set REG = B * M + A.  */
end_comment

begin_function
name|void
name|emit_iv_add_mult
parameter_list|(
name|b
parameter_list|,
name|m
parameter_list|,
name|a
parameter_list|,
name|reg
parameter_list|,
name|insert_before
parameter_list|)
name|rtx
name|b
decl_stmt|;
comment|/* initial value of basic induction variable */
name|rtx
name|m
decl_stmt|;
comment|/* multiplicative constant */
name|rtx
name|a
decl_stmt|;
comment|/* additive constant */
name|rtx
name|reg
decl_stmt|;
comment|/* destination register */
name|rtx
name|insert_before
decl_stmt|;
block|{
name|rtx
name|seq
decl_stmt|;
name|rtx
name|result
decl_stmt|;
comment|/* Prevent unexpected sharing of these rtx.  */
name|a
operator|=
name|copy_rtx
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|b
operator|=
name|copy_rtx
argument_list|(
name|b
argument_list|)
expr_stmt|;
comment|/* Increase the lifetime of any invariants moved further in code.  */
name|update_reg_last_use
argument_list|(
name|a
argument_list|,
name|insert_before
argument_list|)
expr_stmt|;
name|update_reg_last_use
argument_list|(
name|b
argument_list|,
name|insert_before
argument_list|)
expr_stmt|;
name|update_reg_last_use
argument_list|(
name|m
argument_list|,
name|insert_before
argument_list|)
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|result
operator|=
name|expand_mult_add
argument_list|(
name|b
argument_list|,
name|reg
argument_list|,
name|m
argument_list|,
name|a
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|!=
name|result
condition|)
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|seq
operator|=
name|gen_sequence
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_insn_before
argument_list|(
name|seq
argument_list|,
name|insert_before
argument_list|)
expr_stmt|;
comment|/* It is entirely possible that the expansion created lots of new       registers.  Iterate over the sequence we just created and       record them all.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|seq
argument_list|)
operator|==
name|SEQUENCE
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|seq
argument_list|,
literal|0
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|rtx
name|set
init|=
name|single_set
argument_list|(
name|XVECEXP
argument_list|(
name|seq
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|set
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
name|record_base_value
argument_list|(
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
argument_list|,
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|seq
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|seq
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
name|record_base_value
argument_list|(
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|seq
argument_list|)
argument_list|)
argument_list|,
name|SET_SRC
argument_list|(
name|seq
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Test whether A * B can be computed without    an actual multiply insn.  Value is 1 if so.  */
end_comment

begin_function
specifier|static
name|int
name|product_cheap_p
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
name|rtx
name|a
decl_stmt|;
name|rtx
name|b
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|rtx
name|tmp
decl_stmt|;
name|struct
name|obstack
modifier|*
name|old_rtl_obstack
init|=
name|rtl_obstack
decl_stmt|;
name|char
modifier|*
name|storage
init|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|temp_obstack
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|win
init|=
literal|1
decl_stmt|;
comment|/* If only one is constant, make it B.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|a
argument_list|)
operator|==
name|CONST_INT
condition|)
name|tmp
operator|=
name|a
operator|,
name|a
operator|=
name|b
operator|,
name|b
operator|=
name|tmp
expr_stmt|;
comment|/* If first constant, both constant, so don't need multiply.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|a
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
literal|1
return|;
comment|/* If second not constant, neither is constant, so would need multiply.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|b
argument_list|)
operator|!=
name|CONST_INT
condition|)
return|return
literal|0
return|;
comment|/* One operand is constant, so might not need multiply insn.  Generate the      code for the multiply and see if a call or multiply, or long sequence      of insns is generated.  */
name|rtl_obstack
operator|=
operator|&
name|temp_obstack
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|expand_mult
argument_list|(
name|GET_MODE
argument_list|(
name|a
argument_list|)
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|gen_sequence
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|SEQUENCE
condition|)
block|{
if|if
condition|(
name|XVEC
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
name|win
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|XVECLEN
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
operator|>
literal|3
condition|)
name|win
operator|=
literal|0
expr_stmt|;
else|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|insn
init|=
name|XVECEXP
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|INSN
operator|||
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|MULT
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|MULT
operator|)
condition|)
block|{
name|win
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|tmp
argument_list|)
argument_list|)
operator|==
name|MULT
condition|)
name|win
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|MULT
condition|)
name|win
operator|=
literal|0
expr_stmt|;
comment|/* Free any storage we obtained in generating this multiply and restore rtl      allocation to its normal obstack.  */
name|obstack_free
argument_list|(
operator|&
name|temp_obstack
argument_list|,
name|storage
argument_list|)
expr_stmt|;
name|rtl_obstack
operator|=
name|old_rtl_obstack
expr_stmt|;
return|return
name|win
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Check to see if loop can be terminated by a "decrement and branch until    zero" instruction.  If so, add a REG_NONNEG note to the branch insn if so.    Also try reversing an increment loop to a decrement loop    to see if the optimization can be performed.    Value is nonzero if optimization was performed.  */
end_comment

begin_comment
comment|/* This is useful even if the architecture doesn't have such an insn,    because it might change a loops which increments from 0 to n to a loop    which decrements from n to 0.  A loop that decrements to zero is usually    faster than one that increments from zero.  */
end_comment

begin_comment
comment|/* ??? This could be rewritten to use some of the loop unrolling procedures,    such as approx_final_value, biv_total_increment, loop_iterations, and    final_[bg]iv_value.  */
end_comment

begin_function
specifier|static
name|int
name|check_dbra_loop
parameter_list|(
name|loop_end
parameter_list|,
name|insn_count
parameter_list|,
name|loop_start
parameter_list|,
name|loop_info
parameter_list|)
name|rtx
name|loop_end
decl_stmt|;
name|int
name|insn_count
decl_stmt|;
name|rtx
name|loop_start
decl_stmt|;
name|struct
name|loop_info
modifier|*
name|loop_info
decl_stmt|;
block|{
name|struct
name|iv_class
modifier|*
name|bl
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
name|rtx
name|jump_label
decl_stmt|;
name|rtx
name|final_value
decl_stmt|;
name|rtx
name|start_value
decl_stmt|;
name|rtx
name|new_add_val
decl_stmt|;
name|rtx
name|comparison
decl_stmt|;
name|rtx
name|before_comparison
decl_stmt|;
name|rtx
name|p
decl_stmt|;
name|rtx
name|jump
decl_stmt|;
name|rtx
name|first_compare
decl_stmt|;
name|int
name|compare_and_branch
decl_stmt|;
comment|/* If last insn is a conditional branch, and the insn before tests a      register value, try to optimize it.  Otherwise, we can't do anything.  */
name|jump
operator|=
name|PREV_INSN
argument_list|(
name|loop_end
argument_list|)
expr_stmt|;
name|comparison
operator|=
name|get_condition_for_loop
argument_list|(
name|jump
argument_list|)
expr_stmt|;
if|if
condition|(
name|comparison
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Try to compute whether the compare/branch at the loop end is one or      two instructions.  */
name|get_condition
argument_list|(
name|jump
argument_list|,
operator|&
name|first_compare
argument_list|)
expr_stmt|;
if|if
condition|(
name|first_compare
operator|==
name|jump
condition|)
name|compare_and_branch
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|first_compare
operator|==
name|prev_nonnote_insn
argument_list|(
name|jump
argument_list|)
condition|)
name|compare_and_branch
operator|=
literal|2
expr_stmt|;
else|else
return|return
literal|0
return|;
comment|/* Check all of the bivs to see if the compare uses one of them.      Skip biv's set more than once because we can't guarantee that      it will be zero on the last iteration.  Also skip if the biv is      used between its update and the test insn.  */
for|for
control|(
name|bl
operator|=
name|loop_iv_list
init|;
name|bl
condition|;
name|bl
operator|=
name|bl
operator|->
name|next
control|)
block|{
if|if
condition|(
name|bl
operator|->
name|biv_count
operator|==
literal|1
operator|&&
operator|!
name|bl
operator|->
name|biv
operator|->
name|maybe_multiple
operator|&&
name|bl
operator|->
name|biv
operator|->
name|dest_reg
operator|==
name|XEXP
argument_list|(
name|comparison
argument_list|,
literal|0
argument_list|)
operator|&&
operator|!
name|reg_used_between_p
argument_list|(
name|regno_reg_rtx
index|[
name|bl
operator|->
name|regno
index|]
argument_list|,
name|bl
operator|->
name|biv
operator|->
name|insn
argument_list|,
name|first_compare
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|bl
condition|)
return|return
literal|0
return|;
comment|/* Look for the case where the basic induction variable is always      nonnegative, and equals zero on the last iteration.      In this case, add a reg_note REG_NONNEG, which allows the      m68k DBRA instruction to be used.  */
if|if
condition|(
operator|(
operator|(
name|GET_CODE
argument_list|(
name|comparison
argument_list|)
operator|==
name|GT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|comparison
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|comparison
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|comparison
argument_list|)
operator|==
name|NE
operator|&&
name|XEXP
argument_list|(
name|comparison
argument_list|,
literal|1
argument_list|)
operator|==
name|const0_rtx
operator|)
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|bl
operator|->
name|biv
operator|->
name|add_val
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|bl
operator|->
name|biv
operator|->
name|add_val
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* Initial value must be greater than 0, 	 init_val % -dec_value == 0 to ensure that it equals zero on 	 the last iteration */
if|if
condition|(
name|GET_CODE
argument_list|(
name|bl
operator|->
name|initial_value
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|bl
operator|->
name|initial_value
argument_list|)
operator|>
literal|0
operator|&&
operator|(
name|INTVAL
argument_list|(
name|bl
operator|->
name|initial_value
argument_list|)
operator|%
operator|(
operator|-
name|INTVAL
argument_list|(
name|bl
operator|->
name|biv
operator|->
name|add_val
argument_list|)
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* register always nonnegative, add REG_NOTE to branch */
name|REG_NOTES
argument_list|(
name|PREV_INSN
argument_list|(
name|loop_end
argument_list|)
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_NONNEG
argument_list|,
name|NULL_RTX
argument_list|,
name|REG_NOTES
argument_list|(
name|PREV_INSN
argument_list|(
name|loop_end
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|bl
operator|->
name|nonneg
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* If the decrement is 1 and the value was tested as>= 0 before 	 the loop, then we can safely optimize.  */
for|for
control|(
name|p
operator|=
name|loop_start
init|;
name|p
condition|;
name|p
operator|=
name|PREV_INSN
argument_list|(
name|p
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|CODE_LABEL
condition|)
break|break;
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|!=
name|JUMP_INSN
condition|)
continue|continue;
name|before_comparison
operator|=
name|get_condition_for_loop
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|before_comparison
operator|&&
name|XEXP
argument_list|(
name|before_comparison
argument_list|,
literal|0
argument_list|)
operator|==
name|bl
operator|->
name|biv
operator|->
name|dest_reg
operator|&&
name|GET_CODE
argument_list|(
name|before_comparison
argument_list|)
operator|==
name|LT
operator|&&
name|XEXP
argument_list|(
name|before_comparison
argument_list|,
literal|1
argument_list|)
operator|==
name|const0_rtx
operator|&&
operator|!
name|reg_set_between_p
argument_list|(
name|bl
operator|->
name|biv
operator|->
name|dest_reg
argument_list|,
name|p
argument_list|,
name|loop_start
argument_list|)
operator|&&
name|INTVAL
argument_list|(
name|bl
operator|->
name|biv
operator|->
name|add_val
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|REG_NOTES
argument_list|(
name|PREV_INSN
argument_list|(
name|loop_end
argument_list|)
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_NONNEG
argument_list|,
name|NULL_RTX
argument_list|,
name|REG_NOTES
argument_list|(
name|PREV_INSN
argument_list|(
name|loop_end
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|bl
operator|->
name|nonneg
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|bl
operator|->
name|biv
operator|->
name|add_val
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|bl
operator|->
name|biv
operator|->
name|add_val
argument_list|)
operator|>
literal|0
condition|)
block|{
comment|/* Try to change inc to dec, so can apply above optimization.  */
comment|/* Can do this if: 	 all registers modified are induction variables or invariant, 	 all memory references have non-overlapping addresses 	 (obviously true if only one write) 	 allow 2 insns for the compare/jump at the end of the loop.  */
comment|/* Also, we must avoid any instructions which use both the reversed 	 biv and another biv.  Such instructions will fail if the loop is 	 reversed.  We meet this condition by requiring that either 	 no_use_except_counting is true, or else that there is only 	 one biv.  */
name|int
name|num_nonfixed_reads
init|=
literal|0
decl_stmt|;
comment|/* 1 if the iteration var is used only to count iterations.  */
name|int
name|no_use_except_counting
init|=
literal|0
decl_stmt|;
comment|/* 1 if the loop has no memory store, or it has a single memory store 	 which is reversible.  */
name|int
name|reversible_mem_store
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|bl
operator|->
name|giv_count
operator|==
literal|0
operator|&&
operator|!
name|loop_number_exit_count
index|[
name|uid_loop_num
index|[
name|INSN_UID
argument_list|(
name|loop_start
argument_list|)
index|]
index|]
condition|)
block|{
name|rtx
name|bivreg
init|=
name|regno_reg_rtx
index|[
name|bl
operator|->
name|regno
index|]
decl_stmt|;
comment|/* If there are no givs for this biv, and the only exit is the 	     fall through at the end of the loop, then 	     see if perhaps there are no uses except to count.  */
name|no_use_except_counting
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|p
operator|=
name|loop_start
init|;
name|p
operator|!=
name|loop_end
condition|;
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
control|)
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
argument_list|)
operator|==
literal|'i'
condition|)
block|{
name|rtx
name|set
init|=
name|single_set
argument_list|(
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
name|set
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|bl
operator|->
name|regno
condition|)
comment|/* An insn that sets the biv is okay.  */
empty_stmt|;
elseif|else
if|if
condition|(
operator|(
name|p
operator|==
name|prev_nonnote_insn
argument_list|(
name|prev_nonnote_insn
argument_list|(
name|loop_end
argument_list|)
argument_list|)
operator|||
name|p
operator|==
name|prev_nonnote_insn
argument_list|(
name|loop_end
argument_list|)
operator|)
operator|&&
name|reg_mentioned_p
argument_list|(
name|bivreg
argument_list|,
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
condition|)
block|{
comment|/* If either of these insns uses the biv and sets a pseudo 		       that has more than one usage, then the biv has uses 		       other than counting since it's used to derive a value 		       that is used more than one time.  */
name|note_set_pseudo_multiple_uses_retval
operator|=
literal|0
expr_stmt|;
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|,
name|note_set_pseudo_multiple_uses
argument_list|)
expr_stmt|;
if|if
condition|(
name|note_set_pseudo_multiple_uses_retval
condition|)
block|{
name|no_use_except_counting
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|reg_mentioned_p
argument_list|(
name|bivreg
argument_list|,
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
condition|)
block|{
name|no_use_except_counting
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|no_use_except_counting
condition|)
empty_stmt|;
comment|/* no need to worry about MEMs.  */
elseif|else
if|if
condition|(
name|num_mem_sets
operator|<=
literal|1
condition|)
block|{
for|for
control|(
name|p
operator|=
name|loop_start
init|;
name|p
operator|!=
name|loop_end
condition|;
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
control|)
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
argument_list|)
operator|==
literal|'i'
condition|)
name|num_nonfixed_reads
operator|+=
name|count_nonfixed_reads
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the loop has a single store, and the destination address is 	     invariant, then we can't reverse the loop, because this address 	     might then have the wrong value at loop exit. 	     This would work if the source was invariant also, however, in that 	     case, the insn should have been moved out of the loop.  */
if|if
condition|(
name|num_mem_sets
operator|==
literal|1
condition|)
block|{
name|struct
name|induction
modifier|*
name|v
decl_stmt|;
name|reversible_mem_store
operator|=
operator|(
operator|!
name|unknown_address_altered
operator|&&
operator|!
name|invariant_p
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|loop_store_mems
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
expr_stmt|;
comment|/* If the store depends on a register that is set after the 		 store, it depends on the initial value, and is thus not 		 reversible.  */
for|for
control|(
name|v
operator|=
name|bl
operator|->
name|giv
init|;
name|reversible_mem_store
operator|&&
name|v
condition|;
name|v
operator|=
name|v
operator|->
name|next_iv
control|)
block|{
if|if
condition|(
name|v
operator|->
name|giv_type
operator|==
name|DEST_REG
operator|&&
name|reg_mentioned_p
argument_list|(
name|v
operator|->
name|dest_reg
argument_list|,
name|PATTERN
argument_list|(
name|first_loop_store_insn
argument_list|)
argument_list|)
operator|&&
name|loop_insn_first_p
argument_list|(
name|first_loop_store_insn
argument_list|,
name|v
operator|->
name|insn
argument_list|)
condition|)
name|reversible_mem_store
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
else|else
return|return
literal|0
return|;
comment|/* This code only acts for innermost loops.  Also it simplifies 	 the memory address check by only reversing loops with 	 zero or one memory access. 	 Two memory accesses could involve parts of the same array, 	 and that can't be reversed. 	 If the biv is used only for counting, than we don't need to worry 	 about all these things.  */
if|if
condition|(
operator|(
name|num_nonfixed_reads
operator|<=
literal|1
operator|&&
operator|!
name|loop_has_call
operator|&&
operator|!
name|loop_has_volatile
operator|&&
name|reversible_mem_store
operator|&&
operator|(
name|bl
operator|->
name|giv_count
operator|+
name|bl
operator|->
name|biv_count
operator|+
name|num_mem_sets
operator|+
name|num_movables
operator|+
name|compare_and_branch
operator|==
name|insn_count
operator|)
operator|&&
operator|(
name|bl
operator|==
name|loop_iv_list
operator|&&
name|bl
operator|->
name|next
operator|==
literal|0
operator|)
operator|)
operator|||
name|no_use_except_counting
condition|)
block|{
name|rtx
name|tem
decl_stmt|;
comment|/* Loop can be reversed.  */
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Can reverse loop\n"
argument_list|)
expr_stmt|;
comment|/* Now check other conditions:  	     The increment must be a constant, as must the initial value, 	     and the comparison code must be LT.   	     This test can probably be improved since +/- 1 in the constant 	     can be obtained by changing LT to LE and vice versa; this is 	     confusing.  */
if|if
condition|(
name|comparison
comment|/* for constants, LE gets turned into LT */
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|comparison
argument_list|)
operator|==
name|LT
operator|||
operator|(
name|GET_CODE
argument_list|(
name|comparison
argument_list|)
operator|==
name|LE
operator|&&
name|no_use_except_counting
operator|)
operator|)
condition|)
block|{
name|HOST_WIDE_INT
name|add_val
decl_stmt|,
name|add_adjust
decl_stmt|,
name|comparison_val
decl_stmt|;
name|rtx
name|initial_value
decl_stmt|,
name|comparison_value
decl_stmt|;
name|int
name|nonneg
init|=
literal|0
decl_stmt|;
name|enum
name|rtx_code
name|cmp_code
decl_stmt|;
name|int
name|comparison_const_width
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|comparison_sign_mask
decl_stmt|;
name|add_val
operator|=
name|INTVAL
argument_list|(
name|bl
operator|->
name|biv
operator|->
name|add_val
argument_list|)
expr_stmt|;
name|comparison_value
operator|=
name|XEXP
argument_list|(
name|comparison
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|comparison_value
argument_list|)
operator|==
name|VOIDmode
condition|)
name|comparison_const_width
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|comparison
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|comparison_const_width
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|comparison_value
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|comparison_const_width
operator|>
name|HOST_BITS_PER_WIDE_INT
condition|)
name|comparison_const_width
operator|=
name|HOST_BITS_PER_WIDE_INT
expr_stmt|;
name|comparison_sign_mask
operator|=
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|comparison_const_width
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* If the comparison value is not a loop invariant, then we 		 can not reverse this loop.  		 ??? If the insns which initialize the comparison value as 		 a whole compute an invariant result, then we could move 		 them out of the loop and proceed with loop reversal.  */
if|if
condition|(
operator|!
name|invariant_p
argument_list|(
name|comparison_value
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|comparison_value
argument_list|)
operator|==
name|CONST_INT
condition|)
name|comparison_val
operator|=
name|INTVAL
argument_list|(
name|comparison_value
argument_list|)
expr_stmt|;
name|initial_value
operator|=
name|bl
operator|->
name|initial_value
expr_stmt|;
comment|/* Normalize the initial value if it is an integer and  		 has no other use except as a counter.  This will allow 		 a few more loops to be reversed.  */
if|if
condition|(
name|no_use_except_counting
operator|&&
name|GET_CODE
argument_list|(
name|comparison_value
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|initial_value
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|comparison_val
operator|=
name|comparison_val
operator|-
name|INTVAL
argument_list|(
name|bl
operator|->
name|initial_value
argument_list|)
expr_stmt|;
comment|/* The code below requires comparison_val to be a multiple 		     of add_val in order to do the loop reversal, so 		     round up comparison_val to a multiple of add_val. 		     Since comparison_value is constant, we know that the 		     current comparison code is LT.  */
name|comparison_val
operator|=
name|comparison_val
operator|+
name|add_val
operator|-
literal|1
expr_stmt|;
name|comparison_val
operator|-=
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|comparison_val
operator|%
name|add_val
expr_stmt|;
comment|/* We postpone overflow checks for COMPARISON_VAL here; 		     even if there is an overflow, we might still be able to 		     reverse the loop, if converting the loop exit test to 		     NE is possible.  */
name|initial_value
operator|=
name|const0_rtx
expr_stmt|;
block|}
comment|/* First check if we can do a vanilla loop reversal.  */
if|if
condition|(
name|initial_value
operator|==
name|const0_rtx
comment|/* If we have a decrement_and_branch_on_count, prefer 		     the NE test, since this will allow that instruction to 		     be generated.  Note that we must use a vanilla loop 		     reversal if the biv is used to calculate a giv or has 		     a non-counting use.  */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAVE_decrement_and_branch_until_zero
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_decrement_and_branch_on_count
argument_list|)
operator|&&
operator|(
operator|!
operator|(
name|add_val
operator|==
literal|1
operator|&&
name|loop_info
operator|->
name|vtop
operator|&&
operator|(
name|bl
operator|->
name|biv_count
operator|==
literal|0
operator|||
name|no_use_except_counting
operator|)
operator|)
operator|)
endif|#
directive|endif
operator|&&
name|GET_CODE
argument_list|(
name|comparison_value
argument_list|)
operator|==
name|CONST_INT
comment|/* Now do postponed overflow checks on COMPARISON_VAL.  */
operator|&&
operator|!
operator|(
operator|(
operator|(
name|comparison_val
operator|-
name|add_val
operator|)
operator|^
name|INTVAL
argument_list|(
name|comparison_value
argument_list|)
operator|)
operator|&
name|comparison_sign_mask
operator|)
condition|)
block|{
comment|/* Register will always be nonnegative, with value 		     0 on last iteration */
name|add_adjust
operator|=
name|add_val
expr_stmt|;
name|nonneg
operator|=
literal|1
expr_stmt|;
name|cmp_code
operator|=
name|GE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|add_val
operator|==
literal|1
operator|&&
name|loop_info
operator|->
name|vtop
operator|&&
operator|(
name|bl
operator|->
name|biv_count
operator|==
literal|0
operator|||
name|no_use_except_counting
operator|)
condition|)
block|{
name|add_adjust
operator|=
literal|0
expr_stmt|;
name|cmp_code
operator|=
name|NE
expr_stmt|;
block|}
else|else
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|comparison
argument_list|)
operator|==
name|LE
condition|)
name|add_adjust
operator|-=
name|add_val
expr_stmt|;
comment|/* If the initial value is not zero, or if the comparison 		 value is not an exact multiple of the increment, then we 		 can not reverse this loop.  */
if|if
condition|(
name|initial_value
operator|==
name|const0_rtx
operator|&&
name|GET_CODE
argument_list|(
name|comparison_value
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|comparison_val
operator|%
name|add_val
operator|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|no_use_except_counting
operator|||
name|add_val
operator|!=
literal|1
condition|)
return|return
literal|0
return|;
block|}
name|final_value
operator|=
name|comparison_value
expr_stmt|;
comment|/* Reset these in case we normalized the initial value 		 and comparison value above.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|comparison_value
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|initial_value
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|comparison_value
operator|=
name|GEN_INT
argument_list|(
name|comparison_val
argument_list|)
expr_stmt|;
name|final_value
operator|=
name|GEN_INT
argument_list|(
name|comparison_val
operator|+
name|INTVAL
argument_list|(
name|bl
operator|->
name|initial_value
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|bl
operator|->
name|initial_value
operator|=
name|initial_value
expr_stmt|;
comment|/* Save some info needed to produce the new insns.  */
name|reg
operator|=
name|bl
operator|->
name|biv
operator|->
name|dest_reg
expr_stmt|;
name|jump_label
operator|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|PREV_INSN
argument_list|(
name|loop_end
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|jump_label
operator|==
name|pc_rtx
condition|)
name|jump_label
operator|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|PREV_INSN
argument_list|(
name|loop_end
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|new_add_val
operator|=
name|GEN_INT
argument_list|(
operator|-
name|INTVAL
argument_list|(
name|bl
operator|->
name|biv
operator|->
name|add_val
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set start_value; if this is not a CONST_INT, we need 		 to generate a SUB. 		 Initialize biv to start_value before loop start. 		 The old initializing insn will be deleted as a 		 dead store by flow.c.  */
if|if
condition|(
name|initial_value
operator|==
name|const0_rtx
operator|&&
name|GET_CODE
argument_list|(
name|comparison_value
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|start_value
operator|=
name|GEN_INT
argument_list|(
name|comparison_val
operator|-
name|add_adjust
argument_list|)
expr_stmt|;
name|emit_insn_before
argument_list|(
name|gen_move_insn
argument_list|(
name|reg
argument_list|,
name|start_value
argument_list|)
argument_list|,
name|loop_start
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|initial_value
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|rtx
name|offset
init|=
name|GEN_INT
argument_list|(
operator|-
name|INTVAL
argument_list|(
name|initial_value
argument_list|)
operator|-
name|add_adjust
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|reg
argument_list|)
decl_stmt|;
name|enum
name|insn_code
name|icode
init|=
name|add_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
decl_stmt|;
if|if
condition|(
operator|!
call|(
modifier|*
name|insn_operand_predicate
index|[
name|icode
index|]
index|[
literal|0
index|]
call|)
argument_list|(
name|reg
argument_list|,
name|mode
argument_list|)
operator|||
operator|!
operator|(
call|(
modifier|*
name|insn_operand_predicate
index|[
name|icode
index|]
index|[
literal|1
index|]
call|)
argument_list|(
name|comparison_value
argument_list|,
name|mode
argument_list|)
operator|)
operator|||
operator|!
call|(
modifier|*
name|insn_operand_predicate
index|[
name|icode
index|]
index|[
literal|2
index|]
call|)
argument_list|(
name|offset
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|0
return|;
name|start_value
operator|=
name|gen_rtx_PLUS
argument_list|(
name|mode
argument_list|,
name|comparison_value
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|emit_insn_before
argument_list|(
operator|(
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|reg
argument_list|,
name|comparison_value
argument_list|,
name|offset
argument_list|)
operator|)
argument_list|,
name|loop_start
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|comparison
argument_list|)
operator|==
name|LE
condition|)
name|final_value
operator|=
name|gen_rtx_PLUS
argument_list|(
name|mode
argument_list|,
name|comparison_value
argument_list|,
name|GEN_INT
argument_list|(
name|add_val
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|add_adjust
condition|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|reg
argument_list|)
decl_stmt|;
name|enum
name|insn_code
name|icode
init|=
name|sub_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
decl_stmt|;
if|if
condition|(
operator|!
call|(
modifier|*
name|insn_operand_predicate
index|[
name|icode
index|]
index|[
literal|0
index|]
call|)
argument_list|(
name|reg
argument_list|,
name|mode
argument_list|)
operator|||
operator|!
operator|(
call|(
modifier|*
name|insn_operand_predicate
index|[
name|icode
index|]
index|[
literal|1
index|]
call|)
argument_list|(
name|comparison_value
argument_list|,
name|mode
argument_list|)
operator|)
operator|||
operator|!
operator|(
call|(
modifier|*
name|insn_operand_predicate
index|[
name|icode
index|]
index|[
literal|2
index|]
call|)
argument_list|(
name|initial_value
argument_list|,
name|mode
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
name|start_value
operator|=
name|gen_rtx_MINUS
argument_list|(
name|mode
argument_list|,
name|comparison_value
argument_list|,
name|initial_value
argument_list|)
expr_stmt|;
name|emit_insn_before
argument_list|(
operator|(
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|reg
argument_list|,
name|comparison_value
argument_list|,
name|initial_value
argument_list|)
operator|)
argument_list|,
name|loop_start
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* We could handle the other cases too, but it'll be 		   better to have a testcase first.  */
return|return
literal|0
return|;
comment|/* We may not have a single insn which can increment a reg, so 		 create a sequence to hold all the insns from expand_inc.  */
name|start_sequence
argument_list|()
expr_stmt|;
name|expand_inc
argument_list|(
name|reg
argument_list|,
name|new_add_val
argument_list|)
expr_stmt|;
name|tem
operator|=
name|gen_sequence
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|p
operator|=
name|emit_insn_before
argument_list|(
name|tem
argument_list|,
name|bl
operator|->
name|biv
operator|->
name|insn
argument_list|)
expr_stmt|;
name|delete_insn
argument_list|(
name|bl
operator|->
name|biv
operator|->
name|insn
argument_list|)
expr_stmt|;
comment|/* Update biv info to reflect its new status.  */
name|bl
operator|->
name|biv
operator|->
name|insn
operator|=
name|p
expr_stmt|;
name|bl
operator|->
name|initial_value
operator|=
name|start_value
expr_stmt|;
name|bl
operator|->
name|biv
operator|->
name|add_val
operator|=
name|new_add_val
expr_stmt|;
comment|/* Update loop info.  */
name|loop_info
operator|->
name|initial_value
operator|=
name|reg
expr_stmt|;
name|loop_info
operator|->
name|initial_equiv_value
operator|=
name|reg
expr_stmt|;
name|loop_info
operator|->
name|final_value
operator|=
name|const0_rtx
expr_stmt|;
name|loop_info
operator|->
name|final_equiv_value
operator|=
name|const0_rtx
expr_stmt|;
name|loop_info
operator|->
name|comparison_value
operator|=
name|const0_rtx
expr_stmt|;
name|loop_info
operator|->
name|comparison_code
operator|=
name|cmp_code
expr_stmt|;
name|loop_info
operator|->
name|increment
operator|=
name|new_add_val
expr_stmt|;
comment|/* Inc LABEL_NUSES so that delete_insn will 		 not delete the label.  */
name|LABEL_NUSES
argument_list|(
name|XEXP
argument_list|(
name|jump_label
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|++
expr_stmt|;
comment|/* Emit an insn after the end of the loop to set the biv's 		 proper exit value if it is used anywhere outside the loop.  */
if|if
condition|(
operator|(
name|REGNO_LAST_UID
argument_list|(
name|bl
operator|->
name|regno
argument_list|)
operator|!=
name|INSN_UID
argument_list|(
name|first_compare
argument_list|)
operator|)
operator|||
operator|!
name|bl
operator|->
name|init_insn
operator|||
name|REGNO_FIRST_UID
argument_list|(
name|bl
operator|->
name|regno
argument_list|)
operator|!=
name|INSN_UID
argument_list|(
name|bl
operator|->
name|init_insn
argument_list|)
condition|)
name|emit_insn_after
argument_list|(
name|gen_move_insn
argument_list|(
name|reg
argument_list|,
name|final_value
argument_list|)
argument_list|,
name|loop_end
argument_list|)
expr_stmt|;
comment|/* Delete compare/branch at end of loop.  */
name|delete_insn
argument_list|(
name|PREV_INSN
argument_list|(
name|loop_end
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|compare_and_branch
operator|==
literal|2
condition|)
name|delete_insn
argument_list|(
name|first_compare
argument_list|)
expr_stmt|;
comment|/* Add new compare/branch insn at end of loop.  */
name|start_sequence
argument_list|()
expr_stmt|;
name|emit_cmp_and_jump_insns
argument_list|(
name|reg
argument_list|,
name|const0_rtx
argument_list|,
name|cmp_code
argument_list|,
name|NULL_RTX
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|XEXP
argument_list|(
name|jump_label
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|tem
operator|=
name|gen_sequence
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_jump_insn_before
argument_list|(
name|tem
argument_list|,
name|loop_end
argument_list|)
expr_stmt|;
for|for
control|(
name|tem
operator|=
name|PREV_INSN
argument_list|(
name|loop_end
argument_list|)
init|;
name|tem
operator|&&
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|!=
name|JUMP_INSN
condition|;
name|tem
operator|=
name|PREV_INSN
argument_list|(
name|tem
argument_list|)
control|)
empty_stmt|;
if|if
condition|(
name|tem
condition|)
name|JUMP_LABEL
argument_list|(
name|tem
argument_list|)
operator|=
name|XEXP
argument_list|(
name|jump_label
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nonneg
condition|)
block|{
if|if
condition|(
name|tem
condition|)
block|{
comment|/* Increment of LABEL_NUSES done above.  */
comment|/* Register is now always nonnegative, 			 so add REG_NONNEG note to the branch.  */
name|REG_NOTES
argument_list|(
name|tem
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_NONNEG
argument_list|,
name|NULL_RTX
argument_list|,
name|REG_NOTES
argument_list|(
name|tem
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|bl
operator|->
name|nonneg
operator|=
literal|1
expr_stmt|;
block|}
comment|/* No insn may reference both the reversed and another biv or it 		 will fail (see comment near the top of the loop reversal 		 code). 		 Earlier on, we have verified that the biv has no use except 		 counting, or it is the only biv in this function. 		 However, the code that computes no_use_except_counting does 		 not verify reg notes.  It's possible to have an insn that 		 references another biv, and has a REG_EQUAL note with an 		 expression based on the reversed biv.  To avoid this case, 		 remove all REG_EQUAL notes based on the reversed biv 		 here.  */
for|for
control|(
name|p
operator|=
name|loop_start
init|;
name|p
operator|!=
name|loop_end
condition|;
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
control|)
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
argument_list|)
operator|==
literal|'i'
condition|)
block|{
name|rtx
modifier|*
name|pnote
decl_stmt|;
name|rtx
name|set
init|=
name|single_set
argument_list|(
name|p
argument_list|)
decl_stmt|;
comment|/* If this is a set of a GIV based on the reversed biv, any 		       REG_EQUAL notes should still be correct.  */
if|if
condition|(
operator|!
name|set
operator|||
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
operator|(
name|size_t
operator|)
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|>=
name|reg_iv_type
operator|->
name|num_elements
operator|||
name|REG_IV_TYPE
argument_list|(
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|GENERAL_INDUCT
operator|||
name|REG_IV_INFO
argument_list|(
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
argument_list|)
operator|->
name|src_reg
operator|!=
name|bl
operator|->
name|biv
operator|->
name|src_reg
condition|)
for|for
control|(
name|pnote
operator|=
operator|&
name|REG_NOTES
argument_list|(
name|p
argument_list|)
init|;
operator|*
name|pnote
condition|;
control|)
block|{
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
operator|*
name|pnote
argument_list|)
operator|==
name|REG_EQUAL
operator|&&
name|reg_mentioned_p
argument_list|(
name|regno_reg_rtx
index|[
name|bl
operator|->
name|regno
index|]
argument_list|,
name|XEXP
argument_list|(
operator|*
name|pnote
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
operator|*
name|pnote
operator|=
name|XEXP
argument_list|(
operator|*
name|pnote
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|pnote
operator|=
operator|&
name|XEXP
argument_list|(
operator|*
name|pnote
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Mark that this biv has been reversed.  Each giv which depends 		 on this biv, and which is also live past the end of the loop 		 will have to be fixed up.  */
name|bl
operator|->
name|reversed
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|loop_dump_stream
condition|)
block|{
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Reversed loop"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bl
operator|->
name|nonneg
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|" and added reg_nonneg\n"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Verify whether the biv BL appears to be eliminable,    based on the insns in the loop that refer to it.    LOOP_START is the first insn of the loop, and END is the end insn.     If ELIMINATE_P is non-zero, actually do the elimination.     THRESHOLD and INSN_COUNT are from loop_optimize and are used to    determine whether invariant insns should be placed inside or at the    start of the loop.  */
end_comment

begin_function
specifier|static
name|int
name|maybe_eliminate_biv
parameter_list|(
name|bl
parameter_list|,
name|loop_start
parameter_list|,
name|end
parameter_list|,
name|eliminate_p
parameter_list|,
name|threshold
parameter_list|,
name|insn_count
parameter_list|)
name|struct
name|iv_class
modifier|*
name|bl
decl_stmt|;
name|rtx
name|loop_start
decl_stmt|;
name|rtx
name|end
decl_stmt|;
name|int
name|eliminate_p
decl_stmt|;
name|int
name|threshold
decl_stmt|,
name|insn_count
decl_stmt|;
block|{
name|rtx
name|reg
init|=
name|bl
operator|->
name|biv
operator|->
name|dest_reg
decl_stmt|;
name|rtx
name|p
decl_stmt|;
comment|/* Scan all insns in the loop, stopping if we find one that uses the      biv in a way that we cannot eliminate.  */
for|for
control|(
name|p
operator|=
name|loop_start
init|;
name|p
operator|!=
name|end
condition|;
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
control|)
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|rtx
name|where
init|=
name|threshold
operator|>=
name|insn_count
condition|?
name|loop_start
else|:
name|p
decl_stmt|;
comment|/* If this is a libcall that sets a giv, skip ahead to its end.  */
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'i'
condition|)
block|{
name|rtx
name|note
init|=
name|find_reg_note
argument_list|(
name|p
argument_list|,
name|REG_LIBCALL
argument_list|,
name|NULL_RTX
argument_list|)
decl_stmt|;
if|if
condition|(
name|note
condition|)
block|{
name|rtx
name|last
init|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|set
init|=
name|single_set
argument_list|(
name|last
argument_list|)
decl_stmt|;
if|if
condition|(
name|set
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|regno
operator|<
name|max_reg_before_loop
operator|&&
name|REG_IV_TYPE
argument_list|(
name|regno
argument_list|)
operator|==
name|GENERAL_INDUCT
operator|&&
name|REG_IV_INFO
argument_list|(
name|regno
argument_list|)
operator|->
name|src_reg
operator|==
name|bl
operator|->
name|biv
operator|->
name|src_reg
condition|)
name|p
operator|=
name|last
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|(
name|code
operator|==
name|INSN
operator|||
name|code
operator|==
name|JUMP_INSN
operator|||
name|code
operator|==
name|CALL_INSN
operator|)
operator|&&
name|reg_mentioned_p
argument_list|(
name|reg
argument_list|,
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
operator|&&
operator|!
name|maybe_eliminate_biv_1
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|,
name|p
argument_list|,
name|bl
argument_list|,
name|eliminate_p
argument_list|,
name|where
argument_list|)
condition|)
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Cannot eliminate biv %d: biv used in insn %d.\n"
argument_list|,
name|bl
operator|->
name|regno
argument_list|,
name|INSN_UID
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|p
operator|==
name|end
condition|)
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"biv %d %s eliminated.\n"
argument_list|,
name|bl
operator|->
name|regno
argument_list|,
name|eliminate_p
condition|?
literal|"was"
else|:
literal|"can be"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* INSN and REFERENCE are instructions in the same insn chain.    Return non-zero if INSN is first.  */
end_comment

begin_function
name|int
name|loop_insn_first_p
parameter_list|(
name|insn
parameter_list|,
name|reference
parameter_list|)
name|rtx
name|insn
decl_stmt|,
name|reference
decl_stmt|;
block|{
name|rtx
name|p
decl_stmt|,
name|q
decl_stmt|;
for|for
control|(
name|p
operator|=
name|insn
operator|,
name|q
operator|=
name|reference
init|;
condition|;
control|)
block|{
comment|/* Start with test for not first so that INSN == REFERENCE yields not          first.  */
if|if
condition|(
name|q
operator|==
name|insn
operator|||
operator|!
name|p
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|p
operator|==
name|reference
operator|||
operator|!
name|q
condition|)
return|return
literal|1
return|;
comment|/* Either of P or Q might be a NOTE.  Notes have the same LUID as the          previous insn, hence the<= comparison below does not work if 	 P is a note.  */
if|if
condition|(
name|INSN_UID
argument_list|(
name|p
argument_list|)
operator|<
name|max_uid_for_loop
operator|&&
name|INSN_UID
argument_list|(
name|q
argument_list|)
operator|<
name|max_uid_for_loop
operator|&&
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|!=
name|NOTE
condition|)
return|return
name|INSN_LUID
argument_list|(
name|p
argument_list|)
operator|<=
name|INSN_LUID
argument_list|(
name|q
argument_list|)
return|;
if|if
condition|(
name|INSN_UID
argument_list|(
name|p
argument_list|)
operator|>=
name|max_uid_for_loop
operator|||
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|NOTE
condition|)
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|INSN_UID
argument_list|(
name|q
argument_list|)
operator|>=
name|max_uid_for_loop
condition|)
name|q
operator|=
name|NEXT_INSN
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* We are trying to eliminate BIV in INSN using GIV.  Return non-zero if    the offset that we have to take into account due to auto-increment /    div derivation is zero.  */
end_comment

begin_function
specifier|static
name|int
name|biv_elimination_giv_has_0_offset
parameter_list|(
name|biv
parameter_list|,
name|giv
parameter_list|,
name|insn
parameter_list|)
name|struct
name|induction
modifier|*
name|biv
decl_stmt|,
decl|*
name|giv
decl_stmt|;
end_function

begin_decl_stmt
name|rtx
name|insn
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* If the giv V had the auto-inc address optimization applied      to it, and INSN occurs between the giv insn and the biv      insn, then we'd have to adjust the value used here.      This is rare, so we don't bother to make this possible.  */
if|if
condition|(
name|giv
operator|->
name|auto_inc_opt
operator|&&
operator|(
operator|(
name|loop_insn_first_p
argument_list|(
name|giv
operator|->
name|insn
argument_list|,
name|insn
argument_list|)
operator|&&
name|loop_insn_first_p
argument_list|(
name|insn
argument_list|,
name|biv
operator|->
name|insn
argument_list|)
operator|)
operator|||
operator|(
name|loop_insn_first_p
argument_list|(
name|biv
operator|->
name|insn
argument_list|,
name|insn
argument_list|)
operator|&&
name|loop_insn_first_p
argument_list|(
name|insn
argument_list|,
name|giv
operator|->
name|insn
argument_list|)
operator|)
operator|)
condition|)
return|return
literal|0
return|;
comment|/* If the giv V was derived from another giv, and INSN does      not occur between the giv insn and the biv insn, then we'd      have to adjust the value used here.  This is rare, so we don't      bother to make this possible.  */
if|if
condition|(
name|giv
operator|->
name|derived_from
operator|&&
operator|!
operator|(
name|giv
operator|->
name|always_executed
operator|&&
name|loop_insn_first_p
argument_list|(
name|giv
operator|->
name|insn
argument_list|,
name|insn
argument_list|)
operator|&&
name|loop_insn_first_p
argument_list|(
name|insn
argument_list|,
name|biv
operator|->
name|insn
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|giv
operator|->
name|same
operator|&&
name|giv
operator|->
name|same
operator|->
name|derived_from
operator|&&
operator|!
operator|(
name|giv
operator|->
name|same
operator|->
name|always_executed
operator|&&
name|loop_insn_first_p
argument_list|(
name|giv
operator|->
name|same
operator|->
name|insn
argument_list|,
name|insn
argument_list|)
operator|&&
name|loop_insn_first_p
argument_list|(
name|insn
argument_list|,
name|biv
operator|->
name|insn
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_block

begin_comment
comment|/* If BL appears in X (part of the pattern of INSN), see if we can    eliminate its use.  If so, return 1.  If not, return 0.     If BIV does not appear in X, return 1.     If ELIMINATE_P is non-zero, actually do the elimination.  WHERE indicates    where extra insns should be added.  Depending on how many items have been    moved out of the loop, it will either be before INSN or at the start of    the loop.  */
end_comment

begin_function
specifier|static
name|int
name|maybe_eliminate_biv_1
parameter_list|(
name|x
parameter_list|,
name|insn
parameter_list|,
name|bl
parameter_list|,
name|eliminate_p
parameter_list|,
name|where
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|insn
decl_stmt|;
name|struct
name|iv_class
modifier|*
name|bl
decl_stmt|;
name|int
name|eliminate_p
decl_stmt|;
name|rtx
name|where
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|rtx
name|reg
init|=
name|bl
operator|->
name|biv
operator|->
name|dest_reg
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|reg
argument_list|)
decl_stmt|;
name|struct
name|induction
modifier|*
name|v
decl_stmt|;
name|rtx
name|arg
decl_stmt|,
name|tem
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_cc0
name|rtx
name|new
decl_stmt|;
endif|#
directive|endif
name|int
name|arg_operand
decl_stmt|;
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|REG
case|:
comment|/* If we haven't already been able to do something with this BIV, 	 we can't eliminate it.  */
if|if
condition|(
name|x
operator|==
name|reg
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
case|case
name|SET
case|:
comment|/* If this sets the BIV, it is not a problem.  */
if|if
condition|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
operator|==
name|reg
condition|)
return|return
literal|1
return|;
comment|/* If this is an insn that defines a giv, it is also ok because 	 it will go away when the giv is reduced.  */
for|for
control|(
name|v
operator|=
name|bl
operator|->
name|giv
init|;
name|v
condition|;
name|v
operator|=
name|v
operator|->
name|next_iv
control|)
if|if
condition|(
name|v
operator|->
name|giv_type
operator|==
name|DEST_REG
operator|&&
name|SET_DEST
argument_list|(
name|x
argument_list|)
operator|==
name|v
operator|->
name|dest_reg
condition|)
return|return
literal|1
return|;
ifdef|#
directive|ifdef
name|HAVE_cc0
if|if
condition|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
operator|==
name|cc0_rtx
operator|&&
name|SET_SRC
argument_list|(
name|x
argument_list|)
operator|==
name|reg
condition|)
block|{
comment|/* Can replace with any giv that was reduced and 	     that has (MULT_VAL != 0) and (ADD_VAL == 0). 	     Require a constant for MULT_VAL, so we know it's nonzero. 	     ??? We disable this optimization to avoid potential 	     overflows.  */
for|for
control|(
name|v
operator|=
name|bl
operator|->
name|giv
init|;
name|v
condition|;
name|v
operator|=
name|v
operator|->
name|next_iv
control|)
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|v
operator|->
name|mult_val
argument_list|)
operator|&&
name|v
operator|->
name|mult_val
operator|!=
name|const0_rtx
operator|&&
name|v
operator|->
name|add_val
operator|==
name|const0_rtx
operator|&&
operator|!
name|v
operator|->
name|ignore
operator|&&
operator|!
name|v
operator|->
name|maybe_dead
operator|&&
name|v
operator|->
name|always_computable
operator|&&
name|v
operator|->
name|mode
operator|==
name|mode
operator|&&
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|biv_elimination_giv_has_0_offset
argument_list|(
name|bl
operator|->
name|biv
argument_list|,
name|v
argument_list|,
name|insn
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|eliminate_p
condition|)
return|return
literal|1
return|;
comment|/* If the giv has the opposite direction of change, 		   then reverse the comparison.  */
if|if
condition|(
name|INTVAL
argument_list|(
name|v
operator|->
name|mult_val
argument_list|)
operator|<
literal|0
condition|)
name|new
operator|=
name|gen_rtx_COMPARE
argument_list|(
name|GET_MODE
argument_list|(
name|v
operator|->
name|new_reg
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
name|v
operator|->
name|new_reg
argument_list|)
expr_stmt|;
else|else
name|new
operator|=
name|v
operator|->
name|new_reg
expr_stmt|;
comment|/* We can probably test that giv's reduced reg.  */
if|if
condition|(
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|new
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
comment|/* Look for a giv with (MULT_VAL != 0) and (ADD_VAL != 0); 	     replace test insn with a compare insn (cmp REDUCED_GIV ADD_VAL). 	     Require a constant for MULT_VAL, so we know it's nonzero. 	     ??? Do this only if ADD_VAL is a pointer to avoid a potential 	     overflow problem.  */
for|for
control|(
name|v
operator|=
name|bl
operator|->
name|giv
init|;
name|v
condition|;
name|v
operator|=
name|v
operator|->
name|next_iv
control|)
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|v
operator|->
name|mult_val
argument_list|)
operator|&&
name|v
operator|->
name|mult_val
operator|!=
name|const0_rtx
operator|&&
operator|!
name|v
operator|->
name|ignore
operator|&&
operator|!
name|v
operator|->
name|maybe_dead
operator|&&
name|v
operator|->
name|always_computable
operator|&&
name|v
operator|->
name|mode
operator|==
name|mode
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|v
operator|->
name|add_val
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|v
operator|->
name|add_val
argument_list|)
operator|==
name|LABEL_REF
operator|||
name|GET_CODE
argument_list|(
name|v
operator|->
name|add_val
argument_list|)
operator|==
name|CONST
operator|||
operator|(
name|GET_CODE
argument_list|(
name|v
operator|->
name|add_val
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO_POINTER_FLAG
argument_list|(
name|REGNO
argument_list|(
name|v
operator|->
name|add_val
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|biv_elimination_giv_has_0_offset
argument_list|(
name|bl
operator|->
name|biv
argument_list|,
name|v
argument_list|,
name|insn
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|eliminate_p
condition|)
return|return
literal|1
return|;
comment|/* If the giv has the opposite direction of change, 		   then reverse the comparison.  */
if|if
condition|(
name|INTVAL
argument_list|(
name|v
operator|->
name|mult_val
argument_list|)
operator|<
literal|0
condition|)
name|new
operator|=
name|gen_rtx_COMPARE
argument_list|(
name|VOIDmode
argument_list|,
name|copy_rtx
argument_list|(
name|v
operator|->
name|add_val
argument_list|)
argument_list|,
name|v
operator|->
name|new_reg
argument_list|)
expr_stmt|;
else|else
name|new
operator|=
name|gen_rtx_COMPARE
argument_list|(
name|VOIDmode
argument_list|,
name|v
operator|->
name|new_reg
argument_list|,
name|copy_rtx
argument_list|(
name|v
operator|->
name|add_val
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Replace biv with the giv's reduced register.  */
name|update_reg_last_use
argument_list|(
name|v
operator|->
name|add_val
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|,
name|new
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Insn doesn't support that constant or invariant.  Copy it 		   into a register (it will be a loop invariant.)  */
name|tem
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|v
operator|->
name|new_reg
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn_before
argument_list|(
name|gen_move_insn
argument_list|(
name|tem
argument_list|,
name|copy_rtx
argument_list|(
name|v
operator|->
name|add_val
argument_list|)
argument_list|)
argument_list|,
name|where
argument_list|)
expr_stmt|;
comment|/* Substitute the new register for its invariant value in 		   the compare expression. */
name|XEXP
argument_list|(
name|new
argument_list|,
operator|(
name|INTVAL
argument_list|(
name|v
operator|->
name|mult_val
argument_list|)
operator|<
literal|0
operator|)
condition|?
literal|0
else|:
literal|1
argument_list|)
operator|=
name|tem
expr_stmt|;
if|if
condition|(
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|,
name|new
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
block|}
endif|#
directive|endif
break|break;
case|case
name|COMPARE
case|:
case|case
name|EQ
case|:
case|case
name|NE
case|:
case|case
name|GT
case|:
case|case
name|GE
case|:
case|case
name|GTU
case|:
case|case
name|GEU
case|:
case|case
name|LT
case|:
case|case
name|LE
case|:
case|case
name|LTU
case|:
case|case
name|LEU
case|:
comment|/* See if either argument is the biv.  */
if|if
condition|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|reg
condition|)
name|arg
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|,
name|arg_operand
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|==
name|reg
condition|)
name|arg
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|,
name|arg_operand
operator|=
literal|0
expr_stmt|;
else|else
break|break;
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|arg
argument_list|)
condition|)
block|{
comment|/* First try to replace with any giv that has constant positive 	     mult_val and constant add_val.  We might be able to support 	     negative mult_val, but it seems complex to do it in general.  */
for|for
control|(
name|v
operator|=
name|bl
operator|->
name|giv
init|;
name|v
condition|;
name|v
operator|=
name|v
operator|->
name|next_iv
control|)
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|v
operator|->
name|mult_val
argument_list|)
operator|&&
name|INTVAL
argument_list|(
name|v
operator|->
name|mult_val
argument_list|)
operator|>
literal|0
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|v
operator|->
name|add_val
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|v
operator|->
name|add_val
argument_list|)
operator|==
name|LABEL_REF
operator|||
name|GET_CODE
argument_list|(
name|v
operator|->
name|add_val
argument_list|)
operator|==
name|CONST
operator|||
operator|(
name|GET_CODE
argument_list|(
name|v
operator|->
name|add_val
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO_POINTER_FLAG
argument_list|(
name|REGNO
argument_list|(
name|v
operator|->
name|add_val
argument_list|)
argument_list|)
operator|)
operator|)
operator|&&
operator|!
name|v
operator|->
name|ignore
operator|&&
operator|!
name|v
operator|->
name|maybe_dead
operator|&&
name|v
operator|->
name|always_computable
operator|&&
name|v
operator|->
name|mode
operator|==
name|mode
condition|)
block|{
if|if
condition|(
operator|!
name|biv_elimination_giv_has_0_offset
argument_list|(
name|bl
operator|->
name|biv
argument_list|,
name|v
argument_list|,
name|insn
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|eliminate_p
condition|)
return|return
literal|1
return|;
comment|/* Replace biv with the giv's reduced reg.  */
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
operator|-
name|arg_operand
argument_list|)
operator|=
name|v
operator|->
name|new_reg
expr_stmt|;
comment|/* If all constants are actually constant integers and 		   the derived constant can be directly placed in the COMPARE, 		   do so.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|v
operator|->
name|mult_val
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|v
operator|->
name|add_val
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
name|arg_operand
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|INTVAL
argument_list|(
name|arg
argument_list|)
operator|*
name|INTVAL
argument_list|(
name|v
operator|->
name|mult_val
argument_list|)
operator|+
name|INTVAL
argument_list|(
name|v
operator|->
name|add_val
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Otherwise, load it into a register.  */
name|tem
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|emit_iv_add_mult
argument_list|(
name|arg
argument_list|,
name|v
operator|->
name|mult_val
argument_list|,
name|v
operator|->
name|add_val
argument_list|,
name|tem
argument_list|,
name|where
argument_list|)
expr_stmt|;
if|if
condition|(
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
name|arg_operand
argument_list|)
argument_list|,
name|tem
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* If that failed, put back the change we made above.  */
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
operator|-
name|arg_operand
argument_list|)
operator|=
name|reg
expr_stmt|;
block|}
comment|/* Look for giv with positive constant mult_val and nonconst add_val. 	     Insert insns to calculate new compare value.   	     ??? Turn this off due to possible overflow.  */
for|for
control|(
name|v
operator|=
name|bl
operator|->
name|giv
init|;
name|v
condition|;
name|v
operator|=
name|v
operator|->
name|next_iv
control|)
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|v
operator|->
name|mult_val
argument_list|)
operator|&&
name|INTVAL
argument_list|(
name|v
operator|->
name|mult_val
argument_list|)
operator|>
literal|0
operator|&&
operator|!
name|v
operator|->
name|ignore
operator|&&
operator|!
name|v
operator|->
name|maybe_dead
operator|&&
name|v
operator|->
name|always_computable
operator|&&
name|v
operator|->
name|mode
operator|==
name|mode
operator|&&
literal|0
condition|)
block|{
name|rtx
name|tem
decl_stmt|;
if|if
condition|(
operator|!
name|biv_elimination_giv_has_0_offset
argument_list|(
name|bl
operator|->
name|biv
argument_list|,
name|v
argument_list|,
name|insn
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|eliminate_p
condition|)
return|return
literal|1
return|;
name|tem
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
comment|/* Replace biv with giv's reduced register.  */
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
operator|-
name|arg_operand
argument_list|)
argument_list|,
name|v
operator|->
name|new_reg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Compute value to compare against.  */
name|emit_iv_add_mult
argument_list|(
name|arg
argument_list|,
name|v
operator|->
name|mult_val
argument_list|,
name|v
operator|->
name|add_val
argument_list|,
name|tem
argument_list|,
name|where
argument_list|)
expr_stmt|;
comment|/* Use it in this insn.  */
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
name|arg_operand
argument_list|)
argument_list|,
name|tem
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|apply_change_group
argument_list|()
condition|)
return|return
literal|1
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|MEM
condition|)
block|{
if|if
condition|(
name|invariant_p
argument_list|(
name|arg
argument_list|)
operator|==
literal|1
condition|)
block|{
comment|/* Look for giv with constant positive mult_val and nonconst 		 add_val. Insert insns to compute new compare value.  		 ??? Turn this off due to possible overflow.  */
for|for
control|(
name|v
operator|=
name|bl
operator|->
name|giv
init|;
name|v
condition|;
name|v
operator|=
name|v
operator|->
name|next_iv
control|)
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|v
operator|->
name|mult_val
argument_list|)
operator|&&
name|INTVAL
argument_list|(
name|v
operator|->
name|mult_val
argument_list|)
operator|>
literal|0
operator|&&
operator|!
name|v
operator|->
name|ignore
operator|&&
operator|!
name|v
operator|->
name|maybe_dead
operator|&&
name|v
operator|->
name|always_computable
operator|&&
name|v
operator|->
name|mode
operator|==
name|mode
operator|&&
literal|0
condition|)
block|{
name|rtx
name|tem
decl_stmt|;
if|if
condition|(
operator|!
name|biv_elimination_giv_has_0_offset
argument_list|(
name|bl
operator|->
name|biv
argument_list|,
name|v
argument_list|,
name|insn
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|eliminate_p
condition|)
return|return
literal|1
return|;
name|tem
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
comment|/* Replace biv with giv's reduced register.  */
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
operator|-
name|arg_operand
argument_list|)
argument_list|,
name|v
operator|->
name|new_reg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Compute value to compare against.  */
name|emit_iv_add_mult
argument_list|(
name|arg
argument_list|,
name|v
operator|->
name|mult_val
argument_list|,
name|v
operator|->
name|add_val
argument_list|,
name|tem
argument_list|,
name|where
argument_list|)
expr_stmt|;
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
name|arg_operand
argument_list|)
argument_list|,
name|tem
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|apply_change_group
argument_list|()
condition|)
return|return
literal|1
return|;
block|}
block|}
comment|/* This code has problems.  Basically, you can't know when 	     seeing if we will eliminate BL, whether a particular giv 	     of ARG will be reduced.  If it isn't going to be reduced, 	     we can't eliminate BL.  We can try forcing it to be reduced, 	     but that can generate poor code.  	     The problem is that the benefit of reducing TV, below should 	     be increased if BL can actually be eliminated, but this means 	     we might have to do a topological sort of the order in which 	     we try to process biv.  It doesn't seem worthwhile to do 	     this sort of thing now.  */
if|#
directive|if
literal|0
comment|/* Otherwise the reg compared with had better be a biv.  */
block|if (GET_CODE (arg) != REG 	      || REG_IV_TYPE (REGNO (arg)) != BASIC_INDUCT) 	    return 0;
comment|/* Look for a pair of givs, one for each biv, 	     with identical coefficients.  */
block|for (v = bl->giv; v; v = v->next_iv) 	    { 	      struct induction *tv;  	      if (v->ignore || v->maybe_dead || v->mode != mode) 		continue;  	      for (tv = reg_biv_class[REGNO (arg)]->giv; tv; tv = tv->next_iv) 		if (! tv->ignore&& ! tv->maybe_dead&& rtx_equal_p (tv->mult_val, v->mult_val)&& rtx_equal_p (tv->add_val, v->add_val)&& tv->mode == mode) 		  { 		    if (! biv_elimination_giv_has_0_offset (bl->biv, v, insn)) 		      continue;  		    if (! eliminate_p) 		      return 1;
comment|/* Replace biv with its giv's reduced reg.  */
block|XEXP (x, 1-arg_operand) = v->new_reg;
comment|/* Replace other operand with the other giv's 		       reduced reg.  */
block|XEXP (x, arg_operand) = tv->new_reg; 		    return 1; 		  } 	    }
endif|#
directive|endif
block|}
comment|/* If we get here, the biv can't be eliminated.  */
return|return
literal|0
return|;
case|case
name|MEM
case|:
comment|/* If this address is a DEST_ADDR giv, it doesn't matter if the 	 biv is used in it, since it will be replaced.  */
for|for
control|(
name|v
operator|=
name|bl
operator|->
name|giv
init|;
name|v
condition|;
name|v
operator|=
name|v
operator|->
name|next_iv
control|)
if|if
condition|(
name|v
operator|->
name|giv_type
operator|==
name|DEST_ADDR
operator|&&
name|v
operator|->
name|location
operator|==
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|1
return|;
break|break;
default|default:
break|break;
block|}
comment|/* See if any subexpression fails elimination.  */
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
switch|switch
condition|(
name|fmt
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'e'
case|:
if|if
condition|(
operator|!
name|maybe_eliminate_biv_1
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|insn
argument_list|,
name|bl
argument_list|,
name|eliminate_p
argument_list|,
name|where
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'E'
case|:
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
operator|!
name|maybe_eliminate_biv_1
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|insn
argument_list|,
name|bl
argument_list|,
name|eliminate_p
argument_list|,
name|where
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return nonzero if the last use of REG    is in an insn following INSN in the same basic block.  */
end_comment

begin_function
specifier|static
name|int
name|last_use_this_basic_block
parameter_list|(
name|reg
parameter_list|,
name|insn
parameter_list|)
name|rtx
name|reg
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
name|rtx
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
name|insn
init|;
name|n
operator|&&
name|GET_CODE
argument_list|(
name|n
argument_list|)
operator|!=
name|CODE_LABEL
operator|&&
name|GET_CODE
argument_list|(
name|n
argument_list|)
operator|!=
name|JUMP_INSN
condition|;
name|n
operator|=
name|NEXT_INSN
argument_list|(
name|n
argument_list|)
control|)
block|{
if|if
condition|(
name|REGNO_LAST_UID
argument_list|(
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|)
operator|==
name|INSN_UID
argument_list|(
name|n
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Called via `note_stores' to record the initial value of a biv.  Here we    just record the location of the set and process it later.  */
end_comment

begin_function
specifier|static
name|void
name|record_initial
parameter_list|(
name|dest
parameter_list|,
name|set
parameter_list|)
name|rtx
name|dest
decl_stmt|;
name|rtx
name|set
decl_stmt|;
block|{
name|struct
name|iv_class
modifier|*
name|bl
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO
argument_list|(
name|dest
argument_list|)
operator|>=
name|max_reg_before_loop
operator|||
name|REG_IV_TYPE
argument_list|(
name|REGNO
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|!=
name|BASIC_INDUCT
condition|)
return|return;
name|bl
operator|=
name|reg_biv_class
index|[
name|REGNO
argument_list|(
name|dest
argument_list|)
index|]
expr_stmt|;
comment|/* If this is the first set found, record it.  */
if|if
condition|(
name|bl
operator|->
name|init_insn
operator|==
literal|0
condition|)
block|{
name|bl
operator|->
name|init_insn
operator|=
name|note_insn
expr_stmt|;
name|bl
operator|->
name|init_set
operator|=
name|set
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If any of the registers in X are "old" and currently have a last use earlier    than INSN, update them to have a last use of INSN.  Their actual last use    will be the previous insn but it will not have a valid uid_luid so we can't    use it.  */
end_comment

begin_function
specifier|static
name|void
name|update_reg_last_use
parameter_list|(
name|x
parameter_list|,
name|insn
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
comment|/* Check for the case where INSN does not have a valid luid.  In this case,      there is no need to modify the regno_last_uid, as this can only happen      when code is inserted after the loop_end to set a pseudo's final value,      and hence this insn will never be the last use of x.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|x
argument_list|)
operator|<
name|max_reg_before_loop
operator|&&
name|INSN_UID
argument_list|(
name|insn
argument_list|)
operator|<
name|max_uid_for_loop
operator|&&
name|uid_luid
index|[
name|REGNO_LAST_UID
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
index|]
operator|<
name|uid_luid
index|[
name|INSN_UID
argument_list|(
name|insn
argument_list|)
index|]
condition|)
name|REGNO_LAST_UID
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
operator|=
name|INSN_UID
argument_list|(
name|insn
argument_list|)
expr_stmt|;
else|else
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
init|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|update_reg_last_use
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
name|update_reg_last_use
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a jump insn JUMP, return the condition that will cause it to branch    to its JUMP_LABEL.  If the condition cannot be understood, or is an    inequality floating-point comparison which needs to be reversed, 0 will    be returned.     If EARLIEST is non-zero, it is a pointer to a place where the earliest    insn used in locating the condition was found.  If a replacement test    of the condition is desired, it should be placed in front of that    insn and we will be sure that the inputs are still valid.     The condition will be returned in a canonical form to simplify testing by    callers.  Specifically:     (1) The code will always be a comparison operation (EQ, NE, GT, etc.).    (2) Both operands will be machine operands; (cc0) will have been replaced.    (3) If an operand is a constant, it will be the second operand.    (4) (LE x const) will be replaced with (LT x<const+1>) and similarly        for GE, GEU, and LEU.  */
end_comment

begin_function
name|rtx
name|get_condition
parameter_list|(
name|jump
parameter_list|,
name|earliest
parameter_list|)
name|rtx
name|jump
decl_stmt|;
name|rtx
modifier|*
name|earliest
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
decl_stmt|;
name|rtx
name|prev
init|=
name|jump
decl_stmt|;
name|rtx
name|set
decl_stmt|;
name|rtx
name|tem
decl_stmt|;
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|;
name|int
name|reverse_code
init|=
literal|0
decl_stmt|;
name|int
name|did_reverse_condition
init|=
literal|0
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
comment|/* If this is not a standard conditional jump, we can't parse it.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|jump
argument_list|)
operator|!=
name|JUMP_INSN
operator|||
operator|!
name|condjump_p
argument_list|(
name|jump
argument_list|)
operator|||
name|simplejump_p
argument_list|(
name|jump
argument_list|)
condition|)
return|return
literal|0
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|jump
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|mode
operator|=
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|jump
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|op0
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|jump
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|jump
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|earliest
condition|)
operator|*
name|earliest
operator|=
name|jump
expr_stmt|;
comment|/* If this branches to JUMP_LABEL when the condition is false, reverse      the condition.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|jump
argument_list|)
argument_list|)
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|&&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|jump
argument_list|)
argument_list|)
argument_list|,
literal|2
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|JUMP_LABEL
argument_list|(
name|jump
argument_list|)
condition|)
name|code
operator|=
name|reverse_condition
argument_list|(
name|code
argument_list|)
operator|,
name|did_reverse_condition
operator|^=
literal|1
expr_stmt|;
comment|/* If we are comparing a register with zero, see if the register is set      in the previous insn to a COMPARE or a comparison operation.  Perform      the same tests as a function of STORE_FLAG_VALUE as find_comparison_args      in cse.c  */
while|while
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'<'
operator|&&
name|op1
operator|==
name|CONST0_RTX
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Set non-zero when we find something of interest.  */
name|rtx
name|x
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_cc0
comment|/* If comparison with cc0, import actual comparison from compare 	 insn.  */
if|if
condition|(
name|op0
operator|==
name|cc0_rtx
condition|)
block|{
if|if
condition|(
operator|(
name|prev
operator|=
name|prev_nonnote_insn
argument_list|(
name|prev
argument_list|)
operator|)
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|prev
argument_list|)
operator|!=
name|INSN
operator|||
operator|(
name|set
operator|=
name|single_set
argument_list|(
name|prev
argument_list|)
operator|)
operator|==
literal|0
operator|||
name|SET_DEST
argument_list|(
name|set
argument_list|)
operator|!=
name|cc0_rtx
condition|)
return|return
literal|0
return|;
name|op0
operator|=
name|SET_SRC
argument_list|(
name|set
argument_list|)
expr_stmt|;
name|op1
operator|=
name|CONST0_RTX
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|earliest
condition|)
operator|*
name|earliest
operator|=
name|prev
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* If this is a COMPARE, pick up the two things being compared.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|COMPARE
condition|)
block|{
name|op1
operator|=
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|op0
operator|=
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|REG
condition|)
break|break;
comment|/* Go back to the previous insn.  Stop if it is not an INSN.  We also 	 stop if it isn't a single set or if it has a REG_INC note because 	 we don't want to bother dealing with it.  */
if|if
condition|(
operator|(
name|prev
operator|=
name|prev_nonnote_insn
argument_list|(
name|prev
argument_list|)
operator|)
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|prev
argument_list|)
operator|!=
name|INSN
operator|||
name|FIND_REG_INC_NOTE
argument_list|(
name|prev
argument_list|,
literal|0
argument_list|)
operator|||
operator|(
name|set
operator|=
name|single_set
argument_list|(
name|prev
argument_list|)
operator|)
operator|==
literal|0
condition|)
break|break;
comment|/* If this is setting OP0, get what it sets it to if it looks 	 relevant.  */
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|,
name|op0
argument_list|)
condition|)
block|{
name|enum
name|machine_mode
name|inner_mode
init|=
name|GET_MODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
decl_stmt|;
comment|/* ??? We may not combine comparisons done in a CCmode with 	     comparisons not done in a CCmode.  This is to aid targets 	     like Alpha that have an IEEE compliant EQ instruction, and 	     a non-IEEE compliant BEQ instruction.  The use of CCmode is 	     actually artificial, simply to prevent the combination, but 	     should not affect other platforms.  	     However, we must allow VOIDmode comparisons to match either 	     CCmode or non-CCmode comparison, because some ports have 	     modeless comparisons inside branch patterns.  	     ??? This mode check should perhaps look more like the mode check 	     in simplify_comparison in combine.  */
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|COMPARE
operator|||
operator|(
operator|(
operator|(
name|code
operator|==
name|NE
operator|||
operator|(
name|code
operator|==
name|LT
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|inner_mode
argument_list|)
operator|==
name|MODE_INT
operator|&&
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|inner_mode
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|)
operator|&&
operator|(
name|STORE_FLAG_VALUE
operator|&
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|inner_mode
argument_list|)
operator|-
literal|1
operator|)
operator|)
operator|)
operator|)
ifdef|#
directive|ifdef
name|FLOAT_STORE_FLAG_VALUE
operator|||
operator|(
name|code
operator|==
name|LT
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|inner_mode
argument_list|)
operator|==
name|MODE_FLOAT
operator|&&
name|FLOAT_STORE_FLAG_VALUE
operator|<
literal|0
operator|)
endif|#
directive|endif
operator|)
operator|)
operator|&&
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|'<'
operator|)
operator|)
operator|&&
operator|(
operator|(
operator|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_CC
operator|)
operator|==
operator|(
name|GET_MODE_CLASS
argument_list|(
name|inner_mode
argument_list|)
operator|==
name|MODE_CC
operator|)
operator|)
operator|||
name|mode
operator|==
name|VOIDmode
operator|||
name|inner_mode
operator|==
name|VOIDmode
operator|)
condition|)
name|x
operator|=
name|SET_SRC
argument_list|(
name|set
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
operator|(
name|code
operator|==
name|EQ
operator|||
operator|(
name|code
operator|==
name|GE
operator|&&
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|inner_mode
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|)
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|inner_mode
argument_list|)
operator|==
name|MODE_INT
operator|&&
operator|(
name|STORE_FLAG_VALUE
operator|&
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|inner_mode
argument_list|)
operator|-
literal|1
operator|)
operator|)
operator|)
operator|)
ifdef|#
directive|ifdef
name|FLOAT_STORE_FLAG_VALUE
operator|||
operator|(
name|code
operator|==
name|GE
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|inner_mode
argument_list|)
operator|==
name|MODE_FLOAT
operator|&&
name|FLOAT_STORE_FLAG_VALUE
operator|<
literal|0
operator|)
endif|#
directive|endif
operator|)
operator|)
operator|&&
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|'<'
operator|&&
operator|(
operator|(
operator|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_CC
operator|)
operator|==
operator|(
name|GET_MODE_CLASS
argument_list|(
name|inner_mode
argument_list|)
operator|==
name|MODE_CC
operator|)
operator|)
operator|||
name|mode
operator|==
name|VOIDmode
operator|||
name|inner_mode
operator|==
name|VOIDmode
operator|)
condition|)
block|{
comment|/* We might have reversed a LT to get a GE here.  But this wasn't 		 actually the comparison of data, so we don't flag that we 		 have had to reverse the condition.  */
name|did_reverse_condition
operator|^=
literal|1
expr_stmt|;
name|reverse_code
operator|=
literal|1
expr_stmt|;
name|x
operator|=
name|SET_SRC
argument_list|(
name|set
argument_list|)
expr_stmt|;
block|}
else|else
break|break;
block|}
elseif|else
if|if
condition|(
name|reg_set_p
argument_list|(
name|op0
argument_list|,
name|prev
argument_list|)
condition|)
comment|/* If this sets OP0, but not directly, we have to give up.  */
break|break;
if|if
condition|(
name|x
condition|)
block|{
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
literal|'<'
condition|)
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|reverse_code
condition|)
block|{
name|code
operator|=
name|reverse_condition
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|did_reverse_condition
operator|^=
literal|1
expr_stmt|;
name|reverse_code
operator|=
literal|0
expr_stmt|;
block|}
name|op0
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|,
name|op1
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|earliest
condition|)
operator|*
name|earliest
operator|=
name|prev
expr_stmt|;
block|}
block|}
comment|/* If constant is first, put it last.  */
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|op0
argument_list|)
condition|)
name|code
operator|=
name|swap_condition
argument_list|(
name|code
argument_list|)
operator|,
name|tem
operator|=
name|op0
operator|,
name|op0
operator|=
name|op1
operator|,
name|op1
operator|=
name|tem
expr_stmt|;
comment|/* If OP0 is the result of a comparison, we weren't able to find what      was really being compared, so fail.  */
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|==
name|MODE_CC
condition|)
return|return
literal|0
return|;
comment|/* Canonicalize any ordered comparison with integers involving equality      if we can do computations in the relevant mode and we do not      overflow.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
name|HOST_WIDE_INT
name|const_val
init|=
name|INTVAL
argument_list|(
name|op1
argument_list|)
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|uconst_val
init|=
name|const_val
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|max_val
init|=
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|GET_MODE_MASK
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|LE
case|:
if|if
condition|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|const_val
operator|!=
name|max_val
operator|>>
literal|1
condition|)
name|code
operator|=
name|LT
operator|,
name|op1
operator|=
name|GEN_INT
argument_list|(
name|const_val
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
comment|/* When cross-compiling, const_val might be sign-extended from 	   BITS_PER_WORD to HOST_BITS_PER_WIDE_INT */
case|case
name|GE
case|:
if|if
condition|(
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
name|const_val
operator|&
name|max_val
argument_list|)
operator|!=
operator|(
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|-
literal|1
operator|)
operator|)
operator|)
condition|)
name|code
operator|=
name|GT
operator|,
name|op1
operator|=
name|GEN_INT
argument_list|(
name|const_val
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|LEU
case|:
if|if
condition|(
name|uconst_val
operator|<
name|max_val
condition|)
name|code
operator|=
name|LTU
operator|,
name|op1
operator|=
name|GEN_INT
argument_list|(
name|uconst_val
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|GEU
case|:
if|if
condition|(
name|uconst_val
operator|!=
literal|0
condition|)
name|code
operator|=
name|GTU
operator|,
name|op1
operator|=
name|GEN_INT
argument_list|(
name|uconst_val
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
comment|/* If this was floating-point and we reversed anything other than an      EQ or NE, return zero.  */
if|if
condition|(
name|TARGET_FLOAT_FORMAT
operator|==
name|IEEE_FLOAT_FORMAT
operator|&&
name|did_reverse_condition
operator|&&
name|code
operator|!=
name|NE
operator|&&
name|code
operator|!=
name|EQ
operator|&&
operator|!
name|flag_fast_math
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|==
name|MODE_FLOAT
condition|)
return|return
literal|0
return|;
ifdef|#
directive|ifdef
name|HAVE_cc0
comment|/* Never return CC0; return zero instead.  */
if|if
condition|(
name|op0
operator|==
name|cc0_rtx
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
return|return
name|gen_rtx_fmt_ee
argument_list|(
name|code
argument_list|,
name|VOIDmode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Similar to above routine, except that we also put an invariant last    unless both operands are invariants.  */
end_comment

begin_function
name|rtx
name|get_condition_for_loop
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
name|rtx
name|comparison
init|=
name|get_condition
argument_list|(
name|x
argument_list|,
name|NULL_PTR
argument_list|)
decl_stmt|;
if|if
condition|(
name|comparison
operator|==
literal|0
operator|||
operator|!
name|invariant_p
argument_list|(
name|XEXP
argument_list|(
name|comparison
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
name|invariant_p
argument_list|(
name|XEXP
argument_list|(
name|comparison
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
return|return
name|comparison
return|;
return|return
name|gen_rtx_fmt_ee
argument_list|(
name|swap_condition
argument_list|(
name|GET_CODE
argument_list|(
name|comparison
argument_list|)
argument_list|)
argument_list|,
name|VOIDmode
argument_list|,
name|XEXP
argument_list|(
name|comparison
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|comparison
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_decrement_and_branch_on_count
end_ifdef

begin_comment
comment|/* Instrument loop for insertion of bct instruction.  We distinguish between    loops with compile-time bounds and those with run-time bounds.     Information from loop_iterations() is used to compute compile-time bounds.    Run-time bounds should use loop preconditioning, but currently ignored.  */
end_comment

begin_function
specifier|static
name|void
name|insert_bct
parameter_list|(
name|loop_start
parameter_list|,
name|loop_end
parameter_list|,
name|loop_info
parameter_list|)
name|rtx
name|loop_start
decl_stmt|,
name|loop_end
decl_stmt|;
name|struct
name|loop_info
modifier|*
name|loop_info
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|n_iterations
decl_stmt|;
name|int
name|increment_direction
decl_stmt|,
name|compare_direction
decl_stmt|;
comment|/* If the loop condition is<= or>=, the number of iteration       is 1 more than the range of the bounds of the loop.  */
name|int
name|add_iteration
init|=
literal|0
decl_stmt|;
name|enum
name|machine_mode
name|loop_var_mode
init|=
name|word_mode
decl_stmt|;
name|int
name|loop_num
init|=
name|uid_loop_num
index|[
name|INSN_UID
argument_list|(
name|loop_start
argument_list|)
index|]
decl_stmt|;
comment|/* It's impossible to instrument a competely unrolled loop.  */
if|if
condition|(
name|loop_info
operator|->
name|unroll_number
operator|==
operator|-
literal|1
condition|)
return|return;
comment|/* Make sure that the count register is not in use.  */
if|if
condition|(
name|loop_used_count_register
index|[
name|loop_num
index|]
condition|)
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"insert_bct %d: BCT instrumentation failed: count register already in use\n"
argument_list|,
name|loop_num
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Make sure that the function has no indirect jumps.  */
if|if
condition|(
name|indirect_jump_in_function
condition|)
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"insert_bct %d: BCT instrumentation failed: indirect jump in function\n"
argument_list|,
name|loop_num
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Make sure that the last loop insn is a conditional jump.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|PREV_INSN
argument_list|(
name|loop_end
argument_list|)
argument_list|)
operator|!=
name|JUMP_INSN
operator|||
operator|!
name|condjump_p
argument_list|(
name|PREV_INSN
argument_list|(
name|loop_end
argument_list|)
argument_list|)
operator|||
name|simplejump_p
argument_list|(
name|PREV_INSN
argument_list|(
name|loop_end
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"insert_bct %d: BCT instrumentation failed: invalid jump at loop end\n"
argument_list|,
name|loop_num
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Make sure that the loop does not contain a function call      (the count register might be altered by the called function).  */
if|if
condition|(
name|loop_has_call
condition|)
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"insert_bct %d: BCT instrumentation failed: function call in loop\n"
argument_list|,
name|loop_num
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Make sure that the loop does not jump via a table.      (the count register might be used to perform the branch on table).  */
if|if
condition|(
name|loop_has_tablejump
condition|)
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"insert_bct %d: BCT instrumentation failed: computed branch in the loop\n"
argument_list|,
name|loop_num
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Account for loop unrolling in instrumented iteration count.  */
if|if
condition|(
name|loop_info
operator|->
name|unroll_number
operator|>
literal|1
condition|)
name|n_iterations
operator|=
name|loop_info
operator|->
name|n_iterations
operator|/
name|loop_info
operator|->
name|unroll_number
expr_stmt|;
else|else
name|n_iterations
operator|=
name|loop_info
operator|->
name|n_iterations
expr_stmt|;
if|if
condition|(
name|n_iterations
operator|!=
literal|0
operator|&&
name|n_iterations
operator|<
literal|3
condition|)
block|{
comment|/* Allow an enclosing outer loop to benefit if possible.  */
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"insert_bct %d: Too few iterations to benefit from BCT optimization\n"
argument_list|,
name|loop_num
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Try to instrument the loop.  */
comment|/* Handle the simpler case, where the bounds are known at compile time.  */
if|if
condition|(
name|n_iterations
operator|>
literal|0
condition|)
block|{
comment|/* Mark all enclosing loops that they cannot use count register.  */
for|for
control|(
name|i
operator|=
name|loop_num
init|;
name|i
operator|!=
operator|-
literal|1
condition|;
name|i
operator|=
name|loop_outer_loop
index|[
name|i
index|]
control|)
name|loop_used_count_register
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|instrument_loop_bct
argument_list|(
name|loop_start
argument_list|,
name|loop_end
argument_list|,
name|GEN_INT
argument_list|(
name|n_iterations
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Handle the more complex case, that the bounds are NOT known      at compile time.  In this case we generate run_time calculation      of the number of iterations.  */
if|if
condition|(
name|loop_info
operator|->
name|iteration_var
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"insert_bct %d: BCT Runtime Instrumentation failed: no loop iteration variable found\n"
argument_list|,
name|loop_num
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|loop_info
operator|->
name|iteration_var
argument_list|)
argument_list|)
operator|!=
name|MODE_INT
operator|||
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|loop_info
operator|->
name|iteration_var
argument_list|)
argument_list|)
operator|!=
name|UNITS_PER_WORD
condition|)
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"insert_bct %d: BCT Runtime Instrumentation failed: loop variable not integer\n"
argument_list|,
name|loop_num
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* With runtime bounds, if the compare is of the form '!=' we give up */
if|if
condition|(
name|loop_info
operator|->
name|comparison_code
operator|==
name|NE
condition|)
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"insert_bct %d: BCT Runtime Instrumentation failed: runtime bounds with != comparison\n"
argument_list|,
name|loop_num
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Use common loop preconditioning code instead.  */
if|#
directive|if
literal|0
block|else     {
comment|/* We rely on the existence of run-time guard to ensure that the 	 loop executes at least once.  */
block|rtx sequence;       rtx iterations_num_reg;        unsigned HOST_WIDE_INT increment_value_abs 	= INTVAL (increment) * increment_direction;
comment|/* make sure that the increment is a power of two, otherwise (an 	 expensive) divide is needed.  */
block|if (exact_log2 (increment_value_abs) == -1) 	{ 	  if (loop_dump_stream) 	    fprintf (loop_dump_stream, 		     "insert_bct: not instrumenting BCT because the increment is not power of 2\n"); 	  return; 	}
comment|/* compute the number of iterations */
block|start_sequence ();       { 	rtx temp_reg;
comment|/* Again, the number of iterations is calculated by: 	   ; 	   ;                  compare-val - initial-val + (increment -1) + additional-iteration 	   ; num_iterations = ----------------------------------------------------------------- 	   ;                                           increment 	 */
comment|/* ??? Do we have to call copy_rtx here before passing rtx to 	   expand_binop?  */
block|if (compare_direction> 0) 	  {
comment|/*<,<= :the loop variable is increasing */
block|temp_reg = expand_binop (loop_var_mode, sub_optab, 				     comparison_value, initial_value, 				     NULL_RTX, 0, OPTAB_LIB_WIDEN); 	  } 	else 	  { 	    temp_reg = expand_binop (loop_var_mode, sub_optab, 				     initial_value, comparison_value, 				     NULL_RTX, 0, OPTAB_LIB_WIDEN); 	  }  	if (increment_value_abs - 1 + add_iteration != 0) 	  temp_reg = expand_binop (loop_var_mode, add_optab, temp_reg, 				   GEN_INT (increment_value_abs - 1 					    + add_iteration), 				   NULL_RTX, 0, OPTAB_LIB_WIDEN);  	if (increment_value_abs != 1) 	  {
comment|/* ??? This will generate an expensive divide instruction for 	       most targets.  The original authors apparently expected this 	       to be a shift, since they test for power-of-2 divisors above, 	       but just naively generating a divide instruction will not give  	       a shift.  It happens to work for the PowerPC target because 	       the rs6000.md file has a divide pattern that emits shifts. 	       It will probably not work for any other target.  */
block|iterations_num_reg = expand_binop (loop_var_mode, sdiv_optab, 					       temp_reg, 					       GEN_INT (increment_value_abs), 					       NULL_RTX, 0, OPTAB_LIB_WIDEN); 	  } 	else 	  iterations_num_reg = temp_reg;       }       sequence = gen_sequence ();       end_sequence ();       emit_insn_before (sequence, loop_start);       instrument_loop_bct (loop_start, loop_end, iterations_num_reg);     }    return;
endif|#
directive|endif
comment|/* Complex case */
block|}
end_function

begin_comment
comment|/* Instrument loop by inserting a bct in it as follows:    1. A new counter register is created.    2. In the head of the loop the new variable is initialized to the value    passed in the loop_num_iterations parameter.    3. At the end of the loop, comparison of the register with 0 is generated.    The created comparison follows the pattern defined for the    decrement_and_branch_on_count insn, so this insn will be generated.    4. The branch on the old variable are deleted.  The compare must remain    because it might be used elsewhere.  If the loop-variable or condition    register are used elsewhere, they will be eliminated by flow.  */
end_comment

begin_function
specifier|static
name|void
name|instrument_loop_bct
parameter_list|(
name|loop_start
parameter_list|,
name|loop_end
parameter_list|,
name|loop_num_iterations
parameter_list|)
name|rtx
name|loop_start
decl_stmt|,
name|loop_end
decl_stmt|;
name|rtx
name|loop_num_iterations
decl_stmt|;
block|{
name|rtx
name|counter_reg
decl_stmt|;
name|rtx
name|start_label
decl_stmt|;
name|rtx
name|sequence
decl_stmt|;
if|if
condition|(
name|HAVE_decrement_and_branch_on_count
condition|)
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
block|{
name|fputs
argument_list|(
literal|"instrument_bct: Inserting BCT ("
argument_list|,
name|loop_dump_stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|loop_num_iterations
argument_list|)
operator|==
name|CONST_INT
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|INTVAL
argument_list|(
name|loop_num_iterations
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fputs
argument_list|(
literal|"runtime"
argument_list|,
name|loop_dump_stream
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|" iterations)"
argument_list|,
name|loop_dump_stream
argument_list|)
expr_stmt|;
block|}
comment|/* Discard original jump to continue loop.  Original compare result 	 may still be live, so it cannot be discarded explicitly.  */
name|delete_insn
argument_list|(
name|PREV_INSN
argument_list|(
name|loop_end
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Insert the label which will delimit the start of the loop.  */
name|start_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|emit_label_after
argument_list|(
name|start_label
argument_list|,
name|loop_start
argument_list|)
expr_stmt|;
comment|/* Insert initialization of the count register into the loop header.  */
name|start_sequence
argument_list|()
expr_stmt|;
name|counter_reg
operator|=
name|gen_reg_rtx
argument_list|(
name|word_mode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_move_insn
argument_list|(
name|counter_reg
argument_list|,
name|loop_num_iterations
argument_list|)
argument_list|)
expr_stmt|;
name|sequence
operator|=
name|gen_sequence
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_insn_before
argument_list|(
name|sequence
argument_list|,
name|loop_start
argument_list|)
expr_stmt|;
comment|/* Insert new comparison on the count register instead of the 	 old one, generating the needed BCT pattern (that will be 	 later recognized by assembly generation phase).  */
name|emit_jump_insn_before
argument_list|(
name|gen_decrement_and_branch_on_count
argument_list|(
name|counter_reg
argument_list|,
name|start_label
argument_list|)
argument_list|,
name|loop_end
argument_list|)
expr_stmt|;
name|JUMP_LABEL
argument_list|(
name|prev_nonnote_insn
argument_list|(
name|loop_end
argument_list|)
argument_list|)
operator|=
name|start_label
expr_stmt|;
name|LABEL_NUSES
argument_list|(
name|start_label
argument_list|)
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_decrement_and_branch_on_count */
end_comment

begin_comment
comment|/* Scan the function and determine whether it has indirect (computed) jumps.     This is taken mostly from flow.c; similar code exists elsewhere    in the compiler.  It may be useful to put this into rtlanal.c.  */
end_comment

begin_function
specifier|static
name|int
name|indirect_jump_in_function_p
parameter_list|(
name|start
parameter_list|)
name|rtx
name|start
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|start
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|computed_jump_p
argument_list|(
name|insn
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Add MEM to the LOOP_MEMS array, if appropriate.  See the    documentation for LOOP_MEMS for the definition of `appropriate'.    This function is called from prescan_loop via for_each_rtx.  */
end_comment

begin_function
specifier|static
name|int
name|insert_loop_mem
parameter_list|(
name|mem
parameter_list|,
name|data
parameter_list|)
name|rtx
modifier|*
name|mem
decl_stmt|;
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|rtx
name|m
init|=
operator|*
name|mem
decl_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL_RTX
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|m
argument_list|)
condition|)
block|{
case|case
name|MEM
case|:
break|break;
case|case
name|CONST_DOUBLE
case|:
comment|/* We're not interested in the MEM associated with a 	 CONST_DOUBLE, so there's no need to traverse into this.  */
return|return
operator|-
literal|1
return|;
default|default:
comment|/* This is not a MEM.  */
return|return
literal|0
return|;
block|}
comment|/* See if we've already seen this MEM.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|loop_mems_idx
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|m
argument_list|,
name|loop_mems
index|[
name|i
index|]
operator|.
name|mem
argument_list|)
condition|)
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|m
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|loop_mems
index|[
name|i
index|]
operator|.
name|mem
argument_list|)
condition|)
comment|/* The modes of the two memory accesses are different.  If 	     this happens, something tricky is going on, and we just 	     don't optimize accesses to this MEM.  */
name|loop_mems
index|[
name|i
index|]
operator|.
name|optimize
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Resize the array, if necessary.  */
if|if
condition|(
name|loop_mems_idx
operator|==
name|loop_mems_allocated
condition|)
block|{
if|if
condition|(
name|loop_mems_allocated
operator|!=
literal|0
condition|)
name|loop_mems_allocated
operator|*=
literal|2
expr_stmt|;
else|else
name|loop_mems_allocated
operator|=
literal|32
expr_stmt|;
name|loop_mems
operator|=
operator|(
name|loop_mem_info
operator|*
operator|)
name|xrealloc
argument_list|(
name|loop_mems
argument_list|,
name|loop_mems_allocated
operator|*
sizeof|sizeof
argument_list|(
name|loop_mem_info
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Actually insert the MEM.  */
name|loop_mems
index|[
name|loop_mems_idx
index|]
operator|.
name|mem
operator|=
name|m
expr_stmt|;
comment|/* We can't hoist this MEM out of the loop if it's a BLKmode MEM      because we can't put it in a register.  We still store it in the      table, though, so that if we see the same address later, but in a      non-BLK mode, we'll not think we can optimize it at that point.  */
name|loop_mems
index|[
name|loop_mems_idx
index|]
operator|.
name|optimize
operator|=
operator|(
name|GET_MODE
argument_list|(
name|m
argument_list|)
operator|!=
name|BLKmode
operator|)
expr_stmt|;
name|loop_mems
index|[
name|loop_mems_idx
index|]
operator|.
name|reg
operator|=
name|NULL_RTX
expr_stmt|;
operator|++
name|loop_mems_idx
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Like load_mems, but also ensures that SET_IN_LOOP,    MAY_NOT_OPTIMIZE, REG_SINGLE_USAGE, and INSN_COUNT have the correct    values after load_mems.  */
end_comment

begin_function
specifier|static
name|void
name|load_mems_and_recount_loop_regs_set
parameter_list|(
name|scan_start
parameter_list|,
name|end
parameter_list|,
name|loop_top
parameter_list|,
name|start
parameter_list|,
name|insn_count
parameter_list|)
name|rtx
name|scan_start
decl_stmt|;
name|rtx
name|end
decl_stmt|;
name|rtx
name|loop_top
decl_stmt|;
name|rtx
name|start
decl_stmt|;
name|int
modifier|*
name|insn_count
decl_stmt|;
block|{
name|int
name|nregs
init|=
name|max_reg_num
argument_list|()
decl_stmt|;
name|load_mems
argument_list|(
name|scan_start
argument_list|,
name|end
argument_list|,
name|loop_top
argument_list|,
name|start
argument_list|)
expr_stmt|;
comment|/* Recalculate set_in_loop and friends since load_mems may have      created new registers.  */
if|if
condition|(
name|max_reg_num
argument_list|()
operator|>
name|nregs
condition|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|old_nregs
decl_stmt|;
name|old_nregs
operator|=
name|nregs
expr_stmt|;
name|nregs
operator|=
name|max_reg_num
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
operator|)
name|nregs
operator|>
name|set_in_loop
operator|->
name|num_elements
condition|)
block|{
comment|/* Grow all the arrays.  */
name|VARRAY_GROW
argument_list|(
name|set_in_loop
argument_list|,
name|nregs
argument_list|)
expr_stmt|;
name|VARRAY_GROW
argument_list|(
name|n_times_set
argument_list|,
name|nregs
argument_list|)
expr_stmt|;
name|VARRAY_GROW
argument_list|(
name|may_not_optimize
argument_list|,
name|nregs
argument_list|)
expr_stmt|;
name|VARRAY_GROW
argument_list|(
name|reg_single_usage
argument_list|,
name|nregs
argument_list|)
expr_stmt|;
block|}
comment|/* Clear the arrays */
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|set_in_loop
operator|->
name|data
argument_list|,
name|nregs
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|may_not_optimize
operator|->
name|data
argument_list|,
name|nregs
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|reg_single_usage
operator|->
name|data
argument_list|,
name|nregs
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|count_loop_regs_set
argument_list|(
name|loop_top
condition|?
name|loop_top
else|:
name|start
argument_list|,
name|end
argument_list|,
name|may_not_optimize
argument_list|,
name|reg_single_usage
argument_list|,
name|insn_count
argument_list|,
name|nregs
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
block|{
name|VARRAY_CHAR
argument_list|(
name|may_not_optimize
argument_list|,
name|i
argument_list|)
operator|=
literal|1
expr_stmt|;
name|VARRAY_INT
argument_list|(
name|set_in_loop
argument_list|,
name|i
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|AVOID_CCMODE_COPIES
comment|/* Don't try to move insns which set CC registers if we should not 	 create CCmode register copies.  */
for|for
control|(
name|i
operator|=
name|max_reg_num
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|regno_reg_rtx
index|[
name|i
index|]
argument_list|)
argument_list|)
operator|==
name|MODE_CC
condition|)
name|VARRAY_CHAR
argument_list|(
name|may_not_optimize
argument_list|,
name|i
argument_list|)
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* Set n_times_set for the new registers.  */
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
name|set_in_loop
operator|->
name|data
operator|.
name|i
index|[
literal|0
index|]
operator|+
name|old_nregs
operator|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
name|n_times_set
operator|->
name|data
operator|.
name|i
index|[
literal|0
index|]
operator|+
name|old_nregs
operator|)
argument_list|,
operator|(
name|nregs
operator|-
name|old_nregs
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Move MEMs into registers for the duration of the loop.  SCAN_START    is the first instruction in the loop (as it is executed).  The    other parameters are as for next_insn_in_loop.  */
end_comment

begin_function
specifier|static
name|void
name|load_mems
parameter_list|(
name|scan_start
parameter_list|,
name|end
parameter_list|,
name|loop_top
parameter_list|,
name|start
parameter_list|)
name|rtx
name|scan_start
decl_stmt|;
name|rtx
name|end
decl_stmt|;
name|rtx
name|loop_top
decl_stmt|;
name|rtx
name|start
decl_stmt|;
block|{
name|int
name|maybe_never
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|rtx
name|p
decl_stmt|;
name|rtx
name|label
init|=
name|NULL_RTX
decl_stmt|;
name|rtx
name|end_label
decl_stmt|;
if|if
condition|(
name|loop_mems_idx
operator|>
literal|0
condition|)
block|{
comment|/* Nonzero if the next instruction may never be executed.  */
name|int
name|next_maybe_never
init|=
literal|0
decl_stmt|;
comment|/* Check to see if it's possible that some instructions in the 	 loop are never executed.  */
for|for
control|(
name|p
operator|=
name|next_insn_in_loop
argument_list|(
name|scan_start
argument_list|,
name|scan_start
argument_list|,
name|end
argument_list|,
name|loop_top
argument_list|)
init|;
name|p
operator|!=
name|NULL_RTX
operator|&&
operator|!
name|maybe_never
condition|;
name|p
operator|=
name|next_insn_in_loop
argument_list|(
name|p
argument_list|,
name|scan_start
argument_list|,
name|end
argument_list|,
name|loop_top
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|CODE_LABEL
condition|)
name|maybe_never
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|JUMP_INSN
comment|/* If we enter the loop in the middle, and scan 		      around to the beginning, don't set maybe_never 		      for that.  This must be an unconditional jump, 		      otherwise the code at the top of the loop might 		      never be executed.  Unconditional jumps are 		      followed a by barrier then loop end.  */
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|JUMP_LABEL
argument_list|(
name|p
argument_list|)
operator|==
name|loop_top
operator|&&
name|NEXT_INSN
argument_list|(
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
argument_list|)
operator|==
name|end
operator|&&
name|simplejump_p
argument_list|(
name|p
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|condjump_p
argument_list|(
name|p
argument_list|)
condition|)
comment|/* Something complicated.  */
name|maybe_never
operator|=
literal|1
expr_stmt|;
else|else
comment|/* If there are any more instructions in the loop, they 		   might not be reached.  */
name|next_maybe_never
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|next_maybe_never
condition|)
name|maybe_never
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Actually move the MEMs.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|loop_mems_idx
condition|;
operator|++
name|i
control|)
block|{
name|int
name|written
init|=
literal|0
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
name|rtx
name|mem
init|=
name|loop_mems
index|[
name|i
index|]
operator|.
name|mem
decl_stmt|;
name|rtx
name|mem_list_entry
decl_stmt|;
if|if
condition|(
name|MEM_VOLATILE_P
argument_list|(
name|mem
argument_list|)
operator|||
name|invariant_p
argument_list|(
name|XEXP
argument_list|(
name|mem
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
literal|1
condition|)
comment|/* There's no telling whether or not MEM is modified.  */
name|loop_mems
index|[
name|i
index|]
operator|.
name|optimize
operator|=
literal|0
expr_stmt|;
comment|/* Go through the MEMs written to in the loop to see if this 	     one is aliased by one of them.  */
name|mem_list_entry
operator|=
name|loop_store_mems
expr_stmt|;
while|while
condition|(
name|mem_list_entry
condition|)
block|{
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|mem
argument_list|,
name|XEXP
argument_list|(
name|mem_list_entry
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|written
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|true_dependence
argument_list|(
name|XEXP
argument_list|(
name|mem_list_entry
argument_list|,
literal|0
argument_list|)
argument_list|,
name|VOIDmode
argument_list|,
name|mem
argument_list|,
name|rtx_varies_p
argument_list|)
condition|)
block|{
comment|/* MEM is indeed aliased by this store.  */
name|loop_mems
index|[
name|i
index|]
operator|.
name|optimize
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|mem_list_entry
operator|=
name|XEXP
argument_list|(
name|mem_list_entry
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag_float_store
operator|&&
name|written
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|mem
argument_list|)
argument_list|)
operator|==
name|MODE_FLOAT
condition|)
name|loop_mems
index|[
name|i
index|]
operator|.
name|optimize
operator|=
literal|0
expr_stmt|;
comment|/* If this MEM is written to, we must be sure that there 	     are no reads from another MEM that aliases this one.  */
if|if
condition|(
name|loop_mems
index|[
name|i
index|]
operator|.
name|optimize
operator|&&
name|written
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|loop_mems_idx
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
name|j
operator|==
name|i
condition|)
continue|continue;
elseif|else
if|if
condition|(
name|true_dependence
argument_list|(
name|mem
argument_list|,
name|VOIDmode
argument_list|,
name|loop_mems
index|[
name|j
index|]
operator|.
name|mem
argument_list|,
name|rtx_varies_p
argument_list|)
condition|)
block|{
comment|/* It's not safe to hoist loop_mems[i] out of 			 the loop because writes to it might not be 			 seen by reads from loop_mems[j].  */
name|loop_mems
index|[
name|i
index|]
operator|.
name|optimize
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|maybe_never
operator|&&
name|may_trap_p
argument_list|(
name|mem
argument_list|)
condition|)
comment|/* We can't access the MEM outside the loop; it might 	       cause a trap that wouldn't have happened otherwise.  */
name|loop_mems
index|[
name|i
index|]
operator|.
name|optimize
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|loop_mems
index|[
name|i
index|]
operator|.
name|optimize
condition|)
comment|/* We thought we were going to lift this MEM out of the 	       loop, but later discovered that we could not.  */
continue|continue;
comment|/* Allocate a pseudo for this MEM.  We set REG_USERVAR_P in 	     order to keep scan_loop from moving stores to this MEM 	     out of the loop just because this REG is neither a 	     user-variable nor used in the loop test.  */
name|reg
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|mem
argument_list|)
argument_list|)
expr_stmt|;
name|REG_USERVAR_P
argument_list|(
name|reg
argument_list|)
operator|=
literal|1
expr_stmt|;
name|loop_mems
index|[
name|i
index|]
operator|.
name|reg
operator|=
name|reg
expr_stmt|;
comment|/* Now, replace all references to the MEM with the 	     corresponding pesudos.  */
for|for
control|(
name|p
operator|=
name|next_insn_in_loop
argument_list|(
name|scan_start
argument_list|,
name|scan_start
argument_list|,
name|end
argument_list|,
name|loop_top
argument_list|)
init|;
name|p
operator|!=
name|NULL_RTX
condition|;
name|p
operator|=
name|next_insn_in_loop
argument_list|(
name|p
argument_list|,
name|scan_start
argument_list|,
name|end
argument_list|,
name|loop_top
argument_list|)
control|)
block|{
name|rtx_and_int
name|ri
decl_stmt|;
name|ri
operator|.
name|r
operator|=
name|p
expr_stmt|;
name|ri
operator|.
name|i
operator|=
name|i
expr_stmt|;
name|for_each_rtx
argument_list|(
operator|&
name|p
argument_list|,
name|replace_loop_mem
argument_list|,
operator|&
name|ri
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|apply_change_group
argument_list|()
condition|)
comment|/* We couldn't replace all occurrences of the MEM.  */
name|loop_mems
index|[
name|i
index|]
operator|.
name|optimize
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|rtx
name|set
decl_stmt|;
comment|/* Load the memory immediately before START, which is 		 the NOTE_LOOP_BEG.  */
name|set
operator|=
name|gen_move_insn
argument_list|(
name|reg
argument_list|,
name|mem
argument_list|)
expr_stmt|;
name|emit_insn_before
argument_list|(
name|set
argument_list|,
name|start
argument_list|)
expr_stmt|;
if|if
condition|(
name|written
condition|)
block|{
if|if
condition|(
name|label
operator|==
name|NULL_RTX
condition|)
block|{
comment|/* We must compute the former 			 right-after-the-end label before we insert 			 the new one.  */
name|end_label
operator|=
name|next_label
argument_list|(
name|end
argument_list|)
expr_stmt|;
name|label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|emit_label_after
argument_list|(
name|label
argument_list|,
name|end
argument_list|)
expr_stmt|;
block|}
comment|/* Store the memory immediately after END, which is 		   the NOTE_LOOP_END.  */
name|set
operator|=
name|gen_move_insn
argument_list|(
name|copy_rtx
argument_list|(
name|mem
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|emit_insn_after
argument_list|(
name|set
argument_list|,
name|label
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|loop_dump_stream
condition|)
block|{
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Hoisted regno %d %s from "
argument_list|,
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|,
operator|(
name|written
condition|?
literal|"r/w"
else|:
literal|"r/o"
operator|)
argument_list|)
expr_stmt|;
name|print_rtl
argument_list|(
name|loop_dump_stream
argument_list|,
name|mem
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|loop_dump_stream
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|label
operator|!=
name|NULL_RTX
condition|)
block|{
comment|/* Now, we need to replace all references to the previous exit 	 label with the new one.  */
name|rtx_pair
name|rr
decl_stmt|;
name|rr
operator|.
name|r1
operator|=
name|end_label
expr_stmt|;
name|rr
operator|.
name|r2
operator|=
name|label
expr_stmt|;
for|for
control|(
name|p
operator|=
name|start
init|;
name|p
operator|!=
name|end
condition|;
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
control|)
block|{
name|for_each_rtx
argument_list|(
operator|&
name|p
argument_list|,
name|replace_label
argument_list|,
operator|&
name|rr
argument_list|)
expr_stmt|;
comment|/* If this is a JUMP_INSN, then we also need to fix the JUMP_LABEL 	     field.  This is not handled by for_each_rtx because it doesn't 	     handle unprinted ('0') fields.  We need to update JUMP_LABEL 	     because the immediately following unroll pass will use it. 	     replace_label would not work anyways, because that only handles 	     LABEL_REFs.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|JUMP_LABEL
argument_list|(
name|p
argument_list|)
operator|==
name|end_label
condition|)
name|JUMP_LABEL
argument_list|(
name|p
argument_list|)
operator|=
name|label
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Replace MEM with its associated pseudo register.  This function is    called from load_mems via for_each_rtx.  DATA is actually an    rtx_and_int * describing the instruction currently being scanned    and the MEM we are currently replacing.  */
end_comment

begin_function
specifier|static
name|int
name|replace_loop_mem
parameter_list|(
name|mem
parameter_list|,
name|data
parameter_list|)
name|rtx
modifier|*
name|mem
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
name|rtx_and_int
modifier|*
name|ri
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|int
name|i
decl_stmt|;
name|rtx
name|m
init|=
operator|*
name|mem
decl_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL_RTX
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|m
argument_list|)
condition|)
block|{
case|case
name|MEM
case|:
break|break;
case|case
name|CONST_DOUBLE
case|:
comment|/* We're not interested in the MEM associated with a 	 CONST_DOUBLE, so there's no need to traverse into one.  */
return|return
operator|-
literal|1
return|;
default|default:
comment|/* This is not a MEM.  */
return|return
literal|0
return|;
block|}
name|ri
operator|=
operator|(
name|rtx_and_int
operator|*
operator|)
name|data
expr_stmt|;
name|i
operator|=
name|ri
operator|->
name|i
expr_stmt|;
if|if
condition|(
operator|!
name|rtx_equal_p
argument_list|(
name|loop_mems
index|[
name|i
index|]
operator|.
name|mem
argument_list|,
name|m
argument_list|)
condition|)
comment|/* This is not the MEM we are currently replacing.  */
return|return
literal|0
return|;
name|insn
operator|=
name|ri
operator|->
name|r
expr_stmt|;
comment|/* Actually replace the MEM.  */
name|validate_change
argument_list|(
name|insn
argument_list|,
name|mem
argument_list|,
name|loop_mems
index|[
name|i
index|]
operator|.
name|reg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Replace occurrences of the old exit label for the loop with the new    one.  DATA is an rtx_pair containing the old and new labels,    respectively.  */
end_comment

begin_function
specifier|static
name|int
name|replace_label
parameter_list|(
name|x
parameter_list|,
name|data
parameter_list|)
name|rtx
modifier|*
name|x
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
name|rtx
name|l
init|=
operator|*
name|x
decl_stmt|;
name|rtx
name|old_label
init|=
operator|(
operator|(
name|rtx_pair
operator|*
operator|)
name|data
operator|)
operator|->
name|r1
decl_stmt|;
name|rtx
name|new_label
init|=
operator|(
operator|(
name|rtx_pair
operator|*
operator|)
name|data
operator|)
operator|->
name|r2
decl_stmt|;
if|if
condition|(
name|l
operator|==
name|NULL_RTX
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|l
argument_list|)
operator|!=
name|LABEL_REF
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|XEXP
argument_list|(
name|l
argument_list|,
literal|0
argument_list|)
operator|!=
name|old_label
condition|)
return|return
literal|0
return|;
name|XEXP
argument_list|(
name|l
argument_list|,
literal|0
argument_list|)
operator|=
name|new_label
expr_stmt|;
operator|++
name|LABEL_NUSES
argument_list|(
name|new_label
argument_list|)
expr_stmt|;
operator|--
name|LABEL_NUSES
argument_list|(
name|old_label
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

