begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Analysis Utilities for Loop Vectorization.    Copyright (C) 2003,2004,2005,2006 Free Software Foundation, Inc.    Contributed by Dorit Naishlos<dorit@il.ibm.com>  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_include
include|#
directive|include
file|"tree-flow.h"
end_include

begin_include
include|#
directive|include
file|"tree-dump.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"cfgloop.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"optabs.h"
end_include

begin_include
include|#
directive|include
file|"params.h"
end_include

begin_include
include|#
directive|include
file|"tree-chrec.h"
end_include

begin_include
include|#
directive|include
file|"tree-data-ref.h"
end_include

begin_include
include|#
directive|include
file|"tree-scalar-evolution.h"
end_include

begin_include
include|#
directive|include
file|"tree-vectorizer.h"
end_include

begin_comment
comment|/* Main analysis functions.  */
end_comment

begin_function_decl
specifier|static
name|loop_vec_info
name|vect_analyze_loop_form
parameter_list|(
name|struct
name|loop
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|vect_analyze_data_refs
parameter_list|(
name|loop_vec_info
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|vect_mark_stmts_to_be_vectorized
parameter_list|(
name|loop_vec_info
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vect_analyze_scalar_cycles
parameter_list|(
name|loop_vec_info
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|vect_analyze_data_ref_accesses
parameter_list|(
name|loop_vec_info
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|vect_analyze_data_ref_dependences
parameter_list|(
name|loop_vec_info
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|vect_analyze_data_refs_alignment
parameter_list|(
name|loop_vec_info
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|vect_compute_data_refs_alignment
parameter_list|(
name|loop_vec_info
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|vect_enhance_data_refs_alignment
parameter_list|(
name|loop_vec_info
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|vect_analyze_operations
parameter_list|(
name|loop_vec_info
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|vect_determine_vectorization_factor
parameter_list|(
name|loop_vec_info
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Utility functions for the analyses.  */
end_comment

begin_function_decl
specifier|static
name|bool
name|exist_non_indexing_operands_for_use_p
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|void
name|vect_mark_relevant
argument_list|(
name|VEC
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|)
operator|*
operator|*
argument_list|,
name|tree
argument_list|,
name|bool
argument_list|,
name|bool
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|bool
name|vect_stmt_relevant_p
parameter_list|(
name|tree
parameter_list|,
name|loop_vec_info
parameter_list|,
name|bool
modifier|*
parameter_list|,
name|bool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|vect_get_loop_niters
parameter_list|(
name|struct
name|loop
modifier|*
parameter_list|,
name|tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|vect_analyze_data_ref_dependence
parameter_list|(
name|struct
name|data_dependence_relation
modifier|*
parameter_list|,
name|loop_vec_info
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|vect_compute_data_ref_alignment
parameter_list|(
name|struct
name|data_reference
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|vect_analyze_data_ref_access
parameter_list|(
name|struct
name|data_reference
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|vect_can_advance_ivs_p
parameter_list|(
name|loop_vec_info
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vect_update_misalignment_for_peel
parameter_list|(
name|struct
name|data_reference
modifier|*
parameter_list|,
name|struct
name|data_reference
modifier|*
parameter_list|,
name|int
name|npeel
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Function vect_determine_vectorization_factor     Determine the vectorization factor (VF). VF is the number of data elements    that are operated upon in parallel in a single iteration of the vectorized    loop. For example, when vectorizing a loop that operates on 4byte elements,    on a target with vector size (VS) 16byte, the VF is set to 4, since 4    elements can fit in a single vector register.     We currently support vectorization of loops in which all types operated upon    are of the same size. Therefore this function currently sets VF according to    the size of the types operated upon, and fails if there are multiple sizes    in the loop.     VF is also the factor by which the loop iterations are strip-mined, e.g.:    original loop:         for (i=0; i<N; i++){           a[i] = b[i] + c[i];         }     vectorized loop:         for (i=0; i<N; i+=VF){           a[i:VF] = b[i:VF] + c[i:VF];         } */
end_comment

begin_function
specifier|static
name|bool
name|vect_determine_vectorization_factor
parameter_list|(
name|loop_vec_info
name|loop_vinfo
parameter_list|)
block|{
name|struct
name|loop
modifier|*
name|loop
init|=
name|LOOP_VINFO_LOOP
argument_list|(
name|loop_vinfo
argument_list|)
decl_stmt|;
name|basic_block
modifier|*
name|bbs
init|=
name|LOOP_VINFO_BBS
argument_list|(
name|loop_vinfo
argument_list|)
decl_stmt|;
name|int
name|nbbs
init|=
name|loop
operator|->
name|num_nodes
decl_stmt|;
name|block_stmt_iterator
name|si
decl_stmt|;
name|unsigned
name|int
name|vectorization_factor
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|tree
name|scalar_type
decl_stmt|;
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"=== vect_determine_vectorization_factor ==="
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nbbs
condition|;
name|i
operator|++
control|)
block|{
name|basic_block
name|bb
init|=
name|bbs
index|[
name|i
index|]
decl_stmt|;
for|for
control|(
name|si
operator|=
name|bsi_start
argument_list|(
name|bb
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|si
argument_list|)
condition|;
name|bsi_next
argument_list|(
operator|&
name|si
argument_list|)
control|)
block|{
name|tree
name|stmt
init|=
name|bsi_stmt
argument_list|(
name|si
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|nunits
decl_stmt|;
name|stmt_vec_info
name|stmt_info
init|=
name|vinfo_for_stmt
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
name|tree
name|vectype
decl_stmt|;
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"==> examining statement: "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|vect_dump
argument_list|,
name|stmt
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
block|}
name|gcc_assert
argument_list|(
name|stmt_info
argument_list|)
expr_stmt|;
comment|/* skip stmts which do not need to be vectorized.  */
if|if
condition|(
operator|!
name|STMT_VINFO_RELEVANT_P
argument_list|(
name|stmt_info
argument_list|)
operator|&&
operator|!
name|STMT_VINFO_LIVE_P
argument_list|(
name|stmt_info
argument_list|)
condition|)
block|{
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"skip."
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|VECTOR_MODE_P
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|stmt
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_UNVECTORIZED_LOOPS
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"not vectorized: vector stmt in loop:"
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|vect_dump
argument_list|,
name|stmt
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
block|}
return|return
name|false
return|;
block|}
if|if
condition|(
name|STMT_VINFO_VECTYPE
argument_list|(
name|stmt_info
argument_list|)
condition|)
block|{
name|vectype
operator|=
name|STMT_VINFO_VECTYPE
argument_list|(
name|stmt_info
argument_list|)
expr_stmt|;
name|scalar_type
operator|=
name|TREE_TYPE
argument_list|(
name|vectype
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|STMT_VINFO_DATA_REF
argument_list|(
name|stmt_info
argument_list|)
condition|)
name|scalar_type
operator|=
name|TREE_TYPE
argument_list|(
name|DR_REF
argument_list|(
name|STMT_VINFO_DATA_REF
argument_list|(
name|stmt_info
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|MODIFY_EXPR
condition|)
name|scalar_type
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|scalar_type
operator|=
name|TREE_TYPE
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"get vectype for scalar type:  "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|vect_dump
argument_list|,
name|scalar_type
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
block|}
name|vectype
operator|=
name|get_vectype_for_scalar_type
argument_list|(
name|scalar_type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vectype
condition|)
block|{
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_UNVECTORIZED_LOOPS
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"not vectorized: unsupported data-type "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|vect_dump
argument_list|,
name|scalar_type
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
block|}
return|return
name|false
return|;
block|}
name|STMT_VINFO_VECTYPE
argument_list|(
name|stmt_info
argument_list|)
operator|=
name|vectype
expr_stmt|;
block|}
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"vectype: "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|vect_dump
argument_list|,
name|vectype
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
block|}
name|nunits
operator|=
name|TYPE_VECTOR_SUBPARTS
argument_list|(
name|vectype
argument_list|)
expr_stmt|;
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"nunits = %d"
argument_list|,
name|nunits
argument_list|)
expr_stmt|;
if|if
condition|(
name|vectorization_factor
condition|)
block|{
comment|/* FORNOW: don't allow mixed units.                   This restriction will be relaxed in the future.  */
if|if
condition|(
name|nunits
operator|!=
name|vectorization_factor
condition|)
block|{
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_UNVECTORIZED_LOOPS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"not vectorized: mixed data-types"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
else|else
name|vectorization_factor
operator|=
name|nunits
expr_stmt|;
name|gcc_assert
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|scalar_type
argument_list|)
argument_list|)
operator|*
name|vectorization_factor
operator|==
name|UNITS_PER_SIMD_WORD
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* TODO: Analyze cost. Decide if worth while to vectorize.  */
if|if
condition|(
name|vectorization_factor
operator|<=
literal|1
condition|)
block|{
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_UNVECTORIZED_LOOPS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"not vectorized: unsupported data-type"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|LOOP_VINFO_VECT_FACTOR
argument_list|(
name|loop_vinfo
argument_list|)
operator|=
name|vectorization_factor
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Function vect_analyze_operations.     Scan the loop stmts and make sure they are all vectorizable.  */
end_comment

begin_function
specifier|static
name|bool
name|vect_analyze_operations
parameter_list|(
name|loop_vec_info
name|loop_vinfo
parameter_list|)
block|{
name|struct
name|loop
modifier|*
name|loop
init|=
name|LOOP_VINFO_LOOP
argument_list|(
name|loop_vinfo
argument_list|)
decl_stmt|;
name|basic_block
modifier|*
name|bbs
init|=
name|LOOP_VINFO_BBS
argument_list|(
name|loop_vinfo
argument_list|)
decl_stmt|;
name|int
name|nbbs
init|=
name|loop
operator|->
name|num_nodes
decl_stmt|;
name|block_stmt_iterator
name|si
decl_stmt|;
name|unsigned
name|int
name|vectorization_factor
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|bool
name|ok
decl_stmt|;
name|tree
name|phi
decl_stmt|;
name|stmt_vec_info
name|stmt_info
decl_stmt|;
name|bool
name|need_to_vectorize
init|=
name|false
decl_stmt|;
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"=== vect_analyze_operations ==="
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|LOOP_VINFO_VECT_FACTOR
argument_list|(
name|loop_vinfo
argument_list|)
argument_list|)
expr_stmt|;
name|vectorization_factor
operator|=
name|LOOP_VINFO_VECT_FACTOR
argument_list|(
name|loop_vinfo
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nbbs
condition|;
name|i
operator|++
control|)
block|{
name|basic_block
name|bb
init|=
name|bbs
index|[
name|i
index|]
decl_stmt|;
for|for
control|(
name|phi
operator|=
name|phi_nodes
argument_list|(
name|bb
argument_list|)
init|;
name|phi
condition|;
name|phi
operator|=
name|PHI_CHAIN
argument_list|(
name|phi
argument_list|)
control|)
block|{
name|stmt_info
operator|=
name|vinfo_for_stmt
argument_list|(
name|phi
argument_list|)
expr_stmt|;
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"examining phi: "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|vect_dump
argument_list|,
name|phi
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
block|}
name|gcc_assert
argument_list|(
name|stmt_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|STMT_VINFO_LIVE_P
argument_list|(
name|stmt_info
argument_list|)
condition|)
block|{
comment|/* FORNOW: not yet supported.  */
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_UNVECTORIZED_LOOPS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"not vectorized: value used after loop."
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|STMT_VINFO_RELEVANT_P
argument_list|(
name|stmt_info
argument_list|)
condition|)
block|{
comment|/* Most likely a reduction-like computation that is used 	         in the loop.  */
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_UNVECTORIZED_LOOPS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"not vectorized: unsupported pattern."
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
for|for
control|(
name|si
operator|=
name|bsi_start
argument_list|(
name|bb
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|si
argument_list|)
condition|;
name|bsi_next
argument_list|(
operator|&
name|si
argument_list|)
control|)
block|{
name|tree
name|stmt
init|=
name|bsi_stmt
argument_list|(
name|si
argument_list|)
decl_stmt|;
name|stmt_vec_info
name|stmt_info
init|=
name|vinfo_for_stmt
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"==> examining statement: "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|vect_dump
argument_list|,
name|stmt
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
block|}
name|gcc_assert
argument_list|(
name|stmt_info
argument_list|)
expr_stmt|;
comment|/* skip stmts which do not need to be vectorized. 	     this is expected to include: 	     - the COND_EXPR which is the loop exit condition 	     - any LABEL_EXPRs in the loop 	     - computations that are used only for array indexing or loop 	     control  */
if|if
condition|(
operator|!
name|STMT_VINFO_RELEVANT_P
argument_list|(
name|stmt_info
argument_list|)
operator|&&
operator|!
name|STMT_VINFO_LIVE_P
argument_list|(
name|stmt_info
argument_list|)
condition|)
block|{
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"irrelevant."
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|STMT_VINFO_RELEVANT_P
argument_list|(
name|stmt_info
argument_list|)
condition|)
block|{
name|gcc_assert
argument_list|(
operator|!
name|VECTOR_MODE_P
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|stmt
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|STMT_VINFO_VECTYPE
argument_list|(
name|stmt_info
argument_list|)
argument_list|)
expr_stmt|;
name|ok
operator|=
operator|(
name|vectorizable_operation
argument_list|(
name|stmt
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|||
name|vectorizable_assignment
argument_list|(
name|stmt
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|||
name|vectorizable_load
argument_list|(
name|stmt
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|||
name|vectorizable_store
argument_list|(
name|stmt
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|||
name|vectorizable_condition
argument_list|(
name|stmt
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
block|{
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_UNVECTORIZED_LOOPS
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"not vectorized: relevant stmt not supported: "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|vect_dump
argument_list|,
name|stmt
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
block|}
return|return
name|false
return|;
block|}
name|need_to_vectorize
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|STMT_VINFO_LIVE_P
argument_list|(
name|stmt_info
argument_list|)
condition|)
block|{
name|ok
operator|=
name|vectorizable_reduction
argument_list|(
name|stmt
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ok
condition|)
name|need_to_vectorize
operator|=
name|true
expr_stmt|;
else|else
name|ok
operator|=
name|vectorizable_live_operation
argument_list|(
name|stmt
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
block|{
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_UNVECTORIZED_LOOPS
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"not vectorized: live stmt not supported: "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|vect_dump
argument_list|,
name|stmt
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
block|}
return|return
name|false
return|;
block|}
block|}
block|}
comment|/* stmts in bb */
block|}
comment|/* bbs */
comment|/* TODO: Analyze cost. Decide if worth while to vectorize.  */
comment|/* All operations in the loop are either irrelevant (deal with loop      control, or dead), or only used outside the loop and can be moved      out of the loop (e.g. invariants, inductions).  The loop can be       optimized away by scalar optimizations.  We're better off not       touching this loop.  */
if|if
condition|(
operator|!
name|need_to_vectorize
condition|)
block|{
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"All the computation can be taken out of the loop."
argument_list|)
expr_stmt|;
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_UNVECTORIZED_LOOPS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"not vectorized: redundant loop. no profit to vectorize."
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|LOOP_VINFO_NITERS_KNOWN_P
argument_list|(
name|loop_vinfo
argument_list|)
operator|&&
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"vectorization_factor = %d, niters = "
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|vectorization_factor
argument_list|,
name|LOOP_VINFO_INT_NITERS
argument_list|(
name|loop_vinfo
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOOP_VINFO_NITERS_KNOWN_P
argument_list|(
name|loop_vinfo
argument_list|)
operator|&&
name|LOOP_VINFO_INT_NITERS
argument_list|(
name|loop_vinfo
argument_list|)
operator|<
name|vectorization_factor
condition|)
block|{
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_UNVECTORIZED_LOOPS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"not vectorized: iteration count too small."
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
name|LOOP_VINFO_NITERS_KNOWN_P
argument_list|(
name|loop_vinfo
argument_list|)
operator|||
name|LOOP_VINFO_INT_NITERS
argument_list|(
name|loop_vinfo
argument_list|)
operator|%
name|vectorization_factor
operator|!=
literal|0
operator|||
name|LOOP_PEELING_FOR_ALIGNMENT
argument_list|(
name|loop_vinfo
argument_list|)
condition|)
block|{
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"epilog loop required."
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vect_can_advance_ivs_p
argument_list|(
name|loop_vinfo
argument_list|)
condition|)
block|{
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_UNVECTORIZED_LOOPS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"not vectorized: can't create epilog loop 1."
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
name|slpeel_can_duplicate_loop_p
argument_list|(
name|loop
argument_list|,
name|loop
operator|->
name|single_exit
argument_list|)
condition|)
block|{
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_UNVECTORIZED_LOOPS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"not vectorized: can't create epilog loop 2."
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Function exist_non_indexing_operands_for_use_p      USE is one of the uses attached to STMT. Check if USE is     used in STMT for anything other than indexing an array.  */
end_comment

begin_function
specifier|static
name|bool
name|exist_non_indexing_operands_for_use_p
parameter_list|(
name|tree
name|use
parameter_list|,
name|tree
name|stmt
parameter_list|)
block|{
name|tree
name|operand
decl_stmt|;
name|stmt_vec_info
name|stmt_info
init|=
name|vinfo_for_stmt
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
comment|/* USE corresponds to some operand in STMT. If there is no data      reference in STMT, then any operand that corresponds to USE      is not indexing an array.  */
if|if
condition|(
operator|!
name|STMT_VINFO_DATA_REF
argument_list|(
name|stmt_info
argument_list|)
condition|)
return|return
name|true
return|;
comment|/* STMT has a data_ref. FORNOW this means that its of one of      the following forms:      -1- ARRAY_REF = var      -2- var = ARRAY_REF      (This should have been verified in analyze_data_refs).       'var' in the second case corresponds to a def, not a use,      so USE cannot correspond to any operands that are not used       for array indexing.       Therefore, all we need to check is if STMT falls into the      first case, and whether var corresponds to USE.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SSA_NAME
condition|)
return|return
name|false
return|;
name|operand
operator|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|operand
argument_list|)
operator|!=
name|SSA_NAME
condition|)
return|return
name|false
return|;
if|if
condition|(
name|operand
operator|==
name|use
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Function vect_analyze_scalar_cycles.     Examine the cross iteration def-use cycles of scalar variables, by    analyzing the loop (scalar) PHIs; Classify each cycle as one of the    following: invariant, induction, reduction, unknown.        Some forms of scalar cycles are not yet supported.     Example1: reduction: (unsupported yet)                loop1:               for (i=0; i<N; i++)                  sum += a[i];     Example2: induction: (unsupported yet)                loop2:               for (i=0; i<N; i++)                  a[i] = i;     Note: the following loop *is* vectorizable:                loop3:               for (i=0; i<N; i++)                  a[i] = b[i];           even though it has a def-use cycle caused by the induction variable i:                loop: i_2 = PHI (i_0, i_1)                     a[i_2] = ...;                     i_1 = i_2 + 1;                     GOTO loop;           because the def-use cycle in loop3 is considered "not relevant" - i.e.,          it does not need to be vectorized because it is only used for array          indexing (see 'mark_stmts_to_be_vectorized'). The def-use cycle in          loop2 on the other hand is relevant (it is being written to memory). */
end_comment

begin_function
specifier|static
name|void
name|vect_analyze_scalar_cycles
parameter_list|(
name|loop_vec_info
name|loop_vinfo
parameter_list|)
block|{
name|tree
name|phi
decl_stmt|;
name|struct
name|loop
modifier|*
name|loop
init|=
name|LOOP_VINFO_LOOP
argument_list|(
name|loop_vinfo
argument_list|)
decl_stmt|;
name|basic_block
name|bb
init|=
name|loop
operator|->
name|header
decl_stmt|;
name|tree
name|dummy
decl_stmt|;
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"=== vect_analyze_scalar_cycles ==="
argument_list|)
expr_stmt|;
for|for
control|(
name|phi
operator|=
name|phi_nodes
argument_list|(
name|bb
argument_list|)
init|;
name|phi
condition|;
name|phi
operator|=
name|PHI_CHAIN
argument_list|(
name|phi
argument_list|)
control|)
block|{
name|tree
name|access_fn
init|=
name|NULL
decl_stmt|;
name|tree
name|def
init|=
name|PHI_RESULT
argument_list|(
name|phi
argument_list|)
decl_stmt|;
name|stmt_vec_info
name|stmt_vinfo
init|=
name|vinfo_for_stmt
argument_list|(
name|phi
argument_list|)
decl_stmt|;
name|tree
name|reduc_stmt
decl_stmt|;
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"Analyze phi: "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|vect_dump
argument_list|,
name|phi
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
block|}
comment|/* Skip virtual phi's. The data dependences that are associated with          virtual defs/uses (i.e., memory accesses) are analyzed elsewhere.  */
if|if
condition|(
operator|!
name|is_gimple_reg
argument_list|(
name|SSA_NAME_VAR
argument_list|(
name|def
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"virtual phi. skip."
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|STMT_VINFO_DEF_TYPE
argument_list|(
name|stmt_vinfo
argument_list|)
operator|=
name|vect_unknown_def_type
expr_stmt|;
comment|/* Analyze the evolution function.  */
name|access_fn
operator|=
name|analyze_scalar_evolution
argument_list|(
name|loop
argument_list|,
name|def
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|access_fn
condition|)
continue|continue;
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"Access function of PHI: "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|vect_dump
argument_list|,
name|access_fn
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vect_is_simple_iv_evolution
argument_list|(
name|loop
operator|->
name|num
argument_list|,
name|access_fn
argument_list|,
operator|&
name|dummy
argument_list|,
operator|&
name|dummy
argument_list|)
condition|)
block|{
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"Detected induction."
argument_list|)
expr_stmt|;
name|STMT_VINFO_DEF_TYPE
argument_list|(
name|stmt_vinfo
argument_list|)
operator|=
name|vect_induction_def
expr_stmt|;
continue|continue;
block|}
comment|/* TODO: handle invariant phis  */
name|reduc_stmt
operator|=
name|vect_is_simple_reduction
argument_list|(
name|loop
argument_list|,
name|phi
argument_list|)
expr_stmt|;
if|if
condition|(
name|reduc_stmt
condition|)
block|{
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"Detected reduction."
argument_list|)
expr_stmt|;
name|STMT_VINFO_DEF_TYPE
argument_list|(
name|stmt_vinfo
argument_list|)
operator|=
name|vect_reduction_def
expr_stmt|;
name|STMT_VINFO_DEF_TYPE
argument_list|(
name|vinfo_for_stmt
argument_list|(
name|reduc_stmt
argument_list|)
argument_list|)
operator|=
name|vect_reduction_def
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"Unknown def-use cycle pattern."
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* Function vect_analyze_data_ref_dependence.     Return TRUE if there (might) exist a dependence between a memory-reference    DRA and a memory-reference DRB.  */
end_comment

begin_function
specifier|static
name|bool
name|vect_analyze_data_ref_dependence
parameter_list|(
name|struct
name|data_dependence_relation
modifier|*
name|ddr
parameter_list|,
name|loop_vec_info
name|loop_vinfo
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|struct
name|loop
modifier|*
name|loop
init|=
name|LOOP_VINFO_LOOP
argument_list|(
name|loop_vinfo
argument_list|)
decl_stmt|;
name|int
name|vectorization_factor
init|=
name|LOOP_VINFO_VECT_FACTOR
argument_list|(
name|loop_vinfo
argument_list|)
decl_stmt|;
name|struct
name|data_reference
modifier|*
name|dra
init|=
name|DDR_A
argument_list|(
name|ddr
argument_list|)
decl_stmt|;
name|struct
name|data_reference
modifier|*
name|drb
init|=
name|DDR_B
argument_list|(
name|ddr
argument_list|)
decl_stmt|;
name|stmt_vec_info
name|stmtinfo_a
init|=
name|vinfo_for_stmt
argument_list|(
name|DR_STMT
argument_list|(
name|dra
argument_list|)
argument_list|)
decl_stmt|;
name|stmt_vec_info
name|stmtinfo_b
init|=
name|vinfo_for_stmt
argument_list|(
name|DR_STMT
argument_list|(
name|drb
argument_list|)
argument_list|)
decl_stmt|;
name|lambda_vector
name|dist_v
decl_stmt|;
name|unsigned
name|int
name|loop_depth
decl_stmt|;
if|if
condition|(
name|DDR_ARE_DEPENDENT
argument_list|(
name|ddr
argument_list|)
operator|==
name|chrec_known
condition|)
return|return
name|false
return|;
if|if
condition|(
name|DDR_ARE_DEPENDENT
argument_list|(
name|ddr
argument_list|)
operator|==
name|chrec_dont_know
condition|)
block|{
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_UNVECTORIZED_LOOPS
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"not vectorized: can't determine dependence between "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|vect_dump
argument_list|,
name|DR_REF
argument_list|(
name|dra
argument_list|)
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|" and "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|vect_dump
argument_list|,
name|DR_REF
argument_list|(
name|drb
argument_list|)
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
if|if
condition|(
name|DDR_NUM_DIST_VECTS
argument_list|(
name|ddr
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_UNVECTORIZED_LOOPS
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"not vectorized: bad dist vector for "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|vect_dump
argument_list|,
name|DR_REF
argument_list|(
name|dra
argument_list|)
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|" and "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|vect_dump
argument_list|,
name|DR_REF
argument_list|(
name|drb
argument_list|)
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
name|loop_depth
operator|=
name|index_in_loop_nest
argument_list|(
name|loop
operator|->
name|num
argument_list|,
name|DDR_LOOP_NEST
argument_list|(
name|ddr
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|lambda_vector
argument_list|,
name|DDR_DIST_VECTS
argument_list|(
name|ddr
argument_list|)
argument_list|,
name|i
argument_list|,
name|dist_v
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|int
name|dist
init|=
name|dist_v
index|[
name|loop_depth
index|]
decl_stmt|;
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DR_DETAILS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"dependence distance  = %d."
argument_list|,
name|dist
argument_list|)
expr_stmt|;
comment|/* Same loop iteration.  */
if|if
condition|(
name|dist
operator|%
name|vectorization_factor
operator|==
literal|0
condition|)
block|{
comment|/* Two references with distance zero have the same alignment.  */
name|VEC_safe_push
argument_list|(
name|dr_p
argument_list|,
name|heap
argument_list|,
name|STMT_VINFO_SAME_ALIGN_REFS
argument_list|(
name|stmtinfo_a
argument_list|)
argument_list|,
name|drb
argument_list|)
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|dr_p
argument_list|,
name|heap
argument_list|,
name|STMT_VINFO_SAME_ALIGN_REFS
argument_list|(
name|stmtinfo_b
argument_list|)
argument_list|,
name|dra
argument_list|)
expr_stmt|;
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_ALIGNMENT
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"accesses have the same alignment."
argument_list|)
expr_stmt|;
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DR_DETAILS
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"dependence distance modulo vf == 0 between "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|vect_dump
argument_list|,
name|DR_REF
argument_list|(
name|dra
argument_list|)
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|" and "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|vect_dump
argument_list|,
name|DR_REF
argument_list|(
name|drb
argument_list|)
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
name|abs
argument_list|(
name|dist
argument_list|)
operator|>=
name|vectorization_factor
condition|)
block|{
comment|/* Dependence distance does not create dependence, as far as vectorization 	     is concerned, in this case.  */
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DR_DETAILS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"dependence distance>= VF."
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_UNVECTORIZED_LOOPS
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"not vectorized: possible dependence between data-refs "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|vect_dump
argument_list|,
name|DR_REF
argument_list|(
name|dra
argument_list|)
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|" and "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|vect_dump
argument_list|,
name|DR_REF
argument_list|(
name|drb
argument_list|)
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Function vect_analyze_data_ref_dependences.               Examine all the data references in the loop, and make sure there do not    exist any data dependences between them.  */
end_comment

begin_function
specifier|static
name|bool
name|vect_analyze_data_ref_dependences
parameter_list|(
name|loop_vec_info
name|loop_vinfo
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|VEC
argument_list|(
name|ddr_p
argument_list|,
name|heap
argument_list|)
operator|*
name|ddrs
operator|=
name|LOOP_VINFO_DDRS
argument_list|(
name|loop_vinfo
argument_list|)
expr_stmt|;
name|struct
name|data_dependence_relation
modifier|*
name|ddr
decl_stmt|;
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"=== vect_analyze_dependences ==="
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|ddr_p
argument_list|,
name|ddrs
argument_list|,
name|i
argument_list|,
name|ddr
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|vect_analyze_data_ref_dependence
argument_list|(
name|ddr
argument_list|,
name|loop_vinfo
argument_list|)
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Function vect_compute_data_ref_alignment     Compute the misalignment of the data reference DR.     Output:    1. If during the misalignment computation it is found that the data reference       cannot be vectorized then false is returned.    2. DR_MISALIGNMENT (DR) is defined.     FOR NOW: No analysis is actually performed. Misalignment is calculated    only for trivial cases. TODO.  */
end_comment

begin_function
specifier|static
name|bool
name|vect_compute_data_ref_alignment
parameter_list|(
name|struct
name|data_reference
modifier|*
name|dr
parameter_list|)
block|{
name|tree
name|stmt
init|=
name|DR_STMT
argument_list|(
name|dr
argument_list|)
decl_stmt|;
name|stmt_vec_info
name|stmt_info
init|=
name|vinfo_for_stmt
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
name|tree
name|ref
init|=
name|DR_REF
argument_list|(
name|dr
argument_list|)
decl_stmt|;
name|tree
name|vectype
decl_stmt|;
name|tree
name|base
decl_stmt|,
name|base_addr
decl_stmt|;
name|bool
name|base_aligned
decl_stmt|;
name|tree
name|misalign
decl_stmt|;
name|tree
name|aligned_to
decl_stmt|,
name|alignment
decl_stmt|;
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"vect_compute_data_ref_alignment:"
argument_list|)
expr_stmt|;
comment|/* Initialize misalignment to unknown.  */
name|DR_MISALIGNMENT
argument_list|(
name|dr
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
name|misalign
operator|=
name|DR_OFFSET_MISALIGNMENT
argument_list|(
name|dr
argument_list|)
expr_stmt|;
name|aligned_to
operator|=
name|DR_ALIGNED_TO
argument_list|(
name|dr
argument_list|)
expr_stmt|;
name|base_addr
operator|=
name|DR_BASE_ADDRESS
argument_list|(
name|dr
argument_list|)
expr_stmt|;
name|base
operator|=
name|build_fold_indirect_ref
argument_list|(
name|base_addr
argument_list|)
expr_stmt|;
name|vectype
operator|=
name|STMT_VINFO_VECTYPE
argument_list|(
name|stmt_info
argument_list|)
expr_stmt|;
name|alignment
operator|=
name|ssize_int
argument_list|(
name|TYPE_ALIGN
argument_list|(
name|vectype
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|aligned_to
operator|&&
name|tree_int_cst_compare
argument_list|(
name|aligned_to
argument_list|,
name|alignment
argument_list|)
operator|<
literal|0
operator|)
operator|||
operator|!
name|misalign
condition|)
block|{
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"Unknown alignment for access: "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|vect_dump
argument_list|,
name|base
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
if|if
condition|(
operator|(
name|DECL_P
argument_list|(
name|base
argument_list|)
operator|&&
name|tree_int_cst_compare
argument_list|(
name|ssize_int
argument_list|(
name|DECL_ALIGN_UNIT
argument_list|(
name|base
argument_list|)
argument_list|)
argument_list|,
name|alignment
argument_list|)
operator|>=
literal|0
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|base_addr
argument_list|)
operator|==
name|SSA_NAME
operator|&&
name|tree_int_cst_compare
argument_list|(
name|ssize_int
argument_list|(
name|TYPE_ALIGN_UNIT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|base_addr
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|alignment
argument_list|)
operator|>=
literal|0
operator|)
condition|)
name|base_aligned
operator|=
name|true
expr_stmt|;
else|else
name|base_aligned
operator|=
name|false
expr_stmt|;
if|if
condition|(
operator|!
name|base_aligned
condition|)
block|{
comment|/* Do not change the alignment of global variables if  	 flag_section_anchors is enabled.  */
if|if
condition|(
operator|!
name|vect_can_force_dr_alignment_p
argument_list|(
name|base
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|vectype
argument_list|)
argument_list|)
operator|||
operator|(
name|TREE_STATIC
argument_list|(
name|base
argument_list|)
operator|&&
name|flag_section_anchors
operator|)
condition|)
block|{
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"can't force alignment of ref: "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|vect_dump
argument_list|,
name|ref
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
comment|/* Force the alignment of the decl. 	 NOTE: This is the only change to the code we make during 	 the analysis phase, before deciding to vectorize the loop.  */
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"force alignment"
argument_list|)
expr_stmt|;
name|DECL_ALIGN
argument_list|(
name|base
argument_list|)
operator|=
name|TYPE_ALIGN
argument_list|(
name|vectype
argument_list|)
expr_stmt|;
name|DECL_USER_ALIGN
argument_list|(
name|base
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* At this point we assume that the base is aligned.  */
name|gcc_assert
argument_list|(
name|base_aligned
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_ALIGN
argument_list|(
name|base
argument_list|)
operator|>=
name|TYPE_ALIGN
argument_list|(
name|vectype
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* Modulo alignment.  */
name|misalign
operator|=
name|size_binop
argument_list|(
name|TRUNC_MOD_EXPR
argument_list|,
name|misalign
argument_list|,
name|alignment
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|host_integerp
argument_list|(
name|misalign
argument_list|,
literal|1
argument_list|)
condition|)
block|{
comment|/* Negative or overflowed misalignment value.  */
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"unexpected misalign value"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|DR_MISALIGNMENT
argument_list|(
name|dr
argument_list|)
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|misalign
argument_list|)
expr_stmt|;
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"misalign = %d bytes of ref "
argument_list|,
name|DR_MISALIGNMENT
argument_list|(
name|dr
argument_list|)
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|vect_dump
argument_list|,
name|ref
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Function vect_compute_data_refs_alignment     Compute the misalignment of data references in the loop.    Return FALSE if a data reference is found that cannot be vectorized.  */
end_comment

begin_function
specifier|static
name|bool
name|vect_compute_data_refs_alignment
parameter_list|(
name|loop_vec_info
name|loop_vinfo
parameter_list|)
block|{
name|VEC
argument_list|(
name|data_reference_p
argument_list|,
name|heap
argument_list|)
operator|*
name|datarefs
operator|=
name|LOOP_VINFO_DATAREFS
argument_list|(
name|loop_vinfo
argument_list|)
expr_stmt|;
name|struct
name|data_reference
modifier|*
name|dr
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|data_reference_p
argument_list|,
name|datarefs
argument_list|,
name|i
argument_list|,
name|dr
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|vect_compute_data_ref_alignment
argument_list|(
name|dr
argument_list|)
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Function vect_update_misalignment_for_peel     DR - the data reference whose misalignment is to be adjusted.    DR_PEEL - the data reference whose misalignment is being made              zero in the vector loop by the peel.    NPEEL - the number of iterations in the peel loop if the misalignment            of DR_PEEL is known at compile time.  */
end_comment

begin_function
specifier|static
name|void
name|vect_update_misalignment_for_peel
parameter_list|(
name|struct
name|data_reference
modifier|*
name|dr
parameter_list|,
name|struct
name|data_reference
modifier|*
name|dr_peel
parameter_list|,
name|int
name|npeel
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|int
name|drsize
decl_stmt|;
name|VEC
argument_list|(
name|dr_p
argument_list|,
name|heap
argument_list|)
operator|*
name|same_align_drs
expr_stmt|;
name|struct
name|data_reference
modifier|*
name|current_dr
decl_stmt|;
if|if
condition|(
name|known_alignment_for_access_p
argument_list|(
name|dr
argument_list|)
operator|&&
name|DR_MISALIGNMENT
argument_list|(
name|dr
argument_list|)
operator|==
name|DR_MISALIGNMENT
argument_list|(
name|dr_peel
argument_list|)
condition|)
block|{
name|DR_MISALIGNMENT
argument_list|(
name|dr
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return;
block|}
comment|/* It can be assumed that the data refs with the same alignment as dr_peel      are aligned in the vector loop.  */
name|same_align_drs
operator|=
name|STMT_VINFO_SAME_ALIGN_REFS
argument_list|(
name|vinfo_for_stmt
argument_list|(
name|DR_STMT
argument_list|(
name|dr_peel
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|dr_p
argument_list|,
name|same_align_drs
argument_list|,
name|i
argument_list|,
name|current_dr
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|current_dr
operator|!=
name|dr
condition|)
continue|continue;
name|gcc_assert
argument_list|(
name|DR_MISALIGNMENT
argument_list|(
name|dr
argument_list|)
operator|==
name|DR_MISALIGNMENT
argument_list|(
name|dr_peel
argument_list|)
argument_list|)
expr_stmt|;
name|DR_MISALIGNMENT
argument_list|(
name|dr
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|known_alignment_for_access_p
argument_list|(
name|dr
argument_list|)
operator|&&
name|known_alignment_for_access_p
argument_list|(
name|dr_peel
argument_list|)
condition|)
block|{
name|drsize
operator|=
name|GET_MODE_SIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|DR_REF
argument_list|(
name|dr
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|DR_MISALIGNMENT
argument_list|(
name|dr
argument_list|)
operator|+=
name|npeel
operator|*
name|drsize
expr_stmt|;
name|DR_MISALIGNMENT
argument_list|(
name|dr
argument_list|)
operator|%=
name|UNITS_PER_SIMD_WORD
expr_stmt|;
return|return;
block|}
name|DR_MISALIGNMENT
argument_list|(
name|dr
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Function vect_verify_datarefs_alignment     Return TRUE if all data references in the loop can be    handled with respect to alignment.  */
end_comment

begin_function
specifier|static
name|bool
name|vect_verify_datarefs_alignment
parameter_list|(
name|loop_vec_info
name|loop_vinfo
parameter_list|)
block|{
name|VEC
argument_list|(
name|data_reference_p
argument_list|,
name|heap
argument_list|)
operator|*
name|datarefs
operator|=
name|LOOP_VINFO_DATAREFS
argument_list|(
name|loop_vinfo
argument_list|)
expr_stmt|;
name|struct
name|data_reference
modifier|*
name|dr
decl_stmt|;
name|enum
name|dr_alignment_support
name|supportable_dr_alignment
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|data_reference_p
argument_list|,
name|datarefs
argument_list|,
name|i
argument_list|,
name|dr
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|supportable_dr_alignment
operator|=
name|vect_supportable_dr_alignment
argument_list|(
name|dr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|supportable_dr_alignment
condition|)
block|{
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_UNVECTORIZED_LOOPS
argument_list|)
condition|)
block|{
if|if
condition|(
name|DR_IS_READ
argument_list|(
name|dr
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"not vectorized: unsupported unaligned load."
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"not vectorized: unsupported unaligned store."
argument_list|)
expr_stmt|;
block|}
return|return
name|false
return|;
block|}
if|if
condition|(
name|supportable_dr_alignment
operator|!=
name|dr_aligned
operator|&&
name|vect_print_dump_info
argument_list|(
name|REPORT_ALIGNMENT
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"Vectorizing an unaligned access."
argument_list|)
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Function vector_alignment_reachable_p     Return true if vector alignment for DR is reachable by peeling    a few loop iterations.  Return false otherwise.  */
end_comment

begin_function
specifier|static
name|bool
name|vector_alignment_reachable_p
parameter_list|(
name|struct
name|data_reference
modifier|*
name|dr
parameter_list|)
block|{
name|tree
name|stmt
init|=
name|DR_STMT
argument_list|(
name|dr
argument_list|)
decl_stmt|;
name|stmt_vec_info
name|stmt_info
init|=
name|vinfo_for_stmt
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
name|tree
name|vectype
init|=
name|STMT_VINFO_VECTYPE
argument_list|(
name|stmt_info
argument_list|)
decl_stmt|;
comment|/* If misalignment is known at the compile time then allow peeling      only if natural alignment is reachable through peeling.  */
if|if
condition|(
name|known_alignment_for_access_p
argument_list|(
name|dr
argument_list|)
operator|&&
operator|!
name|aligned_access_p
argument_list|(
name|dr
argument_list|)
condition|)
block|{
name|HOST_WIDE_INT
name|elmsize
init|=
name|int_cst_value
argument_list|(
name|TYPE_SIZE_UNIT
argument_list|(
name|TREE_TYPE
argument_list|(
name|vectype
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"data size ="
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|elmsize
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|". misalignment = %d. "
argument_list|,
name|DR_MISALIGNMENT
argument_list|(
name|dr
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DR_MISALIGNMENT
argument_list|(
name|dr
argument_list|)
operator|%
name|elmsize
condition|)
block|{
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"data size does not divide the misalignment.\n"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
if|if
condition|(
operator|!
name|known_alignment_for_access_p
argument_list|(
name|dr
argument_list|)
condition|)
block|{
name|tree
name|type
init|=
operator|(
name|TREE_TYPE
argument_list|(
name|DR_REF
argument_list|(
name|dr
argument_list|)
argument_list|)
operator|)
decl_stmt|;
name|tree
name|ba
init|=
name|DR_BASE_OBJECT
argument_list|(
name|dr
argument_list|)
decl_stmt|;
name|bool
name|is_packed
init|=
name|false
decl_stmt|;
if|if
condition|(
name|ba
condition|)
name|is_packed
operator|=
name|contains_packed_reference
argument_list|(
name|ba
argument_list|)
expr_stmt|;
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"Unknown misalignment, is_packed = %d"
argument_list|,
name|is_packed
argument_list|)
expr_stmt|;
if|if
condition|(
name|targetm
operator|.
name|vectorize
operator|.
name|vector_alignment_reachable
argument_list|(
name|type
argument_list|,
name|is_packed
argument_list|)
condition|)
return|return
name|true
return|;
else|else
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Function vect_enhance_data_refs_alignment     This pass will use loop versioning and loop peeling in order to enhance    the alignment of data references in the loop.     FOR NOW: we assume that whatever versioning/peeling takes place, only the    original loop is to be vectorized; Any other loops that are created by    the transformations performed in this pass - are not supposed to be    vectorized. This restriction will be relaxed.     This pass will require a cost model to guide it whether to apply peeling    or versioning or a combination of the two. For example, the scheme that    intel uses when given a loop with several memory accesses, is as follows:    choose one memory access ('p') which alignment you want to force by doing    peeling. Then, either (1) generate a loop in which 'p' is aligned and all    other accesses are not necessarily aligned, or (2) use loop versioning to    generate one loop in which all accesses are aligned, and another loop in    which only 'p' is necessarily aligned.     ("Automatic Intra-Register Vectorization for the Intel Architecture",    Aart J.C. Bik, Milind Girkar, Paul M. Grey and Ximmin Tian, International    Journal of Parallel Programming, Vol. 30, No. 2, April 2002.)     Devising a cost model is the most critical aspect of this work. It will    guide us on which access to peel for, whether to use loop versioning, how    many versions to create, etc. The cost model will probably consist of    generic considerations as well as target specific considerations (on    powerpc for example, misaligned stores are more painful than misaligned    loads).     Here are the general steps involved in alignment enhancements:       -- original loop, before alignment analysis: 	for (i=0; i<N; i++){ 	  x = q[i];			# DR_MISALIGNMENT(q) = unknown 	  p[i] = y;			# DR_MISALIGNMENT(p) = unknown 	}       -- After vect_compute_data_refs_alignment: 	for (i=0; i<N; i++){ 	  x = q[i];			# DR_MISALIGNMENT(q) = 3 	  p[i] = y;			# DR_MISALIGNMENT(p) = unknown 	}       -- Possibility 1: we do loop versioning:      if (p is aligned) { 	for (i=0; i<N; i++){	# loop 1A 	  x = q[i];			# DR_MISALIGNMENT(q) = 3 	  p[i] = y;			# DR_MISALIGNMENT(p) = 0 	}      }      else { 	for (i=0; i<N; i++){	# loop 1B 	  x = q[i];			# DR_MISALIGNMENT(q) = 3 	  p[i] = y;			# DR_MISALIGNMENT(p) = unaligned 	}      }       -- Possibility 2: we do loop peeling:      for (i = 0; i< 3; i++){	# (scalar loop, not to be vectorized). 	x = q[i]; 	p[i] = y;      }      for (i = 3; i< N; i++){	# loop 2A 	x = q[i];			# DR_MISALIGNMENT(q) = 0 	p[i] = y;			# DR_MISALIGNMENT(p) = unknown      }       -- Possibility 3: combination of loop peeling and versioning:      for (i = 0; i< 3; i++){	# (scalar loop, not to be vectorized). 	x = q[i]; 	p[i] = y;      }      if (p is aligned) { 	for (i = 3; i<N; i++){	# loop 3A 	  x = q[i];			# DR_MISALIGNMENT(q) = 0 	  p[i] = y;			# DR_MISALIGNMENT(p) = 0 	}      }      else { 	for (i = 3; i<N; i++){	# loop 3B 	  x = q[i];			# DR_MISALIGNMENT(q) = 0 	  p[i] = y;			# DR_MISALIGNMENT(p) = unaligned 	}      }       These loops are later passed to loop_transform to be vectorized. The      vectorizer will use the alignment information to guide the transformation      (whether to generate regular loads/stores, or with special handling for      misalignment).  */
end_comment

begin_function
specifier|static
name|bool
name|vect_enhance_data_refs_alignment
parameter_list|(
name|loop_vec_info
name|loop_vinfo
parameter_list|)
block|{
name|VEC
argument_list|(
name|data_reference_p
argument_list|,
name|heap
argument_list|)
operator|*
name|datarefs
operator|=
name|LOOP_VINFO_DATAREFS
argument_list|(
name|loop_vinfo
argument_list|)
expr_stmt|;
name|enum
name|dr_alignment_support
name|supportable_dr_alignment
decl_stmt|;
name|struct
name|data_reference
modifier|*
name|dr0
init|=
name|NULL
decl_stmt|;
name|struct
name|data_reference
modifier|*
name|dr
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|bool
name|do_peeling
init|=
name|false
decl_stmt|;
name|bool
name|do_versioning
init|=
name|false
decl_stmt|;
name|bool
name|stat
decl_stmt|;
comment|/* While cost model enhancements are expected in the future, the high level      view of the code at this time is as follows:       A) If there is a misaligned write then see if peeling to align this write         can make all data references satisfy vect_supportable_dr_alignment.         If so, update data structures as needed and return true.  Note that         at this time vect_supportable_dr_alignment is known to return false         for a a misaligned write.       B) If peeling wasn't possible and there is a data reference with an         unknown misalignment that does not satisfy vect_supportable_dr_alignment         then see if loop versioning checks can be used to make all data         references satisfy vect_supportable_dr_alignment.  If so, update         data structures as needed and return true.       C) If neither peeling nor versioning were successful then return false if         any data reference does not satisfy vect_supportable_dr_alignment.       D) Return true (all data references satisfy vect_supportable_dr_alignment).       Note, Possibility 3 above (which is peeling and versioning together) is not      being done at this time.  */
comment|/* (1) Peeling to force alignment.  */
comment|/* (1.1) Decide whether to perform peeling, and how many iterations to peel:      Considerations:      + How many accesses will become aligned due to the peeling      - How many accesses will become unaligned due to the peeling,        and the cost of misaligned accesses.      - The cost of peeling (the extra runtime checks, the increase         in code size).       The scheme we use FORNOW: peel to force the alignment of the first      misaligned store in the loop.      Rationale: misaligned stores are not yet supported.       TODO: Use a cost model.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|data_reference_p
argument_list|,
name|datarefs
argument_list|,
name|i
argument_list|,
name|dr
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|DR_IS_READ
argument_list|(
name|dr
argument_list|)
operator|&&
operator|!
name|aligned_access_p
argument_list|(
name|dr
argument_list|)
condition|)
block|{
name|do_peeling
operator|=
name|vector_alignment_reachable_p
argument_list|(
name|dr
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_peeling
condition|)
name|dr0
operator|=
name|dr
expr_stmt|;
if|if
condition|(
operator|!
name|do_peeling
operator|&&
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"vector alignment may not be reachable"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Often peeling for alignment will require peeling for loop-bound, which in       turn requires that we know how to adjust the loop ivs after the loop.  */
if|if
condition|(
operator|!
name|vect_can_advance_ivs_p
argument_list|(
name|loop_vinfo
argument_list|)
condition|)
name|do_peeling
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|do_peeling
condition|)
block|{
name|int
name|mis
decl_stmt|;
name|int
name|npeel
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|known_alignment_for_access_p
argument_list|(
name|dr0
argument_list|)
condition|)
block|{
comment|/* Since it's known at compile time, compute the number of iterations              in the peeled loop (the peeling factor) for use in updating              DR_MISALIGNMENT values.  The peeling factor is the vectorization              factor minus the misalignment as an element count.  */
name|mis
operator|=
name|DR_MISALIGNMENT
argument_list|(
name|dr0
argument_list|)
expr_stmt|;
name|mis
operator|/=
name|GET_MODE_SIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|DR_REF
argument_list|(
name|dr0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|npeel
operator|=
name|LOOP_VINFO_VECT_FACTOR
argument_list|(
name|loop_vinfo
argument_list|)
operator|-
name|mis
expr_stmt|;
block|}
comment|/* Ensure that all data refs can be vectorized after the peel.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|data_reference_p
argument_list|,
name|datarefs
argument_list|,
name|i
argument_list|,
name|dr
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|int
name|save_misalignment
decl_stmt|;
if|if
condition|(
name|dr
operator|==
name|dr0
condition|)
continue|continue;
name|save_misalignment
operator|=
name|DR_MISALIGNMENT
argument_list|(
name|dr
argument_list|)
expr_stmt|;
name|vect_update_misalignment_for_peel
argument_list|(
name|dr
argument_list|,
name|dr0
argument_list|,
name|npeel
argument_list|)
expr_stmt|;
name|supportable_dr_alignment
operator|=
name|vect_supportable_dr_alignment
argument_list|(
name|dr
argument_list|)
expr_stmt|;
name|DR_MISALIGNMENT
argument_list|(
name|dr
argument_list|)
operator|=
name|save_misalignment
expr_stmt|;
if|if
condition|(
operator|!
name|supportable_dr_alignment
condition|)
block|{
name|do_peeling
operator|=
name|false
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|do_peeling
condition|)
block|{
comment|/* (1.2) Update the DR_MISALIGNMENT of each data reference DR_i.              If the misalignment of DR_i is identical to that of dr0 then set              DR_MISALIGNMENT (DR_i) to zero.  If the misalignment of DR_i and              dr0 are known at compile time then increment DR_MISALIGNMENT (DR_i)              by the peeling factor times the element size of DR_i (MOD the              vectorization factor times the size).  Otherwise, the              misalignment of DR_i must be set to unknown.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|data_reference_p
argument_list|,
name|datarefs
argument_list|,
name|i
argument_list|,
name|dr
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|dr
operator|!=
name|dr0
condition|)
name|vect_update_misalignment_for_peel
argument_list|(
name|dr
argument_list|,
name|dr0
argument_list|,
name|npeel
argument_list|)
expr_stmt|;
name|LOOP_VINFO_UNALIGNED_DR
argument_list|(
name|loop_vinfo
argument_list|)
operator|=
name|dr0
expr_stmt|;
name|LOOP_PEELING_FOR_ALIGNMENT
argument_list|(
name|loop_vinfo
argument_list|)
operator|=
name|DR_MISALIGNMENT
argument_list|(
name|dr0
argument_list|)
expr_stmt|;
name|DR_MISALIGNMENT
argument_list|(
name|dr0
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_ALIGNMENT
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"Alignment of access forced using peeling."
argument_list|)
expr_stmt|;
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"Peeling for alignment will be applied."
argument_list|)
expr_stmt|;
name|stat
operator|=
name|vect_verify_datarefs_alignment
argument_list|(
name|loop_vinfo
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|stat
argument_list|)
expr_stmt|;
return|return
name|stat
return|;
block|}
block|}
comment|/* (2) Versioning to force alignment.  */
comment|/* Try versioning if:      1) flag_tree_vect_loop_version is TRUE      2) optimize_size is FALSE      3) there is at least one unsupported misaligned data ref with an unknown         misalignment, and      4) all misaligned data refs with a known misalignment are supported, and      5) the number of runtime alignment checks is within reason.  */
name|do_versioning
operator|=
name|flag_tree_vect_loop_version
operator|&&
operator|(
operator|!
name|optimize_size
operator|)
expr_stmt|;
if|if
condition|(
name|do_versioning
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|data_reference_p
argument_list|,
name|datarefs
argument_list|,
name|i
argument_list|,
name|dr
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|aligned_access_p
argument_list|(
name|dr
argument_list|)
condition|)
continue|continue;
name|supportable_dr_alignment
operator|=
name|vect_supportable_dr_alignment
argument_list|(
name|dr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|supportable_dr_alignment
condition|)
block|{
name|tree
name|stmt
decl_stmt|;
name|int
name|mask
decl_stmt|;
name|tree
name|vectype
decl_stmt|;
if|if
condition|(
name|known_alignment_for_access_p
argument_list|(
name|dr
argument_list|)
operator|||
name|VEC_length
argument_list|(
name|tree
argument_list|,
name|LOOP_VINFO_MAY_MISALIGN_STMTS
argument_list|(
name|loop_vinfo
argument_list|)
argument_list|)
operator|>=
operator|(
name|unsigned
operator|)
name|PARAM_VALUE
argument_list|(
name|PARAM_VECT_MAX_VERSION_CHECKS
argument_list|)
condition|)
block|{
name|do_versioning
operator|=
name|false
expr_stmt|;
break|break;
block|}
name|stmt
operator|=
name|DR_STMT
argument_list|(
name|dr
argument_list|)
expr_stmt|;
name|vectype
operator|=
name|STMT_VINFO_VECTYPE
argument_list|(
name|vinfo_for_stmt
argument_list|(
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|vectype
argument_list|)
expr_stmt|;
comment|/* The rightmost bits of an aligned address must be zeros.                  Construct the mask needed for this test.  For example,                  GET_MODE_SIZE for the vector mode V4SI is 16 bytes so the                  mask must be 15 = 0xf. */
name|mask
operator|=
name|GET_MODE_SIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|vectype
argument_list|)
argument_list|)
operator|-
literal|1
expr_stmt|;
comment|/* FORNOW: use the same mask to test all potentially unaligned                  references in the loop.  The vectorizer currently supports                  a single vector size, see the reference to                  GET_MODE_NUNITS (TYPE_MODE (vectype)) where the                  vectorization factor is computed.  */
name|gcc_assert
argument_list|(
operator|!
name|LOOP_VINFO_PTR_MASK
argument_list|(
name|loop_vinfo
argument_list|)
operator|||
name|LOOP_VINFO_PTR_MASK
argument_list|(
name|loop_vinfo
argument_list|)
operator|==
name|mask
argument_list|)
expr_stmt|;
name|LOOP_VINFO_PTR_MASK
argument_list|(
name|loop_vinfo
argument_list|)
operator|=
name|mask
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
name|LOOP_VINFO_MAY_MISALIGN_STMTS
argument_list|(
name|loop_vinfo
argument_list|)
argument_list|,
name|DR_STMT
argument_list|(
name|dr
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Versioning requires at least one misaligned data reference.  */
if|if
condition|(
name|VEC_length
argument_list|(
name|tree
argument_list|,
name|LOOP_VINFO_MAY_MISALIGN_STMTS
argument_list|(
name|loop_vinfo
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|do_versioning
operator|=
name|false
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|do_versioning
condition|)
name|VEC_truncate
argument_list|(
name|tree
argument_list|,
name|LOOP_VINFO_MAY_MISALIGN_STMTS
argument_list|(
name|loop_vinfo
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|do_versioning
condition|)
block|{
name|VEC
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|)
operator|*
name|may_misalign_stmts
operator|=
name|LOOP_VINFO_MAY_MISALIGN_STMTS
argument_list|(
name|loop_vinfo
argument_list|)
expr_stmt|;
name|tree
name|stmt
decl_stmt|;
comment|/* It can now be assumed that the data references in the statements          in LOOP_VINFO_MAY_MISALIGN_STMTS will be aligned in the version          of the loop being vectorized.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|tree
argument_list|,
name|may_misalign_stmts
argument_list|,
name|i
argument_list|,
name|stmt
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|stmt_vec_info
name|stmt_info
init|=
name|vinfo_for_stmt
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
name|dr
operator|=
name|STMT_VINFO_DATA_REF
argument_list|(
name|stmt_info
argument_list|)
expr_stmt|;
name|DR_MISALIGNMENT
argument_list|(
name|dr
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_ALIGNMENT
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"Alignment of access forced using versioning."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"Versioning for alignment will be applied."
argument_list|)
expr_stmt|;
comment|/* Peeling and versioning can't be done together at this time.  */
name|gcc_assert
argument_list|(
operator|!
operator|(
name|do_peeling
operator|&&
name|do_versioning
operator|)
argument_list|)
expr_stmt|;
name|stat
operator|=
name|vect_verify_datarefs_alignment
argument_list|(
name|loop_vinfo
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|stat
argument_list|)
expr_stmt|;
return|return
name|stat
return|;
block|}
comment|/* This point is reached if neither peeling nor versioning is being done.  */
name|gcc_assert
argument_list|(
operator|!
operator|(
name|do_peeling
operator|||
name|do_versioning
operator|)
argument_list|)
expr_stmt|;
name|stat
operator|=
name|vect_verify_datarefs_alignment
argument_list|(
name|loop_vinfo
argument_list|)
expr_stmt|;
return|return
name|stat
return|;
block|}
end_function

begin_comment
comment|/* Function vect_analyze_data_refs_alignment     Analyze the alignment of the data-references in the loop.    Return FALSE if a data reference is found that cannot be vectorized.  */
end_comment

begin_function
specifier|static
name|bool
name|vect_analyze_data_refs_alignment
parameter_list|(
name|loop_vec_info
name|loop_vinfo
parameter_list|)
block|{
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"=== vect_analyze_data_refs_alignment ==="
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vect_compute_data_refs_alignment
argument_list|(
name|loop_vinfo
argument_list|)
condition|)
block|{
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_UNVECTORIZED_LOOPS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"not vectorized: can't calculate alignment for data ref."
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Function vect_analyze_data_ref_access.     Analyze the access pattern of the data-reference DR. For now, a data access    has to be consecutive to be considered vectorizable.  */
end_comment

begin_function
specifier|static
name|bool
name|vect_analyze_data_ref_access
parameter_list|(
name|struct
name|data_reference
modifier|*
name|dr
parameter_list|)
block|{
name|tree
name|step
init|=
name|DR_STEP
argument_list|(
name|dr
argument_list|)
decl_stmt|;
name|tree
name|scalar_type
init|=
name|TREE_TYPE
argument_list|(
name|DR_REF
argument_list|(
name|dr
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|step
operator|||
name|tree_int_cst_compare
argument_list|(
name|step
argument_list|,
name|TYPE_SIZE_UNIT
argument_list|(
name|scalar_type
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"not consecutive access"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Function vect_analyze_data_ref_accesses.     Analyze the access pattern of all the data references in the loop.     FORNOW: the only access pattern that is considered vectorizable is a 	   simple step 1 (consecutive) access.     FORNOW: handle only arrays and pointer accesses.  */
end_comment

begin_function
specifier|static
name|bool
name|vect_analyze_data_ref_accesses
parameter_list|(
name|loop_vec_info
name|loop_vinfo
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|VEC
argument_list|(
name|data_reference_p
argument_list|,
name|heap
argument_list|)
operator|*
name|datarefs
operator|=
name|LOOP_VINFO_DATAREFS
argument_list|(
name|loop_vinfo
argument_list|)
expr_stmt|;
name|struct
name|data_reference
modifier|*
name|dr
decl_stmt|;
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"=== vect_analyze_data_ref_accesses ==="
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|data_reference_p
argument_list|,
name|datarefs
argument_list|,
name|i
argument_list|,
name|dr
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|vect_analyze_data_ref_access
argument_list|(
name|dr
argument_list|)
condition|)
block|{
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_UNVECTORIZED_LOOPS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"not vectorized: complicated access pattern."
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Function vect_analyze_data_refs.    Find all the data references in the loop.     The general structure of the analysis of data refs in the vectorizer is as    follows:    1- vect_analyze_data_refs(loop): call compute_data_dependences_for_loop to       find and analyze all data-refs in the loop and their dependences.    2- vect_analyze_dependences(): apply dependence testing using ddrs.    3- vect_analyze_drs_alignment(): check that ref_stmt.alignment is ok.    4- vect_analyze_drs_access(): check that ref_stmt.step is ok.  */
end_comment

begin_function
specifier|static
name|bool
name|vect_analyze_data_refs
parameter_list|(
name|loop_vec_info
name|loop_vinfo
parameter_list|)
block|{
name|struct
name|loop
modifier|*
name|loop
init|=
name|LOOP_VINFO_LOOP
argument_list|(
name|loop_vinfo
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|VEC
argument_list|(
name|data_reference_p
argument_list|,
name|heap
argument_list|)
operator|*
name|datarefs
expr_stmt|;
name|struct
name|data_reference
modifier|*
name|dr
decl_stmt|;
name|tree
name|scalar_type
decl_stmt|;
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"=== vect_analyze_data_refs ==="
argument_list|)
expr_stmt|;
name|compute_data_dependences_for_loop
argument_list|(
name|loop
argument_list|,
name|false
argument_list|,
operator|&
name|LOOP_VINFO_DATAREFS
argument_list|(
name|loop_vinfo
argument_list|)
argument_list|,
operator|&
name|LOOP_VINFO_DDRS
argument_list|(
name|loop_vinfo
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Go through the data-refs, check that the analysis succeeded. Update pointer      from stmt_vec_info struct to DR and vectype.  */
name|datarefs
operator|=
name|LOOP_VINFO_DATAREFS
argument_list|(
name|loop_vinfo
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|data_reference_p
argument_list|,
name|datarefs
argument_list|,
name|i
argument_list|,
name|dr
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|stmt
decl_stmt|;
name|stmt_vec_info
name|stmt_info
decl_stmt|;
if|if
condition|(
operator|!
name|dr
operator|||
operator|!
name|DR_REF
argument_list|(
name|dr
argument_list|)
condition|)
block|{
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_UNVECTORIZED_LOOPS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"not vectorized: unhandled data-ref "
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* Update DR field in stmt_vec_info struct.  */
name|stmt
operator|=
name|DR_STMT
argument_list|(
name|dr
argument_list|)
expr_stmt|;
name|stmt_info
operator|=
name|vinfo_for_stmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|STMT_VINFO_DATA_REF
argument_list|(
name|stmt_info
argument_list|)
condition|)
block|{
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_UNVECTORIZED_LOOPS
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"not vectorized: more than one data ref in stmt: "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|vect_dump
argument_list|,
name|stmt
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
block|}
return|return
name|false
return|;
block|}
name|STMT_VINFO_DATA_REF
argument_list|(
name|stmt_info
argument_list|)
operator|=
name|dr
expr_stmt|;
comment|/* Check that analysis of the data-ref succeeded.  */
if|if
condition|(
operator|!
name|DR_BASE_ADDRESS
argument_list|(
name|dr
argument_list|)
operator|||
operator|!
name|DR_OFFSET
argument_list|(
name|dr
argument_list|)
operator|||
operator|!
name|DR_INIT
argument_list|(
name|dr
argument_list|)
operator|||
operator|!
name|DR_STEP
argument_list|(
name|dr
argument_list|)
condition|)
block|{
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_UNVECTORIZED_LOOPS
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"not vectorized: data ref analysis failed "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|vect_dump
argument_list|,
name|stmt
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
block|}
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
name|DR_MEMTAG
argument_list|(
name|dr
argument_list|)
condition|)
block|{
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_UNVECTORIZED_LOOPS
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"not vectorized: no memory tag for "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|vect_dump
argument_list|,
name|DR_REF
argument_list|(
name|dr
argument_list|)
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
block|}
return|return
name|false
return|;
block|}
comment|/* Set vectype for STMT.  */
name|scalar_type
operator|=
name|TREE_TYPE
argument_list|(
name|DR_REF
argument_list|(
name|dr
argument_list|)
argument_list|)
expr_stmt|;
name|STMT_VINFO_VECTYPE
argument_list|(
name|stmt_info
argument_list|)
operator|=
name|get_vectype_for_scalar_type
argument_list|(
name|scalar_type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|STMT_VINFO_VECTYPE
argument_list|(
name|stmt_info
argument_list|)
condition|)
block|{
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_UNVECTORIZED_LOOPS
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"not vectorized: no vectype for stmt: "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|vect_dump
argument_list|,
name|stmt
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|" scalar_type: "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|vect_dump
argument_list|,
name|scalar_type
argument_list|,
name|TDF_DETAILS
argument_list|)
expr_stmt|;
block|}
return|return
name|false
return|;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Utility functions used by vect_mark_stmts_to_be_vectorized.  */
end_comment

begin_comment
comment|/* Function vect_mark_relevant.     Mark STMT as "relevant for vectorization" and add it to WORKLIST.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|vect_mark_relevant
argument_list|(
name|VEC
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|)
operator|*
operator|*
name|worklist
argument_list|,
name|tree
name|stmt
argument_list|,
name|bool
name|relevant_p
argument_list|,
name|bool
name|live_p
argument_list|)
block|{
name|stmt_vec_info
name|stmt_info
init|=
name|vinfo_for_stmt
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
name|bool
name|save_relevant_p
init|=
name|STMT_VINFO_RELEVANT_P
argument_list|(
name|stmt_info
argument_list|)
decl_stmt|;
name|bool
name|save_live_p
init|=
name|STMT_VINFO_LIVE_P
argument_list|(
name|stmt_info
argument_list|)
decl_stmt|;
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"mark relevant %d, live %d."
argument_list|,
name|relevant_p
argument_list|,
name|live_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|STMT_VINFO_IN_PATTERN_P
argument_list|(
name|stmt_info
argument_list|)
condition|)
block|{
name|tree
name|pattern_stmt
decl_stmt|;
comment|/* This is the last stmt in a sequence that was detected as a           pattern that can potentially be vectorized.  Don't mark the stmt          as relevant/live because it's not going to vectorized.          Instead mark the pattern-stmt that replaces it.  */
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"last stmt in pattern. don't mark relevant/live."
argument_list|)
expr_stmt|;
name|pattern_stmt
operator|=
name|STMT_VINFO_RELATED_STMT
argument_list|(
name|stmt_info
argument_list|)
expr_stmt|;
name|stmt_info
operator|=
name|vinfo_for_stmt
argument_list|(
name|pattern_stmt
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|STMT_VINFO_RELATED_STMT
argument_list|(
name|stmt_info
argument_list|)
operator|==
name|stmt
argument_list|)
expr_stmt|;
name|save_relevant_p
operator|=
name|STMT_VINFO_RELEVANT_P
argument_list|(
name|stmt_info
argument_list|)
expr_stmt|;
name|save_live_p
operator|=
name|STMT_VINFO_LIVE_P
argument_list|(
name|stmt_info
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|pattern_stmt
expr_stmt|;
block|}
name|STMT_VINFO_LIVE_P
argument_list|(
name|stmt_info
argument_list|)
operator||=
name|live_p
expr_stmt|;
name|STMT_VINFO_RELEVANT_P
argument_list|(
name|stmt_info
argument_list|)
operator||=
name|relevant_p
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|PHI_NODE
condition|)
comment|/* Don't put phi-nodes in the worklist. Phis that are marked relevant        or live will fail vectorization later on.  */
return|return;
if|if
condition|(
name|STMT_VINFO_RELEVANT_P
argument_list|(
name|stmt_info
argument_list|)
operator|==
name|save_relevant_p
operator|&&
name|STMT_VINFO_LIVE_P
argument_list|(
name|stmt_info
argument_list|)
operator|==
name|save_live_p
condition|)
block|{
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"already marked relevant/live."
argument_list|)
expr_stmt|;
return|return;
block|}
name|VEC_safe_push
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
operator|*
name|worklist
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* Function vect_stmt_relevant_p.     Return true if STMT in loop that is represented by LOOP_VINFO is    "relevant for vectorization".     A stmt is considered "relevant for vectorization" if:    - it has uses outside the loop.    - it has vdefs (it alters memory).    - control stmts in the loop (except for the exit condition).     CHECKME: what other side effects would the vectorizer allow?  */
end_comment

begin_function
specifier|static
name|bool
name|vect_stmt_relevant_p
parameter_list|(
name|tree
name|stmt
parameter_list|,
name|loop_vec_info
name|loop_vinfo
parameter_list|,
name|bool
modifier|*
name|relevant_p
parameter_list|,
name|bool
modifier|*
name|live_p
parameter_list|)
block|{
name|struct
name|loop
modifier|*
name|loop
init|=
name|LOOP_VINFO_LOOP
argument_list|(
name|loop_vinfo
argument_list|)
decl_stmt|;
name|ssa_op_iter
name|op_iter
decl_stmt|;
name|imm_use_iterator
name|imm_iter
decl_stmt|;
name|use_operand_p
name|use_p
decl_stmt|;
name|def_operand_p
name|def_p
decl_stmt|;
operator|*
name|relevant_p
operator|=
name|false
expr_stmt|;
operator|*
name|live_p
operator|=
name|false
expr_stmt|;
comment|/* cond stmt other than loop exit cond.  */
if|if
condition|(
name|is_ctrl_stmt
argument_list|(
name|stmt
argument_list|)
operator|&&
operator|(
name|stmt
operator|!=
name|LOOP_VINFO_EXIT_COND
argument_list|(
name|loop_vinfo
argument_list|)
operator|)
condition|)
operator|*
name|relevant_p
operator|=
name|true
expr_stmt|;
comment|/* changing memory.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|!=
name|PHI_NODE
condition|)
if|if
condition|(
operator|!
name|ZERO_SSA_OPERANDS
argument_list|(
name|stmt
argument_list|,
name|SSA_OP_VIRTUAL_DEFS
argument_list|)
condition|)
block|{
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"vec_stmt_relevant_p: stmt has vdefs."
argument_list|)
expr_stmt|;
operator|*
name|relevant_p
operator|=
name|true
expr_stmt|;
block|}
comment|/* uses outside the loop.  */
name|FOR_EACH_PHI_OR_STMT_DEF
argument_list|(
argument|def_p
argument_list|,
argument|stmt
argument_list|,
argument|op_iter
argument_list|,
argument|SSA_OP_DEF
argument_list|)
block|{
name|FOR_EACH_IMM_USE_FAST
argument_list|(
argument|use_p
argument_list|,
argument|imm_iter
argument_list|,
argument|DEF_FROM_PTR (def_p)
argument_list|)
block|{
name|basic_block
name|bb
init|=
name|bb_for_stmt
argument_list|(
name|USE_STMT
argument_list|(
name|use_p
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|flow_bb_inside_loop_p
argument_list|(
name|loop
argument_list|,
name|bb
argument_list|)
condition|)
block|{
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"vec_stmt_relevant_p: used out of loop."
argument_list|)
expr_stmt|;
comment|/* We expect all such uses to be in the loop exit phis 		 (because of loop closed form)   */
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|USE_STMT
argument_list|(
name|use_p
argument_list|)
argument_list|)
operator|==
name|PHI_NODE
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|bb
operator|==
name|loop
operator|->
name|single_exit
operator|->
name|dest
argument_list|)
expr_stmt|;
operator|*
name|live_p
operator|=
name|true
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
operator|*
name|live_p
operator|||
operator|*
name|relevant_p
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Function vect_mark_stmts_to_be_vectorized.     Not all stmts in the loop need to be vectorized. For example:       for i...        for j...    1.    T0 = i + j    2.	 T1 = a[T0]     3.    j = j + 1     Stmt 1 and 3 do not need to be vectorized, because loop control and    addressing of vectorized data-refs are handled differently.     This pass detects such stmts.  */
end_comment

begin_function
specifier|static
name|bool
name|vect_mark_stmts_to_be_vectorized
parameter_list|(
name|loop_vec_info
name|loop_vinfo
parameter_list|)
block|{
name|VEC
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|)
operator|*
name|worklist
expr_stmt|;
name|struct
name|loop
modifier|*
name|loop
init|=
name|LOOP_VINFO_LOOP
argument_list|(
name|loop_vinfo
argument_list|)
decl_stmt|;
name|basic_block
modifier|*
name|bbs
init|=
name|LOOP_VINFO_BBS
argument_list|(
name|loop_vinfo
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|nbbs
init|=
name|loop
operator|->
name|num_nodes
decl_stmt|;
name|block_stmt_iterator
name|si
decl_stmt|;
name|tree
name|stmt
decl_stmt|,
name|use
decl_stmt|;
name|stmt_ann_t
name|ann
decl_stmt|;
name|ssa_op_iter
name|iter
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|stmt_vec_info
name|stmt_vinfo
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|tree
name|phi
decl_stmt|;
name|bool
name|relevant_p
decl_stmt|,
name|live_p
decl_stmt|;
name|tree
name|def
decl_stmt|,
name|def_stmt
decl_stmt|;
name|enum
name|vect_def_type
name|dt
decl_stmt|;
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"=== vect_mark_stmts_to_be_vectorized ==="
argument_list|)
expr_stmt|;
name|worklist
operator|=
name|VEC_alloc
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
literal|64
argument_list|)
expr_stmt|;
comment|/* 1. Init worklist.  */
name|bb
operator|=
name|loop
operator|->
name|header
expr_stmt|;
for|for
control|(
name|phi
operator|=
name|phi_nodes
argument_list|(
name|bb
argument_list|)
init|;
name|phi
condition|;
name|phi
operator|=
name|PHI_CHAIN
argument_list|(
name|phi
argument_list|)
control|)
block|{
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"init: phi relevant? "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|vect_dump
argument_list|,
name|phi
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vect_stmt_relevant_p
argument_list|(
name|phi
argument_list|,
name|loop_vinfo
argument_list|,
operator|&
name|relevant_p
argument_list|,
operator|&
name|live_p
argument_list|)
condition|)
name|vect_mark_relevant
argument_list|(
operator|&
name|worklist
argument_list|,
name|phi
argument_list|,
name|relevant_p
argument_list|,
name|live_p
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nbbs
condition|;
name|i
operator|++
control|)
block|{
name|bb
operator|=
name|bbs
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|si
operator|=
name|bsi_start
argument_list|(
name|bb
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|si
argument_list|)
condition|;
name|bsi_next
argument_list|(
operator|&
name|si
argument_list|)
control|)
block|{
name|stmt
operator|=
name|bsi_stmt
argument_list|(
name|si
argument_list|)
expr_stmt|;
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"init: stmt relevant? "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|vect_dump
argument_list|,
name|stmt
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vect_stmt_relevant_p
argument_list|(
name|stmt
argument_list|,
name|loop_vinfo
argument_list|,
operator|&
name|relevant_p
argument_list|,
operator|&
name|live_p
argument_list|)
condition|)
name|vect_mark_relevant
argument_list|(
operator|&
name|worklist
argument_list|,
name|stmt
argument_list|,
name|relevant_p
argument_list|,
name|live_p
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 2. Process_worklist */
while|while
condition|(
name|VEC_length
argument_list|(
name|tree
argument_list|,
name|worklist
argument_list|)
operator|>
literal|0
condition|)
block|{
name|stmt
operator|=
name|VEC_pop
argument_list|(
name|tree
argument_list|,
name|worklist
argument_list|)
expr_stmt|;
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"worklist: examine stmt: "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|vect_dump
argument_list|,
name|stmt
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
block|}
comment|/* Examine the USEs of STMT. For each ssa-name USE thta is defined          in the loop, mark the stmt that defines it (DEF_STMT) as          relevant/irrelevant and live/dead according to the liveness and          relevance properties of STMT.        */
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|!=
name|PHI_NODE
argument_list|)
expr_stmt|;
name|ann
operator|=
name|stmt_ann
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|stmt_vinfo
operator|=
name|vinfo_for_stmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|relevant_p
operator|=
name|STMT_VINFO_RELEVANT_P
argument_list|(
name|stmt_vinfo
argument_list|)
expr_stmt|;
name|live_p
operator|=
name|STMT_VINFO_LIVE_P
argument_list|(
name|stmt_vinfo
argument_list|)
expr_stmt|;
comment|/* Generally, the liveness and relevance properties of STMT are          propagated to the DEF_STMTs of its USEs:              STMT_VINFO_LIVE_P (DEF_STMT_info)<-- live_p              STMT_VINFO_RELEVANT_P (DEF_STMT_info)<-- relevant_p           Exceptions:  	 (case 1)            If USE is used only for address computations (e.g. array indexing),            which does not need to be directly vectorized, then the            liveness/relevance of the respective DEF_STMT is left unchanged.  	 (case 2)            If STMT has been identified as defining a reduction variable, then 	   we have two cases: 	   (case 2.1) 	     The last use of STMT is the reduction-variable, which is defined 	     by a loop-header-phi. We don't want to mark the phi as live or 	     relevant (because it does not need to be vectorized, it is handled              as part of the vectorization of the reduction), so in this case we 	     skip the call to vect_mark_relevant. 	   (case 2.2) 	     The rest of the uses of STMT are defined in the loop body. For              the def_stmt of these uses we want to set liveness/relevance              as follows:                STMT_VINFO_LIVE_P (DEF_STMT_info)<-- false                STMT_VINFO_RELEVANT_P (DEF_STMT_info)<-- true              because even though STMT is classified as live (since it defines a              value that is used across loop iterations) and irrelevant (since it              is not used inside the loop), it will be vectorized, and therefore              the corresponding DEF_STMTs need to marked as relevant.        */
comment|/* case 2.2:  */
if|if
condition|(
name|STMT_VINFO_DEF_TYPE
argument_list|(
name|stmt_vinfo
argument_list|)
operator|==
name|vect_reduction_def
condition|)
block|{
name|gcc_assert
argument_list|(
operator|!
name|relevant_p
operator|&&
name|live_p
argument_list|)
expr_stmt|;
name|relevant_p
operator|=
name|true
expr_stmt|;
name|live_p
operator|=
name|false
expr_stmt|;
block|}
name|FOR_EACH_SSA_TREE_OPERAND
argument_list|(
argument|use
argument_list|,
argument|stmt
argument_list|,
argument|iter
argument_list|,
argument|SSA_OP_USE
argument_list|)
block|{
comment|/* case 1: we are only interested in uses that need to be vectorized.  	     Uses that are used for address computation are not considered  	     relevant. 	   */
if|if
condition|(
operator|!
name|exist_non_indexing_operands_for_use_p
argument_list|(
name|use
argument_list|,
name|stmt
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|vect_is_simple_use
argument_list|(
name|use
argument_list|,
name|loop_vinfo
argument_list|,
operator|&
name|def_stmt
argument_list|,
operator|&
name|def
argument_list|,
operator|&
name|dt
argument_list|)
condition|)
block|{
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_UNVECTORIZED_LOOPS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"not vectorized: unsupported use in stmt."
argument_list|)
expr_stmt|;
name|VEC_free
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
name|worklist
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
name|def_stmt
operator|||
name|IS_EMPTY_STMT
argument_list|(
name|def_stmt
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"worklist: examine use %d: "
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|vect_dump
argument_list|,
name|use
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
block|}
name|bb
operator|=
name|bb_for_stmt
argument_list|(
name|def_stmt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|flow_bb_inside_loop_p
argument_list|(
name|loop
argument_list|,
name|bb
argument_list|)
condition|)
continue|continue;
comment|/* case 2.1: the reduction-use does not mark the defining-phi 	     as relevant.  */
if|if
condition|(
name|STMT_VINFO_DEF_TYPE
argument_list|(
name|stmt_vinfo
argument_list|)
operator|==
name|vect_reduction_def
operator|&&
name|TREE_CODE
argument_list|(
name|def_stmt
argument_list|)
operator|==
name|PHI_NODE
condition|)
continue|continue;
name|vect_mark_relevant
argument_list|(
operator|&
name|worklist
argument_list|,
name|def_stmt
argument_list|,
name|relevant_p
argument_list|,
name|live_p
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* while worklist */
name|VEC_free
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
name|worklist
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Function vect_can_advance_ivs_p     In case the number of iterations that LOOP iterates is unknown at compile     time, an epilog loop will be generated, and the loop induction variables     (IVs) will be "advanced" to the value they are supposed to take just before     the epilog loop.  Here we check that the access function of the loop IVs    and the expression that represents the loop bound are simple enough.    These restrictions will be relaxed in the future.  */
end_comment

begin_function
specifier|static
name|bool
name|vect_can_advance_ivs_p
parameter_list|(
name|loop_vec_info
name|loop_vinfo
parameter_list|)
block|{
name|struct
name|loop
modifier|*
name|loop
init|=
name|LOOP_VINFO_LOOP
argument_list|(
name|loop_vinfo
argument_list|)
decl_stmt|;
name|basic_block
name|bb
init|=
name|loop
operator|->
name|header
decl_stmt|;
name|tree
name|phi
decl_stmt|;
comment|/* Analyze phi functions of the loop header.  */
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"=== vect_can_advance_ivs_p ==="
argument_list|)
expr_stmt|;
for|for
control|(
name|phi
operator|=
name|phi_nodes
argument_list|(
name|bb
argument_list|)
init|;
name|phi
condition|;
name|phi
operator|=
name|PHI_CHAIN
argument_list|(
name|phi
argument_list|)
control|)
block|{
name|tree
name|access_fn
init|=
name|NULL
decl_stmt|;
name|tree
name|evolution_part
decl_stmt|;
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"Analyze phi: "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|vect_dump
argument_list|,
name|phi
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
block|}
comment|/* Skip virtual phi's. The data dependences that are associated with          virtual defs/uses (i.e., memory accesses) are analyzed elsewhere.  */
if|if
condition|(
operator|!
name|is_gimple_reg
argument_list|(
name|SSA_NAME_VAR
argument_list|(
name|PHI_RESULT
argument_list|(
name|phi
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"virtual phi. skip."
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Skip reduction phis.  */
if|if
condition|(
name|STMT_VINFO_DEF_TYPE
argument_list|(
name|vinfo_for_stmt
argument_list|(
name|phi
argument_list|)
argument_list|)
operator|==
name|vect_reduction_def
condition|)
block|{
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"reduc phi. skip."
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Analyze the evolution function.  */
name|access_fn
operator|=
name|instantiate_parameters
argument_list|(
name|loop
argument_list|,
name|analyze_scalar_evolution
argument_list|(
name|loop
argument_list|,
name|PHI_RESULT
argument_list|(
name|phi
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|access_fn
condition|)
block|{
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"No Access function."
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"Access function of PHI: "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|vect_dump
argument_list|,
name|access_fn
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
block|}
name|evolution_part
operator|=
name|evolution_part_in_loop_num
argument_list|(
name|access_fn
argument_list|,
name|loop
operator|->
name|num
argument_list|)
expr_stmt|;
if|if
condition|(
name|evolution_part
operator|==
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"No evolution."
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* FORNOW: We do not transform initial conditions of IVs  	 which evolution functions are a polynomial of degree>= 2.  */
if|if
condition|(
name|tree_is_chrec
argument_list|(
name|evolution_part
argument_list|)
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Function vect_get_loop_niters.     Determine how many iterations the loop is executed.    If an expression that represents the number of iterations    can be constructed, place it in NUMBER_OF_ITERATIONS.    Return the loop exit condition.  */
end_comment

begin_function
specifier|static
name|tree
name|vect_get_loop_niters
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|tree
modifier|*
name|number_of_iterations
parameter_list|)
block|{
name|tree
name|niters
decl_stmt|;
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"=== get_loop_niters ==="
argument_list|)
expr_stmt|;
name|niters
operator|=
name|number_of_iterations_in_loop
argument_list|(
name|loop
argument_list|)
expr_stmt|;
if|if
condition|(
name|niters
operator|!=
name|NULL_TREE
operator|&&
name|niters
operator|!=
name|chrec_dont_know
condition|)
block|{
operator|*
name|number_of_iterations
operator|=
name|niters
expr_stmt|;
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"==> get_loop_niters:"
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|vect_dump
argument_list|,
operator|*
name|number_of_iterations
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|get_loop_exit_condition
argument_list|(
name|loop
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Function vect_analyze_loop_form.     Verify the following restrictions (some may be relaxed in the future):    - it's an inner-most loop    - number of BBs = 2 (which are the loop header and the latch)    - the loop has a pre-header    - the loop has a single entry and exit    - the loop exit condition is simple enough, and the number of iterations      can be analyzed (a countable loop).  */
end_comment

begin_function
specifier|static
name|loop_vec_info
name|vect_analyze_loop_form
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|)
block|{
name|loop_vec_info
name|loop_vinfo
decl_stmt|;
name|tree
name|loop_cond
decl_stmt|;
name|tree
name|number_of_iterations
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"=== vect_analyze_loop_form ==="
argument_list|)
expr_stmt|;
if|if
condition|(
name|loop
operator|->
name|inner
condition|)
block|{
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_OUTER_LOOPS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"not vectorized: nested loop."
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|!
name|loop
operator|->
name|single_exit
operator|||
name|loop
operator|->
name|num_nodes
operator|!=
literal|2
operator|||
name|EDGE_COUNT
argument_list|(
name|loop
operator|->
name|header
operator|->
name|preds
argument_list|)
operator|!=
literal|2
condition|)
block|{
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_BAD_FORM_LOOPS
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|loop
operator|->
name|single_exit
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"not vectorized: multiple exits."
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|loop
operator|->
name|num_nodes
operator|!=
literal|2
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"not vectorized: too many BBs in loop."
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|EDGE_COUNT
argument_list|(
name|loop
operator|->
name|header
operator|->
name|preds
argument_list|)
operator|!=
literal|2
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"not vectorized: too many incoming edges."
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
comment|/* We assume that the loop exit condition is at the end of the loop. i.e,      that the loop is represented as a do-while (with a proper if-guard      before the loop if needed), where the loop header contains all the      executable statements, and the latch is empty.  */
if|if
condition|(
operator|!
name|empty_block_p
argument_list|(
name|loop
operator|->
name|latch
argument_list|)
operator|||
name|phi_nodes
argument_list|(
name|loop
operator|->
name|latch
argument_list|)
condition|)
block|{
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_BAD_FORM_LOOPS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"not vectorized: unexpected loop form."
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Make sure there exists a single-predecessor exit bb:  */
if|if
condition|(
operator|!
name|single_pred_p
argument_list|(
name|loop
operator|->
name|single_exit
operator|->
name|dest
argument_list|)
condition|)
block|{
name|edge
name|e
init|=
name|loop
operator|->
name|single_exit
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_ABNORMAL
operator|)
condition|)
block|{
name|split_loop_exit_edge
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"split exit edge."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_BAD_FORM_LOOPS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"not vectorized: abnormal loop exit edge."
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
if|if
condition|(
name|empty_block_p
argument_list|(
name|loop
operator|->
name|header
argument_list|)
condition|)
block|{
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_BAD_FORM_LOOPS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"not vectorized: empty loop."
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|loop_cond
operator|=
name|vect_get_loop_niters
argument_list|(
name|loop
argument_list|,
operator|&
name|number_of_iterations
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|loop_cond
condition|)
block|{
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_BAD_FORM_LOOPS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"not vectorized: complicated exit condition."
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|!
name|number_of_iterations
condition|)
block|{
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_BAD_FORM_LOOPS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"not vectorized: number of iterations cannot be computed."
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|chrec_contains_undetermined
argument_list|(
name|number_of_iterations
argument_list|)
condition|)
block|{
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_BAD_FORM_LOOPS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"Infinite number of iterations."
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|loop_vinfo
operator|=
name|new_loop_vec_info
argument_list|(
name|loop
argument_list|)
expr_stmt|;
name|LOOP_VINFO_NITERS
argument_list|(
name|loop_vinfo
argument_list|)
operator|=
name|number_of_iterations
expr_stmt|;
if|if
condition|(
operator|!
name|LOOP_VINFO_NITERS_KNOWN_P
argument_list|(
name|loop_vinfo
argument_list|)
condition|)
block|{
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"Symbolic number of iterations is "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|vect_dump
argument_list|,
name|number_of_iterations
argument_list|,
name|TDF_DETAILS
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|LOOP_VINFO_INT_NITERS
argument_list|(
name|loop_vinfo
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_UNVECTORIZED_LOOPS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"not vectorized: number of iterations = 0."
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|LOOP_VINFO_EXIT_COND
argument_list|(
name|loop_vinfo
argument_list|)
operator|=
name|loop_cond
expr_stmt|;
return|return
name|loop_vinfo
return|;
block|}
end_function

begin_comment
comment|/* Function vect_analyze_loop.     Apply a set of analyses on LOOP, and create a loop_vec_info struct    for it. The different analyses will record information in the    loop_vec_info struct.  */
end_comment

begin_function
name|loop_vec_info
name|vect_analyze_loop
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|)
block|{
name|bool
name|ok
decl_stmt|;
name|loop_vec_info
name|loop_vinfo
decl_stmt|;
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"===== analyze_loop_nest ====="
argument_list|)
expr_stmt|;
comment|/* Check the CFG characteristics of the loop (nesting, entry/exit, etc.  */
name|loop_vinfo
operator|=
name|vect_analyze_loop_form
argument_list|(
name|loop
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|loop_vinfo
condition|)
block|{
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"bad loop form."
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Find all data references in the loop (which correspond to vdefs/vuses)      and analyze their evolution in the loop.       FORNOW: Handle only simple, array references, which      alignment can be forced, and aligned pointer-references.  */
name|ok
operator|=
name|vect_analyze_data_refs
argument_list|(
name|loop_vinfo
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
block|{
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"bad data references."
argument_list|)
expr_stmt|;
name|destroy_loop_vec_info
argument_list|(
name|loop_vinfo
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Classify all cross-iteration scalar data-flow cycles.      Cross-iteration cycles caused by virtual phis are analyzed separately.  */
name|vect_analyze_scalar_cycles
argument_list|(
name|loop_vinfo
argument_list|)
expr_stmt|;
name|vect_pattern_recog
argument_list|(
name|loop_vinfo
argument_list|)
expr_stmt|;
comment|/* Data-flow analysis to detect stmts that do not need to be vectorized.  */
name|ok
operator|=
name|vect_mark_stmts_to_be_vectorized
argument_list|(
name|loop_vinfo
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
block|{
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"unexpected pattern."
argument_list|)
expr_stmt|;
name|destroy_loop_vec_info
argument_list|(
name|loop_vinfo
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Analyze the alignment of the data-refs in the loop.      Fail if a data reference is found that cannot be vectorized.  */
name|ok
operator|=
name|vect_analyze_data_refs_alignment
argument_list|(
name|loop_vinfo
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
block|{
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"bad data alignment."
argument_list|)
expr_stmt|;
name|destroy_loop_vec_info
argument_list|(
name|loop_vinfo
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|ok
operator|=
name|vect_determine_vectorization_factor
argument_list|(
name|loop_vinfo
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
block|{
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"can't determine vectorization factor."
argument_list|)
expr_stmt|;
name|destroy_loop_vec_info
argument_list|(
name|loop_vinfo
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Analyze data dependences between the data-refs in the loop.       FORNOW: fail at the first data dependence that we encounter.  */
name|ok
operator|=
name|vect_analyze_data_ref_dependences
argument_list|(
name|loop_vinfo
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
block|{
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"bad data dependence."
argument_list|)
expr_stmt|;
name|destroy_loop_vec_info
argument_list|(
name|loop_vinfo
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Analyze the access patterns of the data-refs in the loop (consecutive,      complex, etc.). FORNOW: Only handle consecutive access pattern.  */
name|ok
operator|=
name|vect_analyze_data_ref_accesses
argument_list|(
name|loop_vinfo
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
block|{
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"bad data access."
argument_list|)
expr_stmt|;
name|destroy_loop_vec_info
argument_list|(
name|loop_vinfo
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* This pass will decide on using loop versioning and/or loop peeling in      order to enhance the alignment of data references in the loop.  */
name|ok
operator|=
name|vect_enhance_data_refs_alignment
argument_list|(
name|loop_vinfo
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
block|{
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"bad data alignment."
argument_list|)
expr_stmt|;
name|destroy_loop_vec_info
argument_list|(
name|loop_vinfo
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Scan all the operations in the loop and make sure they are      vectorizable.  */
name|ok
operator|=
name|vect_analyze_operations
argument_list|(
name|loop_vinfo
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
block|{
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"bad operation or unsupported loop bound."
argument_list|)
expr_stmt|;
name|destroy_loop_vec_info
argument_list|(
name|loop_vinfo
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|LOOP_VINFO_VECTORIZABLE_P
argument_list|(
name|loop_vinfo
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|loop_vinfo
return|;
block|}
end_function

end_unit

