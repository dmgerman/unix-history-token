begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Output VMS debug format symbol table information from the GNU C compiler.    Copyright (C) 1987, 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2000, 2001, 2002 Free Software Foundation, Inc.    Contributed by Douglas B. Rupp (rupp@gnat.com).  This file is part of GNU CC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|VMS_DEBUGGING_INFO
end_ifdef

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"vmsdbg.h"
end_include

begin_include
include|#
directive|include
file|"debug.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_comment
comment|/* Difference in seconds between the VMS Epoch and the Unix Epoch */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|long
name|long
name|vms_epoch_offset
init|=
literal|3506716800ll
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* NOTE: In the comments in this file, many references are made to "Debug    Symbol Table".  This term is abbreviated as `DST' throughout the remainder    of this file.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|dst_line_info_struct
modifier|*
name|dst_line_info_ref
typedef|;
end_typedef

begin_comment
comment|/* Each entry in the line_info_table maintains the file and    line number associated with the label generated for that    entry.  The label gives the PC value associated with    the line number entry.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|dst_line_info_struct
block|{
name|unsigned
name|long
name|dst_file_num
decl_stmt|;
name|unsigned
name|long
name|dst_line_num
decl_stmt|;
block|}
name|dst_line_info_entry
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|dst_file_info_struct
modifier|*
name|dst_file_info_ref
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|dst_file_info_struct
block|{
name|char
modifier|*
name|file_name
decl_stmt|;
name|unsigned
name|int
name|max_line
decl_stmt|;
name|unsigned
name|int
name|listing_line_start
decl_stmt|;
name|long
name|long
name|cdt
decl_stmt|;
name|long
name|ebk
decl_stmt|;
name|short
name|ffb
decl_stmt|;
name|char
name|rfo
decl_stmt|;
name|char
name|flen
decl_stmt|;
block|}
name|dst_file_info_entry
typedef|;
end_typedef

begin_comment
comment|/* How to start an assembler comment.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_COMMENT_START
end_ifndef

begin_define
define|#
directive|define
name|ASM_COMMENT_START
value|";#"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Maximum size (in bytes) of an artificially generated label.  */
end_comment

begin_define
define|#
directive|define
name|MAX_ARTIFICIAL_LABEL_BYTES
value|30
end_define

begin_comment
comment|/* Make sure we know the sizes of the various types debug can describe. These    are only defaults.  If the sizes are different for your target, you should    override these values by defining the appropriate symbols in your tm.h    file.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CHAR_TYPE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|CHAR_TYPE_SIZE
value|BITS_PER_UNIT
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PTR_SIZE
end_ifndef

begin_define
define|#
directive|define
name|PTR_SIZE
value|4
end_define

begin_comment
comment|/* Must be 32 bits for VMS debug info */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Pointer to an structure of filenames referenced by this compilation unit.  */
end_comment

begin_decl_stmt
specifier|static
name|dst_file_info_ref
name|file_info_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Total number of entries in the table (i.e. array) pointed to by    `file_info_table'.  This is the *total* and includes both used and unused    slots.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|file_info_table_allocated
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of entries in the file_info_table which are actually in use.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|file_info_table_in_use
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Size (in elements) of increments by which we may expand the filename    table.  */
end_comment

begin_define
define|#
directive|define
name|FILE_TABLE_INCREMENT
value|64
end_define

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|func_table
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|func_table_allocated
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|func_table_in_use
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|FUNC_TABLE_INCREMENT
value|256
end_define

begin_comment
comment|/* Local pointer to the name of the main input file.  Initialized in    avmdbgout_init.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|primary_filename
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|module_producer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|module_language
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A pointer to the base of a table that contains line information    for each source code line in .text in the compilation unit.  */
end_comment

begin_decl_stmt
specifier|static
name|dst_line_info_ref
name|line_info_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of elements currently allocated for line_info_table.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|line_info_table_allocated
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of elements in line_info_table currently in use.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|line_info_table_in_use
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Size (in elements) of increments by which we may expand line_info_table.  */
end_comment

begin_define
define|#
directive|define
name|LINE_INFO_TABLE_INCREMENT
value|1024
end_define

begin_comment
comment|/* The number of the current function definition for which debugging    information is being generated.  These numbers range from 1 up to the    maximum number of function definitions contained within the current    compilation unit.  These numbers are used to create unique label id's unique    to each function definition.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|current_funcdef_number
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forward declarations for functions defined in this file.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|full_name
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|lookup_filename
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|addr_const_to_string
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|write_debug_header
name|PARAMS
argument_list|(
operator|(
name|DST_HEADER
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|write_debug_addr
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|write_debug_data1
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|,
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|write_debug_data2
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|,
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|write_debug_data4
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|long
operator|,
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|write_debug_data8
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|long
name|long
operator|,
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|write_debug_delta4
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|write_debug_string
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|write_modbeg
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|write_modend
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|write_rtnbeg
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|write_rtnend
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|write_pclines
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|write_srccorr
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|dst_file_info_entry
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|write_srccorrs
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|vmsdbgout_init
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|vmsdbgout_finish
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|vmsdbgout_define
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|vmsdbgout_undef
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|vmsdbgout_start_source_file
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|vmsdbgout_end_source_file
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|vmsdbgout_begin_block
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|vmsdbgout_end_block
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|vmsdbgout_ignore_block
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|vmsdbgout_source_line
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|vmsdbgout_begin_prologue
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|vmsdbgout_end_epilogue
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|vmsdbgout_begin_function
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|vmsdbgout_decl
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|vmsdbgout_global_decl
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|vmsdbgout_abstract_function
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The debug hooks structure.  */
end_comment

begin_decl_stmt
name|struct
name|gcc_debug_hooks
name|vmsdbg_debug_hooks
init|=
block|{
name|vmsdbgout_init
block|,
name|vmsdbgout_finish
block|,
name|vmsdbgout_define
block|,
name|vmsdbgout_undef
block|,
name|vmsdbgout_start_source_file
block|,
name|vmsdbgout_end_source_file
block|,
name|vmsdbgout_begin_block
block|,
name|vmsdbgout_end_block
block|,
name|vmsdbgout_ignore_block
block|,
name|vmsdbgout_source_line
block|,
name|vmsdbgout_begin_prologue
block|,
name|debug_nothing_int
block|,
comment|/* end_prologue */
name|vmsdbgout_end_epilogue
block|,
comment|/* end_epilogue */
name|vmsdbgout_begin_function
block|,
comment|/* begin_function */
name|debug_nothing_int
block|,
comment|/* end_function */
name|vmsdbgout_decl
block|,
name|vmsdbgout_global_decl
block|,
name|debug_nothing_tree
block|,
comment|/* deferred_inline_function */
name|vmsdbgout_abstract_function
block|,
name|debug_nothing_rtx
comment|/* label */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Definitions of defaults for assembler-dependent names of various    pseudo-ops and section names.    Theses may be overridden in the tm.h file (if necessary) for a particular    assembler.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|UNALIGNED_SHORT_ASM_OP
end_ifdef

begin_undef
undef|#
directive|undef
name|UNALIGNED_SHORT_ASM_OP
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|UNALIGNED_SHORT_ASM_OP
value|".word"
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|UNALIGNED_INT_ASM_OP
end_ifdef

begin_undef
undef|#
directive|undef
name|UNALIGNED_INT_ASM_OP
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|UNALIGNED_INT_ASM_OP
value|".long"
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|UNALIGNED_LONG_ASM_OP
end_ifdef

begin_undef
undef|#
directive|undef
name|UNALIGNED_LONG_ASM_OP
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|UNALIGNED_LONG_ASM_OP
value|".long"
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|UNALIGNED_DOUBLE_INT_ASM_OP
end_ifdef

begin_undef
undef|#
directive|undef
name|UNALIGNED_DOUBLE_INT_ASM_OP
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|UNALIGNED_DOUBLE_INT_ASM_OP
value|".quad"
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|ASM_BYTE_OP
end_ifdef

begin_undef
undef|#
directive|undef
name|ASM_BYTE_OP
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|ASM_BYTE_OP
value|".byte"
end_define

begin_define
define|#
directive|define
name|NUMBYTES
parameter_list|(
name|I
parameter_list|)
value|((I)< 256 ? 1 : (I)< 65536 ? 2 : 4)
end_define

begin_define
define|#
directive|define
name|NUMBYTES0
parameter_list|(
name|I
parameter_list|)
value|((I)< 128 ? 0 : (I)< 65536 ? 2 : 4)
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|UNALIGNED_PTR_ASM_OP
end_ifndef

begin_define
define|#
directive|define
name|UNALIGNED_PTR_ASM_OP
define|\
value|(PTR_SIZE == 8 ? UNALIGNED_DOUBLE_INT_ASM_OP : UNALIGNED_INT_ASM_OP)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|UNALIGNED_OFFSET_ASM_OP
end_ifndef

begin_define
define|#
directive|define
name|UNALIGNED_OFFSET_ASM_OP
parameter_list|(
name|OFFSET
parameter_list|)
define|\
value|(NUMBYTES(OFFSET) == 4 \    ? UNALIGNED_LONG_ASM_OP \    : (NUMBYTES(OFFSET) == 2 ? UNALIGNED_SHORT_ASM_OP : ASM_BYTE_OP))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Pseudo-op for defining a new section.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SECTION_ASM_OP
end_ifndef

begin_define
define|#
directive|define
name|SECTION_ASM_OP
value|".section"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Definitions of defaults for formats and names of various special    (artificial) labels which may be generated within this file (when the -g    options is used and VMS_DEBUGGING_INFO is in effect.  If necessary, these    may be overridden from within the tm.h file, but typically, overriding these    defaults is unnecessary.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|text_end_label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|TEXT_END_LABEL
end_ifndef

begin_define
define|#
directive|define
name|TEXT_END_LABEL
value|"Lvetext"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|FUNC_BEGIN_LABEL
end_ifndef

begin_define
define|#
directive|define
name|FUNC_BEGIN_LABEL
value|"LVFB"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|FUNC_PROLOG_LABEL
end_ifndef

begin_define
define|#
directive|define
name|FUNC_PROLOG_LABEL
value|"LVFP"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|FUNC_END_LABEL
end_ifndef

begin_define
define|#
directive|define
name|FUNC_END_LABEL
value|"LVFE"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|BLOCK_BEGIN_LABEL
end_ifndef

begin_define
define|#
directive|define
name|BLOCK_BEGIN_LABEL
value|"LVBB"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|BLOCK_END_LABEL
end_ifndef

begin_define
define|#
directive|define
name|BLOCK_END_LABEL
value|"LVBE"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LINE_CODE_LABEL
end_ifndef

begin_define
define|#
directive|define
name|LINE_CODE_LABEL
value|"LVM"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_OUTPUT_DEBUG_DELTA2
end_ifndef

begin_define
define|#
directive|define
name|ASM_OUTPUT_DEBUG_DELTA2
parameter_list|(
name|FILE
parameter_list|,
name|LABEL1
parameter_list|,
name|LABEL2
parameter_list|)
define|\
value|do									 \     {									 \       fprintf ((FILE), "\t%s\t", UNALIGNED_SHORT_ASM_OP);		 \       assemble_name (FILE, LABEL1);					 \       fprintf (FILE, "-");						 \       assemble_name (FILE, LABEL2);					 \     }									 \   while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_OUTPUT_DEBUG_DELTA4
end_ifndef

begin_define
define|#
directive|define
name|ASM_OUTPUT_DEBUG_DELTA4
parameter_list|(
name|FILE
parameter_list|,
name|LABEL1
parameter_list|,
name|LABEL2
parameter_list|)
define|\
value|do									 \     {									 \       fprintf ((FILE), "\t%s\t", UNALIGNED_INT_ASM_OP);			 \       assemble_name (FILE, LABEL1);					 \       fprintf (FILE, "-");						 \       assemble_name (FILE, LABEL2);					 \     }									 \   while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_OUTPUT_DEBUG_ADDR_DELTA
end_ifndef

begin_define
define|#
directive|define
name|ASM_OUTPUT_DEBUG_ADDR_DELTA
parameter_list|(
name|FILE
parameter_list|,
name|LABEL1
parameter_list|,
name|LABEL2
parameter_list|)
define|\
value|do									 \     {									 \       fprintf ((FILE), "\t%s\t", UNALIGNED_PTR_ASM_OP);			 \       assemble_name (FILE, LABEL1);					 \       fprintf (FILE, "-");						 \       assemble_name (FILE, LABEL2);					 \     }									 \   while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_OUTPUT_DEBUG_ADDR
end_ifndef

begin_define
define|#
directive|define
name|ASM_OUTPUT_DEBUG_ADDR
parameter_list|(
name|FILE
parameter_list|,
name|LABEL
parameter_list|)
define|\
value|do									 \     {									 \       fprintf ((FILE), "\t%s\t", UNALIGNED_PTR_ASM_OP);			 \       assemble_name (FILE, LABEL);					 \     }									 \   while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_OUTPUT_DEBUG_ADDR_CONST
end_ifndef

begin_define
define|#
directive|define
name|ASM_OUTPUT_DEBUG_ADDR_CONST
parameter_list|(
name|FILE
parameter_list|,
name|ADDR
parameter_list|)
define|\
value|fprintf ((FILE), "\t%s\t%s", UNALIGNED_PTR_ASM_OP, (ADDR))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_OUTPUT_DEBUG_DATA1
end_ifndef

begin_define
define|#
directive|define
name|ASM_OUTPUT_DEBUG_DATA1
parameter_list|(
name|FILE
parameter_list|,
name|VALUE
parameter_list|)
define|\
value|fprintf ((FILE), "\t%s\t0x%x", ASM_BYTE_OP, (unsigned char) VALUE)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_OUTPUT_DEBUG_DATA2
end_ifndef

begin_define
define|#
directive|define
name|ASM_OUTPUT_DEBUG_DATA2
parameter_list|(
name|FILE
parameter_list|,
name|VALUE
parameter_list|)
define|\
value|fprintf ((FILE), "\t%s\t0x%x", UNALIGNED_SHORT_ASM_OP, \ 	   (unsigned short) VALUE)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_OUTPUT_DEBUG_DATA4
end_ifndef

begin_define
define|#
directive|define
name|ASM_OUTPUT_DEBUG_DATA4
parameter_list|(
name|FILE
parameter_list|,
name|VALUE
parameter_list|)
define|\
value|fprintf ((FILE), "\t%s\t0x%lx", UNALIGNED_INT_ASM_OP, (unsigned long) VALUE)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_OUTPUT_DEBUG_DATA
end_ifndef

begin_define
define|#
directive|define
name|ASM_OUTPUT_DEBUG_DATA
parameter_list|(
name|FILE
parameter_list|,
name|VALUE
parameter_list|)
define|\
value|fprintf ((FILE), "\t%s\t0x%lx", UNALIGNED_OFFSET_ASM_OP(VALUE), VALUE)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_OUTPUT_DEBUG_ADDR_DATA
end_ifndef

begin_define
define|#
directive|define
name|ASM_OUTPUT_DEBUG_ADDR_DATA
parameter_list|(
name|FILE
parameter_list|,
name|VALUE
parameter_list|)
define|\
value|fprintf ((FILE), "\t%s\t0x%lx", UNALIGNED_PTR_ASM_OP, \ 	   (unsigned long) VALUE)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_OUTPUT_DEBUG_DATA8
end_ifndef

begin_define
define|#
directive|define
name|ASM_OUTPUT_DEBUG_DATA8
parameter_list|(
name|FILE
parameter_list|,
name|VALUE
parameter_list|)
define|\
value|fprintf ((FILE), "\t%s\t0x%llx", UNALIGNED_DOUBLE_INT_ASM_OP, \                                  (unsigned long long) VALUE)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This is similar to the default ASM_OUTPUT_ASCII, except that no trailing    newline is produced.  When flag_verbose_asm is asserted, we add commnetary    at the end of the line, so we must avoid output of a newline here.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_OUTPUT_DEBUG_STRING
end_ifndef

begin_define
define|#
directive|define
name|ASM_OUTPUT_DEBUG_STRING
parameter_list|(
name|FILE
parameter_list|,
name|P
parameter_list|)
define|\
value|do						\     {						\       register int slen = strlen(P);		\       register char *p = (P);			\       register int i;				\       fprintf (FILE, "\t.ascii \"");		\       for (i = 0; i< slen; i++)		\ 	{					\ 	  register int c = p[i];		\ 	  if (c == '\"' || c == '\\')		\ 	    putc ('\\', FILE);			\ 	  if (c>= ' '&& c< 0177)		\ 	    putc (c, FILE);			\ 	  else					\ 	    fprintf (FILE, "\\%o", c);		\ 	}					\       fprintf (FILE, "\"");			\     }						\   while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Convert a reference to the assembler name of a C-level name.  This    macro has the same effect as ASM_OUTPUT_LABELREF, but copies to    a string rather than writing to a file.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_NAME_TO_STRING
end_ifndef

begin_define
define|#
directive|define
name|ASM_NAME_TO_STRING
parameter_list|(
name|STR
parameter_list|,
name|NAME
parameter_list|)
define|\
value|do						\     {						\       if ((NAME)[0] == '*')			\ 	strcpy (STR, NAME+1);			\       else					\ 	strcpy (STR, NAME);			\     }						\   while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* General utility functions.  */
end_comment

begin_comment
comment|/* Convert an integer constant expression into assembler syntax.  Addition and    subtraction are the only arithmetic that may appear in these expressions.    This is an adaptation of output_addr_const in final.c.  Here, the target    of the conversion is a string buffer.  We can't use output_addr_const    directly, because it writes to a file.  */
end_comment

begin_function
specifier|static
name|void
name|addr_const_to_string
parameter_list|(
name|str
parameter_list|,
name|x
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|rtx
name|x
decl_stmt|;
block|{
name|char
name|buf1
index|[
literal|256
index|]
decl_stmt|;
name|char
name|buf2
index|[
literal|256
index|]
decl_stmt|;
name|restart
label|:
name|str
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|PC
case|:
if|if
condition|(
name|flag_pic
condition|)
name|strcat
argument_list|(
name|str
argument_list|,
literal|","
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
break|break;
case|case
name|SYMBOL_REF
case|:
name|ASM_NAME_TO_STRING
argument_list|(
name|buf1
argument_list|,
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|str
argument_list|,
name|buf1
argument_list|)
expr_stmt|;
break|break;
case|case
name|LABEL_REF
case|:
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|buf1
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ASM_NAME_TO_STRING
argument_list|(
name|buf2
argument_list|,
name|buf1
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|str
argument_list|,
name|buf2
argument_list|)
expr_stmt|;
break|break;
case|case
name|CODE_LABEL
case|:
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|buf1
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|ASM_NAME_TO_STRING
argument_list|(
name|buf2
argument_list|,
name|buf1
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|str
argument_list|,
name|buf2
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONST_INT
case|:
name|sprintf
argument_list|(
name|buf1
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|INTVAL
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|str
argument_list|,
name|buf1
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONST
case|:
comment|/* This used to output parentheses around the expression, but that does           not work on the 386 (either ATT or BSD assembler).  */
name|addr_const_to_string
argument_list|(
name|buf1
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|str
argument_list|,
name|buf1
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONST_DOUBLE
case|:
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|VOIDmode
condition|)
block|{
comment|/* We can use %d if the number is one word and positive.  */
if|if
condition|(
name|CONST_DOUBLE_HIGH
argument_list|(
name|x
argument_list|)
condition|)
name|sprintf
argument_list|(
name|buf1
argument_list|,
name|HOST_WIDE_INT_PRINT_DOUBLE_HEX
argument_list|,
name|CONST_DOUBLE_HIGH
argument_list|(
name|x
argument_list|)
argument_list|,
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
operator|<
literal|0
condition|)
name|sprintf
argument_list|(
name|buf1
argument_list|,
name|HOST_WIDE_INT_PRINT_HEX
argument_list|,
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|buf1
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|str
argument_list|,
name|buf1
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* We can't handle floating point constants; PRINT_OPERAND must 	   handle them.  */
name|output_operand_lossage
argument_list|(
literal|"floating constant misused"
argument_list|)
expr_stmt|;
break|break;
case|case
name|PLUS
case|:
comment|/* Some assemblers need integer constants to appear last (eg masm).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|addr_const_to_string
argument_list|(
name|buf1
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|str
argument_list|,
name|buf1
argument_list|)
expr_stmt|;
if|if
condition|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|>=
literal|0
condition|)
name|strcat
argument_list|(
name|str
argument_list|,
literal|"+"
argument_list|)
expr_stmt|;
name|addr_const_to_string
argument_list|(
name|buf1
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|str
argument_list|,
name|buf1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|addr_const_to_string
argument_list|(
name|buf1
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|str
argument_list|,
name|buf1
argument_list|)
expr_stmt|;
if|if
condition|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|>=
literal|0
condition|)
name|strcat
argument_list|(
name|str
argument_list|,
literal|"+"
argument_list|)
expr_stmt|;
name|addr_const_to_string
argument_list|(
name|buf1
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|str
argument_list|,
name|buf1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|MINUS
case|:
comment|/* Avoid outputting things like x-x or x+5-x, since some assemblers          can't handle that.  */
name|x
operator|=
name|simplify_subtraction
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|MINUS
condition|)
goto|goto
name|restart
goto|;
name|addr_const_to_string
argument_list|(
name|buf1
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|str
argument_list|,
name|buf1
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|str
argument_list|,
literal|"-"
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|strcat
argument_list|(
name|str
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|addr_const_to_string
argument_list|(
name|buf1
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|str
argument_list|,
name|buf1
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|str
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|addr_const_to_string
argument_list|(
name|buf1
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|str
argument_list|,
name|buf1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ZERO_EXTEND
case|:
case|case
name|SIGN_EXTEND
case|:
name|addr_const_to_string
argument_list|(
name|buf1
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|str
argument_list|,
name|buf1
argument_list|)
expr_stmt|;
break|break;
default|default:
name|output_operand_lossage
argument_list|(
literal|"invalid expression as operand"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Output the debug header HEADER.  Also output COMMENT if flag_verbose_asm is    set.  Return the header size.  Just return the size if DOSIZEONLY is    non-zero.  */
end_comment

begin_function
specifier|static
name|int
name|write_debug_header
parameter_list|(
name|header
parameter_list|,
name|comment
parameter_list|,
name|dosizeonly
parameter_list|)
name|DST_HEADER
modifier|*
name|header
decl_stmt|;
specifier|const
name|char
modifier|*
name|comment
decl_stmt|;
name|int
name|dosizeonly
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|dosizeonly
condition|)
block|{
name|ASM_OUTPUT_DEBUG_DATA2
argument_list|(
name|asm_out_file
argument_list|,
name|header
operator|->
name|dst__header_length
operator|.
name|dst_w_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_verbose_asm
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s record length"
argument_list|,
name|ASM_COMMENT_START
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DEBUG_DATA2
argument_list|(
name|asm_out_file
argument_list|,
name|header
operator|->
name|dst__header_type
operator|.
name|dst_w_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_verbose_asm
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s record type (%s)"
argument_list|,
name|ASM_COMMENT_START
argument_list|,
name|comment
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
return|return
literal|4
return|;
block|}
end_function

begin_comment
comment|/* Output the address of SYMBOL.  Also output COMMENT if flag_verbose_asm is    set.  Return the address size.  Just return the size if DOSIZEONLY is    non-zero.  */
end_comment

begin_function
specifier|static
name|int
name|write_debug_addr
parameter_list|(
name|symbol
parameter_list|,
name|comment
parameter_list|,
name|dosizeonly
parameter_list|)
name|char
modifier|*
name|symbol
decl_stmt|;
specifier|const
name|char
modifier|*
name|comment
decl_stmt|;
name|int
name|dosizeonly
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|dosizeonly
condition|)
block|{
name|ASM_OUTPUT_DEBUG_ADDR
argument_list|(
name|asm_out_file
argument_list|,
name|symbol
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_verbose_asm
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s %s"
argument_list|,
name|ASM_COMMENT_START
argument_list|,
name|comment
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
return|return
name|PTR_SIZE
return|;
block|}
end_function

begin_comment
comment|/* Output the single byte DATA1.  Also output COMMENT if flag_verbose_asm is    set.  Return the data size.  Just return the size if DOSIZEONLY is    non-zero.  */
end_comment

begin_function
specifier|static
name|int
name|write_debug_data1
parameter_list|(
name|data1
parameter_list|,
name|comment
parameter_list|,
name|dosizeonly
parameter_list|)
name|unsigned
name|int
name|data1
decl_stmt|;
specifier|const
name|char
modifier|*
name|comment
decl_stmt|;
name|int
name|dosizeonly
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|dosizeonly
condition|)
block|{
name|ASM_OUTPUT_DEBUG_DATA1
argument_list|(
name|asm_out_file
argument_list|,
name|data1
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_verbose_asm
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s %s"
argument_list|,
name|ASM_COMMENT_START
argument_list|,
name|comment
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Output the single word DATA2.  Also output COMMENT if flag_verbose_asm is    set.  Return the data size.  Just return the size if DOSIZEONLY is    non-zero.  */
end_comment

begin_function
specifier|static
name|int
name|write_debug_data2
parameter_list|(
name|data2
parameter_list|,
name|comment
parameter_list|,
name|dosizeonly
parameter_list|)
name|unsigned
name|int
name|data2
decl_stmt|;
specifier|const
name|char
modifier|*
name|comment
decl_stmt|;
name|int
name|dosizeonly
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|dosizeonly
condition|)
block|{
name|ASM_OUTPUT_DEBUG_DATA2
argument_list|(
name|asm_out_file
argument_list|,
name|data2
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_verbose_asm
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s %s"
argument_list|,
name|ASM_COMMENT_START
argument_list|,
name|comment
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
return|return
literal|2
return|;
block|}
end_function

begin_comment
comment|/* Output double word DATA4.  Also output COMMENT if flag_verbose_asm is set.    Return the data size.  Just return the size if DOSIZEONLY is non-zero.  */
end_comment

begin_function
specifier|static
name|int
name|write_debug_data4
parameter_list|(
name|data4
parameter_list|,
name|comment
parameter_list|,
name|dosizeonly
parameter_list|)
name|unsigned
name|long
name|data4
decl_stmt|;
specifier|const
name|char
modifier|*
name|comment
decl_stmt|;
name|int
name|dosizeonly
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|dosizeonly
condition|)
block|{
name|ASM_OUTPUT_DEBUG_DATA4
argument_list|(
name|asm_out_file
argument_list|,
name|data4
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_verbose_asm
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s %s"
argument_list|,
name|ASM_COMMENT_START
argument_list|,
name|comment
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
return|return
literal|4
return|;
block|}
end_function

begin_comment
comment|/* Output quad word DATA8.  Also output COMMENT if flag_verbose_asm is set.    Return the data size.  Just return the size if DOSIZEONLY is non-zero.  */
end_comment

begin_function
specifier|static
name|int
name|write_debug_data8
parameter_list|(
name|data8
parameter_list|,
name|comment
parameter_list|,
name|dosizeonly
parameter_list|)
name|unsigned
name|long
name|long
name|data8
decl_stmt|;
specifier|const
name|char
modifier|*
name|comment
decl_stmt|;
name|int
name|dosizeonly
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|dosizeonly
condition|)
block|{
name|ASM_OUTPUT_DEBUG_DATA8
argument_list|(
name|asm_out_file
argument_list|,
name|data8
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_verbose_asm
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s %s"
argument_list|,
name|ASM_COMMENT_START
argument_list|,
name|comment
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
return|return
literal|8
return|;
block|}
end_function

begin_comment
comment|/* Output the difference between LABEL1 and LABEL2.  Also output COMMENT if    flag_verbose_asm is set.  Return the data size.  Just return the size if    DOSIZEONLY is non-zero.  */
end_comment

begin_function
specifier|static
name|int
name|write_debug_delta4
parameter_list|(
name|label1
parameter_list|,
name|label2
parameter_list|,
name|comment
parameter_list|,
name|dosizeonly
parameter_list|)
name|char
modifier|*
name|label1
decl_stmt|;
name|char
modifier|*
name|label2
decl_stmt|;
specifier|const
name|char
modifier|*
name|comment
decl_stmt|;
name|int
name|dosizeonly
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|dosizeonly
condition|)
block|{
name|ASM_OUTPUT_DEBUG_DELTA4
argument_list|(
name|asm_out_file
argument_list|,
name|label1
argument_list|,
name|label2
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_verbose_asm
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s %s"
argument_list|,
name|ASM_COMMENT_START
argument_list|,
name|comment
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
return|return
literal|4
return|;
block|}
end_function

begin_comment
comment|/* Output a character string STRING.  Also write COMMENT if flag_verbose_asm is    set.  Return the string length.  Just return the length if DOSIZEONLY is    non-zero.  */
end_comment

begin_function
specifier|static
name|int
name|write_debug_string
parameter_list|(
name|string
parameter_list|,
name|comment
parameter_list|,
name|dosizeonly
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
specifier|const
name|char
modifier|*
name|comment
decl_stmt|;
name|int
name|dosizeonly
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|dosizeonly
condition|)
block|{
name|ASM_OUTPUT_DEBUG_STRING
argument_list|(
name|asm_out_file
argument_list|,
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_verbose_asm
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s %s"
argument_list|,
name|ASM_COMMENT_START
argument_list|,
name|comment
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
return|return
name|strlen
argument_list|(
name|string
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Output a module begin header and return the header size.  Just return the    size if DOSIZEONLY is non-zero.  */
end_comment

begin_function
specifier|static
name|int
name|write_modbeg
parameter_list|(
name|dosizeonly
parameter_list|)
name|int
name|dosizeonly
decl_stmt|;
block|{
name|DST_MODULE_BEGIN
name|modbeg
decl_stmt|;
name|DST_MB_TRLR
name|mb_trlr
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|module_name
decl_stmt|,
modifier|*
name|m
decl_stmt|;
name|int
name|modnamelen
decl_stmt|;
name|int
name|prodnamelen
decl_stmt|;
name|int
name|totsize
init|=
literal|0
decl_stmt|;
comment|/* Assumes primary filename has Unix syntax file spec.  */
name|module_name
operator|=
name|xstrdup
argument_list|(
name|basename
argument_list|(
operator|(
name|char
operator|*
operator|)
name|primary_filename
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|=
name|strrchr
argument_list|(
name|module_name
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
condition|)
operator|*
name|m
operator|=
literal|0
expr_stmt|;
name|modnamelen
operator|=
name|strlen
argument_list|(
name|module_name
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|modnamelen
condition|;
name|i
operator|++
control|)
name|module_name
index|[
name|i
index|]
operator|=
name|TOUPPER
argument_list|(
name|module_name
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|prodnamelen
operator|=
name|strlen
argument_list|(
name|module_producer
argument_list|)
expr_stmt|;
name|modbeg
operator|.
name|dst_a_modbeg_header
operator|.
name|dst__header_length
operator|.
name|dst_w_length
operator|=
name|DST_K_MODBEG_SIZE
operator|+
name|modnamelen
operator|+
name|DST_K_MB_TRLR_SIZE
operator|+
name|prodnamelen
operator|-
literal|1
expr_stmt|;
name|modbeg
operator|.
name|dst_a_modbeg_header
operator|.
name|dst__header_type
operator|.
name|dst_w_type
operator|=
name|DST_K_MODBEG
expr_stmt|;
name|modbeg
operator|.
name|dst_b_modbeg_flags
operator|.
name|dst_v_modbeg_hide
operator|=
literal|0
expr_stmt|;
name|modbeg
operator|.
name|dst_b_modbeg_flags
operator|.
name|dst_v_modbeg_version
operator|=
literal|1
expr_stmt|;
name|modbeg
operator|.
name|dst_b_modbeg_flags
operator|.
name|dst_v_modbeg_unused
operator|=
literal|0
expr_stmt|;
name|modbeg
operator|.
name|dst_b_modbeg_unused
operator|=
literal|0
expr_stmt|;
name|modbeg
operator|.
name|dst_l_modbeg_language
operator|=
name|module_language
expr_stmt|;
name|modbeg
operator|.
name|dst_w_version_major
operator|=
name|DST_K_VERSION_MAJOR
expr_stmt|;
name|modbeg
operator|.
name|dst_w_version_minor
operator|=
name|DST_K_VERSION_MINOR
expr_stmt|;
name|modbeg
operator|.
name|dst_b_modbeg_name
operator|=
name|strlen
argument_list|(
name|module_name
argument_list|)
expr_stmt|;
name|mb_trlr
operator|.
name|dst_b_compiler
operator|=
name|strlen
argument_list|(
name|module_producer
argument_list|)
expr_stmt|;
name|totsize
operator|+=
name|write_debug_header
argument_list|(
operator|&
name|modbeg
operator|.
name|dst_a_modbeg_header
argument_list|,
literal|"modbeg"
argument_list|,
name|dosizeonly
argument_list|)
expr_stmt|;
name|totsize
operator|+=
name|write_debug_data1
argument_list|(
operator|*
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|modbeg
operator|.
name|dst_b_modbeg_flags
operator|)
argument_list|,
literal|"flags"
argument_list|,
name|dosizeonly
argument_list|)
expr_stmt|;
name|totsize
operator|+=
name|write_debug_data1
argument_list|(
name|modbeg
operator|.
name|dst_b_modbeg_unused
argument_list|,
literal|"unused"
argument_list|,
name|dosizeonly
argument_list|)
expr_stmt|;
name|totsize
operator|+=
name|write_debug_data4
argument_list|(
name|modbeg
operator|.
name|dst_l_modbeg_language
argument_list|,
literal|"language"
argument_list|,
name|dosizeonly
argument_list|)
expr_stmt|;
name|totsize
operator|+=
name|write_debug_data2
argument_list|(
name|modbeg
operator|.
name|dst_w_version_major
argument_list|,
literal|"DST major version"
argument_list|,
name|dosizeonly
argument_list|)
expr_stmt|;
name|totsize
operator|+=
name|write_debug_data2
argument_list|(
name|modbeg
operator|.
name|dst_w_version_minor
argument_list|,
literal|"DST minor version"
argument_list|,
name|dosizeonly
argument_list|)
expr_stmt|;
name|totsize
operator|+=
name|write_debug_data1
argument_list|(
name|modbeg
operator|.
name|dst_b_modbeg_name
argument_list|,
literal|"length of module name"
argument_list|,
name|dosizeonly
argument_list|)
expr_stmt|;
name|totsize
operator|+=
name|write_debug_string
argument_list|(
name|module_name
argument_list|,
literal|"module name"
argument_list|,
name|dosizeonly
argument_list|)
expr_stmt|;
name|totsize
operator|+=
name|write_debug_data1
argument_list|(
name|mb_trlr
operator|.
name|dst_b_compiler
argument_list|,
literal|"length of compiler name"
argument_list|,
name|dosizeonly
argument_list|)
expr_stmt|;
name|totsize
operator|+=
name|write_debug_string
argument_list|(
name|module_producer
argument_list|,
literal|"compiler name"
argument_list|,
name|dosizeonly
argument_list|)
expr_stmt|;
return|return
name|totsize
return|;
block|}
end_function

begin_comment
comment|/* Output a module end trailer and return the trailer size.   Just return    the size if DOSIZEONLY is non-zero.  */
end_comment

begin_function
specifier|static
name|int
name|write_modend
parameter_list|(
name|dosizeonly
parameter_list|)
name|int
name|dosizeonly
decl_stmt|;
block|{
name|DST_MODULE_END
name|modend
decl_stmt|;
name|int
name|totsize
init|=
literal|0
decl_stmt|;
name|modend
operator|.
name|dst_a_modend_header
operator|.
name|dst__header_length
operator|.
name|dst_w_length
operator|=
name|DST_K_MODEND_SIZE
operator|-
literal|1
expr_stmt|;
name|modend
operator|.
name|dst_a_modend_header
operator|.
name|dst__header_type
operator|.
name|dst_w_type
operator|=
name|DST_K_MODEND
expr_stmt|;
name|totsize
operator|+=
name|write_debug_header
argument_list|(
operator|&
name|modend
operator|.
name|dst_a_modend_header
argument_list|,
literal|"modend"
argument_list|,
name|dosizeonly
argument_list|)
expr_stmt|;
return|return
name|totsize
return|;
block|}
end_function

begin_comment
comment|/* Output a routine begin header routine RTNNUM and return the header size.    Just return the size if DOSIZEONLY is non-zero.  */
end_comment

begin_function
specifier|static
name|int
name|write_rtnbeg
parameter_list|(
name|rtnnum
parameter_list|,
name|dosizeonly
parameter_list|)
name|int
name|rtnnum
decl_stmt|;
name|int
name|dosizeonly
decl_stmt|;
block|{
name|char
modifier|*
name|rtnname
decl_stmt|;
name|int
name|rtnnamelen
decl_stmt|,
name|rtnentrynamelen
decl_stmt|;
name|char
modifier|*
name|rtnentryname
decl_stmt|;
name|int
name|totsize
init|=
literal|0
decl_stmt|;
name|char
name|label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
name|DST_ROUTINE_BEGIN
name|rtnbeg
decl_stmt|;
name|DST_PROLOG
name|prolog
decl_stmt|;
name|rtnname
operator|=
name|func_table
index|[
name|rtnnum
index|]
expr_stmt|;
name|rtnnamelen
operator|=
name|strlen
argument_list|(
name|rtnname
argument_list|)
expr_stmt|;
name|rtnentrynamelen
operator|=
name|rtnnamelen
operator|+
literal|4
expr_stmt|;
comment|/* "..en" */
name|rtnentryname
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|rtnentrynamelen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|rtnentryname
argument_list|,
name|rtnname
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|rtnentryname
argument_list|,
literal|"..en"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|rtnname
argument_list|,
literal|"main"
argument_list|)
condition|)
block|{
name|DST_HEADER
name|header
decl_stmt|;
specifier|const
name|char
modifier|*
name|go
init|=
literal|"TRANSFER$BREAK$GO"
decl_stmt|;
comment|/* This command isn't documented in DSTRECORDS, so it's made to 	 look like what DEC C does */
comment|/* header size - 1st byte + flag byte + STO_LW size 	 + string count byte + string length */
name|header
operator|.
name|dst__header_length
operator|.
name|dst_w_length
operator|=
name|DST_K_DST_HEADER_SIZE
operator|-
literal|1
operator|+
literal|1
operator|+
literal|4
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|go
argument_list|)
expr_stmt|;
name|header
operator|.
name|dst__header_type
operator|.
name|dst_w_type
operator|=
literal|0x17
expr_stmt|;
name|totsize
operator|+=
name|write_debug_header
argument_list|(
operator|&
name|header
argument_list|,
literal|"transfer"
argument_list|,
name|dosizeonly
argument_list|)
expr_stmt|;
comment|/* I think this is a flag byte, but I don't know what this flag means */
name|totsize
operator|+=
name|write_debug_data1
argument_list|(
literal|0x1
argument_list|,
literal|"flags ???"
argument_list|,
name|dosizeonly
argument_list|)
expr_stmt|;
comment|/* Routine Begin PD Address */
name|totsize
operator|+=
name|write_debug_addr
argument_list|(
name|rtnname
argument_list|,
literal|"main procedure descriptor"
argument_list|,
name|dosizeonly
argument_list|)
expr_stmt|;
name|totsize
operator|+=
name|write_debug_data1
argument_list|(
name|strlen
argument_list|(
name|go
argument_list|)
argument_list|,
literal|"length of main_name"
argument_list|,
name|dosizeonly
argument_list|)
expr_stmt|;
name|totsize
operator|+=
name|write_debug_string
argument_list|(
operator|(
name|char
operator|*
operator|)
name|go
argument_list|,
literal|"main name"
argument_list|,
name|dosizeonly
argument_list|)
expr_stmt|;
block|}
comment|/* The header length never includes the length byte */
name|rtnbeg
operator|.
name|dst_a_rtnbeg_header
operator|.
name|dst__header_length
operator|.
name|dst_w_length
operator|=
name|DST_K_RTNBEG_SIZE
operator|+
name|rtnnamelen
operator|-
literal|1
expr_stmt|;
name|rtnbeg
operator|.
name|dst_a_rtnbeg_header
operator|.
name|dst__header_type
operator|.
name|dst_w_type
operator|=
name|DST_K_RTNBEG
expr_stmt|;
name|rtnbeg
operator|.
name|dst_b_rtnbeg_flags
operator|.
name|dst_v_rtnbeg_unused
operator|=
literal|0
expr_stmt|;
name|rtnbeg
operator|.
name|dst_b_rtnbeg_flags
operator|.
name|dst_v_rtnbeg_unalloc
operator|=
literal|0
expr_stmt|;
name|rtnbeg
operator|.
name|dst_b_rtnbeg_flags
operator|.
name|dst_v_rtnbeg_prototype
operator|=
literal|0
expr_stmt|;
name|rtnbeg
operator|.
name|dst_b_rtnbeg_flags
operator|.
name|dst_v_rtnbeg_inlined
operator|=
literal|0
expr_stmt|;
name|rtnbeg
operator|.
name|dst_b_rtnbeg_flags
operator|.
name|dst_v_rtnbeg_no_call
operator|=
literal|1
expr_stmt|;
name|rtnbeg
operator|.
name|dst_b_rtnbeg_name
operator|=
name|rtnnamelen
expr_stmt|;
name|totsize
operator|+=
name|write_debug_header
argument_list|(
operator|&
name|rtnbeg
operator|.
name|dst_a_rtnbeg_header
argument_list|,
literal|"rtnbeg"
argument_list|,
name|dosizeonly
argument_list|)
expr_stmt|;
name|totsize
operator|+=
name|write_debug_data1
argument_list|(
operator|*
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|rtnbeg
operator|.
name|dst_b_rtnbeg_flags
operator|)
argument_list|,
literal|"flags"
argument_list|,
name|dosizeonly
argument_list|)
expr_stmt|;
comment|/* Routine Begin Address */
name|totsize
operator|+=
name|write_debug_addr
argument_list|(
name|rtnentryname
argument_list|,
literal|"routine entry name"
argument_list|,
name|dosizeonly
argument_list|)
expr_stmt|;
comment|/* Routine Begin PD Address */
name|totsize
operator|+=
name|write_debug_addr
argument_list|(
name|rtnname
argument_list|,
literal|"routine procedure descriptor"
argument_list|,
name|dosizeonly
argument_list|)
expr_stmt|;
comment|/* Routine Begin Name */
name|totsize
operator|+=
name|write_debug_data1
argument_list|(
name|rtnbeg
operator|.
name|dst_b_rtnbeg_name
argument_list|,
literal|"length of routine name"
argument_list|,
name|dosizeonly
argument_list|)
expr_stmt|;
name|totsize
operator|+=
name|write_debug_string
argument_list|(
name|rtnname
argument_list|,
literal|"routine name"
argument_list|,
name|dosizeonly
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rtnentryname
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_info_level
operator|>
name|DINFO_LEVEL_TERSE
condition|)
block|{
name|prolog
operator|.
name|dst_a_prolog_header
operator|.
name|dst__header_length
operator|.
name|dst_w_length
operator|=
name|DST_K_PROLOG_SIZE
operator|-
literal|1
expr_stmt|;
name|prolog
operator|.
name|dst_a_prolog_header
operator|.
name|dst__header_type
operator|.
name|dst_w_type
operator|=
name|DST_K_PROLOG
expr_stmt|;
name|totsize
operator|+=
name|write_debug_header
argument_list|(
operator|&
name|prolog
operator|.
name|dst_a_prolog_header
argument_list|,
literal|"prolog"
argument_list|,
name|dosizeonly
argument_list|)
expr_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|label
argument_list|,
name|FUNC_PROLOG_LABEL
argument_list|,
name|rtnnum
argument_list|)
expr_stmt|;
name|totsize
operator|+=
name|write_debug_addr
argument_list|(
name|label
argument_list|,
literal|"prolog breakpoint addr"
argument_list|,
name|dosizeonly
argument_list|)
expr_stmt|;
block|}
return|return
name|totsize
return|;
block|}
end_function

begin_comment
comment|/* Output a routine end trailer for routine RTNNUM and return the header size.    Just return the size if DOSIZEONLY is non-zero.  */
end_comment

begin_function
specifier|static
name|int
name|write_rtnend
parameter_list|(
name|rtnnum
parameter_list|,
name|dosizeonly
parameter_list|)
name|int
name|rtnnum
decl_stmt|;
name|int
name|dosizeonly
decl_stmt|;
block|{
name|DST_ROUTINE_END
name|rtnend
decl_stmt|;
name|char
name|label1
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
name|char
name|label2
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
name|int
name|totsize
decl_stmt|;
name|totsize
operator|=
literal|0
expr_stmt|;
name|rtnend
operator|.
name|dst_a_rtnend_header
operator|.
name|dst__header_length
operator|.
name|dst_w_length
operator|=
name|DST_K_RTNEND_SIZE
operator|-
literal|1
expr_stmt|;
name|rtnend
operator|.
name|dst_a_rtnend_header
operator|.
name|dst__header_type
operator|.
name|dst_w_type
operator|=
name|DST_K_RTNEND
expr_stmt|;
name|rtnend
operator|.
name|dst_b_rtnend_unused
operator|=
literal|0
expr_stmt|;
name|rtnend
operator|.
name|dst_l_rtnend_size
operator|=
literal|0
expr_stmt|;
comment|/* Calculated below.  */
name|totsize
operator|+=
name|write_debug_header
argument_list|(
operator|&
name|rtnend
operator|.
name|dst_a_rtnend_header
argument_list|,
literal|"rtnend"
argument_list|,
name|dosizeonly
argument_list|)
expr_stmt|;
name|totsize
operator|+=
name|write_debug_data1
argument_list|(
name|rtnend
operator|.
name|dst_b_rtnend_unused
argument_list|,
literal|"unused"
argument_list|,
name|dosizeonly
argument_list|)
expr_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|label1
argument_list|,
name|FUNC_BEGIN_LABEL
argument_list|,
name|rtnnum
argument_list|)
expr_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|label2
argument_list|,
name|FUNC_END_LABEL
argument_list|,
name|rtnnum
argument_list|)
expr_stmt|;
name|totsize
operator|+=
name|write_debug_delta4
argument_list|(
name|label2
argument_list|,
name|label1
argument_list|,
literal|"routine size"
argument_list|,
name|dosizeonly
argument_list|)
expr_stmt|;
return|return
name|totsize
return|;
block|}
end_function

begin_define
define|#
directive|define
name|K_DELTA_PC
parameter_list|(
name|I
parameter_list|)
define|\
value|((I)< 128 ? -(I) : (I)< 65536 ? DST_K_DELTA_PC_W : DST_K_DELTA_PC_L)
end_define

begin_define
define|#
directive|define
name|K_SET_LINUM
parameter_list|(
name|I
parameter_list|)
define|\
value|((I)< 256 ? DST_K_SET_LINUM_B \   : (I)< 65536 ? DST_K_SET_LINUM : DST_K_SET_LINUM_L)
end_define

begin_define
define|#
directive|define
name|K_INCR_LINUM
parameter_list|(
name|I
parameter_list|)
define|\
value|((I)< 256 ? DST_K_INCR_LINUM \   : (I)< 65536 ? DST_K_INCR_LINUM_W : DST_K_INCR_LINUM_L)
end_define

begin_comment
comment|/* Output the PC to line number correlations and return the size.  Just return    the size if DOSIZEONLY is non-zero */
end_comment

begin_function
specifier|static
name|int
name|write_pclines
parameter_list|(
name|dosizeonly
parameter_list|)
name|int
name|dosizeonly
decl_stmt|;
block|{
name|unsigned
name|i
decl_stmt|;
name|int
name|fn
decl_stmt|;
name|int
name|ln
decl_stmt|,
name|lastln
decl_stmt|;
name|int
name|linestart
init|=
literal|0
decl_stmt|;
name|int
name|max_line
decl_stmt|;
name|DST_LINE_NUM_HEADER
name|line_num
decl_stmt|;
name|DST_PCLINE_COMMANDS
name|pcline
decl_stmt|;
name|char
name|label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
name|char
name|lastlabel
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
name|int
name|totsize
init|=
literal|0
decl_stmt|;
name|char
name|buff
index|[
literal|256
index|]
decl_stmt|;
name|max_line
operator|=
name|file_info_table
index|[
literal|1
index|]
operator|.
name|max_line
expr_stmt|;
name|file_info_table
index|[
literal|1
index|]
operator|.
name|listing_line_start
operator|=
name|linestart
expr_stmt|;
name|linestart
operator|=
name|linestart
operator|+
operator|(
operator|(
name|max_line
operator|/
literal|100000
operator|)
operator|+
literal|1
operator|)
operator|*
literal|100000
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|file_info_table_in_use
condition|;
name|i
operator|++
control|)
block|{
name|max_line
operator|=
name|file_info_table
index|[
name|i
index|]
operator|.
name|max_line
expr_stmt|;
name|file_info_table
index|[
name|i
index|]
operator|.
name|listing_line_start
operator|=
name|linestart
expr_stmt|;
name|linestart
operator|=
name|linestart
operator|+
operator|(
operator|(
name|max_line
operator|/
literal|10000
operator|)
operator|+
literal|1
operator|)
operator|*
literal|10000
expr_stmt|;
block|}
comment|/* Set starting address to beginning of text section */
name|line_num
operator|.
name|dst_a_line_num_header
operator|.
name|dst__header_length
operator|.
name|dst_w_length
operator|=
literal|8
expr_stmt|;
name|line_num
operator|.
name|dst_a_line_num_header
operator|.
name|dst__header_type
operator|.
name|dst_w_type
operator|=
name|DST_K_LINE_NUM
expr_stmt|;
name|pcline
operator|.
name|dst_b_pcline_command
operator|=
name|DST_K_SET_ABS_PC
expr_stmt|;
name|totsize
operator|+=
name|write_debug_header
argument_list|(
operator|&
name|line_num
operator|.
name|dst_a_line_num_header
argument_list|,
literal|"line_num"
argument_list|,
name|dosizeonly
argument_list|)
expr_stmt|;
name|totsize
operator|+=
name|write_debug_data1
argument_list|(
name|pcline
operator|.
name|dst_b_pcline_command
argument_list|,
literal|"line_num (SET ABS PC)"
argument_list|,
name|dosizeonly
argument_list|)
expr_stmt|;
if|if
condition|(
name|dosizeonly
condition|)
name|totsize
operator|+=
literal|4
expr_stmt|;
else|else
block|{
name|ASM_OUTPUT_DEBUG_ADDR
argument_list|(
name|asm_out_file
argument_list|,
name|TEXT_SECTION_ASM_OP
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_verbose_asm
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s line_num"
argument_list|,
name|ASM_COMMENT_START
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
name|fn
operator|=
name|line_info_table
index|[
literal|1
index|]
operator|.
name|dst_file_num
expr_stmt|;
name|ln
operator|=
operator|(
name|file_info_table
index|[
name|fn
index|]
operator|.
name|listing_line_start
operator|+
name|line_info_table
index|[
literal|1
index|]
operator|.
name|dst_line_num
operator|)
expr_stmt|;
name|line_num
operator|.
name|dst_a_line_num_header
operator|.
name|dst__header_length
operator|.
name|dst_w_length
operator|=
literal|4
operator|+
literal|4
expr_stmt|;
name|pcline
operator|.
name|dst_b_pcline_command
operator|=
name|DST_K_SET_LINUM_L
expr_stmt|;
name|totsize
operator|+=
name|write_debug_header
argument_list|(
operator|&
name|line_num
operator|.
name|dst_a_line_num_header
argument_list|,
literal|"line_num"
argument_list|,
name|dosizeonly
argument_list|)
expr_stmt|;
name|totsize
operator|+=
name|write_debug_data1
argument_list|(
name|pcline
operator|.
name|dst_b_pcline_command
argument_list|,
literal|"line_num (SET LINUM LONG)"
argument_list|,
name|dosizeonly
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"line_num (%d)"
argument_list|,
name|ln
operator|-
literal|1
argument_list|)
expr_stmt|;
name|totsize
operator|+=
name|write_debug_data4
argument_list|(
name|ln
operator|-
literal|1
argument_list|,
name|buff
argument_list|,
name|dosizeonly
argument_list|)
expr_stmt|;
name|lastln
operator|=
name|ln
expr_stmt|;
name|strcpy
argument_list|(
name|lastlabel
argument_list|,
name|TEXT_SECTION_ASM_OP
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|line_info_table_in_use
condition|;
name|i
operator|++
control|)
block|{
name|int
name|extrabytes
decl_stmt|;
name|fn
operator|=
name|line_info_table
index|[
name|i
index|]
operator|.
name|dst_file_num
expr_stmt|;
name|ln
operator|=
operator|(
name|file_info_table
index|[
name|fn
index|]
operator|.
name|listing_line_start
operator|+
name|line_info_table
index|[
name|i
index|]
operator|.
name|dst_line_num
operator|)
expr_stmt|;
if|if
condition|(
name|ln
operator|-
name|lastln
operator|>
literal|1
condition|)
name|extrabytes
operator|=
literal|5
expr_stmt|;
comment|/* NUMBYTES (ln - lastln - 1) + 1; */
elseif|else
if|if
condition|(
name|ln
operator|<=
name|lastln
condition|)
name|extrabytes
operator|=
literal|5
expr_stmt|;
comment|/* NUMBYTES (ln - 1) + 1; */
else|else
name|extrabytes
operator|=
literal|0
expr_stmt|;
name|line_num
operator|.
name|dst_a_line_num_header
operator|.
name|dst__header_length
operator|.
name|dst_w_length
operator|=
literal|8
operator|+
name|extrabytes
expr_stmt|;
name|totsize
operator|+=
name|write_debug_header
argument_list|(
operator|&
name|line_num
operator|.
name|dst_a_line_num_header
argument_list|,
literal|"line_num"
argument_list|,
name|dosizeonly
argument_list|)
expr_stmt|;
if|if
condition|(
name|ln
operator|-
name|lastln
operator|>
literal|1
condition|)
block|{
name|int
name|lndif
init|=
name|ln
operator|-
name|lastln
operator|-
literal|1
decl_stmt|;
comment|/* K_INCR_LINUM (lndif); */
name|pcline
operator|.
name|dst_b_pcline_command
operator|=
name|DST_K_INCR_LINUM_L
expr_stmt|;
name|totsize
operator|+=
name|write_debug_data1
argument_list|(
name|pcline
operator|.
name|dst_b_pcline_command
argument_list|,
literal|"line_num (INCR LINUM LONG)"
argument_list|,
name|dosizeonly
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"line_num (%d)"
argument_list|,
name|lndif
argument_list|)
expr_stmt|;
name|totsize
operator|+=
name|write_debug_data4
argument_list|(
name|lndif
argument_list|,
name|buff
argument_list|,
name|dosizeonly
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ln
operator|<=
name|lastln
condition|)
block|{
comment|/* K_SET_LINUM (ln-1); */
name|pcline
operator|.
name|dst_b_pcline_command
operator|=
name|DST_K_SET_LINUM_L
expr_stmt|;
name|totsize
operator|+=
name|write_debug_data1
argument_list|(
name|pcline
operator|.
name|dst_b_pcline_command
argument_list|,
literal|"line_num (SET LINUM LONG)"
argument_list|,
name|dosizeonly
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"line_num (%d)"
argument_list|,
name|ln
operator|-
literal|1
argument_list|)
expr_stmt|;
name|totsize
operator|+=
name|write_debug_data4
argument_list|(
name|ln
operator|-
literal|1
argument_list|,
name|buff
argument_list|,
name|dosizeonly
argument_list|)
expr_stmt|;
block|}
name|pcline
operator|.
name|dst_b_pcline_command
operator|=
name|DST_K_DELTA_PC_L
expr_stmt|;
name|totsize
operator|+=
name|write_debug_data1
argument_list|(
name|pcline
operator|.
name|dst_b_pcline_command
argument_list|,
literal|"line_num (DELTA PC LONG)"
argument_list|,
name|dosizeonly
argument_list|)
expr_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|label
argument_list|,
name|LINE_CODE_LABEL
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|totsize
operator|+=
name|write_debug_delta4
argument_list|(
name|label
argument_list|,
name|lastlabel
argument_list|,
literal|"increment line_num"
argument_list|,
name|dosizeonly
argument_list|)
expr_stmt|;
name|lastln
operator|=
name|ln
expr_stmt|;
name|strcpy
argument_list|(
name|lastlabel
argument_list|,
name|label
argument_list|)
expr_stmt|;
block|}
return|return
name|totsize
return|;
block|}
end_function

begin_comment
comment|/* Output a source correlation for file FILEID using information saved in    FILE_INFO_ENTRY and return the size.  Just return the size if DOSIZEONLY is    non-zero.  */
end_comment

begin_function
specifier|static
name|int
name|write_srccorr
parameter_list|(
name|fileid
parameter_list|,
name|file_info_entry
parameter_list|,
name|dosizeonly
parameter_list|)
name|int
name|fileid
decl_stmt|;
name|dst_file_info_entry
name|file_info_entry
decl_stmt|;
name|int
name|dosizeonly
decl_stmt|;
block|{
name|int
name|src_command_size
decl_stmt|;
name|int
name|linesleft
init|=
name|file_info_entry
operator|.
name|max_line
decl_stmt|;
name|int
name|linestart
init|=
name|file_info_entry
operator|.
name|listing_line_start
decl_stmt|;
name|int
name|flen
init|=
name|file_info_entry
operator|.
name|flen
decl_stmt|;
name|int
name|linestodo
init|=
literal|0
decl_stmt|;
name|DST_SOURCE_CORR
name|src_header
decl_stmt|;
name|DST_SRC_COMMAND
name|src_command
decl_stmt|;
name|DST_SRC_COMMAND
name|src_command_sf
decl_stmt|;
name|DST_SRC_COMMAND
name|src_command_sl
decl_stmt|;
name|DST_SRC_COMMAND
name|src_command_sr
decl_stmt|;
name|DST_SRC_COMMAND
name|src_command_dl
decl_stmt|;
name|DST_SRC_CMDTRLR
name|src_cmdtrlr
decl_stmt|;
name|char
name|buff
index|[
literal|256
index|]
decl_stmt|;
name|int
name|totsize
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|fileid
operator|==
literal|1
condition|)
block|{
name|src_header
operator|.
name|dst_a_source_corr_header
operator|.
name|dst__header_length
operator|.
name|dst_w_length
operator|=
name|DST_K_SOURCE_CORR_HEADER_SIZE
operator|+
literal|1
operator|-
literal|1
expr_stmt|;
name|src_header
operator|.
name|dst_a_source_corr_header
operator|.
name|dst__header_type
operator|.
name|dst_w_type
operator|=
name|DST_K_SOURCE
expr_stmt|;
name|src_command
operator|.
name|dst_b_src_command
operator|=
name|DST_K_SRC_FORMFEED
expr_stmt|;
name|totsize
operator|+=
name|write_debug_header
argument_list|(
operator|&
name|src_header
operator|.
name|dst_a_source_corr_header
argument_list|,
literal|"source corr"
argument_list|,
name|dosizeonly
argument_list|)
expr_stmt|;
name|totsize
operator|+=
name|write_debug_data1
argument_list|(
name|src_command
operator|.
name|dst_b_src_command
argument_list|,
literal|"source_corr (SRC FORMFEED)"
argument_list|,
name|dosizeonly
argument_list|)
expr_stmt|;
block|}
name|src_command_size
operator|=
name|DST_K_SRC_COMMAND_SIZE
operator|+
name|flen
operator|+
name|DST_K_SRC_CMDTRLR_SIZE
expr_stmt|;
name|src_command
operator|.
name|dst_b_src_command
operator|=
name|DST_K_SRC_DECLFILE
expr_stmt|;
name|src_command
operator|.
name|dst_a_src_cmd_fields
operator|.
name|dst_a_src_decl_src
operator|.
name|dst_b_src_df_length
operator|=
name|src_command_size
operator|-
literal|2
expr_stmt|;
name|src_command
operator|.
name|dst_a_src_cmd_fields
operator|.
name|dst_a_src_decl_src
operator|.
name|dst_b_src_df_flags
operator|=
literal|0
expr_stmt|;
name|src_command
operator|.
name|dst_a_src_cmd_fields
operator|.
name|dst_a_src_decl_src
operator|.
name|dst_w_src_df_fileid
operator|=
name|fileid
expr_stmt|;
name|src_command
operator|.
name|dst_a_src_cmd_fields
operator|.
name|dst_a_src_decl_src
operator|.
name|dst_q_src_df_rms_cdt
operator|=
name|file_info_entry
operator|.
name|cdt
expr_stmt|;
name|src_command
operator|.
name|dst_a_src_cmd_fields
operator|.
name|dst_a_src_decl_src
operator|.
name|dst_l_src_df_rms_ebk
operator|=
name|file_info_entry
operator|.
name|ebk
expr_stmt|;
name|src_command
operator|.
name|dst_a_src_cmd_fields
operator|.
name|dst_a_src_decl_src
operator|.
name|dst_w_src_df_rms_ffb
operator|=
name|file_info_entry
operator|.
name|ffb
expr_stmt|;
name|src_command
operator|.
name|dst_a_src_cmd_fields
operator|.
name|dst_a_src_decl_src
operator|.
name|dst_b_src_df_rms_rfo
operator|=
name|file_info_entry
operator|.
name|rfo
expr_stmt|;
name|src_command
operator|.
name|dst_a_src_cmd_fields
operator|.
name|dst_a_src_decl_src
operator|.
name|dst_b_src_df_filename
operator|=
name|file_info_entry
operator|.
name|flen
expr_stmt|;
name|src_header
operator|.
name|dst_a_source_corr_header
operator|.
name|dst__header_length
operator|.
name|dst_w_length
operator|=
name|DST_K_SOURCE_CORR_HEADER_SIZE
operator|+
name|src_command_size
operator|-
literal|1
expr_stmt|;
name|src_header
operator|.
name|dst_a_source_corr_header
operator|.
name|dst__header_type
operator|.
name|dst_w_type
operator|=
name|DST_K_SOURCE
expr_stmt|;
name|src_cmdtrlr
operator|.
name|dst_b_src_df_libmodname
operator|=
literal|0
expr_stmt|;
name|totsize
operator|+=
name|write_debug_header
argument_list|(
operator|&
name|src_header
operator|.
name|dst_a_source_corr_header
argument_list|,
literal|"source corr"
argument_list|,
name|dosizeonly
argument_list|)
expr_stmt|;
name|totsize
operator|+=
name|write_debug_data1
argument_list|(
name|src_command
operator|.
name|dst_b_src_command
argument_list|,
literal|"source_corr (DECL SRC FILE)"
argument_list|,
name|dosizeonly
argument_list|)
expr_stmt|;
name|totsize
operator|+=
name|write_debug_data1
argument_list|(
name|src_command
operator|.
name|dst_a_src_cmd_fields
operator|.
name|dst_a_src_decl_src
operator|.
name|dst_b_src_df_length
argument_list|,
literal|"source_corr (length)"
argument_list|,
name|dosizeonly
argument_list|)
expr_stmt|;
name|totsize
operator|+=
name|write_debug_data1
argument_list|(
name|src_command
operator|.
name|dst_a_src_cmd_fields
operator|.
name|dst_a_src_decl_src
operator|.
name|dst_b_src_df_flags
argument_list|,
literal|"source_corr (flags)"
argument_list|,
name|dosizeonly
argument_list|)
expr_stmt|;
name|totsize
operator|+=
name|write_debug_data2
argument_list|(
name|src_command
operator|.
name|dst_a_src_cmd_fields
operator|.
name|dst_a_src_decl_src
operator|.
name|dst_w_src_df_fileid
argument_list|,
literal|"source_corr (fileid)"
argument_list|,
name|dosizeonly
argument_list|)
expr_stmt|;
name|totsize
operator|+=
name|write_debug_data8
argument_list|(
name|src_command
operator|.
name|dst_a_src_cmd_fields
operator|.
name|dst_a_src_decl_src
operator|.
name|dst_q_src_df_rms_cdt
argument_list|,
literal|"source_corr (creation date)"
argument_list|,
name|dosizeonly
argument_list|)
expr_stmt|;
name|totsize
operator|+=
name|write_debug_data4
argument_list|(
name|src_command
operator|.
name|dst_a_src_cmd_fields
operator|.
name|dst_a_src_decl_src
operator|.
name|dst_l_src_df_rms_ebk
argument_list|,
literal|"source_corr (EOF block number)"
argument_list|,
name|dosizeonly
argument_list|)
expr_stmt|;
name|totsize
operator|+=
name|write_debug_data2
argument_list|(
name|src_command
operator|.
name|dst_a_src_cmd_fields
operator|.
name|dst_a_src_decl_src
operator|.
name|dst_w_src_df_rms_ffb
argument_list|,
literal|"source_corr (first free byte)"
argument_list|,
name|dosizeonly
argument_list|)
expr_stmt|;
name|totsize
operator|+=
name|write_debug_data1
argument_list|(
name|src_command
operator|.
name|dst_a_src_cmd_fields
operator|.
name|dst_a_src_decl_src
operator|.
name|dst_b_src_df_rms_rfo
argument_list|,
literal|"source_corr (record and file organization)"
argument_list|,
name|dosizeonly
argument_list|)
expr_stmt|;
name|totsize
operator|+=
name|write_debug_data1
argument_list|(
name|src_command
operator|.
name|dst_a_src_cmd_fields
operator|.
name|dst_a_src_decl_src
operator|.
name|dst_b_src_df_filename
argument_list|,
literal|"source_corr (filename length)"
argument_list|,
name|dosizeonly
argument_list|)
expr_stmt|;
name|totsize
operator|+=
name|write_debug_string
argument_list|(
name|file_info_entry
operator|.
name|file_name
argument_list|,
literal|"source file name"
argument_list|,
name|dosizeonly
argument_list|)
expr_stmt|;
name|totsize
operator|+=
name|write_debug_data1
argument_list|(
name|src_cmdtrlr
operator|.
name|dst_b_src_df_libmodname
argument_list|,
literal|"source_corr (libmodname)"
argument_list|,
name|dosizeonly
argument_list|)
expr_stmt|;
name|src_command_sf
operator|.
name|dst_b_src_command
operator|=
name|DST_K_SRC_SETFILE
expr_stmt|;
name|src_command_sf
operator|.
name|dst_a_src_cmd_fields
operator|.
name|dst_w_src_unsword
operator|=
name|fileid
expr_stmt|;
name|src_command_sr
operator|.
name|dst_b_src_command
operator|=
name|DST_K_SRC_SETREC_W
expr_stmt|;
name|src_command_sr
operator|.
name|dst_a_src_cmd_fields
operator|.
name|dst_w_src_unsword
operator|=
literal|1
expr_stmt|;
name|src_command_sl
operator|.
name|dst_b_src_command
operator|=
name|DST_K_SRC_SETLNUM_L
expr_stmt|;
name|src_command_sl
operator|.
name|dst_a_src_cmd_fields
operator|.
name|dst_l_src_unslong
operator|=
name|linestart
operator|+
literal|1
expr_stmt|;
name|src_command_dl
operator|.
name|dst_b_src_command
operator|=
name|DST_K_SRC_DEFLINES_W
expr_stmt|;
if|if
condition|(
name|linesleft
operator|>
literal|65534
condition|)
name|linesleft
operator|=
name|linesleft
operator|-
literal|65534
operator|,
name|linestodo
operator|=
literal|65534
expr_stmt|;
else|else
name|linestodo
operator|=
name|linesleft
operator|,
name|linesleft
operator|=
literal|0
expr_stmt|;
name|src_command_dl
operator|.
name|dst_a_src_cmd_fields
operator|.
name|dst_w_src_unsword
operator|=
name|linestodo
expr_stmt|;
name|src_header
operator|.
name|dst_a_source_corr_header
operator|.
name|dst__header_length
operator|.
name|dst_w_length
operator|=
name|DST_K_SOURCE_CORR_HEADER_SIZE
operator|+
literal|3
operator|+
literal|3
operator|+
literal|5
operator|+
literal|3
operator|-
literal|1
expr_stmt|;
name|src_header
operator|.
name|dst_a_source_corr_header
operator|.
name|dst__header_type
operator|.
name|dst_w_type
operator|=
name|DST_K_SOURCE
expr_stmt|;
name|totsize
operator|+=
name|write_debug_header
argument_list|(
operator|&
name|src_header
operator|.
name|dst_a_source_corr_header
argument_list|,
literal|"source corr"
argument_list|,
name|dosizeonly
argument_list|)
expr_stmt|;
name|totsize
operator|+=
name|write_debug_data1
argument_list|(
name|src_command_sf
operator|.
name|dst_b_src_command
argument_list|,
literal|"source_corr (src setfile)"
argument_list|,
name|dosizeonly
argument_list|)
expr_stmt|;
name|totsize
operator|+=
name|write_debug_data2
argument_list|(
name|src_command_sf
operator|.
name|dst_a_src_cmd_fields
operator|.
name|dst_w_src_unsword
argument_list|,
literal|"source_corr (fileid)"
argument_list|,
name|dosizeonly
argument_list|)
expr_stmt|;
name|totsize
operator|+=
name|write_debug_data1
argument_list|(
name|src_command_sr
operator|.
name|dst_b_src_command
argument_list|,
literal|"source_corr (setrec)"
argument_list|,
name|dosizeonly
argument_list|)
expr_stmt|;
name|totsize
operator|+=
name|write_debug_data2
argument_list|(
name|src_command_sr
operator|.
name|dst_a_src_cmd_fields
operator|.
name|dst_w_src_unsword
argument_list|,
literal|"source_corr (recnum)"
argument_list|,
name|dosizeonly
argument_list|)
expr_stmt|;
name|totsize
operator|+=
name|write_debug_data1
argument_list|(
name|src_command_sl
operator|.
name|dst_b_src_command
argument_list|,
literal|"source_corr (setlnum)"
argument_list|,
name|dosizeonly
argument_list|)
expr_stmt|;
name|totsize
operator|+=
name|write_debug_data4
argument_list|(
name|src_command_sl
operator|.
name|dst_a_src_cmd_fields
operator|.
name|dst_l_src_unslong
argument_list|,
literal|"source_corr (linenum)"
argument_list|,
name|dosizeonly
argument_list|)
expr_stmt|;
name|totsize
operator|+=
name|write_debug_data1
argument_list|(
name|src_command_dl
operator|.
name|dst_b_src_command
argument_list|,
literal|"source_corr (deflines)"
argument_list|,
name|dosizeonly
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"source_corr (%d)"
argument_list|,
name|src_command_dl
operator|.
name|dst_a_src_cmd_fields
operator|.
name|dst_w_src_unsword
argument_list|)
expr_stmt|;
name|totsize
operator|+=
name|write_debug_data2
argument_list|(
name|src_command_dl
operator|.
name|dst_a_src_cmd_fields
operator|.
name|dst_w_src_unsword
argument_list|,
name|buff
argument_list|,
name|dosizeonly
argument_list|)
expr_stmt|;
while|while
condition|(
name|linesleft
operator|>
literal|0
condition|)
block|{
name|src_header
operator|.
name|dst_a_source_corr_header
operator|.
name|dst__header_length
operator|.
name|dst_w_length
operator|=
name|DST_K_SOURCE_CORR_HEADER_SIZE
operator|+
literal|3
operator|-
literal|1
expr_stmt|;
name|src_header
operator|.
name|dst_a_source_corr_header
operator|.
name|dst__header_type
operator|.
name|dst_w_type
operator|=
name|DST_K_SOURCE
expr_stmt|;
name|src_command_dl
operator|.
name|dst_b_src_command
operator|=
name|DST_K_SRC_DEFLINES_W
expr_stmt|;
if|if
condition|(
name|linesleft
operator|>
literal|65534
condition|)
name|linesleft
operator|=
name|linesleft
operator|-
literal|65534
operator|,
name|linestodo
operator|=
literal|65534
expr_stmt|;
else|else
name|linestodo
operator|=
name|linesleft
operator|,
name|linesleft
operator|=
literal|0
expr_stmt|;
name|src_command_dl
operator|.
name|dst_a_src_cmd_fields
operator|.
name|dst_w_src_unsword
operator|=
name|linestodo
expr_stmt|;
name|totsize
operator|+=
name|write_debug_header
argument_list|(
operator|&
name|src_header
operator|.
name|dst_a_source_corr_header
argument_list|,
literal|"source corr"
argument_list|,
name|dosizeonly
argument_list|)
expr_stmt|;
name|totsize
operator|+=
name|write_debug_data1
argument_list|(
name|src_command_dl
operator|.
name|dst_b_src_command
argument_list|,
literal|"source_corr (deflines)"
argument_list|,
name|dosizeonly
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"source_corr (%d)"
argument_list|,
name|src_command_dl
operator|.
name|dst_a_src_cmd_fields
operator|.
name|dst_w_src_unsword
argument_list|)
expr_stmt|;
name|totsize
operator|+=
name|write_debug_data2
argument_list|(
name|src_command_dl
operator|.
name|dst_a_src_cmd_fields
operator|.
name|dst_w_src_unsword
argument_list|,
name|buff
argument_list|,
name|dosizeonly
argument_list|)
expr_stmt|;
block|}
return|return
name|totsize
return|;
block|}
end_function

begin_comment
comment|/* Output all the source correlation entries and return the size.  Just return    the size if DOSIZEONLY is non-zero.  */
end_comment

begin_function
specifier|static
name|int
name|write_srccorrs
parameter_list|(
name|dosizeonly
parameter_list|)
name|int
name|dosizeonly
decl_stmt|;
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|int
name|totsize
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|file_info_table_in_use
condition|;
name|i
operator|++
control|)
name|totsize
operator|+=
name|write_srccorr
argument_list|(
name|i
argument_list|,
name|file_info_table
index|[
name|i
index|]
argument_list|,
name|dosizeonly
argument_list|)
expr_stmt|;
return|return
name|totsize
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output a marker (i.e. a label) for the beginning of a function, before    the prologue.  */
end_comment

begin_function
specifier|static
name|void
name|vmsdbgout_begin_prologue
parameter_list|(
name|line
parameter_list|,
name|file
parameter_list|)
name|unsigned
name|int
name|line
decl_stmt|;
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
block|{
name|char
name|label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
if|if
condition|(
name|write_symbols
operator|==
name|VMS_AND_DWARF2_DEBUG
condition|)
call|(
modifier|*
name|dwarf2_debug_hooks
operator|.
name|begin_prologue
call|)
argument_list|(
name|line
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_info_level
operator|>
name|DINFO_LEVEL_NONE
condition|)
block|{
name|current_funcdef_number
operator|++
expr_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|label
argument_list|,
name|FUNC_BEGIN_LABEL
argument_list|,
name|current_funcdef_number
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|label
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Output a marker (i.e. a label) for the beginning of a function, after    the prologue.  */
end_comment

begin_function
name|void
name|vmsdbgout_after_prologue
parameter_list|()
block|{
name|char
name|label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
if|if
condition|(
name|debug_info_level
operator|>
name|DINFO_LEVEL_TERSE
condition|)
block|{
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|label
argument_list|,
name|FUNC_PROLOG_LABEL
argument_list|,
name|current_funcdef_number
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|label
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Output a marker (i.e. a label) for the absolute end of the generated code    for a function definition.  This gets called *after* the epilogue code has    been generated.  */
end_comment

begin_function
specifier|static
name|void
name|vmsdbgout_end_epilogue
parameter_list|()
block|{
name|char
name|label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
if|if
condition|(
name|write_symbols
operator|==
name|VMS_AND_DWARF2_DEBUG
condition|)
call|(
modifier|*
name|dwarf2_debug_hooks
operator|.
name|end_epilogue
call|)
argument_list|()
expr_stmt|;
if|if
condition|(
name|debug_info_level
operator|>
name|DINFO_LEVEL_NONE
condition|)
block|{
comment|/* Output a label to mark the endpoint of the code generated for this          function.  */
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|label
argument_list|,
name|FUNC_END_LABEL
argument_list|,
name|current_funcdef_number
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|label
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Output a marker (i.e. a label) for the beginning of the generated code for    a lexical block.  */
end_comment

begin_function
specifier|static
name|void
name|vmsdbgout_begin_block
parameter_list|(
name|line
parameter_list|,
name|blocknum
parameter_list|)
specifier|register
name|unsigned
name|line
decl_stmt|;
specifier|register
name|unsigned
name|blocknum
decl_stmt|;
block|{
if|if
condition|(
name|write_symbols
operator|==
name|VMS_AND_DWARF2_DEBUG
condition|)
call|(
modifier|*
name|dwarf2_debug_hooks
operator|.
name|begin_block
call|)
argument_list|(
name|line
argument_list|,
name|blocknum
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_info_level
operator|>
name|DINFO_LEVEL_TERSE
condition|)
name|ASM_OUTPUT_INTERNAL_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|BLOCK_BEGIN_LABEL
argument_list|,
name|blocknum
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output a marker (i.e. a label) for the end of the generated code for a    lexical block.  */
end_comment

begin_function
specifier|static
name|void
name|vmsdbgout_end_block
parameter_list|(
name|line
parameter_list|,
name|blocknum
parameter_list|)
specifier|register
name|unsigned
name|line
decl_stmt|;
specifier|register
name|unsigned
name|blocknum
decl_stmt|;
block|{
if|if
condition|(
name|write_symbols
operator|==
name|VMS_AND_DWARF2_DEBUG
condition|)
call|(
modifier|*
name|dwarf2_debug_hooks
operator|.
name|end_block
call|)
argument_list|(
name|line
argument_list|,
name|blocknum
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_info_level
operator|>
name|DINFO_LEVEL_TERSE
condition|)
name|ASM_OUTPUT_INTERNAL_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|BLOCK_END_LABEL
argument_list|,
name|blocknum
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Not implemented in VMS Debug.  */
end_comment

begin_function
specifier|static
name|bool
name|vmsdbgout_ignore_block
parameter_list|(
name|block
parameter_list|)
name|tree
name|block
decl_stmt|;
block|{
name|bool
name|retval
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|write_symbols
operator|==
name|VMS_AND_DWARF2_DEBUG
condition|)
name|retval
operator|=
call|(
modifier|*
name|dwarf2_debug_hooks
operator|.
name|ignore_block
call|)
argument_list|(
name|block
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* Add an entry for function DECL into the func_table.  */
end_comment

begin_function
specifier|static
name|void
name|vmsdbgout_begin_function
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|write_symbols
operator|==
name|VMS_AND_DWARF2_DEBUG
condition|)
call|(
modifier|*
name|dwarf2_debug_hooks
operator|.
name|begin_function
call|)
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|func_table_in_use
operator|==
name|func_table_allocated
condition|)
block|{
name|func_table_allocated
operator|+=
name|FUNC_TABLE_INCREMENT
expr_stmt|;
name|func_table
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|func_table
argument_list|,
name|func_table_allocated
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Add the new entry to the end of the function name table.  */
name|func_table
index|[
name|func_table_in_use
operator|++
index|]
operator|=
name|xstrdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
name|fullname_buff
index|[
literal|4096
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return the full file specification for FILENAME.  The specification must be    in VMS syntax in order to be processed by VMS Debug.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|full_name
parameter_list|(
name|filename
parameter_list|)
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|VMS
name|FILE
modifier|*
name|fp
init|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
decl_stmt|;
name|fgetname
argument_list|(
name|fp
argument_list|,
name|fullname_buff
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
else|#
directive|else
name|getcwd
argument_list|(
name|fullname_buff
argument_list|,
sizeof|sizeof
argument_list|(
name|fullname_buff
argument_list|)
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|fullname_buff
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|fullname_buff
argument_list|,
name|filename
argument_list|)
expr_stmt|;
comment|/* ??? Insert hairy code here to translate Unix style file specification      to VMS style.  */
endif|#
directive|endif
return|return
name|fullname_buff
return|;
block|}
end_function

begin_comment
comment|/* Lookup a filename (in the list of filenames that we know about here in    vmsdbgout.c) and return its "index".  The index of each (known) filename is    just a unique number which is associated with only that one filename.  We    need such numbers for the sake of generating labels  and references    to those files numbers.  If the filename given as an argument is not    found in our current list, add it to the list and assign it the next    available unique index number.  In order to speed up searches, we remember    the index of the filename was looked up last.  This handles the majority of    all searches.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|lookup_filename
parameter_list|(
name|file_name
parameter_list|)
specifier|const
name|char
modifier|*
name|file_name
decl_stmt|;
block|{
specifier|static
name|unsigned
name|int
name|last_file_lookup_index
init|=
literal|0
decl_stmt|;
specifier|register
name|char
modifier|*
name|fn
decl_stmt|;
specifier|register
name|unsigned
name|i
decl_stmt|;
name|char
modifier|*
name|fnam
decl_stmt|;
name|long
name|long
name|cdt
decl_stmt|;
name|long
name|ebk
decl_stmt|;
name|short
name|ffb
decl_stmt|;
name|char
name|rfo
decl_stmt|;
name|char
name|flen
decl_stmt|;
name|struct
name|stat
name|statbuf
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|file_name
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cdt
operator|=
literal|10000000
operator|*
operator|(
name|statbuf
operator|.
name|st_ctime
operator|+
name|vms_epoch_offset
operator|)
expr_stmt|;
name|ebk
operator|=
name|statbuf
operator|.
name|st_size
operator|/
literal|512
operator|+
literal|1
expr_stmt|;
name|ffb
operator|=
name|statbuf
operator|.
name|st_size
operator|-
operator|(
operator|(
name|statbuf
operator|.
name|st_size
operator|/
literal|512
operator|)
operator|*
literal|512
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VMS
name|rfo
operator|=
name|statbuf
operator|.
name|st_fab_rfm
expr_stmt|;
else|#
directive|else
comment|/* Assume stream LF type file */
name|rfo
operator|=
literal|2
expr_stmt|;
endif|#
directive|endif
name|fnam
operator|=
name|full_name
argument_list|(
name|file_name
argument_list|)
expr_stmt|;
name|flen
operator|=
name|strlen
argument_list|(
name|fnam
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cdt
operator|=
literal|0
expr_stmt|;
name|ebk
operator|=
literal|0
expr_stmt|;
name|ffb
operator|=
literal|0
expr_stmt|;
name|rfo
operator|=
literal|0
expr_stmt|;
name|fnam
operator|=
operator|(
name|char
operator|*
operator|)
literal|""
expr_stmt|;
name|flen
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Check to see if the file name that was searched on the previous call      matches this file name. If so, return the index.  */
if|if
condition|(
name|last_file_lookup_index
operator|!=
literal|0
condition|)
block|{
name|fn
operator|=
name|file_info_table
index|[
name|last_file_lookup_index
index|]
operator|.
name|file_name
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|fnam
argument_list|,
name|fn
argument_list|)
operator|==
literal|0
condition|)
return|return
name|last_file_lookup_index
return|;
block|}
comment|/* Didn't match the previous lookup, search the table */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|file_info_table_in_use
condition|;
operator|++
name|i
control|)
block|{
name|fn
operator|=
name|file_info_table
index|[
name|i
index|]
operator|.
name|file_name
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|fnam
argument_list|,
name|fn
argument_list|)
operator|==
literal|0
condition|)
block|{
name|last_file_lookup_index
operator|=
name|i
expr_stmt|;
return|return
name|i
return|;
block|}
block|}
comment|/* Prepare to add a new table entry by making sure there is enough space in       the table to do so.  If not, expand the current table.  */
if|if
condition|(
name|file_info_table_in_use
operator|==
name|file_info_table_allocated
condition|)
block|{
name|file_info_table_allocated
operator|+=
name|FILE_TABLE_INCREMENT
expr_stmt|;
name|file_info_table
operator|=
operator|(
name|dst_file_info_ref
operator|)
name|xrealloc
argument_list|(
name|file_info_table
argument_list|,
operator|(
name|file_info_table_allocated
operator|*
sizeof|sizeof
argument_list|(
name|dst_file_info_entry
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* Add the new entry to the end of the filename table.  */
name|file_info_table
index|[
name|file_info_table_in_use
index|]
operator|.
name|file_name
operator|=
name|xstrdup
argument_list|(
name|fnam
argument_list|)
expr_stmt|;
name|file_info_table
index|[
name|file_info_table_in_use
index|]
operator|.
name|max_line
operator|=
literal|0
expr_stmt|;
name|file_info_table
index|[
name|file_info_table_in_use
index|]
operator|.
name|cdt
operator|=
name|cdt
expr_stmt|;
name|file_info_table
index|[
name|file_info_table_in_use
index|]
operator|.
name|ebk
operator|=
name|ebk
expr_stmt|;
name|file_info_table
index|[
name|file_info_table_in_use
index|]
operator|.
name|ffb
operator|=
name|ffb
expr_stmt|;
name|file_info_table
index|[
name|file_info_table_in_use
index|]
operator|.
name|rfo
operator|=
name|rfo
expr_stmt|;
name|file_info_table
index|[
name|file_info_table_in_use
index|]
operator|.
name|flen
operator|=
name|flen
expr_stmt|;
name|last_file_lookup_index
operator|=
name|file_info_table_in_use
operator|++
expr_stmt|;
return|return
name|last_file_lookup_index
return|;
block|}
end_function

begin_comment
comment|/* Output a label to mark the beginning of a source code line entry    and record information relating to this source line, in    'line_info_table' for later output of the .debug_line section.  */
end_comment

begin_function
specifier|static
name|void
name|vmsdbgout_source_line
parameter_list|(
name|line
parameter_list|,
name|filename
parameter_list|)
specifier|register
name|unsigned
name|line
decl_stmt|;
specifier|register
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
block|{
if|if
condition|(
name|write_symbols
operator|==
name|VMS_AND_DWARF2_DEBUG
condition|)
call|(
modifier|*
name|dwarf2_debug_hooks
operator|.
name|source_line
call|)
argument_list|(
name|line
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_info_level
operator|>=
name|DINFO_LEVEL_TERSE
condition|)
block|{
name|dst_line_info_ref
name|line_info
decl_stmt|;
name|ASM_OUTPUT_INTERNAL_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|LINE_CODE_LABEL
argument_list|,
name|line_info_table_in_use
argument_list|)
expr_stmt|;
comment|/* Expand the line info table if necessary.  */
if|if
condition|(
name|line_info_table_in_use
operator|==
name|line_info_table_allocated
condition|)
block|{
name|line_info_table_allocated
operator|+=
name|LINE_INFO_TABLE_INCREMENT
expr_stmt|;
name|line_info_table
operator|=
operator|(
name|dst_line_info_ref
operator|)
name|xrealloc
argument_list|(
name|line_info_table
argument_list|,
operator|(
name|line_info_table_allocated
operator|*
sizeof|sizeof
argument_list|(
name|dst_line_info_entry
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* Add the new entry at the end of the line_info_table.  */
name|line_info
operator|=
operator|&
name|line_info_table
index|[
name|line_info_table_in_use
operator|++
index|]
expr_stmt|;
name|line_info
operator|->
name|dst_file_num
operator|=
name|lookup_filename
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|line_info
operator|->
name|dst_line_num
operator|=
name|line
expr_stmt|;
if|if
condition|(
name|line
operator|>
name|file_info_table
index|[
name|line_info
operator|->
name|dst_file_num
index|]
operator|.
name|max_line
condition|)
name|file_info_table
index|[
name|line_info
operator|->
name|dst_file_num
index|]
operator|.
name|max_line
operator|=
name|line
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Record the beginning of a new source file, for later output.    At present, unimplemented.  */
end_comment

begin_function
specifier|static
name|void
name|vmsdbgout_start_source_file
parameter_list|(
name|lineno
parameter_list|,
name|filename
parameter_list|)
name|unsigned
name|int
name|lineno
decl_stmt|;
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
block|{
if|if
condition|(
name|write_symbols
operator|==
name|VMS_AND_DWARF2_DEBUG
condition|)
call|(
modifier|*
name|dwarf2_debug_hooks
operator|.
name|start_source_file
call|)
argument_list|(
name|lineno
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Record the end of a source file, for later output.    At present, unimplemented.  */
end_comment

begin_function
specifier|static
name|void
name|vmsdbgout_end_source_file
parameter_list|(
name|lineno
parameter_list|)
name|unsigned
name|int
name|lineno
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|write_symbols
operator|==
name|VMS_AND_DWARF2_DEBUG
condition|)
call|(
modifier|*
name|dwarf2_debug_hooks
operator|.
name|end_source_file
call|)
argument_list|(
name|lineno
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set up for Debug output at the start of compilation.  */
end_comment

begin_function
specifier|static
name|void
name|vmsdbgout_init
parameter_list|(
name|main_input_filename
parameter_list|)
specifier|const
name|char
modifier|*
name|main_input_filename
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|language_string
init|=
name|lang_hooks
operator|.
name|name
decl_stmt|;
if|if
condition|(
name|write_symbols
operator|==
name|VMS_AND_DWARF2_DEBUG
condition|)
call|(
modifier|*
name|dwarf2_debug_hooks
operator|.
name|init
call|)
argument_list|(
name|main_input_filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_info_level
operator|==
name|DINFO_LEVEL_NONE
condition|)
return|return;
comment|/* Remember the name of the primary input file.  */
name|primary_filename
operator|=
name|main_input_filename
expr_stmt|;
comment|/* Allocate the initial hunk of the file_info_table.  */
name|file_info_table
operator|=
operator|(
name|dst_file_info_ref
operator|)
name|xcalloc
argument_list|(
name|FILE_TABLE_INCREMENT
argument_list|,
sizeof|sizeof
argument_list|(
name|dst_file_info_entry
argument_list|)
argument_list|)
expr_stmt|;
name|file_info_table_allocated
operator|=
name|FILE_TABLE_INCREMENT
expr_stmt|;
comment|/* Skip the first entry - file numbers begin at 1 */
name|file_info_table_in_use
operator|=
literal|1
expr_stmt|;
name|func_table
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xcalloc
argument_list|(
name|FUNC_TABLE_INCREMENT
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|func_table_allocated
operator|=
name|FUNC_TABLE_INCREMENT
expr_stmt|;
name|func_table_in_use
operator|=
literal|1
expr_stmt|;
comment|/* Allocate the initial hunk of the line_info_table.  */
name|line_info_table
operator|=
operator|(
name|dst_line_info_ref
operator|)
name|xcalloc
argument_list|(
name|LINE_INFO_TABLE_INCREMENT
argument_list|,
sizeof|sizeof
argument_list|(
name|dst_line_info_entry
argument_list|)
argument_list|)
expr_stmt|;
name|line_info_table_allocated
operator|=
name|LINE_INFO_TABLE_INCREMENT
expr_stmt|;
comment|/* zero-th entry is allocated, but unused */
name|line_info_table_in_use
operator|=
literal|1
expr_stmt|;
name|lookup_filename
argument_list|(
name|primary_filename
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|language_string
argument_list|,
literal|"GNU C"
argument_list|)
condition|)
name|module_language
operator|=
name|DST_K_C
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|language_string
argument_list|,
literal|"GNU C++"
argument_list|)
condition|)
name|module_language
operator|=
name|DST_K_CXX
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|language_string
argument_list|,
literal|"GNU Ada"
argument_list|)
condition|)
name|module_language
operator|=
name|DST_K_ADA
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|language_string
argument_list|,
literal|"GNU F77"
argument_list|)
condition|)
name|module_language
operator|=
name|DST_K_FORTRAN
expr_stmt|;
else|else
name|module_language
operator|=
name|DST_K_UNKNOWN
expr_stmt|;
name|module_producer
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|language_string
argument_list|)
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|version_string
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|module_producer
argument_list|,
literal|"%s %s"
argument_list|,
name|language_string
argument_list|,
name|version_string
argument_list|)
expr_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|text_end_label
argument_list|,
name|TEXT_END_LABEL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Not implemented in VMS Debug.  */
end_comment

begin_function
specifier|static
name|void
name|vmsdbgout_define
parameter_list|(
name|lineno
parameter_list|,
name|buffer
parameter_list|)
name|unsigned
name|int
name|lineno
decl_stmt|;
specifier|const
name|char
modifier|*
name|buffer
decl_stmt|;
block|{
if|if
condition|(
name|write_symbols
operator|==
name|VMS_AND_DWARF2_DEBUG
condition|)
call|(
modifier|*
name|dwarf2_debug_hooks
operator|.
name|define
call|)
argument_list|(
name|lineno
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Not implemented in VMS Debug.  */
end_comment

begin_function
specifier|static
name|void
name|vmsdbgout_undef
parameter_list|(
name|lineno
parameter_list|,
name|buffer
parameter_list|)
name|unsigned
name|int
name|lineno
decl_stmt|;
specifier|const
name|char
modifier|*
name|buffer
decl_stmt|;
block|{
if|if
condition|(
name|write_symbols
operator|==
name|VMS_AND_DWARF2_DEBUG
condition|)
call|(
modifier|*
name|dwarf2_debug_hooks
operator|.
name|undef
call|)
argument_list|(
name|lineno
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Not implemented in VMS Debug.  */
end_comment

begin_function
specifier|static
name|void
name|vmsdbgout_decl
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
if|if
condition|(
name|write_symbols
operator|==
name|VMS_AND_DWARF2_DEBUG
condition|)
call|(
modifier|*
name|dwarf2_debug_hooks
operator|.
name|function_decl
call|)
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Not implemented in VMS Debug.  */
end_comment

begin_function
specifier|static
name|void
name|vmsdbgout_global_decl
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
if|if
condition|(
name|write_symbols
operator|==
name|VMS_AND_DWARF2_DEBUG
condition|)
call|(
modifier|*
name|dwarf2_debug_hooks
operator|.
name|global_decl
call|)
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Not implemented in VMS Debug.  */
end_comment

begin_function
specifier|static
name|void
name|vmsdbgout_abstract_function
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
if|if
condition|(
name|write_symbols
operator|==
name|VMS_AND_DWARF2_DEBUG
condition|)
call|(
modifier|*
name|dwarf2_debug_hooks
operator|.
name|outlining_inline_function
call|)
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output stuff that Debug requires at the end of every file and generate the    VMS Debug debugging info.  */
end_comment

begin_function
specifier|static
name|void
name|vmsdbgout_finish
parameter_list|(
name|input_filename
parameter_list|)
specifier|const
name|char
modifier|*
name|input_filename
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|int
name|totsize
decl_stmt|;
if|if
condition|(
name|write_symbols
operator|==
name|VMS_AND_DWARF2_DEBUG
condition|)
call|(
modifier|*
name|dwarf2_debug_hooks
operator|.
name|finish
call|)
argument_list|(
name|input_filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_info_level
operator|==
name|DINFO_LEVEL_NONE
condition|)
return|return;
comment|/* Output a terminator label for the .text section.  */
name|text_section
argument_list|()
expr_stmt|;
name|ASM_OUTPUT_INTERNAL_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|TEXT_END_LABEL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Output debugging information.      Warning! Do not change the name of the .vmsdebug section without      changing it in the assembler also.  */
name|named_section
argument_list|(
name|NULL_TREE
argument_list|,
literal|".vmsdebug"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_ALIGN
argument_list|(
name|asm_out_file
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|totsize
operator|=
name|write_modbeg
argument_list|(
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|func_table_in_use
condition|;
name|i
operator|++
control|)
block|{
name|totsize
operator|+=
name|write_rtnbeg
argument_list|(
name|i
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|totsize
operator|+=
name|write_rtnend
argument_list|(
name|i
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|totsize
operator|+=
name|write_pclines
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|write_modbeg
argument_list|(
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|func_table_in_use
condition|;
name|i
operator|++
control|)
block|{
name|write_rtnbeg
argument_list|(
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|write_rtnend
argument_list|(
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|write_pclines
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_info_level
operator|>
name|DINFO_LEVEL_TERSE
condition|)
block|{
name|totsize
operator|=
name|write_srccorrs
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|write_srccorrs
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|totsize
operator|=
name|write_modend
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|write_modend
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VMS_DEBUGGING_INFO */
end_comment

end_unit

