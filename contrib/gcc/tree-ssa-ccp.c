begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Conditional constant propagation pass for the GNU compiler.    Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007    Free Software Foundation, Inc.    Adapted from original RTL SSA-CCP by Daniel Berlin<dberlin@dberlin.org>    Adapted to GIMPLE trees by Diego Novillo<dnovillo@redhat.com>  This file is part of GCC.     GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.     GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.     You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* Conditional constant propagation (CCP) is based on the SSA    propagation engine (tree-ssa-propagate.c).  Constant assignments of    the form VAR = CST are propagated from the assignments into uses of    VAR, which in turn may generate new constants.  The simulation uses    a four level lattice to keep track of constant values associated    with SSA names.  Given an SSA name V_i, it may take one of the    following values:     	UNINITIALIZED	->  This is the default starting value.  V_i 			    has not been processed yet.  	UNDEFINED	->  V_i is a local variable whose definition 			    has not been processed yet.  Therefore we 			    don't yet know if its value is a constant 			    or not.  	CONSTANT	->  V_i has been found to hold a constant 			    value C.  	VARYING		->  V_i cannot take a constant value, or if it 			    does, it is not possible to determine it 			    at compile time.     The core of SSA-CCP is in ccp_visit_stmt and ccp_visit_phi_node:     1- In ccp_visit_stmt, we are interested in assignments whose RHS       evaluates into a constant and conditional jumps whose predicate       evaluates into a boolean true or false.  When an assignment of       the form V_i = CONST is found, V_i's lattice value is set to       CONSTANT and CONST is associated with it.  This causes the       propagation engine to add all the SSA edges coming out the       assignment into the worklists, so that statements that use V_i       can be visited.        If the statement is a conditional with a constant predicate, we       mark the outgoing edges as executable or not executable       depending on the predicate's value.  This is then used when       visiting PHI nodes to know when a PHI argument can be ignored.            2- In ccp_visit_phi_node, if all the PHI arguments evaluate to the       same constant C, then the LHS of the PHI is set to C.  This       evaluation is known as the "meet operation".  Since one of the       goals of this evaluation is to optimistically return constant       values as often as possible, it uses two main short cuts:        - If an argument is flowing in through a non-executable edge, it 	is ignored.  This is useful in cases like this:  			if (PRED) 			  a_9 = 3; 			else 			  a_10 = 100; 			a_11 = PHI (a_9, a_10)  	If PRED is known to always evaluate to false, then we can 	assume that a_11 will always take its value from a_10, meaning 	that instead of consider it VARYING (a_9 and a_10 have 	different values), we can consider it CONSTANT 100.        - If an argument has an UNDEFINED value, then it does not affect 	the outcome of the meet operation.  If a variable V_i has an 	UNDEFINED value, it means that either its defining statement 	hasn't been visited yet or V_i has no defining statement, in 	which case the original symbol 'V' is being used 	uninitialized.  Since 'V' is a local variable, the compiler 	may assume any initial value for it.      After propagation, every variable V_i that ends up with a lattice    value of CONSTANT will have the associated constant value in the    array CONST_VAL[i].VALUE.  That is fed into substitute_and_fold for    final substitution and folding.      Constant propagation in stores and loads (STORE-CCP)    ----------------------------------------------------     While CCP has all the logic to propagate constants in GIMPLE    registers, it is missing the ability to associate constants with    stores and loads (i.e., pointer dereferences, structures and    global/aliased variables).  We don't keep loads and stores in    SSA, but we do build a factored use-def web for them (in the    virtual operands).     For instance, consider the following code fragment:  	  struct A a; 	  const int B = 42;  	  void foo (int i) 	  { 	    if (i> 10) 	      a.a = 42; 	    else 	      { 		a.b = 21; 		a.a = a.b + 21; 	      }  	    if (a.a != B) 	      never_executed (); 	  }     We should be able to deduce that the predicate 'a.a != B' is always    false.  To achieve this, we associate constant values to the SSA    names in the V_MAY_DEF and V_MUST_DEF operands for each store.    Additionally, since we also glob partial loads/stores with the base    symbol, we also keep track of the memory reference where the    constant value was stored (in the MEM_REF field of PROP_VALUE_T).    For instance,          # a_5 = V_MAY_DEF<a_4>         a.a = 2;          # VUSE<a_5>         x_3 = a.b;     In the example above, CCP will associate value '2' with 'a_5', but    it would be wrong to replace the load from 'a.b' with '2', because    '2' had been stored into a.a.     To support STORE-CCP, it is necessary to add a new value to the    constant propagation lattice.  When evaluating a load for a memory    reference we can no longer assume a value of UNDEFINED if we    haven't seen a preceding store to the same memory location.    Consider, for instance global variables:     	int A;     	foo (int i)   	{ 	  if (i_3> 10) 	    A_4 = 3;           # A_5 = PHI (A_4, A_2);  	  # VUSE<A_5> 	  A.0_6 = A;  	  return A.0_6; 	}     The value of A_2 cannot be assumed to be UNDEFINED, as it may have    been defined outside of foo.  If we were to assume it UNDEFINED, we    would erroneously optimize the above into 'return 3;'.  Therefore,    when doing STORE-CCP, we introduce a fifth lattice value    (UNKNOWN_VAL), which overrides any other value when computing the    meet operation in PHI nodes.     Though STORE-CCP is not too expensive, it does have to do more work    than regular CCP, so it is only enabled at -O2.  Both regular CCP    and STORE-CCP use the exact same algorithm.  The only distinction    is that when doing STORE-CCP, the boolean variable DO_STORE_CCP is    set to true.  This affects the evaluation of statements and PHI    nodes.     References:       Constant propagation with conditional branches,      Wegman and Zadeck, ACM TOPLAS 13(2):181-210.       Building an Optimizing Compiler,      Robert Morgan, Butterworth-Heinemann, 1998, Section 8.9.       Advanced Compiler Design and Implementation,      Steven Muchnick, Morgan Kaufmann, 1997, Section 12.6  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"tree-dump.h"
end_include

begin_include
include|#
directive|include
file|"tree-flow.h"
end_include

begin_include
include|#
directive|include
file|"tree-pass.h"
end_include

begin_include
include|#
directive|include
file|"tree-ssa-propagate.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_comment
comment|/* Possible lattice values.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|UNINITIALIZED
init|=
literal|0
block|,
name|UNDEFINED
block|,
name|UNKNOWN_VAL
block|,
name|CONSTANT
block|,
name|VARYING
block|}
name|ccp_lattice_t
typedef|;
end_typedef

begin_comment
comment|/* Array of propagated constant values.  After propagation,    CONST_VAL[I].VALUE holds the constant value for SSA_NAME(I).  If    the constant is held in an SSA name representing a memory store    (i.e., a V_MAY_DEF or V_MUST_DEF), CONST_VAL[I].MEM_REF will    contain the actual memory reference used to store (i.e., the LHS of    the assignment doing the store).  */
end_comment

begin_decl_stmt
specifier|static
name|prop_value_t
modifier|*
name|const_val
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* True if we are also propagating constants in stores and loads.  */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|do_store_ccp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Dump constant propagation value VAL to file OUTF prefixed by PREFIX.  */
end_comment

begin_function
specifier|static
name|void
name|dump_lattice_value
parameter_list|(
name|FILE
modifier|*
name|outf
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|,
name|prop_value_t
name|val
parameter_list|)
block|{
switch|switch
condition|(
name|val
operator|.
name|lattice_val
condition|)
block|{
case|case
name|UNINITIALIZED
case|:
name|fprintf
argument_list|(
name|outf
argument_list|,
literal|"%sUNINITIALIZED"
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNDEFINED
case|:
name|fprintf
argument_list|(
name|outf
argument_list|,
literal|"%sUNDEFINED"
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
break|break;
case|case
name|VARYING
case|:
name|fprintf
argument_list|(
name|outf
argument_list|,
literal|"%sVARYING"
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNKNOWN_VAL
case|:
name|fprintf
argument_list|(
name|outf
argument_list|,
literal|"%sUNKNOWN_VAL"
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONSTANT
case|:
name|fprintf
argument_list|(
name|outf
argument_list|,
literal|"%sCONSTANT "
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|outf
argument_list|,
name|val
operator|.
name|value
argument_list|,
name|dump_flags
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print lattice value VAL to stderr.  */
end_comment

begin_function_decl
name|void
name|debug_lattice_value
parameter_list|(
name|prop_value_t
name|val
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|debug_lattice_value
parameter_list|(
name|prop_value_t
name|val
parameter_list|)
block|{
name|dump_lattice_value
argument_list|(
name|stderr
argument_list|,
literal|""
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The regular is_gimple_min_invariant does a shallow test of the object.    It assumes that full gimplification has happened, or will happen on the    object.  For a value coming from DECL_INITIAL, this is not true, so we    have to be more strict ourselves.  */
end_comment

begin_function
specifier|static
name|bool
name|ccp_decl_initial_min_invariant
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
if|if
condition|(
operator|!
name|is_gimple_min_invariant
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
block|{
comment|/* Inline and unroll is_gimple_addressable.  */
while|while
condition|(
literal|1
condition|)
block|{
name|t
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_gimple_id
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|true
return|;
if|if
condition|(
operator|!
name|handled_component_p
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|false
return|;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Compute a default value for variable VAR and store it in the    CONST_VAL array.  The following rules are used to get default    values:     1- Global and static variables that are declared constant are       considered CONSTANT.     2- Any other value is considered UNDEFINED.  This is useful when       considering PHI nodes.  PHI arguments that are undefined do not       change the constant value of the PHI node, which allows for more       constants to be propagated.     3- If SSA_NAME_VALUE is set and it is a constant, its value is       used.     4- Variables defined by statements other than assignments and PHI       nodes are considered VARYING.     5- Variables that are not GIMPLE registers are considered       UNKNOWN_VAL, which is really a stronger version of UNDEFINED.       It's used to avoid the short circuit evaluation implied by       UNDEFINED in ccp_lattice_meet.  */
end_comment

begin_function
specifier|static
name|prop_value_t
name|get_default_value
parameter_list|(
name|tree
name|var
parameter_list|)
block|{
name|tree
name|sym
init|=
name|SSA_NAME_VAR
argument_list|(
name|var
argument_list|)
decl_stmt|;
name|prop_value_t
name|val
init|=
block|{
name|UNINITIALIZED
block|,
name|NULL_TREE
block|,
name|NULL_TREE
block|}
decl_stmt|;
if|if
condition|(
operator|!
name|do_store_ccp
operator|&&
operator|!
name|is_gimple_reg
argument_list|(
name|var
argument_list|)
condition|)
block|{
comment|/* Short circuit for regular CCP.  We are not interested in any 	 non-register when DO_STORE_CCP is false.  */
name|val
operator|.
name|lattice_val
operator|=
name|VARYING
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|SSA_NAME_VALUE
argument_list|(
name|var
argument_list|)
operator|&&
name|is_gimple_min_invariant
argument_list|(
name|SSA_NAME_VALUE
argument_list|(
name|var
argument_list|)
argument_list|)
condition|)
block|{
name|val
operator|.
name|lattice_val
operator|=
name|CONSTANT
expr_stmt|;
name|val
operator|.
name|value
operator|=
name|SSA_NAME_VALUE
argument_list|(
name|var
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|sym
argument_list|)
operator|&&
name|TREE_READONLY
argument_list|(
name|sym
argument_list|)
operator|&&
operator|!
name|MTAG_P
argument_list|(
name|sym
argument_list|)
operator|&&
name|DECL_INITIAL
argument_list|(
name|sym
argument_list|)
operator|&&
name|ccp_decl_initial_min_invariant
argument_list|(
name|DECL_INITIAL
argument_list|(
name|sym
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Globals and static variables declared 'const' take their 	 initial value.  */
name|val
operator|.
name|lattice_val
operator|=
name|CONSTANT
expr_stmt|;
name|val
operator|.
name|value
operator|=
name|DECL_INITIAL
argument_list|(
name|sym
argument_list|)
expr_stmt|;
name|val
operator|.
name|mem_ref
operator|=
name|sym
expr_stmt|;
block|}
else|else
block|{
name|tree
name|stmt
init|=
name|SSA_NAME_DEF_STMT
argument_list|(
name|var
argument_list|)
decl_stmt|;
if|if
condition|(
name|IS_EMPTY_STMT
argument_list|(
name|stmt
argument_list|)
condition|)
block|{
comment|/* Variables defined by an empty statement are those used 	     before being initialized.  If VAR is a local variable, we 	     can assume initially that it is UNDEFINED.  If we are 	     doing STORE-CCP, function arguments and non-register 	     variables are initially UNKNOWN_VAL, because we cannot 	     discard the value incoming from outside of this function 	     (see ccp_lattice_meet for details).  */
if|if
condition|(
name|is_gimple_reg
argument_list|(
name|sym
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|sym
argument_list|)
operator|!=
name|PARM_DECL
condition|)
name|val
operator|.
name|lattice_val
operator|=
name|UNDEFINED
expr_stmt|;
elseif|else
if|if
condition|(
name|do_store_ccp
condition|)
name|val
operator|.
name|lattice_val
operator|=
name|UNKNOWN_VAL
expr_stmt|;
else|else
name|val
operator|.
name|lattice_val
operator|=
name|VARYING
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|MODIFY_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|PHI_NODE
condition|)
block|{
comment|/* Any other variable defined by an assignment or a PHI node 	     is considered UNDEFINED (or UNKNOWN_VAL if VAR is not a 	     GIMPLE register).  */
name|val
operator|.
name|lattice_val
operator|=
name|is_gimple_reg
argument_list|(
name|sym
argument_list|)
condition|?
name|UNDEFINED
else|:
name|UNKNOWN_VAL
expr_stmt|;
block|}
else|else
block|{
comment|/* Otherwise, VAR will never take on a constant value.  */
name|val
operator|.
name|lattice_val
operator|=
name|VARYING
expr_stmt|;
block|}
block|}
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/* Get the constant value associated with variable VAR.  If    MAY_USE_DEFAULT_P is true, call get_default_value on variables that    have the lattice value UNINITIALIZED.  */
end_comment

begin_function
specifier|static
name|prop_value_t
modifier|*
name|get_value
parameter_list|(
name|tree
name|var
parameter_list|,
name|bool
name|may_use_default_p
parameter_list|)
block|{
name|prop_value_t
modifier|*
name|val
init|=
operator|&
name|const_val
index|[
name|SSA_NAME_VERSION
argument_list|(
name|var
argument_list|)
index|]
decl_stmt|;
if|if
condition|(
name|may_use_default_p
operator|&&
name|val
operator|->
name|lattice_val
operator|==
name|UNINITIALIZED
condition|)
operator|*
name|val
operator|=
name|get_default_value
argument_list|(
name|var
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/* Set the value for variable VAR to NEW_VAL.  Return true if the new    value is different from VAR's previous value.  */
end_comment

begin_function
specifier|static
name|bool
name|set_lattice_value
parameter_list|(
name|tree
name|var
parameter_list|,
name|prop_value_t
name|new_val
parameter_list|)
block|{
name|prop_value_t
modifier|*
name|old_val
init|=
name|get_value
argument_list|(
name|var
argument_list|,
name|false
argument_list|)
decl_stmt|;
comment|/* Lattice transitions must always be monotonically increasing in      value.  We allow two exceptions:            1- If *OLD_VAL and NEW_VAL are the same, return false to 	inform the caller that this was a non-transition.       2- If we are doing store-ccp (i.e., DOING_STORE_CCP is true), 	allow CONSTANT->UNKNOWN_VAL.  The UNKNOWN_VAL state is a 	special type of UNDEFINED state which prevents the short 	circuit evaluation of PHI arguments (see ccp_visit_phi_node 	and ccp_lattice_meet).  */
name|gcc_assert
argument_list|(
name|old_val
operator|->
name|lattice_val
operator|<=
name|new_val
operator|.
name|lattice_val
operator|||
operator|(
name|old_val
operator|->
name|lattice_val
operator|==
name|new_val
operator|.
name|lattice_val
operator|&&
name|old_val
operator|->
name|value
operator|==
name|new_val
operator|.
name|value
operator|&&
name|old_val
operator|->
name|mem_ref
operator|==
name|new_val
operator|.
name|mem_ref
operator|)
operator|||
operator|(
name|do_store_ccp
operator|&&
name|old_val
operator|->
name|lattice_val
operator|==
name|CONSTANT
operator|&&
name|new_val
operator|.
name|lattice_val
operator|==
name|UNKNOWN_VAL
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_val
operator|->
name|lattice_val
operator|!=
name|new_val
operator|.
name|lattice_val
condition|)
block|{
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|dump_lattice_value
argument_list|(
name|dump_file
argument_list|,
literal|"Lattice value changed to "
argument_list|,
name|new_val
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|".  %sdding SSA edges to worklist.\n"
argument_list|,
name|new_val
operator|.
name|lattice_val
operator|!=
name|UNDEFINED
condition|?
literal|"A"
else|:
literal|"Not a"
argument_list|)
expr_stmt|;
block|}
operator|*
name|old_val
operator|=
name|new_val
expr_stmt|;
comment|/* Transitions UNINITIALIZED -> UNDEFINED are never interesting 	 for propagation purposes.  In these cases return false to 	 avoid doing useless work.  */
return|return
operator|(
name|new_val
operator|.
name|lattice_val
operator|!=
name|UNDEFINED
operator|)
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Return the likely CCP lattice value for STMT.     If STMT has no operands, then return CONSTANT.     Else if any operands of STMT are undefined, then return UNDEFINED.     Else if any operands of STMT are constants, then return CONSTANT.     Else return VARYING.  */
end_comment

begin_function
specifier|static
name|ccp_lattice_t
name|likely_value
parameter_list|(
name|tree
name|stmt
parameter_list|)
block|{
name|bool
name|found_constant
decl_stmt|;
name|stmt_ann_t
name|ann
decl_stmt|;
name|tree
name|use
decl_stmt|;
name|ssa_op_iter
name|iter
decl_stmt|;
name|ann
operator|=
name|stmt_ann
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
comment|/* If the statement has volatile operands, it won't fold to a      constant value.  */
if|if
condition|(
name|ann
operator|->
name|has_volatile_ops
condition|)
return|return
name|VARYING
return|;
comment|/* If we are not doing store-ccp, statements with loads      and/or stores will never fold into a constant.  */
if|if
condition|(
operator|!
name|do_store_ccp
operator|&&
operator|!
name|ZERO_SSA_OPERANDS
argument_list|(
name|stmt
argument_list|,
name|SSA_OP_ALL_VIRTUALS
argument_list|)
condition|)
return|return
name|VARYING
return|;
comment|/* A CALL_EXPR is assumed to be varying.  NOTE: This may be overly      conservative, in the presence of const and pure calls.  */
if|if
condition|(
name|get_call_expr_in
argument_list|(
name|stmt
argument_list|)
operator|!=
name|NULL_TREE
condition|)
return|return
name|VARYING
return|;
comment|/* Anything other than assignments and conditional jumps are not      interesting for CCP.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|!=
name|MODIFY_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|!=
name|COND_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|!=
name|SWITCH_EXPR
condition|)
return|return
name|VARYING
return|;
if|if
condition|(
name|is_gimple_min_invariant
argument_list|(
name|get_rhs
argument_list|(
name|stmt
argument_list|)
argument_list|)
condition|)
return|return
name|CONSTANT
return|;
name|found_constant
operator|=
name|false
expr_stmt|;
name|FOR_EACH_SSA_TREE_OPERAND
argument_list|(
argument|use
argument_list|,
argument|stmt
argument_list|,
argument|iter
argument_list|,
argument|SSA_OP_USE|SSA_OP_VUSE
argument_list|)
block|{
name|prop_value_t
modifier|*
name|val
init|=
name|get_value
argument_list|(
name|use
argument_list|,
name|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|->
name|lattice_val
operator|==
name|VARYING
condition|)
return|return
name|VARYING
return|;
if|if
condition|(
name|val
operator|->
name|lattice_val
operator|==
name|UNKNOWN_VAL
condition|)
block|{
comment|/* UNKNOWN_VAL is invalid when not doing STORE-CCP.  */
name|gcc_assert
argument_list|(
name|do_store_ccp
argument_list|)
expr_stmt|;
return|return
name|UNKNOWN_VAL
return|;
block|}
if|if
condition|(
name|val
operator|->
name|lattice_val
operator|==
name|CONSTANT
condition|)
name|found_constant
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|found_constant
operator|||
name|ZERO_SSA_OPERANDS
argument_list|(
name|stmt
argument_list|,
name|SSA_OP_USE
argument_list|)
operator|||
name|ZERO_SSA_OPERANDS
argument_list|(
name|stmt
argument_list|,
name|SSA_OP_VUSE
argument_list|)
condition|)
return|return
name|CONSTANT
return|;
return|return
name|UNDEFINED
return|;
block|}
end_function

begin_comment
comment|/* Initialize local data structures for CCP.  */
end_comment

begin_function
specifier|static
name|void
name|ccp_initialize
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|const_val
operator|=
name|XNEWVEC
argument_list|(
name|prop_value_t
argument_list|,
name|num_ssa_names
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|const_val
argument_list|,
literal|0
argument_list|,
name|num_ssa_names
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|const_val
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Initialize simulation flags for PHI nodes and statements.  */
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|block_stmt_iterator
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|bsi_start
argument_list|(
name|bb
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|i
argument_list|)
condition|;
name|bsi_next
argument_list|(
operator|&
name|i
argument_list|)
control|)
block|{
name|bool
name|is_varying
init|=
name|false
decl_stmt|;
name|tree
name|stmt
init|=
name|bsi_stmt
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|likely_value
argument_list|(
name|stmt
argument_list|)
operator|==
name|VARYING
condition|)
block|{
name|tree
name|def
decl_stmt|;
name|ssa_op_iter
name|iter
decl_stmt|;
comment|/* If the statement will not produce a constant, mark 		 all its outputs VARYING.  */
name|FOR_EACH_SSA_TREE_OPERAND
argument_list|(
argument|def
argument_list|,
argument|stmt
argument_list|,
argument|iter
argument_list|,
argument|SSA_OP_ALL_DEFS
argument_list|)
name|get_value
argument_list|(
name|def
argument_list|,
name|false
argument_list|)
operator|->
name|lattice_val
operator|=
name|VARYING
expr_stmt|;
comment|/* Never mark conditional jumps with DONT_SIMULATE_AGAIN, 		 otherwise the propagator will never add the outgoing 		 control edges.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|!=
name|COND_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|!=
name|SWITCH_EXPR
condition|)
name|is_varying
operator|=
name|true
expr_stmt|;
block|}
name|DONT_SIMULATE_AGAIN
argument_list|(
name|stmt
argument_list|)
operator|=
name|is_varying
expr_stmt|;
block|}
block|}
comment|/* Now process PHI nodes.  */
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|tree
name|phi
decl_stmt|;
for|for
control|(
name|phi
operator|=
name|phi_nodes
argument_list|(
name|bb
argument_list|)
init|;
name|phi
condition|;
name|phi
operator|=
name|PHI_CHAIN
argument_list|(
name|phi
argument_list|)
control|)
block|{
name|int
name|i
decl_stmt|;
name|tree
name|arg
decl_stmt|;
name|prop_value_t
modifier|*
name|val
init|=
name|get_value
argument_list|(
name|PHI_RESULT
argument_list|(
name|phi
argument_list|)
argument_list|,
name|false
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PHI_NUM_ARGS
argument_list|(
name|phi
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|arg
operator|=
name|PHI_ARG_DEF
argument_list|(
name|phi
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|SSA_NAME
operator|&&
name|get_value
argument_list|(
name|arg
argument_list|,
name|false
argument_list|)
operator|->
name|lattice_val
operator|==
name|VARYING
condition|)
block|{
name|val
operator|->
name|lattice_val
operator|=
name|VARYING
expr_stmt|;
break|break;
block|}
block|}
name|DONT_SIMULATE_AGAIN
argument_list|(
name|phi
argument_list|)
operator|=
operator|(
name|val
operator|->
name|lattice_val
operator|==
name|VARYING
operator|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Do final substitution of propagated values, cleanup the flowgraph and    free allocated storage.  */
end_comment

begin_function
specifier|static
name|void
name|ccp_finalize
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Perform substitutions based on the known constant values.  */
name|substitute_and_fold
argument_list|(
name|const_val
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|const_val
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compute the meet operator between *VAL1 and *VAL2.  Store the result    in VAL1.     		any  M UNDEFINED   = any 		any  M UNKNOWN_VAL = UNKNOWN_VAL 		any  M VARYING     = VARYING 		Ci   M Cj	   = Ci		if (i == j) 		Ci   M Cj	   = VARYING	if (i != j)     Lattice values UNKNOWN_VAL and UNDEFINED are similar but have    different semantics at PHI nodes.  Both values imply that we don't    know whether the variable is constant or not.  However, UNKNOWN_VAL    values override all others.  For instance, suppose that A is a    global variable:  		+------+ 		|      | 		|     / \ 		|    /   \ 		|   |  A_1 = 4 		|    \   / 		|     \ /     		| A_3 = PHI (A_2, A_1) 		| ... = A_3 		|    | 		+----+     If the edge into A_2 is not executable, the first visit to A_3 will    yield the constant 4.  But the second visit to A_3 will be with A_2    in state UNKNOWN_VAL.  We can no longer conclude that A_3 is 4    because A_2 may have been set in another function.  If we had used    the lattice value UNDEFINED, we would have had wrongly concluded    that A_3 is 4.  */
end_comment

begin_function
specifier|static
name|void
name|ccp_lattice_meet
parameter_list|(
name|prop_value_t
modifier|*
name|val1
parameter_list|,
name|prop_value_t
modifier|*
name|val2
parameter_list|)
block|{
if|if
condition|(
name|val1
operator|->
name|lattice_val
operator|==
name|UNDEFINED
condition|)
block|{
comment|/* UNDEFINED M any = any   */
operator|*
name|val1
operator|=
operator|*
name|val2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|val2
operator|->
name|lattice_val
operator|==
name|UNDEFINED
condition|)
block|{
comment|/* any M UNDEFINED = any          Nothing to do.  VAL1 already contains the value we want.  */
empty_stmt|;
block|}
elseif|else
if|if
condition|(
name|val1
operator|->
name|lattice_val
operator|==
name|UNKNOWN_VAL
operator|||
name|val2
operator|->
name|lattice_val
operator|==
name|UNKNOWN_VAL
condition|)
block|{
comment|/* UNKNOWN_VAL values are invalid if we are not doing STORE-CCP.  */
name|gcc_assert
argument_list|(
name|do_store_ccp
argument_list|)
expr_stmt|;
comment|/* any M UNKNOWN_VAL = UNKNOWN_VAL.  */
name|val1
operator|->
name|lattice_val
operator|=
name|UNKNOWN_VAL
expr_stmt|;
name|val1
operator|->
name|value
operator|=
name|NULL_TREE
expr_stmt|;
name|val1
operator|->
name|mem_ref
operator|=
name|NULL_TREE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|val1
operator|->
name|lattice_val
operator|==
name|VARYING
operator|||
name|val2
operator|->
name|lattice_val
operator|==
name|VARYING
condition|)
block|{
comment|/* any M VARYING = VARYING.  */
name|val1
operator|->
name|lattice_val
operator|=
name|VARYING
expr_stmt|;
name|val1
operator|->
name|value
operator|=
name|NULL_TREE
expr_stmt|;
name|val1
operator|->
name|mem_ref
operator|=
name|NULL_TREE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|val1
operator|->
name|lattice_val
operator|==
name|CONSTANT
operator|&&
name|val2
operator|->
name|lattice_val
operator|==
name|CONSTANT
operator|&&
name|simple_cst_equal
argument_list|(
name|val1
operator|->
name|value
argument_list|,
name|val2
operator|->
name|value
argument_list|)
operator|==
literal|1
operator|&&
operator|(
operator|!
name|do_store_ccp
operator|||
operator|(
name|val1
operator|->
name|mem_ref
operator|&&
name|val2
operator|->
name|mem_ref
operator|&&
name|operand_equal_p
argument_list|(
name|val1
operator|->
name|mem_ref
argument_list|,
name|val2
operator|->
name|mem_ref
argument_list|,
literal|0
argument_list|)
operator|)
operator|)
condition|)
block|{
comment|/* Ci M Cj = Ci		if (i == j) 	 Ci M Cj = VARYING	if (i != j)           If these two values come from memory stores, make sure that 	 they come from the same memory reference.  */
name|val1
operator|->
name|lattice_val
operator|=
name|CONSTANT
expr_stmt|;
name|val1
operator|->
name|value
operator|=
name|val1
operator|->
name|value
expr_stmt|;
name|val1
operator|->
name|mem_ref
operator|=
name|val1
operator|->
name|mem_ref
expr_stmt|;
block|}
else|else
block|{
comment|/* Any other combination is VARYING.  */
name|val1
operator|->
name|lattice_val
operator|=
name|VARYING
expr_stmt|;
name|val1
operator|->
name|value
operator|=
name|NULL_TREE
expr_stmt|;
name|val1
operator|->
name|mem_ref
operator|=
name|NULL_TREE
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Loop through the PHI_NODE's parameters for BLOCK and compare their    lattice values to determine PHI_NODE's lattice value.  The value of a    PHI node is determined calling ccp_lattice_meet with all the arguments    of the PHI node that are incoming via executable edges.  */
end_comment

begin_function
specifier|static
name|enum
name|ssa_prop_result
name|ccp_visit_phi_node
parameter_list|(
name|tree
name|phi
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|prop_value_t
modifier|*
name|old_val
decl_stmt|,
name|new_val
decl_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\nVisiting PHI node: "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|phi
argument_list|,
name|dump_flags
argument_list|)
expr_stmt|;
block|}
name|old_val
operator|=
name|get_value
argument_list|(
name|PHI_RESULT
argument_list|(
name|phi
argument_list|)
argument_list|,
name|false
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|old_val
operator|->
name|lattice_val
condition|)
block|{
case|case
name|VARYING
case|:
return|return
name|SSA_PROP_VARYING
return|;
case|case
name|CONSTANT
case|:
name|new_val
operator|=
operator|*
name|old_val
expr_stmt|;
break|break;
case|case
name|UNKNOWN_VAL
case|:
comment|/* To avoid the default value of UNKNOWN_VAL overriding          that of its possible constant arguments, temporarily 	 set the PHI node's default lattice value to be  	 UNDEFINED.  If the PHI node's old value was UNKNOWN_VAL and 	 the new value is UNDEFINED, then we prevent the invalid 	 transition by not calling set_lattice_value.  */
name|gcc_assert
argument_list|(
name|do_store_ccp
argument_list|)
expr_stmt|;
comment|/* FALLTHRU  */
case|case
name|UNDEFINED
case|:
case|case
name|UNINITIALIZED
case|:
name|new_val
operator|.
name|lattice_val
operator|=
name|UNDEFINED
expr_stmt|;
name|new_val
operator|.
name|value
operator|=
name|NULL_TREE
expr_stmt|;
name|new_val
operator|.
name|mem_ref
operator|=
name|NULL_TREE
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PHI_NUM_ARGS
argument_list|(
name|phi
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
comment|/* Compute the meet operator over all the PHI arguments flowing 	 through executable edges.  */
name|edge
name|e
init|=
name|PHI_ARG_EDGE
argument_list|(
name|phi
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n    Argument #%d (%d -> %d %sexecutable)\n"
argument_list|,
name|i
argument_list|,
name|e
operator|->
name|src
operator|->
name|index
argument_list|,
name|e
operator|->
name|dest
operator|->
name|index
argument_list|,
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_EXECUTABLE
operator|)
condition|?
literal|""
else|:
literal|"not "
argument_list|)
expr_stmt|;
block|}
comment|/* If the incoming edge is executable, Compute the meet operator for 	 the existing value of the PHI node and the current PHI argument.  */
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_EXECUTABLE
condition|)
block|{
name|tree
name|arg
init|=
name|PHI_ARG_DEF
argument_list|(
name|phi
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|prop_value_t
name|arg_val
decl_stmt|;
if|if
condition|(
name|is_gimple_min_invariant
argument_list|(
name|arg
argument_list|)
condition|)
block|{
name|arg_val
operator|.
name|lattice_val
operator|=
name|CONSTANT
expr_stmt|;
name|arg_val
operator|.
name|value
operator|=
name|arg
expr_stmt|;
name|arg_val
operator|.
name|mem_ref
operator|=
name|NULL_TREE
expr_stmt|;
block|}
else|else
name|arg_val
operator|=
operator|*
operator|(
name|get_value
argument_list|(
name|arg
argument_list|,
name|true
argument_list|)
operator|)
expr_stmt|;
name|ccp_lattice_meet
argument_list|(
operator|&
name|new_val
argument_list|,
operator|&
name|arg_val
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\t"
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|arg
argument_list|,
name|dump_flags
argument_list|)
expr_stmt|;
name|dump_lattice_value
argument_list|(
name|dump_file
argument_list|,
literal|"\tValue: "
argument_list|,
name|arg_val
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|new_val
operator|.
name|lattice_val
operator|==
name|VARYING
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|dump_lattice_value
argument_list|(
name|dump_file
argument_list|,
literal|"\n    PHI node value: "
argument_list|,
name|new_val
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Check for an invalid change from UNKNOWN_VAL to UNDEFINED.  */
if|if
condition|(
name|do_store_ccp
operator|&&
name|old_val
operator|->
name|lattice_val
operator|==
name|UNKNOWN_VAL
operator|&&
name|new_val
operator|.
name|lattice_val
operator|==
name|UNDEFINED
condition|)
return|return
name|SSA_PROP_NOT_INTERESTING
return|;
comment|/* Otherwise, make the transition to the new value.  */
if|if
condition|(
name|set_lattice_value
argument_list|(
name|PHI_RESULT
argument_list|(
name|phi
argument_list|)
argument_list|,
name|new_val
argument_list|)
condition|)
block|{
if|if
condition|(
name|new_val
operator|.
name|lattice_val
operator|==
name|VARYING
condition|)
return|return
name|SSA_PROP_VARYING
return|;
else|else
return|return
name|SSA_PROP_INTERESTING
return|;
block|}
else|else
return|return
name|SSA_PROP_NOT_INTERESTING
return|;
block|}
end_function

begin_comment
comment|/* CCP specific front-end to the non-destructive constant folding    routines.     Attempt to simplify the RHS of STMT knowing that one or more    operands are constants.     If simplification is possible, return the simplified RHS,    otherwise return the original RHS.  */
end_comment

begin_function
specifier|static
name|tree
name|ccp_fold
parameter_list|(
name|tree
name|stmt
parameter_list|)
block|{
name|tree
name|rhs
init|=
name|get_rhs
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
decl_stmt|;
name|enum
name|tree_code_class
name|kind
init|=
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
decl_stmt|;
name|tree
name|retval
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|SSA_NAME
condition|)
block|{
comment|/* If the RHS is an SSA_NAME, return its known constant value, 	 if any.  */
return|return
name|get_value
argument_list|(
name|rhs
argument_list|,
name|true
argument_list|)
operator|->
name|value
return|;
block|}
elseif|else
if|if
condition|(
name|do_store_ccp
operator|&&
name|stmt_makes_single_load
argument_list|(
name|stmt
argument_list|)
condition|)
block|{
comment|/* If the RHS is a memory load, see if the VUSEs associated with 	 it are a valid constant for that memory load.  */
name|prop_value_t
modifier|*
name|val
init|=
name|get_value_loaded_by
argument_list|(
name|stmt
argument_list|,
name|const_val
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|&&
name|val
operator|->
name|mem_ref
condition|)
block|{
if|if
condition|(
name|operand_equal_p
argument_list|(
name|val
operator|->
name|mem_ref
argument_list|,
name|rhs
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|val
operator|->
name|value
return|;
comment|/* If RHS is extracting REALPART_EXPR or IMAGPART_EXPR of a 	     complex type with a known constant value, return it.  */
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|REALPART_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|IMAGPART_EXPR
operator|)
operator|&&
name|operand_equal_p
argument_list|(
name|val
operator|->
name|mem_ref
argument_list|,
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|fold_build1
argument_list|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|,
name|val
operator|->
name|value
argument_list|)
return|;
block|}
return|return
name|NULL_TREE
return|;
block|}
comment|/* Unary operators.  Note that we know the single operand must      be a constant.  So this should almost always return a      simplified RHS.  */
if|if
condition|(
name|kind
operator|==
name|tcc_unary
condition|)
block|{
comment|/* Handle unary operators which can appear in GIMPLE form.  */
name|tree
name|op0
init|=
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* Simplify the operand down to a constant.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|SSA_NAME
condition|)
block|{
name|prop_value_t
modifier|*
name|val
init|=
name|get_value
argument_list|(
name|op0
argument_list|,
name|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|->
name|lattice_val
operator|==
name|CONSTANT
condition|)
name|op0
operator|=
name|get_value
argument_list|(
name|op0
argument_list|,
name|true
argument_list|)
operator|->
name|value
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|code
operator|==
name|NOP_EXPR
operator|||
name|code
operator|==
name|CONVERT_EXPR
operator|)
operator|&&
name|tree_ssa_useless_type_conversion_1
argument_list|(
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|)
condition|)
return|return
name|op0
return|;
return|return
name|fold_unary
argument_list|(
name|code
argument_list|,
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|,
name|op0
argument_list|)
return|;
block|}
comment|/* Binary and comparison operators.  We know one or both of the      operands are constants.  */
elseif|else
if|if
condition|(
name|kind
operator|==
name|tcc_binary
operator|||
name|kind
operator|==
name|tcc_comparison
operator|||
name|code
operator|==
name|TRUTH_AND_EXPR
operator|||
name|code
operator|==
name|TRUTH_OR_EXPR
operator|||
name|code
operator|==
name|TRUTH_XOR_EXPR
condition|)
block|{
comment|/* Handle binary and comparison operators that can appear in          GIMPLE form.  */
name|tree
name|op0
init|=
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|op1
init|=
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|/* Simplify the operands down to constants when appropriate.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|SSA_NAME
condition|)
block|{
name|prop_value_t
modifier|*
name|val
init|=
name|get_value
argument_list|(
name|op0
argument_list|,
name|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|->
name|lattice_val
operator|==
name|CONSTANT
condition|)
name|op0
operator|=
name|val
operator|->
name|value
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|SSA_NAME
condition|)
block|{
name|prop_value_t
modifier|*
name|val
init|=
name|get_value
argument_list|(
name|op1
argument_list|,
name|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|->
name|lattice_val
operator|==
name|CONSTANT
condition|)
name|op1
operator|=
name|val
operator|->
name|value
expr_stmt|;
block|}
return|return
name|fold_binary
argument_list|(
name|code
argument_list|,
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
return|;
block|}
comment|/* We may be able to fold away calls to builtin functions if their      arguments are constants.  */
elseif|else
if|if
condition|(
name|code
operator|==
name|CALL_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
operator|)
operator|&&
name|DECL_BUILT_IN
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|ZERO_SSA_OPERANDS
argument_list|(
name|stmt
argument_list|,
name|SSA_OP_USE
argument_list|)
condition|)
block|{
name|tree
modifier|*
name|orig
decl_stmt|,
name|var
decl_stmt|;
name|tree
name|fndecl
decl_stmt|,
name|arglist
decl_stmt|;
name|size_t
name|i
init|=
literal|0
decl_stmt|;
name|ssa_op_iter
name|iter
decl_stmt|;
name|use_operand_p
name|var_p
decl_stmt|;
comment|/* Preserve the original values of every operand.  */
name|orig
operator|=
name|XNEWVEC
argument_list|(
name|tree
argument_list|,
name|NUM_SSA_OPERANDS
argument_list|(
name|stmt
argument_list|,
name|SSA_OP_USE
argument_list|)
argument_list|)
expr_stmt|;
name|FOR_EACH_SSA_TREE_OPERAND
argument_list|(
argument|var
argument_list|,
argument|stmt
argument_list|,
argument|iter
argument_list|,
argument|SSA_OP_USE
argument_list|)
name|orig
index|[
name|i
operator|++
index|]
operator|=
name|var
expr_stmt|;
comment|/* Substitute operands with their values and try to fold.  */
name|replace_uses_in
argument_list|(
name|stmt
argument_list|,
name|NULL
argument_list|,
name|const_val
argument_list|)
expr_stmt|;
name|fndecl
operator|=
name|get_callee_fndecl
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|retval
operator|=
name|fold_builtin
argument_list|(
name|fndecl
argument_list|,
name|arglist
argument_list|,
name|false
argument_list|)
expr_stmt|;
comment|/* Restore operands to their original form.  */
name|i
operator|=
literal|0
expr_stmt|;
name|FOR_EACH_SSA_USE_OPERAND
argument_list|(
argument|var_p
argument_list|,
argument|stmt
argument_list|,
argument|iter
argument_list|,
argument|SSA_OP_USE
argument_list|)
name|SET_USE
argument_list|(
name|var_p
argument_list|,
name|orig
index|[
name|i
operator|++
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|orig
argument_list|)
expr_stmt|;
block|}
block|}
else|else
return|return
name|rhs
return|;
comment|/* If we got a simplified form, see if we need to convert its type.  */
if|if
condition|(
name|retval
condition|)
return|return
name|fold_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|,
name|retval
argument_list|)
return|;
comment|/* No simplification was possible.  */
return|return
name|rhs
return|;
block|}
end_function

begin_comment
comment|/* Return the tree representing the element referenced by T if T is an    ARRAY_REF or COMPONENT_REF into constant aggregates.  Return    NULL_TREE otherwise.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_const_aggregate_ref
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|prop_value_t
modifier|*
name|value
decl_stmt|;
name|tree
name|base
decl_stmt|,
name|ctor
decl_stmt|,
name|idx
decl_stmt|,
name|field
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|cnt
decl_stmt|;
name|tree
name|cfield
decl_stmt|,
name|cval
decl_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|ARRAY_REF
case|:
comment|/* Get a CONSTRUCTOR.  If BASE is a VAR_DECL, get its 	 DECL_INITIAL.  If BASE is a nested reference into another 	 ARRAY_REF or COMPONENT_REF, make a recursive call to resolve 	 the inner reference.  */
name|base
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|base
argument_list|)
condition|)
block|{
case|case
name|VAR_DECL
case|:
if|if
condition|(
operator|!
name|TREE_READONLY
argument_list|(
name|base
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|base
argument_list|)
argument_list|)
operator|!=
name|ARRAY_TYPE
operator|||
operator|!
name|targetm
operator|.
name|binds_local_p
argument_list|(
name|base
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
name|ctor
operator|=
name|DECL_INITIAL
argument_list|(
name|base
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARRAY_REF
case|:
case|case
name|COMPONENT_REF
case|:
name|ctor
operator|=
name|fold_const_aggregate_ref
argument_list|(
name|base
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
name|NULL_TREE
return|;
block|}
if|if
condition|(
name|ctor
operator|==
name|NULL_TREE
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|ctor
argument_list|)
operator|!=
name|CONSTRUCTOR
operator|&&
name|TREE_CODE
argument_list|(
name|ctor
argument_list|)
operator|!=
name|STRING_CST
operator|)
operator|||
operator|!
name|TREE_STATIC
argument_list|(
name|ctor
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
comment|/* Get the index.  If we have an SSA_NAME, try to resolve it 	 with the current lattice value for the SSA_NAME.  */
name|idx
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|idx
argument_list|)
condition|)
block|{
case|case
name|SSA_NAME
case|:
if|if
condition|(
operator|(
name|value
operator|=
name|get_value
argument_list|(
name|idx
argument_list|,
name|true
argument_list|)
operator|)
operator|&&
name|value
operator|->
name|lattice_val
operator|==
name|CONSTANT
operator|&&
name|TREE_CODE
argument_list|(
name|value
operator|->
name|value
argument_list|)
operator|==
name|INTEGER_CST
condition|)
name|idx
operator|=
name|value
operator|->
name|value
expr_stmt|;
else|else
return|return
name|NULL_TREE
return|;
break|break;
case|case
name|INTEGER_CST
case|:
break|break;
default|default:
return|return
name|NULL_TREE
return|;
block|}
comment|/* Fold read from constant string.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ctor
argument_list|)
operator|==
name|STRING_CST
condition|)
block|{
if|if
condition|(
operator|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|ctor
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
name|GET_MODE_CLASS
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|ctor
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|==
name|MODE_INT
operator|)
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|ctor
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|1
operator|&&
name|compare_tree_int
argument_list|(
name|idx
argument_list|,
name|TREE_STRING_LENGTH
argument_list|(
name|ctor
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
return|return
name|build_int_cst
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
operator|(
name|TREE_STRING_POINTER
argument_list|(
name|ctor
argument_list|)
index|[
name|TREE_INT_CST_LOW
argument_list|(
name|idx
argument_list|)
index|]
operator|)
argument_list|)
return|;
return|return
name|NULL_TREE
return|;
block|}
comment|/* Whoo-hoo!  I'll fold ya baby.  Yeah!  */
name|FOR_EACH_CONSTRUCTOR_ELT
argument_list|(
argument|CONSTRUCTOR_ELTS (ctor)
argument_list|,
argument|cnt
argument_list|,
argument|cfield
argument_list|,
argument|cval
argument_list|)
if|if
condition|(
name|tree_int_cst_equal
argument_list|(
name|cfield
argument_list|,
name|idx
argument_list|)
condition|)
return|return
name|cval
return|;
break|break;
case|case
name|COMPONENT_REF
case|:
comment|/* Get a CONSTRUCTOR.  If BASE is a VAR_DECL, get its 	 DECL_INITIAL.  If BASE is a nested reference into another 	 ARRAY_REF or COMPONENT_REF, make a recursive call to resolve 	 the inner reference.  */
name|base
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|base
argument_list|)
condition|)
block|{
case|case
name|VAR_DECL
case|:
if|if
condition|(
operator|!
name|TREE_READONLY
argument_list|(
name|base
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|base
argument_list|)
argument_list|)
operator|!=
name|RECORD_TYPE
operator|||
operator|!
name|targetm
operator|.
name|binds_local_p
argument_list|(
name|base
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
name|ctor
operator|=
name|DECL_INITIAL
argument_list|(
name|base
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARRAY_REF
case|:
case|case
name|COMPONENT_REF
case|:
name|ctor
operator|=
name|fold_const_aggregate_ref
argument_list|(
name|base
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
name|NULL_TREE
return|;
block|}
if|if
condition|(
name|ctor
operator|==
name|NULL_TREE
operator|||
name|TREE_CODE
argument_list|(
name|ctor
argument_list|)
operator|!=
name|CONSTRUCTOR
operator|||
operator|!
name|TREE_STATIC
argument_list|(
name|ctor
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
name|field
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|FOR_EACH_CONSTRUCTOR_ELT
argument_list|(
argument|CONSTRUCTOR_ELTS (ctor)
argument_list|,
argument|cnt
argument_list|,
argument|cfield
argument_list|,
argument|cval
argument_list|)
if|if
condition|(
name|cfield
operator|==
name|field
comment|/* FIXME: Handle bit-fields.  */
operator|&&
operator|!
name|DECL_BIT_FIELD
argument_list|(
name|cfield
argument_list|)
condition|)
return|return
name|cval
return|;
break|break;
case|case
name|REALPART_EXPR
case|:
case|case
name|IMAGPART_EXPR
case|:
block|{
name|tree
name|c
init|=
name|fold_const_aggregate_ref
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|&&
name|TREE_CODE
argument_list|(
name|c
argument_list|)
operator|==
name|COMPLEX_CST
condition|)
return|return
name|fold_build1
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|c
argument_list|)
return|;
break|break;
block|}
default|default:
break|break;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Evaluate statement STMT.  */
end_comment

begin_function
specifier|static
name|prop_value_t
name|evaluate_stmt
parameter_list|(
name|tree
name|stmt
parameter_list|)
block|{
name|prop_value_t
name|val
decl_stmt|;
name|tree
name|simplified
init|=
name|NULL_TREE
decl_stmt|;
name|ccp_lattice_t
name|likelyvalue
init|=
name|likely_value
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
name|bool
name|is_constant
decl_stmt|;
name|val
operator|.
name|mem_ref
operator|=
name|NULL_TREE
expr_stmt|;
name|fold_defer_overflow_warnings
argument_list|()
expr_stmt|;
comment|/* If the statement is likely to have a CONSTANT result, then try      to fold the statement to determine the constant value.  */
if|if
condition|(
name|likelyvalue
operator|==
name|CONSTANT
condition|)
name|simplified
operator|=
name|ccp_fold
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
comment|/* If the statement is likely to have a VARYING result, then do not      bother folding the statement.  */
if|if
condition|(
name|likelyvalue
operator|==
name|VARYING
condition|)
name|simplified
operator|=
name|get_rhs
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
comment|/* If the statement is an ARRAY_REF or COMPONENT_REF into constant      aggregates, extract the referenced constant.  Otherwise the      statement is likely to have an UNDEFINED value, and there will be      nothing to do.  Note that fold_const_aggregate_ref returns      NULL_TREE if the first case does not match.  */
elseif|else
if|if
condition|(
operator|!
name|simplified
condition|)
name|simplified
operator|=
name|fold_const_aggregate_ref
argument_list|(
name|get_rhs
argument_list|(
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
name|is_constant
operator|=
name|simplified
operator|&&
name|is_gimple_min_invariant
argument_list|(
name|simplified
argument_list|)
expr_stmt|;
name|fold_undefer_overflow_warnings
argument_list|(
name|is_constant
argument_list|,
name|stmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_constant
condition|)
block|{
comment|/* The statement produced a constant value.  */
name|val
operator|.
name|lattice_val
operator|=
name|CONSTANT
expr_stmt|;
name|val
operator|.
name|value
operator|=
name|simplified
expr_stmt|;
block|}
else|else
block|{
comment|/* The statement produced a nonconstant value.  If the statement 	 had UNDEFINED operands, then the result of the statement 	 should be UNDEFINED.  Otherwise, the statement is VARYING.  */
if|if
condition|(
name|likelyvalue
operator|==
name|UNDEFINED
operator|||
name|likelyvalue
operator|==
name|UNKNOWN_VAL
condition|)
name|val
operator|.
name|lattice_val
operator|=
name|likelyvalue
expr_stmt|;
else|else
name|val
operator|.
name|lattice_val
operator|=
name|VARYING
expr_stmt|;
name|val
operator|.
name|value
operator|=
name|NULL_TREE
expr_stmt|;
block|}
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/* Visit the assignment statement STMT.  Set the value of its LHS to the    value computed by the RHS and store LHS in *OUTPUT_P.  If STMT    creates virtual definitions, set the value of each new name to that    of the RHS (if we can derive a constant out of the RHS).  */
end_comment

begin_function
specifier|static
name|enum
name|ssa_prop_result
name|visit_assignment
parameter_list|(
name|tree
name|stmt
parameter_list|,
name|tree
modifier|*
name|output_p
parameter_list|)
block|{
name|prop_value_t
name|val
decl_stmt|;
name|tree
name|lhs
decl_stmt|,
name|rhs
decl_stmt|;
name|enum
name|ssa_prop_result
name|retval
decl_stmt|;
name|lhs
operator|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rhs
operator|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|SSA_NAME
condition|)
block|{
comment|/* For a simple copy operation, we copy the lattice values.  */
name|prop_value_t
modifier|*
name|nval
init|=
name|get_value
argument_list|(
name|rhs
argument_list|,
name|true
argument_list|)
decl_stmt|;
name|val
operator|=
operator|*
name|nval
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|do_store_ccp
operator|&&
name|stmt_makes_single_load
argument_list|(
name|stmt
argument_list|)
condition|)
block|{
comment|/* Same as above, but the RHS is not a gimple register and yet          has a known VUSE.  If STMT is loading from the same memory 	 location that created the SSA_NAMEs for the virtual operands, 	 we can propagate the value on the RHS.  */
name|prop_value_t
modifier|*
name|nval
init|=
name|get_value_loaded_by
argument_list|(
name|stmt
argument_list|,
name|const_val
argument_list|)
decl_stmt|;
if|if
condition|(
name|nval
operator|&&
name|nval
operator|->
name|mem_ref
operator|&&
name|operand_equal_p
argument_list|(
name|nval
operator|->
name|mem_ref
argument_list|,
name|rhs
argument_list|,
literal|0
argument_list|)
condition|)
name|val
operator|=
operator|*
name|nval
expr_stmt|;
else|else
name|val
operator|=
name|evaluate_stmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Evaluate the statement.  */
name|val
operator|=
name|evaluate_stmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
comment|/* If the original LHS was a VIEW_CONVERT_EXPR, modify the constant      value to be a VIEW_CONVERT_EXPR of the old constant value.       ??? Also, if this was a definition of a bitfield, we need to widen      the constant value into the type of the destination variable.  This      should not be necessary if GCC represented bitfields properly.  */
block|{
name|tree
name|orig_lhs
init|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|orig_lhs
argument_list|)
operator|==
name|VIEW_CONVERT_EXPR
operator|&&
name|val
operator|.
name|lattice_val
operator|==
name|CONSTANT
condition|)
block|{
name|tree
name|w
init|=
name|fold_unary
argument_list|(
name|VIEW_CONVERT_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|orig_lhs
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|val
operator|.
name|value
argument_list|)
decl_stmt|;
name|orig_lhs
operator|=
name|TREE_OPERAND
argument_list|(
name|orig_lhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|&&
name|is_gimple_min_invariant
argument_list|(
name|w
argument_list|)
condition|)
name|val
operator|.
name|value
operator|=
name|w
expr_stmt|;
else|else
block|{
name|val
operator|.
name|lattice_val
operator|=
name|VARYING
expr_stmt|;
name|val
operator|.
name|value
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|val
operator|.
name|lattice_val
operator|==
name|CONSTANT
operator|&&
name|TREE_CODE
argument_list|(
name|orig_lhs
argument_list|)
operator|==
name|COMPONENT_REF
operator|&&
name|DECL_BIT_FIELD
argument_list|(
name|TREE_OPERAND
argument_list|(
name|orig_lhs
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|w
init|=
name|widen_bitfield
argument_list|(
name|val
operator|.
name|value
argument_list|,
name|TREE_OPERAND
argument_list|(
name|orig_lhs
argument_list|,
literal|1
argument_list|)
argument_list|,
name|orig_lhs
argument_list|)
decl_stmt|;
if|if
condition|(
name|w
operator|&&
name|is_gimple_min_invariant
argument_list|(
name|w
argument_list|)
condition|)
name|val
operator|.
name|value
operator|=
name|w
expr_stmt|;
else|else
block|{
name|val
operator|.
name|lattice_val
operator|=
name|VARYING
expr_stmt|;
name|val
operator|.
name|value
operator|=
name|NULL_TREE
expr_stmt|;
name|val
operator|.
name|mem_ref
operator|=
name|NULL_TREE
expr_stmt|;
block|}
block|}
block|}
name|retval
operator|=
name|SSA_PROP_NOT_INTERESTING
expr_stmt|;
comment|/* Set the lattice value of the statement's output.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|lhs
argument_list|)
operator|==
name|SSA_NAME
condition|)
block|{
comment|/* If STMT is an assignment to an SSA_NAME, we only have one 	 value to set.  */
if|if
condition|(
name|set_lattice_value
argument_list|(
name|lhs
argument_list|,
name|val
argument_list|)
condition|)
block|{
operator|*
name|output_p
operator|=
name|lhs
expr_stmt|;
if|if
condition|(
name|val
operator|.
name|lattice_val
operator|==
name|VARYING
condition|)
name|retval
operator|=
name|SSA_PROP_VARYING
expr_stmt|;
else|else
name|retval
operator|=
name|SSA_PROP_INTERESTING
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|do_store_ccp
operator|&&
name|stmt_makes_single_store
argument_list|(
name|stmt
argument_list|)
condition|)
block|{
comment|/* Otherwise, set the names in V_MAY_DEF/V_MUST_DEF operands 	 to the new constant value and mark the LHS as the memory 	 reference associated with VAL.  */
name|ssa_op_iter
name|i
decl_stmt|;
name|tree
name|vdef
decl_stmt|;
name|bool
name|changed
decl_stmt|;
comment|/* Stores cannot take on an UNDEFINED value.  */
if|if
condition|(
name|val
operator|.
name|lattice_val
operator|==
name|UNDEFINED
condition|)
name|val
operator|.
name|lattice_val
operator|=
name|UNKNOWN_VAL
expr_stmt|;
comment|/* Mark VAL as stored in the LHS of this assignment.  */
name|val
operator|.
name|mem_ref
operator|=
name|lhs
expr_stmt|;
comment|/* Set the value of every VDEF to VAL.  */
name|changed
operator|=
name|false
expr_stmt|;
name|FOR_EACH_SSA_TREE_OPERAND
argument_list|(
argument|vdef
argument_list|,
argument|stmt
argument_list|,
argument|i
argument_list|,
argument|SSA_OP_VIRTUAL_DEFS
argument_list|)
name|changed
operator||=
name|set_lattice_value
argument_list|(
name|vdef
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* Note that for propagation purposes, we are only interested in 	 visiting statements that load the exact same memory reference 	 stored here.  Those statements will have the exact same list 	 of virtual uses, so it is enough to set the output of this 	 statement to be its first virtual definition.  */
operator|*
name|output_p
operator|=
name|first_vdef
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|changed
condition|)
block|{
if|if
condition|(
name|val
operator|.
name|lattice_val
operator|==
name|VARYING
condition|)
name|retval
operator|=
name|SSA_PROP_VARYING
expr_stmt|;
else|else
name|retval
operator|=
name|SSA_PROP_INTERESTING
expr_stmt|;
block|}
block|}
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* Visit the conditional statement STMT.  Return SSA_PROP_INTERESTING    if it can determine which edge will be taken.  Otherwise, return    SSA_PROP_VARYING.  */
end_comment

begin_function
specifier|static
name|enum
name|ssa_prop_result
name|visit_cond_stmt
parameter_list|(
name|tree
name|stmt
parameter_list|,
name|edge
modifier|*
name|taken_edge_p
parameter_list|)
block|{
name|prop_value_t
name|val
decl_stmt|;
name|basic_block
name|block
decl_stmt|;
name|block
operator|=
name|bb_for_stmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|val
operator|=
name|evaluate_stmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
comment|/* Find which edge out of the conditional block will be taken and add it      to the worklist.  If no single edge can be determined statically,      return SSA_PROP_VARYING to feed all the outgoing edges to the      propagation engine.  */
operator|*
name|taken_edge_p
operator|=
name|val
operator|.
name|value
condition|?
name|find_taken_edge
argument_list|(
name|block
argument_list|,
name|val
operator|.
name|value
argument_list|)
else|:
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|taken_edge_p
condition|)
return|return
name|SSA_PROP_INTERESTING
return|;
else|else
return|return
name|SSA_PROP_VARYING
return|;
block|}
end_function

begin_comment
comment|/* Evaluate statement STMT.  If the statement produces an output value and    its evaluation changes the lattice value of its output, return    SSA_PROP_INTERESTING and set *OUTPUT_P to the SSA_NAME holding the    output value.        If STMT is a conditional branch and we can determine its truth    value, set *TAKEN_EDGE_P accordingly.  If STMT produces a varying    value, return SSA_PROP_VARYING.  */
end_comment

begin_function
specifier|static
name|enum
name|ssa_prop_result
name|ccp_visit_stmt
parameter_list|(
name|tree
name|stmt
parameter_list|,
name|edge
modifier|*
name|taken_edge_p
parameter_list|,
name|tree
modifier|*
name|output_p
parameter_list|)
block|{
name|tree
name|def
decl_stmt|;
name|ssa_op_iter
name|iter
decl_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\nVisiting statement:\n"
argument_list|)
expr_stmt|;
name|print_generic_stmt
argument_list|(
name|dump_file
argument_list|,
name|stmt
argument_list|,
name|dump_flags
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|MODIFY_EXPR
condition|)
block|{
comment|/* If the statement is an assignment that produces a single 	 output value, evaluate its RHS to see if the lattice value of 	 its output has changed.  */
return|return
name|visit_assignment
argument_list|(
name|stmt
argument_list|,
name|output_p
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|COND_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|SWITCH_EXPR
condition|)
block|{
comment|/* If STMT is a conditional branch, see if we can determine 	 which branch will be taken.  */
return|return
name|visit_cond_stmt
argument_list|(
name|stmt
argument_list|,
name|taken_edge_p
argument_list|)
return|;
block|}
comment|/* Any other kind of statement is not interesting for constant      propagation and, therefore, not worth simulating.  */
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"No interesting values produced.  Marked VARYING.\n"
argument_list|)
expr_stmt|;
comment|/* Definitions made by statements other than assignments to      SSA_NAMEs represent unknown modifications to their outputs.      Mark them VARYING.  */
name|FOR_EACH_SSA_TREE_OPERAND
argument_list|(
argument|def
argument_list|,
argument|stmt
argument_list|,
argument|iter
argument_list|,
argument|SSA_OP_ALL_DEFS
argument_list|)
block|{
name|prop_value_t
name|v
init|=
block|{
name|VARYING
block|,
name|NULL_TREE
block|,
name|NULL_TREE
block|}
decl_stmt|;
name|set_lattice_value
argument_list|(
name|def
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
return|return
name|SSA_PROP_VARYING
return|;
block|}
end_function

begin_comment
comment|/* Main entry point for SSA Conditional Constant Propagation.  */
end_comment

begin_function
specifier|static
name|void
name|execute_ssa_ccp
parameter_list|(
name|bool
name|store_ccp
parameter_list|)
block|{
name|do_store_ccp
operator|=
name|store_ccp
expr_stmt|;
name|ccp_initialize
argument_list|()
expr_stmt|;
name|ssa_propagate
argument_list|(
name|ccp_visit_stmt
argument_list|,
name|ccp_visit_phi_node
argument_list|)
expr_stmt|;
name|ccp_finalize
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|do_ssa_ccp
parameter_list|(
name|void
parameter_list|)
block|{
name|execute_ssa_ccp
argument_list|(
name|false
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|gate_ccp
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|flag_tree_ccp
operator|!=
literal|0
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|tree_opt_pass
name|pass_ccp
init|=
block|{
literal|"ccp"
block|,
comment|/* name */
name|gate_ccp
block|,
comment|/* gate */
name|do_ssa_ccp
block|,
comment|/* execute */
name|NULL
block|,
comment|/* sub */
name|NULL
block|,
comment|/* next */
literal|0
block|,
comment|/* static_pass_number */
name|TV_TREE_CCP
block|,
comment|/* tv_id */
name|PROP_cfg
operator||
name|PROP_ssa
operator||
name|PROP_alias
block|,
comment|/* properties_required */
literal|0
block|,
comment|/* properties_provided */
name|PROP_smt_usage
block|,
comment|/* properties_destroyed */
literal|0
block|,
comment|/* todo_flags_start */
name|TODO_cleanup_cfg
operator||
name|TODO_dump_func
operator||
name|TODO_update_ssa
operator||
name|TODO_ggc_collect
operator||
name|TODO_verify_ssa
operator||
name|TODO_verify_stmts
operator||
name|TODO_update_smt_usage
block|,
comment|/* todo_flags_finish */
literal|0
comment|/* letter */
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|unsigned
name|int
name|do_ssa_store_ccp
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* If STORE-CCP is not enabled, we just run regular CCP.  */
name|execute_ssa_ccp
argument_list|(
name|flag_tree_store_ccp
operator|!=
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|gate_store_ccp
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* STORE-CCP is enabled only with -ftree-store-ccp, but when      -fno-tree-store-ccp is specified, we should run regular CCP.      That's why the pass is enabled with either flag.  */
return|return
name|flag_tree_store_ccp
operator|!=
literal|0
operator|||
name|flag_tree_ccp
operator|!=
literal|0
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|tree_opt_pass
name|pass_store_ccp
init|=
block|{
literal|"store_ccp"
block|,
comment|/* name */
name|gate_store_ccp
block|,
comment|/* gate */
name|do_ssa_store_ccp
block|,
comment|/* execute */
name|NULL
block|,
comment|/* sub */
name|NULL
block|,
comment|/* next */
literal|0
block|,
comment|/* static_pass_number */
name|TV_TREE_STORE_CCP
block|,
comment|/* tv_id */
name|PROP_cfg
operator||
name|PROP_ssa
operator||
name|PROP_alias
block|,
comment|/* properties_required */
literal|0
block|,
comment|/* properties_provided */
name|PROP_smt_usage
block|,
comment|/* properties_destroyed */
literal|0
block|,
comment|/* todo_flags_start */
name|TODO_dump_func
operator||
name|TODO_update_ssa
operator||
name|TODO_ggc_collect
operator||
name|TODO_verify_ssa
operator||
name|TODO_cleanup_cfg
operator||
name|TODO_verify_stmts
operator||
name|TODO_update_smt_usage
block|,
comment|/* todo_flags_finish */
literal|0
comment|/* letter */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Given a constant value VAL for bitfield FIELD, and a destination    variable VAR, return VAL appropriately widened to fit into VAR.  If    FIELD is wider than HOST_WIDE_INT, NULL is returned.  */
end_comment

begin_function
name|tree
name|widen_bitfield
parameter_list|(
name|tree
name|val
parameter_list|,
name|tree
name|field
parameter_list|,
name|tree
name|var
parameter_list|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|var_size
decl_stmt|,
name|field_size
decl_stmt|;
name|tree
name|wide_val
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|mask
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
comment|/* We can only do this if the size of the type and field and VAL are      all constants representable in HOST_WIDE_INT.  */
if|if
condition|(
operator|!
name|host_integerp
argument_list|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|var
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|||
operator|!
name|host_integerp
argument_list|(
name|DECL_SIZE
argument_list|(
name|field
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|||
operator|!
name|host_integerp
argument_list|(
name|val
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
name|var_size
operator|=
name|tree_low_cst
argument_list|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|var
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|field_size
operator|=
name|tree_low_cst
argument_list|(
name|DECL_SIZE
argument_list|(
name|field
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Give up if either the bitfield or the variable are too wide.  */
if|if
condition|(
name|field_size
operator|>
name|HOST_BITS_PER_WIDE_INT
operator|||
name|var_size
operator|>
name|HOST_BITS_PER_WIDE_INT
condition|)
return|return
name|NULL_TREE
return|;
name|gcc_assert
argument_list|(
name|var_size
operator|>=
name|field_size
argument_list|)
expr_stmt|;
comment|/* If the sign bit of the value is not set or the field's type is unsigned,      just mask off the high order bits of the value.  */
if|if
condition|(
name|DECL_UNSIGNED
argument_list|(
name|field
argument_list|)
operator|||
operator|!
operator|(
name|tree_low_cst
argument_list|(
name|val
argument_list|,
literal|0
argument_list|)
operator|&
operator|(
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|)
operator|<<
operator|(
name|field_size
operator|-
literal|1
operator|)
operator|)
operator|)
condition|)
block|{
comment|/* Zero extension.  Build a mask with the lower 'field_size' bits 	 set and a BIT_AND_EXPR node to clear the high order bits of 	 the value.  */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|mask
operator|=
literal|0
init|;
name|i
operator|<
name|field_size
condition|;
name|i
operator|++
control|)
name|mask
operator||=
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|)
operator|<<
name|i
expr_stmt|;
name|wide_val
operator|=
name|fold_build2
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|var
argument_list|)
argument_list|,
name|val
argument_list|,
name|build_int_cst
argument_list|(
name|TREE_TYPE
argument_list|(
name|var
argument_list|)
argument_list|,
name|mask
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Sign extension.  Create a mask with the upper 'field_size' 	 bits set and a BIT_IOR_EXPR to set the high order bits of the 	 value.  */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|mask
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|var_size
operator|-
name|field_size
operator|)
condition|;
name|i
operator|++
control|)
name|mask
operator||=
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|)
operator|<<
operator|(
name|var_size
operator|-
name|i
operator|-
literal|1
operator|)
expr_stmt|;
name|wide_val
operator|=
name|fold_build2
argument_list|(
name|BIT_IOR_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|var
argument_list|)
argument_list|,
name|val
argument_list|,
name|build_int_cst
argument_list|(
name|TREE_TYPE
argument_list|(
name|var
argument_list|)
argument_list|,
name|mask
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|wide_val
return|;
block|}
end_function

begin_comment
comment|/* A subroutine of fold_stmt_r.  Attempts to fold *(A+O) to A[X].    BASE is an array type.  OFFSET is a byte displacement.  ORIG_TYPE    is the desired result type.  */
end_comment

begin_function
specifier|static
name|tree
name|maybe_fold_offset_to_array_ref
parameter_list|(
name|tree
name|base
parameter_list|,
name|tree
name|offset
parameter_list|,
name|tree
name|orig_type
parameter_list|)
block|{
name|tree
name|min_idx
decl_stmt|,
name|idx
decl_stmt|,
name|elt_offset
init|=
name|integer_zero_node
decl_stmt|;
name|tree
name|array_type
decl_stmt|,
name|elt_type
decl_stmt|,
name|elt_size
decl_stmt|;
comment|/* If BASE is an ARRAY_REF, we can pick up another offset (this time      measured in units of the size of elements type) from that ARRAY_REF).      We can't do anything if either is variable.       The case we handle here is *(&A[N]+O).  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|ARRAY_REF
condition|)
block|{
name|tree
name|low_bound
init|=
name|array_ref_low_bound
argument_list|(
name|base
argument_list|)
decl_stmt|;
name|elt_offset
operator|=
name|TREE_OPERAND
argument_list|(
name|base
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|low_bound
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
name|TREE_CODE
argument_list|(
name|elt_offset
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
return|return
name|NULL_TREE
return|;
name|elt_offset
operator|=
name|int_const_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|elt_offset
argument_list|,
name|low_bound
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|base
operator|=
name|TREE_OPERAND
argument_list|(
name|base
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Ignore stupid user tricks of indexing non-array variables.  */
name|array_type
operator|=
name|TREE_TYPE
argument_list|(
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|array_type
argument_list|)
operator|!=
name|ARRAY_TYPE
condition|)
return|return
name|NULL_TREE
return|;
name|elt_type
operator|=
name|TREE_TYPE
argument_list|(
name|array_type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lang_hooks
operator|.
name|types_compatible_p
argument_list|(
name|orig_type
argument_list|,
name|elt_type
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
comment|/* If OFFSET and ELT_OFFSET are zero, we don't care about the size of the      element type (so we can use the alignment if it's not constant).      Otherwise, compute the offset as an index by using a division.  If the      division isn't exact, then don't do anything.  */
name|elt_size
operator|=
name|TYPE_SIZE_UNIT
argument_list|(
name|elt_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|integer_zerop
argument_list|(
name|offset
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|elt_size
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
name|elt_size
operator|=
name|size_int
argument_list|(
name|TYPE_ALIGN
argument_list|(
name|elt_type
argument_list|)
argument_list|)
expr_stmt|;
name|idx
operator|=
name|integer_zero_node
expr_stmt|;
block|}
else|else
block|{
name|unsigned
name|HOST_WIDE_INT
name|lquo
decl_stmt|,
name|lrem
decl_stmt|;
name|HOST_WIDE_INT
name|hquo
decl_stmt|,
name|hrem
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|elt_size
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
name|div_and_round_double
argument_list|(
name|TRUNC_DIV_EXPR
argument_list|,
literal|1
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|offset
argument_list|)
argument_list|,
name|TREE_INT_CST_HIGH
argument_list|(
name|offset
argument_list|)
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|elt_size
argument_list|)
argument_list|,
name|TREE_INT_CST_HIGH
argument_list|(
name|elt_size
argument_list|)
argument_list|,
operator|&
name|lquo
argument_list|,
operator|&
name|hquo
argument_list|,
operator|&
name|lrem
argument_list|,
operator|&
name|hrem
argument_list|)
operator|||
name|lrem
operator|||
name|hrem
condition|)
return|return
name|NULL_TREE
return|;
name|idx
operator|=
name|build_int_cst_wide
argument_list|(
name|NULL_TREE
argument_list|,
name|lquo
argument_list|,
name|hquo
argument_list|)
expr_stmt|;
block|}
comment|/* Assume the low bound is zero.  If there is a domain type, get the      low bound, if any, convert the index into that type, and add the      low bound.  */
name|min_idx
operator|=
name|integer_zero_node
expr_stmt|;
if|if
condition|(
name|TYPE_DOMAIN
argument_list|(
name|array_type
argument_list|)
condition|)
block|{
if|if
condition|(
name|TYPE_MIN_VALUE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|array_type
argument_list|)
argument_list|)
condition|)
name|min_idx
operator|=
name|TYPE_MIN_VALUE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|array_type
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|min_idx
operator|=
name|fold_convert
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|array_type
argument_list|)
argument_list|,
name|min_idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|min_idx
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
return|return
name|NULL_TREE
return|;
name|idx
operator|=
name|fold_convert
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|array_type
argument_list|)
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|elt_offset
operator|=
name|fold_convert
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|array_type
argument_list|)
argument_list|,
name|elt_offset
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|integer_zerop
argument_list|(
name|min_idx
argument_list|)
condition|)
name|idx
operator|=
name|int_const_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|idx
argument_list|,
name|min_idx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|integer_zerop
argument_list|(
name|elt_offset
argument_list|)
condition|)
name|idx
operator|=
name|int_const_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|idx
argument_list|,
name|elt_offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|build4
argument_list|(
name|ARRAY_REF
argument_list|,
name|orig_type
argument_list|,
name|base
argument_list|,
name|idx
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* A subroutine of fold_stmt_r.  Attempts to fold *(S+O) to S.X.    BASE is a record type.  OFFSET is a byte displacement.  ORIG_TYPE    is the desired result type.  */
end_comment

begin_comment
comment|/* ??? This doesn't handle class inheritance.  */
end_comment

begin_function
specifier|static
name|tree
name|maybe_fold_offset_to_component_ref
parameter_list|(
name|tree
name|record_type
parameter_list|,
name|tree
name|base
parameter_list|,
name|tree
name|offset
parameter_list|,
name|tree
name|orig_type
parameter_list|,
name|bool
name|base_is_ptr
parameter_list|)
block|{
name|tree
name|f
decl_stmt|,
name|t
decl_stmt|,
name|field_type
decl_stmt|,
name|tail_array_field
decl_stmt|,
name|field_offset
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|record_type
argument_list|)
operator|!=
name|RECORD_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|record_type
argument_list|)
operator|!=
name|UNION_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|record_type
argument_list|)
operator|!=
name|QUAL_UNION_TYPE
condition|)
return|return
name|NULL_TREE
return|;
comment|/* Short-circuit silly cases.  */
if|if
condition|(
name|lang_hooks
operator|.
name|types_compatible_p
argument_list|(
name|record_type
argument_list|,
name|orig_type
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
name|tail_array_field
operator|=
name|NULL_TREE
expr_stmt|;
for|for
control|(
name|f
operator|=
name|TYPE_FIELDS
argument_list|(
name|record_type
argument_list|)
init|;
name|f
condition|;
name|f
operator|=
name|TREE_CHAIN
argument_list|(
name|f
argument_list|)
control|)
block|{
name|int
name|cmp
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|f
argument_list|)
operator|!=
name|FIELD_DECL
condition|)
continue|continue;
if|if
condition|(
name|DECL_BIT_FIELD
argument_list|(
name|f
argument_list|)
condition|)
continue|continue;
name|field_offset
operator|=
name|byte_position
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field_offset
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
continue|continue;
comment|/* ??? Java creates "interesting" fields for representing base classes. 	 They have no name, and have no context.  With no context, we get into 	 trouble with nonoverlapping_component_refs_p.  Skip them.  */
if|if
condition|(
operator|!
name|DECL_FIELD_CONTEXT
argument_list|(
name|f
argument_list|)
condition|)
continue|continue;
comment|/* The previous array field isn't at the end.  */
name|tail_array_field
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Check to see if this offset overlaps with the field.  */
name|cmp
operator|=
name|tree_int_cst_compare
argument_list|(
name|field_offset
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|>
literal|0
condition|)
continue|continue;
name|field_type
operator|=
name|TREE_TYPE
argument_list|(
name|f
argument_list|)
expr_stmt|;
comment|/* Here we exactly match the offset being checked.  If the types match, 	 then we can return that field.  */
if|if
condition|(
name|cmp
operator|==
literal|0
operator|&&
name|lang_hooks
operator|.
name|types_compatible_p
argument_list|(
name|orig_type
argument_list|,
name|field_type
argument_list|)
condition|)
block|{
if|if
condition|(
name|base_is_ptr
condition|)
name|base
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|record_type
argument_list|,
name|base
argument_list|)
expr_stmt|;
name|t
operator|=
name|build3
argument_list|(
name|COMPONENT_REF
argument_list|,
name|field_type
argument_list|,
name|base
argument_list|,
name|f
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
comment|/* Don't care about offsets into the middle of scalars.  */
if|if
condition|(
operator|!
name|AGGREGATE_TYPE_P
argument_list|(
name|field_type
argument_list|)
condition|)
continue|continue;
comment|/* Check for array at the end of the struct.  This is often 	 used as for flexible array members.  We should be able to 	 turn this into an array access anyway.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field_type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|tail_array_field
operator|=
name|f
expr_stmt|;
comment|/* Check the end of the field against the offset.  */
if|if
condition|(
operator|!
name|DECL_SIZE_UNIT
argument_list|(
name|f
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|DECL_SIZE_UNIT
argument_list|(
name|f
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
continue|continue;
name|t
operator|=
name|int_const_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|offset
argument_list|,
name|field_offset
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tree_int_cst_lt
argument_list|(
name|t
argument_list|,
name|DECL_SIZE_UNIT
argument_list|(
name|f
argument_list|)
argument_list|)
condition|)
continue|continue;
comment|/* If we matched, then set offset to the displacement into 	 this field.  */
name|offset
operator|=
name|t
expr_stmt|;
goto|goto
name|found
goto|;
block|}
if|if
condition|(
operator|!
name|tail_array_field
condition|)
return|return
name|NULL_TREE
return|;
name|f
operator|=
name|tail_array_field
expr_stmt|;
name|field_type
operator|=
name|TREE_TYPE
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|offset
operator|=
name|int_const_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|offset
argument_list|,
name|byte_position
argument_list|(
name|f
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|found
label|:
comment|/* If we get here, we've got an aggregate field, and a possibly       nonzero offset into them.  Recurse and hope for a valid match.  */
if|if
condition|(
name|base_is_ptr
condition|)
name|base
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|record_type
argument_list|,
name|base
argument_list|)
expr_stmt|;
name|base
operator|=
name|build3
argument_list|(
name|COMPONENT_REF
argument_list|,
name|field_type
argument_list|,
name|base
argument_list|,
name|f
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|t
operator|=
name|maybe_fold_offset_to_array_ref
argument_list|(
name|base
argument_list|,
name|offset
argument_list|,
name|orig_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
return|return
name|t
return|;
return|return
name|maybe_fold_offset_to_component_ref
argument_list|(
name|field_type
argument_list|,
name|base
argument_list|,
name|offset
argument_list|,
name|orig_type
argument_list|,
name|false
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* A subroutine of fold_stmt_r.  Attempt to simplify *(BASE+OFFSET).    Return the simplified expression, or NULL if nothing could be done.  */
end_comment

begin_function
specifier|static
name|tree
name|maybe_fold_stmt_indirect
parameter_list|(
name|tree
name|expr
parameter_list|,
name|tree
name|base
parameter_list|,
name|tree
name|offset
parameter_list|)
block|{
name|tree
name|t
decl_stmt|;
comment|/* We may well have constructed a double-nested PLUS_EXPR via multiple      substitutions.  Fold that down to one.  Remove NON_LVALUE_EXPRs that      are sometimes added.  */
name|base
operator|=
name|fold
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|STRIP_TYPE_NOPS
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
operator|=
name|base
expr_stmt|;
comment|/* One possibility is that the address reduces to a string constant.  */
name|t
operator|=
name|fold_read_from_constant_string
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
return|return
name|t
return|;
comment|/* Add in any offset from a PLUS_EXPR.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|PLUS_EXPR
condition|)
block|{
name|tree
name|offset2
decl_stmt|;
name|offset2
operator|=
name|TREE_OPERAND
argument_list|(
name|base
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|offset2
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
return|return
name|NULL_TREE
return|;
name|base
operator|=
name|TREE_OPERAND
argument_list|(
name|base
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|offset
operator|=
name|int_const_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|offset
argument_list|,
name|offset2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
block|{
comment|/* Strip the ADDR_EXPR.  */
name|base
operator|=
name|TREE_OPERAND
argument_list|(
name|base
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Fold away CONST_DECL to its value, if the type is scalar.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|CONST_DECL
operator|&&
name|ccp_decl_initial_min_invariant
argument_list|(
name|DECL_INITIAL
argument_list|(
name|base
argument_list|)
argument_list|)
condition|)
return|return
name|DECL_INITIAL
argument_list|(
name|base
argument_list|)
return|;
comment|/* Try folding *(&B+O) to B[X].  */
name|t
operator|=
name|maybe_fold_offset_to_array_ref
argument_list|(
name|base
argument_list|,
name|offset
argument_list|,
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
return|return
name|t
return|;
comment|/* Try folding *(&B+O) to B.X.  */
name|t
operator|=
name|maybe_fold_offset_to_component_ref
argument_list|(
name|TREE_TYPE
argument_list|(
name|base
argument_list|)
argument_list|,
name|base
argument_list|,
name|offset
argument_list|,
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
return|return
name|t
return|;
comment|/* Fold *&B to B.  We can only do this if EXPR is the same type 	 as BASE.  We can't do this if EXPR is the element type of an array 	 and BASE is the array.  */
if|if
condition|(
name|integer_zerop
argument_list|(
name|offset
argument_list|)
operator|&&
name|lang_hooks
operator|.
name|types_compatible_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|base
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
return|return
name|base
return|;
block|}
else|else
block|{
comment|/* We can get here for out-of-range string constant accesses,  	 such as "_"[3].  Bail out of the entire substitution search 	 and arrange for the entire statement to be replaced by a 	 call to __builtin_trap.  In all likelihood this will all be 	 constant-folded away, but in the meantime we can't leave with 	 something that get_expr_operands can't understand.  */
name|t
operator|=
name|base
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|STRING_CST
condition|)
block|{
comment|/* FIXME: Except that this causes problems elsewhere with dead 	     code not being deleted, and we die in the rtl expanders  	     because we failed to remove some ssa_name.  In the meantime, 	     just return zero.  */
comment|/* FIXME2: This condition should be signaled by 	     fold_read_from_constant_string directly, rather than  	     re-checking for it here.  */
return|return
name|integer_zero_node
return|;
block|}
comment|/* Try folding *(B+O) to B->X.  Still an improvement.  */
if|if
condition|(
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|base
argument_list|)
argument_list|)
condition|)
block|{
name|t
operator|=
name|maybe_fold_offset_to_component_ref
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|base
argument_list|)
argument_list|)
argument_list|,
name|base
argument_list|,
name|offset
argument_list|,
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
return|return
name|t
return|;
block|}
block|}
comment|/* Otherwise we had an offset that we could not simplify.  */
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* A subroutine of fold_stmt_r.  EXPR is a PLUS_EXPR.     A quaint feature extant in our address arithmetic is that there    can be hidden type changes here.  The type of the result need    not be the same as the type of the input pointer.     What we're after here is an expression of the form 	(T *)(&array + const)    where the cast doesn't actually exist, but is implicit in the    type of the PLUS_EXPR.  We'd like to turn this into&array[x]    which may be able to propagate further.  */
end_comment

begin_function
specifier|static
name|tree
name|maybe_fold_stmt_addition
parameter_list|(
name|tree
name|expr
parameter_list|)
block|{
name|tree
name|op0
init|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|op1
init|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|ptr_type
init|=
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
decl_stmt|;
name|tree
name|ptd_type
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|bool
name|subtract
init|=
operator|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|MINUS_EXPR
operator|)
decl_stmt|;
comment|/* We're only interested in pointer arithmetic.  */
if|if
condition|(
operator|!
name|POINTER_TYPE_P
argument_list|(
name|ptr_type
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
comment|/* Canonicalize the integral operand to op1.  */
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|subtract
condition|)
return|return
name|NULL_TREE
return|;
name|t
operator|=
name|op0
operator|,
name|op0
operator|=
name|op1
operator|,
name|op1
operator|=
name|t
expr_stmt|;
block|}
comment|/* It had better be a constant.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
return|return
name|NULL_TREE
return|;
comment|/* The first operand should be an ADDR_EXPR.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|ADDR_EXPR
condition|)
return|return
name|NULL_TREE
return|;
name|op0
operator|=
name|TREE_OPERAND
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If the first operand is an ARRAY_REF, expand it so that we can fold      the offset into it.  */
while|while
condition|(
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|ARRAY_REF
condition|)
block|{
name|tree
name|array_obj
init|=
name|TREE_OPERAND
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|array_idx
init|=
name|TREE_OPERAND
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|elt_type
init|=
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
decl_stmt|;
name|tree
name|elt_size
init|=
name|TYPE_SIZE_UNIT
argument_list|(
name|elt_type
argument_list|)
decl_stmt|;
name|tree
name|min_idx
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|array_idx
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
break|break;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|elt_size
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
break|break;
comment|/* Un-bias the index by the min index of the array type.  */
name|min_idx
operator|=
name|TYPE_DOMAIN
argument_list|(
name|TREE_TYPE
argument_list|(
name|array_obj
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|min_idx
condition|)
block|{
name|min_idx
operator|=
name|TYPE_MIN_VALUE
argument_list|(
name|min_idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|min_idx
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|min_idx
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
break|break;
name|array_idx
operator|=
name|fold_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|min_idx
argument_list|)
argument_list|,
name|array_idx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|integer_zerop
argument_list|(
name|min_idx
argument_list|)
condition|)
name|array_idx
operator|=
name|int_const_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|array_idx
argument_list|,
name|min_idx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Convert the index to a byte offset.  */
name|array_idx
operator|=
name|fold_convert
argument_list|(
name|sizetype
argument_list|,
name|array_idx
argument_list|)
expr_stmt|;
name|array_idx
operator|=
name|int_const_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|array_idx
argument_list|,
name|elt_size
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Update the operands for the next round, or for folding.  */
comment|/* If we're manipulating unsigned types, then folding into negative 	 values can produce incorrect results.  Particularly if the type 	 is smaller than the width of the pointer.  */
if|if
condition|(
name|subtract
operator|&&
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
argument_list|)
operator|&&
name|tree_int_cst_lt
argument_list|(
name|array_idx
argument_list|,
name|op1
argument_list|)
condition|)
return|return
name|NULL
return|;
name|op1
operator|=
name|int_const_binop
argument_list|(
name|subtract
condition|?
name|MINUS_EXPR
else|:
name|PLUS_EXPR
argument_list|,
name|array_idx
argument_list|,
name|op1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|subtract
operator|=
name|false
expr_stmt|;
name|op0
operator|=
name|array_obj
expr_stmt|;
block|}
comment|/* If we weren't able to fold the subtraction into another array reference,      canonicalize the integer for passing to the array and component ref      simplification functions.  */
if|if
condition|(
name|subtract
condition|)
block|{
if|if
condition|(
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
argument_list|)
condition|)
return|return
name|NULL
return|;
name|op1
operator|=
name|fold_unary
argument_list|(
name|NEGATE_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
argument_list|,
name|op1
argument_list|)
expr_stmt|;
comment|/* ??? In theory fold should always produce another integer.  */
if|if
condition|(
name|op1
operator|==
name|NULL
operator|||
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
return|return
name|NULL
return|;
block|}
name|ptd_type
operator|=
name|TREE_TYPE
argument_list|(
name|ptr_type
argument_list|)
expr_stmt|;
comment|/* At which point we can try some of the same things as for indirects.  */
name|t
operator|=
name|maybe_fold_offset_to_array_ref
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|,
name|ptd_type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|t
condition|)
name|t
operator|=
name|maybe_fold_offset_to_component_ref
argument_list|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|ptd_type
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
name|t
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|ptr_type
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* For passing state through walk_tree into fold_stmt_r and its    children.  */
end_comment

begin_struct
struct|struct
name|fold_stmt_r_data
block|{
name|tree
name|stmt
decl_stmt|;
name|bool
modifier|*
name|changed_p
decl_stmt|;
name|bool
modifier|*
name|inside_addr_expr_p
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Subroutine of fold_stmt called via walk_tree.  We perform several    simplifications of EXPR_P, mostly having to do with pointer arithmetic.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_stmt_r
parameter_list|(
name|tree
modifier|*
name|expr_p
parameter_list|,
name|int
modifier|*
name|walk_subtrees
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|fold_stmt_r_data
modifier|*
name|fold_stmt_r_data
init|=
operator|(
expr|struct
name|fold_stmt_r_data
operator|*
operator|)
name|data
decl_stmt|;
name|bool
modifier|*
name|inside_addr_expr_p
init|=
name|fold_stmt_r_data
operator|->
name|inside_addr_expr_p
decl_stmt|;
name|bool
modifier|*
name|changed_p
init|=
name|fold_stmt_r_data
operator|->
name|changed_p
decl_stmt|;
name|tree
name|expr
init|=
operator|*
name|expr_p
decl_stmt|,
name|t
decl_stmt|;
comment|/* ??? It'd be nice if walk_tree had a pre-order option.  */
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
condition|)
block|{
case|case
name|INDIRECT_REF
case|:
name|t
operator|=
name|walk_tree
argument_list|(
operator|&
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|fold_stmt_r
argument_list|,
name|data
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
return|return
name|t
return|;
operator|*
name|walk_subtrees
operator|=
literal|0
expr_stmt|;
name|t
operator|=
name|maybe_fold_stmt_indirect
argument_list|(
name|expr
argument_list|,
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|integer_zero_node
argument_list|)
expr_stmt|;
break|break;
comment|/* ??? Could handle more ARRAY_REFs here, as a variant of INDIRECT_REF. 	 We'd only want to bother decomposing an existing ARRAY_REF if 	 the base array is found to have another offset contained within. 	 Otherwise we'd be wasting time.  */
case|case
name|ARRAY_REF
case|:
comment|/* If we are not processing expressions found within an 	 ADDR_EXPR, then we can fold constant array references.  */
if|if
condition|(
operator|!
operator|*
name|inside_addr_expr_p
condition|)
name|t
operator|=
name|fold_read_from_constant_string
argument_list|(
name|expr
argument_list|)
expr_stmt|;
else|else
name|t
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|ADDR_EXPR
case|:
operator|*
name|inside_addr_expr_p
operator|=
name|true
expr_stmt|;
name|t
operator|=
name|walk_tree
argument_list|(
operator|&
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|fold_stmt_r
argument_list|,
name|data
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|inside_addr_expr_p
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|t
condition|)
return|return
name|t
return|;
operator|*
name|walk_subtrees
operator|=
literal|0
expr_stmt|;
comment|/* Set TREE_INVARIANT properly so that the value is properly 	 considered constant, and so gets propagated as expected.  */
if|if
condition|(
operator|*
name|changed_p
condition|)
name|recompute_tree_invariant_for_addr_expr
argument_list|(
name|expr
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
case|case
name|PLUS_EXPR
case|:
case|case
name|MINUS_EXPR
case|:
name|t
operator|=
name|walk_tree
argument_list|(
operator|&
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|fold_stmt_r
argument_list|,
name|data
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
return|return
name|t
return|;
name|t
operator|=
name|walk_tree
argument_list|(
operator|&
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|,
name|fold_stmt_r
argument_list|,
name|data
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
return|return
name|t
return|;
operator|*
name|walk_subtrees
operator|=
literal|0
expr_stmt|;
name|t
operator|=
name|maybe_fold_stmt_addition
argument_list|(
name|expr
argument_list|)
expr_stmt|;
break|break;
case|case
name|COMPONENT_REF
case|:
name|t
operator|=
name|walk_tree
argument_list|(
operator|&
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|fold_stmt_r
argument_list|,
name|data
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
return|return
name|t
return|;
operator|*
name|walk_subtrees
operator|=
literal|0
expr_stmt|;
comment|/* Make sure the FIELD_DECL is actually a field in the type on the lhs. 	 We've already checked that the records are compatible, so we should 	 come up with a set of compatible fields.  */
block|{
name|tree
name|expr_record
init|=
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|expr_field
init|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|DECL_FIELD_CONTEXT
argument_list|(
name|expr_field
argument_list|)
operator|!=
name|TYPE_MAIN_VARIANT
argument_list|(
name|expr_record
argument_list|)
condition|)
block|{
name|expr_field
operator|=
name|find_compatible_field
argument_list|(
name|expr_record
argument_list|,
name|expr_field
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
operator|=
name|expr_field
expr_stmt|;
block|}
block|}
break|break;
case|case
name|TARGET_MEM_REF
case|:
name|t
operator|=
name|maybe_fold_tmr
argument_list|(
name|expr
argument_list|)
expr_stmt|;
break|break;
case|case
name|COND_EXPR
case|:
if|if
condition|(
name|COMPARISON_CLASS_P
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|op0
init|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|tem
decl_stmt|;
name|bool
name|set
decl_stmt|;
name|fold_defer_overflow_warnings
argument_list|()
expr_stmt|;
name|tem
operator|=
name|fold_binary
argument_list|(
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|set
operator|=
name|tem
operator|&&
name|is_gimple_condexpr
argument_list|(
name|tem
argument_list|)
expr_stmt|;
name|fold_undefer_overflow_warnings
argument_list|(
name|set
argument_list|,
name|fold_stmt_r_data
operator|->
name|stmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|set
condition|)
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
operator|=
name|tem
expr_stmt|;
name|t
operator|=
name|expr
expr_stmt|;
break|break;
block|}
default|default:
return|return
name|NULL_TREE
return|;
block|}
if|if
condition|(
name|t
condition|)
block|{
operator|*
name|expr_p
operator|=
name|t
expr_stmt|;
operator|*
name|changed_p
operator|=
name|true
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Return the string length, maximum string length or maximum value of    ARG in LENGTH.    If ARG is an SSA name variable, follow its use-def chains.  If LENGTH    is not NULL and, for TYPE == 0, its value is not equal to the length    we determine or if we are unable to determine the length or value,    return false.  VISITED is a bitmap of visited variables.    TYPE is 0 if string length should be returned, 1 for maximum string    length and 2 for maximum value ARG can have.  */
end_comment

begin_function
specifier|static
name|bool
name|get_maxval_strlen
parameter_list|(
name|tree
name|arg
parameter_list|,
name|tree
modifier|*
name|length
parameter_list|,
name|bitmap
name|visited
parameter_list|,
name|int
name|type
parameter_list|)
block|{
name|tree
name|var
decl_stmt|,
name|def_stmt
decl_stmt|,
name|val
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|!=
name|SSA_NAME
condition|)
block|{
if|if
condition|(
name|type
operator|==
literal|2
condition|)
block|{
name|val
operator|=
name|arg
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
name|tree_int_cst_sgn
argument_list|(
name|val
argument_list|)
operator|<
literal|0
condition|)
return|return
name|false
return|;
block|}
else|else
name|val
operator|=
name|c_strlen
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|val
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|*
name|length
condition|)
block|{
if|if
condition|(
name|type
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|length
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
return|return
name|false
return|;
if|if
condition|(
name|tree_int_cst_lt
argument_list|(
operator|*
name|length
argument_list|,
name|val
argument_list|)
condition|)
operator|*
name|length
operator|=
name|val
expr_stmt|;
return|return
name|true
return|;
block|}
elseif|else
if|if
condition|(
name|simple_cst_equal
argument_list|(
name|val
argument_list|,
operator|*
name|length
argument_list|)
operator|!=
literal|1
condition|)
return|return
name|false
return|;
block|}
operator|*
name|length
operator|=
name|val
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* If we were already here, break the infinite cycle.  */
if|if
condition|(
name|bitmap_bit_p
argument_list|(
name|visited
argument_list|,
name|SSA_NAME_VERSION
argument_list|(
name|arg
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
name|bitmap_set_bit
argument_list|(
name|visited
argument_list|,
name|SSA_NAME_VERSION
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
name|var
operator|=
name|arg
expr_stmt|;
name|def_stmt
operator|=
name|SSA_NAME_DEF_STMT
argument_list|(
name|var
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|def_stmt
argument_list|)
condition|)
block|{
case|case
name|MODIFY_EXPR
case|:
block|{
name|tree
name|rhs
decl_stmt|;
comment|/* The RHS of the statement defining VAR must either have a 	     constant length or come from another SSA_NAME with a constant 	     length.  */
name|rhs
operator|=
name|TREE_OPERAND
argument_list|(
name|def_stmt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
return|return
name|get_maxval_strlen
argument_list|(
name|rhs
argument_list|,
name|length
argument_list|,
name|visited
argument_list|,
name|type
argument_list|)
return|;
block|}
case|case
name|PHI_NODE
case|:
block|{
comment|/* All the arguments of the PHI node must have the same constant 	     length.  */
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PHI_NUM_ARGS
argument_list|(
name|def_stmt
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|arg
init|=
name|PHI_ARG_DEF
argument_list|(
name|def_stmt
argument_list|,
name|i
argument_list|)
decl_stmt|;
comment|/* If this PHI has itself as an argument, we cannot 		 determine the string length of this argument.  However, 		 if we can find a constant string length for the other 		 PHI args then we can still be sure that this is a 		 constant string length.  So be optimistic and just 		 continue with the next argument.  */
if|if
condition|(
name|arg
operator|==
name|PHI_RESULT
argument_list|(
name|def_stmt
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|get_maxval_strlen
argument_list|(
name|arg
argument_list|,
name|length
argument_list|,
name|visited
argument_list|,
name|type
argument_list|)
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
default|default:
break|break;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Fold builtin call FN in statement STMT.  If it cannot be folded into a    constant, return NULL_TREE.  Otherwise, return its constant value.  */
end_comment

begin_function
specifier|static
name|tree
name|ccp_fold_builtin
parameter_list|(
name|tree
name|stmt
parameter_list|,
name|tree
name|fn
parameter_list|)
block|{
name|tree
name|result
decl_stmt|,
name|val
index|[
literal|3
index|]
decl_stmt|;
name|tree
name|callee
decl_stmt|,
name|arglist
decl_stmt|,
name|a
decl_stmt|;
name|int
name|arg_mask
decl_stmt|,
name|i
decl_stmt|,
name|type
decl_stmt|;
name|bitmap
name|visited
decl_stmt|;
name|bool
name|ignore
decl_stmt|;
name|ignore
operator|=
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|!=
name|MODIFY_EXPR
expr_stmt|;
comment|/* First try the generic builtin folder.  If that succeeds, return the      result directly.  */
name|callee
operator|=
name|get_callee_fndecl
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|TREE_OPERAND
argument_list|(
name|fn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|result
operator|=
name|fold_builtin
argument_list|(
name|callee
argument_list|,
name|arglist
argument_list|,
name|ignore
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
block|{
if|if
condition|(
name|ignore
condition|)
name|STRIP_NOPS
argument_list|(
name|result
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
comment|/* Ignore MD builtins.  */
if|if
condition|(
name|DECL_BUILT_IN_CLASS
argument_list|(
name|callee
argument_list|)
operator|==
name|BUILT_IN_MD
condition|)
return|return
name|NULL_TREE
return|;
comment|/* If the builtin could not be folded, and it has no argument list,      we're done.  */
if|if
condition|(
operator|!
name|arglist
condition|)
return|return
name|NULL_TREE
return|;
comment|/* Limit the work only for builtins we know how to simplify.  */
switch|switch
condition|(
name|DECL_FUNCTION_CODE
argument_list|(
name|callee
argument_list|)
condition|)
block|{
case|case
name|BUILT_IN_STRLEN
case|:
case|case
name|BUILT_IN_FPUTS
case|:
case|case
name|BUILT_IN_FPUTS_UNLOCKED
case|:
name|arg_mask
operator|=
literal|1
expr_stmt|;
name|type
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|BUILT_IN_STRCPY
case|:
case|case
name|BUILT_IN_STRNCPY
case|:
name|arg_mask
operator|=
literal|2
expr_stmt|;
name|type
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|BUILT_IN_MEMCPY_CHK
case|:
case|case
name|BUILT_IN_MEMPCPY_CHK
case|:
case|case
name|BUILT_IN_MEMMOVE_CHK
case|:
case|case
name|BUILT_IN_MEMSET_CHK
case|:
case|case
name|BUILT_IN_STRNCPY_CHK
case|:
name|arg_mask
operator|=
literal|4
expr_stmt|;
name|type
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|BUILT_IN_STRCPY_CHK
case|:
case|case
name|BUILT_IN_STPCPY_CHK
case|:
name|arg_mask
operator|=
literal|2
expr_stmt|;
name|type
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|BUILT_IN_SNPRINTF_CHK
case|:
case|case
name|BUILT_IN_VSNPRINTF_CHK
case|:
name|arg_mask
operator|=
literal|2
expr_stmt|;
name|type
operator|=
literal|2
expr_stmt|;
break|break;
default|default:
return|return
name|NULL_TREE
return|;
block|}
comment|/* Try to use the dataflow information gathered by the CCP process.  */
name|visited
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|val
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|a
operator|=
name|arglist
init|;
name|arg_mask
condition|;
name|i
operator|++
operator|,
name|arg_mask
operator|>>=
literal|1
operator|,
name|a
operator|=
name|TREE_CHAIN
argument_list|(
name|a
argument_list|)
control|)
if|if
condition|(
name|arg_mask
operator|&
literal|1
condition|)
block|{
name|bitmap_clear
argument_list|(
name|visited
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|get_maxval_strlen
argument_list|(
name|TREE_VALUE
argument_list|(
name|a
argument_list|)
argument_list|,
operator|&
name|val
index|[
name|i
index|]
argument_list|,
name|visited
argument_list|,
name|type
argument_list|)
condition|)
name|val
index|[
name|i
index|]
operator|=
name|NULL_TREE
expr_stmt|;
block|}
name|BITMAP_FREE
argument_list|(
name|visited
argument_list|)
expr_stmt|;
name|result
operator|=
name|NULL_TREE
expr_stmt|;
switch|switch
condition|(
name|DECL_FUNCTION_CODE
argument_list|(
name|callee
argument_list|)
condition|)
block|{
case|case
name|BUILT_IN_STRLEN
case|:
if|if
condition|(
name|val
index|[
literal|0
index|]
condition|)
block|{
name|tree
name|new
init|=
name|fold_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|,
name|val
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
comment|/* If the result is not a valid gimple value, or not a cast 	     of a valid gimple value, then we can not use the result.  */
if|if
condition|(
name|is_gimple_val
argument_list|(
name|new
argument_list|)
operator|||
operator|(
name|is_gimple_cast
argument_list|(
name|new
argument_list|)
operator|&&
name|is_gimple_val
argument_list|(
name|TREE_OPERAND
argument_list|(
name|new
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
condition|)
return|return
name|new
return|;
block|}
break|break;
case|case
name|BUILT_IN_STRCPY
case|:
if|if
condition|(
name|val
index|[
literal|1
index|]
operator|&&
name|is_gimple_val
argument_list|(
name|val
index|[
literal|1
index|]
argument_list|)
condition|)
name|result
operator|=
name|fold_builtin_strcpy
argument_list|(
name|callee
argument_list|,
name|arglist
argument_list|,
name|val
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|BUILT_IN_STRNCPY
case|:
if|if
condition|(
name|val
index|[
literal|1
index|]
operator|&&
name|is_gimple_val
argument_list|(
name|val
index|[
literal|1
index|]
argument_list|)
condition|)
name|result
operator|=
name|fold_builtin_strncpy
argument_list|(
name|callee
argument_list|,
name|arglist
argument_list|,
name|val
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|BUILT_IN_FPUTS
case|:
name|result
operator|=
name|fold_builtin_fputs
argument_list|(
name|arglist
argument_list|,
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|!=
name|MODIFY_EXPR
argument_list|,
literal|0
argument_list|,
name|val
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|BUILT_IN_FPUTS_UNLOCKED
case|:
name|result
operator|=
name|fold_builtin_fputs
argument_list|(
name|arglist
argument_list|,
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|!=
name|MODIFY_EXPR
argument_list|,
literal|1
argument_list|,
name|val
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|BUILT_IN_MEMCPY_CHK
case|:
case|case
name|BUILT_IN_MEMPCPY_CHK
case|:
case|case
name|BUILT_IN_MEMMOVE_CHK
case|:
case|case
name|BUILT_IN_MEMSET_CHK
case|:
if|if
condition|(
name|val
index|[
literal|2
index|]
operator|&&
name|is_gimple_val
argument_list|(
name|val
index|[
literal|2
index|]
argument_list|)
condition|)
name|result
operator|=
name|fold_builtin_memory_chk
argument_list|(
name|callee
argument_list|,
name|arglist
argument_list|,
name|val
index|[
literal|2
index|]
argument_list|,
name|ignore
argument_list|,
name|DECL_FUNCTION_CODE
argument_list|(
name|callee
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|BUILT_IN_STRCPY_CHK
case|:
case|case
name|BUILT_IN_STPCPY_CHK
case|:
if|if
condition|(
name|val
index|[
literal|1
index|]
operator|&&
name|is_gimple_val
argument_list|(
name|val
index|[
literal|1
index|]
argument_list|)
condition|)
name|result
operator|=
name|fold_builtin_stxcpy_chk
argument_list|(
name|callee
argument_list|,
name|arglist
argument_list|,
name|val
index|[
literal|1
index|]
argument_list|,
name|ignore
argument_list|,
name|DECL_FUNCTION_CODE
argument_list|(
name|callee
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|BUILT_IN_STRNCPY_CHK
case|:
if|if
condition|(
name|val
index|[
literal|2
index|]
operator|&&
name|is_gimple_val
argument_list|(
name|val
index|[
literal|2
index|]
argument_list|)
condition|)
name|result
operator|=
name|fold_builtin_strncpy_chk
argument_list|(
name|arglist
argument_list|,
name|val
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|BUILT_IN_SNPRINTF_CHK
case|:
case|case
name|BUILT_IN_VSNPRINTF_CHK
case|:
if|if
condition|(
name|val
index|[
literal|1
index|]
operator|&&
name|is_gimple_val
argument_list|(
name|val
index|[
literal|1
index|]
argument_list|)
condition|)
name|result
operator|=
name|fold_builtin_snprintf_chk
argument_list|(
name|arglist
argument_list|,
name|val
index|[
literal|1
index|]
argument_list|,
name|DECL_FUNCTION_CODE
argument_list|(
name|callee
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|&&
name|ignore
condition|)
name|result
operator|=
name|fold_ignored_result
argument_list|(
name|result
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Fold the statement pointed to by STMT_P.  In some cases, this function may    replace the whole statement with a new one.  Returns true iff folding    makes any changes.  */
end_comment

begin_function
name|bool
name|fold_stmt
parameter_list|(
name|tree
modifier|*
name|stmt_p
parameter_list|)
block|{
name|tree
name|rhs
decl_stmt|,
name|result
decl_stmt|,
name|stmt
decl_stmt|;
name|struct
name|fold_stmt_r_data
name|fold_stmt_r_data
decl_stmt|;
name|bool
name|changed
init|=
name|false
decl_stmt|;
name|bool
name|inside_addr_expr
init|=
name|false
decl_stmt|;
name|stmt
operator|=
operator|*
name|stmt_p
expr_stmt|;
name|fold_stmt_r_data
operator|.
name|stmt
operator|=
name|stmt
expr_stmt|;
name|fold_stmt_r_data
operator|.
name|changed_p
operator|=
operator|&
name|changed
expr_stmt|;
name|fold_stmt_r_data
operator|.
name|inside_addr_expr_p
operator|=
operator|&
name|inside_addr_expr
expr_stmt|;
comment|/* If we replaced constants and the statement makes pointer dereferences,      then we may need to fold instances of *&VAR into VAR, etc.  */
if|if
condition|(
name|walk_tree
argument_list|(
name|stmt_p
argument_list|,
name|fold_stmt_r
argument_list|,
operator|&
name|fold_stmt_r_data
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
operator|*
name|stmt_p
operator|=
name|build_function_call_expr
argument_list|(
name|implicit_built_in_decls
index|[
name|BUILT_IN_TRAP
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
name|rhs
operator|=
name|get_rhs
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rhs
condition|)
return|return
name|changed
return|;
name|result
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|CALL_EXPR
condition|)
block|{
name|tree
name|callee
decl_stmt|;
comment|/* Check for builtins that CCP can handle using information not 	 available in the generic fold routines.  */
name|callee
operator|=
name|get_callee_fndecl
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
if|if
condition|(
name|callee
operator|&&
name|DECL_BUILT_IN
argument_list|(
name|callee
argument_list|)
condition|)
name|result
operator|=
name|ccp_fold_builtin
argument_list|(
name|stmt
argument_list|,
name|rhs
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Check for resolvable OBJ_TYPE_REF.  The only sorts we can resolve 	     here are when we've propagated the address of a decl into the 	     object slot.  */
comment|/* ??? Should perhaps do this in fold proper.  However, doing it 	     there requires that we create a new CALL_EXPR, and that requires 	     copying EH region info to the new node.  Easier to just do it 	     here where we can just smash the call operand. Also 	     CALL_EXPR_RETURN_SLOT_OPT needs to be handled correctly and 	     copied, fold_ternary does not have not information. */
name|callee
operator|=
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|callee
argument_list|)
operator|==
name|OBJ_TYPE_REF
operator|&&
name|lang_hooks
operator|.
name|fold_obj_type_ref
operator|&&
name|TREE_CODE
argument_list|(
name|OBJ_TYPE_REF_OBJECT
argument_list|(
name|callee
argument_list|)
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
name|DECL_P
argument_list|(
name|TREE_OPERAND
argument_list|(
name|OBJ_TYPE_REF_OBJECT
argument_list|(
name|callee
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|t
decl_stmt|;
comment|/* ??? Caution: Broken ADDR_EXPR semantics means that 		 looking at the type of the operand of the addr_expr 		 can yield an array type.  See silly exception in 		 check_pointer_types_r.  */
name|t
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|OBJ_TYPE_REF_OBJECT
argument_list|(
name|callee
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|lang_hooks
operator|.
name|fold_obj_type_ref
argument_list|(
name|callee
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
block|{
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
operator|=
name|t
expr_stmt|;
name|changed
operator|=
name|true
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* If we couldn't fold the RHS, hand over to the generic fold routines.  */
if|if
condition|(
name|result
operator|==
name|NULL_TREE
condition|)
name|result
operator|=
name|fold
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
comment|/* Strip away useless type conversions.  Both the NON_LVALUE_EXPR that      may have been added by fold, and "useless" type conversions that might      now be apparent due to propagation.  */
name|STRIP_USELESS_TYPE_CONVERSION
argument_list|(
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|rhs
condition|)
name|changed
operator||=
name|set_rhs
argument_list|(
name|stmt_p
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
name|changed
return|;
block|}
end_function

begin_comment
comment|/* Perform the minimal folding on statement STMT.  Only operations like    *&x created by constant propagation are handled.  The statement cannot    be replaced with a new one.  */
end_comment

begin_function
name|bool
name|fold_stmt_inplace
parameter_list|(
name|tree
name|stmt
parameter_list|)
block|{
name|tree
name|old_stmt
init|=
name|stmt
decl_stmt|,
name|rhs
decl_stmt|,
name|new_rhs
decl_stmt|;
name|struct
name|fold_stmt_r_data
name|fold_stmt_r_data
decl_stmt|;
name|bool
name|changed
init|=
name|false
decl_stmt|;
name|bool
name|inside_addr_expr
init|=
name|false
decl_stmt|;
name|fold_stmt_r_data
operator|.
name|stmt
operator|=
name|stmt
expr_stmt|;
name|fold_stmt_r_data
operator|.
name|changed_p
operator|=
operator|&
name|changed
expr_stmt|;
name|fold_stmt_r_data
operator|.
name|inside_addr_expr_p
operator|=
operator|&
name|inside_addr_expr
expr_stmt|;
name|walk_tree
argument_list|(
operator|&
name|stmt
argument_list|,
name|fold_stmt_r
argument_list|,
operator|&
name|fold_stmt_r_data
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|stmt
operator|==
name|old_stmt
argument_list|)
expr_stmt|;
name|rhs
operator|=
name|get_rhs
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rhs
operator|||
name|rhs
operator|==
name|stmt
condition|)
return|return
name|changed
return|;
name|new_rhs
operator|=
name|fold
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
name|STRIP_USELESS_TYPE_CONVERSION
argument_list|(
name|new_rhs
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_rhs
operator|==
name|rhs
condition|)
return|return
name|changed
return|;
name|changed
operator||=
name|set_rhs
argument_list|(
operator|&
name|stmt
argument_list|,
name|new_rhs
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|stmt
operator|==
name|old_stmt
argument_list|)
expr_stmt|;
return|return
name|changed
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Convert EXPR into a GIMPLE value suitable for substitution on the    RHS of an assignment.  Insert the necessary statements before    iterator *SI_P.  */
end_comment

begin_function
specifier|static
name|tree
name|convert_to_gimple_builtin
parameter_list|(
name|block_stmt_iterator
modifier|*
name|si_p
parameter_list|,
name|tree
name|expr
parameter_list|)
block|{
name|tree_stmt_iterator
name|ti
decl_stmt|;
name|tree
name|stmt
init|=
name|bsi_stmt
argument_list|(
operator|*
name|si_p
argument_list|)
decl_stmt|;
name|tree
name|tmp
decl_stmt|,
name|stmts
init|=
name|NULL
decl_stmt|;
name|push_gimplify_context
argument_list|()
expr_stmt|;
name|tmp
operator|=
name|get_initialized_tmp_var
argument_list|(
name|expr
argument_list|,
operator|&
name|stmts
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|pop_gimplify_context
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|EXPR_HAS_LOCATION
argument_list|(
name|stmt
argument_list|)
condition|)
name|annotate_all_with_locus
argument_list|(
operator|&
name|stmts
argument_list|,
name|EXPR_LOCATION
argument_list|(
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The replacement can expose previously unreferenced variables.  */
for|for
control|(
name|ti
operator|=
name|tsi_start
argument_list|(
name|stmts
argument_list|)
init|;
operator|!
name|tsi_end_p
argument_list|(
name|ti
argument_list|)
condition|;
name|tsi_next
argument_list|(
operator|&
name|ti
argument_list|)
control|)
block|{
name|tree
name|new_stmt
init|=
name|tsi_stmt
argument_list|(
name|ti
argument_list|)
decl_stmt|;
name|find_new_referenced_vars
argument_list|(
name|tsi_stmt_ptr
argument_list|(
name|ti
argument_list|)
argument_list|)
expr_stmt|;
name|bsi_insert_before
argument_list|(
name|si_p
argument_list|,
name|new_stmt
argument_list|,
name|BSI_NEW_STMT
argument_list|)
expr_stmt|;
name|mark_new_vars_to_rename
argument_list|(
name|bsi_stmt
argument_list|(
operator|*
name|si_p
argument_list|)
argument_list|)
expr_stmt|;
name|bsi_next
argument_list|(
name|si_p
argument_list|)
expr_stmt|;
block|}
return|return
name|tmp
return|;
block|}
end_function

begin_comment
comment|/* A simple pass that attempts to fold all builtin functions.  This pass    is run after we've propagated as many constants as we can.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|execute_fold_all_builtins
parameter_list|(
name|void
parameter_list|)
block|{
name|bool
name|cfg_changed
init|=
name|false
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|block_stmt_iterator
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|bsi_start
argument_list|(
name|bb
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|i
argument_list|)
condition|;
control|)
block|{
name|tree
modifier|*
name|stmtp
init|=
name|bsi_stmt_ptr
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|tree
name|old_stmt
init|=
operator|*
name|stmtp
decl_stmt|;
name|tree
name|call
init|=
name|get_rhs
argument_list|(
operator|*
name|stmtp
argument_list|)
decl_stmt|;
name|tree
name|callee
decl_stmt|,
name|result
decl_stmt|;
name|enum
name|built_in_function
name|fcode
decl_stmt|;
if|if
condition|(
operator|!
name|call
operator|||
name|TREE_CODE
argument_list|(
name|call
argument_list|)
operator|!=
name|CALL_EXPR
condition|)
block|{
name|bsi_next
argument_list|(
operator|&
name|i
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|callee
operator|=
name|get_callee_fndecl
argument_list|(
name|call
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|callee
operator|||
name|DECL_BUILT_IN_CLASS
argument_list|(
name|callee
argument_list|)
operator|!=
name|BUILT_IN_NORMAL
condition|)
block|{
name|bsi_next
argument_list|(
operator|&
name|i
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|fcode
operator|=
name|DECL_FUNCTION_CODE
argument_list|(
name|callee
argument_list|)
expr_stmt|;
name|result
operator|=
name|ccp_fold_builtin
argument_list|(
operator|*
name|stmtp
argument_list|,
name|call
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|result
condition|)
switch|switch
condition|(
name|DECL_FUNCTION_CODE
argument_list|(
name|callee
argument_list|)
condition|)
block|{
case|case
name|BUILT_IN_CONSTANT_P
case|:
comment|/* Resolve __builtin_constant_p.  If it hasn't been 		   folded to integer_one_node by now, it's fairly 		   certain that the value simply isn't constant.  */
name|result
operator|=
name|integer_zero_node
expr_stmt|;
break|break;
default|default:
name|bsi_next
argument_list|(
operator|&
name|i
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Simplified\n  "
argument_list|)
expr_stmt|;
name|print_generic_stmt
argument_list|(
name|dump_file
argument_list|,
operator|*
name|stmtp
argument_list|,
name|dump_flags
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|set_rhs
argument_list|(
name|stmtp
argument_list|,
name|result
argument_list|)
condition|)
block|{
name|result
operator|=
name|convert_to_gimple_builtin
argument_list|(
operator|&
name|i
argument_list|,
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
block|{
name|bool
name|ok
init|=
name|set_rhs
argument_list|(
name|stmtp
argument_list|,
name|result
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
name|ok
argument_list|)
expr_stmt|;
block|}
block|}
name|mark_new_vars_to_rename
argument_list|(
operator|*
name|stmtp
argument_list|)
expr_stmt|;
if|if
condition|(
name|maybe_clean_or_replace_eh_stmt
argument_list|(
name|old_stmt
argument_list|,
operator|*
name|stmtp
argument_list|)
operator|&&
name|tree_purge_dead_eh_edges
argument_list|(
name|bb
argument_list|)
condition|)
name|cfg_changed
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"to\n  "
argument_list|)
expr_stmt|;
name|print_generic_stmt
argument_list|(
name|dump_file
argument_list|,
operator|*
name|stmtp
argument_list|,
name|dump_flags
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Retry the same statement if it changed into another 	     builtin, there might be new opportunities now.  */
name|call
operator|=
name|get_rhs
argument_list|(
operator|*
name|stmtp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|call
operator|||
name|TREE_CODE
argument_list|(
name|call
argument_list|)
operator|!=
name|CALL_EXPR
condition|)
block|{
name|bsi_next
argument_list|(
operator|&
name|i
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|callee
operator|=
name|get_callee_fndecl
argument_list|(
name|call
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|callee
operator|||
name|DECL_BUILT_IN_CLASS
argument_list|(
name|callee
argument_list|)
operator|!=
name|BUILT_IN_NORMAL
operator|||
name|DECL_FUNCTION_CODE
argument_list|(
name|callee
argument_list|)
operator|==
name|fcode
condition|)
name|bsi_next
argument_list|(
operator|&
name|i
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Delete unreachable blocks.  */
if|if
condition|(
name|cfg_changed
condition|)
name|cleanup_tree_cfg
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|tree_opt_pass
name|pass_fold_builtins
init|=
block|{
literal|"fab"
block|,
comment|/* name */
name|NULL
block|,
comment|/* gate */
name|execute_fold_all_builtins
block|,
comment|/* execute */
name|NULL
block|,
comment|/* sub */
name|NULL
block|,
comment|/* next */
literal|0
block|,
comment|/* static_pass_number */
literal|0
block|,
comment|/* tv_id */
name|PROP_cfg
operator||
name|PROP_ssa
operator||
name|PROP_alias
block|,
comment|/* properties_required */
literal|0
block|,
comment|/* properties_provided */
literal|0
block|,
comment|/* properties_destroyed */
literal|0
block|,
comment|/* todo_flags_start */
name|TODO_dump_func
operator||
name|TODO_verify_ssa
operator||
name|TODO_update_ssa
block|,
comment|/* todo_flags_finish */
literal|0
comment|/* letter */
block|}
decl_stmt|;
end_decl_stmt

end_unit

