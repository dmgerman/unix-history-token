begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* The tracer pass for the GNU compiler.    Contributed by Jan Hubicka, SuSE Labs.    Copyright (C) 2001, 2002 Free Software Foundation, Inc.     This file is part of GCC.     GCC is free software; you can redistribute it and/or modify it    under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GCC is distributed in the hope that it will be useful, but WITHOUT    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public    License for more details.     You should have received a copy of the GNU General Public License    along with GCC; see the file COPYING.  If not, write to the Free    Software Foundation, 59 Temple Place - Suite 330, Boston, MA    02111-1307, USA.  */
end_comment

begin_comment
comment|/* This pass performs the tail duplication needed for superblock formation.    For more information see:       Design and Analysis of Profile-Based Optimization in Compaq's      Compilation Tools for Alpha; Journal of Instruction-Level      Parallelism 3 (2000) 1-25     Unlike Compaq's implementation we don't do the loop peeling as most    probably a better job can be done by a special pass and we don't    need to worry too much about the code size implications as the tail    duplicates are crossjumped again if optimizations are not    performed.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"cfglayout.h"
end_include

begin_include
include|#
directive|include
file|"fibheap.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"params.h"
end_include

begin_include
include|#
directive|include
file|"profile.h"
end_include

begin_decl_stmt
specifier|static
name|int
name|count_insns
name|PARAMS
argument_list|(
operator|(
name|basic_block
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|ignore_bb_p
name|PARAMS
argument_list|(
operator|(
name|basic_block
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|better_p
name|PARAMS
argument_list|(
operator|(
name|edge
operator|,
name|edge
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|edge
name|find_best_successor
name|PARAMS
argument_list|(
operator|(
name|basic_block
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|edge
name|find_best_predecessor
name|PARAMS
argument_list|(
operator|(
name|basic_block
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|find_trace
name|PARAMS
argument_list|(
operator|(
name|basic_block
operator|,
name|basic_block
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|tail_duplicate
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|layout_superblocks
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|ignore_bb_p
name|PARAMS
argument_list|(
operator|(
name|basic_block
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Minimal outgoing edge probability considered for superblock formation.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|probability_cutoff
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|branch_ratio_cutoff
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return true if BB has been seen - it is connected to some trace    already.  */
end_comment

begin_define
define|#
directive|define
name|seen
parameter_list|(
name|bb
parameter_list|)
value|(RBI (bb)->visited || RBI (bb)->next)
end_define

begin_comment
comment|/* Return true if we should ignore the basic block for purposes of tracing.  */
end_comment

begin_function
specifier|static
name|bool
name|ignore_bb_p
parameter_list|(
name|bb
parameter_list|)
name|basic_block
name|bb
decl_stmt|;
block|{
if|if
condition|(
name|bb
operator|->
name|index
operator|<
literal|0
condition|)
return|return
name|true
return|;
if|if
condition|(
operator|!
name|maybe_hot_bb_p
argument_list|(
name|bb
argument_list|)
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Return number of instructions in the block.  */
end_comment

begin_function
specifier|static
name|int
name|count_insns
parameter_list|(
name|bb
parameter_list|)
name|basic_block
name|bb
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|;
name|int
name|n
init|=
literal|0
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|bb
operator|->
name|head
init|;
name|insn
operator|!=
name|NEXT_INSN
argument_list|(
name|bb
operator|->
name|end
argument_list|)
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|active_insn_p
argument_list|(
name|insn
argument_list|)
condition|)
name|n
operator|++
expr_stmt|;
return|return
name|n
return|;
block|}
end_function

begin_comment
comment|/* Return true if E1 is more frequent than E2.  */
end_comment

begin_function
specifier|static
name|bool
name|better_p
parameter_list|(
name|e1
parameter_list|,
name|e2
parameter_list|)
name|edge
name|e1
decl_stmt|,
name|e2
decl_stmt|;
block|{
if|if
condition|(
name|e1
operator|->
name|count
operator|!=
name|e2
operator|->
name|count
condition|)
return|return
name|e1
operator|->
name|count
operator|>
name|e2
operator|->
name|count
return|;
if|if
condition|(
name|e1
operator|->
name|src
operator|->
name|frequency
operator|*
name|e1
operator|->
name|probability
operator|!=
name|e2
operator|->
name|src
operator|->
name|frequency
operator|*
name|e2
operator|->
name|probability
condition|)
return|return
operator|(
name|e1
operator|->
name|src
operator|->
name|frequency
operator|*
name|e1
operator|->
name|probability
operator|>
name|e2
operator|->
name|src
operator|->
name|frequency
operator|*
name|e2
operator|->
name|probability
operator|)
return|;
comment|/* This is needed to avoid changes in the decision after      CFG is modified.  */
if|if
condition|(
name|e1
operator|->
name|src
operator|!=
name|e2
operator|->
name|src
condition|)
return|return
name|e1
operator|->
name|src
operator|->
name|index
operator|>
name|e2
operator|->
name|src
operator|->
name|index
return|;
return|return
name|e1
operator|->
name|dest
operator|->
name|index
operator|>
name|e2
operator|->
name|dest
operator|->
name|index
return|;
block|}
end_function

begin_comment
comment|/* Return most frequent successor of basic block BB.  */
end_comment

begin_function
specifier|static
name|edge
name|find_best_successor
parameter_list|(
name|bb
parameter_list|)
name|basic_block
name|bb
decl_stmt|;
block|{
name|edge
name|e
decl_stmt|;
name|edge
name|best
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
if|if
condition|(
operator|!
name|best
operator|||
name|better_p
argument_list|(
name|e
argument_list|,
name|best
argument_list|)
condition|)
name|best
operator|=
name|e
expr_stmt|;
if|if
condition|(
operator|!
name|best
operator|||
name|ignore_bb_p
argument_list|(
name|best
operator|->
name|dest
argument_list|)
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|best
operator|->
name|probability
operator|<=
name|probability_cutoff
condition|)
return|return
name|NULL
return|;
return|return
name|best
return|;
block|}
end_function

begin_comment
comment|/* Return most frequent predecessor of basic block BB.  */
end_comment

begin_function
specifier|static
name|edge
name|find_best_predecessor
parameter_list|(
name|bb
parameter_list|)
name|basic_block
name|bb
decl_stmt|;
block|{
name|edge
name|e
decl_stmt|;
name|edge
name|best
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|pred
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|pred_next
control|)
if|if
condition|(
operator|!
name|best
operator|||
name|better_p
argument_list|(
name|e
argument_list|,
name|best
argument_list|)
condition|)
name|best
operator|=
name|e
expr_stmt|;
if|if
condition|(
operator|!
name|best
operator|||
name|ignore_bb_p
argument_list|(
name|best
operator|->
name|src
argument_list|)
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|EDGE_FREQUENCY
argument_list|(
name|best
argument_list|)
operator|*
name|REG_BR_PROB_BASE
operator|<
name|bb
operator|->
name|frequency
operator|*
name|branch_ratio_cutoff
condition|)
return|return
name|NULL
return|;
return|return
name|best
return|;
block|}
end_function

begin_comment
comment|/* Find the trace using bb and record it in the TRACE array.    Return number of basic blocks recorded.  */
end_comment

begin_function
specifier|static
name|int
name|find_trace
parameter_list|(
name|bb
parameter_list|,
name|trace
parameter_list|)
name|basic_block
name|bb
decl_stmt|;
name|basic_block
modifier|*
name|trace
decl_stmt|;
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|edge
name|e
decl_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Trace seed %i [%i]"
argument_list|,
name|bb
operator|->
name|index
argument_list|,
name|bb
operator|->
name|frequency
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|e
operator|=
name|find_best_predecessor
argument_list|(
name|bb
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|basic_block
name|bb2
init|=
name|e
operator|->
name|src
decl_stmt|;
if|if
condition|(
name|seen
argument_list|(
name|bb2
argument_list|)
operator|||
operator|(
name|e
operator|->
name|flags
operator|&
operator|(
name|EDGE_DFS_BACK
operator||
name|EDGE_COMPLEX
operator|)
operator|)
operator|||
name|find_best_successor
argument_list|(
name|bb2
argument_list|)
operator|!=
name|e
condition|)
break|break;
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|",%i [%i]"
argument_list|,
name|bb
operator|->
name|index
argument_list|,
name|bb
operator|->
name|frequency
argument_list|)
expr_stmt|;
name|bb
operator|=
name|bb2
expr_stmt|;
block|}
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|" forward %i [%i]"
argument_list|,
name|bb
operator|->
name|index
argument_list|,
name|bb
operator|->
name|frequency
argument_list|)
expr_stmt|;
name|trace
index|[
name|i
operator|++
index|]
operator|=
name|bb
expr_stmt|;
comment|/* Follow the trace in forward direction.  */
while|while
condition|(
operator|(
name|e
operator|=
name|find_best_successor
argument_list|(
name|bb
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|bb
operator|=
name|e
operator|->
name|dest
expr_stmt|;
if|if
condition|(
name|seen
argument_list|(
name|bb
argument_list|)
operator|||
operator|(
name|e
operator|->
name|flags
operator|&
operator|(
name|EDGE_DFS_BACK
operator||
name|EDGE_COMPLEX
operator|)
operator|)
operator|||
name|find_best_predecessor
argument_list|(
name|bb
argument_list|)
operator|!=
name|e
condition|)
break|break;
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|",%i [%i]"
argument_list|,
name|bb
operator|->
name|index
argument_list|,
name|bb
operator|->
name|frequency
argument_list|)
expr_stmt|;
name|trace
index|[
name|i
operator|++
index|]
operator|=
name|bb
expr_stmt|;
block|}
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
return|return
name|i
return|;
block|}
end_function

begin_comment
comment|/* Look for basic blocks in frequency order, construct traces and tail duplicate    if profitable.  */
end_comment

begin_function
specifier|static
name|void
name|tail_duplicate
parameter_list|()
block|{
name|fibnode_t
modifier|*
name|blocks
init|=
name|xcalloc
argument_list|(
name|last_basic_block
argument_list|,
sizeof|sizeof
argument_list|(
name|fibnode_t
argument_list|)
argument_list|)
decl_stmt|;
name|basic_block
modifier|*
name|trace
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|basic_block
argument_list|)
operator|*
name|n_basic_blocks
argument_list|)
decl_stmt|;
name|int
modifier|*
name|counts
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|last_basic_block
argument_list|)
decl_stmt|;
name|int
name|ninsns
init|=
literal|0
decl_stmt|,
name|nduplicated
init|=
literal|0
decl_stmt|;
name|gcov_type
name|weighted_insns
init|=
literal|0
decl_stmt|,
name|traced_insns
init|=
literal|0
decl_stmt|;
name|fibheap_t
name|heap
init|=
name|fibheap_new
argument_list|()
decl_stmt|;
name|gcov_type
name|cover_insns
decl_stmt|;
name|int
name|max_dup_insns
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
if|if
condition|(
name|profile_info
operator|.
name|count_profiles_merged
operator|&&
name|flag_branch_probabilities
condition|)
name|probability_cutoff
operator|=
name|PARAM_VALUE
argument_list|(
name|TRACER_MIN_BRANCH_PROBABILITY_FEEDBACK
argument_list|)
expr_stmt|;
else|else
name|probability_cutoff
operator|=
name|PARAM_VALUE
argument_list|(
name|TRACER_MIN_BRANCH_PROBABILITY
argument_list|)
expr_stmt|;
name|probability_cutoff
operator|=
name|REG_BR_PROB_BASE
operator|/
literal|100
operator|*
name|probability_cutoff
expr_stmt|;
name|branch_ratio_cutoff
operator|=
operator|(
name|REG_BR_PROB_BASE
operator|/
literal|100
operator|*
name|PARAM_VALUE
argument_list|(
name|TRACER_MIN_BRANCH_RATIO
argument_list|)
operator|)
expr_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|int
name|n
init|=
name|count_insns
argument_list|(
name|bb
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ignore_bb_p
argument_list|(
name|bb
argument_list|)
condition|)
name|blocks
index|[
name|bb
operator|->
name|index
index|]
operator|=
name|fibheap_insert
argument_list|(
name|heap
argument_list|,
operator|-
name|bb
operator|->
name|frequency
argument_list|,
name|bb
argument_list|)
expr_stmt|;
name|counts
index|[
name|bb
operator|->
name|index
index|]
operator|=
name|n
expr_stmt|;
name|ninsns
operator|+=
name|n
expr_stmt|;
name|weighted_insns
operator|+=
name|n
operator|*
name|bb
operator|->
name|frequency
expr_stmt|;
block|}
if|if
condition|(
name|profile_info
operator|.
name|count_profiles_merged
operator|&&
name|flag_branch_probabilities
condition|)
name|cover_insns
operator|=
name|PARAM_VALUE
argument_list|(
name|TRACER_DYNAMIC_COVERAGE_FEEDBACK
argument_list|)
expr_stmt|;
else|else
name|cover_insns
operator|=
name|PARAM_VALUE
argument_list|(
name|TRACER_DYNAMIC_COVERAGE
argument_list|)
expr_stmt|;
name|cover_insns
operator|=
operator|(
name|weighted_insns
operator|*
name|cover_insns
operator|+
literal|50
operator|)
operator|/
literal|100
expr_stmt|;
name|max_dup_insns
operator|=
operator|(
name|ninsns
operator|*
name|PARAM_VALUE
argument_list|(
name|TRACER_MAX_CODE_GROWTH
argument_list|)
operator|+
literal|50
operator|)
operator|/
literal|100
expr_stmt|;
while|while
condition|(
name|traced_insns
operator|<
name|cover_insns
operator|&&
name|nduplicated
operator|<
name|max_dup_insns
operator|&&
operator|!
name|fibheap_empty
argument_list|(
name|heap
argument_list|)
condition|)
block|{
name|basic_block
name|bb
init|=
name|fibheap_extract_min
argument_list|(
name|heap
argument_list|)
decl_stmt|;
name|int
name|n
decl_stmt|,
name|pos
decl_stmt|;
if|if
condition|(
operator|!
name|bb
condition|)
break|break;
name|blocks
index|[
name|bb
operator|->
name|index
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ignore_bb_p
argument_list|(
name|bb
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|seen
argument_list|(
name|bb
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|n
operator|=
name|find_trace
argument_list|(
name|bb
argument_list|,
name|trace
argument_list|)
expr_stmt|;
name|bb
operator|=
name|trace
index|[
literal|0
index|]
expr_stmt|;
name|traced_insns
operator|+=
name|bb
operator|->
name|frequency
operator|*
name|counts
index|[
name|bb
operator|->
name|index
index|]
expr_stmt|;
if|if
condition|(
name|blocks
index|[
name|bb
operator|->
name|index
index|]
condition|)
block|{
name|fibheap_delete_node
argument_list|(
name|heap
argument_list|,
name|blocks
index|[
name|bb
operator|->
name|index
index|]
argument_list|)
expr_stmt|;
name|blocks
index|[
name|bb
operator|->
name|index
index|]
operator|=
name|NULL
expr_stmt|;
block|}
for|for
control|(
name|pos
operator|=
literal|1
init|;
name|pos
operator|<
name|n
condition|;
name|pos
operator|++
control|)
block|{
name|basic_block
name|bb2
init|=
name|trace
index|[
name|pos
index|]
decl_stmt|;
if|if
condition|(
name|blocks
index|[
name|bb2
operator|->
name|index
index|]
condition|)
block|{
name|fibheap_delete_node
argument_list|(
name|heap
argument_list|,
name|blocks
index|[
name|bb2
operator|->
name|index
index|]
argument_list|)
expr_stmt|;
name|blocks
index|[
name|bb2
operator|->
name|index
index|]
operator|=
name|NULL
expr_stmt|;
block|}
name|traced_insns
operator|+=
name|bb2
operator|->
name|frequency
operator|*
name|counts
index|[
name|bb2
operator|->
name|index
index|]
expr_stmt|;
if|if
condition|(
name|bb2
operator|->
name|pred
operator|&&
name|bb2
operator|->
name|pred
operator|->
name|pred_next
operator|&&
name|cfg_layout_can_duplicate_bb_p
argument_list|(
name|bb2
argument_list|)
condition|)
block|{
name|edge
name|e
init|=
name|bb2
operator|->
name|pred
decl_stmt|;
name|basic_block
name|old
init|=
name|bb2
decl_stmt|;
while|while
condition|(
name|e
operator|->
name|src
operator|!=
name|bb
condition|)
name|e
operator|=
name|e
operator|->
name|pred_next
expr_stmt|;
name|nduplicated
operator|+=
name|counts
index|[
name|bb2
operator|->
name|index
index|]
expr_stmt|;
name|bb2
operator|=
name|cfg_layout_duplicate_bb
argument_list|(
name|bb2
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|/* Reconsider the original copy of block we've duplicated. 	         Removing the most common predecesor may make it to be 	         head.  */
name|blocks
index|[
name|old
operator|->
name|index
index|]
operator|=
name|fibheap_insert
argument_list|(
name|heap
argument_list|,
operator|-
name|old
operator|->
name|frequency
argument_list|,
name|old
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Duplicated %i as %i [%i]\n"
argument_list|,
name|old
operator|->
name|index
argument_list|,
name|bb2
operator|->
name|index
argument_list|,
name|bb2
operator|->
name|frequency
argument_list|)
expr_stmt|;
block|}
name|RBI
argument_list|(
name|bb
argument_list|)
operator|->
name|next
operator|=
name|bb2
expr_stmt|;
name|RBI
argument_list|(
name|bb2
argument_list|)
operator|->
name|visited
operator|=
literal|1
expr_stmt|;
name|bb
operator|=
name|bb2
expr_stmt|;
comment|/* In case the trace became infrequent, stop duplicating.  */
if|if
condition|(
name|ignore_bb_p
argument_list|(
name|bb
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|" covered now %.1f\n\n"
argument_list|,
name|traced_insns
operator|*
literal|100.0
operator|/
name|weighted_insns
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Duplicated %i insns (%i%%)\n"
argument_list|,
name|nduplicated
argument_list|,
name|nduplicated
operator|*
literal|100
operator|/
name|ninsns
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|blocks
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|trace
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|counts
argument_list|)
expr_stmt|;
name|fibheap_delete
argument_list|(
name|heap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Connect the superblocks into linear seuqence.  At the moment we attempt to keep    the original order as much as possible, but the algorithm may be made smarter    later if needed.  BB reordering pass should void most of the benefits of such    change though.  */
end_comment

begin_function
specifier|static
name|void
name|layout_superblocks
parameter_list|()
block|{
name|basic_block
name|end
init|=
name|ENTRY_BLOCK_PTR
operator|->
name|succ
operator|->
name|dest
decl_stmt|;
name|basic_block
name|bb
init|=
name|ENTRY_BLOCK_PTR
operator|->
name|succ
operator|->
name|dest
operator|->
name|next_bb
decl_stmt|;
while|while
condition|(
name|bb
operator|!=
name|EXIT_BLOCK_PTR
condition|)
block|{
name|edge
name|e
decl_stmt|,
name|best
init|=
name|NULL
decl_stmt|;
while|while
condition|(
name|RBI
argument_list|(
name|end
argument_list|)
operator|->
name|next
condition|)
name|end
operator|=
name|RBI
argument_list|(
name|end
argument_list|)
operator|->
name|next
expr_stmt|;
for|for
control|(
name|e
operator|=
name|end
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
if|if
condition|(
name|e
operator|->
name|dest
operator|!=
name|EXIT_BLOCK_PTR
operator|&&
name|e
operator|->
name|dest
operator|!=
name|ENTRY_BLOCK_PTR
operator|->
name|succ
operator|->
name|dest
operator|&&
operator|!
name|RBI
argument_list|(
name|e
operator|->
name|dest
argument_list|)
operator|->
name|visited
operator|&&
operator|(
operator|!
name|best
operator|||
name|EDGE_FREQUENCY
argument_list|(
name|e
argument_list|)
operator|>
name|EDGE_FREQUENCY
argument_list|(
name|best
argument_list|)
operator|)
condition|)
name|best
operator|=
name|e
expr_stmt|;
if|if
condition|(
name|best
condition|)
block|{
name|RBI
argument_list|(
name|end
argument_list|)
operator|->
name|next
operator|=
name|best
operator|->
name|dest
expr_stmt|;
name|RBI
argument_list|(
name|best
operator|->
name|dest
argument_list|)
operator|->
name|visited
operator|=
literal|1
expr_stmt|;
block|}
else|else
for|for
control|(
init|;
name|bb
operator|!=
name|EXIT_BLOCK_PTR
condition|;
name|bb
operator|=
name|bb
operator|->
name|next_bb
control|)
block|{
if|if
condition|(
operator|!
name|RBI
argument_list|(
name|bb
argument_list|)
operator|->
name|visited
condition|)
block|{
name|RBI
argument_list|(
name|end
argument_list|)
operator|->
name|next
operator|=
name|bb
expr_stmt|;
name|RBI
argument_list|(
name|bb
argument_list|)
operator|->
name|visited
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Main entry point to this file.  */
end_comment

begin_function
name|void
name|tracer
parameter_list|()
block|{
if|if
condition|(
name|n_basic_blocks
operator|<=
literal|1
condition|)
return|return;
name|cfg_layout_initialize
argument_list|()
expr_stmt|;
name|mark_dfs_back_edges
argument_list|()
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
name|dump_flow_info
argument_list|(
name|rtl_dump_file
argument_list|)
expr_stmt|;
name|tail_duplicate
argument_list|()
expr_stmt|;
name|layout_superblocks
argument_list|()
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
name|dump_flow_info
argument_list|(
name|rtl_dump_file
argument_list|)
expr_stmt|;
name|cfg_layout_finalize
argument_list|()
expr_stmt|;
comment|/* Merge basic blocks in duplicated traces.  */
name|cleanup_cfg
argument_list|(
name|CLEANUP_EXPENSIVE
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

