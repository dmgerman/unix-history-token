begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Dead-code elimination pass for the GNU compiler.    Copyright (C) 2000, 2001, 2002 Free Software Foundation, Inc.    Written by Jeffrey D. Oldham<oldham@codesourcery.com>.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* Dead-code elimination is the removal of instructions which have no    impact on the program's output.  "Dead instructions" have no impact    on the program's output, while "necessary instructions" may have    impact on the output.     The algorithm consists of three phases:    1) marking as necessary all instructions known to be necessary,       e.g., writing a value to memory,    2) propagating necessary instructions, e.g., the instructions       giving values to operands in necessary instructions, and    3) removing dead instructions (except replacing dead conditionals       with unconditional jumps).     Side Effects:    The last step can require adding labels, deleting insns, and    modifying basic block structures.  Some conditional jumps may be    converted to unconditional jumps so the control-flow graph may be    out-of-date.     Edges from some infinite loops to the exit block can be added to    the control-flow graph, but will be removed after this pass is    complete.     It Does Not Perform:    We decided to not simultaneously perform jump optimization and dead    loop removal during dead-code elimination.  Thus, all jump    instructions originally present remain after dead-code elimination    but 1) unnecessary conditional jump instructions are changed to    unconditional jump instructions and 2) all unconditional jump    instructions remain.     Assumptions:    1) SSA has been performed.    2) The basic block and control-flow graph structures are accurate.    3) The flow graph permits constructing an edge_list.    4) note rtxes should be saved.     Unfinished:    When replacing unnecessary conditional jumps with unconditional    jumps, the control-flow graph is not updated.  It should be.     References:    Building an Optimizing Compiler    Robert Morgan    Butterworth-Heinemann, 1998    Section 8.9 */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"ssa.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_escape
end_escape

begin_comment
comment|/* A map from blocks to the edges on which they are control dependent.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
comment|/* An dynamically allocated array.  The Nth element corresponds to      the block with index N + 2.  The Ith bit in the bitmap is set if      that block is dependent on the Ith edge.  */
name|bitmap
modifier|*
name|data
decl_stmt|;
comment|/* The number of elements in the array.  */
name|int
name|length
decl_stmt|;
block|}
name|control_dependent_block_to_edge_map_s
operator|,
typedef|*
name|control_dependent_block_to_edge_map
typedef|;
end_typedef

begin_comment
comment|/* Local function prototypes.  */
end_comment

begin_decl_stmt
specifier|static
name|control_dependent_block_to_edge_map
name|control_dependent_block_to_edge_map_create
name|PARAMS
argument_list|(
operator|(
name|size_t
name|num_basic_blocks
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_control_dependent_block_to_edge_map_bit
name|PARAMS
argument_list|(
operator|(
name|control_dependent_block_to_edge_map
name|c
operator|,
name|basic_block
name|bb
operator|,
name|int
name|edge_index
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|control_dependent_block_to_edge_map_free
name|PARAMS
argument_list|(
operator|(
name|control_dependent_block_to_edge_map
name|c
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|find_all_control_dependences
name|PARAMS
argument_list|(
operator|(
expr|struct
name|edge_list
operator|*
name|el
operator|,
name|int
operator|*
name|pdom
operator|,
name|control_dependent_block_to_edge_map
name|cdbte
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|find_control_dependence
name|PARAMS
argument_list|(
operator|(
expr|struct
name|edge_list
operator|*
name|el
operator|,
name|int
name|edge_index
operator|,
name|int
operator|*
name|pdom
operator|,
name|control_dependent_block_to_edge_map
name|cdbte
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|basic_block
name|find_pdom
name|PARAMS
argument_list|(
operator|(
name|int
operator|*
name|pdom
operator|,
name|basic_block
name|block
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|inherently_necessary_register_1
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|*
name|current_rtx
operator|,
name|void
operator|*
name|data
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|inherently_necessary_register
name|PARAMS
argument_list|(
operator|(
name|rtx
name|current_rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|find_inherently_necessary
name|PARAMS
argument_list|(
operator|(
name|rtx
name|current_rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|propagate_necessity_through_operand
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|*
name|current_rtx
operator|,
name|void
operator|*
name|data
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|note_inherently_necessary_set
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Unnecessary insns are indicated using insns' in_struct bit.  */
end_comment

begin_comment
comment|/* Indicate INSN is dead-code; returns nothing.  */
end_comment

begin_define
define|#
directive|define
name|KILL_INSN
parameter_list|(
name|INSN
parameter_list|)
value|INSN_DEAD_CODE_P(INSN) = 1
end_define

begin_comment
comment|/* Indicate INSN is necessary, i.e., not dead-code; returns nothing.  */
end_comment

begin_define
define|#
directive|define
name|RESURRECT_INSN
parameter_list|(
name|INSN
parameter_list|)
value|INSN_DEAD_CODE_P(INSN) = 0
end_define

begin_comment
comment|/* Return nonzero if INSN is unnecessary.  */
end_comment

begin_define
define|#
directive|define
name|UNNECESSARY_P
parameter_list|(
name|INSN
parameter_list|)
value|INSN_DEAD_CODE_P(INSN)
end_define

begin_decl_stmt
specifier|static
name|void
name|mark_all_insn_unnecessary
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Execute CODE with free variable INSN for all unnecessary insns in    an unspecified order, producing no output.  */
end_comment

begin_define
define|#
directive|define
name|EXECUTE_IF_UNNECESSARY
parameter_list|(
name|INSN
parameter_list|,
name|CODE
parameter_list|)
define|\
value|{								\   rtx INSN;							\ 								\   for (INSN = get_insns (); INSN != NULL_RTX; INSN = NEXT_INSN (INSN))	\     if (INSN_DEAD_CODE_P (INSN)) {				\       CODE;							\     }								\ }
end_define

begin_comment
comment|/* Find the label beginning block BB.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|find_block_label
name|PARAMS
argument_list|(
operator|(
name|basic_block
name|bb
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Remove INSN, updating its basic block structure.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|delete_insn_bb
name|PARAMS
argument_list|(
operator|(
name|rtx
name|insn
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Recording which blocks are control dependent on which edges.  We    expect each block to be control dependent on very few edges so we    use a bitmap for each block recording its edges.  An array holds    the bitmap.  Its position 0 entry holds the bitmap for block    INVALID_BLOCK+1 so that all blocks, including the entry and exit    blocks can participate in the data structure.  */
end_comment

begin_comment
comment|/* Create a control_dependent_block_to_edge_map, given the number    NUM_BASIC_BLOCKS of non-entry, non-exit basic blocks, e.g.,    n_basic_blocks.  This memory must be released using    control_dependent_block_to_edge_map_free ().  */
end_comment

begin_function
specifier|static
name|control_dependent_block_to_edge_map
name|control_dependent_block_to_edge_map_create
parameter_list|(
name|num_basic_blocks
parameter_list|)
name|size_t
name|num_basic_blocks
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|control_dependent_block_to_edge_map
name|c
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|control_dependent_block_to_edge_map_s
argument_list|)
argument_list|)
decl_stmt|;
name|c
operator|->
name|length
operator|=
name|num_basic_blocks
operator|-
operator|(
name|INVALID_BLOCK
operator|+
literal|1
operator|)
expr_stmt|;
name|c
operator|->
name|data
operator|=
name|xmalloc
argument_list|(
operator|(
name|size_t
operator|)
name|c
operator|->
name|length
operator|*
sizeof|sizeof
argument_list|(
name|bitmap
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|c
operator|->
name|length
condition|;
operator|++
name|i
control|)
name|c
operator|->
name|data
index|[
name|i
index|]
operator|=
name|BITMAP_XMALLOC
argument_list|()
expr_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_comment
comment|/* Indicate block BB is control dependent on an edge with index    EDGE_INDEX in the mapping C of blocks to edges on which they are    control-dependent.  */
end_comment

begin_function
specifier|static
name|void
name|set_control_dependent_block_to_edge_map_bit
parameter_list|(
name|c
parameter_list|,
name|bb
parameter_list|,
name|edge_index
parameter_list|)
name|control_dependent_block_to_edge_map
name|c
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|int
name|edge_index
decl_stmt|;
block|{
if|if
condition|(
name|bb
operator|->
name|index
operator|-
operator|(
name|INVALID_BLOCK
operator|+
literal|1
operator|)
operator|>=
name|c
operator|->
name|length
condition|)
name|abort
argument_list|()
expr_stmt|;
name|bitmap_set_bit
argument_list|(
name|c
operator|->
name|data
index|[
name|bb
operator|->
name|index
operator|-
operator|(
name|INVALID_BLOCK
operator|+
literal|1
operator|)
index|]
argument_list|,
name|edge_index
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Execute CODE for each edge (given number EDGE_NUMBER within the    CODE) for which the block containing INSN is control dependent,    returning no output.  CDBTE is the mapping of blocks to edges on    which they are control-dependent.  */
end_comment

begin_define
define|#
directive|define
name|EXECUTE_IF_CONTROL_DEPENDENT
parameter_list|(
name|CDBTE
parameter_list|,
name|INSN
parameter_list|,
name|EDGE_NUMBER
parameter_list|,
name|CODE
parameter_list|)
define|\
value|EXECUTE_IF_SET_IN_BITMAP \ 	  (CDBTE->data[BLOCK_NUM (INSN) - (INVALID_BLOCK+1)], 0, \ 	  EDGE_NUMBER, CODE)
end_define

begin_comment
comment|/* Destroy a control_dependent_block_to_edge_map C.  */
end_comment

begin_function
specifier|static
name|void
name|control_dependent_block_to_edge_map_free
parameter_list|(
name|c
parameter_list|)
name|control_dependent_block_to_edge_map
name|c
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|c
operator|->
name|length
condition|;
operator|++
name|i
control|)
name|BITMAP_XFREE
argument_list|(
name|c
operator|->
name|data
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|c
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Record all blocks' control dependences on all edges in the edge    list EL, ala Morgan, Section 3.6.  The mapping PDOM of blocks to    their postdominators are used, and results are stored in CDBTE,    which should be empty.  */
end_comment

begin_function
specifier|static
name|void
name|find_all_control_dependences
parameter_list|(
name|el
parameter_list|,
name|pdom
parameter_list|,
name|cdbte
parameter_list|)
name|struct
name|edge_list
modifier|*
name|el
decl_stmt|;
name|int
modifier|*
name|pdom
decl_stmt|;
name|control_dependent_block_to_edge_map
name|cdbte
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_EDGES
argument_list|(
name|el
argument_list|)
condition|;
operator|++
name|i
control|)
name|find_control_dependence
argument_list|(
name|el
argument_list|,
name|i
argument_list|,
name|pdom
argument_list|,
name|cdbte
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Determine all blocks' control dependences on the given edge with    edge_list EL index EDGE_INDEX, ala Morgan, Section 3.6.  The    mapping PDOM of blocks to their postdominators are used, and    results are stored in CDBTE, which is assumed to be initialized    with zeros in each (block b', edge) position.  */
end_comment

begin_function
specifier|static
name|void
name|find_control_dependence
parameter_list|(
name|el
parameter_list|,
name|edge_index
parameter_list|,
name|pdom
parameter_list|,
name|cdbte
parameter_list|)
name|struct
name|edge_list
modifier|*
name|el
decl_stmt|;
name|int
name|edge_index
decl_stmt|;
name|int
modifier|*
name|pdom
decl_stmt|;
name|control_dependent_block_to_edge_map
name|cdbte
decl_stmt|;
block|{
name|basic_block
name|current_block
decl_stmt|;
name|basic_block
name|ending_block
decl_stmt|;
if|if
condition|(
name|INDEX_EDGE_PRED_BB
argument_list|(
name|el
argument_list|,
name|edge_index
argument_list|)
operator|==
name|EXIT_BLOCK_PTR
condition|)
name|abort
argument_list|()
expr_stmt|;
name|ending_block
operator|=
operator|(
name|INDEX_EDGE_PRED_BB
argument_list|(
name|el
argument_list|,
name|edge_index
argument_list|)
operator|==
name|ENTRY_BLOCK_PTR
operator|)
condition|?
name|BASIC_BLOCK
argument_list|(
literal|0
argument_list|)
else|:
name|find_pdom
argument_list|(
name|pdom
argument_list|,
name|INDEX_EDGE_PRED_BB
argument_list|(
name|el
argument_list|,
name|edge_index
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|current_block
operator|=
name|INDEX_EDGE_SUCC_BB
argument_list|(
name|el
argument_list|,
name|edge_index
argument_list|)
init|;
name|current_block
operator|!=
name|ending_block
operator|&&
name|current_block
operator|!=
name|EXIT_BLOCK_PTR
condition|;
name|current_block
operator|=
name|find_pdom
argument_list|(
name|pdom
argument_list|,
name|current_block
argument_list|)
control|)
block|{
name|set_control_dependent_block_to_edge_map_bit
argument_list|(
name|cdbte
argument_list|,
name|current_block
argument_list|,
name|edge_index
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Find the immediate postdominator PDOM of the specified basic block    BLOCK.  This function is necessary because some blocks have    negative numbers.  */
end_comment

begin_function
specifier|static
name|basic_block
name|find_pdom
parameter_list|(
name|pdom
parameter_list|,
name|block
parameter_list|)
name|int
modifier|*
name|pdom
decl_stmt|;
name|basic_block
name|block
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|block
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|block
operator|->
name|index
operator|==
name|INVALID_BLOCK
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|block
operator|==
name|ENTRY_BLOCK_PTR
condition|)
return|return
name|BASIC_BLOCK
argument_list|(
literal|0
argument_list|)
return|;
elseif|else
if|if
condition|(
name|block
operator|==
name|EXIT_BLOCK_PTR
operator|||
name|pdom
index|[
name|block
operator|->
name|index
index|]
operator|==
name|EXIT_BLOCK
condition|)
return|return
name|EXIT_BLOCK_PTR
return|;
else|else
return|return
name|BASIC_BLOCK
argument_list|(
name|pdom
index|[
name|block
operator|->
name|index
index|]
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Determine if the given CURRENT_RTX uses a hard register not    converted to SSA.  Returns nonzero only if it uses such a hard    register.  DATA is not used.     The program counter (PC) is not considered inherently necessary    since code should be position-independent and thus not depend on    particular PC values.  */
end_comment

begin_function
specifier|static
name|int
name|inherently_necessary_register_1
parameter_list|(
name|current_rtx
parameter_list|,
name|data
parameter_list|)
name|rtx
modifier|*
name|current_rtx
decl_stmt|;
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|rtx
name|x
init|=
operator|*
name|current_rtx
decl_stmt|;
if|if
condition|(
name|x
operator|==
name|NULL_RTX
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|CLOBBER
case|:
comment|/* Do not traverse the rest of the clobber.  */
return|return
operator|-
literal|1
return|;
break|break;
case|case
name|PC
case|:
return|return
literal|0
return|;
break|break;
case|case
name|REG
case|:
if|if
condition|(
name|CONVERT_REGISTER_TO_SSA_P
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
operator|||
name|x
operator|==
name|pc_rtx
condition|)
return|return
literal|0
return|;
else|else
return|return
operator|!
literal|0
return|;
break|break;
default|default:
return|return
literal|0
return|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Return nonzero if the insn CURRENT_RTX is inherently necessary.  */
end_comment

begin_function
specifier|static
name|int
name|inherently_necessary_register
parameter_list|(
name|current_rtx
parameter_list|)
name|rtx
name|current_rtx
decl_stmt|;
block|{
return|return
name|for_each_rtx
argument_list|(
operator|&
name|current_rtx
argument_list|,
operator|&
name|inherently_necessary_register_1
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Called via note_stores for each store in an insn.  Note whether    or not a particular store is inherently necessary.  Store a    nonzero value in inherently_necessary_p if such a store is found.  */
end_comment

begin_function
specifier|static
name|void
name|note_inherently_necessary_set
parameter_list|(
name|dest
parameter_list|,
name|set
parameter_list|,
name|data
parameter_list|)
name|rtx
name|set
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|rtx
name|dest
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
name|int
modifier|*
name|inherently_necessary_set_p
init|=
operator|(
name|int
operator|*
operator|)
name|data
decl_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|STRICT_LOW_PART
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SIGN_EXTRACT
condition|)
name|dest
operator|=
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|MEM
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|UNSPEC
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|UNSPEC_VOLATILE
condition|)
operator|*
name|inherently_necessary_set_p
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Mark X as inherently necessary if appropriate.  For example,    function calls and storing values into memory are inherently    necessary.  This function is to be used with for_each_rtx ().    Return nonzero iff inherently necessary.  */
end_comment

begin_function
specifier|static
name|int
name|find_inherently_necessary
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
if|if
condition|(
name|x
operator|==
name|NULL_RTX
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|inherently_necessary_register
argument_list|(
name|x
argument_list|)
condition|)
return|return
operator|!
literal|0
return|;
else|else
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|CALL_INSN
case|:
case|case
name|BARRIER
case|:
case|case
name|PREFETCH
case|:
return|return
operator|!
literal|0
return|;
case|case
name|CODE_LABEL
case|:
case|case
name|NOTE
case|:
return|return
literal|0
return|;
case|case
name|JUMP_INSN
case|:
return|return
name|JUMP_TABLE_DATA_P
argument_list|(
name|x
argument_list|)
operator|||
name|computed_jump_p
argument_list|(
name|x
argument_list|)
operator|!=
literal|0
return|;
case|case
name|INSN
case|:
block|{
name|int
name|inherently_necessary_set
init|=
literal|0
decl_stmt|;
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|x
argument_list|)
argument_list|,
name|note_inherently_necessary_set
argument_list|,
operator|&
name|inherently_necessary_set
argument_list|)
expr_stmt|;
comment|/* If we found an inherently necessary set or an asm 	     instruction, then we consider this insn inherently 	     necessary.  */
return|return
operator|(
name|inherently_necessary_set
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|ASM_INPUT
operator|||
name|asm_noperands
argument_list|(
name|PATTERN
argument_list|(
name|x
argument_list|)
argument_list|)
operator|>=
literal|0
operator|)
return|;
block|}
default|default:
comment|/* Found an impossible insn type.  */
name|abort
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Propagate necessity through REG and SUBREG operands of CURRENT_RTX.    This function is called with for_each_rtx () on necessary    instructions.  The DATA must be a varray of unprocessed    instructions.  */
end_comment

begin_function
specifier|static
name|int
name|propagate_necessity_through_operand
parameter_list|(
name|current_rtx
parameter_list|,
name|data
parameter_list|)
name|rtx
modifier|*
name|current_rtx
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
name|rtx
name|x
init|=
operator|*
name|current_rtx
decl_stmt|;
name|varray_type
modifier|*
name|unprocessed_instructions
init|=
operator|(
name|varray_type
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
name|x
operator|==
name|NULL_RTX
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|REG
case|:
if|if
condition|(
name|CONVERT_REGISTER_TO_SSA_P
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|insn
init|=
name|VARRAY_RTX
argument_list|(
name|ssa_definition
argument_list|,
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|insn
operator|!=
name|NULL_RTX
operator|&&
name|UNNECESSARY_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|RESURRECT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|VARRAY_PUSH_RTX
argument_list|(
operator|*
name|unprocessed_instructions
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Indicate all insns initially assumed to be unnecessary.  */
end_comment

begin_function
specifier|static
name|void
name|mark_all_insn_unnecessary
parameter_list|()
block|{
name|rtx
name|insn
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
operator|!=
name|NULL_RTX
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
name|KILL_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Find the label beginning block BB, adding one if necessary.  */
end_comment

begin_function
specifier|static
name|rtx
name|find_block_label
parameter_list|(
name|bb
parameter_list|)
name|basic_block
name|bb
decl_stmt|;
block|{
name|rtx
name|insn
init|=
name|bb
operator|->
name|head
decl_stmt|;
if|if
condition|(
name|LABEL_P
argument_list|(
name|insn
argument_list|)
condition|)
return|return
name|insn
return|;
else|else
block|{
name|rtx
name|new_label
init|=
name|emit_label_before
argument_list|(
name|gen_label_rtx
argument_list|()
argument_list|,
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|insn
operator|==
name|bb
operator|->
name|head
condition|)
name|bb
operator|->
name|head
operator|=
name|new_label
expr_stmt|;
return|return
name|new_label
return|;
block|}
block|}
end_function

begin_comment
comment|/* Remove INSN, updating its basic block structure.  */
end_comment

begin_function
specifier|static
name|void
name|delete_insn_bb
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|insn
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Do not actually delete anything that is not an INSN.       We can get here because we only consider INSNs as      potentially necessary.  We leave it to later passes      to remove unnecessary notes, unused labels, etc.  */
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
return|return;
name|delete_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Perform the dead-code elimination.  */
end_comment

begin_function
name|void
name|ssa_eliminate_dead_code
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
comment|/* Necessary instructions with operands to explore.  */
name|varray_type
name|unprocessed_instructions
decl_stmt|;
comment|/* Map element (b,e) is nonzero if the block is control dependent on      edge.  "cdbte" abbreviates control dependent block to edge.  */
name|control_dependent_block_to_edge_map
name|cdbte
decl_stmt|;
comment|/* Element I is the immediate postdominator of block I.  */
name|int
modifier|*
name|pdom
decl_stmt|;
name|struct
name|edge_list
modifier|*
name|el
decl_stmt|;
name|int
name|max_insn_uid
init|=
name|get_max_uid
argument_list|()
decl_stmt|;
comment|/* Initialize the data structures.  */
name|mark_all_insn_unnecessary
argument_list|()
expr_stmt|;
name|VARRAY_RTX_INIT
argument_list|(
name|unprocessed_instructions
argument_list|,
literal|64
argument_list|,
literal|"unprocessed instructions"
argument_list|)
expr_stmt|;
name|cdbte
operator|=
name|control_dependent_block_to_edge_map_create
argument_list|(
name|n_basic_blocks
argument_list|)
expr_stmt|;
comment|/* Prepare for use of BLOCK_NUM ().  */
name|connect_infinite_loops_to_exit
argument_list|()
expr_stmt|;
comment|/* Be careful not to clear the added edges.  */
name|compute_bb_for_insn
argument_list|(
name|max_insn_uid
argument_list|)
expr_stmt|;
comment|/* Compute control dependence.  */
name|pdom
operator|=
operator|(
name|int
operator|*
operator|)
name|xmalloc
argument_list|(
name|n_basic_blocks
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
operator|++
name|i
control|)
name|pdom
index|[
name|i
index|]
operator|=
name|INVALID_BLOCK
expr_stmt|;
name|calculate_dominance_info
argument_list|(
name|pdom
argument_list|,
name|NULL
argument_list|,
name|CDI_POST_DOMINATORS
argument_list|)
expr_stmt|;
comment|/* Assume there is a path from each node to the exit block.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|pdom
index|[
name|i
index|]
operator|==
name|INVALID_BLOCK
condition|)
name|pdom
index|[
name|i
index|]
operator|=
name|EXIT_BLOCK
expr_stmt|;
name|el
operator|=
name|create_edge_list
argument_list|()
expr_stmt|;
name|find_all_control_dependences
argument_list|(
name|el
argument_list|,
name|pdom
argument_list|,
name|cdbte
argument_list|)
expr_stmt|;
comment|/* Find inherently necessary instructions.  */
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
operator|!=
name|NULL_RTX
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|find_inherently_necessary
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|RESURRECT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|VARRAY_PUSH_RTX
argument_list|(
name|unprocessed_instructions
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
comment|/* Propagate necessity using the operands of necessary instructions.  */
while|while
condition|(
name|VARRAY_ACTIVE_SIZE
argument_list|(
name|unprocessed_instructions
argument_list|)
operator|>
literal|0
condition|)
block|{
name|rtx
name|current_instruction
decl_stmt|;
name|int
name|edge_number
decl_stmt|;
name|current_instruction
operator|=
name|VARRAY_TOP_RTX
argument_list|(
name|unprocessed_instructions
argument_list|)
expr_stmt|;
name|VARRAY_POP
argument_list|(
name|unprocessed_instructions
argument_list|)
expr_stmt|;
comment|/* Make corresponding control dependent edges necessary.  */
comment|/* Assume the only JUMP_INSN is the block's last insn.  It appears 	 that the last instruction of the program need not be a 	 JUMP_INSN.  */
if|if
condition|(
name|INSN_P
argument_list|(
name|current_instruction
argument_list|)
operator|&&
operator|!
name|JUMP_TABLE_DATA_P
argument_list|(
name|current_instruction
argument_list|)
condition|)
block|{
comment|/* Notes and labels contain no interesting operands.  */
name|EXECUTE_IF_CONTROL_DEPENDENT
argument_list|(
argument|cdbte
argument_list|,
argument|current_instruction
argument_list|,
argument|edge_number
argument_list|,
argument|{ 	      rtx jump_insn = (INDEX_EDGE_PRED_BB (el, edge_number))->end; 	      if (GET_CODE (jump_insn) == JUMP_INSN&& UNNECESSARY_P (jump_insn)) 		{ 		  RESURRECT_INSN (jump_insn); 		  VARRAY_PUSH_RTX (unprocessed_instructions, jump_insn); 		} 	    }
argument_list|)
empty_stmt|;
comment|/* Propagate through the operands.  */
name|for_each_rtx
argument_list|(
operator|&
name|current_instruction
argument_list|,
operator|&
name|propagate_necessity_through_operand
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|unprocessed_instructions
argument_list|)
expr_stmt|;
comment|/* PHI nodes are somewhat special in that each PHI alternative 	     has data and control dependencies.  The data dependencies 	     are handled via propagate_necessity_through_operand.  We 	     handle the control dependency here.  	     We consider the control dependent edges leading to the 	     predecessor block associated with each PHI alternative 	     as necessary.  */
if|if
condition|(
name|PHI_NODE_P
argument_list|(
name|current_instruction
argument_list|)
condition|)
block|{
name|rtvec
name|phi_vec
init|=
name|XVEC
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|current_instruction
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|num_elem
init|=
name|GET_NUM_ELEM
argument_list|(
name|phi_vec
argument_list|)
decl_stmt|;
name|int
name|v
decl_stmt|;
for|for
control|(
name|v
operator|=
name|num_elem
operator|-
literal|2
init|;
name|v
operator|>=
literal|0
condition|;
name|v
operator|-=
literal|2
control|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|bb
operator|=
name|BASIC_BLOCK
argument_list|(
name|INTVAL
argument_list|(
name|RTVEC_ELT
argument_list|(
name|phi_vec
argument_list|,
name|v
operator|+
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|EXECUTE_IF_CONTROL_DEPENDENT
argument_list|(
argument|cdbte
argument_list|,
argument|bb->end
argument_list|,
argument|edge_number
argument_list|,
argument|{ 		      rtx jump_insn;  		      jump_insn = (INDEX_EDGE_PRED_BB (el, edge_number))->end; 		      if (((GET_CODE (jump_insn) == JUMP_INSN))&& UNNECESSARY_P (jump_insn)) 			{ 			  RESURRECT_INSN (jump_insn); 			  VARRAY_PUSH_RTX (unprocessed_instructions, jump_insn); 			} 		    }
argument_list|)
empty_stmt|;
block|}
block|}
block|}
block|}
comment|/* Remove the unnecessary instructions.  */
name|EXECUTE_IF_UNNECESSARY
argument_list|(
argument|insn
argument_list|,
argument|{     if (any_condjump_p (insn))       { 	basic_block bb = BLOCK_FOR_INSN (insn); 	basic_block pdom_bb = find_pdom (pdom, bb); 	rtx lbl; 	edge e;
comment|/* Egad.  The immediate post dominator is the exit block.  We 	   would like to optimize this conditional jump to jump directly 	   to the exit block.  That can be difficult as we may not have 	   a suitable CODE_LABEL that allows us to fall unmolested into 	   the exit block.  	   So, we just delete the conditional branch by turning it into 	   a deleted note.   That is safe, but just not as optimal as 	   it could be.  */
argument|if (pdom_bb == EXIT_BLOCK_PTR) 	  {
comment|/* Since we're going to just delete the branch, we need 	       look at all the edges and remove all those which are not 	       a fallthru edge.  */
argument|e = bb->succ; 	    while (e) 	      { 		edge temp = e;  		e = e->succ_next; 		if ((temp->flags& EDGE_FALLTHRU) ==
literal|0
argument|) 		  {
comment|/* We've found a non-fallthru edge, find any PHI nodes 		       at the target and clean them up.  */
argument|if (temp->dest != EXIT_BLOCK_PTR) 		      { 		        rtx insn 			  = first_insn_after_basic_block_note (temp->dest);  		        while (PHI_NODE_P (insn)) 			  { 			    remove_phi_alternative (PATTERN (insn), temp->src); 			    insn = NEXT_INSN (insn); 			  } 		      }  		    remove_edge (temp); 		  } 	      }
comment|/* Now "delete" the conditional jump.  */
argument|PUT_CODE (insn, NOTE); 	    NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED; 	    continue; 	  }
comment|/* We've found a conditional branch that is unnecessary.  	   First, remove all outgoing edges from this block, updating 	   PHI nodes as appropriate.  */
argument|e = bb->succ; 	while (e) 	  { 	    edge temp = e;  	    e = e->succ_next;  	    if (temp->flags& EDGE_ABNORMAL) 	      continue;
comment|/* We found an edge that is not executable.  First simplify 	       the PHI nodes in the target block.  */
argument|if (temp->dest != EXIT_BLOCK_PTR) 	      { 		rtx insn = first_insn_after_basic_block_note (temp->dest);  		while (PHI_NODE_P (insn)) 		  { 		    remove_phi_alternative (PATTERN (insn), temp->src); 		    insn = NEXT_INSN (insn); 		  } 	      }  	    remove_edge (temp); 	  }
comment|/* Create an edge from this block to the post dominator.   	   What about the PHI nodes at the target?  */
argument|make_edge (bb, pdom_bb,
literal|0
argument|);
comment|/* Third, transform this insn into an unconditional 	   jump to the label for the immediate postdominator.  */
argument|lbl = find_block_label (pdom_bb); 	SET_SRC (PATTERN (insn)) = gen_rtx_LABEL_REF (VOIDmode, lbl); 	INSN_CODE (insn) = -
literal|1
argument|; 	JUMP_LABEL (insn) = lbl; 	LABEL_NUSES (lbl)++;
comment|/* A barrier must follow any unconditional jump.  Barriers 	   are not in basic blocks so this must occur after 	   deleting the conditional jump.  */
argument|emit_barrier_after (insn);       }     else if (!JUMP_P (insn))       delete_insn_bb (insn);   }
argument_list|)
empty_stmt|;
comment|/* Remove fake edges from the CFG.  */
name|remove_fake_edges
argument_list|()
expr_stmt|;
comment|/* Find any blocks with no successors and ensure they are followed      by a BARRIER.  delete_insn has the nasty habit of deleting barriers      when deleting insns.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
name|i
operator|++
control|)
block|{
name|basic_block
name|bb
init|=
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|bb
operator|->
name|succ
operator|==
name|NULL
condition|)
block|{
name|rtx
name|next
init|=
name|NEXT_INSN
argument_list|(
name|bb
operator|->
name|end
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|next
operator|||
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|!=
name|BARRIER
condition|)
name|emit_barrier_after
argument_list|(
name|bb
operator|->
name|end
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Release allocated memory.  */
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
operator|!=
name|NULL_RTX
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
name|RESURRECT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|VARRAY_ACTIVE_SIZE
argument_list|(
name|unprocessed_instructions
argument_list|)
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|VARRAY_FREE
argument_list|(
name|unprocessed_instructions
argument_list|)
expr_stmt|;
name|control_dependent_block_to_edge_map_free
argument_list|(
name|cdbte
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|pdom
argument_list|)
expr_stmt|;
name|free_edge_list
argument_list|(
name|el
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

