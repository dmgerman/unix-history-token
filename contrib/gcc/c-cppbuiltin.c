begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Define builtin-in macros for the C family front ends.    Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007    Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"version.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"c-common.h"
end_include

begin_include
include|#
directive|include
file|"c-pragma.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_comment
comment|/* For USING_SJLJ_EXCEPTIONS.  */
end_comment

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_comment
comment|/* Target prototypes.  */
end_comment

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|TARGET_OS_CPP_BUILTINS
end_ifndef

begin_define
define|#
directive|define
name|TARGET_OS_CPP_BUILTINS
parameter_list|()
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|TARGET_OBJFMT_CPP_BUILTINS
end_ifndef

begin_define
define|#
directive|define
name|TARGET_OBJFMT_CPP_BUILTINS
parameter_list|()
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|REGISTER_PREFIX
end_ifndef

begin_define
define|#
directive|define
name|REGISTER_PREFIX
value|""
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Non-static as some targets don't use it.  */
end_comment

begin_decl_stmt
name|void
name|builtin_define_std
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
name|ATTRIBUTE_UNUSED
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|builtin_define_with_value_n
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|builtin_define_with_int_value
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|HOST_WIDE_INT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|builtin_define_with_hex_fp_value
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|builtin_define_stdint_macros
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|builtin_define_type_max
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|builtin_define_type_precision
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|builtin_define_float_constants
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|define__GNUC__
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Define NAME with value TYPE precision.  */
end_comment

begin_function
specifier|static
name|void
name|builtin_define_type_precision
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
name|builtin_define_with_int_value
argument_list|(
name|name
argument_list|,
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Define the float.h constants for TYPE using NAME_PREFIX, FP_SUFFIX,    and FP_CAST. */
end_comment

begin_function
specifier|static
name|void
name|builtin_define_float_constants
parameter_list|(
specifier|const
name|char
modifier|*
name|name_prefix
parameter_list|,
specifier|const
name|char
modifier|*
name|fp_suffix
parameter_list|,
specifier|const
name|char
modifier|*
name|fp_cast
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
comment|/* Used to convert radix-based values to base 10 values in several cases.       In the max_exp -> max_10_exp conversion for 128-bit IEEE, we need at      least 6 significant digits for correct results.  Using the fraction      formed by (log(2)*1e6)/(log(10)*1e6) overflows a 32-bit integer as an      intermediate; perhaps someone can find a better approximation, in the      mean time, I suspect using doubles won't harm the bootstrap here.  */
specifier|const
name|double
name|log10_2
init|=
literal|.30102999566398119521
decl_stmt|;
name|double
name|log10_b
decl_stmt|;
specifier|const
name|struct
name|real_format
modifier|*
name|fmt
decl_stmt|;
name|char
name|name
index|[
literal|64
index|]
decl_stmt|,
name|buf
index|[
literal|128
index|]
decl_stmt|;
name|int
name|dig
decl_stmt|,
name|min_10_exp
decl_stmt|,
name|max_10_exp
decl_stmt|;
name|int
name|decimal_dig
decl_stmt|;
name|fmt
operator|=
name|REAL_MODE_FORMAT
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|fmt
operator|->
name|b
operator|!=
literal|10
argument_list|)
expr_stmt|;
comment|/* The radix of the exponent representation.  */
if|if
condition|(
name|type
operator|==
name|float_type_node
condition|)
name|builtin_define_with_int_value
argument_list|(
literal|"__FLT_RADIX__"
argument_list|,
name|fmt
operator|->
name|b
argument_list|)
expr_stmt|;
name|log10_b
operator|=
name|log10_2
operator|*
name|fmt
operator|->
name|log2_b
expr_stmt|;
comment|/* The number of radix digits, p, in the floating-point significand.  */
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"__%s_MANT_DIG__"
argument_list|,
name|name_prefix
argument_list|)
expr_stmt|;
name|builtin_define_with_int_value
argument_list|(
name|name
argument_list|,
name|fmt
operator|->
name|p
argument_list|)
expr_stmt|;
comment|/* The number of decimal digits, q, such that any floating-point number      with q decimal digits can be rounded into a floating-point number with      p radix b digits and back again without change to the q decimal digits,  	p log10 b			if b is a power of 10 	floor((p - 1) log10 b)		otherwise   */
name|dig
operator|=
operator|(
name|fmt
operator|->
name|p
operator|-
literal|1
operator|)
operator|*
name|log10_b
expr_stmt|;
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"__%s_DIG__"
argument_list|,
name|name_prefix
argument_list|)
expr_stmt|;
name|builtin_define_with_int_value
argument_list|(
name|name
argument_list|,
name|dig
argument_list|)
expr_stmt|;
comment|/* The minimum negative int x such that b**(x-1) is a normalized float.  */
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"__%s_MIN_EXP__"
argument_list|,
name|name_prefix
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"(%d)"
argument_list|,
name|fmt
operator|->
name|emin
argument_list|)
expr_stmt|;
name|builtin_define_with_value
argument_list|(
name|name
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* The minimum negative int x such that 10**x is a normalized float,  	  ceil (log10 (b ** (emin - 1))) 	= ceil (log10 (b) * (emin - 1))       Recall that emin is negative, so the integer truncation calculates      the ceiling, not the floor, in this case.  */
name|min_10_exp
operator|=
operator|(
name|fmt
operator|->
name|emin
operator|-
literal|1
operator|)
operator|*
name|log10_b
expr_stmt|;
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"__%s_MIN_10_EXP__"
argument_list|,
name|name_prefix
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"(%d)"
argument_list|,
name|min_10_exp
argument_list|)
expr_stmt|;
name|builtin_define_with_value
argument_list|(
name|name
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* The maximum int x such that b**(x-1) is a representable float.  */
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"__%s_MAX_EXP__"
argument_list|,
name|name_prefix
argument_list|)
expr_stmt|;
name|builtin_define_with_int_value
argument_list|(
name|name
argument_list|,
name|fmt
operator|->
name|emax
argument_list|)
expr_stmt|;
comment|/* The maximum int x such that 10**x is in the range of representable      finite floating-point numbers,  	  floor (log10((1 - b**-p) * b**emax)) 	= floor (log10(1 - b**-p) + log10(b**emax)) 	= floor (log10(1 - b**-p) + log10(b)*emax)       The safest thing to do here is to just compute this number.  But since      we don't link cc1 with libm, we cannot.  We could implement log10 here      a series expansion, but that seems too much effort because:       Note that the first term, for all extant p, is a number exceedingly close      to zero, but slightly negative.  Note that the second term is an integer      scaling an irrational number, and that because of the floor we are only      interested in its integral portion.       In order for the first term to have any effect on the integral portion      of the second term, the second term has to be exceedingly close to an      integer itself (e.g. 123.000000000001 or something).  Getting a result      that close to an integer requires that the irrational multiplicand have      a long series of zeros in its expansion, which doesn't occur in the      first 20 digits or so of log10(b).       Hand-waving aside, crunching all of the sets of constants above by hand      does not yield a case for which the first term is significant, which      in the end is all that matters.  */
name|max_10_exp
operator|=
name|fmt
operator|->
name|emax
operator|*
name|log10_b
expr_stmt|;
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"__%s_MAX_10_EXP__"
argument_list|,
name|name_prefix
argument_list|)
expr_stmt|;
name|builtin_define_with_int_value
argument_list|(
name|name
argument_list|,
name|max_10_exp
argument_list|)
expr_stmt|;
comment|/* The number of decimal digits, n, such that any floating-point number      can be rounded to n decimal digits and back again without change to      the value.  	p * log10(b)			if b is a power of 10 	ceil(1 + p * log10(b))		otherwise       The only macro we care about is this number for the widest supported      floating type, but we want this value for rendering constants below.  */
block|{
name|double
name|d_decimal_dig
init|=
literal|1
operator|+
name|fmt
operator|->
name|p
operator|*
name|log10_b
decl_stmt|;
name|decimal_dig
operator|=
name|d_decimal_dig
expr_stmt|;
if|if
condition|(
name|decimal_dig
operator|<
name|d_decimal_dig
condition|)
name|decimal_dig
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|==
name|long_double_type_node
condition|)
name|builtin_define_with_int_value
argument_list|(
literal|"__DECIMAL_DIG__"
argument_list|,
name|decimal_dig
argument_list|)
expr_stmt|;
comment|/* Since, for the supported formats, B is always a power of 2, we      construct the following numbers directly as a hexadecimal      constants.  */
comment|/* The maximum representable finite floating-point number,      (1 - b**-p) * b**emax  */
block|{
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"0x0."
argument_list|)
expr_stmt|;
name|n
operator|=
name|fmt
operator|->
name|p
operator|*
name|fmt
operator|->
name|log2_b
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|p
operator|=
name|buf
operator|+
literal|4
init|;
name|i
operator|+
literal|3
operator|<
name|n
condition|;
name|i
operator|+=
literal|4
control|)
operator|*
name|p
operator|++
operator|=
literal|'f'
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|n
condition|)
operator|*
name|p
operator|++
operator|=
literal|"08ce"
index|[
name|n
operator|-
name|i
index|]
expr_stmt|;
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"p%d"
argument_list|,
name|fmt
operator|->
name|emax
operator|*
name|fmt
operator|->
name|log2_b
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt
operator|->
name|pnan
operator|<
name|fmt
operator|->
name|p
condition|)
block|{
comment|/* This is an IBM extended double format made up of two IEEE 	   doubles.  The value of the long double is the sum of the 	   values of the two parts.  The most significant part is 	   required to be the value of the long double rounded to the 	   nearest double.  Rounding means we need a slightly smaller 	   value for LDBL_MAX.  */
name|buf
index|[
literal|4
operator|+
name|fmt
operator|->
name|pnan
operator|/
literal|4
index|]
operator|=
literal|"7bde"
index|[
name|fmt
operator|->
name|pnan
operator|%
literal|4
index|]
expr_stmt|;
block|}
block|}
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"__%s_MAX__"
argument_list|,
name|name_prefix
argument_list|)
expr_stmt|;
name|builtin_define_with_hex_fp_value
argument_list|(
name|name
argument_list|,
name|type
argument_list|,
name|decimal_dig
argument_list|,
name|buf
argument_list|,
name|fp_suffix
argument_list|,
name|fp_cast
argument_list|)
expr_stmt|;
comment|/* The minimum normalized positive floating-point number,      b**(emin-1).  */
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"__%s_MIN__"
argument_list|,
name|name_prefix
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"0x1p%d"
argument_list|,
operator|(
name|fmt
operator|->
name|emin
operator|-
literal|1
operator|)
operator|*
name|fmt
operator|->
name|log2_b
argument_list|)
expr_stmt|;
name|builtin_define_with_hex_fp_value
argument_list|(
name|name
argument_list|,
name|type
argument_list|,
name|decimal_dig
argument_list|,
name|buf
argument_list|,
name|fp_suffix
argument_list|,
name|fp_cast
argument_list|)
expr_stmt|;
comment|/* The difference between 1 and the least value greater than 1 that is      representable in the given floating point type, b**(1-p).  */
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"__%s_EPSILON__"
argument_list|,
name|name_prefix
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt
operator|->
name|pnan
operator|<
name|fmt
operator|->
name|p
condition|)
comment|/* This is an IBM extended double format, so 1.0 + any double is        representable precisely.  */
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"0x1p%d"
argument_list|,
operator|(
name|fmt
operator|->
name|emin
operator|-
name|fmt
operator|->
name|p
operator|)
operator|*
name|fmt
operator|->
name|log2_b
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"0x1p%d"
argument_list|,
operator|(
literal|1
operator|-
name|fmt
operator|->
name|p
operator|)
operator|*
name|fmt
operator|->
name|log2_b
argument_list|)
expr_stmt|;
name|builtin_define_with_hex_fp_value
argument_list|(
name|name
argument_list|,
name|type
argument_list|,
name|decimal_dig
argument_list|,
name|buf
argument_list|,
name|fp_suffix
argument_list|,
name|fp_cast
argument_list|)
expr_stmt|;
comment|/* For C++ std::numeric_limits<T>::denorm_min.  The minimum denormalized      positive floating-point number, b**(emin-p).  Zero for formats that      don't support denormals.  */
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"__%s_DENORM_MIN__"
argument_list|,
name|name_prefix
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt
operator|->
name|has_denorm
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"0x1p%d"
argument_list|,
operator|(
name|fmt
operator|->
name|emin
operator|-
name|fmt
operator|->
name|p
operator|)
operator|*
name|fmt
operator|->
name|log2_b
argument_list|)
expr_stmt|;
name|builtin_define_with_hex_fp_value
argument_list|(
name|name
argument_list|,
name|type
argument_list|,
name|decimal_dig
argument_list|,
name|buf
argument_list|,
name|fp_suffix
argument_list|,
name|fp_cast
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"0.0%s"
argument_list|,
name|fp_suffix
argument_list|)
expr_stmt|;
name|builtin_define_with_value
argument_list|(
name|name
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"__%s_HAS_DENORM__"
argument_list|,
name|name_prefix
argument_list|)
expr_stmt|;
name|builtin_define_with_value
argument_list|(
name|name
argument_list|,
name|fmt
operator|->
name|has_denorm
condition|?
literal|"1"
else|:
literal|"0"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* For C++ std::numeric_limits<T>::has_infinity.  */
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"__%s_HAS_INFINITY__"
argument_list|,
name|name_prefix
argument_list|)
expr_stmt|;
name|builtin_define_with_int_value
argument_list|(
name|name
argument_list|,
name|MODE_HAS_INFINITIES
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* For C++ std::numeric_limits<T>::has_quiet_NaN.  We do not have a      predicate to distinguish a target that has both quiet and      signalling NaNs from a target that has only quiet NaNs or only      signalling NaNs, so we assume that a target that has any kind of      NaN has quiet NaNs.  */
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"__%s_HAS_QUIET_NAN__"
argument_list|,
name|name_prefix
argument_list|)
expr_stmt|;
name|builtin_define_with_int_value
argument_list|(
name|name
argument_list|,
name|MODE_HAS_NANS
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Define __DECx__ constants for TYPE using NAME_PREFIX and SUFFIX. */
end_comment

begin_function
specifier|static
name|void
name|builtin_define_decimal_float_constants
parameter_list|(
specifier|const
name|char
modifier|*
name|name_prefix
parameter_list|,
specifier|const
name|char
modifier|*
name|suffix
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
specifier|const
name|struct
name|real_format
modifier|*
name|fmt
decl_stmt|;
name|char
name|name
index|[
literal|64
index|]
decl_stmt|,
name|buf
index|[
literal|128
index|]
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|int
name|digits
decl_stmt|;
name|fmt
operator|=
name|REAL_MODE_FORMAT
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The number of radix digits, p, in the significand.  */
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"__%s_MANT_DIG__"
argument_list|,
name|name_prefix
argument_list|)
expr_stmt|;
name|builtin_define_with_int_value
argument_list|(
name|name
argument_list|,
name|fmt
operator|->
name|p
argument_list|)
expr_stmt|;
comment|/* The minimum negative int x such that b**(x-1) is a normalized float.  */
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"__%s_MIN_EXP__"
argument_list|,
name|name_prefix
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"(%d)"
argument_list|,
name|fmt
operator|->
name|emin
argument_list|)
expr_stmt|;
name|builtin_define_with_value
argument_list|(
name|name
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* The maximum int x such that b**(x-1) is a representable float.  */
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"__%s_MAX_EXP__"
argument_list|,
name|name_prefix
argument_list|)
expr_stmt|;
name|builtin_define_with_int_value
argument_list|(
name|name
argument_list|,
name|fmt
operator|->
name|emax
argument_list|)
expr_stmt|;
comment|/* Compute the minimum representable value.  */
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"__%s_MIN__"
argument_list|,
name|name_prefix
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"1E%d%s"
argument_list|,
name|fmt
operator|->
name|emin
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
name|builtin_define_with_value
argument_list|(
name|name
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Compute the maximum representable value.  */
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"__%s_MAX__"
argument_list|,
name|name_prefix
argument_list|)
expr_stmt|;
name|p
operator|=
name|buf
expr_stmt|;
for|for
control|(
name|digits
operator|=
name|fmt
operator|->
name|p
init|;
name|digits
condition|;
name|digits
operator|--
control|)
block|{
operator|*
name|p
operator|++
operator|=
literal|'9'
expr_stmt|;
if|if
condition|(
name|digits
operator|==
name|fmt
operator|->
name|p
condition|)
operator|*
name|p
operator|++
operator|=
literal|'.'
expr_stmt|;
block|}
operator|*
name|p
operator|=
literal|0
expr_stmt|;
comment|/* fmt->p plus 1, to account for the decimal point.  */
name|sprintf
argument_list|(
operator|&
name|buf
index|[
name|fmt
operator|->
name|p
operator|+
literal|1
index|]
argument_list|,
literal|"E%d%s"
argument_list|,
name|fmt
operator|->
name|emax
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
name|builtin_define_with_value
argument_list|(
name|name
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Compute epsilon (the difference between 1 and least value greater      than 1 representable).  */
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"__%s_EPSILON__"
argument_list|,
name|name_prefix
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"1E-%d%s"
argument_list|,
name|fmt
operator|->
name|p
operator|-
literal|1
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
name|builtin_define_with_value
argument_list|(
name|name
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Minimum denormalized postive decimal value.  */
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"__%s_DEN__"
argument_list|,
name|name_prefix
argument_list|)
expr_stmt|;
name|p
operator|=
name|buf
expr_stmt|;
for|for
control|(
name|digits
operator|=
name|fmt
operator|->
name|p
init|;
name|digits
operator|>
literal|1
condition|;
name|digits
operator|--
control|)
block|{
operator|*
name|p
operator|++
operator|=
literal|'0'
expr_stmt|;
if|if
condition|(
name|digits
operator|==
name|fmt
operator|->
name|p
condition|)
operator|*
name|p
operator|++
operator|=
literal|'.'
expr_stmt|;
block|}
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|sprintf
argument_list|(
operator|&
name|buf
index|[
name|fmt
operator|->
name|p
index|]
argument_list|,
literal|"1E%d%s"
argument_list|,
name|fmt
operator|->
name|emin
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
name|builtin_define_with_value
argument_list|(
name|name
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Define __GNUC__, __GNUC_MINOR__ and __GNUC_PATCHLEVEL__.  */
end_comment

begin_function
specifier|static
name|void
name|define__GNUC__
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* The format of the version string, enforced below, is      ([^0-9]*-)?[0-9]+[.][0-9]+([.][0-9]+)?([- ].*)?  */
specifier|const
name|char
modifier|*
name|q
decl_stmt|,
modifier|*
name|v
init|=
name|version_string
decl_stmt|;
while|while
condition|(
operator|*
name|v
operator|&&
operator|!
name|ISDIGIT
argument_list|(
operator|*
name|v
argument_list|)
condition|)
name|v
operator|++
expr_stmt|;
name|gcc_assert
argument_list|(
operator|*
name|v
operator|&&
operator|(
name|v
operator|<=
name|version_string
operator|||
name|v
index|[
operator|-
literal|1
index|]
operator|==
literal|'-'
operator|)
argument_list|)
expr_stmt|;
name|q
operator|=
name|v
expr_stmt|;
while|while
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|v
argument_list|)
condition|)
name|v
operator|++
expr_stmt|;
name|builtin_define_with_value_n
argument_list|(
literal|"__GNUC__"
argument_list|,
name|q
argument_list|,
name|v
operator|-
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_dialect_cxx
argument_list|()
condition|)
name|builtin_define_with_value_n
argument_list|(
literal|"__GNUG__"
argument_list|,
name|q
argument_list|,
name|v
operator|-
name|q
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|*
name|v
operator|==
literal|'.'
operator|&&
name|ISDIGIT
argument_list|(
name|v
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|q
operator|=
operator|++
name|v
expr_stmt|;
while|while
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|v
argument_list|)
condition|)
name|v
operator|++
expr_stmt|;
name|builtin_define_with_value_n
argument_list|(
literal|"__GNUC_MINOR__"
argument_list|,
name|q
argument_list|,
name|v
operator|-
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|v
operator|==
literal|'.'
condition|)
block|{
name|gcc_assert
argument_list|(
name|ISDIGIT
argument_list|(
name|v
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|q
operator|=
operator|++
name|v
expr_stmt|;
while|while
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|v
argument_list|)
condition|)
name|v
operator|++
expr_stmt|;
name|builtin_define_with_value_n
argument_list|(
literal|"__GNUC_PATCHLEVEL__"
argument_list|,
name|q
argument_list|,
name|v
operator|-
name|q
argument_list|)
expr_stmt|;
block|}
else|else
name|builtin_define_with_value_n
argument_list|(
literal|"__GNUC_PATCHLEVEL__"
argument_list|,
literal|"0"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
operator|*
name|v
operator|||
operator|*
name|v
operator|==
literal|' '
operator|||
operator|*
name|v
operator|==
literal|'-'
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Define macros used by<stdint.h>.  Currently only defines limits    for intmax_t, used by the testsuite.  */
end_comment

begin_function
specifier|static
name|void
name|builtin_define_stdint_macros
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|intmax_long
decl_stmt|;
if|if
condition|(
name|intmax_type_node
operator|==
name|long_long_integer_type_node
condition|)
name|intmax_long
operator|=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|intmax_type_node
operator|==
name|long_integer_type_node
condition|)
name|intmax_long
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|intmax_type_node
operator|==
name|integer_type_node
condition|)
name|intmax_long
operator|=
literal|0
expr_stmt|;
else|else
name|gcc_unreachable
argument_list|()
expr_stmt|;
name|builtin_define_type_max
argument_list|(
literal|"__INTMAX_MAX__"
argument_list|,
name|intmax_type_node
argument_list|,
name|intmax_long
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Hook that registers front end and target-specific built-ins.  */
end_comment

begin_function
name|void
name|c_cpp_builtins
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|)
block|{
comment|/* -undef turns off target-specific built-ins.  */
if|if
condition|(
name|flag_undef
condition|)
return|return;
name|define__GNUC__
argument_list|()
expr_stmt|;
comment|/* For stddef.h.  They require macros defined in c-common.c.  */
name|c_stddef_cpp_builtins
argument_list|()
expr_stmt|;
if|if
condition|(
name|c_dialect_cxx
argument_list|()
condition|)
block|{
if|if
condition|(
name|flag_weak
operator|&&
name|SUPPORTS_ONE_ONLY
condition|)
name|cpp_define
argument_list|(
name|pfile
argument_list|,
literal|"__GXX_WEAK__=1"
argument_list|)
expr_stmt|;
else|else
name|cpp_define
argument_list|(
name|pfile
argument_list|,
literal|"__GXX_WEAK__=0"
argument_list|)
expr_stmt|;
if|if
condition|(
name|warn_deprecated
condition|)
name|cpp_define
argument_list|(
name|pfile
argument_list|,
literal|"__DEPRECATED"
argument_list|)
expr_stmt|;
block|}
comment|/* Note that we define this for C as well, so that we know if      __attribute__((cleanup)) will interface with EH.  */
if|if
condition|(
name|flag_exceptions
condition|)
name|cpp_define
argument_list|(
name|pfile
argument_list|,
literal|"__EXCEPTIONS"
argument_list|)
expr_stmt|;
comment|/* Represents the C++ ABI version, always defined so it can be used while      preprocessing C and assembler.  */
if|if
condition|(
name|flag_abi_version
operator|==
literal|0
condition|)
comment|/* Use a very large value so that:  	 #if __GXX_ABI_VERSION>=<value for version X>         will work whether the user explicitly says "-fabi-version=x" or        "-fabi-version=0".  Do not use INT_MAX because that will be        different from system to system.  */
name|builtin_define_with_int_value
argument_list|(
literal|"__GXX_ABI_VERSION"
argument_list|,
literal|999999
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|flag_abi_version
operator|==
literal|1
condition|)
comment|/* Due to a historical accident, this version had the value        "102".  */
name|builtin_define_with_int_value
argument_list|(
literal|"__GXX_ABI_VERSION"
argument_list|,
literal|102
argument_list|)
expr_stmt|;
else|else
comment|/* Newer versions have values 1002, 1003, ....  */
name|builtin_define_with_int_value
argument_list|(
literal|"__GXX_ABI_VERSION"
argument_list|,
literal|1000
operator|+
name|flag_abi_version
argument_list|)
expr_stmt|;
comment|/* libgcc needs to know this.  */
if|if
condition|(
name|USING_SJLJ_EXCEPTIONS
condition|)
name|cpp_define
argument_list|(
name|pfile
argument_list|,
literal|"__USING_SJLJ_EXCEPTIONS__"
argument_list|)
expr_stmt|;
comment|/* limits.h needs to know these.  */
name|builtin_define_type_max
argument_list|(
literal|"__SCHAR_MAX__"
argument_list|,
name|signed_char_type_node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|builtin_define_type_max
argument_list|(
literal|"__SHRT_MAX__"
argument_list|,
name|short_integer_type_node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|builtin_define_type_max
argument_list|(
literal|"__INT_MAX__"
argument_list|,
name|integer_type_node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|builtin_define_type_max
argument_list|(
literal|"__LONG_MAX__"
argument_list|,
name|long_integer_type_node
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|builtin_define_type_max
argument_list|(
literal|"__LONG_LONG_MAX__"
argument_list|,
name|long_long_integer_type_node
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|builtin_define_type_max
argument_list|(
literal|"__WCHAR_MAX__"
argument_list|,
name|wchar_type_node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|builtin_define_type_precision
argument_list|(
literal|"__CHAR_BIT__"
argument_list|,
name|char_type_node
argument_list|)
expr_stmt|;
comment|/* stdint.h (eventually) and the testsuite need to know these.  */
name|builtin_define_stdint_macros
argument_list|()
expr_stmt|;
comment|/* float.h needs to know these.  */
name|builtin_define_with_int_value
argument_list|(
literal|"__FLT_EVAL_METHOD__"
argument_list|,
name|TARGET_FLT_EVAL_METHOD
argument_list|)
expr_stmt|;
comment|/* And decfloat.h needs this.  */
name|builtin_define_with_int_value
argument_list|(
literal|"__DEC_EVAL_METHOD__"
argument_list|,
name|TARGET_DEC_EVAL_METHOD
argument_list|)
expr_stmt|;
name|builtin_define_float_constants
argument_list|(
literal|"FLT"
argument_list|,
literal|"F"
argument_list|,
literal|"%s"
argument_list|,
name|float_type_node
argument_list|)
expr_stmt|;
comment|/* Cast the double precision constants when single precision constants are      specified. The correct result is computed by the compiler when using       macros that include a cast. This has the side-effect of making the value       unusable in const expressions. */
if|if
condition|(
name|flag_single_precision_constant
condition|)
name|builtin_define_float_constants
argument_list|(
literal|"DBL"
argument_list|,
literal|"L"
argument_list|,
literal|"((double)%s)"
argument_list|,
name|double_type_node
argument_list|)
expr_stmt|;
else|else
name|builtin_define_float_constants
argument_list|(
literal|"DBL"
argument_list|,
literal|""
argument_list|,
literal|"%s"
argument_list|,
name|double_type_node
argument_list|)
expr_stmt|;
name|builtin_define_float_constants
argument_list|(
literal|"LDBL"
argument_list|,
literal|"L"
argument_list|,
literal|"%s"
argument_list|,
name|long_double_type_node
argument_list|)
expr_stmt|;
comment|/* For decfloat.h.  */
name|builtin_define_decimal_float_constants
argument_list|(
literal|"DEC32"
argument_list|,
literal|"DF"
argument_list|,
name|dfloat32_type_node
argument_list|)
expr_stmt|;
name|builtin_define_decimal_float_constants
argument_list|(
literal|"DEC64"
argument_list|,
literal|"DD"
argument_list|,
name|dfloat64_type_node
argument_list|)
expr_stmt|;
name|builtin_define_decimal_float_constants
argument_list|(
literal|"DEC128"
argument_list|,
literal|"DL"
argument_list|,
name|dfloat128_type_node
argument_list|)
expr_stmt|;
comment|/* For use in assembly language.  */
name|builtin_define_with_value
argument_list|(
literal|"__REGISTER_PREFIX__"
argument_list|,
name|REGISTER_PREFIX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|builtin_define_with_value
argument_list|(
literal|"__USER_LABEL_PREFIX__"
argument_list|,
name|user_label_prefix
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Misc.  */
name|builtin_define_with_value
argument_list|(
literal|"__VERSION__"
argument_list|,
name|version_string
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_gnu89_inline
condition|)
name|cpp_define
argument_list|(
name|pfile
argument_list|,
literal|"__GNUC_GNU_INLINE__"
argument_list|)
expr_stmt|;
else|else
name|cpp_define
argument_list|(
name|pfile
argument_list|,
literal|"__GNUC_STDC_INLINE__"
argument_list|)
expr_stmt|;
comment|/* Definitions for LP64 model.  */
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|long_integer_type_node
argument_list|)
operator|==
literal|64
operator|&&
name|POINTER_SIZE
operator|==
literal|64
operator|&&
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
operator|==
literal|32
condition|)
block|{
name|cpp_define
argument_list|(
name|pfile
argument_list|,
literal|"_LP64"
argument_list|)
expr_stmt|;
name|cpp_define
argument_list|(
name|pfile
argument_list|,
literal|"__LP64__"
argument_list|)
expr_stmt|;
block|}
comment|/* Other target-independent built-ins determined by command-line      options.  */
comment|/* APPLE LOCAL begin blocks */
comment|/* APPLE LOCAL radar 5868913 */
if|if
condition|(
name|flag_blocks
condition|)
block|{
name|cpp_define
argument_list|(
name|pfile
argument_list|,
literal|"__block=__attribute__((__blocks__(byref)))"
argument_list|)
expr_stmt|;
name|cpp_define
argument_list|(
name|pfile
argument_list|,
literal|"__BLOCKS__=1"
argument_list|)
expr_stmt|;
block|}
comment|/* APPLE LOCAL end blocks */
if|if
condition|(
name|optimize_size
condition|)
name|cpp_define
argument_list|(
name|pfile
argument_list|,
literal|"__OPTIMIZE_SIZE__"
argument_list|)
expr_stmt|;
if|if
condition|(
name|optimize
condition|)
name|cpp_define
argument_list|(
name|pfile
argument_list|,
literal|"__OPTIMIZE__"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fast_math_flags_set_p
argument_list|()
condition|)
name|cpp_define
argument_list|(
name|pfile
argument_list|,
literal|"__FAST_MATH__"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_really_no_inline
condition|)
name|cpp_define
argument_list|(
name|pfile
argument_list|,
literal|"__NO_INLINE__"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_signaling_nans
condition|)
name|cpp_define
argument_list|(
name|pfile
argument_list|,
literal|"__SUPPORT_SNAN__"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_finite_math_only
condition|)
name|cpp_define
argument_list|(
name|pfile
argument_list|,
literal|"__FINITE_MATH_ONLY__=1"
argument_list|)
expr_stmt|;
else|else
name|cpp_define
argument_list|(
name|pfile
argument_list|,
literal|"__FINITE_MATH_ONLY__=0"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_pic
condition|)
block|{
name|builtin_define_with_int_value
argument_list|(
literal|"__pic__"
argument_list|,
name|flag_pic
argument_list|)
expr_stmt|;
name|builtin_define_with_int_value
argument_list|(
literal|"__PIC__"
argument_list|,
name|flag_pic
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag_iso
condition|)
name|cpp_define
argument_list|(
name|pfile
argument_list|,
literal|"__STRICT_ANSI__"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|flag_signed_char
condition|)
name|cpp_define
argument_list|(
name|pfile
argument_list|,
literal|"__CHAR_UNSIGNED__"
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_dialect_cxx
argument_list|()
operator|&&
name|TYPE_UNSIGNED
argument_list|(
name|wchar_type_node
argument_list|)
condition|)
name|cpp_define
argument_list|(
name|pfile
argument_list|,
literal|"__WCHAR_UNSIGNED__"
argument_list|)
expr_stmt|;
comment|/* Make the choice of ObjC runtime visible to source code.  */
if|if
condition|(
name|c_dialect_objc
argument_list|()
operator|&&
name|flag_next_runtime
condition|)
name|cpp_define
argument_list|(
name|pfile
argument_list|,
literal|"__NEXT_RUNTIME__"
argument_list|)
expr_stmt|;
comment|/* Show the availability of some target pragmas.  */
if|if
condition|(
name|flag_mudflap
operator|||
name|targetm
operator|.
name|handle_pragma_redefine_extname
condition|)
name|cpp_define
argument_list|(
name|pfile
argument_list|,
literal|"__PRAGMA_REDEFINE_EXTNAME"
argument_list|)
expr_stmt|;
if|if
condition|(
name|targetm
operator|.
name|handle_pragma_extern_prefix
condition|)
name|cpp_define
argument_list|(
name|pfile
argument_list|,
literal|"__PRAGMA_EXTERN_PREFIX"
argument_list|)
expr_stmt|;
comment|/* Make the choice of the stack protector runtime visible to source code.      The macro names and values here were chosen for compatibility with an      earlier implementation, i.e. ProPolice.  */
if|if
condition|(
name|flag_stack_protect
operator|==
literal|2
condition|)
name|cpp_define
argument_list|(
name|pfile
argument_list|,
literal|"__SSP_ALL__=2"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|flag_stack_protect
operator|==
literal|1
condition|)
name|cpp_define
argument_list|(
name|pfile
argument_list|,
literal|"__SSP__=1"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_openmp
condition|)
name|cpp_define
argument_list|(
name|pfile
argument_list|,
literal|"_OPENMP=200505"
argument_list|)
expr_stmt|;
comment|/* A straightforward target hook doesn't work, because of problems      linking that hook's body when part of non-C front ends.  */
define|#
directive|define
name|preprocessing_asm_p
parameter_list|()
value|(cpp_get_options (pfile)->lang == CLK_ASM)
define|#
directive|define
name|preprocessing_trad_p
parameter_list|()
value|(cpp_get_options (pfile)->traditional)
define|#
directive|define
name|builtin_define
parameter_list|(
name|TXT
parameter_list|)
value|cpp_define (pfile, TXT)
define|#
directive|define
name|builtin_assert
parameter_list|(
name|TXT
parameter_list|)
value|cpp_assert (pfile, TXT)
name|TARGET_CPU_CPP_BUILTINS
argument_list|()
expr_stmt|;
name|TARGET_OS_CPP_BUILTINS
argument_list|()
expr_stmt|;
name|TARGET_OBJFMT_CPP_BUILTINS
argument_list|()
expr_stmt|;
comment|/* Support the __declspec keyword by turning them into attributes.      Note that the current way we do this may result in a collision      with predefined attributes later on.  This can be solved by using      one attribute, say __declspec__, and passing args to it.  The      problem with that approach is that args are not accumulated: each      new appearance would clobber any existing args.  */
if|if
condition|(
name|TARGET_DECLSPEC
condition|)
name|builtin_define
argument_list|(
literal|"__declspec(x)=__attribute__((x))"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Pass an object-like macro.  If it doesn't lie in the user's    namespace, defines it unconditionally.  Otherwise define a version    with two leading underscores, and another version with two leading    and trailing underscores, and define the original only if an ISO    standard was not nominated.     e.g. passing "unix" defines "__unix", "__unix__" and possibly    "unix".  Passing "_mips" defines "__mips", "__mips__" and possibly    "_mips".  */
end_comment

begin_function
name|void
name|builtin_define_std
parameter_list|(
specifier|const
name|char
modifier|*
name|macro
parameter_list|)
block|{
name|size_t
name|len
init|=
name|strlen
argument_list|(
name|macro
argument_list|)
decl_stmt|;
name|char
modifier|*
name|buff
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|len
operator|+
literal|5
argument_list|)
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|buff
operator|+
literal|2
decl_stmt|;
name|char
modifier|*
name|q
init|=
name|p
operator|+
name|len
decl_stmt|;
comment|/* prepend __ (or maybe just _) if in user's namespace.  */
name|memcpy
argument_list|(
name|p
argument_list|,
name|macro
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|p
operator|==
literal|'_'
operator|&&
operator|(
name|p
index|[
literal|1
index|]
operator|==
literal|'_'
operator|||
name|ISUPPER
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|!=
literal|'_'
condition|)
operator|*
operator|--
name|p
operator|=
literal|'_'
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|!=
literal|'_'
condition|)
operator|*
operator|--
name|p
operator|=
literal|'_'
expr_stmt|;
block|}
name|cpp_define
argument_list|(
name|parse_in
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* If it was in user's namespace...  */
if|if
condition|(
name|p
operator|!=
name|buff
operator|+
literal|2
condition|)
block|{
comment|/* Define the macro with leading and following __.  */
if|if
condition|(
name|q
index|[
operator|-
literal|1
index|]
operator|!=
literal|'_'
condition|)
operator|*
name|q
operator|++
operator|=
literal|'_'
expr_stmt|;
if|if
condition|(
name|q
index|[
operator|-
literal|2
index|]
operator|!=
literal|'_'
condition|)
operator|*
name|q
operator|++
operator|=
literal|'_'
expr_stmt|;
operator|*
name|q
operator|=
literal|'\0'
expr_stmt|;
name|cpp_define
argument_list|(
name|parse_in
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* Finally, define the original macro if permitted.  */
if|if
condition|(
operator|!
name|flag_iso
condition|)
name|cpp_define
argument_list|(
name|parse_in
argument_list|,
name|macro
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Pass an object-like macro and a value to define it to.  The third    parameter says whether or not to turn the value into a string    constant.  */
end_comment

begin_function
name|void
name|builtin_define_with_value
parameter_list|(
specifier|const
name|char
modifier|*
name|macro
parameter_list|,
specifier|const
name|char
modifier|*
name|expansion
parameter_list|,
name|int
name|is_str
parameter_list|)
block|{
name|char
modifier|*
name|buf
decl_stmt|;
name|size_t
name|mlen
init|=
name|strlen
argument_list|(
name|macro
argument_list|)
decl_stmt|;
name|size_t
name|elen
init|=
name|strlen
argument_list|(
name|expansion
argument_list|)
decl_stmt|;
name|size_t
name|extra
init|=
literal|2
decl_stmt|;
comment|/* space for an = and a NUL */
if|if
condition|(
name|is_str
condition|)
name|extra
operator|+=
literal|2
expr_stmt|;
comment|/* space for two quote marks */
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|mlen
operator|+
name|elen
operator|+
name|extra
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_str
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s=\"%s\""
argument_list|,
name|macro
argument_list|,
name|expansion
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s=%s"
argument_list|,
name|macro
argument_list|,
name|expansion
argument_list|)
expr_stmt|;
name|cpp_define
argument_list|(
name|parse_in
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Pass an object-like macro and a value to define it to.  The third    parameter is the length of the expansion.  */
end_comment

begin_function
specifier|static
name|void
name|builtin_define_with_value_n
parameter_list|(
specifier|const
name|char
modifier|*
name|macro
parameter_list|,
specifier|const
name|char
modifier|*
name|expansion
parameter_list|,
name|size_t
name|elen
parameter_list|)
block|{
name|char
modifier|*
name|buf
decl_stmt|;
name|size_t
name|mlen
init|=
name|strlen
argument_list|(
name|macro
argument_list|)
decl_stmt|;
comment|/* Space for an = and a NUL.  */
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|mlen
operator|+
name|elen
operator|+
literal|2
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|buf
argument_list|,
name|macro
argument_list|,
name|mlen
argument_list|)
expr_stmt|;
name|buf
index|[
name|mlen
index|]
operator|=
literal|'='
expr_stmt|;
name|memcpy
argument_list|(
name|buf
operator|+
name|mlen
operator|+
literal|1
argument_list|,
name|expansion
argument_list|,
name|elen
argument_list|)
expr_stmt|;
name|buf
index|[
name|mlen
operator|+
name|elen
operator|+
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|cpp_define
argument_list|(
name|parse_in
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Pass an object-like macro and an integer value to define it to.  */
end_comment

begin_function
specifier|static
name|void
name|builtin_define_with_int_value
parameter_list|(
specifier|const
name|char
modifier|*
name|macro
parameter_list|,
name|HOST_WIDE_INT
name|value
parameter_list|)
block|{
name|char
modifier|*
name|buf
decl_stmt|;
name|size_t
name|mlen
init|=
name|strlen
argument_list|(
name|macro
argument_list|)
decl_stmt|;
name|size_t
name|vlen
init|=
literal|18
decl_stmt|;
name|size_t
name|extra
init|=
literal|2
decl_stmt|;
comment|/* space for = and NUL.  */
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|mlen
operator|+
name|vlen
operator|+
name|extra
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|buf
argument_list|,
name|macro
argument_list|,
name|mlen
argument_list|)
expr_stmt|;
name|buf
index|[
name|mlen
index|]
operator|=
literal|'='
expr_stmt|;
name|sprintf
argument_list|(
name|buf
operator|+
name|mlen
operator|+
literal|1
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|cpp_define
argument_list|(
name|parse_in
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Pass an object-like macro a hexadecimal floating-point value.  */
end_comment

begin_function
specifier|static
name|void
name|builtin_define_with_hex_fp_value
parameter_list|(
specifier|const
name|char
modifier|*
name|macro
parameter_list|,
name|tree
name|type
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|digits
parameter_list|,
specifier|const
name|char
modifier|*
name|hex_str
parameter_list|,
specifier|const
name|char
modifier|*
name|fp_suffix
parameter_list|,
specifier|const
name|char
modifier|*
name|fp_cast
parameter_list|)
block|{
name|REAL_VALUE_TYPE
name|real
decl_stmt|;
name|char
name|dec_str
index|[
literal|64
index|]
decl_stmt|,
name|buf1
index|[
literal|256
index|]
decl_stmt|,
name|buf2
index|[
literal|256
index|]
decl_stmt|;
comment|/* Hex values are really cool and convenient, except that they're      not supported in strict ISO C90 mode.  First, the "p-" sequence      is not valid as part of a preprocessor number.  Second, we get a      pedwarn from the preprocessor, which has no context, so we can't      suppress the warning with __extension__.       So instead what we do is construct the number in hex (because      it's easy to get the exact correct value), parse it as a real,      then print it back out as decimal.  */
name|real_from_string
argument_list|(
operator|&
name|real
argument_list|,
name|hex_str
argument_list|)
expr_stmt|;
name|real_to_decimal
argument_list|(
name|dec_str
argument_list|,
operator|&
name|real
argument_list|,
sizeof|sizeof
argument_list|(
name|dec_str
argument_list|)
argument_list|,
name|digits
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Assemble the macro in the following fashion      macro = fp_cast [dec_str fp_suffix] */
name|sprintf
argument_list|(
name|buf1
argument_list|,
literal|"%s%s"
argument_list|,
name|dec_str
argument_list|,
name|fp_suffix
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf2
argument_list|,
name|fp_cast
argument_list|,
name|buf1
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf1
argument_list|,
literal|"%s=%s"
argument_list|,
name|macro
argument_list|,
name|buf2
argument_list|)
expr_stmt|;
name|cpp_define
argument_list|(
name|parse_in
argument_list|,
name|buf1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Define MAX for TYPE based on the precision of the type.  IS_LONG is    1 for type "long" and 2 for "long long".  We have to handle    unsigned types, since wchar_t might be unsigned.  */
end_comment

begin_function
specifier|static
name|void
name|builtin_define_type_max
parameter_list|(
specifier|const
name|char
modifier|*
name|macro
parameter_list|,
name|tree
name|type
parameter_list|,
name|int
name|is_long
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|values
index|[]
init|=
block|{
literal|"127"
block|,
literal|"255"
block|,
literal|"32767"
block|,
literal|"65535"
block|,
literal|"2147483647"
block|,
literal|"4294967295"
block|,
literal|"9223372036854775807"
block|,
literal|"18446744073709551615"
block|,
literal|"170141183460469231731687303715884105727"
block|,
literal|"340282366920938463463374607431768211455"
block|}
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|suffixes
index|[]
init|=
block|{
literal|""
block|,
literal|"U"
block|,
literal|"L"
block|,
literal|"UL"
block|,
literal|"LL"
block|,
literal|"ULL"
block|}
decl_stmt|;
specifier|const
name|char
modifier|*
name|value
decl_stmt|,
modifier|*
name|suffix
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|size_t
name|idx
decl_stmt|;
comment|/* Pre-rendering the values mean we don't have to futz with printing a      multi-word decimal value.  There are also a very limited number of      precisions that we support, so it's really a waste of time.  */
switch|switch
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
literal|8
case|:
name|idx
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|16
case|:
name|idx
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|32
case|:
name|idx
operator|=
literal|4
expr_stmt|;
break|break;
case|case
literal|64
case|:
name|idx
operator|=
literal|6
expr_stmt|;
break|break;
case|case
literal|128
case|:
name|idx
operator|=
literal|8
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|value
operator|=
name|values
index|[
name|idx
operator|+
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
index|]
expr_stmt|;
name|suffix
operator|=
name|suffixes
index|[
name|is_long
operator|*
literal|2
operator|+
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
index|]
expr_stmt|;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|macro
argument_list|)
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|value
argument_list|)
operator|+
name|strlen
argument_list|(
name|suffix
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s=%s%s"
argument_list|,
name|macro
argument_list|,
name|value
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
name|cpp_define
argument_list|(
name|parse_in
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

