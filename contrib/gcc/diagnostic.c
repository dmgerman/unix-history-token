begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Language-independent diagnostic subroutines for the GNU C compiler    Copyright (C) 1999, 2000, 2001, 2002 Free Software Foundation, Inc.    Contributed by Gabriel Dos Reis<gdr@codesourcery.com>  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* This file implements the language independent aspect of diagnostic    message module.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_undef
undef|#
directive|undef
name|FLOAT
end_undef

begin_comment
comment|/* This is for hpux. They should change hpux.  */
end_comment

begin_undef
undef|#
directive|undef
name|FFS
end_undef

begin_comment
comment|/* Some systems define this in param.h.  */
end_comment

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"input.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"intl.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_define
define|#
directive|define
name|obstack_chunk_alloc
value|xmalloc
end_define

begin_define
define|#
directive|define
name|obstack_chunk_free
value|free
end_define

begin_define
define|#
directive|define
name|output_formatted_integer
parameter_list|(
name|BUFFER
parameter_list|,
name|FORMAT
parameter_list|,
name|INTEGER
parameter_list|)
define|\
value|do {                                                    \     sprintf ((BUFFER)->digit_buffer, FORMAT, INTEGER);    \     output_add_string (BUFFER, (BUFFER)->digit_buffer);   \   } while (0)
end_define

begin_define
define|#
directive|define
name|output_text_length
parameter_list|(
name|BUFFER
parameter_list|)
value|(BUFFER)->line_length
end_define

begin_define
define|#
directive|define
name|is_starting_newline
parameter_list|(
name|BUFFER
parameter_list|)
value|(output_text_length (BUFFER) == 0)
end_define

begin_define
define|#
directive|define
name|output_prefix
parameter_list|(
name|BUFFER
parameter_list|)
value|(BUFFER)->state.prefix
end_define

begin_define
define|#
directive|define
name|line_wrap_cutoff
parameter_list|(
name|BUFFER
parameter_list|)
value|(BUFFER)->state.maximum_length
end_define

begin_define
define|#
directive|define
name|prefix_was_emitted_for
parameter_list|(
name|BUFFER
parameter_list|)
value|(BUFFER)->state.emitted_prefix_p
end_define

begin_define
define|#
directive|define
name|output_buffer_ptr_to_format_args
parameter_list|(
name|BUFFER
parameter_list|)
value|(BUFFER)->state.format_args
end_define

begin_define
define|#
directive|define
name|diagnostic_args
value|output_buffer_ptr_to_format_args (diagnostic_buffer)
end_define

begin_define
define|#
directive|define
name|diagnostic_msg
value|output_buffer_text_cursor (diagnostic_buffer)
end_define

begin_comment
comment|/* Prototypes.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|diagnostic_finish
name|PARAMS
argument_list|(
operator|(
name|output_buffer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_do_verbatim
name|PARAMS
argument_list|(
operator|(
name|output_buffer
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|va_list
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_buffer_to_stream
name|PARAMS
argument_list|(
operator|(
name|output_buffer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_format
name|PARAMS
argument_list|(
operator|(
name|output_buffer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_indent
name|PARAMS
argument_list|(
operator|(
name|output_buffer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|vbuild_message_string
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|va_list
operator|)
argument_list|)
name|ATTRIBUTE_PRINTF
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|build_message_string
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
operator|...
operator|)
argument_list|)
name|ATTRIBUTE_PRINTF_1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_do_printf
name|PARAMS
argument_list|(
operator|(
name|output_buffer
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
name|ATTRIBUTE_PRINTF
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|format_with_decl
name|PARAMS
argument_list|(
operator|(
name|output_buffer
operator|*
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|diagnostic_for_decl
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
specifier|const
name|char
operator|*
operator|,
name|va_list
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_real_maximum_length
name|PARAMS
argument_list|(
operator|(
name|output_buffer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_unsigned_decimal
name|PARAMS
argument_list|(
operator|(
name|output_buffer
operator|*
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_long_decimal
name|PARAMS
argument_list|(
operator|(
name|output_buffer
operator|*
operator|,
name|long
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_long_unsigned_decimal
name|PARAMS
argument_list|(
operator|(
name|output_buffer
operator|*
operator|,
name|long
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_octal
name|PARAMS
argument_list|(
operator|(
name|output_buffer
operator|*
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_long_octal
name|PARAMS
argument_list|(
operator|(
name|output_buffer
operator|*
operator|,
name|unsigned
name|long
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_hexadecimal
name|PARAMS
argument_list|(
operator|(
name|output_buffer
operator|*
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_long_hexadecimal
name|PARAMS
argument_list|(
operator|(
name|output_buffer
operator|*
operator|,
name|unsigned
name|long
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_append_r
name|PARAMS
argument_list|(
operator|(
name|output_buffer
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|wrap_text
name|PARAMS
argument_list|(
operator|(
name|output_buffer
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|maybe_wrap_text
name|PARAMS
argument_list|(
operator|(
name|output_buffer
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|clear_diagnostic_info
name|PARAMS
argument_list|(
operator|(
name|output_buffer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|default_diagnostic_starter
name|PARAMS
argument_list|(
operator|(
name|output_buffer
operator|*
operator|,
name|diagnostic_context
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|default_diagnostic_finalizer
name|PARAMS
argument_list|(
operator|(
name|output_buffer
operator|*
operator|,
name|diagnostic_context
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|error_recursion
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
name|ATTRIBUTE_NORETURN
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|rtl_dump_and_exit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|warnings_are_errors
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A diagnostic_context surrogate for stderr.  */
end_comment

begin_decl_stmt
specifier|static
name|diagnostic_context
name|global_diagnostic_context
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|diagnostic_context
modifier|*
name|global_dc
init|=
operator|&
name|global_diagnostic_context
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This will be removed shortly.  */
end_comment

begin_decl_stmt
name|output_buffer
modifier|*
name|diagnostic_buffer
init|=
operator|&
name|global_diagnostic_context
operator|.
name|buffer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Function of last error message;    more generally, function such that if next error message is in it    then we don't have to mention the function name.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|last_error_function
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Used to detect when input_file_stack has changed since last described.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|last_error_tick
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Called by report_error_function to print out function name.    Default may be overridden by language front-ends.  */
end_comment

begin_macro
name|void
argument_list|(
argument|*print_error_function
argument_list|)
end_macro

begin_expr_stmt
name|PARAMS
argument_list|(
operator|(
name|diagnostic_context
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
operator|=
name|default_print_error_function
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Prevent recursion into the error handler.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|diagnostic_lock
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Return truthvalue if current input file is different from the most recent    file involved in a diagnostic message.  */
end_comment

begin_function
name|int
name|error_module_changed
parameter_list|()
block|{
return|return
name|last_error_tick
operator|!=
name|input_file_stack_tick
return|;
block|}
end_function

begin_comment
comment|/* Remember current file as being the most recent file involved in a    diagnostic message.  */
end_comment

begin_function
name|void
name|record_last_error_module
parameter_list|()
block|{
name|last_error_tick
operator|=
name|input_file_stack_tick
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Same as error_module_changed, but for function.  */
end_comment

begin_function
name|int
name|error_function_changed
parameter_list|()
block|{
return|return
name|last_error_function
operator|!=
name|current_function_decl
return|;
block|}
end_function

begin_comment
comment|/* Same as record_last_error_module, but for function.  */
end_comment

begin_function
name|void
name|record_last_error_function
parameter_list|()
block|{
name|last_error_function
operator|=
name|current_function_decl
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize the diagnostic message outputting machinery.  */
end_comment

begin_function
name|void
name|diagnostic_initialize
parameter_list|(
name|context
parameter_list|)
name|diagnostic_context
modifier|*
name|context
decl_stmt|;
block|{
name|memset
argument_list|(
name|context
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|context
argument_list|)
expr_stmt|;
name|obstack_init
argument_list|(
operator|&
name|context
operator|->
name|buffer
operator|.
name|obstack
argument_list|)
expr_stmt|;
comment|/* By default, diagnostics are sent to stderr.  */
name|output_buffer_attached_stream
argument_list|(
operator|&
name|context
operator|->
name|buffer
argument_list|)
operator|=
name|stderr
expr_stmt|;
comment|/* By default, we emit prefixes once per message.  */
name|diagnostic_prefixing_rule
argument_list|(
name|context
argument_list|)
operator|=
name|DIAGNOSTICS_SHOW_PREFIX_ONCE
expr_stmt|;
name|diagnostic_starter
argument_list|(
name|context
argument_list|)
operator|=
name|default_diagnostic_starter
expr_stmt|;
name|diagnostic_finalizer
argument_list|(
name|context
argument_list|)
operator|=
name|default_diagnostic_finalizer
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns true if BUFFER is in line-wrapping mode.  */
end_comment

begin_function
name|int
name|output_is_line_wrapping
parameter_list|(
name|buffer
parameter_list|)
name|output_buffer
modifier|*
name|buffer
decl_stmt|;
block|{
return|return
name|diagnostic_line_cutoff
argument_list|(
name|buffer
argument_list|)
operator|>
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return BUFFER's prefix.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|output_get_prefix
parameter_list|(
name|buffer
parameter_list|)
specifier|const
name|output_buffer
modifier|*
name|buffer
decl_stmt|;
block|{
return|return
name|output_prefix
argument_list|(
name|buffer
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of output_set_maximum_length.  Set up BUFFER's    internal maximum characters per line.  */
end_comment

begin_function
specifier|static
name|void
name|set_real_maximum_length
parameter_list|(
name|buffer
parameter_list|)
name|output_buffer
modifier|*
name|buffer
decl_stmt|;
block|{
comment|/* If we're told not to wrap lines then do the obvious thing.  In case    we'll emit prefix only once per diagnostic message, it is appropriate   not to increase unnecessarily the line-length cut-off.  */
if|if
condition|(
operator|!
name|output_is_line_wrapping
argument_list|(
name|buffer
argument_list|)
operator|||
name|diagnostic_prefixing_rule
argument_list|(
name|buffer
argument_list|)
operator|==
name|DIAGNOSTICS_SHOW_PREFIX_ONCE
operator|||
name|diagnostic_prefixing_rule
argument_list|(
name|buffer
argument_list|)
operator|==
name|DIAGNOSTICS_SHOW_PREFIX_NEVER
condition|)
name|line_wrap_cutoff
argument_list|(
name|buffer
argument_list|)
operator|=
name|diagnostic_line_cutoff
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|prefix_length
init|=
name|output_prefix
argument_list|(
name|buffer
argument_list|)
condition|?
name|strlen
argument_list|(
name|output_prefix
argument_list|(
name|buffer
argument_list|)
argument_list|)
else|:
literal|0
decl_stmt|;
comment|/* If the prefix is ridiculously too long, output at least          32 characters.  */
if|if
condition|(
name|diagnostic_line_cutoff
argument_list|(
name|buffer
argument_list|)
operator|-
name|prefix_length
operator|<
literal|32
condition|)
name|line_wrap_cutoff
argument_list|(
name|buffer
argument_list|)
operator|=
name|diagnostic_line_cutoff
argument_list|(
name|buffer
argument_list|)
operator|+
literal|32
expr_stmt|;
else|else
name|line_wrap_cutoff
argument_list|(
name|buffer
argument_list|)
operator|=
name|diagnostic_line_cutoff
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Sets the number of maximum characters per line BUFFER can output    in line-wrapping mode.  A LENGTH value 0 suppresses line-wrapping.  */
end_comment

begin_function
name|void
name|output_set_maximum_length
parameter_list|(
name|buffer
parameter_list|,
name|length
parameter_list|)
name|output_buffer
modifier|*
name|buffer
decl_stmt|;
name|int
name|length
decl_stmt|;
block|{
name|diagnostic_line_cutoff
argument_list|(
name|buffer
argument_list|)
operator|=
name|length
expr_stmt|;
name|set_real_maximum_length
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Sets BUFFER's PREFIX.  */
end_comment

begin_function
name|void
name|output_set_prefix
parameter_list|(
name|buffer
parameter_list|,
name|prefix
parameter_list|)
name|output_buffer
modifier|*
name|buffer
decl_stmt|;
specifier|const
name|char
modifier|*
name|prefix
decl_stmt|;
block|{
name|output_prefix
argument_list|(
name|buffer
argument_list|)
operator|=
name|prefix
expr_stmt|;
name|set_real_maximum_length
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|prefix_was_emitted_for
argument_list|(
name|buffer
argument_list|)
operator|=
literal|0
expr_stmt|;
name|output_indentation
argument_list|(
name|buffer
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  Return a pointer to the last character emitted in the output     BUFFER area.  A NULL pointer means no character available.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|output_last_position
parameter_list|(
name|buffer
parameter_list|)
specifier|const
name|output_buffer
modifier|*
name|buffer
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|p
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|obstack_base
argument_list|(
operator|&
name|buffer
operator|->
name|obstack
argument_list|)
operator|!=
name|obstack_next_free
argument_list|(
operator|&
name|buffer
operator|->
name|obstack
argument_list|)
condition|)
name|p
operator|=
operator|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|obstack_next_free
argument_list|(
operator|&
name|buffer
operator|->
name|obstack
argument_list|)
operator|)
operator|-
literal|1
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* Free BUFFER's prefix, a previously malloc'd string.  */
end_comment

begin_function
name|void
name|output_destroy_prefix
parameter_list|(
name|buffer
parameter_list|)
name|output_buffer
modifier|*
name|buffer
decl_stmt|;
block|{
if|if
condition|(
name|output_prefix
argument_list|(
name|buffer
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|output_prefix
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
name|output_prefix
argument_list|(
name|buffer
argument_list|)
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Zero out any text output so far in BUFFER.  */
end_comment

begin_function
name|void
name|output_clear_message_text
parameter_list|(
name|buffer
parameter_list|)
name|output_buffer
modifier|*
name|buffer
decl_stmt|;
block|{
name|obstack_free
argument_list|(
operator|&
name|buffer
operator|->
name|obstack
argument_list|,
name|obstack_base
argument_list|(
operator|&
name|buffer
operator|->
name|obstack
argument_list|)
argument_list|)
expr_stmt|;
name|output_text_length
argument_list|(
name|buffer
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Zero out any diagnostic data used so far by BUFFER.  */
end_comment

begin_function
specifier|static
name|void
name|clear_diagnostic_info
parameter_list|(
name|buffer
parameter_list|)
name|output_buffer
modifier|*
name|buffer
decl_stmt|;
block|{
name|output_buffer_text_cursor
argument_list|(
name|buffer
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|output_buffer_ptr_to_format_args
argument_list|(
name|buffer
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|prefix_was_emitted_for
argument_list|(
name|buffer
argument_list|)
operator|=
literal|0
expr_stmt|;
name|output_indentation
argument_list|(
name|buffer
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Construct an output BUFFER with PREFIX and of MAXIMUM_LENGTH    characters per line.  */
end_comment

begin_function
name|void
name|init_output_buffer
parameter_list|(
name|buffer
parameter_list|,
name|prefix
parameter_list|,
name|maximum_length
parameter_list|)
name|output_buffer
modifier|*
name|buffer
decl_stmt|;
specifier|const
name|char
modifier|*
name|prefix
decl_stmt|;
name|int
name|maximum_length
decl_stmt|;
block|{
name|memset
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|output_buffer
argument_list|)
argument_list|)
expr_stmt|;
name|obstack_init
argument_list|(
operator|&
name|buffer
operator|->
name|obstack
argument_list|)
expr_stmt|;
name|output_buffer_attached_stream
argument_list|(
name|buffer
argument_list|)
operator|=
name|stderr
expr_stmt|;
name|diagnostic_line_cutoff
argument_list|(
name|buffer
argument_list|)
operator|=
name|maximum_length
expr_stmt|;
name|diagnostic_prefixing_rule
argument_list|(
name|buffer
argument_list|)
operator|=
name|diagnostic_prefixing_rule
argument_list|(
name|global_dc
argument_list|)
expr_stmt|;
name|output_set_prefix
argument_list|(
name|buffer
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
name|output_text_length
argument_list|(
name|buffer
argument_list|)
operator|=
literal|0
expr_stmt|;
name|clear_diagnostic_info
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Reinitialize BUFFER.  */
end_comment

begin_function
name|void
name|output_clear
parameter_list|(
name|buffer
parameter_list|)
name|output_buffer
modifier|*
name|buffer
decl_stmt|;
block|{
name|output_clear_message_text
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|clear_diagnostic_info
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finishes constructing a NULL-terminated character string representing    the BUFFERed message.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|output_finalize_message
parameter_list|(
name|buffer
parameter_list|)
name|output_buffer
modifier|*
name|buffer
decl_stmt|;
block|{
name|obstack_1grow
argument_list|(
operator|&
name|buffer
operator|->
name|obstack
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
return|return
name|output_message_text
argument_list|(
name|buffer
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|flush_diagnostic_buffer
parameter_list|()
block|{
name|output_buffer_to_stream
argument_list|(
name|diagnostic_buffer
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|output_buffer_attached_stream
argument_list|(
name|diagnostic_buffer
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the amount of characters BUFFER can accept to    make a full line.  */
end_comment

begin_function
name|int
name|output_space_left
parameter_list|(
name|buffer
parameter_list|)
specifier|const
name|output_buffer
modifier|*
name|buffer
decl_stmt|;
block|{
return|return
name|line_wrap_cutoff
argument_list|(
name|buffer
argument_list|)
operator|-
name|output_text_length
argument_list|(
name|buffer
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Write out BUFFER's prefix.  */
end_comment

begin_function
name|void
name|output_emit_prefix
parameter_list|(
name|buffer
parameter_list|)
name|output_buffer
modifier|*
name|buffer
decl_stmt|;
block|{
if|if
condition|(
name|output_prefix
argument_list|(
name|buffer
argument_list|)
operator|!=
name|NULL
condition|)
block|{
switch|switch
condition|(
name|diagnostic_prefixing_rule
argument_list|(
name|buffer
argument_list|)
condition|)
block|{
default|default:
case|case
name|DIAGNOSTICS_SHOW_PREFIX_NEVER
case|:
break|break;
case|case
name|DIAGNOSTICS_SHOW_PREFIX_ONCE
case|:
if|if
condition|(
name|prefix_was_emitted_for
argument_list|(
name|buffer
argument_list|)
condition|)
block|{
name|output_indent
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
break|break;
block|}
name|output_indentation
argument_list|(
name|buffer
argument_list|)
operator|+=
literal|3
expr_stmt|;
comment|/* Fall through.  */
case|case
name|DIAGNOSTICS_SHOW_PREFIX_EVERY_LINE
case|:
block|{
name|int
name|prefix_length
init|=
name|strlen
argument_list|(
name|output_prefix
argument_list|(
name|buffer
argument_list|)
argument_list|)
decl_stmt|;
name|output_append_r
argument_list|(
name|buffer
argument_list|,
name|output_prefix
argument_list|(
name|buffer
argument_list|)
argument_list|,
name|prefix_length
argument_list|)
expr_stmt|;
name|prefix_was_emitted_for
argument_list|(
name|buffer
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Have BUFFER start a new line.  */
end_comment

begin_function
name|void
name|output_add_newline
parameter_list|(
name|buffer
parameter_list|)
name|output_buffer
modifier|*
name|buffer
decl_stmt|;
block|{
name|obstack_1grow
argument_list|(
operator|&
name|buffer
operator|->
name|obstack
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
name|output_text_length
argument_list|(
name|buffer
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Appends a character to BUFFER.  */
end_comment

begin_function
name|void
name|output_add_character
parameter_list|(
name|buffer
parameter_list|,
name|c
parameter_list|)
name|output_buffer
modifier|*
name|buffer
decl_stmt|;
name|int
name|c
decl_stmt|;
block|{
if|if
condition|(
name|output_is_line_wrapping
argument_list|(
name|buffer
argument_list|)
operator|&&
name|output_space_left
argument_list|(
name|buffer
argument_list|)
operator|<=
literal|0
condition|)
name|output_add_newline
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|obstack_1grow
argument_list|(
operator|&
name|buffer
operator|->
name|obstack
argument_list|,
name|c
argument_list|)
expr_stmt|;
operator|++
name|output_text_length
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Adds a space to BUFFER.  */
end_comment

begin_function
name|void
name|output_add_space
parameter_list|(
name|buffer
parameter_list|)
name|output_buffer
modifier|*
name|buffer
decl_stmt|;
block|{
if|if
condition|(
name|output_is_line_wrapping
argument_list|(
name|buffer
argument_list|)
operator|&&
name|output_space_left
argument_list|(
name|buffer
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|output_add_newline
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
return|return;
block|}
name|obstack_1grow
argument_list|(
operator|&
name|buffer
operator|->
name|obstack
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
operator|++
name|output_text_length
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* These functions format an INTEGER into BUFFER as suggested by their    names.  */
end_comment

begin_function
name|void
name|output_decimal
parameter_list|(
name|buffer
parameter_list|,
name|i
parameter_list|)
name|output_buffer
modifier|*
name|buffer
decl_stmt|;
name|int
name|i
decl_stmt|;
block|{
name|output_formatted_integer
argument_list|(
name|buffer
argument_list|,
literal|"%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_long_decimal
parameter_list|(
name|buffer
parameter_list|,
name|i
parameter_list|)
name|output_buffer
modifier|*
name|buffer
decl_stmt|;
name|long
name|int
name|i
decl_stmt|;
block|{
name|output_formatted_integer
argument_list|(
name|buffer
argument_list|,
literal|"%ld"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_unsigned_decimal
parameter_list|(
name|buffer
parameter_list|,
name|i
parameter_list|)
name|output_buffer
modifier|*
name|buffer
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
block|{
name|output_formatted_integer
argument_list|(
name|buffer
argument_list|,
literal|"%u"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_long_unsigned_decimal
parameter_list|(
name|buffer
parameter_list|,
name|i
parameter_list|)
name|output_buffer
modifier|*
name|buffer
decl_stmt|;
name|long
name|unsigned
name|int
name|i
decl_stmt|;
block|{
name|output_formatted_integer
argument_list|(
name|buffer
argument_list|,
literal|"%lu"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_octal
parameter_list|(
name|buffer
parameter_list|,
name|i
parameter_list|)
name|output_buffer
modifier|*
name|buffer
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
block|{
name|output_formatted_integer
argument_list|(
name|buffer
argument_list|,
literal|"%o"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_long_octal
parameter_list|(
name|buffer
parameter_list|,
name|i
parameter_list|)
name|output_buffer
modifier|*
name|buffer
decl_stmt|;
name|unsigned
name|long
name|int
name|i
decl_stmt|;
block|{
name|output_formatted_integer
argument_list|(
name|buffer
argument_list|,
literal|"%lo"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_hexadecimal
parameter_list|(
name|buffer
parameter_list|,
name|i
parameter_list|)
name|output_buffer
modifier|*
name|buffer
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
block|{
name|output_formatted_integer
argument_list|(
name|buffer
argument_list|,
literal|"%x"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_long_hexadecimal
parameter_list|(
name|buffer
parameter_list|,
name|i
parameter_list|)
name|output_buffer
modifier|*
name|buffer
decl_stmt|;
name|unsigned
name|long
name|int
name|i
decl_stmt|;
block|{
name|output_formatted_integer
argument_list|(
name|buffer
argument_list|,
literal|"%lx"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Append to BUFFER a string specified by its STARTING character    and LENGTH.  */
end_comment

begin_function
specifier|static
name|void
name|output_append_r
parameter_list|(
name|buffer
parameter_list|,
name|start
parameter_list|,
name|length
parameter_list|)
name|output_buffer
modifier|*
name|buffer
decl_stmt|;
specifier|const
name|char
modifier|*
name|start
decl_stmt|;
name|int
name|length
decl_stmt|;
block|{
name|obstack_grow
argument_list|(
operator|&
name|buffer
operator|->
name|obstack
argument_list|,
name|start
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|output_text_length
argument_list|(
name|buffer
argument_list|)
operator|+=
name|length
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Append a string deliminated by START and END to BUFFER.  No wrapping is    done.  However, if beginning a new line then emit output_prefix (BUFFER)    and skip any leading whitespace if appropriate.  The caller must ensure    that it is safe to do so.  */
end_comment

begin_function
name|void
name|output_append
parameter_list|(
name|buffer
parameter_list|,
name|start
parameter_list|,
name|end
parameter_list|)
name|output_buffer
modifier|*
name|buffer
decl_stmt|;
specifier|const
name|char
modifier|*
name|start
decl_stmt|;
specifier|const
name|char
modifier|*
name|end
decl_stmt|;
block|{
comment|/* Emit prefix and skip whitespace if we're starting a new line.  */
if|if
condition|(
name|is_starting_newline
argument_list|(
name|buffer
argument_list|)
condition|)
block|{
name|output_emit_prefix
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|output_is_line_wrapping
argument_list|(
name|buffer
argument_list|)
condition|)
while|while
condition|(
name|start
operator|!=
name|end
operator|&&
operator|*
name|start
operator|==
literal|' '
condition|)
operator|++
name|start
expr_stmt|;
block|}
name|output_append_r
argument_list|(
name|buffer
argument_list|,
name|start
argument_list|,
name|end
operator|-
name|start
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_indent
parameter_list|(
name|buffer
parameter_list|)
name|output_buffer
modifier|*
name|buffer
decl_stmt|;
block|{
name|int
name|n
init|=
name|output_indentation
argument_list|(
name|buffer
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
name|output_add_character
argument_list|(
name|buffer
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Wrap a text delimited by START and END into BUFFER.  */
end_comment

begin_function
specifier|static
name|void
name|wrap_text
parameter_list|(
name|buffer
parameter_list|,
name|start
parameter_list|,
name|end
parameter_list|)
name|output_buffer
modifier|*
name|buffer
decl_stmt|;
specifier|const
name|char
modifier|*
name|start
decl_stmt|;
specifier|const
name|char
modifier|*
name|end
decl_stmt|;
block|{
name|int
name|is_wrapping
init|=
name|output_is_line_wrapping
argument_list|(
name|buffer
argument_list|)
decl_stmt|;
while|while
condition|(
name|start
operator|!=
name|end
condition|)
block|{
comment|/* Dump anything bordered by whitespaces.  */
block|{
specifier|const
name|char
modifier|*
name|p
init|=
name|start
decl_stmt|;
while|while
condition|(
name|p
operator|!=
name|end
operator|&&
operator|*
name|p
operator|!=
literal|' '
operator|&&
operator|*
name|p
operator|!=
literal|'\n'
condition|)
operator|++
name|p
expr_stmt|;
if|if
condition|(
name|is_wrapping
operator|&&
name|p
operator|-
name|start
operator|>=
name|output_space_left
argument_list|(
name|buffer
argument_list|)
condition|)
name|output_add_newline
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|output_append
argument_list|(
name|buffer
argument_list|,
name|start
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|start
operator|=
name|p
expr_stmt|;
block|}
if|if
condition|(
name|start
operator|!=
name|end
operator|&&
operator|*
name|start
operator|==
literal|' '
condition|)
block|{
name|output_add_space
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
operator|++
name|start
expr_stmt|;
block|}
if|if
condition|(
name|start
operator|!=
name|end
operator|&&
operator|*
name|start
operator|==
literal|'\n'
condition|)
block|{
name|output_add_newline
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
operator|++
name|start
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Same as wrap_text but wrap text only when in line-wrapping mode.  */
end_comment

begin_function
specifier|static
name|void
name|maybe_wrap_text
parameter_list|(
name|buffer
parameter_list|,
name|start
parameter_list|,
name|end
parameter_list|)
name|output_buffer
modifier|*
name|buffer
decl_stmt|;
specifier|const
name|char
modifier|*
name|start
decl_stmt|;
specifier|const
name|char
modifier|*
name|end
decl_stmt|;
block|{
if|if
condition|(
name|output_is_line_wrapping
argument_list|(
name|buffer
argument_list|)
condition|)
name|wrap_text
argument_list|(
name|buffer
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
else|else
name|output_append
argument_list|(
name|buffer
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Append a STRING to BUFFER; the STRING might be line-wrapped if in    appropriate mode.  */
end_comment

begin_function
name|void
name|output_add_string
parameter_list|(
name|buffer
parameter_list|,
name|str
parameter_list|)
name|output_buffer
modifier|*
name|buffer
decl_stmt|;
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|maybe_wrap_text
argument_list|(
name|buffer
argument_list|,
name|str
argument_list|,
name|str
operator|+
operator|(
name|str
condition|?
name|strlen
argument_list|(
name|str
argument_list|)
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Flush the content of BUFFER onto the attached stream,    and reinitialize.  */
end_comment

begin_function
specifier|static
name|void
name|output_buffer_to_stream
parameter_list|(
name|buffer
parameter_list|)
name|output_buffer
modifier|*
name|buffer
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|text
init|=
name|output_finalize_message
argument_list|(
name|buffer
argument_list|)
decl_stmt|;
name|fputs
argument_list|(
name|text
argument_list|,
name|output_buffer_attached_stream
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
name|output_clear_message_text
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Format a message pointed to by output_buffer_text_cursor (BUFFER) using    output_buffer_format_args (BUFFER) as appropriate.  The following format    specifiers are recognized as being language independent:    %d, %i: (signed) integer in base ten.    %u: unsigned integer in base ten.    %o: unsigned integer in base eight.    %x: unsigned integer in base sixteen.    %ld, %li, %lo, %lu, %lx: long versions of the above.    %c: character.    %s: string.    %%: `%'.    %*.s: a substring the length of which is specified by an integer.  */
end_comment

begin_function
specifier|static
name|void
name|output_format
parameter_list|(
name|buffer
parameter_list|)
name|output_buffer
modifier|*
name|buffer
decl_stmt|;
block|{
for|for
control|(
init|;
operator|*
name|output_buffer_text_cursor
argument_list|(
name|buffer
argument_list|)
condition|;
operator|++
name|output_buffer_text_cursor
argument_list|(
name|buffer
argument_list|)
control|)
block|{
name|int
name|long_integer
init|=
literal|0
decl_stmt|;
comment|/* Ignore text.  */
block|{
specifier|const
name|char
modifier|*
name|p
init|=
name|output_buffer_text_cursor
argument_list|(
name|buffer
argument_list|)
decl_stmt|;
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|'%'
condition|)
operator|++
name|p
expr_stmt|;
name|wrap_text
argument_list|(
name|buffer
argument_list|,
name|output_buffer_text_cursor
argument_list|(
name|buffer
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|output_buffer_text_cursor
argument_list|(
name|buffer
argument_list|)
operator|=
name|p
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|*
name|output_buffer_text_cursor
argument_list|(
name|buffer
argument_list|)
condition|)
break|break;
comment|/* We got a '%'.  Let's see what happens. Record whether we're          parsing a long integer format specifier.  */
if|if
condition|(
operator|*
operator|++
name|output_buffer_text_cursor
argument_list|(
name|buffer
argument_list|)
operator|==
literal|'l'
condition|)
block|{
name|long_integer
operator|=
literal|1
expr_stmt|;
operator|++
name|output_buffer_text_cursor
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
comment|/* Handle %c, %d, %i, %ld, %li, %lo, %lu, %lx, %o, %s, %u,          %x, %.*s; %%.  And nothing else.  Front-ends should install          printers to grok language specific format specifiers.  */
switch|switch
condition|(
operator|*
name|output_buffer_text_cursor
argument_list|(
name|buffer
argument_list|)
condition|)
block|{
case|case
literal|'c'
case|:
name|output_add_character
argument_list|(
name|buffer
argument_list|,
name|va_arg
argument_list|(
name|output_buffer_format_args
argument_list|(
name|buffer
argument_list|)
argument_list|,
name|int
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
case|case
literal|'i'
case|:
if|if
condition|(
name|long_integer
condition|)
name|output_long_decimal
argument_list|(
name|buffer
argument_list|,
name|va_arg
argument_list|(
argument|output_buffer_format_args (buffer)
argument_list|,
argument|long int
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|output_decimal
argument_list|(
name|buffer
argument_list|,
name|va_arg
argument_list|(
name|output_buffer_format_args
argument_list|(
name|buffer
argument_list|)
argument_list|,
name|int
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
if|if
condition|(
name|long_integer
condition|)
name|output_long_octal
argument_list|(
name|buffer
argument_list|,
name|va_arg
argument_list|(
argument|output_buffer_format_args (buffer)
argument_list|,
argument|unsigned long int
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|output_octal
argument_list|(
name|buffer
argument_list|,
name|va_arg
argument_list|(
argument|output_buffer_format_args (buffer)
argument_list|,
argument|unsigned int
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|output_add_string
argument_list|(
name|buffer
argument_list|,
name|va_arg
argument_list|(
name|output_buffer_format_args
argument_list|(
name|buffer
argument_list|)
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
if|if
condition|(
name|long_integer
condition|)
name|output_long_unsigned_decimal
argument_list|(
name|buffer
argument_list|,
name|va_arg
argument_list|(
argument|output_buffer_format_args (buffer)
argument_list|,
argument|long unsigned int
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|output_unsigned_decimal
argument_list|(
name|buffer
argument_list|,
name|va_arg
argument_list|(
argument|output_buffer_format_args (buffer)
argument_list|,
argument|unsigned int
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
if|if
condition|(
name|long_integer
condition|)
name|output_long_hexadecimal
argument_list|(
name|buffer
argument_list|,
name|va_arg
argument_list|(
argument|output_buffer_format_args (buffer)
argument_list|,
argument|unsigned long int
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|output_hexadecimal
argument_list|(
name|buffer
argument_list|,
name|va_arg
argument_list|(
argument|output_buffer_format_args (buffer)
argument_list|,
argument|unsigned int
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'%'
case|:
name|output_add_character
argument_list|(
name|buffer
argument_list|,
literal|'%'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'.'
case|:
block|{
name|int
name|n
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
comment|/* We handle no precision specifier but `%.*s'.  */
if|if
condition|(
operator|*
operator|++
name|output_buffer_text_cursor
argument_list|(
name|buffer
argument_list|)
operator|!=
literal|'*'
condition|)
name|abort
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
operator|++
name|output_buffer_text_cursor
argument_list|(
name|buffer
argument_list|)
operator|!=
literal|'s'
condition|)
name|abort
argument_list|()
expr_stmt|;
name|n
operator|=
name|va_arg
argument_list|(
name|output_buffer_format_args
argument_list|(
name|buffer
argument_list|)
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|s
operator|=
name|va_arg
argument_list|(
name|output_buffer_format_args
argument_list|(
name|buffer
argument_list|)
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
name|output_append
argument_list|(
name|buffer
argument_list|,
name|s
argument_list|,
name|s
operator|+
name|n
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
if|if
condition|(
operator|!
name|buffer
operator|->
name|format_decoder
operator|||
operator|!
call|(
modifier|*
name|buffer
operator|->
name|format_decoder
call|)
argument_list|(
name|buffer
argument_list|)
condition|)
block|{
comment|/* Hmmm.  The front-end failed to install a format translator                  but called us with an unrecognized format.  Sorry.  */
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|vbuild_message_string
parameter_list|(
name|msg
parameter_list|,
name|ap
parameter_list|)
specifier|const
name|char
modifier|*
name|msg
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
block|{
name|char
modifier|*
name|str
decl_stmt|;
name|vasprintf
argument_list|(
operator|&
name|str
argument_list|,
name|msg
argument_list|,
name|ap
argument_list|)
expr_stmt|;
return|return
name|str
return|;
block|}
end_function

begin_comment
comment|/*  Return a malloc'd string containing MSG formatted a la     printf.  The caller is responsible for freeing the memory.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|build_message_string
name|VPARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|msg
operator|,
operator|...
operator|)
argument_list|)
block|{
name|char
modifier|*
name|str
decl_stmt|;
name|VA_OPEN
argument_list|(
name|ap
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|str
operator|=
name|vbuild_message_string
argument_list|(
name|msg
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|VA_CLOSE
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
name|str
return|;
block|}
end_decl_stmt

begin_comment
comment|/* Return a malloc'd string describing a location.  The caller is    responsible for freeing the memory.  */
end_comment

begin_function
name|char
modifier|*
name|context_as_prefix
parameter_list|(
name|file
parameter_list|,
name|line
parameter_list|,
name|warn
parameter_list|)
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|line
decl_stmt|;
name|int
name|warn
decl_stmt|;
block|{
if|if
condition|(
name|file
condition|)
block|{
if|if
condition|(
name|warn
condition|)
return|return
name|build_message_string
argument_list|(
name|_
argument_list|(
literal|"%s:%d: warning: "
argument_list|)
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
return|;
else|else
return|return
name|build_message_string
argument_list|(
literal|"%s:%d: "
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|warn
condition|)
return|return
name|build_message_string
argument_list|(
name|_
argument_list|(
literal|"%s: warning: "
argument_list|)
argument_list|,
name|progname
argument_list|)
return|;
else|else
return|return
name|build_message_string
argument_list|(
literal|"%s: "
argument_list|,
name|progname
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Same as context_as_prefix, but only the source FILE is given.  */
end_comment

begin_function
name|char
modifier|*
name|file_name_as_prefix
parameter_list|(
name|f
parameter_list|)
specifier|const
name|char
modifier|*
name|f
decl_stmt|;
block|{
return|return
name|build_message_string
argument_list|(
literal|"%s: "
argument_list|,
name|f
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Format a MESSAGE into BUFFER.  Automatically wrap lines.  */
end_comment

begin_function
specifier|static
name|void
name|output_do_printf
parameter_list|(
name|buffer
parameter_list|,
name|msg
parameter_list|)
name|output_buffer
modifier|*
name|buffer
decl_stmt|;
specifier|const
name|char
modifier|*
name|msg
decl_stmt|;
block|{
name|char
modifier|*
name|message
init|=
name|vbuild_message_string
argument_list|(
name|msg
argument_list|,
name|output_buffer_format_args
argument_list|(
name|buffer
argument_list|)
argument_list|)
decl_stmt|;
name|wrap_text
argument_list|(
name|buffer
argument_list|,
name|message
argument_list|,
name|message
operator|+
name|strlen
argument_list|(
name|message
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Format a message into BUFFER a la printf.  */
end_comment

begin_decl_stmt
name|void
name|output_printf
name|VPARAMS
argument_list|(
operator|(
expr|struct
name|output_buffer
operator|*
name|buffer
operator|,
specifier|const
name|char
operator|*
name|msgid
operator|,
operator|...
operator|)
argument_list|)
block|{
name|va_list
modifier|*
name|old_args
decl_stmt|;
name|VA_OPEN
argument_list|(
name|ap
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
name|output_buffer
operator|*
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|old_args
operator|=
name|output_buffer_ptr_to_format_args
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|output_buffer_ptr_to_format_args
argument_list|(
name|buffer
argument_list|)
operator|=
operator|&
name|ap
expr_stmt|;
name|output_do_printf
argument_list|(
name|buffer
argument_list|,
name|_
argument_list|(
name|msgid
argument_list|)
argument_list|)
expr_stmt|;
name|output_buffer_ptr_to_format_args
argument_list|(
name|buffer
argument_list|)
operator|=
name|old_args
expr_stmt|;
name|VA_CLOSE
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* Print a message relevant to the given DECL.  */
end_comment

begin_function
specifier|static
name|void
name|format_with_decl
parameter_list|(
name|buffer
parameter_list|,
name|decl
parameter_list|)
name|output_buffer
modifier|*
name|buffer
decl_stmt|;
name|tree
name|decl
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
comment|/* Do magic to get around lack of varargs support for insertion      of arguments into existing list.  We know that the decl is first;      we ass_u_me that it will be printed with "%s".  */
for|for
control|(
name|p
operator|=
name|output_buffer_text_cursor
argument_list|(
name|buffer
argument_list|)
init|;
operator|*
name|p
condition|;
operator|++
name|p
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'%'
condition|)
block|{
if|if
condition|(
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
operator|==
literal|'%'
condition|)
operator|++
name|p
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
operator|!=
literal|'s'
condition|)
name|abort
argument_list|()
expr_stmt|;
else|else
break|break;
block|}
block|}
comment|/* Print the left-hand substring.  */
name|maybe_wrap_text
argument_list|(
name|buffer
argument_list|,
name|output_buffer_text_cursor
argument_list|(
name|buffer
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'%'
condition|)
comment|/* Print the name.  */
block|{
specifier|const
name|char
modifier|*
specifier|const
name|n
init|=
operator|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
condition|?
call|(
modifier|*
name|decl_printable_name
call|)
argument_list|(
name|decl
argument_list|,
literal|2
argument_list|)
else|:
name|_
argument_list|(
literal|"((anonymous))"
argument_list|)
operator|)
decl_stmt|;
name|output_add_string
argument_list|(
name|buffer
argument_list|,
name|n
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
block|{
operator|++
name|p
expr_stmt|;
if|if
condition|(
name|ISALPHA
argument_list|(
operator|*
operator|(
name|p
operator|-
literal|1
operator|)
operator|&
literal|0xFF
argument_list|)
condition|)
break|break;
block|}
block|}
if|if
condition|(
operator|*
name|p
condition|)
comment|/* Print the rest of the message.  */
block|{
name|output_buffer_text_cursor
argument_list|(
name|buffer
argument_list|)
operator|=
name|p
expr_stmt|;
name|output_format
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Report a diagnostic MESSAGE at the declaration DECL.    MSG is a format string which uses %s to substitute the declaration    name; subsequent substitutions are a la output_format.  */
end_comment

begin_function
specifier|static
name|void
name|diagnostic_for_decl
parameter_list|(
name|decl
parameter_list|,
name|msgid
parameter_list|,
name|args_ptr
parameter_list|,
name|warn
parameter_list|)
name|tree
name|decl
decl_stmt|;
specifier|const
name|char
modifier|*
name|msgid
decl_stmt|;
name|va_list
modifier|*
name|args_ptr
decl_stmt|;
name|int
name|warn
decl_stmt|;
block|{
name|output_state
name|os
decl_stmt|;
if|if
condition|(
name|diagnostic_lock
operator|++
condition|)
name|error_recursion
argument_list|()
expr_stmt|;
if|if
condition|(
name|count_error
argument_list|(
name|warn
argument_list|)
condition|)
block|{
name|os
operator|=
name|output_buffer_state
argument_list|(
name|diagnostic_buffer
argument_list|)
expr_stmt|;
name|report_error_function
argument_list|(
name|DECL_SOURCE_FILE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|output_set_prefix
argument_list|(
name|diagnostic_buffer
argument_list|,
name|context_as_prefix
argument_list|(
name|DECL_SOURCE_FILE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|DECL_SOURCE_LINE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|warn
argument_list|)
argument_list|)
expr_stmt|;
name|output_buffer_ptr_to_format_args
argument_list|(
name|diagnostic_buffer
argument_list|)
operator|=
name|args_ptr
expr_stmt|;
name|output_buffer_text_cursor
argument_list|(
name|diagnostic_buffer
argument_list|)
operator|=
name|_
argument_list|(
name|msgid
argument_list|)
expr_stmt|;
name|format_with_decl
argument_list|(
name|diagnostic_buffer
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|diagnostic_finish
argument_list|(
operator|(
name|output_buffer
operator|*
operator|)
name|global_dc
argument_list|)
expr_stmt|;
name|output_destroy_prefix
argument_list|(
name|diagnostic_buffer
argument_list|)
expr_stmt|;
name|output_buffer_state
argument_list|(
name|diagnostic_buffer
argument_list|)
operator|=
name|os
expr_stmt|;
block|}
name|diagnostic_lock
operator|--
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Count an error or warning.  Return 1 if the message should be printed.  */
end_comment

begin_function
name|int
name|count_error
parameter_list|(
name|warningp
parameter_list|)
name|int
name|warningp
decl_stmt|;
block|{
if|if
condition|(
name|warningp
operator|&&
operator|!
name|diagnostic_report_warnings_p
argument_list|()
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|warningp
operator|&&
operator|!
name|warnings_are_errors
condition|)
name|warningcount
operator|++
expr_stmt|;
else|else
block|{
specifier|static
name|int
name|warning_message
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|warningp
operator|&&
operator|!
name|warning_message
condition|)
block|{
name|verbatim
argument_list|(
literal|"%s: warnings being treated as errors\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|warning_message
operator|=
literal|1
expr_stmt|;
block|}
name|errorcount
operator|++
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Print a diagnostic MSGID on FILE.  This is just fprintf, except it    runs its second argument through gettext.  */
end_comment

begin_decl_stmt
name|void
name|fnotice
name|VPARAMS
argument_list|(
operator|(
name|FILE
operator|*
name|file
operator|,
specifier|const
name|char
operator|*
name|msgid
operator|,
operator|...
operator|)
argument_list|)
block|{
name|VA_OPEN
argument_list|(
name|ap
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
name|FILE
operator|*
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
name|msgid
argument_list|)
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|VA_CLOSE
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* Print a fatal I/O error message.  Argument are like printf.    Also include a system error message based on `errno'.  */
end_comment

begin_decl_stmt
name|void
name|fatal_io_error
name|VPARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|msgid
operator|,
operator|...
operator|)
argument_list|)
block|{
name|output_state
name|os
decl_stmt|;
name|VA_OPEN
argument_list|(
name|ap
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|os
operator|=
name|output_buffer_state
argument_list|(
name|diagnostic_buffer
argument_list|)
expr_stmt|;
name|output_printf
argument_list|(
name|diagnostic_buffer
argument_list|,
literal|"%s: %s: "
argument_list|,
name|progname
argument_list|,
name|xstrerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|output_buffer_ptr_to_format_args
argument_list|(
name|diagnostic_buffer
argument_list|)
operator|=
operator|&
name|ap
expr_stmt|;
name|output_buffer_text_cursor
argument_list|(
name|diagnostic_buffer
argument_list|)
operator|=
name|_
argument_list|(
name|msgid
argument_list|)
expr_stmt|;
name|output_format
argument_list|(
name|diagnostic_buffer
argument_list|)
expr_stmt|;
name|diagnostic_finish
argument_list|(
operator|(
name|output_buffer
operator|*
operator|)
name|global_dc
argument_list|)
expr_stmt|;
name|output_buffer_state
argument_list|(
name|diagnostic_buffer
argument_list|)
operator|=
name|os
expr_stmt|;
name|VA_CLOSE
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|FATAL_EXIT_CODE
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* Issue a pedantic warning MSGID.  */
end_comment

begin_decl_stmt
name|void
name|pedwarn
name|VPARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|msgid
operator|,
operator|...
operator|)
argument_list|)
block|{
name|diagnostic_context
name|dc
decl_stmt|;
name|VA_OPEN
argument_list|(
name|ap
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|set_diagnostic_context
argument_list|(
operator|&
name|dc
argument_list|,
name|msgid
argument_list|,
operator|&
name|ap
argument_list|,
name|input_filename
argument_list|,
name|lineno
argument_list|,
operator|!
name|flag_pedantic_errors
argument_list|)
expr_stmt|;
name|report_diagnostic
argument_list|(
operator|&
name|dc
argument_list|)
expr_stmt|;
name|VA_CLOSE
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* Issue a pedantic waring about DECL.  */
end_comment

begin_decl_stmt
name|void
name|pedwarn_with_decl
name|VPARAMS
argument_list|(
operator|(
name|tree
name|decl
operator|,
specifier|const
name|char
operator|*
name|msgid
operator|,
operator|...
operator|)
argument_list|)
block|{
name|VA_OPEN
argument_list|(
name|ap
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
name|tree
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
comment|/* We don't want -pedantic-errors to cause the compilation to fail from      "errors" in system header files.  Sometimes fixincludes can't fix what's      broken (eg: unsigned char bitfields - fixing it may change the alignment      which will cause programs to mysteriously fail because the C library      or kernel uses the original layout).  There's no point in issuing a      warning either, it's just unnecessary noise.  */
if|if
condition|(
operator|!
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|decl
argument_list|)
condition|)
name|diagnostic_for_decl
argument_list|(
name|decl
argument_list|,
name|msgid
argument_list|,
operator|&
name|ap
argument_list|,
operator|!
name|flag_pedantic_errors
argument_list|)
expr_stmt|;
name|VA_CLOSE
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* Same as above but within the context FILE and LINE.  */
end_comment

begin_decl_stmt
name|void
name|pedwarn_with_file_and_line
name|VPARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|file
operator|,
name|int
name|line
operator|,
specifier|const
name|char
operator|*
name|msgid
operator|,
operator|...
operator|)
argument_list|)
block|{
name|diagnostic_context
name|dc
decl_stmt|;
name|VA_OPEN
argument_list|(
name|ap
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
name|int
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|set_diagnostic_context
argument_list|(
operator|&
name|dc
argument_list|,
name|msgid
argument_list|,
operator|&
name|ap
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
operator|!
name|flag_pedantic_errors
argument_list|)
expr_stmt|;
name|report_diagnostic
argument_list|(
operator|&
name|dc
argument_list|)
expr_stmt|;
name|VA_CLOSE
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* Just apologize with MSGID.  */
end_comment

begin_decl_stmt
name|void
name|sorry
name|VPARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|msgid
operator|,
operator|...
operator|)
argument_list|)
block|{
name|output_state
name|os
decl_stmt|;
name|VA_OPEN
argument_list|(
name|ap
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
operator|++
name|sorrycount
expr_stmt|;
name|os
operator|=
name|output_buffer_state
argument_list|(
name|diagnostic_buffer
argument_list|)
expr_stmt|;
name|output_set_prefix
argument_list|(
name|diagnostic_buffer
argument_list|,
name|context_as_prefix
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|output_printf
argument_list|(
name|diagnostic_buffer
argument_list|,
literal|"sorry, not implemented: "
argument_list|)
expr_stmt|;
name|output_buffer_ptr_to_format_args
argument_list|(
name|diagnostic_buffer
argument_list|)
operator|=
operator|&
name|ap
expr_stmt|;
name|output_buffer_text_cursor
argument_list|(
name|diagnostic_buffer
argument_list|)
operator|=
name|_
argument_list|(
name|msgid
argument_list|)
expr_stmt|;
name|output_format
argument_list|(
name|diagnostic_buffer
argument_list|)
expr_stmt|;
name|diagnostic_finish
argument_list|(
operator|(
name|output_buffer
operator|*
operator|)
name|global_dc
argument_list|)
expr_stmt|;
name|output_buffer_state
argument_list|(
name|diagnostic_buffer
argument_list|)
operator|=
name|os
expr_stmt|;
name|VA_CLOSE
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* Called when the start of a function definition is parsed,    this function prints on stderr the name of the function.  */
end_comment

begin_function
name|void
name|announce_function
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|quiet_flag
condition|)
block|{
if|if
condition|(
name|rtl_dump_and_exit
condition|)
name|verbatim
argument_list|(
literal|"%s "
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|verbatim
argument_list|(
literal|" %s"
argument_list|,
call|(
modifier|*
name|decl_printable_name
call|)
argument_list|(
name|decl
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|output_needs_newline
argument_list|(
name|diagnostic_buffer
argument_list|)
operator|=
literal|1
expr_stmt|;
name|record_last_error_function
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* The default function to print out name of current function that caused    an error.  */
end_comment

begin_function
name|void
name|default_print_error_function
parameter_list|(
name|context
parameter_list|,
name|file
parameter_list|)
name|diagnostic_context
modifier|*
name|context
decl_stmt|;
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
block|{
if|if
condition|(
name|error_function_changed
argument_list|()
condition|)
block|{
name|char
modifier|*
name|prefix
init|=
name|file
condition|?
name|build_message_string
argument_list|(
literal|"%s: "
argument_list|,
name|file
argument_list|)
else|:
name|NULL
decl_stmt|;
name|output_state
name|os
decl_stmt|;
name|os
operator|=
name|output_buffer_state
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|output_set_prefix
argument_list|(
operator|(
name|output_buffer
operator|*
operator|)
name|context
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_function_decl
operator|==
name|NULL
condition|)
name|output_add_string
argument_list|(
operator|(
name|output_buffer
operator|*
operator|)
name|context
argument_list|,
name|_
argument_list|(
literal|"At top level:"
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
name|output_printf
argument_list|(
operator|(
name|output_buffer
operator|*
operator|)
name|context
argument_list|,
literal|"In member function `%s':"
argument_list|,
call|(
modifier|*
name|decl_printable_name
call|)
argument_list|(
name|current_function_decl
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|output_printf
argument_list|(
operator|(
name|output_buffer
operator|*
operator|)
name|context
argument_list|,
literal|"In function `%s':"
argument_list|,
call|(
modifier|*
name|decl_printable_name
call|)
argument_list|(
name|current_function_decl
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|output_add_newline
argument_list|(
operator|(
name|output_buffer
operator|*
operator|)
name|context
argument_list|)
expr_stmt|;
name|record_last_error_function
argument_list|()
expr_stmt|;
name|output_buffer_to_stream
argument_list|(
operator|(
name|output_buffer
operator|*
operator|)
name|context
argument_list|)
expr_stmt|;
name|output_buffer_state
argument_list|(
name|context
argument_list|)
operator|=
name|os
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|prefix
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Prints out, if necessary, the name of the current function   that caused an error.  Called from all error and warning functions.   We ignore the FILE parameter, as it cannot be relied upon.  */
end_comment

begin_function
name|void
name|report_error_function
parameter_list|(
name|file
parameter_list|)
specifier|const
name|char
modifier|*
name|file
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|report_problematic_module
argument_list|(
operator|(
name|output_buffer
operator|*
operator|)
name|global_dc
argument_list|)
expr_stmt|;
call|(
modifier|*
name|print_error_function
call|)
argument_list|(
name|global_dc
argument_list|,
name|input_filename
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|void
name|error_with_file_and_line
name|VPARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|file
operator|,
name|int
name|line
operator|,
specifier|const
name|char
operator|*
name|msgid
operator|,
operator|...
operator|)
argument_list|)
block|{
name|diagnostic_context
name|dc
decl_stmt|;
name|VA_OPEN
argument_list|(
name|ap
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
name|int
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|set_diagnostic_context
argument_list|(
operator|&
name|dc
argument_list|,
name|msgid
argument_list|,
operator|&
name|ap
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
comment|/* warn = */
literal|0
argument_list|)
expr_stmt|;
name|report_diagnostic
argument_list|(
operator|&
name|dc
argument_list|)
expr_stmt|;
name|VA_CLOSE
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|void
name|error_with_decl
name|VPARAMS
argument_list|(
operator|(
name|tree
name|decl
operator|,
specifier|const
name|char
operator|*
name|msgid
operator|,
operator|...
operator|)
argument_list|)
block|{
name|VA_OPEN
argument_list|(
name|ap
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
name|tree
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|diagnostic_for_decl
argument_list|(
name|decl
argument_list|,
name|msgid
argument_list|,
operator|&
name|ap
argument_list|,
comment|/* warn = */
literal|0
argument_list|)
expr_stmt|;
name|VA_CLOSE
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* Report an error message.  The arguments are like that of printf.  */
end_comment

begin_decl_stmt
name|void
name|error
name|VPARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|msgid
operator|,
operator|...
operator|)
argument_list|)
block|{
name|diagnostic_context
name|dc
decl_stmt|;
name|VA_OPEN
argument_list|(
name|ap
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|set_diagnostic_context
argument_list|(
operator|&
name|dc
argument_list|,
name|msgid
argument_list|,
operator|&
name|ap
argument_list|,
name|input_filename
argument_list|,
name|lineno
argument_list|,
comment|/* warn = */
literal|0
argument_list|)
expr_stmt|;
name|report_diagnostic
argument_list|(
operator|&
name|dc
argument_list|)
expr_stmt|;
name|VA_CLOSE
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* Likewise, except that the compilation is terminated after printing the    error message.  */
end_comment

begin_decl_stmt
name|void
name|fatal_error
name|VPARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|msgid
operator|,
operator|...
operator|)
argument_list|)
block|{
name|diagnostic_context
name|dc
decl_stmt|;
name|VA_OPEN
argument_list|(
name|ap
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|set_diagnostic_context
argument_list|(
operator|&
name|dc
argument_list|,
name|msgid
argument_list|,
operator|&
name|ap
argument_list|,
name|input_filename
argument_list|,
name|lineno
argument_list|,
comment|/* warn = */
literal|0
argument_list|)
expr_stmt|;
name|report_diagnostic
argument_list|(
operator|&
name|dc
argument_list|)
expr_stmt|;
name|VA_CLOSE
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|fnotice
argument_list|(
name|stderr
argument_list|,
literal|"compilation terminated.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|FATAL_EXIT_CODE
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* Report a compiler error at the current line number.  Allow a front end to    intercept the message.  */
end_comment

begin_expr_stmt
specifier|static
name|void
argument_list|(
argument|*internal_error_function
argument_list|)
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|va_list
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Set the function to call when a compiler error occurs.  */
end_comment

begin_function_decl
name|void
name|set_internal_error_function
parameter_list|(
name|f
parameter_list|)
function_decl|void
parameter_list|(
function_decl|*f
end_function_decl

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|va_list
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|internal_error_function
operator|=
name|f
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|void
name|internal_error
name|VPARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|msgid
operator|,
operator|...
operator|)
argument_list|)
block|{
name|diagnostic_context
name|dc
decl_stmt|;
name|VA_OPEN
argument_list|(
name|ap
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
if|if
condition|(
name|diagnostic_lock
condition|)
name|error_recursion
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|ENABLE_CHECKING
if|if
condition|(
name|errorcount
operator|>
literal|0
operator|||
name|sorrycount
operator|>
literal|0
condition|)
block|{
name|fnotice
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: confused by earlier errors, bailing out\n"
argument_list|,
name|input_filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|FATAL_EXIT_CODE
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|internal_error_function
operator|!=
literal|0
condition|)
call|(
modifier|*
name|internal_error_function
call|)
argument_list|(
name|_
argument_list|(
name|msgid
argument_list|)
argument_list|,
operator|&
name|ap
argument_list|)
expr_stmt|;
name|set_diagnostic_context
argument_list|(
operator|&
name|dc
argument_list|,
name|msgid
argument_list|,
operator|&
name|ap
argument_list|,
name|input_filename
argument_list|,
name|lineno
argument_list|,
comment|/* warn = */
literal|0
argument_list|)
expr_stmt|;
name|report_diagnostic
argument_list|(
operator|&
name|dc
argument_list|)
expr_stmt|;
name|VA_CLOSE
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|fnotice
argument_list|(
name|stderr
argument_list|,
literal|"Please submit a full bug report,\n\ with preprocessed source if appropriate.\n\ See %s for instructions.\n"
argument_list|,
name|GCCBUGURL
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|FATAL_EXIT_CODE
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|void
name|warning_with_file_and_line
name|VPARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|file
operator|,
name|int
name|line
operator|,
specifier|const
name|char
operator|*
name|msgid
operator|,
operator|...
operator|)
argument_list|)
block|{
name|diagnostic_context
name|dc
decl_stmt|;
name|VA_OPEN
argument_list|(
name|ap
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
name|int
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|set_diagnostic_context
argument_list|(
operator|&
name|dc
argument_list|,
name|msgid
argument_list|,
operator|&
name|ap
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
comment|/* warn = */
literal|1
argument_list|)
expr_stmt|;
name|report_diagnostic
argument_list|(
operator|&
name|dc
argument_list|)
expr_stmt|;
name|VA_CLOSE
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|void
name|warning_with_decl
name|VPARAMS
argument_list|(
operator|(
name|tree
name|decl
operator|,
specifier|const
name|char
operator|*
name|msgid
operator|,
operator|...
operator|)
argument_list|)
block|{
name|VA_OPEN
argument_list|(
name|ap
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
name|tree
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|diagnostic_for_decl
argument_list|(
name|decl
argument_list|,
name|msgid
argument_list|,
operator|&
name|ap
argument_list|,
comment|/* warn = */
literal|1
argument_list|)
expr_stmt|;
name|VA_CLOSE
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|void
name|warning
name|VPARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|msgid
operator|,
operator|...
operator|)
argument_list|)
block|{
name|diagnostic_context
name|dc
decl_stmt|;
name|VA_OPEN
argument_list|(
name|ap
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|set_diagnostic_context
argument_list|(
operator|&
name|dc
argument_list|,
name|msgid
argument_list|,
operator|&
name|ap
argument_list|,
name|input_filename
argument_list|,
name|lineno
argument_list|,
comment|/* warn = */
literal|1
argument_list|)
expr_stmt|;
name|report_diagnostic
argument_list|(
operator|&
name|dc
argument_list|)
expr_stmt|;
name|VA_CLOSE
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* Flush diagnostic_buffer content on stderr.  */
end_comment

begin_function
specifier|static
name|void
name|diagnostic_finish
parameter_list|(
name|buffer
parameter_list|)
name|output_buffer
modifier|*
name|buffer
decl_stmt|;
block|{
name|output_buffer_to_stream
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|clear_diagnostic_info
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|output_buffer_attached_stream
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|output_buffer_attached_stream
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Helper subroutine of output_verbatim and verbatim. Do the appropriate    settings needed by BUFFER for a verbatim formatting.  */
end_comment

begin_function
specifier|static
name|void
name|output_do_verbatim
parameter_list|(
name|buffer
parameter_list|,
name|msgid
parameter_list|,
name|args_ptr
parameter_list|)
name|output_buffer
modifier|*
name|buffer
decl_stmt|;
specifier|const
name|char
modifier|*
name|msgid
decl_stmt|;
name|va_list
modifier|*
name|args_ptr
decl_stmt|;
block|{
name|output_state
name|os
decl_stmt|;
name|os
operator|=
name|output_buffer_state
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|output_prefix
argument_list|(
name|buffer
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|diagnostic_prefixing_rule
argument_list|(
name|buffer
argument_list|)
operator|=
name|DIAGNOSTICS_SHOW_PREFIX_NEVER
expr_stmt|;
name|output_buffer_text_cursor
argument_list|(
name|buffer
argument_list|)
operator|=
name|_
argument_list|(
name|msgid
argument_list|)
expr_stmt|;
name|output_buffer_ptr_to_format_args
argument_list|(
name|buffer
argument_list|)
operator|=
name|args_ptr
expr_stmt|;
name|output_set_maximum_length
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|output_format
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|output_buffer_state
argument_list|(
name|buffer
argument_list|)
operator|=
name|os
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output MESSAGE verbatim into BUFFER.  */
end_comment

begin_decl_stmt
name|void
name|output_verbatim
name|VPARAMS
argument_list|(
operator|(
name|output_buffer
operator|*
name|buffer
operator|,
specifier|const
name|char
operator|*
name|msgid
operator|,
operator|...
operator|)
argument_list|)
block|{
name|VA_OPEN
argument_list|(
name|ap
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
name|output_buffer
operator|*
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|output_do_verbatim
argument_list|(
name|buffer
argument_list|,
name|msgid
argument_list|,
operator|&
name|ap
argument_list|)
expr_stmt|;
name|VA_CLOSE
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* Same as above but use diagnostic_buffer.  */
end_comment

begin_decl_stmt
name|void
name|verbatim
name|VPARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|msgid
operator|,
operator|...
operator|)
argument_list|)
block|{
name|VA_OPEN
argument_list|(
name|ap
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|output_do_verbatim
argument_list|(
name|diagnostic_buffer
argument_list|,
name|msgid
argument_list|,
operator|&
name|ap
argument_list|)
expr_stmt|;
name|output_buffer_to_stream
argument_list|(
name|diagnostic_buffer
argument_list|)
expr_stmt|;
name|VA_CLOSE
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* Report a diagnostic message (an error or a warning) as specified by    DC.  This function is *the* subroutine in terms of which front-ends    should implement their specific diagnostic handling modules.  The    front-end independent format specifiers are exactly those described    in the documentation of output_format.  */
end_comment

begin_function
name|void
name|report_diagnostic
parameter_list|(
name|dc
parameter_list|)
name|diagnostic_context
modifier|*
name|dc
decl_stmt|;
block|{
name|output_state
name|os
decl_stmt|;
if|if
condition|(
name|diagnostic_lock
operator|++
condition|)
name|error_recursion
argument_list|()
expr_stmt|;
if|if
condition|(
name|count_error
argument_list|(
name|diagnostic_is_warning
argument_list|(
name|dc
argument_list|)
argument_list|)
condition|)
block|{
name|os
operator|=
name|output_buffer_state
argument_list|(
name|diagnostic_buffer
argument_list|)
expr_stmt|;
name|diagnostic_msg
operator|=
name|diagnostic_message
argument_list|(
name|dc
argument_list|)
expr_stmt|;
name|diagnostic_args
operator|=
name|diagnostic_argument_list
argument_list|(
name|dc
argument_list|)
expr_stmt|;
operator|(
operator|*
name|diagnostic_starter
argument_list|(
name|dc
argument_list|)
operator|)
operator|(
name|diagnostic_buffer
operator|,
name|dc
operator|)
expr_stmt|;
name|output_format
argument_list|(
name|diagnostic_buffer
argument_list|)
expr_stmt|;
operator|(
operator|*
name|diagnostic_finalizer
argument_list|(
name|dc
argument_list|)
operator|)
operator|(
name|diagnostic_buffer
operator|,
name|dc
operator|)
expr_stmt|;
name|diagnostic_finish
argument_list|(
operator|(
name|output_buffer
operator|*
operator|)
name|global_dc
argument_list|)
expr_stmt|;
name|output_buffer_state
argument_list|(
name|diagnostic_buffer
argument_list|)
operator|=
name|os
expr_stmt|;
block|}
name|diagnostic_lock
operator|--
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Inform the user that an error occurred while trying to report some    other error.  This indicates catastrophic internal inconsistencies,    so give up now.  But do try to flush out the previous error.    This mustn't use internal_error, that will cause infinite recursion.  */
end_comment

begin_function
specifier|static
name|void
name|error_recursion
parameter_list|()
block|{
if|if
condition|(
name|diagnostic_lock
operator|<
literal|3
condition|)
name|diagnostic_finish
argument_list|(
operator|(
name|output_buffer
operator|*
operator|)
name|global_dc
argument_list|)
expr_stmt|;
name|fnotice
argument_list|(
name|stderr
argument_list|,
literal|"Internal compiler error: Error reporting routines re-entered.\n"
argument_list|)
expr_stmt|;
name|fnotice
argument_list|(
name|stderr
argument_list|,
literal|"Please submit a full bug report,\n\ with preprocessed source if appropriate.\n\ See %s for instructions.\n"
argument_list|,
name|GCCBUGURL
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|FATAL_EXIT_CODE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given a partial pathname as input, return another pathname that    shares no directory elements with the pathname of __FILE__.  This    is used by fancy_abort() to print `Internal compiler error in expr.c'    instead of `Internal compiler error in ../../GCC/gcc/expr.c'.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|trim_filename
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|static
specifier|const
name|char
name|this_file
index|[]
init|=
name|__FILE__
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
init|=
name|name
decl_stmt|,
modifier|*
name|q
init|=
name|this_file
decl_stmt|;
comment|/* First skip any "../" in each filename.  This allows us to give a proper      reference to a file in a subdirectory.  */
while|while
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
operator|(
name|p
index|[
literal|2
index|]
operator|==
name|DIR_SEPARATOR
ifdef|#
directive|ifdef
name|DIR_SEPARATOR_2
operator|||
name|p
index|[
literal|2
index|]
operator|==
name|DIR_SEPARATOR_2
endif|#
directive|endif
operator|)
condition|)
name|p
operator|+=
literal|3
expr_stmt|;
while|while
condition|(
name|q
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|q
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
operator|(
name|q
index|[
literal|2
index|]
operator|==
name|DIR_SEPARATOR
ifdef|#
directive|ifdef
name|DIR_SEPARATOR_2
operator|||
name|p
index|[
literal|2
index|]
operator|==
name|DIR_SEPARATOR_2
endif|#
directive|endif
operator|)
condition|)
name|q
operator|+=
literal|3
expr_stmt|;
comment|/* Now skip any parts the two filenames have in common.  */
while|while
condition|(
operator|*
name|p
operator|==
operator|*
name|q
operator|&&
operator|*
name|p
operator|!=
literal|0
operator|&&
operator|*
name|q
operator|!=
literal|0
condition|)
name|p
operator|++
operator|,
name|q
operator|++
expr_stmt|;
comment|/* Now go backwards until the previous directory separator.  */
while|while
condition|(
name|p
operator|>
name|name
operator|&&
name|p
index|[
operator|-
literal|1
index|]
operator|!=
name|DIR_SEPARATOR
ifdef|#
directive|ifdef
name|DIR_SEPARATOR_2
operator|&&
name|p
index|[
operator|-
literal|1
index|]
operator|!=
name|DIR_SEPARATOR_2
endif|#
directive|endif
condition|)
name|p
operator|--
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* Report an internal compiler error in a friendly manner and without    dumping core.  */
end_comment

begin_function
name|void
name|fancy_abort
parameter_list|(
name|file
parameter_list|,
name|line
parameter_list|,
name|function
parameter_list|)
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|line
decl_stmt|;
specifier|const
name|char
modifier|*
name|function
decl_stmt|;
block|{
name|internal_error
argument_list|(
literal|"Internal compiler error in %s, at %s:%d"
argument_list|,
name|function
argument_list|,
name|trim_filename
argument_list|(
name|file
argument_list|)
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Setup DC for reporting a diagnostic MESSAGE (an error or a WARNING),    using arguments pointed to by ARGS_PTR, issued at a location specified    by FILE and LINE.  */
end_comment

begin_function
name|void
name|set_diagnostic_context
parameter_list|(
name|dc
parameter_list|,
name|msgid
parameter_list|,
name|args_ptr
parameter_list|,
name|file
parameter_list|,
name|line
parameter_list|,
name|warn
parameter_list|)
name|diagnostic_context
modifier|*
name|dc
decl_stmt|;
specifier|const
name|char
modifier|*
name|msgid
decl_stmt|;
name|va_list
modifier|*
name|args_ptr
decl_stmt|;
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|line
decl_stmt|;
name|int
name|warn
decl_stmt|;
block|{
name|memset
argument_list|(
name|dc
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|diagnostic_context
argument_list|)
argument_list|)
expr_stmt|;
name|diagnostic_message
argument_list|(
name|dc
argument_list|)
operator|=
name|_
argument_list|(
name|msgid
argument_list|)
expr_stmt|;
name|diagnostic_argument_list
argument_list|(
name|dc
argument_list|)
operator|=
name|args_ptr
expr_stmt|;
name|diagnostic_file_location
argument_list|(
name|dc
argument_list|)
operator|=
name|file
expr_stmt|;
name|diagnostic_line_location
argument_list|(
name|dc
argument_list|)
operator|=
name|line
expr_stmt|;
name|diagnostic_is_warning
argument_list|(
name|dc
argument_list|)
operator|=
name|warn
expr_stmt|;
name|diagnostic_starter
argument_list|(
name|dc
argument_list|)
operator|=
name|diagnostic_starter
argument_list|(
name|global_dc
argument_list|)
expr_stmt|;
name|diagnostic_finalizer
argument_list|(
name|dc
argument_list|)
operator|=
name|diagnostic_finalizer
argument_list|(
name|global_dc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|report_problematic_module
parameter_list|(
name|buffer
parameter_list|)
name|output_buffer
modifier|*
name|buffer
decl_stmt|;
block|{
name|struct
name|file_stack
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|output_needs_newline
argument_list|(
name|buffer
argument_list|)
condition|)
block|{
name|output_add_newline
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|output_needs_newline
argument_list|(
name|buffer
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|input_file_stack
operator|&&
name|input_file_stack
operator|->
name|next
operator|!=
literal|0
operator|&&
name|error_module_changed
argument_list|()
condition|)
block|{
for|for
control|(
name|p
operator|=
name|input_file_stack
operator|->
name|next
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
if|if
condition|(
name|p
operator|==
name|input_file_stack
operator|->
name|next
condition|)
name|output_verbatim
argument_list|(
name|buffer
argument_list|,
literal|"In file included from %s:%d"
argument_list|,
name|p
operator|->
name|name
argument_list|,
name|p
operator|->
name|line
argument_list|)
expr_stmt|;
else|else
name|output_verbatim
argument_list|(
name|buffer
argument_list|,
literal|",\n                 from %s:%d"
argument_list|,
name|p
operator|->
name|name
argument_list|,
name|p
operator|->
name|line
argument_list|)
expr_stmt|;
name|output_verbatim
argument_list|(
name|buffer
argument_list|,
literal|":\n"
argument_list|)
expr_stmt|;
name|record_last_error_module
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|default_diagnostic_starter
parameter_list|(
name|buffer
parameter_list|,
name|dc
parameter_list|)
name|output_buffer
modifier|*
name|buffer
decl_stmt|;
name|diagnostic_context
modifier|*
name|dc
decl_stmt|;
block|{
name|report_error_function
argument_list|(
name|diagnostic_file_location
argument_list|(
name|dc
argument_list|)
argument_list|)
expr_stmt|;
name|output_set_prefix
argument_list|(
name|buffer
argument_list|,
name|context_as_prefix
argument_list|(
name|diagnostic_file_location
argument_list|(
name|dc
argument_list|)
argument_list|,
name|diagnostic_line_location
argument_list|(
name|dc
argument_list|)
argument_list|,
name|diagnostic_is_warning
argument_list|(
name|dc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|default_diagnostic_finalizer
argument_list|(
name|buffer
argument_list|,
name|dc
argument_list|)
name|output_buffer
modifier|*
name|buffer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|diagnostic_context
modifier|*
name|dc
name|__attribute__
argument_list|(
operator|(
name|__unused__
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|output_destroy_prefix
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|void
name|warn_deprecated_use
parameter_list|(
name|node
parameter_list|)
name|tree
name|node
decl_stmt|;
block|{
if|if
condition|(
name|node
operator|==
literal|0
operator|||
operator|!
name|warn_deprecated_decl
condition|)
return|return;
if|if
condition|(
name|DECL_P
argument_list|(
name|node
argument_list|)
condition|)
name|warning
argument_list|(
literal|"`%s' is deprecated (declared at %s:%d)"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|node
argument_list|)
argument_list|)
argument_list|,
name|DECL_SOURCE_FILE
argument_list|(
name|node
argument_list|)
argument_list|,
name|DECL_SOURCE_LINE
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_P
argument_list|(
name|node
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|what
init|=
name|NULL
decl_stmt|;
name|tree
name|decl
init|=
name|TYPE_STUB_DECL
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|node
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
name|what
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|TYPE_NAME
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|node
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|node
argument_list|)
argument_list|)
condition|)
name|what
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|node
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|what
condition|)
block|{
if|if
condition|(
name|decl
condition|)
name|warning
argument_list|(
literal|"`%s' is deprecated (declared at %s:%d)"
argument_list|,
name|what
argument_list|,
name|DECL_SOURCE_FILE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|DECL_SOURCE_LINE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
literal|"`%s' is deprecated"
argument_list|,
name|what
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|decl
condition|)
name|warning
argument_list|(
literal|"type is deprecated (declared at %s:%d)"
argument_list|,
name|DECL_SOURCE_FILE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|DECL_SOURCE_LINE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
literal|"type is deprecated"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

