begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Language-independent diagnostic subroutines for the GNU Compiler Collection    Copyright (C) 1999, 2000, 2001, 2002 Free Software Foundation, Inc.    Contributed by Gabriel Dos Reis<gdr@codesourcery.com>  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* This file implements the language independent aspect of diagnostic    message module.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_undef
undef|#
directive|undef
name|FLOAT
end_undef

begin_comment
comment|/* This is for hpux. They should change hpux.  */
end_comment

begin_undef
undef|#
directive|undef
name|FFS
end_undef

begin_comment
comment|/* Some systems define this in param.h.  */
end_comment

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"input.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"intl.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_include
include|#
directive|include
file|"langhooks-def.h"
end_include

begin_define
define|#
directive|define
name|output_text_length
parameter_list|(
name|BUFFER
parameter_list|)
value|(BUFFER)->line_length
end_define

begin_define
define|#
directive|define
name|is_starting_newline
parameter_list|(
name|BUFFER
parameter_list|)
value|(output_text_length (BUFFER) == 0)
end_define

begin_define
define|#
directive|define
name|line_wrap_cutoff
parameter_list|(
name|BUFFER
parameter_list|)
value|(BUFFER)->state.maximum_length
end_define

begin_define
define|#
directive|define
name|prefix_was_emitted_for
parameter_list|(
name|BUFFER
parameter_list|)
value|(BUFFER)->state.emitted_prefix_p
end_define

begin_comment
comment|/* Prototypes.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|output_flush
name|PARAMS
argument_list|(
operator|(
name|output_buffer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_do_verbatim
name|PARAMS
argument_list|(
operator|(
name|output_buffer
operator|*
operator|,
name|text_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_buffer_to_stream
name|PARAMS
argument_list|(
operator|(
name|output_buffer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_format
name|PARAMS
argument_list|(
operator|(
name|output_buffer
operator|*
operator|,
name|text_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_indent
name|PARAMS
argument_list|(
operator|(
name|output_buffer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|vbuild_message_string
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|va_list
operator|)
argument_list|)
name|ATTRIBUTE_PRINTF
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|build_message_string
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
operator|...
operator|)
argument_list|)
name|ATTRIBUTE_PRINTF_1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|format_with_decl
name|PARAMS
argument_list|(
operator|(
name|output_buffer
operator|*
operator|,
name|text_info
operator|*
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|diagnostic_for_decl
name|PARAMS
argument_list|(
operator|(
name|diagnostic_info
operator|*
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_real_maximum_length
name|PARAMS
argument_list|(
operator|(
name|output_buffer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_unsigned_decimal
name|PARAMS
argument_list|(
operator|(
name|output_buffer
operator|*
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_long_decimal
name|PARAMS
argument_list|(
operator|(
name|output_buffer
operator|*
operator|,
name|long
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_long_unsigned_decimal
name|PARAMS
argument_list|(
operator|(
name|output_buffer
operator|*
operator|,
name|long
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_octal
name|PARAMS
argument_list|(
operator|(
name|output_buffer
operator|*
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_long_octal
name|PARAMS
argument_list|(
operator|(
name|output_buffer
operator|*
operator|,
name|unsigned
name|long
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_hexadecimal
name|PARAMS
argument_list|(
operator|(
name|output_buffer
operator|*
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_long_hexadecimal
name|PARAMS
argument_list|(
operator|(
name|output_buffer
operator|*
operator|,
name|unsigned
name|long
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_pointer
name|PARAMS
argument_list|(
operator|(
name|output_buffer
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_append_r
name|PARAMS
argument_list|(
operator|(
name|output_buffer
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|wrap_text
name|PARAMS
argument_list|(
operator|(
name|output_buffer
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|maybe_wrap_text
name|PARAMS
argument_list|(
operator|(
name|output_buffer
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_clear_data
name|PARAMS
argument_list|(
operator|(
name|output_buffer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|default_diagnostic_starter
name|PARAMS
argument_list|(
operator|(
name|diagnostic_context
operator|*
operator|,
name|diagnostic_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|default_diagnostic_finalizer
name|PARAMS
argument_list|(
operator|(
name|diagnostic_context
operator|*
operator|,
name|diagnostic_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|error_recursion
name|PARAMS
argument_list|(
operator|(
name|diagnostic_context
operator|*
operator|)
argument_list|)
name|ATTRIBUTE_NORETURN
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|text_specifies_location
name|PARAMS
argument_list|(
operator|(
name|text_info
operator|*
operator|,
name|location_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|rtl_dump_and_exit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|warnings_are_errors
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A diagnostic_context surrogate for stderr.  */
end_comment

begin_decl_stmt
specifier|static
name|diagnostic_context
name|global_diagnostic_context
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|diagnostic_context
modifier|*
name|global_dc
init|=
operator|&
name|global_diagnostic_context
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Subroutine of output_set_maximum_length.  Set up BUFFER's    internal maximum characters per line.  */
end_comment

begin_function
specifier|static
name|void
name|set_real_maximum_length
parameter_list|(
name|buffer
parameter_list|)
name|output_buffer
modifier|*
name|buffer
decl_stmt|;
block|{
comment|/* If we're told not to wrap lines then do the obvious thing.  In case    we'll emit prefix only once per diagnostic message, it is appropriate   not to increase unnecessarily the line-length cut-off.  */
if|if
condition|(
operator|!
name|output_is_line_wrapping
argument_list|(
name|buffer
argument_list|)
operator|||
name|output_prefixing_rule
argument_list|(
name|buffer
argument_list|)
operator|==
name|DIAGNOSTICS_SHOW_PREFIX_ONCE
operator|||
name|output_prefixing_rule
argument_list|(
name|buffer
argument_list|)
operator|==
name|DIAGNOSTICS_SHOW_PREFIX_NEVER
condition|)
name|line_wrap_cutoff
argument_list|(
name|buffer
argument_list|)
operator|=
name|output_line_cutoff
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|prefix_length
init|=
name|buffer
operator|->
name|state
operator|.
name|prefix
condition|?
name|strlen
argument_list|(
name|buffer
operator|->
name|state
operator|.
name|prefix
argument_list|)
else|:
literal|0
decl_stmt|;
comment|/* If the prefix is ridiculously too long, output at least          32 characters.  */
if|if
condition|(
name|output_line_cutoff
argument_list|(
name|buffer
argument_list|)
operator|-
name|prefix_length
operator|<
literal|32
condition|)
name|line_wrap_cutoff
argument_list|(
name|buffer
argument_list|)
operator|=
name|output_line_cutoff
argument_list|(
name|buffer
argument_list|)
operator|+
literal|32
expr_stmt|;
else|else
name|line_wrap_cutoff
argument_list|(
name|buffer
argument_list|)
operator|=
name|output_line_cutoff
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Sets the number of maximum characters per line BUFFER can output    in line-wrapping mode.  A LENGTH value 0 suppresses line-wrapping.  */
end_comment

begin_function
name|void
name|output_set_maximum_length
parameter_list|(
name|buffer
parameter_list|,
name|length
parameter_list|)
name|output_buffer
modifier|*
name|buffer
decl_stmt|;
name|int
name|length
decl_stmt|;
block|{
name|output_line_cutoff
argument_list|(
name|buffer
argument_list|)
operator|=
name|length
expr_stmt|;
name|set_real_maximum_length
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Sets BUFFER's PREFIX.  */
end_comment

begin_function
name|void
name|output_set_prefix
parameter_list|(
name|buffer
parameter_list|,
name|prefix
parameter_list|)
name|output_buffer
modifier|*
name|buffer
decl_stmt|;
specifier|const
name|char
modifier|*
name|prefix
decl_stmt|;
block|{
name|buffer
operator|->
name|state
operator|.
name|prefix
operator|=
name|prefix
expr_stmt|;
name|set_real_maximum_length
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|prefix_was_emitted_for
argument_list|(
name|buffer
argument_list|)
operator|=
name|false
expr_stmt|;
name|output_indentation
argument_list|(
name|buffer
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  Return a pointer to the last character emitted in the output     BUFFER area.  A NULL pointer means no character available.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|output_last_position
parameter_list|(
name|buffer
parameter_list|)
specifier|const
name|output_buffer
modifier|*
name|buffer
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|p
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|obstack_base
argument_list|(
operator|&
name|buffer
operator|->
name|obstack
argument_list|)
operator|!=
name|obstack_next_free
argument_list|(
operator|&
name|buffer
operator|->
name|obstack
argument_list|)
condition|)
name|p
operator|=
operator|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|obstack_next_free
argument_list|(
operator|&
name|buffer
operator|->
name|obstack
argument_list|)
operator|)
operator|-
literal|1
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* Free BUFFER's prefix, a previously malloc'd string.  */
end_comment

begin_function
name|void
name|output_destroy_prefix
parameter_list|(
name|buffer
parameter_list|)
name|output_buffer
modifier|*
name|buffer
decl_stmt|;
block|{
if|if
condition|(
name|buffer
operator|->
name|state
operator|.
name|prefix
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buffer
operator|->
name|state
operator|.
name|prefix
argument_list|)
expr_stmt|;
name|buffer
operator|->
name|state
operator|.
name|prefix
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Zero out any text output so far in BUFFER.  */
end_comment

begin_function
name|void
name|output_clear_message_text
parameter_list|(
name|buffer
parameter_list|)
name|output_buffer
modifier|*
name|buffer
decl_stmt|;
block|{
name|obstack_free
argument_list|(
operator|&
name|buffer
operator|->
name|obstack
argument_list|,
name|obstack_base
argument_list|(
operator|&
name|buffer
operator|->
name|obstack
argument_list|)
argument_list|)
expr_stmt|;
name|output_text_length
argument_list|(
name|buffer
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Zero out any formatting data used so far by BUFFER.  */
end_comment

begin_function
specifier|static
name|void
name|output_clear_data
parameter_list|(
name|buffer
parameter_list|)
name|output_buffer
modifier|*
name|buffer
decl_stmt|;
block|{
name|prefix_was_emitted_for
argument_list|(
name|buffer
argument_list|)
operator|=
name|false
expr_stmt|;
name|output_indentation
argument_list|(
name|buffer
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Construct an output BUFFER with PREFIX and of MAXIMUM_LENGTH    characters per line.  */
end_comment

begin_function
name|void
name|init_output_buffer
parameter_list|(
name|buffer
parameter_list|,
name|prefix
parameter_list|,
name|maximum_length
parameter_list|)
name|output_buffer
modifier|*
name|buffer
decl_stmt|;
specifier|const
name|char
modifier|*
name|prefix
decl_stmt|;
name|int
name|maximum_length
decl_stmt|;
block|{
name|memset
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|output_buffer
argument_list|)
argument_list|)
expr_stmt|;
name|obstack_init
argument_list|(
operator|&
name|buffer
operator|->
name|obstack
argument_list|)
expr_stmt|;
name|output_buffer_attached_stream
argument_list|(
name|buffer
argument_list|)
operator|=
name|stderr
expr_stmt|;
name|output_line_cutoff
argument_list|(
name|buffer
argument_list|)
operator|=
name|maximum_length
expr_stmt|;
name|output_prefixing_rule
argument_list|(
name|buffer
argument_list|)
operator|=
name|diagnostic_prefixing_rule
argument_list|(
name|global_dc
argument_list|)
expr_stmt|;
name|output_set_prefix
argument_list|(
name|buffer
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
name|output_text_length
argument_list|(
name|buffer
argument_list|)
operator|=
literal|0
expr_stmt|;
name|output_clear_data
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Reinitialize BUFFER.  */
end_comment

begin_function
name|void
name|output_clear
parameter_list|(
name|buffer
parameter_list|)
name|output_buffer
modifier|*
name|buffer
decl_stmt|;
block|{
name|output_clear_message_text
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|output_clear_data
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finishes constructing a NULL-terminated character string representing    the BUFFERed message.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|output_finalize_message
parameter_list|(
name|buffer
parameter_list|)
name|output_buffer
modifier|*
name|buffer
decl_stmt|;
block|{
name|obstack_1grow
argument_list|(
operator|&
name|buffer
operator|->
name|obstack
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
return|return
name|output_message_text
argument_list|(
name|buffer
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the amount of characters BUFFER can accept to    make a full line.  */
end_comment

begin_function
name|int
name|output_space_left
parameter_list|(
name|buffer
parameter_list|)
specifier|const
name|output_buffer
modifier|*
name|buffer
decl_stmt|;
block|{
return|return
name|line_wrap_cutoff
argument_list|(
name|buffer
argument_list|)
operator|-
name|output_text_length
argument_list|(
name|buffer
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Write out BUFFER's prefix.  */
end_comment

begin_function
name|void
name|output_emit_prefix
parameter_list|(
name|buffer
parameter_list|)
name|output_buffer
modifier|*
name|buffer
decl_stmt|;
block|{
if|if
condition|(
name|buffer
operator|->
name|state
operator|.
name|prefix
operator|!=
name|NULL
condition|)
block|{
switch|switch
condition|(
name|output_prefixing_rule
argument_list|(
name|buffer
argument_list|)
condition|)
block|{
default|default:
case|case
name|DIAGNOSTICS_SHOW_PREFIX_NEVER
case|:
break|break;
case|case
name|DIAGNOSTICS_SHOW_PREFIX_ONCE
case|:
if|if
condition|(
name|prefix_was_emitted_for
argument_list|(
name|buffer
argument_list|)
condition|)
block|{
name|output_indent
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
break|break;
block|}
name|output_indentation
argument_list|(
name|buffer
argument_list|)
operator|+=
literal|3
expr_stmt|;
comment|/* Fall through.  */
case|case
name|DIAGNOSTICS_SHOW_PREFIX_EVERY_LINE
case|:
block|{
name|int
name|prefix_length
init|=
name|strlen
argument_list|(
name|buffer
operator|->
name|state
operator|.
name|prefix
argument_list|)
decl_stmt|;
name|output_append_r
argument_list|(
name|buffer
argument_list|,
name|buffer
operator|->
name|state
operator|.
name|prefix
argument_list|,
name|prefix_length
argument_list|)
expr_stmt|;
name|prefix_was_emitted_for
argument_list|(
name|buffer
argument_list|)
operator|=
name|true
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Have BUFFER start a new line.  */
end_comment

begin_function
name|void
name|output_add_newline
parameter_list|(
name|buffer
parameter_list|)
name|output_buffer
modifier|*
name|buffer
decl_stmt|;
block|{
name|obstack_1grow
argument_list|(
operator|&
name|buffer
operator|->
name|obstack
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
name|output_text_length
argument_list|(
name|buffer
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Appends a character to BUFFER.  */
end_comment

begin_function
name|void
name|output_add_character
parameter_list|(
name|buffer
parameter_list|,
name|c
parameter_list|)
name|output_buffer
modifier|*
name|buffer
decl_stmt|;
name|int
name|c
decl_stmt|;
block|{
if|if
condition|(
name|output_is_line_wrapping
argument_list|(
name|buffer
argument_list|)
operator|&&
name|output_space_left
argument_list|(
name|buffer
argument_list|)
operator|<=
literal|0
condition|)
name|output_add_newline
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|obstack_1grow
argument_list|(
operator|&
name|buffer
operator|->
name|obstack
argument_list|,
name|c
argument_list|)
expr_stmt|;
operator|++
name|output_text_length
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Adds a space to BUFFER.  */
end_comment

begin_function
name|void
name|output_add_space
parameter_list|(
name|buffer
parameter_list|)
name|output_buffer
modifier|*
name|buffer
decl_stmt|;
block|{
if|if
condition|(
name|output_is_line_wrapping
argument_list|(
name|buffer
argument_list|)
operator|&&
name|output_space_left
argument_list|(
name|buffer
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|output_add_newline
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
return|return;
block|}
name|obstack_1grow
argument_list|(
operator|&
name|buffer
operator|->
name|obstack
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
operator|++
name|output_text_length
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* These functions format an INTEGER into BUFFER as suggested by their    names.  */
end_comment

begin_function
name|void
name|output_decimal
parameter_list|(
name|buffer
parameter_list|,
name|i
parameter_list|)
name|output_buffer
modifier|*
name|buffer
decl_stmt|;
name|int
name|i
decl_stmt|;
block|{
name|output_formatted_scalar
argument_list|(
name|buffer
argument_list|,
literal|"%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_long_decimal
parameter_list|(
name|buffer
parameter_list|,
name|i
parameter_list|)
name|output_buffer
modifier|*
name|buffer
decl_stmt|;
name|long
name|int
name|i
decl_stmt|;
block|{
name|output_formatted_scalar
argument_list|(
name|buffer
argument_list|,
literal|"%ld"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_unsigned_decimal
parameter_list|(
name|buffer
parameter_list|,
name|i
parameter_list|)
name|output_buffer
modifier|*
name|buffer
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
block|{
name|output_formatted_scalar
argument_list|(
name|buffer
argument_list|,
literal|"%u"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_long_unsigned_decimal
parameter_list|(
name|buffer
parameter_list|,
name|i
parameter_list|)
name|output_buffer
modifier|*
name|buffer
decl_stmt|;
name|long
name|unsigned
name|int
name|i
decl_stmt|;
block|{
name|output_formatted_scalar
argument_list|(
name|buffer
argument_list|,
literal|"%lu"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_octal
parameter_list|(
name|buffer
parameter_list|,
name|i
parameter_list|)
name|output_buffer
modifier|*
name|buffer
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
block|{
name|output_formatted_scalar
argument_list|(
name|buffer
argument_list|,
literal|"%o"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_long_octal
parameter_list|(
name|buffer
parameter_list|,
name|i
parameter_list|)
name|output_buffer
modifier|*
name|buffer
decl_stmt|;
name|unsigned
name|long
name|int
name|i
decl_stmt|;
block|{
name|output_formatted_scalar
argument_list|(
name|buffer
argument_list|,
literal|"%lo"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_hexadecimal
parameter_list|(
name|buffer
parameter_list|,
name|i
parameter_list|)
name|output_buffer
modifier|*
name|buffer
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
block|{
name|output_formatted_scalar
argument_list|(
name|buffer
argument_list|,
literal|"%x"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_long_hexadecimal
parameter_list|(
name|buffer
parameter_list|,
name|i
parameter_list|)
name|output_buffer
modifier|*
name|buffer
decl_stmt|;
name|unsigned
name|long
name|int
name|i
decl_stmt|;
block|{
name|output_formatted_scalar
argument_list|(
name|buffer
argument_list|,
literal|"%lx"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_pointer
parameter_list|(
name|buffer
parameter_list|,
name|p
parameter_list|)
name|output_buffer
modifier|*
name|buffer
decl_stmt|;
name|void
modifier|*
name|p
decl_stmt|;
block|{
name|output_formatted_scalar
argument_list|(
name|buffer
argument_list|,
name|HOST_PTR_PRINTF
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Append to BUFFER a string specified by its STARTING character    and LENGTH.  */
end_comment

begin_function
specifier|static
name|void
name|output_append_r
parameter_list|(
name|buffer
parameter_list|,
name|start
parameter_list|,
name|length
parameter_list|)
name|output_buffer
modifier|*
name|buffer
decl_stmt|;
specifier|const
name|char
modifier|*
name|start
decl_stmt|;
name|int
name|length
decl_stmt|;
block|{
name|obstack_grow
argument_list|(
operator|&
name|buffer
operator|->
name|obstack
argument_list|,
name|start
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|output_text_length
argument_list|(
name|buffer
argument_list|)
operator|+=
name|length
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Append a string deliminated by START and END to BUFFER.  No wrapping is    done.  However, if beginning a new line then emit BUFFER->state.prefix    and skip any leading whitespace if appropriate.  The caller must ensure    that it is safe to do so.  */
end_comment

begin_function
name|void
name|output_append
parameter_list|(
name|buffer
parameter_list|,
name|start
parameter_list|,
name|end
parameter_list|)
name|output_buffer
modifier|*
name|buffer
decl_stmt|;
specifier|const
name|char
modifier|*
name|start
decl_stmt|;
specifier|const
name|char
modifier|*
name|end
decl_stmt|;
block|{
comment|/* Emit prefix and skip whitespace if we're starting a new line.  */
if|if
condition|(
name|is_starting_newline
argument_list|(
name|buffer
argument_list|)
condition|)
block|{
name|output_emit_prefix
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|output_is_line_wrapping
argument_list|(
name|buffer
argument_list|)
condition|)
while|while
condition|(
name|start
operator|!=
name|end
operator|&&
operator|*
name|start
operator|==
literal|' '
condition|)
operator|++
name|start
expr_stmt|;
block|}
name|output_append_r
argument_list|(
name|buffer
argument_list|,
name|start
argument_list|,
name|end
operator|-
name|start
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_indent
parameter_list|(
name|buffer
parameter_list|)
name|output_buffer
modifier|*
name|buffer
decl_stmt|;
block|{
name|int
name|n
init|=
name|output_indentation
argument_list|(
name|buffer
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
name|output_add_character
argument_list|(
name|buffer
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Wrap a text delimited by START and END into BUFFER.  */
end_comment

begin_function
specifier|static
name|void
name|wrap_text
parameter_list|(
name|buffer
parameter_list|,
name|start
parameter_list|,
name|end
parameter_list|)
name|output_buffer
modifier|*
name|buffer
decl_stmt|;
specifier|const
name|char
modifier|*
name|start
decl_stmt|;
specifier|const
name|char
modifier|*
name|end
decl_stmt|;
block|{
name|bool
name|is_wrapping
init|=
name|output_is_line_wrapping
argument_list|(
name|buffer
argument_list|)
decl_stmt|;
while|while
condition|(
name|start
operator|!=
name|end
condition|)
block|{
comment|/* Dump anything bordered by whitespaces.  */
block|{
specifier|const
name|char
modifier|*
name|p
init|=
name|start
decl_stmt|;
while|while
condition|(
name|p
operator|!=
name|end
operator|&&
operator|*
name|p
operator|!=
literal|' '
operator|&&
operator|*
name|p
operator|!=
literal|'\n'
condition|)
operator|++
name|p
expr_stmt|;
if|if
condition|(
name|is_wrapping
operator|&&
name|p
operator|-
name|start
operator|>=
name|output_space_left
argument_list|(
name|buffer
argument_list|)
condition|)
name|output_add_newline
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|output_append
argument_list|(
name|buffer
argument_list|,
name|start
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|start
operator|=
name|p
expr_stmt|;
block|}
if|if
condition|(
name|start
operator|!=
name|end
operator|&&
operator|*
name|start
operator|==
literal|' '
condition|)
block|{
name|output_add_space
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
operator|++
name|start
expr_stmt|;
block|}
if|if
condition|(
name|start
operator|!=
name|end
operator|&&
operator|*
name|start
operator|==
literal|'\n'
condition|)
block|{
name|output_add_newline
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
operator|++
name|start
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Same as wrap_text but wrap text only when in line-wrapping mode.  */
end_comment

begin_function
specifier|static
name|void
name|maybe_wrap_text
parameter_list|(
name|buffer
parameter_list|,
name|start
parameter_list|,
name|end
parameter_list|)
name|output_buffer
modifier|*
name|buffer
decl_stmt|;
specifier|const
name|char
modifier|*
name|start
decl_stmt|;
specifier|const
name|char
modifier|*
name|end
decl_stmt|;
block|{
if|if
condition|(
name|output_is_line_wrapping
argument_list|(
name|buffer
argument_list|)
condition|)
name|wrap_text
argument_list|(
name|buffer
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
else|else
name|output_append
argument_list|(
name|buffer
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Append a STRING to BUFFER; the STRING might be line-wrapped if in    appropriate mode.  */
end_comment

begin_function
name|void
name|output_add_string
parameter_list|(
name|buffer
parameter_list|,
name|str
parameter_list|)
name|output_buffer
modifier|*
name|buffer
decl_stmt|;
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|maybe_wrap_text
argument_list|(
name|buffer
argument_list|,
name|str
argument_list|,
name|str
operator|+
operator|(
name|str
condition|?
name|strlen
argument_list|(
name|str
argument_list|)
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Append an identifier ID to BUFFER.  */
end_comment

begin_function
name|void
name|output_add_identifier
parameter_list|(
name|buffer
parameter_list|,
name|id
parameter_list|)
name|output_buffer
modifier|*
name|buffer
decl_stmt|;
name|tree
name|id
decl_stmt|;
block|{
name|output_append
argument_list|(
name|buffer
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|id
argument_list|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|id
argument_list|)
operator|+
name|IDENTIFIER_LENGTH
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Flush the content of BUFFER onto the attached stream,    and reinitialize.  */
end_comment

begin_function
specifier|static
name|void
name|output_buffer_to_stream
parameter_list|(
name|buffer
parameter_list|)
name|output_buffer
modifier|*
name|buffer
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|text
init|=
name|output_finalize_message
argument_list|(
name|buffer
argument_list|)
decl_stmt|;
name|fputs
argument_list|(
name|text
argument_list|,
name|output_buffer_attached_stream
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
name|output_clear_message_text
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Format a message pointed to by TEXT.  The following format specifiers are    recognized as being language independent:    %d, %i: (signed) integer in base ten.    %u: unsigned integer in base ten.    %o: unsigned integer in base eight.    %x: unsigned integer in base sixteen.    %ld, %li, %lo, %lu, %lx: long versions of the above.    %c: character.    %s: string.    %p: pointer.    %%: `%'.    %*.s: a substring the length of which is specified by an integer.    %H: location_t.  */
end_comment

begin_function
specifier|static
name|void
name|output_format
parameter_list|(
name|buffer
parameter_list|,
name|text
parameter_list|)
name|output_buffer
modifier|*
name|buffer
decl_stmt|;
name|text_info
modifier|*
name|text
decl_stmt|;
block|{
for|for
control|(
init|;
operator|*
name|text
operator|->
name|format_spec
condition|;
operator|++
name|text
operator|->
name|format_spec
control|)
block|{
name|bool
name|long_integer
init|=
literal|0
decl_stmt|;
comment|/* Ignore text.  */
block|{
specifier|const
name|char
modifier|*
name|p
init|=
name|text
operator|->
name|format_spec
decl_stmt|;
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|'%'
condition|)
operator|++
name|p
expr_stmt|;
name|wrap_text
argument_list|(
name|buffer
argument_list|,
name|text
operator|->
name|format_spec
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|text
operator|->
name|format_spec
operator|=
name|p
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|text
operator|->
name|format_spec
operator|==
literal|'\0'
condition|)
break|break;
comment|/* We got a '%'.  Let's see what happens. Record whether we're          parsing a long integer format specifier.  */
if|if
condition|(
operator|*
operator|++
name|text
operator|->
name|format_spec
operator|==
literal|'l'
condition|)
block|{
name|long_integer
operator|=
name|true
expr_stmt|;
operator|++
name|text
operator|->
name|format_spec
expr_stmt|;
block|}
comment|/* Handle %c, %d, %i, %ld, %li, %lo, %lu, %lx, %o, %s, %u,          %x, %.*s; %%.  And nothing else.  Front-ends should install          printers to grok language specific format specifiers.  */
switch|switch
condition|(
operator|*
name|text
operator|->
name|format_spec
condition|)
block|{
case|case
literal|'c'
case|:
name|output_add_character
argument_list|(
name|buffer
argument_list|,
name|va_arg
argument_list|(
operator|*
name|text
operator|->
name|args_ptr
argument_list|,
name|int
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
case|case
literal|'i'
case|:
if|if
condition|(
name|long_integer
condition|)
name|output_long_decimal
argument_list|(
name|buffer
argument_list|,
name|va_arg
argument_list|(
argument|*text->args_ptr
argument_list|,
argument|long int
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|output_decimal
argument_list|(
name|buffer
argument_list|,
name|va_arg
argument_list|(
operator|*
name|text
operator|->
name|args_ptr
argument_list|,
name|int
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
if|if
condition|(
name|long_integer
condition|)
name|output_long_octal
argument_list|(
name|buffer
argument_list|,
name|va_arg
argument_list|(
argument|*text->args_ptr
argument_list|,
argument|unsigned long int
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|output_octal
argument_list|(
name|buffer
argument_list|,
name|va_arg
argument_list|(
argument|*text->args_ptr
argument_list|,
argument|unsigned int
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|output_add_string
argument_list|(
name|buffer
argument_list|,
name|va_arg
argument_list|(
operator|*
name|text
operator|->
name|args_ptr
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|output_pointer
argument_list|(
name|buffer
argument_list|,
name|va_arg
argument_list|(
operator|*
name|text
operator|->
name|args_ptr
argument_list|,
name|void
operator|*
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
if|if
condition|(
name|long_integer
condition|)
name|output_long_unsigned_decimal
argument_list|(
name|buffer
argument_list|,
name|va_arg
argument_list|(
argument|*text->args_ptr
argument_list|,
argument|long unsigned int
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|output_unsigned_decimal
argument_list|(
name|buffer
argument_list|,
name|va_arg
argument_list|(
argument|*text->args_ptr
argument_list|,
argument|unsigned int
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
if|if
condition|(
name|long_integer
condition|)
name|output_long_hexadecimal
argument_list|(
name|buffer
argument_list|,
name|va_arg
argument_list|(
argument|*text->args_ptr
argument_list|,
argument|unsigned long int
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|output_hexadecimal
argument_list|(
name|buffer
argument_list|,
name|va_arg
argument_list|(
argument|*text->args_ptr
argument_list|,
argument|unsigned int
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'%'
case|:
name|output_add_character
argument_list|(
name|buffer
argument_list|,
literal|'%'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
block|{
specifier|const
name|location_t
modifier|*
name|locus
init|=
name|va_arg
argument_list|(
operator|*
name|text
operator|->
name|args_ptr
argument_list|,
name|location_t
operator|*
argument_list|)
decl_stmt|;
name|output_add_string
argument_list|(
name|buffer
argument_list|,
literal|"file '"
argument_list|)
expr_stmt|;
name|output_add_string
argument_list|(
name|buffer
argument_list|,
name|locus
operator|->
name|file
argument_list|)
expr_stmt|;
name|output_add_string
argument_list|(
name|buffer
argument_list|,
literal|"', line "
argument_list|)
expr_stmt|;
name|output_decimal
argument_list|(
name|buffer
argument_list|,
name|locus
operator|->
name|line
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'.'
case|:
block|{
name|int
name|n
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
comment|/* We handle no precision specifier but `%.*s'.  */
if|if
condition|(
operator|*
operator|++
name|text
operator|->
name|format_spec
operator|!=
literal|'*'
condition|)
name|abort
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
operator|++
name|text
operator|->
name|format_spec
operator|!=
literal|'s'
condition|)
name|abort
argument_list|()
expr_stmt|;
name|n
operator|=
name|va_arg
argument_list|(
operator|*
name|text
operator|->
name|args_ptr
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|s
operator|=
name|va_arg
argument_list|(
operator|*
name|text
operator|->
name|args_ptr
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
name|output_append
argument_list|(
name|buffer
argument_list|,
name|s
argument_list|,
name|s
operator|+
name|n
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
if|if
condition|(
operator|!
name|buffer
operator|->
name|format_decoder
operator|||
operator|!
call|(
modifier|*
name|buffer
operator|->
name|format_decoder
call|)
argument_list|(
name|buffer
argument_list|,
name|text
argument_list|)
condition|)
block|{
comment|/* Hmmm.  The front-end failed to install a format translator                  but called us with an unrecognized format.  Sorry.  */
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|vbuild_message_string
parameter_list|(
name|msg
parameter_list|,
name|ap
parameter_list|)
specifier|const
name|char
modifier|*
name|msg
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
block|{
name|char
modifier|*
name|str
decl_stmt|;
name|vasprintf
argument_list|(
operator|&
name|str
argument_list|,
name|msg
argument_list|,
name|ap
argument_list|)
expr_stmt|;
return|return
name|str
return|;
block|}
end_function

begin_comment
comment|/*  Return a malloc'd string containing MSG formatted a la     printf.  The caller is responsible for freeing the memory.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|build_message_string
name|VPARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|msg
operator|,
operator|...
operator|)
argument_list|)
block|{
name|char
modifier|*
name|str
decl_stmt|;
name|VA_OPEN
argument_list|(
name|ap
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|str
operator|=
name|vbuild_message_string
argument_list|(
name|msg
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|VA_CLOSE
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
name|str
return|;
block|}
end_decl_stmt

begin_comment
comment|/* Same as diagnsotic_build_prefix, but only the source FILE is given.  */
end_comment

begin_function
name|char
modifier|*
name|file_name_as_prefix
parameter_list|(
name|f
parameter_list|)
specifier|const
name|char
modifier|*
name|f
decl_stmt|;
block|{
return|return
name|build_message_string
argument_list|(
literal|"%s: "
argument_list|,
name|f
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Format a message into BUFFER a la printf.  */
end_comment

begin_decl_stmt
name|void
name|output_printf
name|VPARAMS
argument_list|(
operator|(
expr|struct
name|output_buffer
operator|*
name|buffer
operator|,
specifier|const
name|char
operator|*
name|msgid
operator|,
operator|...
operator|)
argument_list|)
block|{
name|text_info
name|text
decl_stmt|;
name|VA_OPEN
argument_list|(
name|ap
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
name|output_buffer
operator|*
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|text
operator|.
name|args_ptr
operator|=
operator|&
name|ap
expr_stmt|;
name|text
operator|.
name|format_spec
operator|=
name|_
argument_list|(
name|msgid
argument_list|)
expr_stmt|;
name|output_format
argument_list|(
name|buffer
argument_list|,
operator|&
name|text
argument_list|)
expr_stmt|;
name|VA_CLOSE
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* Print a message relevant to the given DECL.  */
end_comment

begin_function
specifier|static
name|void
name|format_with_decl
parameter_list|(
name|buffer
parameter_list|,
name|text
parameter_list|,
name|decl
parameter_list|)
name|output_buffer
modifier|*
name|buffer
decl_stmt|;
name|text_info
modifier|*
name|text
decl_stmt|;
name|tree
name|decl
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
comment|/* Do magic to get around lack of varargs support for insertion      of arguments into existing list.  We know that the decl is first;      we ass_u_me that it will be printed with "%s".  */
for|for
control|(
name|p
operator|=
name|text
operator|->
name|format_spec
init|;
operator|*
name|p
condition|;
operator|++
name|p
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'%'
condition|)
block|{
if|if
condition|(
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
operator|==
literal|'%'
condition|)
operator|++
name|p
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
operator|!=
literal|'s'
condition|)
name|abort
argument_list|()
expr_stmt|;
else|else
break|break;
block|}
block|}
comment|/* Print the left-hand substring.  */
name|maybe_wrap_text
argument_list|(
name|buffer
argument_list|,
name|text
operator|->
name|format_spec
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'%'
condition|)
comment|/* Print the name.  */
block|{
specifier|const
name|char
modifier|*
specifier|const
name|n
init|=
operator|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
condition|?
call|(
modifier|*
name|lang_hooks
operator|.
name|decl_printable_name
call|)
argument_list|(
name|decl
argument_list|,
literal|2
argument_list|)
else|:
name|_
argument_list|(
literal|"((anonymous))"
argument_list|)
operator|)
decl_stmt|;
name|output_add_string
argument_list|(
name|buffer
argument_list|,
name|n
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
block|{
operator|++
name|p
expr_stmt|;
if|if
condition|(
name|ISALPHA
argument_list|(
operator|*
operator|(
name|p
operator|-
literal|1
operator|)
operator|&
literal|0xFF
argument_list|)
condition|)
break|break;
block|}
block|}
if|if
condition|(
operator|*
name|p
condition|)
comment|/* Print the rest of the message.  */
block|{
name|text
operator|->
name|format_spec
operator|=
name|p
expr_stmt|;
name|output_format
argument_list|(
name|buffer
argument_list|,
name|text
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Flush the content of BUFFER onto the attached stream.  */
end_comment

begin_function
specifier|static
name|void
name|output_flush
parameter_list|(
name|buffer
parameter_list|)
name|output_buffer
modifier|*
name|buffer
decl_stmt|;
block|{
name|output_buffer_to_stream
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|output_clear_data
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|output_buffer_attached_stream
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|output_buffer_attached_stream
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Helper subroutine of output_verbatim and verbatim. Do the appropriate    settings needed by BUFFER for a verbatim formatting.  */
end_comment

begin_function
specifier|static
name|void
name|output_do_verbatim
parameter_list|(
name|buffer
parameter_list|,
name|text
parameter_list|)
name|output_buffer
modifier|*
name|buffer
decl_stmt|;
name|text_info
modifier|*
name|text
decl_stmt|;
block|{
name|diagnostic_prefixing_rule_t
name|rule
init|=
name|output_prefixing_rule
argument_list|(
name|buffer
argument_list|)
decl_stmt|;
name|int
name|line_cutoff
init|=
name|output_line_cutoff
argument_list|(
name|buffer
argument_list|)
decl_stmt|;
comment|/* Set verbatim mode.  */
name|output_prefixing_rule
argument_list|(
name|buffer
argument_list|)
operator|=
name|DIAGNOSTICS_SHOW_PREFIX_NEVER
expr_stmt|;
name|output_line_cutoff
argument_list|(
name|buffer
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Do the actual formatting.  */
name|output_format
argument_list|(
name|buffer
argument_list|,
name|text
argument_list|)
expr_stmt|;
comment|/* Restore previous settings.  */
name|output_prefixing_rule
argument_list|(
name|buffer
argument_list|)
operator|=
name|rule
expr_stmt|;
name|output_line_cutoff
argument_list|(
name|buffer
argument_list|)
operator|=
name|line_cutoff
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output MESSAGE verbatim into BUFFER.  */
end_comment

begin_decl_stmt
name|void
name|output_verbatim
name|VPARAMS
argument_list|(
operator|(
name|output_buffer
operator|*
name|buffer
operator|,
specifier|const
name|char
operator|*
name|msgid
operator|,
operator|...
operator|)
argument_list|)
block|{
name|text_info
name|text
decl_stmt|;
name|VA_OPEN
argument_list|(
name|ap
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
name|output_buffer
operator|*
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|text
operator|.
name|format_spec
operator|=
name|msgid
expr_stmt|;
name|text
operator|.
name|args_ptr
operator|=
operator|&
name|ap
expr_stmt|;
name|output_do_verbatim
argument_list|(
name|buffer
argument_list|,
operator|&
name|text
argument_list|)
expr_stmt|;
name|VA_CLOSE
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Initialize the diagnostic message outputting machinery.  */
end_comment

begin_function
name|void
name|diagnostic_initialize
parameter_list|(
name|context
parameter_list|)
name|diagnostic_context
modifier|*
name|context
decl_stmt|;
block|{
name|memset
argument_list|(
name|context
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|context
argument_list|)
expr_stmt|;
name|obstack_init
argument_list|(
operator|&
name|context
operator|->
name|buffer
operator|.
name|obstack
argument_list|)
expr_stmt|;
comment|/* By default, diagnostics are sent to stderr.  */
name|output_buffer_attached_stream
argument_list|(
operator|&
name|context
operator|->
name|buffer
argument_list|)
operator|=
name|stderr
expr_stmt|;
comment|/* By default, we emit prefixes once per message.  */
name|diagnostic_prefixing_rule
argument_list|(
name|context
argument_list|)
operator|=
name|DIAGNOSTICS_SHOW_PREFIX_ONCE
expr_stmt|;
name|diagnostic_starter
argument_list|(
name|context
argument_list|)
operator|=
name|default_diagnostic_starter
expr_stmt|;
name|diagnostic_finalizer
argument_list|(
name|context
argument_list|)
operator|=
name|default_diagnostic_finalizer
expr_stmt|;
name|context
operator|->
name|warnings_are_errors_message
operator|=
name|warnings_are_errors
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns true if the next format specifier in TEXT is a format specifier    for a location_t.  If so, update the object pointed by LOCUS to reflect    the specified location in *TEXT->args_ptr.  */
end_comment

begin_function
specifier|static
name|bool
name|text_specifies_location
parameter_list|(
name|text
parameter_list|,
name|locus
parameter_list|)
name|text_info
modifier|*
name|text
decl_stmt|;
name|location_t
modifier|*
name|locus
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
comment|/* Skip any leading text.  */
for|for
control|(
name|p
operator|=
name|text
operator|->
name|format_spec
init|;
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|'%'
condition|;
operator|++
name|p
control|)
empty_stmt|;
comment|/* Extract the location information if any.  */
if|if
condition|(
operator|*
name|p
operator|==
literal|'%'
operator|&&
operator|*
operator|++
name|p
operator|==
literal|'H'
condition|)
block|{
operator|*
name|locus
operator|=
operator|*
name|va_arg
argument_list|(
operator|*
name|text
operator|->
name|args_ptr
argument_list|,
name|location_t
operator|*
argument_list|)
expr_stmt|;
name|text
operator|->
name|format_spec
operator|=
name|p
operator|+
literal|1
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_function
name|void
name|diagnostic_set_info
parameter_list|(
name|diagnostic
parameter_list|,
name|msgid
parameter_list|,
name|args
parameter_list|,
name|file
parameter_list|,
name|line
parameter_list|,
name|kind
parameter_list|)
name|diagnostic_info
modifier|*
name|diagnostic
decl_stmt|;
specifier|const
name|char
modifier|*
name|msgid
decl_stmt|;
name|va_list
modifier|*
name|args
decl_stmt|;
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|line
decl_stmt|;
name|diagnostic_t
name|kind
decl_stmt|;
block|{
name|diagnostic
operator|->
name|message
operator|.
name|format_spec
operator|=
name|msgid
expr_stmt|;
name|diagnostic
operator|->
name|message
operator|.
name|args_ptr
operator|=
name|args
expr_stmt|;
comment|/* If the diagnostic message doesn't specify a loccation,      use FILE and LINE.  */
if|if
condition|(
operator|!
name|text_specifies_location
argument_list|(
operator|&
name|diagnostic
operator|->
name|message
argument_list|,
operator|&
name|diagnostic
operator|->
name|location
argument_list|)
condition|)
block|{
name|diagnostic
operator|->
name|location
operator|.
name|file
operator|=
name|file
expr_stmt|;
name|diagnostic
operator|->
name|location
operator|.
name|line
operator|=
name|line
expr_stmt|;
block|}
name|diagnostic
operator|->
name|kind
operator|=
name|kind
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return a malloc'd string describing a location.  The caller is    responsible for freeing the memory.  */
end_comment

begin_function
name|char
modifier|*
name|diagnostic_build_prefix
parameter_list|(
name|diagnostic
parameter_list|)
name|diagnostic_info
modifier|*
name|diagnostic
decl_stmt|;
block|{
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|diagnostic_kind_text
index|[]
init|=
block|{
define|#
directive|define
name|DEFINE_DIAGNOSTIC_KIND
parameter_list|(
name|K
parameter_list|,
name|T
parameter_list|)
value|(T),
include|#
directive|include
file|"diagnostic.def"
undef|#
directive|undef
name|DEFINE_DIAGNOSTIC_KIND
literal|"must-not-happen"
block|}
decl_stmt|;
if|if
condition|(
name|diagnostic
operator|->
name|kind
operator|>=
name|DK_LAST_DIAGNOSTIC_KIND
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|diagnostic
operator|->
name|location
operator|.
name|file
condition|?
name|build_message_string
argument_list|(
literal|"%s:%d: %s"
argument_list|,
name|diagnostic
operator|->
name|location
operator|.
name|file
argument_list|,
name|diagnostic
operator|->
name|location
operator|.
name|line
argument_list|,
name|_
argument_list|(
name|diagnostic_kind_text
index|[
name|diagnostic
operator|->
name|kind
index|]
argument_list|)
argument_list|)
else|:
name|build_message_string
argument_list|(
literal|"%s: %s"
argument_list|,
name|progname
argument_list|,
name|_
argument_list|(
name|diagnostic_kind_text
index|[
name|diagnostic
operator|->
name|kind
index|]
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Report a diagnostic MESSAGE at the declaration DECL.    MSG is a format string which uses %s to substitute the declaration    name; subsequent substitutions are a la output_format.  */
end_comment

begin_function
specifier|static
name|void
name|diagnostic_for_decl
parameter_list|(
name|diagnostic
parameter_list|,
name|decl
parameter_list|)
name|diagnostic_info
modifier|*
name|diagnostic
decl_stmt|;
name|tree
name|decl
decl_stmt|;
block|{
if|if
condition|(
name|global_dc
operator|->
name|lock
operator|++
condition|)
name|error_recursion
argument_list|(
name|global_dc
argument_list|)
expr_stmt|;
if|if
condition|(
name|diagnostic_count_diagnostic
argument_list|(
name|global_dc
argument_list|,
name|diagnostic
operator|->
name|kind
argument_list|)
condition|)
block|{
name|diagnostic_report_current_function
argument_list|(
name|global_dc
argument_list|)
expr_stmt|;
name|output_set_prefix
argument_list|(
operator|&
name|global_dc
operator|->
name|buffer
argument_list|,
name|diagnostic_build_prefix
argument_list|(
name|diagnostic
argument_list|)
argument_list|)
expr_stmt|;
name|format_with_decl
argument_list|(
operator|&
name|global_dc
operator|->
name|buffer
argument_list|,
operator|&
name|diagnostic
operator|->
name|message
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|output_flush
argument_list|(
operator|&
name|global_dc
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|output_destroy_prefix
argument_list|(
operator|&
name|global_dc
operator|->
name|buffer
argument_list|)
expr_stmt|;
block|}
name|global_dc
operator|->
name|lock
operator|--
expr_stmt|;
block|}
end_function

begin_function
name|void
name|diagnostic_flush_buffer
parameter_list|(
name|context
parameter_list|)
name|diagnostic_context
modifier|*
name|context
decl_stmt|;
block|{
name|output_buffer_to_stream
argument_list|(
operator|&
name|context
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|output_buffer_attached_stream
argument_list|(
operator|&
name|context
operator|->
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Count a diagnostic.  Return true if the message should be printed.  */
end_comment

begin_function
name|bool
name|diagnostic_count_diagnostic
parameter_list|(
name|context
parameter_list|,
name|kind
parameter_list|)
name|diagnostic_context
modifier|*
name|context
decl_stmt|;
name|diagnostic_t
name|kind
decl_stmt|;
block|{
switch|switch
condition|(
name|kind
condition|)
block|{
default|default:
name|abort
argument_list|()
expr_stmt|;
break|break;
case|case
name|DK_FATAL
case|:
case|case
name|DK_ICE
case|:
case|case
name|DK_SORRY
case|:
case|case
name|DK_ANACHRONISM
case|:
case|case
name|DK_NOTE
case|:
operator|++
name|diagnostic_kind_count
argument_list|(
name|context
argument_list|,
name|kind
argument_list|)
expr_stmt|;
break|break;
case|case
name|DK_WARNING
case|:
if|if
condition|(
operator|!
name|diagnostic_report_warnings_p
argument_list|()
condition|)
return|return
name|false
return|;
elseif|else
if|if
condition|(
operator|!
name|warnings_are_errors
condition|)
block|{
operator|++
name|diagnostic_kind_count
argument_list|(
name|context
argument_list|,
name|DK_WARNING
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* else fall through.  */
case|case
name|DK_ERROR
case|:
if|if
condition|(
name|kind
operator|==
name|DK_WARNING
operator|&&
name|context
operator|->
name|warnings_are_errors_message
condition|)
block|{
name|output_verbatim
argument_list|(
operator|&
name|context
operator|->
name|buffer
argument_list|,
literal|"%s: warnings being treated as errors\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|context
operator|->
name|warnings_are_errors_message
operator|=
name|false
expr_stmt|;
block|}
operator|++
name|diagnostic_kind_count
argument_list|(
name|context
argument_list|,
name|DK_ERROR
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Print a diagnostic MSGID on FILE.  This is just fprintf, except it    runs its second argument through gettext.  */
end_comment

begin_decl_stmt
name|void
name|fnotice
name|VPARAMS
argument_list|(
operator|(
name|FILE
operator|*
name|file
operator|,
specifier|const
name|char
operator|*
name|msgid
operator|,
operator|...
operator|)
argument_list|)
block|{
name|VA_OPEN
argument_list|(
name|ap
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
name|FILE
operator|*
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
name|msgid
argument_list|)
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|VA_CLOSE
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* Print a fatal I/O error message.  Argument are like printf.    Also include a system error message based on `errno'.  */
end_comment

begin_decl_stmt
name|void
name|fatal_io_error
name|VPARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|msgid
operator|,
operator|...
operator|)
argument_list|)
block|{
name|text_info
name|text
decl_stmt|;
name|VA_OPEN
argument_list|(
name|ap
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|text
operator|.
name|format_spec
operator|=
name|_
argument_list|(
name|msgid
argument_list|)
expr_stmt|;
name|text
operator|.
name|args_ptr
operator|=
operator|&
name|ap
expr_stmt|;
name|output_printf
argument_list|(
operator|&
name|global_dc
operator|->
name|buffer
argument_list|,
literal|"%s: %s: "
argument_list|,
name|progname
argument_list|,
name|xstrerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|output_format
argument_list|(
operator|&
name|global_dc
operator|->
name|buffer
argument_list|,
operator|&
name|text
argument_list|)
expr_stmt|;
name|output_flush
argument_list|(
operator|&
name|global_dc
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|VA_CLOSE
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|FATAL_EXIT_CODE
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* Issue a pedantic warning MSGID.  */
end_comment

begin_decl_stmt
name|void
name|pedwarn
name|VPARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|msgid
operator|,
operator|...
operator|)
argument_list|)
block|{
name|diagnostic_info
name|diagnostic
decl_stmt|;
name|VA_OPEN
argument_list|(
name|ap
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|diagnostic_set_info
argument_list|(
operator|&
name|diagnostic
argument_list|,
name|_
argument_list|(
name|msgid
argument_list|)
argument_list|,
operator|&
name|ap
argument_list|,
name|input_filename
argument_list|,
name|lineno
argument_list|,
name|pedantic_error_kind
argument_list|()
argument_list|)
expr_stmt|;
name|report_diagnostic
argument_list|(
operator|&
name|diagnostic
argument_list|)
expr_stmt|;
name|VA_CLOSE
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* Issue a pedantic warning about DECL.  */
end_comment

begin_decl_stmt
name|void
name|pedwarn_with_decl
name|VPARAMS
argument_list|(
operator|(
name|tree
name|decl
operator|,
specifier|const
name|char
operator|*
name|msgid
operator|,
operator|...
operator|)
argument_list|)
block|{
name|diagnostic_info
name|diagnostic
decl_stmt|;
name|VA_OPEN
argument_list|(
name|ap
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
name|tree
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|diagnostic_set_info
argument_list|(
operator|&
name|diagnostic
argument_list|,
name|_
argument_list|(
name|msgid
argument_list|)
argument_list|,
operator|&
name|ap
argument_list|,
name|DECL_SOURCE_FILE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|DECL_SOURCE_LINE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|pedantic_error_kind
argument_list|()
argument_list|)
expr_stmt|;
comment|/* We don't want -pedantic-errors to cause the compilation to fail from      "errors" in system header files.  Sometimes fixincludes can't fix what's      broken (eg: unsigned char bitfields - fixing it may change the alignment      which will cause programs to mysteriously fail because the C library      or kernel uses the original layout).  There's no point in issuing a      warning either, it's just unnecessary noise.  */
if|if
condition|(
operator|!
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|decl
argument_list|)
condition|)
name|diagnostic_for_decl
argument_list|(
operator|&
name|diagnostic
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|VA_CLOSE
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* Same as above but within the context FILE and LINE.  */
end_comment

begin_decl_stmt
name|void
name|pedwarn_with_file_and_line
name|VPARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|file
operator|,
name|int
name|line
operator|,
specifier|const
name|char
operator|*
name|msgid
operator|,
operator|...
operator|)
argument_list|)
block|{
name|diagnostic_info
name|diagnostic
decl_stmt|;
name|VA_OPEN
argument_list|(
name|ap
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
name|int
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|diagnostic_set_info
argument_list|(
operator|&
name|diagnostic
argument_list|,
name|_
argument_list|(
name|msgid
argument_list|)
argument_list|,
operator|&
name|ap
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
name|pedantic_error_kind
argument_list|()
argument_list|)
expr_stmt|;
name|report_diagnostic
argument_list|(
operator|&
name|diagnostic
argument_list|)
expr_stmt|;
name|VA_CLOSE
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* Just apologize with MSGID.  */
end_comment

begin_decl_stmt
name|void
name|sorry
name|VPARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|msgid
operator|,
operator|...
operator|)
argument_list|)
block|{
name|diagnostic_info
name|diagnostic
decl_stmt|;
name|VA_OPEN
argument_list|(
name|ap
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
operator|++
name|sorrycount
expr_stmt|;
name|diagnostic_set_info
argument_list|(
operator|&
name|diagnostic
argument_list|,
name|_
argument_list|(
name|msgid
argument_list|)
argument_list|,
operator|&
name|ap
argument_list|,
name|input_filename
argument_list|,
name|lineno
argument_list|,
name|DK_SORRY
argument_list|)
expr_stmt|;
name|output_set_prefix
argument_list|(
operator|&
name|global_dc
operator|->
name|buffer
argument_list|,
name|diagnostic_build_prefix
argument_list|(
operator|&
name|diagnostic
argument_list|)
argument_list|)
expr_stmt|;
name|output_format
argument_list|(
operator|&
name|global_dc
operator|->
name|buffer
argument_list|,
operator|&
name|diagnostic
operator|.
name|message
argument_list|)
expr_stmt|;
name|output_flush
argument_list|(
operator|&
name|global_dc
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|VA_CLOSE
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* Called when the start of a function definition is parsed,    this function prints on stderr the name of the function.  */
end_comment

begin_function
name|void
name|announce_function
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|quiet_flag
condition|)
block|{
if|if
condition|(
name|rtl_dump_and_exit
condition|)
name|verbatim
argument_list|(
literal|"%s "
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|verbatim
argument_list|(
literal|" %s"
argument_list|,
call|(
modifier|*
name|lang_hooks
operator|.
name|decl_printable_name
call|)
argument_list|(
name|decl
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|output_needs_newline
argument_list|(
operator|&
name|global_dc
operator|->
name|buffer
argument_list|)
operator|=
name|true
expr_stmt|;
name|diagnostic_set_last_function
argument_list|(
name|global_dc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* The default function to print out name of current function that caused    an error.  */
end_comment

begin_function
name|void
name|lhd_print_error_function
parameter_list|(
name|context
parameter_list|,
name|file
parameter_list|)
name|diagnostic_context
modifier|*
name|context
decl_stmt|;
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
block|{
if|if
condition|(
name|diagnostic_last_function_changed
argument_list|(
name|context
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|old_prefix
init|=
name|output_prefix
argument_list|(
operator|&
name|context
operator|->
name|buffer
argument_list|)
decl_stmt|;
name|char
modifier|*
name|new_prefix
init|=
name|file
condition|?
name|build_message_string
argument_list|(
literal|"%s: "
argument_list|,
name|file
argument_list|)
else|:
name|NULL
decl_stmt|;
name|output_set_prefix
argument_list|(
operator|&
name|context
operator|->
name|buffer
argument_list|,
name|new_prefix
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_function_decl
operator|==
name|NULL
condition|)
name|output_add_string
argument_list|(
operator|&
name|context
operator|->
name|buffer
argument_list|,
name|_
argument_list|(
literal|"At top level:"
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
name|output_printf
argument_list|(
operator|&
name|context
operator|->
name|buffer
argument_list|,
literal|"In member function `%s':"
argument_list|,
call|(
modifier|*
name|lang_hooks
operator|.
name|decl_printable_name
call|)
argument_list|(
name|current_function_decl
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|output_printf
argument_list|(
operator|&
name|context
operator|->
name|buffer
argument_list|,
literal|"In function `%s':"
argument_list|,
call|(
modifier|*
name|lang_hooks
operator|.
name|decl_printable_name
call|)
argument_list|(
name|current_function_decl
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|output_add_newline
argument_list|(
operator|&
name|context
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|diagnostic_set_last_function
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|output_buffer_to_stream
argument_list|(
operator|&
name|context
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|context
operator|->
name|buffer
operator|.
name|state
operator|.
name|prefix
operator|=
name|old_prefix
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|new_prefix
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Prints out, if necessary, the name of the current function   that caused an error.  Called from all error and warning functions.   We ignore the FILE parameter, as it cannot be relied upon.  */
end_comment

begin_function
name|void
name|diagnostic_report_current_function
parameter_list|(
name|context
parameter_list|)
name|diagnostic_context
modifier|*
name|context
decl_stmt|;
block|{
name|diagnostic_report_current_module
argument_list|(
name|context
argument_list|)
expr_stmt|;
call|(
modifier|*
name|lang_hooks
operator|.
name|print_error_function
call|)
argument_list|(
name|context
argument_list|,
name|input_filename
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|void
name|error_with_file_and_line
name|VPARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|file
operator|,
name|int
name|line
operator|,
specifier|const
name|char
operator|*
name|msgid
operator|,
operator|...
operator|)
argument_list|)
block|{
name|diagnostic_info
name|diagnostic
decl_stmt|;
name|VA_OPEN
argument_list|(
name|ap
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
name|int
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|diagnostic_set_info
argument_list|(
operator|&
name|diagnostic
argument_list|,
name|msgid
argument_list|,
operator|&
name|ap
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
name|DK_ERROR
argument_list|)
expr_stmt|;
name|report_diagnostic
argument_list|(
operator|&
name|diagnostic
argument_list|)
expr_stmt|;
name|VA_CLOSE
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|void
name|error_with_decl
name|VPARAMS
argument_list|(
operator|(
name|tree
name|decl
operator|,
specifier|const
name|char
operator|*
name|msgid
operator|,
operator|...
operator|)
argument_list|)
block|{
name|diagnostic_info
name|diagnostic
decl_stmt|;
name|VA_OPEN
argument_list|(
name|ap
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
name|tree
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|diagnostic_set_info
argument_list|(
operator|&
name|diagnostic
argument_list|,
name|msgid
argument_list|,
operator|&
name|ap
argument_list|,
name|DECL_SOURCE_FILE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|DECL_SOURCE_LINE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|DK_ERROR
argument_list|)
expr_stmt|;
name|diagnostic_for_decl
argument_list|(
operator|&
name|diagnostic
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|VA_CLOSE
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* Report an error message.  The arguments are like that of printf.  */
end_comment

begin_decl_stmt
name|void
name|error
name|VPARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|msgid
operator|,
operator|...
operator|)
argument_list|)
block|{
name|diagnostic_info
name|diagnostic
decl_stmt|;
name|VA_OPEN
argument_list|(
name|ap
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|diagnostic_set_info
argument_list|(
operator|&
name|diagnostic
argument_list|,
name|msgid
argument_list|,
operator|&
name|ap
argument_list|,
name|input_filename
argument_list|,
name|lineno
argument_list|,
name|DK_ERROR
argument_list|)
expr_stmt|;
name|report_diagnostic
argument_list|(
operator|&
name|diagnostic
argument_list|)
expr_stmt|;
name|VA_CLOSE
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* Likewise, except that the compilation is terminated after printing the    error message.  */
end_comment

begin_decl_stmt
name|void
name|fatal_error
name|VPARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|msgid
operator|,
operator|...
operator|)
argument_list|)
block|{
name|diagnostic_info
name|diagnostic
decl_stmt|;
name|VA_OPEN
argument_list|(
name|ap
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|diagnostic_set_info
argument_list|(
operator|&
name|diagnostic
argument_list|,
name|msgid
argument_list|,
operator|&
name|ap
argument_list|,
name|input_filename
argument_list|,
name|lineno
argument_list|,
name|DK_FATAL
argument_list|)
expr_stmt|;
name|report_diagnostic
argument_list|(
operator|&
name|diagnostic
argument_list|)
expr_stmt|;
name|VA_CLOSE
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|fnotice
argument_list|(
name|stderr
argument_list|,
literal|"compilation terminated.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|FATAL_EXIT_CODE
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|void
name|internal_error
name|VPARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|msgid
operator|,
operator|...
operator|)
argument_list|)
block|{
name|diagnostic_info
name|diagnostic
decl_stmt|;
name|VA_OPEN
argument_list|(
name|ap
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
if|if
condition|(
name|global_dc
operator|->
name|lock
condition|)
name|error_recursion
argument_list|(
name|global_dc
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|ENABLE_CHECKING
if|if
condition|(
name|errorcount
operator|>
literal|0
operator|||
name|sorrycount
operator|>
literal|0
condition|)
block|{
name|fnotice
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: confused by earlier errors, bailing out\n"
argument_list|,
name|input_filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|FATAL_EXIT_CODE
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|global_dc
operator|->
name|internal_error
operator|!=
literal|0
condition|)
call|(
modifier|*
name|global_dc
operator|->
name|internal_error
call|)
argument_list|(
name|_
argument_list|(
name|msgid
argument_list|)
argument_list|,
operator|&
name|ap
argument_list|)
expr_stmt|;
name|diagnostic_set_info
argument_list|(
operator|&
name|diagnostic
argument_list|,
name|msgid
argument_list|,
operator|&
name|ap
argument_list|,
name|input_filename
argument_list|,
name|lineno
argument_list|,
name|DK_ICE
argument_list|)
expr_stmt|;
name|report_diagnostic
argument_list|(
operator|&
name|diagnostic
argument_list|)
expr_stmt|;
name|VA_CLOSE
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|fnotice
argument_list|(
name|stderr
argument_list|,
literal|"Please submit a full bug report,\n\ with preprocessed source if appropriate.\n\ See %s for instructions.\n"
argument_list|,
name|bug_report_url
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|FATAL_EXIT_CODE
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|void
name|warning_with_file_and_line
name|VPARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|file
operator|,
name|int
name|line
operator|,
specifier|const
name|char
operator|*
name|msgid
operator|,
operator|...
operator|)
argument_list|)
block|{
name|diagnostic_info
name|diagnostic
decl_stmt|;
name|VA_OPEN
argument_list|(
name|ap
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
name|int
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|diagnostic_set_info
argument_list|(
operator|&
name|diagnostic
argument_list|,
name|msgid
argument_list|,
operator|&
name|ap
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
name|DK_WARNING
argument_list|)
expr_stmt|;
name|report_diagnostic
argument_list|(
operator|&
name|diagnostic
argument_list|)
expr_stmt|;
name|VA_CLOSE
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|void
name|warning_with_decl
name|VPARAMS
argument_list|(
operator|(
name|tree
name|decl
operator|,
specifier|const
name|char
operator|*
name|msgid
operator|,
operator|...
operator|)
argument_list|)
block|{
name|diagnostic_info
name|diagnostic
decl_stmt|;
name|VA_OPEN
argument_list|(
name|ap
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
name|tree
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|diagnostic_set_info
argument_list|(
operator|&
name|diagnostic
argument_list|,
name|msgid
argument_list|,
operator|&
name|ap
argument_list|,
name|DECL_SOURCE_FILE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|DECL_SOURCE_LINE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|DK_WARNING
argument_list|)
expr_stmt|;
name|diagnostic_for_decl
argument_list|(
operator|&
name|diagnostic
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|VA_CLOSE
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|void
name|warning
name|VPARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|msgid
operator|,
operator|...
operator|)
argument_list|)
block|{
name|diagnostic_info
name|diagnostic
decl_stmt|;
name|VA_OPEN
argument_list|(
name|ap
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|diagnostic_set_info
argument_list|(
operator|&
name|diagnostic
argument_list|,
name|msgid
argument_list|,
operator|&
name|ap
argument_list|,
name|input_filename
argument_list|,
name|lineno
argument_list|,
name|DK_WARNING
argument_list|)
expr_stmt|;
name|report_diagnostic
argument_list|(
operator|&
name|diagnostic
argument_list|)
expr_stmt|;
name|VA_CLOSE
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* Same as above but use diagnostic_buffer.  */
end_comment

begin_decl_stmt
name|void
name|verbatim
name|VPARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|msgid
operator|,
operator|...
operator|)
argument_list|)
block|{
name|text_info
name|text
decl_stmt|;
name|VA_OPEN
argument_list|(
name|ap
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|text
operator|.
name|format_spec
operator|=
name|_
argument_list|(
name|msgid
argument_list|)
expr_stmt|;
name|text
operator|.
name|args_ptr
operator|=
operator|&
name|ap
expr_stmt|;
name|output_do_verbatim
argument_list|(
operator|&
name|global_dc
operator|->
name|buffer
argument_list|,
operator|&
name|text
argument_list|)
expr_stmt|;
name|output_buffer_to_stream
argument_list|(
operator|&
name|global_dc
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|VA_CLOSE
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* Report a diagnostic message (an error or a warning) as specified by    DC.  This function is *the* subroutine in terms of which front-ends    should implement their specific diagnostic handling modules.  The    front-end independent format specifiers are exactly those described    in the documentation of output_format.  */
end_comment

begin_function
name|void
name|diagnostic_report_diagnostic
parameter_list|(
name|context
parameter_list|,
name|diagnostic
parameter_list|)
name|diagnostic_context
modifier|*
name|context
decl_stmt|;
name|diagnostic_info
modifier|*
name|diagnostic
decl_stmt|;
block|{
if|if
condition|(
name|context
operator|->
name|lock
operator|++
condition|)
name|error_recursion
argument_list|(
name|context
argument_list|)
expr_stmt|;
if|if
condition|(
name|diagnostic_count_diagnostic
argument_list|(
name|context
argument_list|,
name|diagnostic
operator|->
name|kind
argument_list|)
condition|)
block|{
operator|(
operator|*
name|diagnostic_starter
argument_list|(
name|context
argument_list|)
operator|)
operator|(
name|context
operator|,
name|diagnostic
operator|)
expr_stmt|;
name|output_format
argument_list|(
operator|&
name|context
operator|->
name|buffer
argument_list|,
operator|&
name|diagnostic
operator|->
name|message
argument_list|)
expr_stmt|;
operator|(
operator|*
name|diagnostic_finalizer
argument_list|(
name|context
argument_list|)
operator|)
operator|(
name|context
operator|,
name|diagnostic
operator|)
expr_stmt|;
name|output_flush
argument_list|(
operator|&
name|context
operator|->
name|buffer
argument_list|)
expr_stmt|;
block|}
operator|--
name|context
operator|->
name|lock
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Inform the user that an error occurred while trying to report some    other error.  This indicates catastrophic internal inconsistencies,    so give up now.  But do try to flush out the previous error.    This mustn't use internal_error, that will cause infinite recursion.  */
end_comment

begin_function
specifier|static
name|void
name|error_recursion
parameter_list|(
name|context
parameter_list|)
name|diagnostic_context
modifier|*
name|context
decl_stmt|;
block|{
if|if
condition|(
name|context
operator|->
name|lock
operator|<
literal|3
condition|)
name|output_flush
argument_list|(
operator|&
name|context
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|fnotice
argument_list|(
name|stderr
argument_list|,
literal|"Internal compiler error: Error reporting routines re-entered.\n"
argument_list|)
expr_stmt|;
name|fnotice
argument_list|(
name|stderr
argument_list|,
literal|"Please submit a full bug report,\n\ with preprocessed source if appropriate.\n\ See %s for instructions.\n"
argument_list|,
name|bug_report_url
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|FATAL_EXIT_CODE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given a partial pathname as input, return another pathname that    shares no directory elements with the pathname of __FILE__.  This    is used by fancy_abort() to print `Internal compiler error in expr.c'    instead of `Internal compiler error in ../../GCC/gcc/expr.c'.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|trim_filename
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|static
specifier|const
name|char
name|this_file
index|[]
init|=
name|__FILE__
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
init|=
name|name
decl_stmt|,
modifier|*
name|q
init|=
name|this_file
decl_stmt|;
comment|/* First skip any "../" in each filename.  This allows us to give a proper      reference to a file in a subdirectory.  */
while|while
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
operator|(
name|p
index|[
literal|2
index|]
operator|==
name|DIR_SEPARATOR
ifdef|#
directive|ifdef
name|DIR_SEPARATOR_2
operator|||
name|p
index|[
literal|2
index|]
operator|==
name|DIR_SEPARATOR_2
endif|#
directive|endif
operator|)
condition|)
name|p
operator|+=
literal|3
expr_stmt|;
while|while
condition|(
name|q
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|q
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
operator|(
name|q
index|[
literal|2
index|]
operator|==
name|DIR_SEPARATOR
ifdef|#
directive|ifdef
name|DIR_SEPARATOR_2
operator|||
name|p
index|[
literal|2
index|]
operator|==
name|DIR_SEPARATOR_2
endif|#
directive|endif
operator|)
condition|)
name|q
operator|+=
literal|3
expr_stmt|;
comment|/* Now skip any parts the two filenames have in common.  */
while|while
condition|(
operator|*
name|p
operator|==
operator|*
name|q
operator|&&
operator|*
name|p
operator|!=
literal|0
operator|&&
operator|*
name|q
operator|!=
literal|0
condition|)
name|p
operator|++
operator|,
name|q
operator|++
expr_stmt|;
comment|/* Now go backwards until the previous directory separator.  */
while|while
condition|(
name|p
operator|>
name|name
operator|&&
name|p
index|[
operator|-
literal|1
index|]
operator|!=
name|DIR_SEPARATOR
ifdef|#
directive|ifdef
name|DIR_SEPARATOR_2
operator|&&
name|p
index|[
operator|-
literal|1
index|]
operator|!=
name|DIR_SEPARATOR_2
endif|#
directive|endif
condition|)
name|p
operator|--
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* Report an internal compiler error in a friendly manner and without    dumping core.  */
end_comment

begin_function
name|void
name|fancy_abort
parameter_list|(
name|file
parameter_list|,
name|line
parameter_list|,
name|function
parameter_list|)
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|line
decl_stmt|;
specifier|const
name|char
modifier|*
name|function
decl_stmt|;
block|{
name|internal_error
argument_list|(
literal|"in %s, at %s:%d"
argument_list|,
name|function
argument_list|,
name|trim_filename
argument_list|(
name|file
argument_list|)
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|diagnostic_report_current_module
parameter_list|(
name|context
parameter_list|)
name|diagnostic_context
modifier|*
name|context
decl_stmt|;
block|{
name|struct
name|file_stack
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|output_needs_newline
argument_list|(
operator|&
name|context
operator|->
name|buffer
argument_list|)
condition|)
block|{
name|output_add_newline
argument_list|(
operator|&
name|context
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|output_needs_newline
argument_list|(
operator|&
name|context
operator|->
name|buffer
argument_list|)
operator|=
name|false
expr_stmt|;
block|}
if|if
condition|(
name|input_file_stack
operator|&&
name|input_file_stack
operator|->
name|next
operator|!=
literal|0
operator|&&
name|diagnostic_last_module_changed
argument_list|(
name|context
argument_list|)
condition|)
block|{
for|for
control|(
name|p
operator|=
name|input_file_stack
operator|->
name|next
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
if|if
condition|(
name|p
operator|==
name|input_file_stack
operator|->
name|next
condition|)
name|output_verbatim
argument_list|(
operator|&
name|context
operator|->
name|buffer
argument_list|,
literal|"In file included from %s:%d"
argument_list|,
name|p
operator|->
name|name
argument_list|,
name|p
operator|->
name|line
argument_list|)
expr_stmt|;
else|else
name|output_verbatim
argument_list|(
operator|&
name|context
operator|->
name|buffer
argument_list|,
literal|",\n                 from %s:%d"
argument_list|,
name|p
operator|->
name|name
argument_list|,
name|p
operator|->
name|line
argument_list|)
expr_stmt|;
name|output_verbatim
argument_list|(
operator|&
name|context
operator|->
name|buffer
argument_list|,
literal|":\n"
argument_list|)
expr_stmt|;
name|diagnostic_set_last_module
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|default_diagnostic_starter
parameter_list|(
name|context
parameter_list|,
name|diagnostic
parameter_list|)
name|diagnostic_context
modifier|*
name|context
decl_stmt|;
name|diagnostic_info
modifier|*
name|diagnostic
decl_stmt|;
block|{
name|diagnostic_report_current_function
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|output_set_prefix
argument_list|(
operator|&
name|context
operator|->
name|buffer
argument_list|,
name|diagnostic_build_prefix
argument_list|(
name|diagnostic
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|default_diagnostic_finalizer
argument_list|(
name|context
argument_list|,
name|diagnostic
argument_list|)
name|diagnostic_context
modifier|*
name|context
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|diagnostic_info
modifier|*
name|diagnostic
name|__attribute__
argument_list|(
operator|(
name|unused
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|output_destroy_prefix
argument_list|(
operator|&
name|context
operator|->
name|buffer
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|void
name|inform
name|VPARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|msgid
operator|,
operator|...
operator|)
argument_list|)
block|{
name|diagnostic_info
name|diagnostic
decl_stmt|;
name|VA_OPEN
argument_list|(
name|ap
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|diagnostic_set_info
argument_list|(
operator|&
name|diagnostic
argument_list|,
name|msgid
argument_list|,
operator|&
name|ap
argument_list|,
name|input_filename
argument_list|,
name|lineno
argument_list|,
name|DK_NOTE
argument_list|)
expr_stmt|;
name|report_diagnostic
argument_list|(
operator|&
name|diagnostic
argument_list|)
expr_stmt|;
name|VA_CLOSE
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_function
name|void
name|warn_deprecated_use
parameter_list|(
name|node
parameter_list|)
name|tree
name|node
decl_stmt|;
block|{
if|if
condition|(
name|node
operator|==
literal|0
operator|||
operator|!
name|warn_deprecated_decl
condition|)
return|return;
if|if
condition|(
name|DECL_P
argument_list|(
name|node
argument_list|)
condition|)
name|warning
argument_list|(
literal|"`%s' is deprecated (declared at %s:%d)"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|node
argument_list|)
argument_list|)
argument_list|,
name|DECL_SOURCE_FILE
argument_list|(
name|node
argument_list|)
argument_list|,
name|DECL_SOURCE_LINE
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_P
argument_list|(
name|node
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|what
init|=
name|NULL
decl_stmt|;
name|tree
name|decl
init|=
name|TYPE_STUB_DECL
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|node
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
name|what
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|TYPE_NAME
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|node
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|node
argument_list|)
argument_list|)
condition|)
name|what
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|node
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|what
condition|)
block|{
if|if
condition|(
name|decl
condition|)
name|warning
argument_list|(
literal|"`%s' is deprecated (declared at %s:%d)"
argument_list|,
name|what
argument_list|,
name|DECL_SOURCE_FILE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|DECL_SOURCE_LINE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
literal|"`%s' is deprecated"
argument_list|,
name|what
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|decl
condition|)
name|warning
argument_list|(
literal|"type is deprecated (declared at %s:%d)"
argument_list|,
name|DECL_SOURCE_FILE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|DECL_SOURCE_LINE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
literal|"type is deprecated"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

