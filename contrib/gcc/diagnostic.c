begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Language-independent diagnostic subroutines for the GNU Compiler Collection    Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006    Free Software Foundation, Inc.    Contributed by Gabriel Dos Reis<gdr@codesourcery.com>  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* This file implements the language independent aspect of diagnostic    message module.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_undef
undef|#
directive|undef
name|FLOAT
end_undef

begin_comment
comment|/* This is for hpux. They should change hpux.  */
end_comment

begin_undef
undef|#
directive|undef
name|FFS
end_undef

begin_comment
comment|/* Some systems define this in param.h.  */
end_comment

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"version.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"input.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"intl.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_include
include|#
directive|include
file|"langhooks-def.h"
end_include

begin_include
include|#
directive|include
file|"opts.h"
end_include

begin_comment
comment|/* Prototypes.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|build_message_string
argument_list|(
specifier|const
name|char
operator|*
argument_list|,
operator|...
argument_list|)
name|ATTRIBUTE_PRINTF_1
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|default_diagnostic_starter
parameter_list|(
name|diagnostic_context
modifier|*
parameter_list|,
name|diagnostic_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|default_diagnostic_finalizer
parameter_list|(
name|diagnostic_context
modifier|*
parameter_list|,
name|diagnostic_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|void
name|error_recursion
argument_list|(
name|diagnostic_context
operator|*
argument_list|)
name|ATTRIBUTE_NORETURN
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|bool
name|diagnostic_count_diagnostic
parameter_list|(
name|diagnostic_context
modifier|*
parameter_list|,
name|diagnostic_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|diagnostic_action_after_output
parameter_list|(
name|diagnostic_context
modifier|*
parameter_list|,
name|diagnostic_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|void
name|real_abort
argument_list|(
name|void
argument_list|)
name|ATTRIBUTE_NORETURN
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A diagnostic_context surrogate for stderr.  */
end_comment

begin_decl_stmt
specifier|static
name|diagnostic_context
name|global_diagnostic_context
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|diagnostic_context
modifier|*
name|global_dc
init|=
operator|&
name|global_diagnostic_context
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Return a malloc'd string containing MSG formatted a la printf.  The    caller is responsible for freeing the memory.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|build_message_string
parameter_list|(
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
modifier|...
parameter_list|)
block|{
name|char
modifier|*
name|str
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|vasprintf
argument_list|(
operator|&
name|str
argument_list|,
name|msg
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
name|str
return|;
block|}
end_function

begin_comment
comment|/* Same as diagnostic_build_prefix, but only the source FILE is given.  */
end_comment

begin_function
name|char
modifier|*
name|file_name_as_prefix
parameter_list|(
specifier|const
name|char
modifier|*
name|f
parameter_list|)
block|{
return|return
name|build_message_string
argument_list|(
literal|"%s: "
argument_list|,
name|f
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Initialize the diagnostic message outputting machinery.  */
end_comment

begin_function
name|void
name|diagnostic_initialize
parameter_list|(
name|diagnostic_context
modifier|*
name|context
parameter_list|)
block|{
comment|/* Allocate a basic pretty-printer.  Clients will replace this a      much more elaborated pretty-printer if they wish.  */
name|context
operator|->
name|printer
operator|=
name|XNEW
argument_list|(
name|pretty_printer
argument_list|)
expr_stmt|;
name|pp_construct
argument_list|(
name|context
operator|->
name|printer
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* By default, diagnostics are sent to stderr.  */
name|context
operator|->
name|printer
operator|->
name|buffer
operator|->
name|stream
operator|=
name|stderr
expr_stmt|;
comment|/* By default, we emit prefixes once per message.  */
name|context
operator|->
name|printer
operator|->
name|wrapping
operator|.
name|rule
operator|=
name|DIAGNOSTICS_SHOW_PREFIX_ONCE
expr_stmt|;
name|memset
argument_list|(
name|context
operator|->
name|diagnostic_count
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|context
operator|->
name|diagnostic_count
argument_list|)
expr_stmt|;
name|context
operator|->
name|issue_warnings_are_errors_message
operator|=
name|true
expr_stmt|;
name|context
operator|->
name|warning_as_error_requested
operator|=
name|false
expr_stmt|;
name|memset
argument_list|(
name|context
operator|->
name|classify_diagnostic
argument_list|,
name|DK_UNSPECIFIED
argument_list|,
sizeof|sizeof
name|context
operator|->
name|classify_diagnostic
argument_list|)
expr_stmt|;
name|context
operator|->
name|show_option_requested
operator|=
name|false
expr_stmt|;
name|context
operator|->
name|abort_on_error
operator|=
name|false
expr_stmt|;
name|context
operator|->
name|internal_error
operator|=
name|NULL
expr_stmt|;
name|diagnostic_starter
argument_list|(
name|context
argument_list|)
operator|=
name|default_diagnostic_starter
expr_stmt|;
name|diagnostic_finalizer
argument_list|(
name|context
argument_list|)
operator|=
name|default_diagnostic_finalizer
expr_stmt|;
name|context
operator|->
name|last_module
operator|=
literal|0
expr_stmt|;
name|context
operator|->
name|last_function
operator|=
name|NULL
expr_stmt|;
name|context
operator|->
name|lock
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize DIAGNOSTIC, where the message MSG has already been    translated.  */
end_comment

begin_function
name|void
name|diagnostic_set_info_translated
parameter_list|(
name|diagnostic_info
modifier|*
name|diagnostic
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
name|va_list
modifier|*
name|args
parameter_list|,
name|location_t
name|location
parameter_list|,
name|diagnostic_t
name|kind
parameter_list|)
block|{
name|diagnostic
operator|->
name|message
operator|.
name|err_no
operator|=
name|errno
expr_stmt|;
name|diagnostic
operator|->
name|message
operator|.
name|args_ptr
operator|=
name|args
expr_stmt|;
name|diagnostic
operator|->
name|message
operator|.
name|format_spec
operator|=
name|msg
expr_stmt|;
name|diagnostic
operator|->
name|location
operator|=
name|location
expr_stmt|;
name|diagnostic
operator|->
name|kind
operator|=
name|kind
expr_stmt|;
name|diagnostic
operator|->
name|option_index
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize DIAGNOSTIC, where the message GMSGID has not yet been    translated.  */
end_comment

begin_function
name|void
name|diagnostic_set_info
parameter_list|(
name|diagnostic_info
modifier|*
name|diagnostic
parameter_list|,
specifier|const
name|char
modifier|*
name|gmsgid
parameter_list|,
name|va_list
modifier|*
name|args
parameter_list|,
name|location_t
name|location
parameter_list|,
name|diagnostic_t
name|kind
parameter_list|)
block|{
name|diagnostic_set_info_translated
argument_list|(
name|diagnostic
argument_list|,
name|_
argument_list|(
name|gmsgid
argument_list|)
argument_list|,
name|args
argument_list|,
name|location
argument_list|,
name|kind
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return a malloc'd string describing a location.  The caller is    responsible for freeing the memory.  */
end_comment

begin_function
name|char
modifier|*
name|diagnostic_build_prefix
parameter_list|(
name|diagnostic_info
modifier|*
name|diagnostic
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|diagnostic_kind_text
index|[]
init|=
block|{
define|#
directive|define
name|DEFINE_DIAGNOSTIC_KIND
parameter_list|(
name|K
parameter_list|,
name|T
parameter_list|)
value|(T),
include|#
directive|include
file|"diagnostic.def"
undef|#
directive|undef
name|DEFINE_DIAGNOSTIC_KIND
literal|"must-not-happen"
block|}
decl_stmt|;
specifier|const
name|char
modifier|*
name|text
init|=
name|_
argument_list|(
name|diagnostic_kind_text
index|[
name|diagnostic
operator|->
name|kind
index|]
argument_list|)
decl_stmt|;
name|expanded_location
name|s
init|=
name|expand_location
argument_list|(
name|diagnostic
operator|->
name|location
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
name|diagnostic
operator|->
name|kind
operator|<
name|DK_LAST_DIAGNOSTIC_KIND
argument_list|)
expr_stmt|;
return|return
operator|(
name|s
operator|.
name|file
operator|==
name|NULL
condition|?
name|build_message_string
argument_list|(
literal|"%s: %s"
argument_list|,
name|progname
argument_list|,
name|text
argument_list|)
ifdef|#
directive|ifdef
name|USE_MAPPED_LOCATION
else|:
name|flag_show_column
operator|&&
name|s
operator|.
name|column
operator|!=
literal|0
condition|?
name|build_message_string
argument_list|(
literal|"%s:%d:%d: %s"
argument_list|,
name|s
operator|.
name|file
argument_list|,
name|s
operator|.
name|line
argument_list|,
name|s
operator|.
name|column
argument_list|,
name|text
argument_list|)
endif|#
directive|endif
else|:
name|build_message_string
argument_list|(
literal|"%s:%d: %s"
argument_list|,
name|s
operator|.
name|file
argument_list|,
name|s
operator|.
name|line
argument_list|,
name|text
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Count a diagnostic.  Return true if the message should be printed.  */
end_comment

begin_function
specifier|static
name|bool
name|diagnostic_count_diagnostic
parameter_list|(
name|diagnostic_context
modifier|*
name|context
parameter_list|,
name|diagnostic_info
modifier|*
name|diagnostic
parameter_list|)
block|{
name|diagnostic_t
name|kind
init|=
name|diagnostic
operator|->
name|kind
decl_stmt|;
switch|switch
condition|(
name|kind
condition|)
block|{
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
case|case
name|DK_ICE
case|:
ifndef|#
directive|ifndef
name|ENABLE_CHECKING
comment|/* When not checking, ICEs are converted to fatal errors when an 	 error has already occurred.  This is counteracted by 	 abort_on_error.  */
if|if
condition|(
operator|(
name|diagnostic_kind_count
argument_list|(
name|context
argument_list|,
name|DK_ERROR
argument_list|)
operator|>
literal|0
operator|||
name|diagnostic_kind_count
argument_list|(
name|context
argument_list|,
name|DK_SORRY
argument_list|)
operator|>
literal|0
operator|)
operator|&&
operator|!
name|context
operator|->
name|abort_on_error
condition|)
block|{
name|expanded_location
name|s
init|=
name|expand_location
argument_list|(
name|diagnostic
operator|->
name|location
argument_list|)
decl_stmt|;
name|fnotice
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: confused by earlier errors, bailing out\n"
argument_list|,
name|s
operator|.
name|file
argument_list|,
name|s
operator|.
name|line
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|ICE_EXIT_CODE
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|context
operator|->
name|internal_error
condition|)
call|(
modifier|*
name|context
operator|->
name|internal_error
call|)
argument_list|(
name|diagnostic
operator|->
name|message
operator|.
name|format_spec
argument_list|,
name|diagnostic
operator|->
name|message
operator|.
name|args_ptr
argument_list|)
expr_stmt|;
comment|/* Fall through.  */
case|case
name|DK_FATAL
case|:
case|case
name|DK_SORRY
case|:
case|case
name|DK_ANACHRONISM
case|:
case|case
name|DK_NOTE
case|:
operator|++
name|diagnostic_kind_count
argument_list|(
name|context
argument_list|,
name|kind
argument_list|)
expr_stmt|;
break|break;
case|case
name|DK_WARNING
case|:
if|if
condition|(
operator|!
name|diagnostic_report_warnings_p
argument_list|()
condition|)
return|return
name|false
return|;
comment|/* -Werror can reclassify warnings as errors, but 	 classify_diagnostic can reclassify it back to a warning.  The 	 second part of this test detects that case.  */
if|if
condition|(
operator|!
name|context
operator|->
name|warning_as_error_requested
operator|||
operator|(
name|context
operator|->
name|classify_diagnostic
index|[
name|diagnostic
operator|->
name|option_index
index|]
operator|==
name|DK_WARNING
operator|)
condition|)
block|{
operator|++
name|diagnostic_kind_count
argument_list|(
name|context
argument_list|,
name|DK_WARNING
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|context
operator|->
name|issue_warnings_are_errors_message
condition|)
block|{
name|pp_verbatim
argument_list|(
name|context
operator|->
name|printer
argument_list|,
literal|"%s: warnings being treated as errors\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|context
operator|->
name|issue_warnings_are_errors_message
operator|=
name|false
expr_stmt|;
block|}
comment|/* And fall through.  */
case|case
name|DK_ERROR
case|:
operator|++
name|diagnostic_kind_count
argument_list|(
name|context
argument_list|,
name|DK_ERROR
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Take any action which is expected to happen after the diagnostic    is written out.  This function does not always return.  */
end_comment

begin_function
specifier|static
name|void
name|diagnostic_action_after_output
parameter_list|(
name|diagnostic_context
modifier|*
name|context
parameter_list|,
name|diagnostic_info
modifier|*
name|diagnostic
parameter_list|)
block|{
switch|switch
condition|(
name|diagnostic
operator|->
name|kind
condition|)
block|{
case|case
name|DK_DEBUG
case|:
case|case
name|DK_NOTE
case|:
case|case
name|DK_ANACHRONISM
case|:
case|case
name|DK_WARNING
case|:
break|break;
case|case
name|DK_ERROR
case|:
case|case
name|DK_SORRY
case|:
if|if
condition|(
name|context
operator|->
name|abort_on_error
condition|)
name|real_abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|flag_fatal_errors
condition|)
block|{
name|fnotice
argument_list|(
name|stderr
argument_list|,
literal|"compilation terminated due to -Wfatal-errors.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|FATAL_EXIT_CODE
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DK_ICE
case|:
if|if
condition|(
name|context
operator|->
name|abort_on_error
condition|)
name|real_abort
argument_list|()
expr_stmt|;
name|fnotice
argument_list|(
name|stderr
argument_list|,
literal|"Please submit a full bug report,\n"
literal|"with preprocessed source if appropriate.\n"
literal|"See %s for instructions.\n"
argument_list|,
name|bug_report_url
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|ICE_EXIT_CODE
argument_list|)
expr_stmt|;
case|case
name|DK_FATAL
case|:
if|if
condition|(
name|context
operator|->
name|abort_on_error
condition|)
name|real_abort
argument_list|()
expr_stmt|;
name|fnotice
argument_list|(
name|stderr
argument_list|,
literal|"compilation terminated.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|FATAL_EXIT_CODE
argument_list|)
expr_stmt|;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Prints out, if necessary, the name of the current function    that caused an error.  Called from all error and warning functions.  */
end_comment

begin_function
name|void
name|diagnostic_report_current_function
parameter_list|(
name|diagnostic_context
modifier|*
name|context
parameter_list|)
block|{
name|diagnostic_report_current_module
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|lang_hooks
operator|.
name|print_error_function
argument_list|(
name|context
argument_list|,
name|input_filename
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|diagnostic_report_current_module
parameter_list|(
name|diagnostic_context
modifier|*
name|context
parameter_list|)
block|{
name|struct
name|file_stack
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|pp_needs_newline
argument_list|(
name|context
operator|->
name|printer
argument_list|)
condition|)
block|{
name|pp_newline
argument_list|(
name|context
operator|->
name|printer
argument_list|)
expr_stmt|;
name|pp_needs_newline
argument_list|(
name|context
operator|->
name|printer
argument_list|)
operator|=
name|false
expr_stmt|;
block|}
name|p
operator|=
name|input_file_stack
expr_stmt|;
if|if
condition|(
name|p
operator|&&
name|diagnostic_last_module_changed
argument_list|(
name|context
argument_list|)
condition|)
block|{
name|expanded_location
name|xloc
init|=
name|expand_location
argument_list|(
name|p
operator|->
name|location
argument_list|)
decl_stmt|;
name|pp_verbatim
argument_list|(
name|context
operator|->
name|printer
argument_list|,
literal|"In file included from %s:%d"
argument_list|,
name|xloc
operator|.
name|file
argument_list|,
name|xloc
operator|.
name|line
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|p
operator|=
name|p
operator|->
name|next
operator|)
operator|!=
name|NULL
condition|)
block|{
name|xloc
operator|=
name|expand_location
argument_list|(
name|p
operator|->
name|location
argument_list|)
expr_stmt|;
name|pp_verbatim
argument_list|(
name|context
operator|->
name|printer
argument_list|,
literal|",\n                 from %s:%d"
argument_list|,
name|xloc
operator|.
name|file
argument_list|,
name|xloc
operator|.
name|line
argument_list|)
expr_stmt|;
block|}
name|pp_verbatim
argument_list|(
name|context
operator|->
name|printer
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
name|diagnostic_set_last_module
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|pp_newline
argument_list|(
name|context
operator|->
name|printer
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|default_diagnostic_starter
parameter_list|(
name|diagnostic_context
modifier|*
name|context
parameter_list|,
name|diagnostic_info
modifier|*
name|diagnostic
parameter_list|)
block|{
name|diagnostic_report_current_function
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|pp_set_prefix
argument_list|(
name|context
operator|->
name|printer
argument_list|,
name|diagnostic_build_prefix
argument_list|(
name|diagnostic
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|default_diagnostic_finalizer
parameter_list|(
name|diagnostic_context
modifier|*
name|context
parameter_list|,
name|diagnostic_info
modifier|*
name|diagnostic
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|pp_destroy_prefix
argument_list|(
name|context
operator|->
name|printer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Interface to specify diagnostic kind overrides.  Returns the    previous setting, or DK_UNSPECIFIED if the parameters are out of    range.  */
end_comment

begin_function
name|diagnostic_t
name|diagnostic_classify_diagnostic
parameter_list|(
name|diagnostic_context
modifier|*
name|context
parameter_list|,
name|int
name|option_index
parameter_list|,
name|diagnostic_t
name|new_kind
parameter_list|)
block|{
name|diagnostic_t
name|old_kind
decl_stmt|;
if|if
condition|(
name|option_index
operator|<=
literal|0
operator|||
name|option_index
operator|>=
name|N_OPTS
operator|||
name|new_kind
operator|>=
name|DK_LAST_DIAGNOSTIC_KIND
condition|)
return|return
name|DK_UNSPECIFIED
return|;
name|old_kind
operator|=
name|context
operator|->
name|classify_diagnostic
index|[
name|option_index
index|]
expr_stmt|;
name|context
operator|->
name|classify_diagnostic
index|[
name|option_index
index|]
operator|=
name|new_kind
expr_stmt|;
return|return
name|old_kind
return|;
block|}
end_function

begin_comment
comment|/* Report a diagnostic message (an error or a warning) as specified by    DC.  This function is *the* subroutine in terms of which front-ends    should implement their specific diagnostic handling modules.  The    front-end independent format specifiers are exactly those described    in the documentation of output_format.  */
end_comment

begin_function
name|void
name|diagnostic_report_diagnostic
parameter_list|(
name|diagnostic_context
modifier|*
name|context
parameter_list|,
name|diagnostic_info
modifier|*
name|diagnostic
parameter_list|)
block|{
if|if
condition|(
name|context
operator|->
name|lock
operator|>
literal|0
condition|)
block|{
comment|/* If we're reporting an ICE in the middle of some other error, 	 try to flush out the previous error, then let this one 	 through.  Don't do this more than once.  */
if|if
condition|(
name|diagnostic
operator|->
name|kind
operator|==
name|DK_ICE
operator|&&
name|context
operator|->
name|lock
operator|==
literal|1
condition|)
name|pp_flush
argument_list|(
name|context
operator|->
name|printer
argument_list|)
expr_stmt|;
else|else
name|error_recursion
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|diagnostic
operator|->
name|option_index
condition|)
block|{
comment|/* This tests if the user provided the appropriate -Wfoo or 	 -Wno-foo option.  */
if|if
condition|(
operator|!
name|option_enabled
argument_list|(
name|diagnostic
operator|->
name|option_index
argument_list|)
condition|)
return|return;
comment|/* This tests if the user provided the appropriate -Werror=foo 	 option.  */
if|if
condition|(
name|context
operator|->
name|classify_diagnostic
index|[
name|diagnostic
operator|->
name|option_index
index|]
operator|!=
name|DK_UNSPECIFIED
condition|)
name|diagnostic
operator|->
name|kind
operator|=
name|context
operator|->
name|classify_diagnostic
index|[
name|diagnostic
operator|->
name|option_index
index|]
expr_stmt|;
comment|/* This allows for future extensions, like temporarily disabling 	 warnings for ranges of source code.  */
if|if
condition|(
name|diagnostic
operator|->
name|kind
operator|==
name|DK_IGNORED
condition|)
return|return;
block|}
name|context
operator|->
name|lock
operator|++
expr_stmt|;
if|if
condition|(
name|diagnostic_count_diagnostic
argument_list|(
name|context
argument_list|,
name|diagnostic
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|saved_format_spec
init|=
name|diagnostic
operator|->
name|message
operator|.
name|format_spec
decl_stmt|;
if|if
condition|(
name|context
operator|->
name|show_option_requested
operator|&&
name|diagnostic
operator|->
name|option_index
condition|)
name|diagnostic
operator|->
name|message
operator|.
name|format_spec
operator|=
name|ACONCAT
argument_list|(
operator|(
name|diagnostic
operator|->
name|message
operator|.
name|format_spec
operator|,
literal|" ["
operator|,
name|cl_options
index|[
name|diagnostic
operator|->
name|option_index
index|]
operator|.
name|opt_text
operator|,
literal|"]"
operator|,
name|NULL
operator|)
argument_list|)
expr_stmt|;
name|diagnostic
operator|->
name|message
operator|.
name|locus
operator|=
operator|&
name|diagnostic
operator|->
name|location
expr_stmt|;
name|pp_format
argument_list|(
name|context
operator|->
name|printer
argument_list|,
operator|&
name|diagnostic
operator|->
name|message
argument_list|)
expr_stmt|;
operator|(
operator|*
name|diagnostic_starter
argument_list|(
name|context
argument_list|)
operator|)
operator|(
name|context
operator|,
name|diagnostic
operator|)
expr_stmt|;
name|pp_output_formatted_text
argument_list|(
name|context
operator|->
name|printer
argument_list|)
expr_stmt|;
operator|(
operator|*
name|diagnostic_finalizer
argument_list|(
name|context
argument_list|)
operator|)
operator|(
name|context
operator|,
name|diagnostic
operator|)
expr_stmt|;
name|pp_flush
argument_list|(
name|context
operator|->
name|printer
argument_list|)
expr_stmt|;
name|diagnostic_action_after_output
argument_list|(
name|context
argument_list|,
name|diagnostic
argument_list|)
expr_stmt|;
name|diagnostic
operator|->
name|message
operator|.
name|format_spec
operator|=
name|saved_format_spec
expr_stmt|;
block|}
name|context
operator|->
name|lock
operator|--
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given a partial pathname as input, return another pathname that    shares no directory elements with the pathname of __FILE__.  This    is used by fancy_abort() to print `Internal compiler error in expr.c'    instead of `Internal compiler error in ../../GCC/gcc/expr.c'.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|trim_filename
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|this_file
index|[]
init|=
name|__FILE__
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
init|=
name|name
decl_stmt|,
modifier|*
name|q
init|=
name|this_file
decl_stmt|;
comment|/* First skip any "../" in each filename.  This allows us to give a proper      reference to a file in a subdirectory.  */
while|while
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
name|IS_DIR_SEPARATOR
argument_list|(
name|p
index|[
literal|2
index|]
argument_list|)
condition|)
name|p
operator|+=
literal|3
expr_stmt|;
while|while
condition|(
name|q
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|q
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
name|IS_DIR_SEPARATOR
argument_list|(
name|q
index|[
literal|2
index|]
argument_list|)
condition|)
name|q
operator|+=
literal|3
expr_stmt|;
comment|/* Now skip any parts the two filenames have in common.  */
while|while
condition|(
operator|*
name|p
operator|==
operator|*
name|q
operator|&&
operator|*
name|p
operator|!=
literal|0
operator|&&
operator|*
name|q
operator|!=
literal|0
condition|)
name|p
operator|++
operator|,
name|q
operator|++
expr_stmt|;
comment|/* Now go backwards until the previous directory separator.  */
while|while
condition|(
name|p
operator|>
name|name
operator|&&
operator|!
name|IS_DIR_SEPARATOR
argument_list|(
name|p
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
name|p
operator|--
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Standard error reporting routines in increasing order of severity.    All of these take arguments like printf.  */
end_comment

begin_comment
comment|/* Text to be emitted verbatim to the error message stream; this    produces no prefix and disables line-wrapping.  Use rarely.  */
end_comment

begin_function
name|void
name|verbatim
parameter_list|(
specifier|const
name|char
modifier|*
name|gmsgid
parameter_list|,
modifier|...
parameter_list|)
block|{
name|text_info
name|text
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|gmsgid
argument_list|)
expr_stmt|;
name|text
operator|.
name|err_no
operator|=
name|errno
expr_stmt|;
name|text
operator|.
name|args_ptr
operator|=
operator|&
name|ap
expr_stmt|;
name|text
operator|.
name|format_spec
operator|=
name|_
argument_list|(
name|gmsgid
argument_list|)
expr_stmt|;
name|text
operator|.
name|locus
operator|=
name|NULL
expr_stmt|;
name|pp_format_verbatim
argument_list|(
name|global_dc
operator|->
name|printer
argument_list|,
operator|&
name|text
argument_list|)
expr_stmt|;
name|pp_flush
argument_list|(
name|global_dc
operator|->
name|printer
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* An informative note.  Use this for additional details on an error    message.  */
end_comment

begin_function
name|void
name|inform
parameter_list|(
specifier|const
name|char
modifier|*
name|gmsgid
parameter_list|,
modifier|...
parameter_list|)
block|{
name|diagnostic_info
name|diagnostic
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|gmsgid
argument_list|)
expr_stmt|;
name|diagnostic_set_info
argument_list|(
operator|&
name|diagnostic
argument_list|,
name|gmsgid
argument_list|,
operator|&
name|ap
argument_list|,
name|input_location
argument_list|,
name|DK_NOTE
argument_list|)
expr_stmt|;
name|report_diagnostic
argument_list|(
operator|&
name|diagnostic
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A warning.  Use this for code which is correct according to the    relevant language specification but is likely to be buggy anyway.  */
end_comment

begin_function
name|void
name|warning
parameter_list|(
name|int
name|opt
parameter_list|,
specifier|const
name|char
modifier|*
name|gmsgid
parameter_list|,
modifier|...
parameter_list|)
block|{
name|diagnostic_info
name|diagnostic
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|gmsgid
argument_list|)
expr_stmt|;
name|diagnostic_set_info
argument_list|(
operator|&
name|diagnostic
argument_list|,
name|gmsgid
argument_list|,
operator|&
name|ap
argument_list|,
name|input_location
argument_list|,
name|DK_WARNING
argument_list|)
expr_stmt|;
name|diagnostic
operator|.
name|option_index
operator|=
name|opt
expr_stmt|;
name|report_diagnostic
argument_list|(
operator|&
name|diagnostic
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|warning0
parameter_list|(
specifier|const
name|char
modifier|*
name|gmsgid
parameter_list|,
modifier|...
parameter_list|)
block|{
name|diagnostic_info
name|diagnostic
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|gmsgid
argument_list|)
expr_stmt|;
name|diagnostic_set_info
argument_list|(
operator|&
name|diagnostic
argument_list|,
name|gmsgid
argument_list|,
operator|&
name|ap
argument_list|,
name|input_location
argument_list|,
name|DK_WARNING
argument_list|)
expr_stmt|;
name|report_diagnostic
argument_list|(
operator|&
name|diagnostic
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A "pedantic" warning: issues a warning unless -pedantic-errors was    given on the command line, in which case it issues an error.  Use    this for diagnostics required by the relevant language standard,    if you have chosen not to make them errors.     Note that these diagnostics are issued independent of the setting    of the -pedantic command-line switch.  To get a warning enabled    only with that switch, write "if (pedantic) pedwarn (...);"  */
end_comment

begin_function
name|void
name|pedwarn
parameter_list|(
specifier|const
name|char
modifier|*
name|gmsgid
parameter_list|,
modifier|...
parameter_list|)
block|{
name|diagnostic_info
name|diagnostic
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|gmsgid
argument_list|)
expr_stmt|;
name|diagnostic_set_info
argument_list|(
operator|&
name|diagnostic
argument_list|,
name|gmsgid
argument_list|,
operator|&
name|ap
argument_list|,
name|input_location
argument_list|,
name|pedantic_error_kind
argument_list|()
argument_list|)
expr_stmt|;
name|report_diagnostic
argument_list|(
operator|&
name|diagnostic
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A hard error: the code is definitely ill-formed, and an object file    will not be produced.  */
end_comment

begin_function
name|void
name|error
parameter_list|(
specifier|const
name|char
modifier|*
name|gmsgid
parameter_list|,
modifier|...
parameter_list|)
block|{
name|diagnostic_info
name|diagnostic
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|gmsgid
argument_list|)
expr_stmt|;
name|diagnostic_set_info
argument_list|(
operator|&
name|diagnostic
argument_list|,
name|gmsgid
argument_list|,
operator|&
name|ap
argument_list|,
name|input_location
argument_list|,
name|DK_ERROR
argument_list|)
expr_stmt|;
name|report_diagnostic
argument_list|(
operator|&
name|diagnostic
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* "Sorry, not implemented."  Use for a language feature which is    required by the relevant specification but not implemented by GCC.    An object file will not be produced.  */
end_comment

begin_function
name|void
name|sorry
parameter_list|(
specifier|const
name|char
modifier|*
name|gmsgid
parameter_list|,
modifier|...
parameter_list|)
block|{
name|diagnostic_info
name|diagnostic
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|gmsgid
argument_list|)
expr_stmt|;
name|diagnostic_set_info
argument_list|(
operator|&
name|diagnostic
argument_list|,
name|gmsgid
argument_list|,
operator|&
name|ap
argument_list|,
name|input_location
argument_list|,
name|DK_SORRY
argument_list|)
expr_stmt|;
name|report_diagnostic
argument_list|(
operator|&
name|diagnostic
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* An error which is severe enough that we make no attempt to    continue.  Do not use this for internal consistency checks; that's    internal_error.  Use of this function should be rare.  */
end_comment

begin_function
name|void
name|fatal_error
parameter_list|(
specifier|const
name|char
modifier|*
name|gmsgid
parameter_list|,
modifier|...
parameter_list|)
block|{
name|diagnostic_info
name|diagnostic
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|gmsgid
argument_list|)
expr_stmt|;
name|diagnostic_set_info
argument_list|(
operator|&
name|diagnostic
argument_list|,
name|gmsgid
argument_list|,
operator|&
name|ap
argument_list|,
name|input_location
argument_list|,
name|DK_FATAL
argument_list|)
expr_stmt|;
name|report_diagnostic
argument_list|(
operator|&
name|diagnostic
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* An internal consistency check has failed.  We make no attempt to    continue.  Note that unless there is debugging value to be had from    a more specific message, or some other good reason, you should use    abort () instead of calling this function directly.  */
end_comment

begin_function
name|void
name|internal_error
parameter_list|(
specifier|const
name|char
modifier|*
name|gmsgid
parameter_list|,
modifier|...
parameter_list|)
block|{
name|diagnostic_info
name|diagnostic
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|gmsgid
argument_list|)
expr_stmt|;
name|diagnostic_set_info
argument_list|(
operator|&
name|diagnostic
argument_list|,
name|gmsgid
argument_list|,
operator|&
name|ap
argument_list|,
name|input_location
argument_list|,
name|DK_ICE
argument_list|)
expr_stmt|;
name|report_diagnostic
argument_list|(
operator|&
name|diagnostic
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Special case error functions.  Most are implemented in terms of the    above, or should be.  */
end_comment

begin_comment
comment|/* Print a diagnostic MSGID on FILE.  This is just fprintf, except it    runs its second argument through gettext.  */
end_comment

begin_function
name|void
name|fnotice
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
specifier|const
name|char
modifier|*
name|cmsgid
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|cmsgid
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
name|cmsgid
argument_list|)
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Inform the user that an error occurred while trying to report some    other error.  This indicates catastrophic internal inconsistencies,    so give up now.  But do try to flush out the previous error.    This mustn't use internal_error, that will cause infinite recursion.  */
end_comment

begin_function
specifier|static
name|void
name|error_recursion
parameter_list|(
name|diagnostic_context
modifier|*
name|context
parameter_list|)
block|{
name|diagnostic_info
name|diagnostic
decl_stmt|;
if|if
condition|(
name|context
operator|->
name|lock
operator|<
literal|3
condition|)
name|pp_flush
argument_list|(
name|context
operator|->
name|printer
argument_list|)
expr_stmt|;
name|fnotice
argument_list|(
name|stderr
argument_list|,
literal|"Internal compiler error: Error reporting routines re-entered.\n"
argument_list|)
expr_stmt|;
comment|/* Call diagnostic_action_after_output to get the "please submit a bug      report" message.  It only looks at the kind field of diagnostic_info.  */
name|diagnostic
operator|.
name|kind
operator|=
name|DK_ICE
expr_stmt|;
name|diagnostic_action_after_output
argument_list|(
name|context
argument_list|,
operator|&
name|diagnostic
argument_list|)
expr_stmt|;
comment|/* Do not use gcc_unreachable here; that goes through internal_error      and therefore would cause infinite recursion.  */
name|real_abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Report an internal compiler error in a friendly manner.  This is    the function that gets called upon use of abort() in the source    code generally, thanks to a special macro.  */
end_comment

begin_function
name|void
name|fancy_abort
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|function
parameter_list|)
block|{
name|internal_error
argument_list|(
literal|"in %s, at %s:%d"
argument_list|,
name|function
argument_list|,
name|trim_filename
argument_list|(
name|file
argument_list|)
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Really call the system 'abort'.  This has to go right at the end of    this file, so that there are no functions after it that call abort    and get the system abort instead of our macro.  */
end_comment

begin_undef
undef|#
directive|undef
name|abort
end_undef

begin_function
specifier|static
name|void
name|real_abort
parameter_list|(
name|void
parameter_list|)
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

end_unit

