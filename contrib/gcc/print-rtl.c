begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Print RTL for GCC.    Copyright (C) 1987, 1988, 1992, 1997, 1998, 1999, 2000, 2002, 2003,    2004, 2005    Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* This file is compiled twice: once for the generator programs,    once for the compiler.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|GENERATOR_FILE
end_ifdef

begin_include
include|#
directive|include
file|"bconfig.h"
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_comment
comment|/* These headers all define things which are not available in    generator programs.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|GENERATOR_FILE
end_ifndef

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|outfile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sawclose
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|indent
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|print_rtx
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* String printed at beginning of each RTL when it is dumped.    This string is set to ASM_COMMENT_START when the RTL is dumped in    the assembly output file.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|print_rtx_head
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means suppress output of instruction numbers and line number    notes in debugging dumps.    This must be defined here so that programs like gencodes can be linked.  */
end_comment

begin_decl_stmt
name|int
name|flag_dump_unnumbered
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means use simplified format without flags, modes, etc.  */
end_comment

begin_decl_stmt
name|int
name|flag_simple
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if we are dumping graphical description.  */
end_comment

begin_decl_stmt
name|int
name|dump_for_graph
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|GENERATOR_FILE
end_ifndef

begin_function
specifier|static
name|void
name|print_decl_name
parameter_list|(
name|FILE
modifier|*
name|outfile
parameter_list|,
name|tree
name|node
parameter_list|)
block|{
if|if
condition|(
name|DECL_NAME
argument_list|(
name|node
argument_list|)
condition|)
name|fputs
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|node
argument_list|)
argument_list|)
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|node
argument_list|)
operator|==
name|LABEL_DECL
operator|&&
name|LABEL_DECL_UID
argument_list|(
name|node
argument_list|)
operator|!=
operator|-
literal|1
condition|)
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"L."
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|LABEL_DECL_UID
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|char
name|c
init|=
name|TREE_CODE
argument_list|(
name|node
argument_list|)
operator|==
name|CONST_DECL
condition|?
literal|'C'
else|:
literal|'D'
decl_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"%c.%u"
argument_list|,
name|c
argument_list|,
name|DECL_UID
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|print_mem_expr
parameter_list|(
name|FILE
modifier|*
name|outfile
parameter_list|,
name|tree
name|expr
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
block|{
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
condition|)
name|print_mem_expr
argument_list|(
name|outfile
argument_list|,
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fputs
argument_list|(
literal|"<variable>"
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'.'
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|print_decl_name
argument_list|(
name|outfile
argument_list|,
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|INDIRECT_REF
condition|)
block|{
name|fputs
argument_list|(
literal|" (*"
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|print_mem_expr
argument_list|(
name|outfile
argument_list|,
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|")"
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|ALIGN_INDIRECT_REF
condition|)
block|{
name|fputs
argument_list|(
literal|" (A*"
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|print_mem_expr
argument_list|(
name|outfile
argument_list|,
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|")"
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|MISALIGNED_INDIRECT_REF
condition|)
block|{
name|fputs
argument_list|(
literal|" (M*"
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|print_mem_expr
argument_list|(
name|outfile
argument_list|,
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|")"
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|RESULT_DECL
condition|)
name|fputs
argument_list|(
literal|"<result>"
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
else|else
block|{
name|fputc
argument_list|(
literal|' '
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|print_decl_name
argument_list|(
name|outfile
argument_list|,
name|expr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Print IN_RTX onto OUTFILE.  This is the recursive part of printing.  */
end_comment

begin_function
specifier|static
name|void
name|print_rtx
parameter_list|(
name|rtx
name|in_rtx
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|int
name|j
decl_stmt|;
specifier|const
name|char
modifier|*
name|format_ptr
decl_stmt|;
name|int
name|is_insn
decl_stmt|;
if|if
condition|(
name|sawclose
condition|)
block|{
if|if
condition|(
name|flag_simple
condition|)
name|fputc
argument_list|(
literal|' '
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\n%s%*s"
argument_list|,
name|print_rtx_head
argument_list|,
name|indent
operator|*
literal|2
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|sawclose
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|in_rtx
operator|==
literal|0
condition|)
block|{
name|fputs
argument_list|(
literal|"(nil)"
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|sawclose
operator|=
literal|1
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|in_rtx
argument_list|)
operator|>
name|NUM_RTX_CODE
condition|)
block|{
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"(??? bad code %d\n)"
argument_list|,
name|GET_CODE
argument_list|(
name|in_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|sawclose
operator|=
literal|1
expr_stmt|;
return|return;
block|}
name|is_insn
operator|=
name|INSN_P
argument_list|(
name|in_rtx
argument_list|)
expr_stmt|;
comment|/* When printing in VCG format we write INSNs, NOTE, LABEL, and BARRIER      in separate nodes and therefore have to handle them special here.  */
if|if
condition|(
name|dump_for_graph
operator|&&
operator|(
name|is_insn
operator|||
name|NOTE_P
argument_list|(
name|in_rtx
argument_list|)
operator|||
name|LABEL_P
argument_list|(
name|in_rtx
argument_list|)
operator|||
name|BARRIER_P
argument_list|(
name|in_rtx
argument_list|)
operator|)
condition|)
block|{
name|i
operator|=
literal|3
expr_stmt|;
name|indent
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* Print name of expression code.  */
if|if
condition|(
name|flag_simple
operator|&&
name|GET_CODE
argument_list|(
name|in_rtx
argument_list|)
operator|==
name|CONST_INT
condition|)
name|fputc
argument_list|(
literal|'('
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"(%s"
argument_list|,
name|GET_RTX_NAME
argument_list|(
name|GET_CODE
argument_list|(
name|in_rtx
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|flag_simple
condition|)
block|{
if|if
condition|(
name|RTX_FLAG
argument_list|(
name|in_rtx
argument_list|,
name|in_struct
argument_list|)
condition|)
name|fputs
argument_list|(
literal|"/s"
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|RTX_FLAG
argument_list|(
name|in_rtx
argument_list|,
name|volatil
argument_list|)
condition|)
name|fputs
argument_list|(
literal|"/v"
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|RTX_FLAG
argument_list|(
name|in_rtx
argument_list|,
name|unchanging
argument_list|)
condition|)
name|fputs
argument_list|(
literal|"/u"
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|RTX_FLAG
argument_list|(
name|in_rtx
argument_list|,
name|frame_related
argument_list|)
condition|)
name|fputs
argument_list|(
literal|"/f"
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|RTX_FLAG
argument_list|(
name|in_rtx
argument_list|,
name|jump
argument_list|)
condition|)
name|fputs
argument_list|(
literal|"/j"
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|RTX_FLAG
argument_list|(
name|in_rtx
argument_list|,
name|call
argument_list|)
condition|)
name|fputs
argument_list|(
literal|"/c"
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|RTX_FLAG
argument_list|(
name|in_rtx
argument_list|,
name|return_val
argument_list|)
condition|)
name|fputs
argument_list|(
literal|"/i"
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
comment|/* Print REG_NOTE names for EXPR_LIST and INSN_LIST.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|in_rtx
argument_list|)
operator|==
name|EXPR_LIST
operator|||
name|GET_CODE
argument_list|(
name|in_rtx
argument_list|)
operator|==
name|INSN_LIST
condition|)
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|":%s"
argument_list|,
name|GET_REG_NOTE_NAME
argument_list|(
name|GET_MODE
argument_list|(
name|in_rtx
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* For other rtl, print the mode if it's not VOID.  */
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|in_rtx
argument_list|)
operator|!=
name|VOIDmode
condition|)
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|":%s"
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|GET_MODE
argument_list|(
name|in_rtx
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
ifndef|#
directive|ifndef
name|GENERATOR_FILE
if|if
condition|(
name|GET_CODE
argument_list|(
name|in_rtx
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|FLOAT_MODE_P
argument_list|(
name|GET_MODE
argument_list|(
name|in_rtx
argument_list|)
argument_list|)
condition|)
name|i
operator|=
literal|5
expr_stmt|;
endif|#
directive|endif
comment|/* Get the format string and skip the first elements if we have handled      them already.  */
name|format_ptr
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|in_rtx
argument_list|)
argument_list|)
operator|+
name|i
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|in_rtx
argument_list|)
argument_list|)
condition|;
name|i
operator|++
control|)
switch|switch
condition|(
operator|*
name|format_ptr
operator|++
condition|)
block|{
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
case|case
literal|'T'
case|:
name|str
operator|=
name|XTMPL
argument_list|(
name|in_rtx
argument_list|,
name|i
argument_list|)
expr_stmt|;
goto|goto
name|string
goto|;
case|case
literal|'S'
case|:
case|case
literal|'s'
case|:
name|str
operator|=
name|XSTR
argument_list|(
name|in_rtx
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|string
label|:
if|if
condition|(
name|str
operator|==
literal|0
condition|)
name|fputs
argument_list|(
name|dump_for_graph
condition|?
literal|" \\\"\\\""
else|:
literal|" \"\""
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|dump_for_graph
condition|)
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|" (\\\"%s\\\")"
argument_list|,
name|str
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|" (\"%s\")"
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
name|sawclose
operator|=
literal|1
expr_stmt|;
break|break;
comment|/* 0 indicates a field for internal use that should not be printed. 	   An exception is the third field of a NOTE, where it indicates 	   that the field has several different valid contents.  */
case|case
literal|'0'
case|:
if|if
condition|(
name|i
operator|==
literal|1
operator|&&
name|REG_P
argument_list|(
name|in_rtx
argument_list|)
condition|)
block|{
if|if
condition|(
name|REGNO
argument_list|(
name|in_rtx
argument_list|)
operator|!=
name|ORIGINAL_REGNO
argument_list|(
name|in_rtx
argument_list|)
condition|)
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|" [%d]"
argument_list|,
name|ORIGINAL_REGNO
argument_list|(
name|in_rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|GENERATOR_FILE
elseif|else
if|if
condition|(
name|i
operator|==
literal|1
operator|&&
name|GET_CODE
argument_list|(
name|in_rtx
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
block|{
name|int
name|flags
init|=
name|SYMBOL_REF_FLAGS
argument_list|(
name|in_rtx
argument_list|)
decl_stmt|;
if|if
condition|(
name|flags
condition|)
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|" [flags 0x%x]"
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|==
literal|2
operator|&&
name|GET_CODE
argument_list|(
name|in_rtx
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
block|{
name|tree
name|decl
init|=
name|SYMBOL_REF_DECL
argument_list|(
name|in_rtx
argument_list|)
decl_stmt|;
if|if
condition|(
name|decl
condition|)
name|print_node_brief
argument_list|(
name|outfile
argument_list|,
literal|""
argument_list|,
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
elseif|else
if|if
condition|(
name|i
operator|==
literal|4
operator|&&
name|NOTE_P
argument_list|(
name|in_rtx
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|in_rtx
argument_list|)
condition|)
block|{
case|case
name|NOTE_INSN_EH_REGION_BEG
case|:
case|case
name|NOTE_INSN_EH_REGION_END
case|:
if|if
condition|(
name|flag_dump_unnumbered
condition|)
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|" #"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|" %d"
argument_list|,
name|NOTE_EH_HANDLER
argument_list|(
name|in_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|sawclose
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|NOTE_INSN_BLOCK_BEG
case|:
case|case
name|NOTE_INSN_BLOCK_END
case|:
ifndef|#
directive|ifndef
name|GENERATOR_FILE
name|dump_addr
argument_list|(
name|outfile
argument_list|,
literal|" "
argument_list|,
name|NOTE_BLOCK
argument_list|(
name|in_rtx
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sawclose
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|NOTE_INSN_BASIC_BLOCK
case|:
block|{
ifndef|#
directive|ifndef
name|GENERATOR_FILE
name|basic_block
name|bb
init|=
name|NOTE_BASIC_BLOCK
argument_list|(
name|in_rtx
argument_list|)
decl_stmt|;
if|if
condition|(
name|bb
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|" [bb %d]"
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
case|case
name|NOTE_INSN_EXPECTED_VALUE
case|:
name|indent
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
operator|!
name|sawclose
condition|)
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|print_rtx
argument_list|(
name|NOTE_EXPECTED_VALUE
argument_list|(
name|in_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|indent
operator|-=
literal|2
expr_stmt|;
break|break;
case|case
name|NOTE_INSN_DELETED_LABEL
case|:
block|{
specifier|const
name|char
modifier|*
name|label
init|=
name|NOTE_DELETED_LABEL_NAME
argument_list|(
name|in_rtx
argument_list|)
decl_stmt|;
if|if
condition|(
name|label
condition|)
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|" (\"%s\")"
argument_list|,
name|label
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|" \"\""
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|NOTE_INSN_SWITCH_TEXT_SECTIONS
case|:
block|{
ifndef|#
directive|ifndef
name|GENERATOR_FILE
name|basic_block
name|bb
init|=
name|NOTE_BASIC_BLOCK
argument_list|(
name|in_rtx
argument_list|)
decl_stmt|;
if|if
condition|(
name|bb
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|" [bb %d]"
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
case|case
name|NOTE_INSN_VAR_LOCATION
case|:
ifndef|#
directive|ifndef
name|GENERATOR_FILE
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|" ("
argument_list|)
expr_stmt|;
name|print_mem_expr
argument_list|(
name|outfile
argument_list|,
name|NOTE_VAR_LOCATION_DECL
argument_list|(
name|in_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|print_rtx
argument_list|(
name|NOTE_VAR_LOCATION_LOC
argument_list|(
name|in_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
default|default:
block|{
specifier|const
name|char
modifier|*
specifier|const
name|str
init|=
name|X0STR
argument_list|(
name|in_rtx
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|in_rtx
argument_list|)
operator|<
literal|0
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|str
operator|==
literal|0
condition|)
name|fputs
argument_list|(
name|dump_for_graph
condition|?
literal|" \\\"\\\""
else|:
literal|" \"\""
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|dump_for_graph
condition|)
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|" (\\\"%s\\\")"
argument_list|,
name|str
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|" (\"%s\")"
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
break|break;
case|case
literal|'e'
case|:
name|do_e
label|:
name|indent
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
operator|!
name|sawclose
condition|)
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|print_rtx
argument_list|(
name|XEXP
argument_list|(
name|in_rtx
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|indent
operator|-=
literal|2
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
case|case
literal|'V'
case|:
name|indent
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|sawclose
condition|)
block|{
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\n%s%*s"
argument_list|,
name|print_rtx_head
argument_list|,
name|indent
operator|*
literal|2
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|sawclose
operator|=
literal|0
expr_stmt|;
block|}
name|fputs
argument_list|(
literal|" ["
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
name|XVEC
argument_list|(
name|in_rtx
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|indent
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|XVECLEN
argument_list|(
name|in_rtx
argument_list|,
name|i
argument_list|)
condition|)
name|sawclose
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|in_rtx
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|print_rtx
argument_list|(
name|XVECEXP
argument_list|(
name|in_rtx
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
name|indent
operator|-=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|sawclose
condition|)
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\n%s%*s"
argument_list|,
name|print_rtx_head
argument_list|,
name|indent
operator|*
literal|2
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"]"
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|sawclose
operator|=
literal|1
expr_stmt|;
name|indent
operator|-=
literal|2
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
if|if
condition|(
operator|!
name|flag_simple
condition|)
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|XWINT
argument_list|(
name|in_rtx
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|flag_simple
condition|)
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|" ["
name|HOST_WIDE_INT_PRINT_HEX
literal|"]"
argument_list|,
name|XWINT
argument_list|(
name|in_rtx
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
if|if
condition|(
name|i
operator|==
literal|4
operator|&&
name|INSN_P
argument_list|(
name|in_rtx
argument_list|)
condition|)
block|{
ifndef|#
directive|ifndef
name|GENERATOR_FILE
comment|/*  Pretty-print insn locators.  Ignore scoping as it is mostly 		redundant with line number information and do not print anything 		when there is no location information available.  */
if|if
condition|(
name|INSN_LOCATOR
argument_list|(
name|in_rtx
argument_list|)
operator|&&
name|insn_file
argument_list|(
name|in_rtx
argument_list|)
condition|)
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|" %s:%i"
argument_list|,
name|insn_file
argument_list|(
name|in_rtx
argument_list|)
argument_list|,
name|insn_line
argument_list|(
name|in_rtx
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|i
operator|==
literal|6
operator|&&
name|NOTE_P
argument_list|(
name|in_rtx
argument_list|)
condition|)
block|{
comment|/* This field is only used for NOTE_INSN_DELETED_LABEL, and 	       other times often contains garbage from INSN->NOTE death.  */
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|in_rtx
argument_list|)
operator|==
name|NOTE_INSN_DELETED_LABEL
condition|)
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|" %d"
argument_list|,
name|XINT
argument_list|(
name|in_rtx
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|value
init|=
name|XINT
argument_list|(
name|in_rtx
argument_list|,
name|i
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
ifndef|#
directive|ifndef
name|GENERATOR_FILE
if|if
condition|(
name|REG_P
argument_list|(
name|in_rtx
argument_list|)
operator|&&
name|value
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|" %d %s"
argument_list|,
name|REGNO
argument_list|(
name|in_rtx
argument_list|)
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|in_rtx
argument_list|)
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|REG_P
argument_list|(
name|in_rtx
argument_list|)
operator|&&
name|value
operator|<=
name|LAST_VIRTUAL_REGISTER
condition|)
block|{
if|if
condition|(
name|value
operator|==
name|VIRTUAL_INCOMING_ARGS_REGNUM
condition|)
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|" %d virtual-incoming-args"
argument_list|,
name|value
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|value
operator|==
name|VIRTUAL_STACK_VARS_REGNUM
condition|)
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|" %d virtual-stack-vars"
argument_list|,
name|value
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|value
operator|==
name|VIRTUAL_STACK_DYNAMIC_REGNUM
condition|)
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|" %d virtual-stack-dynamic"
argument_list|,
name|value
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|value
operator|==
name|VIRTUAL_OUTGOING_ARGS_REGNUM
condition|)
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|" %d virtual-outgoing-args"
argument_list|,
name|value
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|value
operator|==
name|VIRTUAL_CFA_REGNUM
condition|)
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|" %d virtual-cfa"
argument_list|,
name|value
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|" %d virtual-reg-%d"
argument_list|,
name|value
argument_list|,
name|value
operator|-
name|FIRST_VIRTUAL_REGISTER
argument_list|)
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
if|if
condition|(
name|flag_dump_unnumbered
operator|&&
operator|(
name|is_insn
operator|||
name|NOTE_P
argument_list|(
name|in_rtx
argument_list|)
operator|)
condition|)
name|fputc
argument_list|(
literal|'#'
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|" %d"
argument_list|,
name|value
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|GENERATOR_FILE
if|if
condition|(
name|REG_P
argument_list|(
name|in_rtx
argument_list|)
operator|&&
name|REG_ATTRS
argument_list|(
name|in_rtx
argument_list|)
condition|)
block|{
name|fputs
argument_list|(
literal|" ["
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|ORIGINAL_REGNO
argument_list|(
name|in_rtx
argument_list|)
operator|!=
name|REGNO
argument_list|(
name|in_rtx
argument_list|)
condition|)
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"orig:%i"
argument_list|,
name|ORIGINAL_REGNO
argument_list|(
name|in_rtx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|REG_EXPR
argument_list|(
name|in_rtx
argument_list|)
condition|)
name|print_mem_expr
argument_list|(
name|outfile
argument_list|,
name|REG_EXPR
argument_list|(
name|in_rtx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|REG_OFFSET
argument_list|(
name|in_rtx
argument_list|)
condition|)
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"+"
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|REG_OFFSET
argument_list|(
name|in_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|" ]"
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|is_insn
operator|&&
operator|&
name|INSN_CODE
argument_list|(
name|in_rtx
argument_list|)
operator|==
operator|&
name|XINT
argument_list|(
name|in_rtx
argument_list|,
name|i
argument_list|)
operator|&&
name|XINT
argument_list|(
name|in_rtx
argument_list|,
name|i
argument_list|)
operator|>=
literal|0
operator|&&
operator|(
name|name
operator|=
name|get_insn_name
argument_list|(
name|XINT
argument_list|(
name|in_rtx
argument_list|,
name|i
argument_list|)
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|" {%s}"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|sawclose
operator|=
literal|0
expr_stmt|;
block|}
break|break;
comment|/* Print NOTE_INSN names rather than integer codes.  */
case|case
literal|'n'
case|:
if|if
condition|(
name|XINT
argument_list|(
name|in_rtx
argument_list|,
name|i
argument_list|)
operator|>=
operator|(
name|int
operator|)
name|NOTE_INSN_BIAS
operator|&&
name|XINT
argument_list|(
name|in_rtx
argument_list|,
name|i
argument_list|)
operator|<
operator|(
name|int
operator|)
name|NOTE_INSN_MAX
condition|)
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|" %s"
argument_list|,
name|GET_NOTE_INSN_NAME
argument_list|(
name|XINT
argument_list|(
name|in_rtx
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|" %d"
argument_list|,
name|XINT
argument_list|(
name|in_rtx
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|sawclose
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
if|if
condition|(
name|XEXP
argument_list|(
name|in_rtx
argument_list|,
name|i
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|rtx
name|sub
init|=
name|XEXP
argument_list|(
name|in_rtx
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|enum
name|rtx_code
name|subc
init|=
name|GET_CODE
argument_list|(
name|sub
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|in_rtx
argument_list|)
operator|==
name|LABEL_REF
condition|)
block|{
if|if
condition|(
name|subc
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|sub
argument_list|)
operator|==
name|NOTE_INSN_DELETED_LABEL
condition|)
block|{
if|if
condition|(
name|flag_dump_unnumbered
condition|)
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|" [# deleted]"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|" [%d deleted]"
argument_list|,
name|INSN_UID
argument_list|(
name|sub
argument_list|)
argument_list|)
expr_stmt|;
name|sawclose
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|subc
operator|!=
name|CODE_LABEL
condition|)
goto|goto
name|do_e
goto|;
block|}
if|if
condition|(
name|flag_dump_unnumbered
condition|)
name|fputs
argument_list|(
literal|" #"
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|" %d"
argument_list|,
name|INSN_UID
argument_list|(
name|sub
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|fputs
argument_list|(
literal|" 0"
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|sawclose
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
ifndef|#
directive|ifndef
name|GENERATOR_FILE
if|if
condition|(
name|XBITMAP
argument_list|(
name|in_rtx
argument_list|,
name|i
argument_list|)
operator|==
name|NULL
condition|)
name|fputs
argument_list|(
literal|" {null}"
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
else|else
name|bitmap_print
argument_list|(
name|outfile
argument_list|,
name|XBITMAP
argument_list|(
name|in_rtx
argument_list|,
name|i
argument_list|)
argument_list|,
literal|" {"
argument_list|,
literal|"}"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sawclose
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
ifndef|#
directive|ifndef
name|GENERATOR_FILE
name|dump_addr
argument_list|(
name|outfile
argument_list|,
literal|" "
argument_list|,
name|XTREE
argument_list|(
name|in_rtx
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|'*'
case|:
name|fputs
argument_list|(
literal|" Unknown"
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|sawclose
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
ifndef|#
directive|ifndef
name|GENERATOR_FILE
if|if
condition|(
name|XBBDEF
argument_list|(
name|in_rtx
argument_list|,
name|i
argument_list|)
condition|)
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|" %i"
argument_list|,
name|XBBDEF
argument_list|(
name|in_rtx
argument_list|,
name|i
argument_list|)
operator|->
name|index
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|in_rtx
argument_list|)
condition|)
block|{
ifndef|#
directive|ifndef
name|GENERATOR_FILE
case|case
name|MEM
case|:
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|" ["
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|MEM_ALIAS_SET
argument_list|(
name|in_rtx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|MEM_EXPR
argument_list|(
name|in_rtx
argument_list|)
condition|)
name|print_mem_expr
argument_list|(
name|outfile
argument_list|,
name|MEM_EXPR
argument_list|(
name|in_rtx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|MEM_OFFSET
argument_list|(
name|in_rtx
argument_list|)
condition|)
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"+"
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|INTVAL
argument_list|(
name|MEM_OFFSET
argument_list|(
name|in_rtx
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|MEM_SIZE
argument_list|(
name|in_rtx
argument_list|)
condition|)
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|" S"
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|INTVAL
argument_list|(
name|MEM_SIZE
argument_list|(
name|in_rtx
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|MEM_ALIGN
argument_list|(
name|in_rtx
argument_list|)
operator|!=
literal|1
condition|)
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|" A%u"
argument_list|,
name|MEM_ALIGN
argument_list|(
name|in_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|']'
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONST_DOUBLE
case|:
if|if
condition|(
name|FLOAT_MODE_P
argument_list|(
name|GET_MODE
argument_list|(
name|in_rtx
argument_list|)
argument_list|)
condition|)
block|{
name|char
name|s
index|[
literal|60
index|]
decl_stmt|;
name|real_to_decimal
argument_list|(
name|s
argument_list|,
name|CONST_DOUBLE_REAL_VALUE
argument_list|(
name|in_rtx
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|s
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|" %s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|real_to_hexadecimal
argument_list|(
name|s
argument_list|,
name|CONST_DOUBLE_REAL_VALUE
argument_list|(
name|in_rtx
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|s
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|" [%s]"
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
case|case
name|CODE_LABEL
case|:
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|" [%d uses]"
argument_list|,
name|LABEL_NUSES
argument_list|(
name|in_rtx
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|LABEL_KIND
argument_list|(
name|in_rtx
argument_list|)
condition|)
block|{
case|case
name|LABEL_NORMAL
case|:
break|break;
case|case
name|LABEL_STATIC_ENTRY
case|:
name|fputs
argument_list|(
literal|" [entry]"
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|LABEL_GLOBAL_ENTRY
case|:
name|fputs
argument_list|(
literal|" [global entry]"
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|LABEL_WEAK_ENTRY
case|:
name|fputs
argument_list|(
literal|" [weak entry]"
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
comment|/* APPLE LOCAL begin for-fsf-4_4 3274130 5295549 */
block|\
if|if
condition|(
name|LABEL_ALIGN_LOG
argument_list|(
name|in_rtx
argument_list|)
operator|>
literal|0
condition|)
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|" [log_align %u skip %u]"
argument_list|,
name|LABEL_ALIGN_LOG
argument_list|(
name|in_rtx
argument_list|)
argument_list|,
name|LABEL_MAX_SKIP
argument_list|(
name|in_rtx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* APPLE LOCAL end for-fsf-4_4 3274130 5295549 */
block|\
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|dump_for_graph
operator|&&
operator|(
name|is_insn
operator|||
name|NOTE_P
argument_list|(
name|in_rtx
argument_list|)
operator|||
name|LABEL_P
argument_list|(
name|in_rtx
argument_list|)
operator|||
name|BARRIER_P
argument_list|(
name|in_rtx
argument_list|)
operator|)
condition|)
name|sawclose
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|fputc
argument_list|(
literal|')'
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|sawclose
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print an rtx on the current line of FILE.  Initially indent IND    characters.  */
end_comment

begin_function
name|void
name|print_inline_rtx
parameter_list|(
name|FILE
modifier|*
name|outf
parameter_list|,
name|rtx
name|x
parameter_list|,
name|int
name|ind
parameter_list|)
block|{
name|int
name|oldsaw
init|=
name|sawclose
decl_stmt|;
name|int
name|oldindent
init|=
name|indent
decl_stmt|;
name|sawclose
operator|=
literal|0
expr_stmt|;
name|indent
operator|=
name|ind
expr_stmt|;
name|outfile
operator|=
name|outf
expr_stmt|;
name|print_rtx
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|sawclose
operator|=
name|oldsaw
expr_stmt|;
name|indent
operator|=
name|oldindent
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Call this function from the debugger to see what X looks like.  */
end_comment

begin_function
name|void
name|debug_rtx
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
name|outfile
operator|=
name|stderr
expr_stmt|;
name|sawclose
operator|=
literal|0
expr_stmt|;
name|print_rtx
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Count of rtx's to print with debug_rtx_list.    This global exists because gdb user defined commands have no arguments.  */
end_comment

begin_decl_stmt
name|int
name|debug_rtx_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 0 is treated as equivalent to 1 */
end_comment

begin_comment
comment|/* Call this function to print list from X on.     N is a count of the rtx's to print. Positive values print from the specified    rtx on.  Negative values print a window around the rtx.    EG: -5 prints 2 rtx's on either side (in addition to the specified rtx).  */
end_comment

begin_function
name|void
name|debug_rtx_list
parameter_list|(
name|rtx
name|x
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|count
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|count
operator|=
name|n
operator|==
literal|0
condition|?
literal|1
else|:
name|n
operator|<
literal|0
condition|?
operator|-
name|n
else|:
name|n
expr_stmt|;
comment|/* If we are printing a window, back up to the start.  */
if|if
condition|(
name|n
operator|<
literal|0
condition|)
for|for
control|(
name|i
operator|=
name|count
operator|/
literal|2
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|PREV_INSN
argument_list|(
name|x
argument_list|)
operator|==
literal|0
condition|)
break|break;
name|x
operator|=
name|PREV_INSN
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|count
operator|,
name|insn
operator|=
name|x
init|;
name|i
operator|>
literal|0
operator|&&
name|insn
operator|!=
literal|0
condition|;
name|i
operator|--
operator|,
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|debug_rtx
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Call this function to print an rtx list from START to END inclusive.  */
end_comment

begin_function
name|void
name|debug_rtx_range
parameter_list|(
name|rtx
name|start
parameter_list|,
name|rtx
name|end
parameter_list|)
block|{
while|while
condition|(
literal|1
condition|)
block|{
name|debug_rtx
argument_list|(
name|start
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|start
operator|||
name|start
operator|==
name|end
condition|)
break|break;
name|start
operator|=
name|NEXT_INSN
argument_list|(
name|start
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Call this function to search an rtx list to find one with insn uid UID,    and then call debug_rtx_list to print it, using DEBUG_RTX_COUNT.    The found insn is returned to enable further debugging analysis.  */
end_comment

begin_function
name|rtx
name|debug_rtx_find
parameter_list|(
name|rtx
name|x
parameter_list|,
name|int
name|uid
parameter_list|)
block|{
while|while
condition|(
name|x
operator|!=
literal|0
operator|&&
name|INSN_UID
argument_list|(
name|x
argument_list|)
operator|!=
name|uid
condition|)
name|x
operator|=
name|NEXT_INSN
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|!=
literal|0
condition|)
block|{
name|debug_rtx_list
argument_list|(
name|x
argument_list|,
name|debug_rtx_count
argument_list|)
expr_stmt|;
return|return
name|x
return|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"insn uid %d not found\n"
argument_list|,
name|uid
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* External entry point for printing a chain of insns    starting with RTX_FIRST onto file OUTF.    A blank line separates insns.     If RTX_FIRST is not an insn, then it alone is printed, with no newline.  */
end_comment

begin_function
name|void
name|print_rtl
parameter_list|(
name|FILE
modifier|*
name|outf
parameter_list|,
name|rtx
name|rtx_first
parameter_list|)
block|{
name|rtx
name|tmp_rtx
decl_stmt|;
name|outfile
operator|=
name|outf
expr_stmt|;
name|sawclose
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rtx_first
operator|==
literal|0
condition|)
block|{
name|fputs
argument_list|(
name|print_rtx_head
argument_list|,
name|outf
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"(nil)\n"
argument_list|,
name|outf
argument_list|)
expr_stmt|;
block|}
else|else
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|rtx_first
argument_list|)
condition|)
block|{
case|case
name|INSN
case|:
case|case
name|JUMP_INSN
case|:
case|case
name|CALL_INSN
case|:
case|case
name|NOTE
case|:
case|case
name|CODE_LABEL
case|:
case|case
name|BARRIER
case|:
for|for
control|(
name|tmp_rtx
operator|=
name|rtx_first
init|;
name|tmp_rtx
operator|!=
literal|0
condition|;
name|tmp_rtx
operator|=
name|NEXT_INSN
argument_list|(
name|tmp_rtx
argument_list|)
control|)
if|if
condition|(
operator|!
name|flag_dump_unnumbered
operator|||
operator|!
name|NOTE_P
argument_list|(
name|tmp_rtx
argument_list|)
operator|||
name|NOTE_LINE_NUMBER
argument_list|(
name|tmp_rtx
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fputs
argument_list|(
name|print_rtx_head
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|print_rtx
argument_list|(
name|tmp_rtx
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|fputs
argument_list|(
name|print_rtx_head
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|print_rtx
argument_list|(
name|rtx_first
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Like print_rtx, except specify a file.  */
end_comment

begin_comment
comment|/* Return nonzero if we actually printed anything.  */
end_comment

begin_function
name|int
name|print_rtl_single
parameter_list|(
name|FILE
modifier|*
name|outf
parameter_list|,
name|rtx
name|x
parameter_list|)
block|{
name|outfile
operator|=
name|outf
expr_stmt|;
name|sawclose
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|flag_dump_unnumbered
operator|||
operator|!
name|NOTE_P
argument_list|(
name|x
argument_list|)
operator|||
name|NOTE_LINE_NUMBER
argument_list|(
name|x
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fputs
argument_list|(
name|print_rtx_head
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|print_rtx
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|outf
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Like print_rtl except without all the detail; for example,    if RTX is a CONST_INT then print in decimal format.  */
end_comment

begin_function
name|void
name|print_simple_rtl
parameter_list|(
name|FILE
modifier|*
name|outf
parameter_list|,
name|rtx
name|x
parameter_list|)
block|{
name|flag_simple
operator|=
literal|1
expr_stmt|;
name|print_rtl
argument_list|(
name|outf
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|flag_simple
operator|=
literal|0
expr_stmt|;
block|}
end_function

end_unit

