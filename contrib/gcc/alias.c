begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Alias analysis for GNU C    Copyright (C) 1997, 1998, 1999, 2000 Free Software Foundation, Inc.    Contributed by John Carr (jfc@mit.edu).  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"splay-tree.h"
end_include

begin_comment
comment|/* The alias sets assigned to MEMs assist the back-end in determining    which MEMs can alias which other MEMs.  In general, two MEMs in    different alias sets to not alias each other.  There is one    exception, however.  Consider something like:       struct S {int i; double d; };     a store to an `S' can alias something of either type `int' or type    `double'.  (However, a store to an `int' cannot alias a `double'    and vice versa.)  We indicate this via a tree structure that looks    like:            struct S             /   \ 	   /     \          |/_     _\|          int    double     (The arrows are directed and point downwards.)  If, when comparing    two alias sets, we can hold one set fixed, and trace the other set    downwards, and at some point find the first set, the two MEMs can    alias one another.  In this situation we say the alias set for    `struct S' is the `superset' and that those for `int' and `double'    are `subsets'.       Alias set zero is implicitly a superset of all other alias sets.    However, this is no actual entry for alias set zero.  It is an    error to attempt to explicitly construct a subset of zero.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|alias_set_entry
block|{
comment|/* The alias set number, as stored in MEM_ALIAS_SET.  */
name|int
name|alias_set
decl_stmt|;
comment|/* The children of the alias set.  These are not just the immediate      children, but, in fact, all children.  So, if we have:         struct T { struct S s; float f; }        continuing our example above, the children here will be all of      `int', `double', `float', and `struct S'.  */
name|splay_tree
name|children
decl_stmt|;
block|}
typedef|*
name|alias_set_entry
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|rtx
name|canon_rtx
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|rtx_equal_for_memref_p
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|find_symbolic_term
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|memrefs_conflict_p
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|rtx
operator|,
name|int
operator|,
name|rtx
operator|,
name|HOST_WIDE_INT
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|record_set
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|find_base_term
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|base_alias_check
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
expr|enum
name|machine_mode
operator|,
expr|enum
name|machine_mode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|find_base_value
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mems_in_disjoint_alias_sets_p
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|insert_subset_children
name|PROTO
argument_list|(
operator|(
name|splay_tree_node
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|alias_set_entry
name|get_alias_set_entry
name|PROTO
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|fixed_scalar_and_varying_struct_p
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|int
argument_list|(
operator|*
argument_list|)
argument_list|(
name|rtx
argument_list|)
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|aliases_everything_p
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|write_dependence_p
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set up all info needed to perform alias analysis on memory references.  */
end_comment

begin_define
define|#
directive|define
name|SIZE_FOR_MODE
parameter_list|(
name|X
parameter_list|)
value|(GET_MODE_SIZE (GET_MODE (X)))
end_define

begin_comment
comment|/* Returns nonzero if MEM1 and MEM2 do not alias because they are in    different alias sets.  We ignore alias sets in functions making use    of variable arguments because the va_arg macros on some systems are    not legal ANSI C.  */
end_comment

begin_define
define|#
directive|define
name|DIFFERENT_ALIAS_SETS_P
parameter_list|(
name|MEM1
parameter_list|,
name|MEM2
parameter_list|)
define|\
value|mems_in_disjoint_alias_sets_p (MEM1, MEM2)
end_define

begin_comment
comment|/* Cap the number of passes we make over the insns propagating alias    information through set chains.     10 is a completely arbitrary choice.  */
end_comment

begin_define
define|#
directive|define
name|MAX_ALIAS_LOOP_PASSES
value|10
end_define

begin_comment
comment|/* reg_base_value[N] gives an address to which register N is related.    If all sets after the first add or subtract to the current value    or otherwise modify it so it does not point to a different top level    object, reg_base_value[N] is equal to the address part of the source    of the first set.     A base address can be an ADDRESS, SYMBOL_REF, or LABEL_REF.  ADDRESS    expressions represent certain special values: function arguments and    the stack, frame, and argument pointers.  The contents of an address    expression are not used (but they are descriptive for debugging);    only the address and mode matter.  Pointer equality, not rtx_equal_p,    determines whether two ADDRESS expressions refer to the same base    address.  The mode determines whether it is a function argument or    other special value. */
end_comment

begin_decl_stmt
name|rtx
modifier|*
name|reg_base_value
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
modifier|*
name|new_reg_base_value
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|int
name|reg_base_value_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* size of reg_base_value array */
end_comment

begin_define
define|#
directive|define
name|REG_BASE_VALUE
parameter_list|(
name|X
parameter_list|)
define|\
value|((unsigned) REGNO (X)< reg_base_value_size ? reg_base_value[REGNO (X)] : 0)
end_define

begin_comment
comment|/* Vector of known invariant relationships between registers.  Set in    loop unrolling.  Indexed by register number, if nonzero the value    is an expression describing this register in terms of another.     The length of this array is REG_BASE_VALUE_SIZE.     Because this array contains only pseudo registers it has no effect    after reload.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
modifier|*
name|alias_invariant
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Vector indexed by N giving the initial (unchanging) value known    for pseudo-register N.  */
end_comment

begin_decl_stmt
name|rtx
modifier|*
name|reg_known_value
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indicates number of valid entries in reg_known_value.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|reg_known_value_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Vector recording for each reg_known_value whether it is due to a    REG_EQUIV note.  Future passes (viz., reload) may replace the    pseudo with the equivalent expression and so we account for the    dependences that would be introduced if that happens. */
end_comment

begin_comment
comment|/* ??? This is a problem only on the Convex.  The REG_EQUIV notes created in    assign_parms mention the arg pointer, and there are explicit insns in the    RTL that modify the arg pointer.  Thus we must ensure that such insns don't    get scheduled across each other because that would invalidate the REG_EQUIV    notes.  One could argue that the REG_EQUIV notes are wrong, but solving    the problem in the scheduler will likely give better code, so we do it    here.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|reg_known_equiv_p
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* True when scanning insns from the start of the rtl to the    NOTE_INSN_FUNCTION_BEG note.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|copying_arguments
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The splay-tree used to store the various alias set entries.  */
end_comment

begin_decl_stmt
specifier|static
name|splay_tree
name|alias_sets
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Returns a pointer to the alias set entry for ALIAS_SET, if there is    such an entry, or NULL otherwise.  */
end_comment

begin_function
specifier|static
name|alias_set_entry
name|get_alias_set_entry
parameter_list|(
name|alias_set
parameter_list|)
name|int
name|alias_set
decl_stmt|;
block|{
name|splay_tree_node
name|sn
init|=
name|splay_tree_lookup
argument_list|(
name|alias_sets
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|alias_set
argument_list|)
decl_stmt|;
return|return
name|sn
condition|?
operator|(
operator|(
name|alias_set_entry
operator|)
name|sn
operator|->
name|value
operator|)
else|:
operator|(
operator|(
name|alias_set_entry
operator|)
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Returns nonzero value if the alias sets for MEM1 and MEM2 are such    that the two MEMs cannot alias each other.  */
end_comment

begin_function
specifier|static
name|int
name|mems_in_disjoint_alias_sets_p
parameter_list|(
name|mem1
parameter_list|,
name|mem2
parameter_list|)
name|rtx
name|mem1
decl_stmt|;
name|rtx
name|mem2
decl_stmt|;
block|{
name|alias_set_entry
name|ase
decl_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
comment|/* Perform a basic sanity check.  Namely, that there are no alias sets    if we're not using strict aliasing.  This helps to catch bugs    whereby someone uses PUT_CODE, but doesn't clear MEM_ALIAS_SET, or    where a MEM is allocated in some way other than by the use of    gen_rtx_MEM, and the MEM_ALIAS_SET is not cleared.  If we begin to    use alias sets to indicate that spilled registers cannot alias each    other, we might need to remove this check.  */
if|if
condition|(
operator|!
name|flag_strict_aliasing
operator|&&
operator|(
name|MEM_ALIAS_SET
argument_list|(
name|mem1
argument_list|)
operator|||
name|MEM_ALIAS_SET
argument_list|(
name|mem2
argument_list|)
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* The code used in varargs macros are often not conforming ANSI C,      which can trick the compiler into making incorrect aliasing      assumptions in these functions.  So, we don't use alias sets in      such a function.  FIXME: This should be moved into the front-end;      it is a language-dependent notion, and there's no reason not to      still use these checks to handle globals.  */
if|if
condition|(
name|current_function_stdarg
operator|||
name|current_function_varargs
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|MEM_ALIAS_SET
argument_list|(
name|mem1
argument_list|)
operator|||
operator|!
name|MEM_ALIAS_SET
argument_list|(
name|mem2
argument_list|)
condition|)
comment|/* We have no alias set information for one of the MEMs, so we        have to assume it can alias anything.  */
return|return
literal|0
return|;
if|if
condition|(
name|MEM_ALIAS_SET
argument_list|(
name|mem1
argument_list|)
operator|==
name|MEM_ALIAS_SET
argument_list|(
name|mem2
argument_list|)
condition|)
comment|/* The two alias sets are the same, so they may alias.  */
return|return
literal|0
return|;
comment|/* Iterate through each of the children of the first alias set,      comparing it with the second alias set.  */
name|ase
operator|=
name|get_alias_set_entry
argument_list|(
name|MEM_ALIAS_SET
argument_list|(
name|mem1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ase
operator|&&
name|splay_tree_lookup
argument_list|(
name|ase
operator|->
name|children
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|MEM_ALIAS_SET
argument_list|(
name|mem2
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Now do the same, but with the alias sets reversed.  */
name|ase
operator|=
name|get_alias_set_entry
argument_list|(
name|MEM_ALIAS_SET
argument_list|(
name|mem2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ase
operator|&&
name|splay_tree_lookup
argument_list|(
name|ase
operator|->
name|children
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|MEM_ALIAS_SET
argument_list|(
name|mem1
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* The two MEMs are in distinct alias sets, and neither one is the      child of the other.  Therefore, they cannot alias.  */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Insert the NODE into the splay tree given by DATA.  Used by    record_alias_subset via splay_tree_foreach.  */
end_comment

begin_function
specifier|static
name|int
name|insert_subset_children
parameter_list|(
name|node
parameter_list|,
name|data
parameter_list|)
name|splay_tree_node
name|node
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
name|splay_tree_insert
argument_list|(
operator|(
name|splay_tree
operator|)
name|data
argument_list|,
name|node
operator|->
name|key
argument_list|,
name|node
operator|->
name|value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Indicate that things in SUBSET can alias things in SUPERSET, but    not vice versa.  For example, in C, a store to an `int' can alias a    structure containing an `int', but not vice versa.  Here, the    structure would be the SUPERSET and `int' the SUBSET.  This    function should be called only once per SUPERSET/SUBSET pair.  At    present any given alias set may only be a subset of one superset.       It is illegal for SUPERSET to be zero; everything is implicitly a    subset of alias set zero.  */
end_comment

begin_function
name|void
name|record_alias_subset
parameter_list|(
name|superset
parameter_list|,
name|subset
parameter_list|)
name|int
name|superset
decl_stmt|;
name|int
name|subset
decl_stmt|;
block|{
name|alias_set_entry
name|superset_entry
decl_stmt|;
name|alias_set_entry
name|subset_entry
decl_stmt|;
if|if
condition|(
name|superset
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|superset_entry
operator|=
name|get_alias_set_entry
argument_list|(
name|superset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|superset_entry
condition|)
block|{
comment|/* Create an entry for the SUPERSET, so that we have a place to 	 attach the SUBSET.  */
name|superset_entry
operator|=
operator|(
name|alias_set_entry
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|alias_set_entry
argument_list|)
argument_list|)
expr_stmt|;
name|superset_entry
operator|->
name|alias_set
operator|=
name|superset
expr_stmt|;
name|superset_entry
operator|->
name|children
operator|=
name|splay_tree_new
argument_list|(
name|splay_tree_compare_ints
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|splay_tree_insert
argument_list|(
name|alias_sets
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|superset
argument_list|,
operator|(
name|splay_tree_value
operator|)
name|superset_entry
argument_list|)
expr_stmt|;
block|}
name|subset_entry
operator|=
name|get_alias_set_entry
argument_list|(
name|subset
argument_list|)
expr_stmt|;
if|if
condition|(
name|subset_entry
condition|)
comment|/* There is an entry for the subset.  Enter all of its children        (if they are not already present) as children of the SUPERSET.  */
name|splay_tree_foreach
argument_list|(
name|subset_entry
operator|->
name|children
argument_list|,
name|insert_subset_children
argument_list|,
name|superset_entry
operator|->
name|children
argument_list|)
expr_stmt|;
comment|/* Enter the SUBSET itself as a child of the SUPERSET.  */
name|splay_tree_insert
argument_list|(
name|superset_entry
operator|->
name|children
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|subset
argument_list|,
comment|/*value=*/
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Inside SRC, the source of a SET, find a base address.  */
end_comment

begin_function
specifier|static
name|rtx
name|find_base_value
parameter_list|(
name|src
parameter_list|)
specifier|register
name|rtx
name|src
decl_stmt|;
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
condition|)
block|{
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
return|return
name|src
return|;
case|case
name|REG
case|:
comment|/* At the start of a function argument registers have known base 	 values which may be lost later.  Returning an ADDRESS 	 expression here allows optimization based on argument values 	 even when the argument registers are used for other purposes.  */
if|if
condition|(
name|REGNO
argument_list|(
name|src
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|copying_arguments
condition|)
return|return
name|new_reg_base_value
index|[
name|REGNO
argument_list|(
name|src
argument_list|)
index|]
return|;
comment|/* If a pseudo has a known base value, return it.  Do not do this 	 for hard regs since it can result in a circular dependency 	 chain for registers which have values at function entry.  	 The test above is not sufficient because the scheduler may move 	 a copy out of an arg reg past the NOTE_INSN_FUNCTION_BEGIN.  */
if|if
condition|(
name|REGNO
argument_list|(
name|src
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
operator|(
name|unsigned
operator|)
name|REGNO
argument_list|(
name|src
argument_list|)
operator|<
name|reg_base_value_size
operator|&&
name|reg_base_value
index|[
name|REGNO
argument_list|(
name|src
argument_list|)
index|]
condition|)
return|return
name|reg_base_value
index|[
name|REGNO
argument_list|(
name|src
argument_list|)
index|]
return|;
return|return
name|src
return|;
case|case
name|MEM
case|:
comment|/* Check for an argument passed in memory.  Only record in the 	 copying-arguments block; it is too hard to track changes 	 otherwise.  */
if|if
condition|(
name|copying_arguments
operator|&&
operator|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
operator|==
name|arg_pointer_rtx
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|arg_pointer_rtx
operator|)
operator|)
condition|)
return|return
name|gen_rtx_ADDRESS
argument_list|(
name|VOIDmode
argument_list|,
name|src
argument_list|)
return|;
return|return
literal|0
return|;
case|case
name|CONST
case|:
name|src
operator|=
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|!=
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|!=
name|MINUS
condition|)
break|break;
comment|/* fall through */
case|case
name|PLUS
case|:
case|case
name|MINUS
case|:
block|{
name|rtx
name|temp
decl_stmt|,
name|src_0
init|=
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
decl_stmt|,
name|src_1
init|=
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|/* If either operand is a REG, then see if we already have 	   a known value for it.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|src_0
argument_list|)
operator|==
name|REG
condition|)
block|{
name|temp
operator|=
name|find_base_value
argument_list|(
name|src_0
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
condition|)
name|src_0
operator|=
name|temp
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|src_1
argument_list|)
operator|==
name|REG
condition|)
block|{
name|temp
operator|=
name|find_base_value
argument_list|(
name|src_1
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
condition|)
name|src_1
operator|=
name|temp
expr_stmt|;
block|}
comment|/* Guess which operand is the base address.  	   If either operand is a symbol, then it is the base.  If 	   either operand is a CONST_INT, then the other is the base.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|src_1
argument_list|)
operator|==
name|CONST_INT
operator|||
name|GET_CODE
argument_list|(
name|src_0
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|src_0
argument_list|)
operator|==
name|LABEL_REF
operator|||
name|GET_CODE
argument_list|(
name|src_0
argument_list|)
operator|==
name|CONST
condition|)
return|return
name|find_base_value
argument_list|(
name|src_0
argument_list|)
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|src_0
argument_list|)
operator|==
name|CONST_INT
operator|||
name|GET_CODE
argument_list|(
name|src_1
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|src_1
argument_list|)
operator|==
name|LABEL_REF
operator|||
name|GET_CODE
argument_list|(
name|src_1
argument_list|)
operator|==
name|CONST
condition|)
return|return
name|find_base_value
argument_list|(
name|src_1
argument_list|)
return|;
comment|/* This might not be necessary anymore.   	   If either operand is a REG that is a known pointer, then it 	   is the base.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|src_0
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO_POINTER_FLAG
argument_list|(
name|REGNO
argument_list|(
name|src_0
argument_list|)
argument_list|)
condition|)
return|return
name|find_base_value
argument_list|(
name|src_0
argument_list|)
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|src_1
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO_POINTER_FLAG
argument_list|(
name|REGNO
argument_list|(
name|src_1
argument_list|)
argument_list|)
condition|)
return|return
name|find_base_value
argument_list|(
name|src_1
argument_list|)
return|;
return|return
literal|0
return|;
block|}
case|case
name|LO_SUM
case|:
comment|/* The standard form is (lo_sum reg sym) so look only at the 	 second operand.  */
return|return
name|find_base_value
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
case|case
name|AND
case|:
comment|/* If the second operand is constant set the base 	 address to the first operand. */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|find_base_value
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
return|return
literal|0
return|;
case|case
name|ZERO_EXTEND
case|:
case|case
name|SIGN_EXTEND
case|:
comment|/* used for NT/Alpha pointers */
case|case
name|HIGH
case|:
return|return
name|find_base_value
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
default|default:
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Called from init_alias_analysis indirectly through note_stores.  */
end_comment

begin_comment
comment|/* while scanning insns to find base values, reg_seen[N] is nonzero if    register N has been set in this function.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|reg_seen
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Addresses which are known not to alias anything else are identified    by a unique integer.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|unique_id
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|record_set
parameter_list|(
name|dest
parameter_list|,
name|set
parameter_list|)
name|rtx
name|dest
decl_stmt|,
name|set
decl_stmt|;
block|{
specifier|register
name|int
name|regno
decl_stmt|;
name|rtx
name|src
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|!=
name|REG
condition|)
return|return;
name|regno
operator|=
name|REGNO
argument_list|(
name|dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|set
condition|)
block|{
comment|/* A CLOBBER wipes out any old value but does not prevent a previously 	 unset register from acquiring a base address (i.e. reg_seen is not 	 set).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|set
argument_list|)
operator|==
name|CLOBBER
condition|)
block|{
name|new_reg_base_value
index|[
name|regno
index|]
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|src
operator|=
name|SET_SRC
argument_list|(
name|set
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|reg_seen
index|[
name|regno
index|]
condition|)
block|{
name|new_reg_base_value
index|[
name|regno
index|]
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|reg_seen
index|[
name|regno
index|]
operator|=
literal|1
expr_stmt|;
name|new_reg_base_value
index|[
name|regno
index|]
operator|=
name|gen_rtx_ADDRESS
argument_list|(
name|Pmode
argument_list|,
name|GEN_INT
argument_list|(
name|unique_id
operator|++
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* This is not the first set.  If the new value is not related to the      old value, forget the base value. Note that the following code is      not detected:      extern int x, y;  int *p =&x; p += (&y-&x);      ANSI C does not allow computing the difference of addresses      of distinct top level objects.  */
if|if
condition|(
name|new_reg_base_value
index|[
name|regno
index|]
condition|)
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
condition|)
block|{
case|case
name|LO_SUM
case|:
case|case
name|PLUS
case|:
case|case
name|MINUS
case|:
if|if
condition|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
operator|!=
name|dest
operator|&&
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
operator|!=
name|dest
condition|)
name|new_reg_base_value
index|[
name|regno
index|]
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|AND
case|:
if|if
condition|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
operator|!=
name|dest
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
condition|)
name|new_reg_base_value
index|[
name|regno
index|]
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|new_reg_base_value
index|[
name|regno
index|]
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* If this is the first set of a register, record the value.  */
elseif|else
if|if
condition|(
operator|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|||
operator|!
name|fixed_regs
index|[
name|regno
index|]
operator|)
operator|&&
operator|!
name|reg_seen
index|[
name|regno
index|]
operator|&&
name|new_reg_base_value
index|[
name|regno
index|]
operator|==
literal|0
condition|)
name|new_reg_base_value
index|[
name|regno
index|]
operator|=
name|find_base_value
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|reg_seen
index|[
name|regno
index|]
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called from loop optimization when a new pseudo-register is created.  */
end_comment

begin_function
name|void
name|record_base_value
parameter_list|(
name|regno
parameter_list|,
name|val
parameter_list|,
name|invariant
parameter_list|)
name|int
name|regno
decl_stmt|;
name|rtx
name|val
decl_stmt|;
name|int
name|invariant
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|unsigned
operator|)
name|regno
operator|>=
name|reg_base_value_size
condition|)
return|return;
comment|/* If INVARIANT is true then this value also describes an invariant      relationship which can be used to deduce that two registers with      unknown values are different.  */
if|if
condition|(
name|invariant
operator|&&
name|alias_invariant
condition|)
name|alias_invariant
index|[
name|regno
index|]
operator|=
name|val
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|val
argument_list|)
operator|==
name|REG
condition|)
block|{
if|if
condition|(
operator|(
name|unsigned
operator|)
name|REGNO
argument_list|(
name|val
argument_list|)
operator|<
name|reg_base_value_size
condition|)
block|{
name|reg_base_value
index|[
name|regno
index|]
operator|=
name|reg_base_value
index|[
name|REGNO
argument_list|(
name|val
argument_list|)
index|]
expr_stmt|;
block|}
return|return;
block|}
name|reg_base_value
index|[
name|regno
index|]
operator|=
name|find_base_value
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|rtx
name|canon_rtx
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
comment|/* Recursively look for equivalences.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|x
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|REGNO
argument_list|(
name|x
argument_list|)
operator|<
name|reg_known_value_size
condition|)
return|return
name|reg_known_value
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
operator|==
name|x
condition|?
name|x
else|:
name|canon_rtx
argument_list|(
name|reg_known_value
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
argument_list|)
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|rtx
name|x0
init|=
name|canon_rtx
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|x1
init|=
name|canon_rtx
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|x0
operator|!=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|||
name|x1
operator|!=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
condition|)
block|{
comment|/* We can tolerate LO_SUMs being offset here; these 	     rtl are used for nothing other than comparisons.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x0
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|plus_constant_for_output
argument_list|(
name|x1
argument_list|,
name|INTVAL
argument_list|(
name|x0
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x1
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|plus_constant_for_output
argument_list|(
name|x0
argument_list|,
name|INTVAL
argument_list|(
name|x1
argument_list|)
argument_list|)
return|;
return|return
name|gen_rtx_PLUS
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|x0
argument_list|,
name|x1
argument_list|)
return|;
block|}
block|}
comment|/* This gives us much better alias analysis when called from      the loop optimizer.   Note we want to leave the original      MEM alone, but need to return the canonicalized MEM with      all the flags with their original values.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|rtx
name|addr
init|=
name|canon_rtx
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|addr
operator|!=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|rtx
name|new
init|=
name|gen_rtx_MEM
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|addr
argument_list|)
decl_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|new
argument_list|)
operator|=
name|RTX_UNCHANGING_P
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|MEM_COPY_ATTRIBUTES
argument_list|(
name|new
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|MEM_ALIAS_SET
argument_list|(
name|new
argument_list|)
operator|=
name|MEM_ALIAS_SET
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|x
operator|=
name|new
expr_stmt|;
block|}
block|}
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if X and Y are identical-looking rtx's.     We use the data in reg_known_value above to see if two registers with    different numbers are, in fact, equivalent.  */
end_comment

begin_function
specifier|static
name|int
name|rtx_equal_for_memref_p
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|y
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
specifier|register
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
operator|&&
name|y
operator|==
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|x
operator|==
literal|0
operator|||
name|y
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|x
operator|=
name|canon_rtx
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|y
operator|=
name|canon_rtx
argument_list|(
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|==
name|y
condition|)
return|return
literal|1
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* Rtx's of different codes cannot be equal.  */
if|if
condition|(
name|code
operator|!=
name|GET_CODE
argument_list|(
name|y
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* (MULT:SI x y) and (MULT:HI x y) are NOT equivalent.      (REG:SI x) and (REG:HI x) are NOT equivalent.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|y
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* REG, LABEL_REF, and SYMBOL_REF can be compared nonrecursively.  */
if|if
condition|(
name|code
operator|==
name|REG
condition|)
return|return
name|REGNO
argument_list|(
name|x
argument_list|)
operator|==
name|REGNO
argument_list|(
name|y
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|LABEL_REF
condition|)
return|return
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|SYMBOL_REF
condition|)
return|return
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|XSTR
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|CONST_INT
condition|)
return|return
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|==
name|INTVAL
argument_list|(
name|y
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|ADDRESSOF
condition|)
return|return
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|XINT
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|==
name|XINT
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
return|;
comment|/* For commutative operations, the RTX match if the operand match in any      order.  Also handle the simple binary and unary cases without a loop.  */
if|if
condition|(
name|code
operator|==
name|EQ
operator|||
name|code
operator|==
name|NE
operator|||
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'c'
condition|)
return|return
operator|(
operator|(
name|rtx_equal_for_memref_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|rtx_equal_for_memref_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|rtx_equal_for_memref_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|rtx_equal_for_memref_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|)
return|;
elseif|else
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'<'
operator|||
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'2'
condition|)
return|return
operator|(
name|rtx_equal_for_memref_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|rtx_equal_for_memref_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'1'
condition|)
return|return
name|rtx_equal_for_memref_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
comment|/* Compare the elements.  If any pair of corresponding elements      fail to match, return 0 for the whole things.       Limit cases to types which actually appear in addresses.  */
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
switch|switch
condition|(
name|fmt
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'i'
case|:
if|if
condition|(
name|XINT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
name|XINT
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'E'
case|:
comment|/* Two vectors must have the same length.  */
if|if
condition|(
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
name|XVECLEN
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* And the corresponding elements must match.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|rtx_equal_for_memref_p
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|XVECEXP
argument_list|(
name|y
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'e'
case|:
if|if
condition|(
name|rtx_equal_for_memref_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
break|break;
comment|/* This can happen for an asm which clobbers memory.  */
case|case
literal|'0'
case|:
break|break;
comment|/* It is believed that rtx's at this level will never 	     contain anything but integers and other rtx's, 	     except for within LABEL_REFs and SYMBOL_REFs.  */
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Given an rtx X, find a SYMBOL_REF or LABEL_REF within    X and return it, or return 0 if none found.  */
end_comment

begin_function
specifier|static
name|rtx
name|find_symbolic_term
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|SYMBOL_REF
operator|||
name|code
operator|==
name|LABEL_REF
condition|)
return|return
name|x
return|;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'o'
condition|)
return|return
literal|0
return|;
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|rtx
name|t
decl_stmt|;
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
name|t
operator|=
name|find_symbolic_term
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|!=
literal|0
condition|)
return|return
name|t
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|rtx
name|find_base_term
parameter_list|(
name|x
parameter_list|)
specifier|register
name|rtx
name|x
decl_stmt|;
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|REG
case|:
return|return
name|REG_BASE_VALUE
argument_list|(
name|x
argument_list|)
return|;
case|case
name|ZERO_EXTEND
case|:
case|case
name|SIGN_EXTEND
case|:
comment|/* Used for Alpha/NT pointers */
case|case
name|HIGH
case|:
case|case
name|PRE_INC
case|:
case|case
name|PRE_DEC
case|:
case|case
name|POST_INC
case|:
case|case
name|POST_DEC
case|:
return|return
name|find_base_term
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|CONST
case|:
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|MINUS
condition|)
return|return
literal|0
return|;
comment|/* fall through */
case|case
name|LO_SUM
case|:
case|case
name|PLUS
case|:
case|case
name|MINUS
case|:
block|{
name|rtx
name|tmp1
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|tmp2
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|/* This is a litle bit tricky since we have to determine which of 	   the two operands represents the real base address.  Otherwise this 	   routine may return the index register instead of the base register.  	   That may cause us to believe no aliasing was possible, when in 	   fact aliasing is possible.  	   We use a few simple tests to guess the base register.  Additional 	   tests can certainly be added.  For example, if one of the operands 	   is a shift or multiply, then it must be the index register and the 	   other operand is the base register.  */
comment|/* If either operand is known to be a pointer, then use it 	   to determine the base term.  */
if|if
condition|(
name|REG_P
argument_list|(
name|tmp1
argument_list|)
operator|&&
name|REGNO_POINTER_FLAG
argument_list|(
name|REGNO
argument_list|(
name|tmp1
argument_list|)
argument_list|)
condition|)
return|return
name|find_base_term
argument_list|(
name|tmp1
argument_list|)
return|;
if|if
condition|(
name|REG_P
argument_list|(
name|tmp2
argument_list|)
operator|&&
name|REGNO_POINTER_FLAG
argument_list|(
name|REGNO
argument_list|(
name|tmp2
argument_list|)
argument_list|)
condition|)
return|return
name|find_base_term
argument_list|(
name|tmp2
argument_list|)
return|;
comment|/* Neither operand was known to be a pointer.  Go ahead and find the 	   base term for both operands.  */
name|tmp1
operator|=
name|find_base_term
argument_list|(
name|tmp1
argument_list|)
expr_stmt|;
name|tmp2
operator|=
name|find_base_term
argument_list|(
name|tmp2
argument_list|)
expr_stmt|;
comment|/* If either base term is named object or a special address 	   (like an argument or stack reference), then use it for the 	   base term.  */
if|if
condition|(
name|tmp1
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|tmp1
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|tmp1
argument_list|)
operator|==
name|LABEL_REF
operator|||
operator|(
name|GET_CODE
argument_list|(
name|tmp1
argument_list|)
operator|==
name|ADDRESS
operator|&&
name|GET_MODE
argument_list|(
name|tmp1
argument_list|)
operator|!=
name|VOIDmode
operator|)
operator|)
condition|)
return|return
name|tmp1
return|;
if|if
condition|(
name|tmp2
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|tmp2
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|tmp2
argument_list|)
operator|==
name|LABEL_REF
operator|||
operator|(
name|GET_CODE
argument_list|(
name|tmp2
argument_list|)
operator|==
name|ADDRESS
operator|&&
name|GET_MODE
argument_list|(
name|tmp2
argument_list|)
operator|!=
name|VOIDmode
operator|)
operator|)
condition|)
return|return
name|tmp2
return|;
comment|/* We could not determine which of the two operands was the 	   base register and which was the index.  So we can determine 	   nothing from the base alias check.  */
return|return
literal|0
return|;
block|}
case|case
name|AND
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|REG_BASE_VALUE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
return|return
literal|0
return|;
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
return|return
name|x
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return 0 if the addresses X and Y are known to point to different    objects, 1 if they might be pointers to the same object.  */
end_comment

begin_function
specifier|static
name|int
name|base_alias_check
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|x_mode
parameter_list|,
name|y_mode
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|y
decl_stmt|;
name|enum
name|machine_mode
name|x_mode
decl_stmt|,
name|y_mode
decl_stmt|;
block|{
name|rtx
name|x_base
init|=
name|find_base_term
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|rtx
name|y_base
init|=
name|find_base_term
argument_list|(
name|y
argument_list|)
decl_stmt|;
comment|/* If the address itself has no known base see if a known equivalent      value has one.  If either address still has no known base, nothing      is known about aliasing.  */
if|if
condition|(
name|x_base
operator|==
literal|0
condition|)
block|{
name|rtx
name|x_c
decl_stmt|;
if|if
condition|(
operator|!
name|flag_expensive_optimizations
operator|||
operator|(
name|x_c
operator|=
name|canon_rtx
argument_list|(
name|x
argument_list|)
operator|)
operator|==
name|x
condition|)
return|return
literal|1
return|;
name|x_base
operator|=
name|find_base_term
argument_list|(
name|x_c
argument_list|)
expr_stmt|;
if|if
condition|(
name|x_base
operator|==
literal|0
condition|)
return|return
literal|1
return|;
block|}
if|if
condition|(
name|y_base
operator|==
literal|0
condition|)
block|{
name|rtx
name|y_c
decl_stmt|;
if|if
condition|(
operator|!
name|flag_expensive_optimizations
operator|||
operator|(
name|y_c
operator|=
name|canon_rtx
argument_list|(
name|y
argument_list|)
operator|)
operator|==
name|y
condition|)
return|return
literal|1
return|;
name|y_base
operator|=
name|find_base_term
argument_list|(
name|y_c
argument_list|)
expr_stmt|;
if|if
condition|(
name|y_base
operator|==
literal|0
condition|)
return|return
literal|1
return|;
block|}
comment|/* If the base addresses are equal nothing is known about aliasing.  */
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|x_base
argument_list|,
name|y_base
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* The base addresses of the read and write are different expressions.       If they are both symbols and they are not accessed via AND, there is      no conflict.  We can bring knowledge of object alignment into play      here.  For example, on alpha, "char a, b;" can alias one another,      though "char a; long b;" cannot.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x_base
argument_list|)
operator|!=
name|ADDRESS
operator|&&
name|GET_CODE
argument_list|(
name|y_base
argument_list|)
operator|!=
name|ADDRESS
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|AND
operator|&&
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|AND
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|AND
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
operator|||
name|GET_MODE_UNIT_SIZE
argument_list|(
name|y_mode
argument_list|)
operator|<
operator|-
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|AND
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
operator|||
name|GET_MODE_UNIT_SIZE
argument_list|(
name|x_mode
argument_list|)
operator|<
operator|-
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
condition|)
return|return
literal|1
return|;
comment|/* Differing symbols never alias.  */
return|return
literal|0
return|;
block|}
comment|/* If one address is a stack reference there can be no alias:      stack references using different base registers do not alias,      a stack reference can not alias a parameter, and a stack reference      can not alias a global.  */
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|x_base
argument_list|)
operator|==
name|ADDRESS
operator|&&
name|GET_MODE
argument_list|(
name|x_base
argument_list|)
operator|==
name|Pmode
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|y_base
argument_list|)
operator|==
name|ADDRESS
operator|&&
name|GET_MODE
argument_list|(
name|y_base
argument_list|)
operator|==
name|Pmode
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|flag_argument_noalias
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|flag_argument_noalias
operator|>
literal|1
condition|)
return|return
literal|0
return|;
comment|/* Weak noalias assertion (arguments are distinct, but may match globals). */
return|return
operator|!
operator|(
name|GET_MODE
argument_list|(
name|x_base
argument_list|)
operator|==
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|y_base
argument_list|)
operator|==
name|VOIDmode
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  Return the address of the (N_REFS + 1)th memory reference to ADDR     where SIZE is the size in bytes of the memory reference.  If ADDR     is not modified by the memory reference then ADDR is returned.  */
end_comment

begin_function
name|rtx
name|addr_side_effect_eval
parameter_list|(
name|addr
parameter_list|,
name|size
parameter_list|,
name|n_refs
parameter_list|)
name|rtx
name|addr
decl_stmt|;
name|int
name|size
decl_stmt|;
name|int
name|n_refs
decl_stmt|;
block|{
name|int
name|offset
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
condition|)
block|{
case|case
name|PRE_INC
case|:
name|offset
operator|=
operator|(
name|n_refs
operator|+
literal|1
operator|)
operator|*
name|size
expr_stmt|;
break|break;
case|case
name|PRE_DEC
case|:
name|offset
operator|=
operator|-
operator|(
name|n_refs
operator|+
literal|1
operator|)
operator|*
name|size
expr_stmt|;
break|break;
case|case
name|POST_INC
case|:
name|offset
operator|=
name|n_refs
operator|*
name|size
expr_stmt|;
break|break;
case|case
name|POST_DEC
case|:
name|offset
operator|=
operator|-
name|n_refs
operator|*
name|size
expr_stmt|;
break|break;
default|default:
return|return
name|addr
return|;
block|}
if|if
condition|(
name|offset
condition|)
name|addr
operator|=
name|gen_rtx_PLUS
argument_list|(
name|GET_MODE
argument_list|(
name|addr
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|offset
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|addr
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if X and Y (memory addresses) could reference the    same location in memory.  C is an offset accumulator.  When    C is nonzero, we are testing aliases between X and Y + C.    XSIZE is the size in bytes of the X reference,    similarly YSIZE is the size in bytes for Y.     If XSIZE or YSIZE is zero, we do not know the amount of memory being    referenced (the reference was BLKmode), so make the most pessimistic    assumptions.     If XSIZE or YSIZE is negative, we may access memory outside the object    being referenced as a side effect.  This can happen when using AND to    align memory references, as is done on the Alpha.     Nice to notice that varying addresses cannot conflict with fp if no    local variables had their addresses taken, but that's too hard now.  */
end_comment

begin_function
specifier|static
name|int
name|memrefs_conflict_p
parameter_list|(
name|xsize
parameter_list|,
name|x
parameter_list|,
name|ysize
parameter_list|,
name|y
parameter_list|,
name|c
parameter_list|)
specifier|register
name|rtx
name|x
decl_stmt|,
name|y
decl_stmt|;
name|int
name|xsize
decl_stmt|,
name|ysize
decl_stmt|;
name|HOST_WIDE_INT
name|c
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|HIGH
condition|)
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|LO_SUM
condition|)
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|x
operator|=
name|canon_rtx
argument_list|(
name|addr_side_effect_eval
argument_list|(
name|x
argument_list|,
name|xsize
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|HIGH
condition|)
name|y
operator|=
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|LO_SUM
condition|)
name|y
operator|=
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|y
operator|=
name|canon_rtx
argument_list|(
name|addr_side_effect_eval
argument_list|(
name|y
argument_list|,
name|ysize
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtx_equal_for_memref_p
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
condition|)
block|{
if|if
condition|(
name|xsize
operator|<=
literal|0
operator|||
name|ysize
operator|<=
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|c
operator|>=
literal|0
operator|&&
name|xsize
operator|>
name|c
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|c
operator|<
literal|0
operator|&&
name|ysize
operator|+
name|c
operator|>
literal|0
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
comment|/* This code used to check for conflicts involving stack references and      globals but the base address alias code now handles these cases.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
condition|)
block|{
comment|/* The fact that X is canonicalized means that this 	 PLUS rtx is canonicalized.  */
name|rtx
name|x0
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|x1
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|PLUS
condition|)
block|{
comment|/* The fact that Y is canonicalized means that this 	     PLUS rtx is canonicalized.  */
name|rtx
name|y0
init|=
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|y1
init|=
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|rtx_equal_for_memref_p
argument_list|(
name|x1
argument_list|,
name|y1
argument_list|)
condition|)
return|return
name|memrefs_conflict_p
argument_list|(
name|xsize
argument_list|,
name|x0
argument_list|,
name|ysize
argument_list|,
name|y0
argument_list|,
name|c
argument_list|)
return|;
if|if
condition|(
name|rtx_equal_for_memref_p
argument_list|(
name|x0
argument_list|,
name|y0
argument_list|)
condition|)
return|return
name|memrefs_conflict_p
argument_list|(
name|xsize
argument_list|,
name|x1
argument_list|,
name|ysize
argument_list|,
name|y1
argument_list|,
name|c
argument_list|)
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x1
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|y1
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|memrefs_conflict_p
argument_list|(
name|xsize
argument_list|,
name|x0
argument_list|,
name|ysize
argument_list|,
name|y0
argument_list|,
name|c
operator|-
name|INTVAL
argument_list|(
name|x1
argument_list|)
operator|+
name|INTVAL
argument_list|(
name|y1
argument_list|)
argument_list|)
return|;
else|else
return|return
name|memrefs_conflict_p
argument_list|(
name|xsize
argument_list|,
name|x0
argument_list|,
name|ysize
argument_list|,
name|y
argument_list|,
name|c
operator|-
name|INTVAL
argument_list|(
name|x1
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|y1
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|memrefs_conflict_p
argument_list|(
name|xsize
argument_list|,
name|x
argument_list|,
name|ysize
argument_list|,
name|y0
argument_list|,
name|c
operator|+
name|INTVAL
argument_list|(
name|y1
argument_list|)
argument_list|)
return|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x1
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|memrefs_conflict_p
argument_list|(
name|xsize
argument_list|,
name|x0
argument_list|,
name|ysize
argument_list|,
name|y
argument_list|,
name|c
operator|-
name|INTVAL
argument_list|(
name|x1
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|PLUS
condition|)
block|{
comment|/* The fact that Y is canonicalized means that this 	 PLUS rtx is canonicalized.  */
name|rtx
name|y0
init|=
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|y1
init|=
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|y1
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|memrefs_conflict_p
argument_list|(
name|xsize
argument_list|,
name|x
argument_list|,
name|ysize
argument_list|,
name|y0
argument_list|,
name|c
operator|+
name|INTVAL
argument_list|(
name|y1
argument_list|)
argument_list|)
return|;
else|else
return|return
literal|1
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|GET_CODE
argument_list|(
name|y
argument_list|)
condition|)
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|MULT
case|:
block|{
comment|/* Handle cases where we expect the second operands to be the 	     same, and check only whether the first operand would conflict 	     or not.  */
name|rtx
name|x0
decl_stmt|,
name|y0
decl_stmt|;
name|rtx
name|x1
init|=
name|canon_rtx
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|y1
init|=
name|canon_rtx
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|rtx_equal_for_memref_p
argument_list|(
name|x1
argument_list|,
name|y1
argument_list|)
condition|)
return|return
literal|1
return|;
name|x0
operator|=
name|canon_rtx
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|y0
operator|=
name|canon_rtx
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtx_equal_for_memref_p
argument_list|(
name|x0
argument_list|,
name|y0
argument_list|)
condition|)
return|return
operator|(
name|xsize
operator|==
literal|0
operator|||
name|ysize
operator|==
literal|0
operator|||
operator|(
name|c
operator|>=
literal|0
operator|&&
name|xsize
operator|>
name|c
operator|)
operator|||
operator|(
name|c
operator|<
literal|0
operator|&&
name|ysize
operator|+
name|c
operator|>
literal|0
operator|)
operator|)
return|;
comment|/* Can't properly adjust our sizes.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x1
argument_list|)
operator|!=
name|CONST_INT
condition|)
return|return
literal|1
return|;
name|xsize
operator|/=
name|INTVAL
argument_list|(
name|x1
argument_list|)
expr_stmt|;
name|ysize
operator|/=
name|INTVAL
argument_list|(
name|x1
argument_list|)
expr_stmt|;
name|c
operator|/=
name|INTVAL
argument_list|(
name|x1
argument_list|)
expr_stmt|;
return|return
name|memrefs_conflict_p
argument_list|(
name|xsize
argument_list|,
name|x0
argument_list|,
name|ysize
argument_list|,
name|y0
argument_list|,
name|c
argument_list|)
return|;
block|}
case|case
name|REG
case|:
comment|/* Are these registers known not to be equal?  */
if|if
condition|(
name|alias_invariant
condition|)
block|{
name|unsigned
name|int
name|r_x
init|=
name|REGNO
argument_list|(
name|x
argument_list|)
decl_stmt|,
name|r_y
init|=
name|REGNO
argument_list|(
name|y
argument_list|)
decl_stmt|;
name|rtx
name|i_x
decl_stmt|,
name|i_y
decl_stmt|;
comment|/* invariant relationships of X and Y */
name|i_x
operator|=
name|r_x
operator|>=
name|reg_base_value_size
condition|?
literal|0
else|:
name|alias_invariant
index|[
name|r_x
index|]
expr_stmt|;
name|i_y
operator|=
name|r_y
operator|>=
name|reg_base_value_size
condition|?
literal|0
else|:
name|alias_invariant
index|[
name|r_y
index|]
expr_stmt|;
if|if
condition|(
name|i_x
operator|==
literal|0
operator|&&
name|i_y
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
operator|!
name|memrefs_conflict_p
argument_list|(
name|xsize
argument_list|,
name|i_x
condition|?
name|i_x
else|:
name|x
argument_list|,
name|ysize
argument_list|,
name|i_y
condition|?
name|i_y
else|:
name|y
argument_list|,
name|c
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
break|break;
default|default:
break|break;
block|}
comment|/* Treat an access through an AND (e.g. a subword access on an Alpha)      as an access with indeterminate size.  Assume that references       besides AND are aligned, so if the size of the other reference is      at least as large as the alignment, assume no other overlap.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|AND
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|AND
operator|||
name|ysize
operator|<
operator|-
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
name|xsize
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|memrefs_conflict_p
argument_list|(
name|xsize
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|ysize
argument_list|,
name|y
argument_list|,
name|c
argument_list|)
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|AND
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
comment|/* ??? If we are indexing far enough into the array/structure, we 	 may yet be able to determine that we can not overlap.  But we  	 also need to that we are far enough from the end not to overlap 	 a following reference, so we do nothing with that for now.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|AND
operator|||
name|xsize
operator|<
operator|-
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
name|ysize
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|memrefs_conflict_p
argument_list|(
name|xsize
argument_list|,
name|x
argument_list|,
name|ysize
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|,
name|c
argument_list|)
return|;
block|}
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|c
operator|+=
operator|(
name|INTVAL
argument_list|(
name|y
argument_list|)
operator|-
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|)
expr_stmt|;
return|return
operator|(
name|xsize
operator|<=
literal|0
operator|||
name|ysize
operator|<=
literal|0
operator|||
operator|(
name|c
operator|>=
literal|0
operator|&&
name|xsize
operator|>
name|c
operator|)
operator|||
operator|(
name|c
operator|<
literal|0
operator|&&
name|ysize
operator|+
name|c
operator|>
literal|0
operator|)
operator|)
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|CONST
condition|)
return|return
name|memrefs_conflict_p
argument_list|(
name|xsize
argument_list|,
name|canon_rtx
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|ysize
argument_list|,
name|canon_rtx
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|c
argument_list|)
return|;
else|else
return|return
name|memrefs_conflict_p
argument_list|(
name|xsize
argument_list|,
name|canon_rtx
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|ysize
argument_list|,
name|y
argument_list|,
name|c
argument_list|)
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|CONST
condition|)
return|return
name|memrefs_conflict_p
argument_list|(
name|xsize
argument_list|,
name|x
argument_list|,
name|ysize
argument_list|,
name|canon_rtx
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|c
argument_list|)
return|;
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|y
argument_list|)
condition|)
return|return
operator|(
name|xsize
operator|<
literal|0
operator|||
name|ysize
operator|<
literal|0
operator|||
operator|(
name|rtx_equal_for_memref_p
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
operator|&&
operator|(
name|xsize
operator|==
literal|0
operator|||
name|ysize
operator|==
literal|0
operator|||
operator|(
name|c
operator|>=
literal|0
operator|&&
name|xsize
operator|>
name|c
operator|)
operator|||
operator|(
name|c
operator|<
literal|0
operator|&&
name|ysize
operator|+
name|c
operator|>
literal|0
operator|)
operator|)
operator|)
operator|)
return|;
return|return
literal|1
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Functions to compute memory dependencies.     Since we process the insns in execution order, we can build tables    to keep track of what registers are fixed (and not aliased), what registers    are varying in known ways, and what registers are varying in unknown    ways.     If both memory references are volatile, then there must always be a    dependence between the two references, since their order can not be    changed.  A volatile and non-volatile reference can be interchanged    though.      A MEM_IN_STRUCT reference at a non-QImode non-AND varying address can never    conflict with a non-MEM_IN_STRUCT reference at a fixed address.   We must    allow QImode aliasing because the ANSI C standard allows character    pointers to alias anything.  We are assuming that characters are    always QImode here.  We also must allow AND addresses, because they may    generate accesses outside the object being referenced.  This is used to    generate aligned addresses from unaligned addresses, for instance, the    alpha storeqi_unaligned pattern.  */
end_comment

begin_comment
comment|/* Read dependence: X is read after read in MEM takes place.  There can    only be a dependence here if both reads are volatile.  */
end_comment

begin_function
name|int
name|read_dependence
parameter_list|(
name|mem
parameter_list|,
name|x
parameter_list|)
name|rtx
name|mem
decl_stmt|;
name|rtx
name|x
decl_stmt|;
block|{
return|return
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
operator|&&
name|MEM_VOLATILE_P
argument_list|(
name|mem
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns MEM1 if and only if MEM1 is a scalar at a fixed address and    MEM2 is a reference to a structure at a varying address, or returns    MEM2 if vice versa.  Otherwise, returns NULL_RTX.  If a non-NULL    value is returned MEM1 and MEM2 can never alias.  VARIES_P is used    to decide whether or not an address may vary; it should return    nozero whenever variation is possible.  */
end_comment

begin_function_decl
specifier|static
name|rtx
name|fixed_scalar_and_varying_struct_p
parameter_list|(
name|mem1
parameter_list|,
name|mem2
parameter_list|,
name|varies_p
parameter_list|)
name|rtx
name|mem1
decl_stmt|;
name|rtx
name|mem2
decl_stmt|;
function_decl|int
parameter_list|(
function_decl|*varies_p
end_function_decl

begin_expr_stmt
unit|)
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|rtx
name|mem1_addr
init|=
name|XEXP
argument_list|(
name|mem1
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|mem2_addr
init|=
name|XEXP
argument_list|(
name|mem2
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|MEM_SCALAR_P
argument_list|(
name|mem1
argument_list|)
operator|&&
name|MEM_IN_STRUCT_P
argument_list|(
name|mem2
argument_list|)
operator|&&
operator|!
name|varies_p
argument_list|(
name|mem1_addr
argument_list|)
operator|&&
name|varies_p
argument_list|(
name|mem2_addr
argument_list|)
condition|)
comment|/* MEM1 is a scalar at a fixed address; MEM2 is a struct at a        varying address.  */
return|return
name|mem1
return|;
if|if
condition|(
name|MEM_IN_STRUCT_P
argument_list|(
name|mem1
argument_list|)
operator|&&
name|MEM_SCALAR_P
argument_list|(
name|mem2
argument_list|)
operator|&&
name|varies_p
argument_list|(
name|mem1_addr
argument_list|)
operator|&&
operator|!
name|varies_p
argument_list|(
name|mem2_addr
argument_list|)
condition|)
comment|/* MEM2 is a scalar at a fixed address; MEM1 is a struct at a        varying address.  */
return|return
name|mem2
return|;
return|return
name|NULL_RTX
return|;
block|}
end_block

begin_comment
comment|/* Returns nonzero if something about the mode or address format MEM1    indicates that it might well alias *anything*.  */
end_comment

begin_function
specifier|static
name|int
name|aliases_everything_p
parameter_list|(
name|mem
parameter_list|)
name|rtx
name|mem
decl_stmt|;
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|mem
argument_list|)
operator|==
name|QImode
condition|)
comment|/* ANSI C says that a `char*' can point to anything.  */
return|return
literal|1
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|mem
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|AND
condition|)
comment|/* If the address is an AND, its very hard to know at what it is        actually pointing.  */
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* True dependence: X is read after store in MEM takes place.  */
end_comment

begin_function_decl
name|int
name|true_dependence
parameter_list|(
name|mem
parameter_list|,
name|mem_mode
parameter_list|,
name|x
parameter_list|,
name|varies
parameter_list|)
name|rtx
name|mem
decl_stmt|;
name|enum
name|machine_mode
name|mem_mode
decl_stmt|;
name|rtx
name|x
decl_stmt|;
function_decl|int
parameter_list|(
function_decl|*varies
end_function_decl

begin_expr_stmt
unit|)
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|rtx
name|x_addr
decl_stmt|,
name|mem_addr
decl_stmt|;
if|if
condition|(
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
operator|&&
name|MEM_VOLATILE_P
argument_list|(
name|mem
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|DIFFERENT_ALIAS_SETS_P
argument_list|(
name|x
argument_list|,
name|mem
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* If X is an unchanging read, then it can't possibly conflict with any      non-unchanging store.  It may conflict with an unchanging write though,      because there may be a single store to this address to initialize it.      Just fall through to the code below to resolve the case where we have      both an unchanging read and an unchanging write.  This won't handle all      cases optimally, but the possible performance loss should be      negligible.  */
if|if
condition|(
name|RTX_UNCHANGING_P
argument_list|(
name|x
argument_list|)
operator|&&
operator|!
name|RTX_UNCHANGING_P
argument_list|(
name|mem
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|mem_mode
operator|==
name|VOIDmode
condition|)
name|mem_mode
operator|=
name|GET_MODE
argument_list|(
name|mem
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|base_alias_check
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|mem
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|mem_mode
argument_list|)
condition|)
return|return
literal|0
return|;
name|x_addr
operator|=
name|canon_rtx
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|mem_addr
operator|=
name|canon_rtx
argument_list|(
name|XEXP
argument_list|(
name|mem
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|memrefs_conflict_p
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|mem_mode
argument_list|)
argument_list|,
name|mem_addr
argument_list|,
name|SIZE_FOR_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|x_addr
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|aliases_everything_p
argument_list|(
name|x
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* We cannot use aliases_everyting_p to test MEM, since we must look      at MEM_MODE, rather than GET_MODE (MEM).  */
if|if
condition|(
name|mem_mode
operator|==
name|QImode
operator|||
name|GET_CODE
argument_list|(
name|mem_addr
argument_list|)
operator|==
name|AND
condition|)
return|return
literal|1
return|;
comment|/* In true_dependence we also allow BLKmode to alias anything.  Why      don't we do this in anti_dependence and output_dependence?  */
if|if
condition|(
name|mem_mode
operator|==
name|BLKmode
operator|||
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|BLKmode
condition|)
return|return
literal|1
return|;
return|return
operator|!
name|fixed_scalar_and_varying_struct_p
argument_list|(
name|mem
argument_list|,
name|x
argument_list|,
name|varies
argument_list|)
return|;
block|}
end_block

begin_comment
comment|/* Returns non-zero if a write to X might alias a previous read from    (or, if WRITEP is non-zero, a write to) MEM.  */
end_comment

begin_function
specifier|static
name|int
name|write_dependence_p
parameter_list|(
name|mem
parameter_list|,
name|x
parameter_list|,
name|writep
parameter_list|)
name|rtx
name|mem
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|int
name|writep
decl_stmt|;
block|{
name|rtx
name|x_addr
decl_stmt|,
name|mem_addr
decl_stmt|;
name|rtx
name|fixed_scalar
decl_stmt|;
if|if
condition|(
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
operator|&&
name|MEM_VOLATILE_P
argument_list|(
name|mem
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* If MEM is an unchanging read, then it can't possibly conflict with      the store to X, because there is at most one store to MEM, and it must      have occurred somewhere before MEM.  */
if|if
condition|(
operator|!
name|writep
operator|&&
name|RTX_UNCHANGING_P
argument_list|(
name|mem
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|base_alias_check
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|mem
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|mem
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
name|x
operator|=
name|canon_rtx
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|mem
operator|=
name|canon_rtx
argument_list|(
name|mem
argument_list|)
expr_stmt|;
if|if
condition|(
name|DIFFERENT_ALIAS_SETS_P
argument_list|(
name|x
argument_list|,
name|mem
argument_list|)
condition|)
return|return
literal|0
return|;
name|x_addr
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mem_addr
operator|=
name|XEXP
argument_list|(
name|mem
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|memrefs_conflict_p
argument_list|(
name|SIZE_FOR_MODE
argument_list|(
name|mem
argument_list|)
argument_list|,
name|mem_addr
argument_list|,
name|SIZE_FOR_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|x_addr
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|0
return|;
name|fixed_scalar
operator|=
name|fixed_scalar_and_varying_struct_p
argument_list|(
name|mem
argument_list|,
name|x
argument_list|,
name|rtx_addr_varies_p
argument_list|)
expr_stmt|;
return|return
operator|(
operator|!
operator|(
name|fixed_scalar
operator|==
name|mem
operator|&&
operator|!
name|aliases_everything_p
argument_list|(
name|x
argument_list|)
operator|)
operator|&&
operator|!
operator|(
name|fixed_scalar
operator|==
name|x
operator|&&
operator|!
name|aliases_everything_p
argument_list|(
name|mem
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Anti dependence: X is written after read in MEM takes place.  */
end_comment

begin_function
name|int
name|anti_dependence
parameter_list|(
name|mem
parameter_list|,
name|x
parameter_list|)
name|rtx
name|mem
decl_stmt|;
name|rtx
name|x
decl_stmt|;
block|{
return|return
name|write_dependence_p
argument_list|(
name|mem
argument_list|,
name|x
argument_list|,
comment|/*writep=*/
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Output dependence: X is written after store in MEM takes place.  */
end_comment

begin_function
name|int
name|output_dependence
parameter_list|(
name|mem
parameter_list|,
name|x
parameter_list|)
specifier|register
name|rtx
name|mem
decl_stmt|;
specifier|register
name|rtx
name|x
decl_stmt|;
block|{
return|return
name|write_dependence_p
argument_list|(
name|mem
argument_list|,
name|x
argument_list|,
comment|/*writep=*/
literal|1
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|HARD_REG_SET
name|argument_registers
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|init_alias_once
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
ifndef|#
directive|ifndef
name|OUTGOING_REGNO
define|#
directive|define
name|OUTGOING_REGNO
parameter_list|(
name|N
parameter_list|)
value|N
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
comment|/* Check whether this register can hold an incoming pointer        argument.  FUNCTION_ARG_REGNO_P tests outgoing register        numbers, so translate if necessary due to register windows. */
if|if
condition|(
name|FUNCTION_ARG_REGNO_P
argument_list|(
name|OUTGOING_REGNO
argument_list|(
name|i
argument_list|)
argument_list|)
operator|&&
name|HARD_REGNO_MODE_OK
argument_list|(
name|i
argument_list|,
name|Pmode
argument_list|)
condition|)
name|SET_HARD_REG_BIT
argument_list|(
name|argument_registers
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|alias_sets
operator|=
name|splay_tree_new
argument_list|(
name|splay_tree_compare_ints
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|init_alias_analysis
parameter_list|()
block|{
name|int
name|maxreg
init|=
name|max_reg_num
argument_list|()
decl_stmt|;
name|int
name|changed
decl_stmt|,
name|pass
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|unsigned
name|int
name|ui
decl_stmt|;
specifier|register
name|rtx
name|insn
decl_stmt|;
name|reg_known_value_size
operator|=
name|maxreg
expr_stmt|;
name|reg_known_value
operator|=
operator|(
name|rtx
operator|*
operator|)
name|oballoc
argument_list|(
operator|(
name|maxreg
operator|-
name|FIRST_PSEUDO_REGISTER
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
operator|-
name|FIRST_PSEUDO_REGISTER
expr_stmt|;
name|reg_known_equiv_p
operator|=
name|oballoc
argument_list|(
name|maxreg
operator|-
name|FIRST_PSEUDO_REGISTER
argument_list|)
operator|-
name|FIRST_PSEUDO_REGISTER
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|reg_known_value
operator|+
name|FIRST_PSEUDO_REGISTER
operator|)
argument_list|,
operator|(
name|maxreg
operator|-
name|FIRST_PSEUDO_REGISTER
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|reg_known_equiv_p
operator|+
name|FIRST_PSEUDO_REGISTER
argument_list|,
operator|(
name|maxreg
operator|-
name|FIRST_PSEUDO_REGISTER
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Overallocate reg_base_value to allow some growth during loop      optimization.  Loop unrolling can create a large number of      registers.  */
name|reg_base_value_size
operator|=
name|maxreg
operator|*
literal|2
expr_stmt|;
name|reg_base_value
operator|=
operator|(
name|rtx
operator|*
operator|)
name|oballoc
argument_list|(
name|reg_base_value_size
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|new_reg_base_value
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|reg_base_value_size
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|reg_seen
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|reg_base_value_size
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|reg_base_value
argument_list|,
name|reg_base_value_size
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|reload_completed
operator|&&
name|flag_unroll_loops
condition|)
block|{
name|alias_invariant
operator|=
operator|(
name|rtx
operator|*
operator|)
name|xrealloc
argument_list|(
name|alias_invariant
argument_list|,
name|reg_base_value_size
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|alias_invariant
argument_list|,
name|reg_base_value_size
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* The basic idea is that each pass through this loop will use the      "constant" information from the previous pass to propagate alias      information through another level of assignments.       This could get expensive if the assignment chains are long.  Maybe      we should throttle the number of iterations, possibly based on      the optimization level or flag_expensive_optimizations.       We could propagate more information in the first pass by making use      of REG_N_SETS to determine immediately that the alias information      for a pseudo is "constant".       A program with an uninitialized variable can cause an infinite loop      here.  Instead of doing a full dataflow analysis to detect such problems      we just cap the number of iterations for the loop.       The state of the arrays for the set chain in question does not matter      since the program has undefined behavior.  */
name|pass
operator|=
literal|0
expr_stmt|;
do|do
block|{
comment|/* Assume nothing will change this iteration of the loop.  */
name|changed
operator|=
literal|0
expr_stmt|;
comment|/* We want to assign the same IDs each iteration of this loop, so 	 start counting from zero each iteration of the loop.  */
name|unique_id
operator|=
literal|0
expr_stmt|;
comment|/* We're at the start of the funtion each iteration through the 	 loop, so we're copying arguments.  */
name|copying_arguments
operator|=
literal|1
expr_stmt|;
comment|/* Wipe the potential alias information clean for this pass.  */
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|new_reg_base_value
argument_list|,
name|reg_base_value_size
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Wipe the reg_seen array clean.  */
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|reg_seen
argument_list|,
name|reg_base_value_size
argument_list|)
expr_stmt|;
comment|/* Mark all hard registers which may contain an address. 	 The stack, frame and argument pointers may contain an address. 	 An argument register which can hold a Pmode value may contain 	 an address even if it is not in BASE_REGS.  	 The address expression is VOIDmode for an argument and 	 Pmode for other registers.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|argument_registers
argument_list|,
name|i
argument_list|)
condition|)
name|new_reg_base_value
index|[
name|i
index|]
operator|=
name|gen_rtx_ADDRESS
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|new_reg_base_value
index|[
name|STACK_POINTER_REGNUM
index|]
operator|=
name|gen_rtx_ADDRESS
argument_list|(
name|Pmode
argument_list|,
name|stack_pointer_rtx
argument_list|)
expr_stmt|;
name|new_reg_base_value
index|[
name|ARG_POINTER_REGNUM
index|]
operator|=
name|gen_rtx_ADDRESS
argument_list|(
name|Pmode
argument_list|,
name|arg_pointer_rtx
argument_list|)
expr_stmt|;
name|new_reg_base_value
index|[
name|FRAME_POINTER_REGNUM
index|]
operator|=
name|gen_rtx_ADDRESS
argument_list|(
name|Pmode
argument_list|,
name|frame_pointer_rtx
argument_list|)
expr_stmt|;
if|#
directive|if
name|HARD_FRAME_POINTER_REGNUM
operator|!=
name|FRAME_POINTER_REGNUM
name|new_reg_base_value
index|[
name|HARD_FRAME_POINTER_REGNUM
index|]
operator|=
name|gen_rtx_ADDRESS
argument_list|(
name|Pmode
argument_list|,
name|hard_frame_pointer_rtx
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Walk the insns adding values to the new_reg_base_value array.  */
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
literal|'i'
condition|)
block|{
name|rtx
name|note
decl_stmt|,
name|set
decl_stmt|;
comment|/* If this insn has a noalias note, process it,  Otherwise, 	         scan for sets.  A simple set will have no side effects 	         which could change the base value of any other register. */
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
operator|(
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_NOALIAS
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
condition|)
name|record_set
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
else|else
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|record_set
argument_list|)
expr_stmt|;
name|set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|set
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
operator|(
operator|(
operator|(
name|note
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_EQUAL
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|REG_N_SETS
argument_list|(
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|1
operator|)
operator|||
operator|(
name|note
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_EQUIV
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
operator|!=
literal|0
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|EXPR_LIST
operator|&&
operator|!
name|reg_overlap_mentioned_p
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
decl_stmt|;
name|reg_known_value
index|[
name|regno
index|]
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|reg_known_equiv_p
index|[
name|regno
index|]
operator|=
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
operator|==
name|REG_EQUIV
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_FUNCTION_BEG
condition|)
name|copying_arguments
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Now propagate values from new_reg_base_value to reg_base_value.  */
for|for
control|(
name|ui
operator|=
literal|0
init|;
name|ui
operator|<
name|reg_base_value_size
condition|;
name|ui
operator|++
control|)
block|{
if|if
condition|(
name|new_reg_base_value
index|[
name|ui
index|]
operator|&&
name|new_reg_base_value
index|[
name|ui
index|]
operator|!=
name|reg_base_value
index|[
name|ui
index|]
operator|&&
operator|!
name|rtx_equal_p
argument_list|(
name|new_reg_base_value
index|[
name|ui
index|]
argument_list|,
name|reg_base_value
index|[
name|ui
index|]
argument_list|)
condition|)
block|{
name|reg_base_value
index|[
name|ui
index|]
operator|=
name|new_reg_base_value
index|[
name|ui
index|]
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
name|changed
operator|&&
operator|++
name|pass
operator|<
name|MAX_ALIAS_LOOP_PASSES
condition|)
do|;
comment|/* Fill in the remaining entries.  */
for|for
control|(
name|i
operator|=
name|FIRST_PSEUDO_REGISTER
init|;
name|i
operator|<
name|maxreg
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|reg_known_value
index|[
name|i
index|]
operator|==
literal|0
condition|)
name|reg_known_value
index|[
name|i
index|]
operator|=
name|regno_reg_rtx
index|[
name|i
index|]
expr_stmt|;
comment|/* Simplify the reg_base_value array so that no register refers to      another register, except to special registers indirectly through      ADDRESS expressions.       In theory this loop can take as long as O(registers^2), but unless      there are very long dependency chains it will run in close to linear      time.       This loop may not be needed any longer now that the main loop does      a better job at propagating alias information.  */
name|pass
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|changed
operator|=
literal|0
expr_stmt|;
name|pass
operator|++
expr_stmt|;
for|for
control|(
name|ui
operator|=
literal|0
init|;
name|ui
operator|<
name|reg_base_value_size
condition|;
name|ui
operator|++
control|)
block|{
name|rtx
name|base
init|=
name|reg_base_value
index|[
name|ui
index|]
decl_stmt|;
if|if
condition|(
name|base
operator|&&
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|REG
condition|)
block|{
name|unsigned
name|int
name|base_regno
init|=
name|REGNO
argument_list|(
name|base
argument_list|)
decl_stmt|;
if|if
condition|(
name|base_regno
operator|==
name|ui
condition|)
comment|/* register set from itself */
name|reg_base_value
index|[
name|ui
index|]
operator|=
literal|0
expr_stmt|;
else|else
name|reg_base_value
index|[
name|ui
index|]
operator|=
name|reg_base_value
index|[
name|base_regno
index|]
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
name|changed
operator|&&
name|pass
operator|<
name|MAX_ALIAS_LOOP_PASSES
condition|)
do|;
name|new_reg_base_value
operator|=
literal|0
expr_stmt|;
name|reg_seen
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|end_alias_analysis
parameter_list|()
block|{
name|reg_known_value
operator|=
literal|0
expr_stmt|;
name|reg_base_value
operator|=
literal|0
expr_stmt|;
name|reg_base_value_size
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|alias_invariant
condition|)
block|{
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|alias_invariant
argument_list|)
expr_stmt|;
name|alias_invariant
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

end_unit

