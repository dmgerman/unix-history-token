begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Alias analysis for GNU C    Copyright (C) 1997, 1998 Free Software Foundation, Inc.    Contributed by John Carr (jfc@mit.edu).  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_decl_stmt
specifier|static
name|rtx
name|canon_rtx
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|rtx_equal_for_memref_p
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|find_symbolic_term
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|memrefs_conflict_p
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|rtx
operator|,
name|int
operator|,
name|rtx
operator|,
name|HOST_WIDE_INT
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|record_set
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|find_base_term
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|base_alias_check
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|find_base_value
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set up all info needed to perform alias analysis on memory references.  */
end_comment

begin_define
define|#
directive|define
name|SIZE_FOR_MODE
parameter_list|(
name|X
parameter_list|)
value|(GET_MODE_SIZE (GET_MODE (X)))
end_define

begin_comment
comment|/* Perform a basic sanity check.  Namely, that there are	    no alias sets if we're not doing strict aliasing.  This helps         to catch bugs whereby someone uses PUT_CODE, but doesn't clear    MEM_ALIAS_SET, or where a MEM is allocated in some way other    than by the use of gen_rtx_MEM, and the MEM_ALIAS_SET is not    cleared.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
end_ifdef

begin_define
define|#
directive|define
name|CHECK_ALIAS_SETS_FOR_CONSISTENCY
parameter_list|(
name|MEM1
parameter_list|,
name|MEM2
parameter_list|)
define|\
value|(!flag_strict_aliasing				\&& (MEM_ALIAS_SET (MEM1) || MEM_ALIAS_SET (MEM2))	\    ? (abort (), 0) : 0)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CHECK_ALIAS_SETS_FOR_CONSISTENCY
parameter_list|(
name|MEM1
parameter_list|,
name|MEM2
parameter_list|)
value|((void)0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Returns nonzero if MEM1 and MEM2 do not alias because they are in    different alias sets.  */
end_comment

begin_define
define|#
directive|define
name|DIFFERENT_ALIAS_SETS_P
parameter_list|(
name|MEM1
parameter_list|,
name|MEM2
parameter_list|)
define|\
value|(CHECK_ALIAS_SETS_FOR_CONSISTENCY(MEM1, MEM2),	\    MEM_ALIAS_SET (MEM1)&& MEM_ALIAS_SET (MEM2)		\&& MEM_ALIAS_SET (MEM1) != MEM_ALIAS_SET (MEM2))
end_define

begin_comment
comment|/* Cap the number of passes we make over the insns propagating alias    information through set chains.     10 is a completely arbitrary choice.  */
end_comment

begin_define
define|#
directive|define
name|MAX_ALIAS_LOOP_PASSES
value|10
end_define

begin_comment
comment|/* reg_base_value[N] gives an address to which register N is related.    If all sets after the first add or subtract to the current value    or otherwise modify it so it does not point to a different top level    object, reg_base_value[N] is equal to the address part of the source    of the first set.     A base address can be an ADDRESS, SYMBOL_REF, or LABEL_REF.  ADDRESS    expressions represent certain special values: function arguments and    the stack, frame, and argument pointers.  The contents of an address    expression are not used (but they are descriptive for debugging);    only the address and mode matter.  Pointer equality, not rtx_equal_p,    determines whether two ADDRESS expressions refer to the same base    address.  The mode determines whether it is a function argument or    other special value. */
end_comment

begin_decl_stmt
name|rtx
modifier|*
name|reg_base_value
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
modifier|*
name|new_reg_base_value
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|int
name|reg_base_value_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* size of reg_base_value array */
end_comment

begin_define
define|#
directive|define
name|REG_BASE_VALUE
parameter_list|(
name|X
parameter_list|)
define|\
value|(REGNO (X)< reg_base_value_size ? reg_base_value[REGNO (X)] : 0)
end_define

begin_comment
comment|/* Vector of known invariant relationships between registers.  Set in    loop unrolling.  Indexed by register number, if nonzero the value    is an expression describing this register in terms of another.     The length of this array is REG_BASE_VALUE_SIZE.     Because this array contains only pseudo registers it has no effect    after reload.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
modifier|*
name|alias_invariant
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Vector indexed by N giving the initial (unchanging) value known    for pseudo-register N.  */
end_comment

begin_decl_stmt
name|rtx
modifier|*
name|reg_known_value
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indicates number of valid entries in reg_known_value.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|reg_known_value_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Vector recording for each reg_known_value whether it is due to a    REG_EQUIV note.  Future passes (viz., reload) may replace the    pseudo with the equivalent expression and so we account for the    dependences that would be introduced if that happens. */
end_comment

begin_comment
comment|/* ??? This is a problem only on the Convex.  The REG_EQUIV notes created in    assign_parms mention the arg pointer, and there are explicit insns in the    RTL that modify the arg pointer.  Thus we must ensure that such insns don't    get scheduled across each other because that would invalidate the REG_EQUIV    notes.  One could argue that the REG_EQUIV notes are wrong, but solving    the problem in the scheduler will likely give better code, so we do it    here.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|reg_known_equiv_p
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* True when scanning insns from the start of the rtl to the    NOTE_INSN_FUNCTION_BEG note.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|copying_arguments
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Inside SRC, the source of a SET, find a base address.  */
end_comment

begin_function
specifier|static
name|rtx
name|find_base_value
parameter_list|(
name|src
parameter_list|)
specifier|register
name|rtx
name|src
decl_stmt|;
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
condition|)
block|{
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
return|return
name|src
return|;
case|case
name|REG
case|:
comment|/* At the start of a function argument registers have known base 	 values which may be lost later.  Returning an ADDRESS 	 expression here allows optimization based on argument values 	 even when the argument registers are used for other purposes.  */
if|if
condition|(
name|REGNO
argument_list|(
name|src
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|copying_arguments
condition|)
return|return
name|new_reg_base_value
index|[
name|REGNO
argument_list|(
name|src
argument_list|)
index|]
return|;
comment|/* If a pseudo has a known base value, return it.  Do not do this 	 for hard regs since it can result in a circular dependency 	 chain for registers which have values at function entry.  	 The test above is not sufficient because the scheduler may move 	 a copy out of an arg reg past the NOTE_INSN_FUNCTION_BEGIN.  */
if|if
condition|(
name|REGNO
argument_list|(
name|src
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|REGNO
argument_list|(
name|src
argument_list|)
operator|<
name|reg_base_value_size
operator|&&
name|reg_base_value
index|[
name|REGNO
argument_list|(
name|src
argument_list|)
index|]
condition|)
return|return
name|reg_base_value
index|[
name|REGNO
argument_list|(
name|src
argument_list|)
index|]
return|;
return|return
name|src
return|;
case|case
name|MEM
case|:
comment|/* Check for an argument passed in memory.  Only record in the 	 copying-arguments block; it is too hard to track changes 	 otherwise.  */
if|if
condition|(
name|copying_arguments
operator|&&
operator|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
operator|==
name|arg_pointer_rtx
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|arg_pointer_rtx
operator|)
operator|)
condition|)
return|return
name|gen_rtx_ADDRESS
argument_list|(
name|VOIDmode
argument_list|,
name|src
argument_list|)
return|;
return|return
literal|0
return|;
case|case
name|CONST
case|:
name|src
operator|=
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|!=
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|!=
name|MINUS
condition|)
break|break;
comment|/* fall through */
case|case
name|PLUS
case|:
case|case
name|MINUS
case|:
block|{
name|rtx
name|temp
decl_stmt|,
name|src_0
init|=
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
decl_stmt|,
name|src_1
init|=
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|/* If either operand is a REG, then see if we already have 	   a known value for it.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|src_0
argument_list|)
operator|==
name|REG
condition|)
block|{
name|temp
operator|=
name|find_base_value
argument_list|(
name|src_0
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
condition|)
name|src_0
operator|=
name|temp
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|src_1
argument_list|)
operator|==
name|REG
condition|)
block|{
name|temp
operator|=
name|find_base_value
argument_list|(
name|src_1
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
condition|)
name|src_1
operator|=
name|temp
expr_stmt|;
block|}
comment|/* Guess which operand is the base address.  	   If either operand is a symbol, then it is the base.  If 	   either operand is a CONST_INT, then the other is the base.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|src_1
argument_list|)
operator|==
name|CONST_INT
operator|||
name|GET_CODE
argument_list|(
name|src_0
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|src_0
argument_list|)
operator|==
name|LABEL_REF
operator|||
name|GET_CODE
argument_list|(
name|src_0
argument_list|)
operator|==
name|CONST
condition|)
return|return
name|find_base_value
argument_list|(
name|src_0
argument_list|)
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|src_0
argument_list|)
operator|==
name|CONST_INT
operator|||
name|GET_CODE
argument_list|(
name|src_1
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|src_1
argument_list|)
operator|==
name|LABEL_REF
operator|||
name|GET_CODE
argument_list|(
name|src_1
argument_list|)
operator|==
name|CONST
condition|)
return|return
name|find_base_value
argument_list|(
name|src_1
argument_list|)
return|;
comment|/* This might not be necessary anymore.   	   If either operand is a REG that is a known pointer, then it 	   is the base.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|src_0
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO_POINTER_FLAG
argument_list|(
name|REGNO
argument_list|(
name|src_0
argument_list|)
argument_list|)
condition|)
return|return
name|find_base_value
argument_list|(
name|src_0
argument_list|)
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|src_1
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO_POINTER_FLAG
argument_list|(
name|REGNO
argument_list|(
name|src_1
argument_list|)
argument_list|)
condition|)
return|return
name|find_base_value
argument_list|(
name|src_1
argument_list|)
return|;
return|return
literal|0
return|;
block|}
case|case
name|LO_SUM
case|:
comment|/* The standard form is (lo_sum reg sym) so look only at the 	 second operand.  */
return|return
name|find_base_value
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
case|case
name|AND
case|:
comment|/* If the second operand is constant set the base 	 address to the first operand. */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|find_base_value
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
return|return
literal|0
return|;
case|case
name|ZERO_EXTEND
case|:
case|case
name|SIGN_EXTEND
case|:
comment|/* used for NT/Alpha pointers */
case|case
name|HIGH
case|:
return|return
name|find_base_value
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
default|default:
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Called from init_alias_analysis indirectly through note_stores.  */
end_comment

begin_comment
comment|/* while scanning insns to find base values, reg_seen[N] is nonzero if    register N has been set in this function.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|reg_seen
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Addresses which are known not to alias anything else are identified    by a unique integer.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|unique_id
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|record_set
parameter_list|(
name|dest
parameter_list|,
name|set
parameter_list|)
name|rtx
name|dest
decl_stmt|,
name|set
decl_stmt|;
block|{
specifier|register
name|int
name|regno
decl_stmt|;
name|rtx
name|src
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|!=
name|REG
condition|)
return|return;
name|regno
operator|=
name|REGNO
argument_list|(
name|dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|set
condition|)
block|{
comment|/* A CLOBBER wipes out any old value but does not prevent a previously 	 unset register from acquiring a base address (i.e. reg_seen is not 	 set).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|set
argument_list|)
operator|==
name|CLOBBER
condition|)
block|{
name|new_reg_base_value
index|[
name|regno
index|]
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|src
operator|=
name|SET_SRC
argument_list|(
name|set
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|reg_seen
index|[
name|regno
index|]
condition|)
block|{
name|new_reg_base_value
index|[
name|regno
index|]
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|reg_seen
index|[
name|regno
index|]
operator|=
literal|1
expr_stmt|;
name|new_reg_base_value
index|[
name|regno
index|]
operator|=
name|gen_rtx_ADDRESS
argument_list|(
name|Pmode
argument_list|,
name|GEN_INT
argument_list|(
name|unique_id
operator|++
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* This is not the first set.  If the new value is not related to the      old value, forget the base value. Note that the following code is      not detected:      extern int x, y;  int *p =&x; p += (&y-&x);      ANSI C does not allow computing the difference of addresses      of distinct top level objects.  */
if|if
condition|(
name|new_reg_base_value
index|[
name|regno
index|]
condition|)
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
condition|)
block|{
case|case
name|LO_SUM
case|:
case|case
name|PLUS
case|:
case|case
name|MINUS
case|:
if|if
condition|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
operator|!=
name|dest
operator|&&
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
operator|!=
name|dest
condition|)
name|new_reg_base_value
index|[
name|regno
index|]
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|AND
case|:
if|if
condition|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
operator|!=
name|dest
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
condition|)
name|new_reg_base_value
index|[
name|regno
index|]
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|new_reg_base_value
index|[
name|regno
index|]
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* If this is the first set of a register, record the value.  */
elseif|else
if|if
condition|(
operator|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|||
operator|!
name|fixed_regs
index|[
name|regno
index|]
operator|)
operator|&&
operator|!
name|reg_seen
index|[
name|regno
index|]
operator|&&
name|new_reg_base_value
index|[
name|regno
index|]
operator|==
literal|0
condition|)
name|new_reg_base_value
index|[
name|regno
index|]
operator|=
name|find_base_value
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|reg_seen
index|[
name|regno
index|]
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called from loop optimization when a new pseudo-register is created.  */
end_comment

begin_function
name|void
name|record_base_value
parameter_list|(
name|regno
parameter_list|,
name|val
parameter_list|,
name|invariant
parameter_list|)
name|int
name|regno
decl_stmt|;
name|rtx
name|val
decl_stmt|;
name|int
name|invariant
decl_stmt|;
block|{
if|if
condition|(
name|regno
operator|>=
name|reg_base_value_size
condition|)
return|return;
comment|/* If INVARIANT is true then this value also describes an invariant      relationship which can be used to deduce that two registers with      unknown values are different.  */
if|if
condition|(
name|invariant
operator|&&
name|alias_invariant
condition|)
name|alias_invariant
index|[
name|regno
index|]
operator|=
name|val
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|val
argument_list|)
operator|==
name|REG
condition|)
block|{
if|if
condition|(
name|REGNO
argument_list|(
name|val
argument_list|)
operator|<
name|reg_base_value_size
condition|)
block|{
name|reg_base_value
index|[
name|regno
index|]
operator|=
name|reg_base_value
index|[
name|REGNO
argument_list|(
name|val
argument_list|)
index|]
expr_stmt|;
block|}
return|return;
block|}
name|reg_base_value
index|[
name|regno
index|]
operator|=
name|find_base_value
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|rtx
name|canon_rtx
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
comment|/* Recursively look for equivalences.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|x
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|REGNO
argument_list|(
name|x
argument_list|)
operator|<
name|reg_known_value_size
condition|)
return|return
name|reg_known_value
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
operator|==
name|x
condition|?
name|x
else|:
name|canon_rtx
argument_list|(
name|reg_known_value
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
argument_list|)
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|rtx
name|x0
init|=
name|canon_rtx
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|x1
init|=
name|canon_rtx
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|x0
operator|!=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|||
name|x1
operator|!=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
condition|)
block|{
comment|/* We can tolerate LO_SUMs being offset here; these 	     rtl are used for nothing other than comparisons.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x0
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|plus_constant_for_output
argument_list|(
name|x1
argument_list|,
name|INTVAL
argument_list|(
name|x0
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x1
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|plus_constant_for_output
argument_list|(
name|x0
argument_list|,
name|INTVAL
argument_list|(
name|x1
argument_list|)
argument_list|)
return|;
return|return
name|gen_rtx_PLUS
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|x0
argument_list|,
name|x1
argument_list|)
return|;
block|}
block|}
comment|/* This gives us much better alias analysis when called from      the loop optimizer.   Note we want to leave the original      MEM alone, but need to return the canonicalized MEM with      all the flags with their original values.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|rtx
name|addr
init|=
name|canon_rtx
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|addr
operator|!=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|rtx
name|new
init|=
name|gen_rtx_MEM
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|addr
argument_list|)
decl_stmt|;
name|MEM_VOLATILE_P
argument_list|(
name|new
argument_list|)
operator|=
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|new
argument_list|)
operator|=
name|RTX_UNCHANGING_P
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|MEM_IN_STRUCT_P
argument_list|(
name|new
argument_list|)
operator|=
name|MEM_IN_STRUCT_P
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|MEM_ALIAS_SET
argument_list|(
name|new
argument_list|)
operator|=
name|MEM_ALIAS_SET
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|x
operator|=
name|new
expr_stmt|;
block|}
block|}
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if X and Y are identical-looking rtx's.     We use the data in reg_known_value above to see if two registers with    different numbers are, in fact, equivalent.  */
end_comment

begin_function
specifier|static
name|int
name|rtx_equal_for_memref_p
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|y
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
specifier|register
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
operator|&&
name|y
operator|==
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|x
operator|==
literal|0
operator|||
name|y
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|x
operator|=
name|canon_rtx
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|y
operator|=
name|canon_rtx
argument_list|(
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|==
name|y
condition|)
return|return
literal|1
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* Rtx's of different codes cannot be equal.  */
if|if
condition|(
name|code
operator|!=
name|GET_CODE
argument_list|(
name|y
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* (MULT:SI x y) and (MULT:HI x y) are NOT equivalent.      (REG:SI x) and (REG:HI x) are NOT equivalent.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|y
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* REG, LABEL_REF, and SYMBOL_REF can be compared nonrecursively.  */
if|if
condition|(
name|code
operator|==
name|REG
condition|)
return|return
name|REGNO
argument_list|(
name|x
argument_list|)
operator|==
name|REGNO
argument_list|(
name|y
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|LABEL_REF
condition|)
return|return
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|SYMBOL_REF
condition|)
return|return
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|XSTR
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|CONST_INT
condition|)
return|return
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|==
name|INTVAL
argument_list|(
name|y
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|ADDRESSOF
condition|)
return|return
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|XINT
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|==
name|XINT
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
return|;
comment|/* For commutative operations, the RTX match if the operand match in any      order.  Also handle the simple binary and unary cases without a loop.  */
if|if
condition|(
name|code
operator|==
name|EQ
operator|||
name|code
operator|==
name|NE
operator|||
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'c'
condition|)
return|return
operator|(
operator|(
name|rtx_equal_for_memref_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|rtx_equal_for_memref_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|rtx_equal_for_memref_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|rtx_equal_for_memref_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|)
return|;
elseif|else
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'<'
operator|||
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'2'
condition|)
return|return
operator|(
name|rtx_equal_for_memref_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|rtx_equal_for_memref_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'1'
condition|)
return|return
name|rtx_equal_for_memref_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
comment|/* Compare the elements.  If any pair of corresponding elements      fail to match, return 0 for the whole things.       Limit cases to types which actually appear in addresses.  */
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
switch|switch
condition|(
name|fmt
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'i'
case|:
if|if
condition|(
name|XINT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
name|XINT
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'E'
case|:
comment|/* Two vectors must have the same length.  */
if|if
condition|(
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
name|XVECLEN
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* And the corresponding elements must match.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|rtx_equal_for_memref_p
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|XVECEXP
argument_list|(
name|y
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'e'
case|:
if|if
condition|(
name|rtx_equal_for_memref_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
break|break;
comment|/* This can happen for an asm which clobbers memory.  */
case|case
literal|'0'
case|:
break|break;
comment|/* It is believed that rtx's at this level will never 	     contain anything but integers and other rtx's, 	     except for within LABEL_REFs and SYMBOL_REFs.  */
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Given an rtx X, find a SYMBOL_REF or LABEL_REF within    X and return it, or return 0 if none found.  */
end_comment

begin_function
specifier|static
name|rtx
name|find_symbolic_term
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|SYMBOL_REF
operator|||
name|code
operator|==
name|LABEL_REF
condition|)
return|return
name|x
return|;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'o'
condition|)
return|return
literal|0
return|;
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|rtx
name|t
decl_stmt|;
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
name|t
operator|=
name|find_symbolic_term
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|!=
literal|0
condition|)
return|return
name|t
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|rtx
name|find_base_term
parameter_list|(
name|x
parameter_list|)
specifier|register
name|rtx
name|x
decl_stmt|;
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|REG
case|:
return|return
name|REG_BASE_VALUE
argument_list|(
name|x
argument_list|)
return|;
case|case
name|ZERO_EXTEND
case|:
case|case
name|SIGN_EXTEND
case|:
comment|/* Used for Alpha/NT pointers */
case|case
name|HIGH
case|:
case|case
name|PRE_INC
case|:
case|case
name|PRE_DEC
case|:
case|case
name|POST_INC
case|:
case|case
name|POST_DEC
case|:
return|return
name|find_base_term
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|CONST
case|:
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|MINUS
condition|)
return|return
literal|0
return|;
comment|/* fall through */
case|case
name|LO_SUM
case|:
case|case
name|PLUS
case|:
case|case
name|MINUS
case|:
block|{
name|rtx
name|tmp
init|=
name|find_base_term
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|tmp
condition|)
return|return
name|tmp
return|;
return|return
name|find_base_term
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
block|}
case|case
name|AND
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|REG_BASE_VALUE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
return|return
literal|0
return|;
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
return|return
name|x
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return 0 if the addresses X and Y are known to point to different    objects, 1 if they might be pointers to the same object.  */
end_comment

begin_function
specifier|static
name|int
name|base_alias_check
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|y
decl_stmt|;
block|{
name|rtx
name|x_base
init|=
name|find_base_term
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|rtx
name|y_base
init|=
name|find_base_term
argument_list|(
name|y
argument_list|)
decl_stmt|;
comment|/* If the address itself has no known base see if a known equivalent      value has one.  If either address still has no known base, nothing      is known about aliasing.  */
if|if
condition|(
name|x_base
operator|==
literal|0
condition|)
block|{
name|rtx
name|x_c
decl_stmt|;
if|if
condition|(
operator|!
name|flag_expensive_optimizations
operator|||
operator|(
name|x_c
operator|=
name|canon_rtx
argument_list|(
name|x
argument_list|)
operator|)
operator|==
name|x
condition|)
return|return
literal|1
return|;
name|x_base
operator|=
name|find_base_term
argument_list|(
name|x_c
argument_list|)
expr_stmt|;
if|if
condition|(
name|x_base
operator|==
literal|0
condition|)
return|return
literal|1
return|;
block|}
if|if
condition|(
name|y_base
operator|==
literal|0
condition|)
block|{
name|rtx
name|y_c
decl_stmt|;
if|if
condition|(
operator|!
name|flag_expensive_optimizations
operator|||
operator|(
name|y_c
operator|=
name|canon_rtx
argument_list|(
name|y
argument_list|)
operator|)
operator|==
name|y
condition|)
return|return
literal|1
return|;
name|y_base
operator|=
name|find_base_term
argument_list|(
name|y_c
argument_list|)
expr_stmt|;
if|if
condition|(
name|y_base
operator|==
literal|0
condition|)
return|return
literal|1
return|;
block|}
comment|/* If the base addresses are equal nothing is known about aliasing.  */
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|x_base
argument_list|,
name|y_base
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* The base addresses of the read and write are different      expressions.  If they are both symbols and they are not accessed      via AND, there is no conflict.  */
comment|/* XXX: We can bring knowledge of object alignment and offset into       play here.  For example, on alpha, "char a, b;" can alias one      another, though "char a; long b;" cannot.  Similarly, offsets      into strutures may be brought into play.  Given "char a, b[40];",      a and b[1] may overlap, but a and b[20] do not.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x_base
argument_list|)
operator|!=
name|ADDRESS
operator|&&
name|GET_CODE
argument_list|(
name|y_base
argument_list|)
operator|!=
name|ADDRESS
condition|)
block|{
return|return
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|AND
operator|||
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|AND
return|;
block|}
comment|/* If one address is a stack reference there can be no alias:      stack references using different base registers do not alias,      a stack reference can not alias a parameter, and a stack reference      can not alias a global.  */
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|x_base
argument_list|)
operator|==
name|ADDRESS
operator|&&
name|GET_MODE
argument_list|(
name|x_base
argument_list|)
operator|==
name|Pmode
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|y_base
argument_list|)
operator|==
name|ADDRESS
operator|&&
name|GET_MODE
argument_list|(
name|y_base
argument_list|)
operator|==
name|Pmode
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|flag_argument_noalias
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|flag_argument_noalias
operator|>
literal|1
condition|)
return|return
literal|0
return|;
comment|/* Weak noalias assertion (arguments are distinct, but may match globals). */
return|return
operator|!
operator|(
name|GET_MODE
argument_list|(
name|x_base
argument_list|)
operator|==
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|y_base
argument_list|)
operator|==
name|VOIDmode
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if X and Y (memory addresses) could reference the    same location in memory.  C is an offset accumulator.  When    C is nonzero, we are testing aliases between X and Y + C.    XSIZE is the size in bytes of the X reference,    similarly YSIZE is the size in bytes for Y.     If XSIZE or YSIZE is zero, we do not know the amount of memory being    referenced (the reference was BLKmode), so make the most pessimistic    assumptions.     If XSIZE or YSIZE is negative, we may access memory outside the object    being referenced as a side effect.  This can happen when using AND to    align memory references, as is done on the Alpha.     Nice to notice that varying addresses cannot conflict with fp if no    local variables had their addresses taken, but that's too hard now.  */
end_comment

begin_function
specifier|static
name|int
name|memrefs_conflict_p
parameter_list|(
name|xsize
parameter_list|,
name|x
parameter_list|,
name|ysize
parameter_list|,
name|y
parameter_list|,
name|c
parameter_list|)
specifier|register
name|rtx
name|x
decl_stmt|,
name|y
decl_stmt|;
name|int
name|xsize
decl_stmt|,
name|ysize
decl_stmt|;
name|HOST_WIDE_INT
name|c
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|HIGH
condition|)
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|LO_SUM
condition|)
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|x
operator|=
name|canon_rtx
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|HIGH
condition|)
name|y
operator|=
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|LO_SUM
condition|)
name|y
operator|=
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|y
operator|=
name|canon_rtx
argument_list|(
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtx_equal_for_memref_p
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
condition|)
block|{
if|if
condition|(
name|xsize
operator|<=
literal|0
operator|||
name|ysize
operator|<=
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|c
operator|>=
literal|0
operator|&&
name|xsize
operator|>
name|c
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|c
operator|<
literal|0
operator|&&
name|ysize
operator|+
name|c
operator|>
literal|0
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
comment|/* This code used to check for conflicts involving stack references and      globals but the base address alias code now handles these cases.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
condition|)
block|{
comment|/* The fact that X is canonicalized means that this 	 PLUS rtx is canonicalized.  */
name|rtx
name|x0
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|x1
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|PLUS
condition|)
block|{
comment|/* The fact that Y is canonicalized means that this 	     PLUS rtx is canonicalized.  */
name|rtx
name|y0
init|=
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|y1
init|=
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|rtx_equal_for_memref_p
argument_list|(
name|x1
argument_list|,
name|y1
argument_list|)
condition|)
return|return
name|memrefs_conflict_p
argument_list|(
name|xsize
argument_list|,
name|x0
argument_list|,
name|ysize
argument_list|,
name|y0
argument_list|,
name|c
argument_list|)
return|;
if|if
condition|(
name|rtx_equal_for_memref_p
argument_list|(
name|x0
argument_list|,
name|y0
argument_list|)
condition|)
return|return
name|memrefs_conflict_p
argument_list|(
name|xsize
argument_list|,
name|x1
argument_list|,
name|ysize
argument_list|,
name|y1
argument_list|,
name|c
argument_list|)
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x1
argument_list|)
operator|==
name|CONST_INT
condition|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|y1
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|memrefs_conflict_p
argument_list|(
name|xsize
argument_list|,
name|x0
argument_list|,
name|ysize
argument_list|,
name|y0
argument_list|,
name|c
operator|-
name|INTVAL
argument_list|(
name|x1
argument_list|)
operator|+
name|INTVAL
argument_list|(
name|y1
argument_list|)
argument_list|)
return|;
else|else
return|return
name|memrefs_conflict_p
argument_list|(
name|xsize
argument_list|,
name|x0
argument_list|,
name|ysize
argument_list|,
name|y
argument_list|,
name|c
operator|-
name|INTVAL
argument_list|(
name|x1
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|y1
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|memrefs_conflict_p
argument_list|(
name|xsize
argument_list|,
name|x
argument_list|,
name|ysize
argument_list|,
name|y0
argument_list|,
name|c
operator|+
name|INTVAL
argument_list|(
name|y1
argument_list|)
argument_list|)
return|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x1
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|memrefs_conflict_p
argument_list|(
name|xsize
argument_list|,
name|x0
argument_list|,
name|ysize
argument_list|,
name|y
argument_list|,
name|c
operator|-
name|INTVAL
argument_list|(
name|x1
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|PLUS
condition|)
block|{
comment|/* The fact that Y is canonicalized means that this 	 PLUS rtx is canonicalized.  */
name|rtx
name|y0
init|=
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|y1
init|=
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|y1
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|memrefs_conflict_p
argument_list|(
name|xsize
argument_list|,
name|x
argument_list|,
name|ysize
argument_list|,
name|y0
argument_list|,
name|c
operator|+
name|INTVAL
argument_list|(
name|y1
argument_list|)
argument_list|)
return|;
else|else
return|return
literal|1
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|GET_CODE
argument_list|(
name|y
argument_list|)
condition|)
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|MULT
case|:
block|{
comment|/* Handle cases where we expect the second operands to be the 	     same, and check only whether the first operand would conflict 	     or not.  */
name|rtx
name|x0
decl_stmt|,
name|y0
decl_stmt|;
name|rtx
name|x1
init|=
name|canon_rtx
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|y1
init|=
name|canon_rtx
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|rtx_equal_for_memref_p
argument_list|(
name|x1
argument_list|,
name|y1
argument_list|)
condition|)
return|return
literal|1
return|;
name|x0
operator|=
name|canon_rtx
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|y0
operator|=
name|canon_rtx
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtx_equal_for_memref_p
argument_list|(
name|x0
argument_list|,
name|y0
argument_list|)
condition|)
return|return
operator|(
name|xsize
operator|==
literal|0
operator|||
name|ysize
operator|==
literal|0
operator|||
operator|(
name|c
operator|>=
literal|0
operator|&&
name|xsize
operator|>
name|c
operator|)
operator|||
operator|(
name|c
operator|<
literal|0
operator|&&
name|ysize
operator|+
name|c
operator|>
literal|0
operator|)
operator|)
return|;
comment|/* Can't properly adjust our sizes.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x1
argument_list|)
operator|!=
name|CONST_INT
condition|)
return|return
literal|1
return|;
name|xsize
operator|/=
name|INTVAL
argument_list|(
name|x1
argument_list|)
expr_stmt|;
name|ysize
operator|/=
name|INTVAL
argument_list|(
name|x1
argument_list|)
expr_stmt|;
name|c
operator|/=
name|INTVAL
argument_list|(
name|x1
argument_list|)
expr_stmt|;
return|return
name|memrefs_conflict_p
argument_list|(
name|xsize
argument_list|,
name|x0
argument_list|,
name|ysize
argument_list|,
name|y0
argument_list|,
name|c
argument_list|)
return|;
block|}
case|case
name|REG
case|:
comment|/* Are these registers known not to be equal?  */
if|if
condition|(
name|alias_invariant
condition|)
block|{
name|int
name|r_x
init|=
name|REGNO
argument_list|(
name|x
argument_list|)
decl_stmt|,
name|r_y
init|=
name|REGNO
argument_list|(
name|y
argument_list|)
decl_stmt|;
name|rtx
name|i_x
decl_stmt|,
name|i_y
decl_stmt|;
comment|/* invariant relationships of X and Y */
name|i_x
operator|=
name|r_x
operator|>=
name|reg_base_value_size
condition|?
literal|0
else|:
name|alias_invariant
index|[
name|r_x
index|]
expr_stmt|;
name|i_y
operator|=
name|r_y
operator|>=
name|reg_base_value_size
condition|?
literal|0
else|:
name|alias_invariant
index|[
name|r_y
index|]
expr_stmt|;
if|if
condition|(
name|i_x
operator|==
literal|0
operator|&&
name|i_y
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
operator|!
name|memrefs_conflict_p
argument_list|(
name|xsize
argument_list|,
name|i_x
condition|?
name|i_x
else|:
name|x
argument_list|,
name|ysize
argument_list|,
name|i_y
condition|?
name|i_y
else|:
name|y
argument_list|,
name|c
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
break|break;
default|default:
break|break;
block|}
comment|/* Treat an access through an AND (e.g. a subword access on an Alpha)      as an access with indeterminate size.      ??? Could instead convert an n byte reference at (and x y) to an      n-y byte reference at (plus x y). */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|AND
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|memrefs_conflict_p
argument_list|(
operator|-
literal|1
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|ysize
argument_list|,
name|y
argument_list|,
name|c
argument_list|)
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|AND
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
comment|/* XXX: If we are indexing far enough into the array/structure, we 	 may yet be able to determine that we can not overlap.  But we  	 also need to that we are far enough from the end not to overlap 	 a following reference, so we do nothing for now.  */
return|return
name|memrefs_conflict_p
argument_list|(
name|xsize
argument_list|,
name|x
argument_list|,
operator|-
literal|1
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|,
name|c
argument_list|)
return|;
block|}
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|c
operator|+=
operator|(
name|INTVAL
argument_list|(
name|y
argument_list|)
operator|-
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|)
expr_stmt|;
return|return
operator|(
name|xsize
operator|<=
literal|0
operator|||
name|ysize
operator|<=
literal|0
operator|||
operator|(
name|c
operator|>=
literal|0
operator|&&
name|xsize
operator|>
name|c
operator|)
operator|||
operator|(
name|c
operator|<
literal|0
operator|&&
name|ysize
operator|+
name|c
operator|>
literal|0
operator|)
operator|)
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|CONST
condition|)
return|return
name|memrefs_conflict_p
argument_list|(
name|xsize
argument_list|,
name|canon_rtx
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|ysize
argument_list|,
name|canon_rtx
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|c
argument_list|)
return|;
else|else
return|return
name|memrefs_conflict_p
argument_list|(
name|xsize
argument_list|,
name|canon_rtx
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|ysize
argument_list|,
name|y
argument_list|,
name|c
argument_list|)
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|CONST
condition|)
return|return
name|memrefs_conflict_p
argument_list|(
name|xsize
argument_list|,
name|x
argument_list|,
name|ysize
argument_list|,
name|canon_rtx
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|c
argument_list|)
return|;
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|y
argument_list|)
condition|)
return|return
operator|(
name|xsize
operator|<
literal|0
operator|||
name|ysize
operator|<
literal|0
operator|||
operator|(
name|rtx_equal_for_memref_p
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
operator|&&
operator|(
name|xsize
operator|==
literal|0
operator|||
name|ysize
operator|==
literal|0
operator|||
operator|(
name|c
operator|>=
literal|0
operator|&&
name|xsize
operator|>
name|c
operator|)
operator|||
operator|(
name|c
operator|<
literal|0
operator|&&
name|ysize
operator|+
name|c
operator|>
literal|0
operator|)
operator|)
operator|)
operator|)
return|;
return|return
literal|1
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Functions to compute memory dependencies.     Since we process the insns in execution order, we can build tables    to keep track of what registers are fixed (and not aliased), what registers    are varying in known ways, and what registers are varying in unknown    ways.     If both memory references are volatile, then there must always be a    dependence between the two references, since their order can not be    changed.  A volatile and non-volatile reference can be interchanged    though.      A MEM_IN_STRUCT reference at a non-QImode non-AND varying address can never    conflict with a non-MEM_IN_STRUCT reference at a fixed address.   We must    allow QImode aliasing because the ANSI C standard allows character    pointers to alias anything.  We are assuming that characters are    always QImode here.  We also must allow AND addresses, because they may    generate accesses outside the object being referenced.  This is used to    generate aligned addresses from unaligned addresses, for instance, the    alpha storeqi_unaligned pattern.  */
end_comment

begin_comment
comment|/* Read dependence: X is read after read in MEM takes place.  There can    only be a dependence here if both reads are volatile.  */
end_comment

begin_function
name|int
name|read_dependence
parameter_list|(
name|mem
parameter_list|,
name|x
parameter_list|)
name|rtx
name|mem
decl_stmt|;
name|rtx
name|x
decl_stmt|;
block|{
return|return
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
operator|&&
name|MEM_VOLATILE_P
argument_list|(
name|mem
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* True dependence: X is read after store in MEM takes place.  */
end_comment

begin_function_decl
name|int
name|true_dependence
parameter_list|(
name|mem
parameter_list|,
name|mem_mode
parameter_list|,
name|x
parameter_list|,
name|varies
parameter_list|)
name|rtx
name|mem
decl_stmt|;
name|enum
name|machine_mode
name|mem_mode
decl_stmt|;
name|rtx
name|x
decl_stmt|;
function_decl|int
parameter_list|(
function_decl|*varies
end_function_decl

begin_expr_stmt
unit|)
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|rtx
name|x_addr
decl_stmt|,
name|mem_addr
decl_stmt|;
if|if
condition|(
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
operator|&&
name|MEM_VOLATILE_P
argument_list|(
name|mem
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|DIFFERENT_ALIAS_SETS_P
argument_list|(
name|x
argument_list|,
name|mem
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* If X is an unchanging read, then it can't possibly conflict with any      non-unchanging store.  It may conflict with an unchanging write though,      because there may be a single store to this address to initialize it.      Just fall through to the code below to resolve the case where we have      both an unchanging read and an unchanging write.  This won't handle all      cases optimally, but the possible performance loss should be      negligible.  */
if|if
condition|(
name|RTX_UNCHANGING_P
argument_list|(
name|x
argument_list|)
operator|&&
operator|!
name|RTX_UNCHANGING_P
argument_list|(
name|mem
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|base_alias_check
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|mem
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
name|x_addr
operator|=
name|canon_rtx
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|mem_addr
operator|=
name|canon_rtx
argument_list|(
name|XEXP
argument_list|(
name|mem
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mem_mode
operator|==
name|VOIDmode
condition|)
name|mem_mode
operator|=
name|GET_MODE
argument_list|(
name|mem
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|memrefs_conflict_p
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|mem_mode
argument_list|)
argument_list|,
name|mem_addr
argument_list|,
name|SIZE_FOR_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|x_addr
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* If both references are struct references, or both are not, nothing      is known about aliasing.       If either reference is QImode or BLKmode, ANSI C permits aliasing.       If both addresses are constant, or both are not, nothing is known      about aliasing.  */
if|if
condition|(
name|MEM_IN_STRUCT_P
argument_list|(
name|x
argument_list|)
operator|==
name|MEM_IN_STRUCT_P
argument_list|(
name|mem
argument_list|)
operator|||
name|mem_mode
operator|==
name|QImode
operator|||
name|mem_mode
operator|==
name|BLKmode
operator|||
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|QImode
operator|||
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|BLKmode
operator|||
name|GET_CODE
argument_list|(
name|x_addr
argument_list|)
operator|==
name|AND
operator|||
name|GET_CODE
argument_list|(
name|mem_addr
argument_list|)
operator|==
name|AND
operator|||
name|varies
argument_list|(
name|x_addr
argument_list|)
operator|==
name|varies
argument_list|(
name|mem_addr
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* One memory reference is to a constant address, one is not.      One is to a structure, the other is not.       If either memory reference is a variable structure the other is a      fixed scalar and there is no aliasing.  */
comment|/* Disabled by default for egcs 1.1.x as alias analysis isn't good      enough yet to discover all cases where this doesn't apply.  */
if|if
condition|(
name|flag_structure_noalias
condition|)
block|{
if|if
condition|(
operator|(
name|MEM_IN_STRUCT_P
argument_list|(
name|mem
argument_list|)
operator|&&
name|varies
argument_list|(
name|mem_addr
argument_list|)
operator|)
operator|||
operator|(
name|MEM_IN_STRUCT_P
argument_list|(
name|x
argument_list|)
operator|&&
name|varies
argument_list|(
name|x_addr
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_block

begin_comment
comment|/* Anti dependence: X is written after read in MEM takes place.  */
end_comment

begin_function
name|int
name|anti_dependence
parameter_list|(
name|mem
parameter_list|,
name|x
parameter_list|)
name|rtx
name|mem
decl_stmt|;
name|rtx
name|x
decl_stmt|;
block|{
name|rtx
name|x_addr
decl_stmt|,
name|mem_addr
decl_stmt|;
if|if
condition|(
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
operator|&&
name|MEM_VOLATILE_P
argument_list|(
name|mem
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* If MEM is an unchanging read, then it can't possibly conflict with      the store to X, because there is at most one store to MEM, and it must      have occurred somewhere before MEM.  */
if|if
condition|(
name|RTX_UNCHANGING_P
argument_list|(
name|mem
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|base_alias_check
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|mem
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
name|x
operator|=
name|canon_rtx
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|mem
operator|=
name|canon_rtx
argument_list|(
name|mem
argument_list|)
expr_stmt|;
if|if
condition|(
name|DIFFERENT_ALIAS_SETS_P
argument_list|(
name|x
argument_list|,
name|mem
argument_list|)
condition|)
return|return
literal|0
return|;
name|x_addr
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mem_addr
operator|=
name|XEXP
argument_list|(
name|mem
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|memrefs_conflict_p
argument_list|(
name|SIZE_FOR_MODE
argument_list|(
name|mem
argument_list|)
argument_list|,
name|mem_addr
argument_list|,
name|SIZE_FOR_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|x_addr
argument_list|,
literal|0
argument_list|)
operator|&&
operator|!
operator|(
name|MEM_IN_STRUCT_P
argument_list|(
name|mem
argument_list|)
operator|&&
name|rtx_addr_varies_p
argument_list|(
name|mem
argument_list|)
operator|&&
name|GET_MODE
argument_list|(
name|mem
argument_list|)
operator|!=
name|QImode
operator|&&
name|GET_CODE
argument_list|(
name|mem_addr
argument_list|)
operator|!=
name|AND
operator|&&
operator|!
name|MEM_IN_STRUCT_P
argument_list|(
name|x
argument_list|)
operator|&&
operator|!
name|rtx_addr_varies_p
argument_list|(
name|x
argument_list|)
operator|)
operator|&&
operator|!
operator|(
name|MEM_IN_STRUCT_P
argument_list|(
name|x
argument_list|)
operator|&&
name|rtx_addr_varies_p
argument_list|(
name|x
argument_list|)
operator|&&
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|QImode
operator|&&
name|GET_CODE
argument_list|(
name|x_addr
argument_list|)
operator|!=
name|AND
operator|&&
operator|!
name|MEM_IN_STRUCT_P
argument_list|(
name|mem
argument_list|)
operator|&&
operator|!
name|rtx_addr_varies_p
argument_list|(
name|mem
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Output dependence: X is written after store in MEM takes place.  */
end_comment

begin_function
name|int
name|output_dependence
parameter_list|(
name|mem
parameter_list|,
name|x
parameter_list|)
specifier|register
name|rtx
name|mem
decl_stmt|;
specifier|register
name|rtx
name|x
decl_stmt|;
block|{
if|if
condition|(
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
operator|&&
name|MEM_VOLATILE_P
argument_list|(
name|mem
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
name|base_alias_check
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|mem
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
name|x
operator|=
name|canon_rtx
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|mem
operator|=
name|canon_rtx
argument_list|(
name|mem
argument_list|)
expr_stmt|;
if|if
condition|(
name|DIFFERENT_ALIAS_SETS_P
argument_list|(
name|x
argument_list|,
name|mem
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|memrefs_conflict_p
argument_list|(
name|SIZE_FOR_MODE
argument_list|(
name|mem
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|mem
argument_list|,
literal|0
argument_list|)
argument_list|,
name|SIZE_FOR_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|&&
operator|!
operator|(
name|MEM_IN_STRUCT_P
argument_list|(
name|mem
argument_list|)
operator|&&
name|rtx_addr_varies_p
argument_list|(
name|mem
argument_list|)
operator|&&
name|GET_MODE
argument_list|(
name|mem
argument_list|)
operator|!=
name|QImode
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|mem
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|AND
operator|&&
operator|!
name|MEM_IN_STRUCT_P
argument_list|(
name|x
argument_list|)
operator|&&
operator|!
name|rtx_addr_varies_p
argument_list|(
name|x
argument_list|)
operator|)
operator|&&
operator|!
operator|(
name|MEM_IN_STRUCT_P
argument_list|(
name|x
argument_list|)
operator|&&
name|rtx_addr_varies_p
argument_list|(
name|x
argument_list|)
operator|&&
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|QImode
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|AND
operator|&&
operator|!
name|MEM_IN_STRUCT_P
argument_list|(
name|mem
argument_list|)
operator|&&
operator|!
name|rtx_addr_varies_p
argument_list|(
name|mem
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|HARD_REG_SET
name|argument_registers
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|init_alias_once
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
ifndef|#
directive|ifndef
name|OUTGOING_REGNO
define|#
directive|define
name|OUTGOING_REGNO
parameter_list|(
name|N
parameter_list|)
value|N
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
comment|/* Check whether this register can hold an incoming pointer        argument.  FUNCTION_ARG_REGNO_P tests outgoing register        numbers, so translate if necessary due to register windows. */
if|if
condition|(
name|FUNCTION_ARG_REGNO_P
argument_list|(
name|OUTGOING_REGNO
argument_list|(
name|i
argument_list|)
argument_list|)
operator|&&
name|HARD_REGNO_MODE_OK
argument_list|(
name|i
argument_list|,
name|Pmode
argument_list|)
condition|)
name|SET_HARD_REG_BIT
argument_list|(
name|argument_registers
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|init_alias_analysis
parameter_list|()
block|{
name|int
name|maxreg
init|=
name|max_reg_num
argument_list|()
decl_stmt|;
name|int
name|changed
decl_stmt|,
name|pass
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|rtx
name|insn
decl_stmt|;
name|reg_known_value_size
operator|=
name|maxreg
expr_stmt|;
name|reg_known_value
operator|=
operator|(
name|rtx
operator|*
operator|)
name|oballoc
argument_list|(
operator|(
name|maxreg
operator|-
name|FIRST_PSEUDO_REGISTER
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
operator|-
name|FIRST_PSEUDO_REGISTER
expr_stmt|;
name|reg_known_equiv_p
operator|=
name|oballoc
argument_list|(
name|maxreg
operator|-
name|FIRST_PSEUDO_REGISTER
argument_list|)
operator|-
name|FIRST_PSEUDO_REGISTER
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|reg_known_value
operator|+
name|FIRST_PSEUDO_REGISTER
operator|)
argument_list|,
operator|(
name|maxreg
operator|-
name|FIRST_PSEUDO_REGISTER
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|reg_known_equiv_p
operator|+
name|FIRST_PSEUDO_REGISTER
argument_list|,
operator|(
name|maxreg
operator|-
name|FIRST_PSEUDO_REGISTER
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Overallocate reg_base_value to allow some growth during loop      optimization.  Loop unrolling can create a large number of      registers.  */
name|reg_base_value_size
operator|=
name|maxreg
operator|*
literal|2
expr_stmt|;
name|reg_base_value
operator|=
operator|(
name|rtx
operator|*
operator|)
name|oballoc
argument_list|(
name|reg_base_value_size
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|new_reg_base_value
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|reg_base_value_size
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|reg_seen
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|reg_base_value_size
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|reg_base_value
argument_list|,
name|reg_base_value_size
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|reload_completed
operator|&&
name|flag_unroll_loops
condition|)
block|{
name|alias_invariant
operator|=
operator|(
name|rtx
operator|*
operator|)
name|xrealloc
argument_list|(
name|alias_invariant
argument_list|,
name|reg_base_value_size
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|alias_invariant
argument_list|,
name|reg_base_value_size
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* The basic idea is that each pass through this loop will use the      "constant" information from the previous pass to propagate alias      information through another level of assignments.       This could get expensive if the assignment chains are long.  Maybe      we should throttle the number of iterations, possibly based on      the optimization level or flag_expensive_optimizations.       We could propagate more information in the first pass by making use      of REG_N_SETS to determine immediately that the alias information      for a pseudo is "constant".       A program with an uninitialized variable can cause an infinite loop      here.  Instead of doing a full dataflow analysis to detect such problems      we just cap the number of iterations for the loop.       The state of the arrays for the set chain in question does not matter      since the program has undefined behavior.  */
name|pass
operator|=
literal|0
expr_stmt|;
do|do
block|{
comment|/* Assume nothing will change this iteration of the loop.  */
name|changed
operator|=
literal|0
expr_stmt|;
comment|/* We want to assign the same IDs each iteration of this loop, so 	 start counting from zero each iteration of the loop.  */
name|unique_id
operator|=
literal|0
expr_stmt|;
comment|/* We're at the start of the funtion each iteration through the 	 loop, so we're copying arguments.  */
name|copying_arguments
operator|=
literal|1
expr_stmt|;
comment|/* Wipe the potential alias information clean for this pass.  */
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|new_reg_base_value
argument_list|,
name|reg_base_value_size
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Wipe the reg_seen array clean.  */
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|reg_seen
argument_list|,
name|reg_base_value_size
argument_list|)
expr_stmt|;
comment|/* Mark all hard registers which may contain an address. 	 The stack, frame and argument pointers may contain an address. 	 An argument register which can hold a Pmode value may contain 	 an address even if it is not in BASE_REGS.  	 The address expression is VOIDmode for an argument and 	 Pmode for other registers.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|argument_registers
argument_list|,
name|i
argument_list|)
condition|)
name|new_reg_base_value
index|[
name|i
index|]
operator|=
name|gen_rtx_ADDRESS
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|new_reg_base_value
index|[
name|STACK_POINTER_REGNUM
index|]
operator|=
name|gen_rtx_ADDRESS
argument_list|(
name|Pmode
argument_list|,
name|stack_pointer_rtx
argument_list|)
expr_stmt|;
name|new_reg_base_value
index|[
name|ARG_POINTER_REGNUM
index|]
operator|=
name|gen_rtx_ADDRESS
argument_list|(
name|Pmode
argument_list|,
name|arg_pointer_rtx
argument_list|)
expr_stmt|;
name|new_reg_base_value
index|[
name|FRAME_POINTER_REGNUM
index|]
operator|=
name|gen_rtx_ADDRESS
argument_list|(
name|Pmode
argument_list|,
name|frame_pointer_rtx
argument_list|)
expr_stmt|;
if|#
directive|if
name|HARD_FRAME_POINTER_REGNUM
operator|!=
name|FRAME_POINTER_REGNUM
name|new_reg_base_value
index|[
name|HARD_FRAME_POINTER_REGNUM
index|]
operator|=
name|gen_rtx_ADDRESS
argument_list|(
name|Pmode
argument_list|,
name|hard_frame_pointer_rtx
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|struct_value_incoming_rtx
operator|&&
name|GET_CODE
argument_list|(
name|struct_value_incoming_rtx
argument_list|)
operator|==
name|REG
condition|)
name|new_reg_base_value
index|[
name|REGNO
argument_list|(
name|struct_value_incoming_rtx
argument_list|)
index|]
operator|=
name|gen_rtx_ADDRESS
argument_list|(
name|Pmode
argument_list|,
name|struct_value_incoming_rtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|static_chain_rtx
operator|&&
name|GET_CODE
argument_list|(
name|static_chain_rtx
argument_list|)
operator|==
name|REG
condition|)
name|new_reg_base_value
index|[
name|REGNO
argument_list|(
name|static_chain_rtx
argument_list|)
index|]
operator|=
name|gen_rtx_ADDRESS
argument_list|(
name|Pmode
argument_list|,
name|static_chain_rtx
argument_list|)
expr_stmt|;
comment|/* Walk the insns adding values to the new_reg_base_value array.  */
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
literal|'i'
condition|)
block|{
name|rtx
name|note
decl_stmt|,
name|set
decl_stmt|;
comment|/* If this insn has a noalias note, process it,  Otherwise, 	         scan for sets.  A simple set will have no side effects 	         which could change the base value of any other register. */
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
operator|(
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_NOALIAS
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
condition|)
name|record_set
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
else|else
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|record_set
argument_list|)
expr_stmt|;
name|set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|set
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
operator|(
operator|(
operator|(
name|note
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_EQUAL
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|REG_N_SETS
argument_list|(
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|1
operator|)
operator|||
operator|(
name|note
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_EQUIV
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
operator|!=
literal|0
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|EXPR_LIST
operator|&&
operator|!
name|reg_overlap_mentioned_p
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
decl_stmt|;
name|reg_known_value
index|[
name|regno
index|]
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|reg_known_equiv_p
index|[
name|regno
index|]
operator|=
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
operator|==
name|REG_EQUIV
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_FUNCTION_BEG
condition|)
name|copying_arguments
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Now propagate values from new_reg_base_value to reg_base_value.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|reg_base_value_size
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|new_reg_base_value
index|[
name|i
index|]
operator|&&
name|new_reg_base_value
index|[
name|i
index|]
operator|!=
name|reg_base_value
index|[
name|i
index|]
operator|&&
operator|!
name|rtx_equal_p
argument_list|(
name|new_reg_base_value
index|[
name|i
index|]
argument_list|,
name|reg_base_value
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|reg_base_value
index|[
name|i
index|]
operator|=
name|new_reg_base_value
index|[
name|i
index|]
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
name|changed
operator|&&
operator|++
name|pass
operator|<
name|MAX_ALIAS_LOOP_PASSES
condition|)
do|;
comment|/* Fill in the remaining entries.  */
for|for
control|(
name|i
operator|=
name|FIRST_PSEUDO_REGISTER
init|;
name|i
operator|<
name|maxreg
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|reg_known_value
index|[
name|i
index|]
operator|==
literal|0
condition|)
name|reg_known_value
index|[
name|i
index|]
operator|=
name|regno_reg_rtx
index|[
name|i
index|]
expr_stmt|;
comment|/* Simplify the reg_base_value array so that no register refers to      another register, except to special registers indirectly through      ADDRESS expressions.       In theory this loop can take as long as O(registers^2), but unless      there are very long dependency chains it will run in close to linear      time.       This loop may not be needed any longer now that the main loop does      a better job at propagating alias information.  */
name|pass
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|changed
operator|=
literal|0
expr_stmt|;
name|pass
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|reg_base_value_size
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|base
init|=
name|reg_base_value
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|base
operator|&&
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|REG
condition|)
block|{
name|int
name|base_regno
init|=
name|REGNO
argument_list|(
name|base
argument_list|)
decl_stmt|;
if|if
condition|(
name|base_regno
operator|==
name|i
condition|)
comment|/* register set from itself */
name|reg_base_value
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
else|else
name|reg_base_value
index|[
name|i
index|]
operator|=
name|reg_base_value
index|[
name|base_regno
index|]
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
name|changed
operator|&&
name|pass
operator|<
name|MAX_ALIAS_LOOP_PASSES
condition|)
do|;
name|new_reg_base_value
operator|=
literal|0
expr_stmt|;
name|reg_seen
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|end_alias_analysis
parameter_list|()
block|{
name|reg_known_value
operator|=
literal|0
expr_stmt|;
name|reg_base_value
operator|=
literal|0
expr_stmt|;
name|reg_base_value_size
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|alias_invariant
condition|)
block|{
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|alias_invariant
argument_list|)
expr_stmt|;
name|alias_invariant
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

end_unit

