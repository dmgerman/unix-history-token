begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Alias analysis for GNU C    Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003    Free Software Foundation, Inc.    Contributed by John Carr (jfc@mit.edu).  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"cselib.h"
end_include

begin_include
include|#
directive|include
file|"splay-tree.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_comment
comment|/* The alias sets assigned to MEMs assist the back-end in determining    which MEMs can alias which other MEMs.  In general, two MEMs in    different alias sets cannot alias each other, with one important    exception.  Consider something like:       struct S {int i; double d; };     a store to an `S' can alias something of either type `int' or type    `double'.  (However, a store to an `int' cannot alias a `double'    and vice versa.)  We indicate this via a tree structure that looks    like:            struct S             /   \ 	   /     \          |/_     _\|          int    double     (The arrows are directed and point downwards.)     In this situation we say the alias set for `struct S' is the    `superset' and that those for `int' and `double' are `subsets'.     To see whether two alias sets can point to the same memory, we must    see if either alias set is a subset of the other. We need not trace    past immediate descendents, however, since we propagate all    grandchildren up one level.     Alias set zero is implicitly a superset of all other alias sets.    However, this is no actual entry for alias set zero.  It is an    error to attempt to explicitly construct a subset of zero.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|alias_set_entry
block|{
comment|/* The alias set number, as stored in MEM_ALIAS_SET.  */
name|HOST_WIDE_INT
name|alias_set
decl_stmt|;
comment|/* The children of the alias set.  These are not just the immediate      children, but, in fact, all descendents.  So, if we have:         struct T { struct S s; float f; }       continuing our example above, the children here will be all of      `int', `double', `float', and `struct S'.  */
name|splay_tree
name|children
decl_stmt|;
comment|/* Nonzero if would have a child of zero: this effectively makes this      alias set the same as alias set zero.  */
name|int
name|has_zero_child
decl_stmt|;
block|}
typedef|*
name|alias_set_entry
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|int
name|rtx_equal_for_memref_p
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|find_symbolic_term
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|get_addr
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|memrefs_conflict_p
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|rtx
operator|,
name|int
operator|,
name|rtx
operator|,
name|HOST_WIDE_INT
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|record_set
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|find_base_term
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|base_alias_check
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
expr|enum
name|machine_mode
operator|,
expr|enum
name|machine_mode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|find_base_value
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mems_in_disjoint_alias_sets_p
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|insert_subset_children
name|PARAMS
argument_list|(
operator|(
name|splay_tree_node
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|find_base_decl
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|alias_set_entry
name|get_alias_set_entry
name|PARAMS
argument_list|(
operator|(
name|HOST_WIDE_INT
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|fixed_scalar_and_varying_struct_p
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|int
argument_list|(
operator|*
argument_list|)
argument_list|(
name|rtx
argument_list|,
name|int
argument_list|)
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|aliases_everything_p
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|nonoverlapping_component_refs_p
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|decl_for_component_ref
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|adjust_offset_for_component_ref
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nonoverlapping_memrefs_p
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|write_dependence_p
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nonlocal_mentioned_p_1
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nonlocal_mentioned_p
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nonlocal_referenced_p_1
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nonlocal_referenced_p
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nonlocal_set_p_1
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nonlocal_set_p
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set up all info needed to perform alias analysis on memory references.  */
end_comment

begin_comment
comment|/* Returns the size in bytes of the mode of X.  */
end_comment

begin_define
define|#
directive|define
name|SIZE_FOR_MODE
parameter_list|(
name|X
parameter_list|)
value|(GET_MODE_SIZE (GET_MODE (X)))
end_define

begin_comment
comment|/* Returns nonzero if MEM1 and MEM2 do not alias because they are in    different alias sets.  We ignore alias sets in functions making use    of variable arguments because the va_arg macros on some systems are    not legal ANSI C.  */
end_comment

begin_define
define|#
directive|define
name|DIFFERENT_ALIAS_SETS_P
parameter_list|(
name|MEM1
parameter_list|,
name|MEM2
parameter_list|)
define|\
value|mems_in_disjoint_alias_sets_p (MEM1, MEM2)
end_define

begin_comment
comment|/* Cap the number of passes we make over the insns propagating alias    information through set chains.   10 is a completely arbitrary choice.  */
end_comment

begin_define
define|#
directive|define
name|MAX_ALIAS_LOOP_PASSES
value|10
end_define

begin_comment
comment|/* reg_base_value[N] gives an address to which register N is related.    If all sets after the first add or subtract to the current value    or otherwise modify it so it does not point to a different top level    object, reg_base_value[N] is equal to the address part of the source    of the first set.     A base address can be an ADDRESS, SYMBOL_REF, or LABEL_REF.  ADDRESS    expressions represent certain special values: function arguments and    the stack, frame, and argument pointers.     The contents of an ADDRESS is not normally used, the mode of the    ADDRESS determines whether the ADDRESS is a function argument or some    other special value.  Pointer equality, not rtx_equal_p, determines whether    two ADDRESS expressions refer to the same base address.     The only use of the contents of an ADDRESS is for determining if the    current function performs nonlocal memory memory references for the    purposes of marking the function as a constant function.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|(length (
literal|"reg_base_value_size"
argument|))
argument_list|)
name|rtx
operator|*
name|reg_base_value
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|rtx
modifier|*
name|new_reg_base_value
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|reg_base_value_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* size of reg_base_value array */
end_comment

begin_comment
comment|/* Static hunks of RTL used by the aliasing code; these are initialized    once per function to avoid unnecessary RTL allocations.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|rtx
name|static_reg_base_value
index|[
name|FIRST_PSEUDO_REGISTER
index|]
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|REG_BASE_VALUE
parameter_list|(
name|X
parameter_list|)
define|\
value|(REGNO (X)< reg_base_value_size \    ? reg_base_value[REGNO (X)] : 0)
end_define

begin_comment
comment|/* Vector of known invariant relationships between registers.  Set in    loop unrolling.  Indexed by register number, if nonzero the value    is an expression describing this register in terms of another.     The length of this array is REG_BASE_VALUE_SIZE.     Because this array contains only pseudo registers it has no effect    after reload.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
modifier|*
name|alias_invariant
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Vector indexed by N giving the initial (unchanging) value known for    pseudo-register N.  This array is initialized in    init_alias_analysis, and does not change until end_alias_analysis    is called.  */
end_comment

begin_decl_stmt
name|rtx
modifier|*
name|reg_known_value
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indicates number of valid entries in reg_known_value.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|reg_known_value_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Vector recording for each reg_known_value whether it is due to a    REG_EQUIV note.  Future passes (viz., reload) may replace the    pseudo with the equivalent expression and so we account for the    dependences that would be introduced if that happens.     The REG_EQUIV notes created in assign_parms may mention the arg    pointer, and there are explicit insns in the RTL that modify the    arg pointer.  Thus we must ensure that such insns don't get    scheduled across each other because that would invalidate the    REG_EQUIV notes.  One could argue that the REG_EQUIV notes are    wrong, but solving the problem in the scheduler will likely give    better code, so we do it here.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|reg_known_equiv_p
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* True when scanning insns from the start of the rtl to the    NOTE_INSN_FUNCTION_BEG note.  */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|copying_arguments
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The splay-tree used to store the various alias set entries.  */
end_comment

begin_decl_stmt
specifier|static
name|splay_tree
name|alias_sets
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Returns a pointer to the alias set entry for ALIAS_SET, if there is    such an entry, or NULL otherwise.  */
end_comment

begin_function
specifier|static
name|alias_set_entry
name|get_alias_set_entry
parameter_list|(
name|alias_set
parameter_list|)
name|HOST_WIDE_INT
name|alias_set
decl_stmt|;
block|{
name|splay_tree_node
name|sn
init|=
name|splay_tree_lookup
argument_list|(
name|alias_sets
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|alias_set
argument_list|)
decl_stmt|;
return|return
name|sn
operator|!=
literal|0
condition|?
operator|(
operator|(
name|alias_set_entry
operator|)
name|sn
operator|->
name|value
operator|)
else|:
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Returns nonzero if the alias sets for MEM1 and MEM2 are such that    the two MEMs cannot alias each other.  */
end_comment

begin_function
specifier|static
name|int
name|mems_in_disjoint_alias_sets_p
parameter_list|(
name|mem1
parameter_list|,
name|mem2
parameter_list|)
name|rtx
name|mem1
decl_stmt|;
name|rtx
name|mem2
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
comment|/* Perform a basic sanity check.  Namely, that there are no alias sets    if we're not using strict aliasing.  This helps to catch bugs    whereby someone uses PUT_CODE, but doesn't clear MEM_ALIAS_SET, or    where a MEM is allocated in some way other than by the use of    gen_rtx_MEM, and the MEM_ALIAS_SET is not cleared.  If we begin to    use alias sets to indicate that spilled registers cannot alias each    other, we might need to remove this check.  */
if|if
condition|(
operator|!
name|flag_strict_aliasing
operator|&&
operator|(
name|MEM_ALIAS_SET
argument_list|(
name|mem1
argument_list|)
operator|!=
literal|0
operator|||
name|MEM_ALIAS_SET
argument_list|(
name|mem2
argument_list|)
operator|!=
literal|0
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
return|return
operator|!
name|alias_sets_conflict_p
argument_list|(
name|MEM_ALIAS_SET
argument_list|(
name|mem1
argument_list|)
argument_list|,
name|MEM_ALIAS_SET
argument_list|(
name|mem2
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Insert the NODE into the splay tree given by DATA.  Used by    record_alias_subset via splay_tree_foreach.  */
end_comment

begin_function
specifier|static
name|int
name|insert_subset_children
parameter_list|(
name|node
parameter_list|,
name|data
parameter_list|)
name|splay_tree_node
name|node
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
name|splay_tree_insert
argument_list|(
operator|(
name|splay_tree
operator|)
name|data
argument_list|,
name|node
operator|->
name|key
argument_list|,
name|node
operator|->
name|value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if the two specified alias sets may conflict.  */
end_comment

begin_function
name|int
name|alias_sets_conflict_p
parameter_list|(
name|set1
parameter_list|,
name|set2
parameter_list|)
name|HOST_WIDE_INT
name|set1
decl_stmt|,
name|set2
decl_stmt|;
block|{
name|alias_set_entry
name|ase
decl_stmt|;
comment|/* If have no alias set information for one of the operands, we have      to assume it can alias anything.  */
if|if
condition|(
name|set1
operator|==
literal|0
operator|||
name|set2
operator|==
literal|0
comment|/* If the two alias sets are the same, they may alias.  */
operator|||
name|set1
operator|==
name|set2
condition|)
return|return
literal|1
return|;
comment|/* See if the first alias set is a subset of the second.  */
name|ase
operator|=
name|get_alias_set_entry
argument_list|(
name|set1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ase
operator|!=
literal|0
operator|&&
operator|(
name|ase
operator|->
name|has_zero_child
operator|||
name|splay_tree_lookup
argument_list|(
name|ase
operator|->
name|children
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|set2
argument_list|)
operator|)
condition|)
return|return
literal|1
return|;
comment|/* Now do the same, but with the alias sets reversed.  */
name|ase
operator|=
name|get_alias_set_entry
argument_list|(
name|set2
argument_list|)
expr_stmt|;
if|if
condition|(
name|ase
operator|!=
literal|0
operator|&&
operator|(
name|ase
operator|->
name|has_zero_child
operator|||
name|splay_tree_lookup
argument_list|(
name|ase
operator|->
name|children
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|set1
argument_list|)
operator|)
condition|)
return|return
literal|1
return|;
comment|/* The two alias sets are distinct and neither one is the      child of the other.  Therefore, they cannot alias.  */
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if TYPE is a RECORD_TYPE, UNION_TYPE, or QUAL_UNION_TYPE and has    has any readonly fields.  If any of the fields have types that    contain readonly fields, return true as well.  */
end_comment

begin_function
name|int
name|readonly_fields_p
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|field
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|RECORD_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|UNION_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|QUAL_UNION_TYPE
condition|)
return|return
literal|0
return|;
for|for
control|(
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|field
operator|!=
literal|0
condition|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|FIELD_DECL
operator|&&
operator|(
name|TREE_READONLY
argument_list|(
name|field
argument_list|)
operator|||
name|readonly_fields_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if any MEM object of type T1 will always conflict (using the    dependency routines in this file) with any MEM object of type T2.    This is used when allocating temporary storage.  If T1 and/or T2 are    NULL_TREE, it means we know nothing about the storage.  */
end_comment

begin_function
name|int
name|objects_must_conflict_p
parameter_list|(
name|t1
parameter_list|,
name|t2
parameter_list|)
name|tree
name|t1
decl_stmt|,
name|t2
decl_stmt|;
block|{
name|HOST_WIDE_INT
name|set1
decl_stmt|,
name|set2
decl_stmt|;
comment|/* If neither has a type specified, we don't know if they'll conflict      because we may be using them to store objects of various types, for      example the argument and local variables areas of inlined functions.  */
if|if
condition|(
name|t1
operator|==
literal|0
operator|&&
name|t2
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* If one or the other has readonly fields or is readonly,      then they may not conflict.  */
if|if
condition|(
operator|(
name|t1
operator|!=
literal|0
operator|&&
name|readonly_fields_p
argument_list|(
name|t1
argument_list|)
operator|)
operator|||
operator|(
name|t2
operator|!=
literal|0
operator|&&
name|readonly_fields_p
argument_list|(
name|t2
argument_list|)
operator|)
operator|||
operator|(
name|t1
operator|!=
literal|0
operator|&&
name|lang_hooks
operator|.
name|honor_readonly
operator|&&
name|TYPE_READONLY
argument_list|(
name|t1
argument_list|)
operator|)
operator|||
operator|(
name|t2
operator|!=
literal|0
operator|&&
name|lang_hooks
operator|.
name|honor_readonly
operator|&&
name|TYPE_READONLY
argument_list|(
name|t2
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
comment|/* If they are the same type, they must conflict.  */
if|if
condition|(
name|t1
operator|==
name|t2
comment|/* Likewise if both are volatile.  */
operator|||
operator|(
name|t1
operator|!=
literal|0
operator|&&
name|TYPE_VOLATILE
argument_list|(
name|t1
argument_list|)
operator|&&
name|t2
operator|!=
literal|0
operator|&&
name|TYPE_VOLATILE
argument_list|(
name|t2
argument_list|)
operator|)
condition|)
return|return
literal|1
return|;
name|set1
operator|=
name|t1
condition|?
name|get_alias_set
argument_list|(
name|t1
argument_list|)
else|:
literal|0
expr_stmt|;
name|set2
operator|=
name|t2
condition|?
name|get_alias_set
argument_list|(
name|t2
argument_list|)
else|:
literal|0
expr_stmt|;
comment|/* Otherwise they conflict if they have no alias set or the same. We      can't simply use alias_sets_conflict_p here, because we must make      sure that every subtype of t1 will conflict with every subtype of      t2 for which a pair of subobjects of these respective subtypes      overlaps on the stack.  */
return|return
name|set1
operator|==
literal|0
operator|||
name|set2
operator|==
literal|0
operator|||
name|set1
operator|==
name|set2
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* T is an expression with pointer type.  Find the DECL on which this    expression is based.  (For example, in `a[i]' this would be `a'.)    If there is no such DECL, or a unique decl cannot be determined,    NULL_TREE is returned.  */
end_comment

begin_function
specifier|static
name|tree
name|find_base_decl
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
name|tree
name|d0
decl_stmt|,
name|d1
decl_stmt|,
name|d2
decl_stmt|;
if|if
condition|(
name|t
operator|==
literal|0
operator|||
name|t
operator|==
name|error_mark_node
operator|||
operator|!
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* If this is a declaration, return it.  */
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
literal|'d'
condition|)
return|return
name|t
return|;
comment|/* Handle general expressions.  It would be nice to deal with      COMPONENT_REFs here.  If we could tell that `a' and `b' were the      same, then `a->f' and `b->f' are also the same.  */
switch|switch
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
block|{
case|case
literal|'1'
case|:
return|return
name|find_base_decl
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
case|case
literal|'2'
case|:
comment|/* Return 0 if found in neither or both are the same.  */
name|d0
operator|=
name|find_base_decl
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|d1
operator|=
name|find_base_decl
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|d0
operator|==
name|d1
condition|)
return|return
name|d0
return|;
elseif|else
if|if
condition|(
name|d0
operator|==
literal|0
condition|)
return|return
name|d1
return|;
elseif|else
if|if
condition|(
name|d1
operator|==
literal|0
condition|)
return|return
name|d0
return|;
else|else
return|return
literal|0
return|;
case|case
literal|'3'
case|:
name|d0
operator|=
name|find_base_decl
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|d1
operator|=
name|find_base_decl
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|d2
operator|=
name|find_base_decl
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set any nonzero values from the last, then from the first.  */
if|if
condition|(
name|d1
operator|==
literal|0
condition|)
name|d1
operator|=
name|d2
expr_stmt|;
if|if
condition|(
name|d0
operator|==
literal|0
condition|)
name|d0
operator|=
name|d1
expr_stmt|;
if|if
condition|(
name|d1
operator|==
literal|0
condition|)
name|d1
operator|=
name|d0
expr_stmt|;
if|if
condition|(
name|d2
operator|==
literal|0
condition|)
name|d2
operator|=
name|d1
expr_stmt|;
comment|/* At this point all are nonzero or all are zero.  If all three are the 	 same, return it.  Otherwise, return zero.  */
return|return
operator|(
name|d0
operator|==
name|d1
operator|&&
name|d1
operator|==
name|d2
operator|)
condition|?
name|d0
else|:
literal|0
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return 1 if all the nested component references handled by    get_inner_reference in T are such that we can address the object in T.  */
end_comment

begin_function
name|int
name|can_address_p
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
comment|/* If we're at the end, it is vacuously addressable.  */
if|if
condition|(
operator|!
name|handled_component_p
argument_list|(
name|t
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Bitfields are never addressable.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|BIT_FIELD_REF
condition|)
return|return
literal|0
return|;
comment|/* Fields are addressable unless they are marked as nonaddressable or      the containing type has alias set 0.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|COMPONENT_REF
operator|&&
operator|!
name|DECL_NONADDRESSABLE_P
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|get_alias_set
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|!=
literal|0
operator|&&
name|can_address_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Likewise for arrays.  */
elseif|else
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|ARRAY_REF
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|ARRAY_RANGE_REF
operator|)
operator|&&
operator|!
name|TYPE_NONALIASED_COMPONENT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|get_alias_set
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|!=
literal|0
operator|&&
name|can_address_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return the alias set for T, which may be either a type or an    expression.  Call language-specific routine for help, if needed.  */
end_comment

begin_function
name|HOST_WIDE_INT
name|get_alias_set
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
name|HOST_WIDE_INT
name|set
decl_stmt|;
comment|/* If we're not doing any alias analysis, just assume everything      aliases everything else.  Also return 0 if this or its type is      an error.  */
if|if
condition|(
operator|!
name|flag_strict_aliasing
operator|||
name|t
operator|==
name|error_mark_node
operator|||
operator|(
operator|!
name|TYPE_P
argument_list|(
name|t
argument_list|)
operator|&&
operator|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|==
literal|0
operator|||
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|==
name|error_mark_node
operator|)
operator|)
condition|)
return|return
literal|0
return|;
comment|/* We can be passed either an expression or a type.  This and the      language-specific routine may make mutually-recursive calls to each other      to figure out what to do.  At each juncture, we see if this is a tree      that the language may need to handle specially.  First handle things that      aren't types.  */
if|if
condition|(
operator|!
name|TYPE_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|tree
name|inner
init|=
name|t
decl_stmt|;
name|tree
name|placeholder_ptr
init|=
literal|0
decl_stmt|;
comment|/* Remove any nops, then give the language a chance to do 	 something with this tree before we look at it.  */
name|STRIP_NOPS
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|set
operator|=
call|(
modifier|*
name|lang_hooks
operator|.
name|get_alias_set
call|)
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|set
operator|!=
operator|-
literal|1
condition|)
return|return
name|set
return|;
comment|/* First see if the actual object referenced is an INDIRECT_REF from a 	 restrict-qualified pointer or a "void *".  Replace 	 PLACEHOLDER_EXPRs.  */
while|while
condition|(
name|TREE_CODE
argument_list|(
name|inner
argument_list|)
operator|==
name|PLACEHOLDER_EXPR
operator|||
name|handled_component_p
argument_list|(
name|inner
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|inner
argument_list|)
operator|==
name|PLACEHOLDER_EXPR
condition|)
name|inner
operator|=
name|find_placeholder
argument_list|(
name|inner
argument_list|,
operator|&
name|placeholder_ptr
argument_list|)
expr_stmt|;
else|else
name|inner
operator|=
name|TREE_OPERAND
argument_list|(
name|inner
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|inner
argument_list|)
expr_stmt|;
block|}
comment|/* Check for accesses through restrict-qualified pointers.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|inner
argument_list|)
operator|==
name|INDIRECT_REF
condition|)
block|{
name|tree
name|decl
init|=
name|find_base_decl
argument_list|(
name|TREE_OPERAND
argument_list|(
name|inner
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|decl
operator|&&
name|DECL_POINTER_ALIAS_SET_KNOWN_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* If we haven't computed the actual alias set, do it now.  */
if|if
condition|(
name|DECL_POINTER_ALIAS_SET
argument_list|(
name|decl
argument_list|)
operator|==
operator|-
literal|2
condition|)
block|{
comment|/* No two restricted pointers can point at the same thing. 		     However, a restricted pointer can point at the same thing 		     as an unrestricted pointer, if that unrestricted pointer 		     is based on the restricted pointer.  So, we make the 		     alias set for the restricted pointer a subset of the 		     alias set for the type pointed to by the type of the 		     decl.  */
name|HOST_WIDE_INT
name|pointed_to_alias_set
init|=
name|get_alias_set
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|pointed_to_alias_set
operator|==
literal|0
condition|)
comment|/* It's not legal to make a subset of alias set zero.  */
empty_stmt|;
else|else
block|{
name|DECL_POINTER_ALIAS_SET
argument_list|(
name|decl
argument_list|)
operator|=
name|new_alias_set
argument_list|()
expr_stmt|;
name|record_alias_subset
argument_list|(
name|pointed_to_alias_set
argument_list|,
name|DECL_POINTER_ALIAS_SET
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* We use the alias set indicated in the declaration.  */
return|return
name|DECL_POINTER_ALIAS_SET
argument_list|(
name|decl
argument_list|)
return|;
block|}
comment|/* If we have an INDIRECT_REF via a void pointer, we don't 	     know anything about what that might alias.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|inner
argument_list|)
argument_list|)
operator|==
name|VOID_TYPE
condition|)
return|return
literal|0
return|;
block|}
comment|/* Otherwise, pick up the outermost object that we could have a pointer 	 to, processing conversion and PLACEHOLDER_EXPR as above.  */
name|placeholder_ptr
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|PLACEHOLDER_EXPR
operator|||
operator|(
name|handled_component_p
argument_list|(
name|t
argument_list|)
operator|&&
operator|!
name|can_address_p
argument_list|(
name|t
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|PLACEHOLDER_EXPR
condition|)
name|t
operator|=
name|find_placeholder
argument_list|(
name|t
argument_list|,
operator|&
name|placeholder_ptr
argument_list|)
expr_stmt|;
else|else
name|t
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
comment|/* If we've already determined the alias set for a decl, just return 	 it.  This is necessary for C++ anonymous unions, whose component 	 variables don't look like union members (boo!).  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_RTL_SET_P
argument_list|(
name|t
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
return|return
name|MEM_ALIAS_SET
argument_list|(
name|DECL_RTL
argument_list|(
name|t
argument_list|)
argument_list|)
return|;
comment|/* Now all we care about is the type.  */
name|t
operator|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
comment|/* Variant qualifiers don't affect the alias set, so get the main      variant. If this is a type with a known alias set, return it.  */
name|t
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_ALIAS_SET_KNOWN_P
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|TYPE_ALIAS_SET
argument_list|(
name|t
argument_list|)
return|;
comment|/* See if the language has special handling for this type.  */
name|set
operator|=
call|(
modifier|*
name|lang_hooks
operator|.
name|get_alias_set
call|)
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|set
operator|!=
operator|-
literal|1
condition|)
return|return
name|set
return|;
comment|/* There are no objects of FUNCTION_TYPE, so there's no point in      using up an alias set for them.  (There are, of course, pointers      and references to functions, but that's different.)  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|set
operator|=
literal|0
expr_stmt|;
comment|/* Unless the language specifies otherwise, let vector types alias      their components.  This avoids some nasty type punning issues in      normal usage.  And indeed lets vectors be treated more like an      array slice.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|VECTOR_TYPE
condition|)
name|set
operator|=
name|get_alias_set
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
else|else
comment|/* Otherwise make a new alias set for this type.  */
name|set
operator|=
name|new_alias_set
argument_list|()
expr_stmt|;
name|TYPE_ALIAS_SET
argument_list|(
name|t
argument_list|)
operator|=
name|set
expr_stmt|;
comment|/* If this is an aggregate type, we must record any component aliasing      information.  */
if|if
condition|(
name|AGGREGATE_TYPE_P
argument_list|(
name|t
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|COMPLEX_TYPE
condition|)
name|record_component_aliases
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|set
return|;
block|}
end_function

begin_comment
comment|/* Return a brand-new alias set.  */
end_comment

begin_function
name|HOST_WIDE_INT
name|new_alias_set
parameter_list|()
block|{
specifier|static
name|HOST_WIDE_INT
name|last_alias_set
decl_stmt|;
if|if
condition|(
name|flag_strict_aliasing
condition|)
return|return
operator|++
name|last_alias_set
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Indicate that things in SUBSET can alias things in SUPERSET, but    not vice versa.  For example, in C, a store to an `int' can alias a    structure containing an `int', but not vice versa.  Here, the    structure would be the SUPERSET and `int' the SUBSET.  This    function should be called only once per SUPERSET/SUBSET pair.     It is illegal for SUPERSET to be zero; everything is implicitly a    subset of alias set zero.  */
end_comment

begin_function
name|void
name|record_alias_subset
parameter_list|(
name|superset
parameter_list|,
name|subset
parameter_list|)
name|HOST_WIDE_INT
name|superset
decl_stmt|;
name|HOST_WIDE_INT
name|subset
decl_stmt|;
block|{
name|alias_set_entry
name|superset_entry
decl_stmt|;
name|alias_set_entry
name|subset_entry
decl_stmt|;
comment|/* It is possible in complex type situations for both sets to be the same,      in which case we can ignore this operation.  */
if|if
condition|(
name|superset
operator|==
name|subset
condition|)
return|return;
if|if
condition|(
name|superset
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|superset_entry
operator|=
name|get_alias_set_entry
argument_list|(
name|superset
argument_list|)
expr_stmt|;
if|if
condition|(
name|superset_entry
operator|==
literal|0
condition|)
block|{
comment|/* Create an entry for the SUPERSET, so that we have a place to 	 attach the SUBSET.  */
name|superset_entry
operator|=
operator|(
name|alias_set_entry
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|alias_set_entry
argument_list|)
argument_list|)
expr_stmt|;
name|superset_entry
operator|->
name|alias_set
operator|=
name|superset
expr_stmt|;
name|superset_entry
operator|->
name|children
operator|=
name|splay_tree_new
argument_list|(
name|splay_tree_compare_ints
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|superset_entry
operator|->
name|has_zero_child
operator|=
literal|0
expr_stmt|;
name|splay_tree_insert
argument_list|(
name|alias_sets
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|superset
argument_list|,
operator|(
name|splay_tree_value
operator|)
name|superset_entry
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|subset
operator|==
literal|0
condition|)
name|superset_entry
operator|->
name|has_zero_child
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|subset_entry
operator|=
name|get_alias_set_entry
argument_list|(
name|subset
argument_list|)
expr_stmt|;
comment|/* If there is an entry for the subset, enter all of its children 	 (if they are not already present) as children of the SUPERSET.  */
if|if
condition|(
name|subset_entry
condition|)
block|{
if|if
condition|(
name|subset_entry
operator|->
name|has_zero_child
condition|)
name|superset_entry
operator|->
name|has_zero_child
operator|=
literal|1
expr_stmt|;
name|splay_tree_foreach
argument_list|(
name|subset_entry
operator|->
name|children
argument_list|,
name|insert_subset_children
argument_list|,
name|superset_entry
operator|->
name|children
argument_list|)
expr_stmt|;
block|}
comment|/* Enter the SUBSET itself as a child of the SUPERSET.  */
name|splay_tree_insert
argument_list|(
name|superset_entry
operator|->
name|children
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|subset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Record that component types of TYPE, if any, are part of that type for    aliasing purposes.  For record types, we only record component types    for fields that are marked addressable.  For array types, we always    record the component types, so the front end should not call this    function if the individual component aren't addressable.  */
end_comment

begin_function
name|void
name|record_component_aliases
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|HOST_WIDE_INT
name|superset
init|=
name|get_alias_set
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|field
decl_stmt|;
if|if
condition|(
name|superset
operator|==
literal|0
condition|)
return|return;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|ARRAY_TYPE
case|:
if|if
condition|(
operator|!
name|TYPE_NONALIASED_COMPONENT
argument_list|(
name|type
argument_list|)
condition|)
name|record_alias_subset
argument_list|(
name|superset
argument_list|,
name|get_alias_set
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
case|case
name|QUAL_UNION_TYPE
case|:
comment|/* Recursively record aliases for the base classes, if there are any */
if|if
condition|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
operator|!=
name|NULL
operator|&&
name|TYPE_BINFO_BASETYPES
argument_list|(
name|type
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TREE_VEC_LENGTH
argument_list|(
name|TYPE_BINFO_BASETYPES
argument_list|(
name|type
argument_list|)
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|TYPE_BINFO_BASETYPES
argument_list|(
name|type
argument_list|)
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|record_alias_subset
argument_list|(
name|superset
argument_list|,
name|get_alias_set
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|field
operator|!=
literal|0
condition|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|FIELD_DECL
operator|&&
operator|!
name|DECL_NONADDRESSABLE_P
argument_list|(
name|field
argument_list|)
condition|)
name|record_alias_subset
argument_list|(
name|superset
argument_list|,
name|get_alias_set
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|COMPLEX_TYPE
case|:
name|record_alias_subset
argument_list|(
name|superset
argument_list|,
name|get_alias_set
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Allocate an alias set for use in storing and reading from the varargs    spill area.  */
end_comment

begin_function
name|HOST_WIDE_INT
name|get_varargs_alias_set
parameter_list|()
block|{
specifier|static
name|HOST_WIDE_INT
name|set
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|set
operator|==
operator|-
literal|1
condition|)
name|set
operator|=
name|new_alias_set
argument_list|()
expr_stmt|;
return|return
name|set
return|;
block|}
end_function

begin_comment
comment|/* Likewise, but used for the fixed portions of the frame, e.g., register    save areas.  */
end_comment

begin_function
name|HOST_WIDE_INT
name|get_frame_alias_set
parameter_list|()
block|{
specifier|static
name|HOST_WIDE_INT
name|set
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|set
operator|==
operator|-
literal|1
condition|)
name|set
operator|=
name|new_alias_set
argument_list|()
expr_stmt|;
return|return
name|set
return|;
block|}
end_function

begin_comment
comment|/* Inside SRC, the source of a SET, find a base address.  */
end_comment

begin_function
specifier|static
name|rtx
name|find_base_value
parameter_list|(
name|src
parameter_list|)
name|rtx
name|src
decl_stmt|;
block|{
name|unsigned
name|int
name|regno
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
condition|)
block|{
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
return|return
name|src
return|;
case|case
name|REG
case|:
name|regno
operator|=
name|REGNO
argument_list|(
name|src
argument_list|)
expr_stmt|;
comment|/* At the start of a function, argument registers have known base 	 values which may be lost later.  Returning an ADDRESS 	 expression here allows optimization based on argument values 	 even when the argument registers are used for other purposes.  */
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|copying_arguments
condition|)
return|return
name|new_reg_base_value
index|[
name|regno
index|]
return|;
comment|/* If a pseudo has a known base value, return it.  Do not do this 	 for non-fixed hard regs since it can result in a circular 	 dependency chain for registers which have values at function entry.  	 The test above is not sufficient because the scheduler may move 	 a copy out of an arg reg past the NOTE_INSN_FUNCTION_BEGIN.  */
if|if
condition|(
operator|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|||
name|fixed_regs
index|[
name|regno
index|]
operator|)
operator|&&
name|regno
operator|<
name|reg_base_value_size
condition|)
block|{
comment|/* If we're inside init_alias_analysis, use new_reg_base_value 	     to reduce the number of relaxation iterations.  */
if|if
condition|(
name|new_reg_base_value
operator|&&
name|new_reg_base_value
index|[
name|regno
index|]
operator|&&
name|REG_N_SETS
argument_list|(
name|regno
argument_list|)
operator|==
literal|1
condition|)
return|return
name|new_reg_base_value
index|[
name|regno
index|]
return|;
if|if
condition|(
name|reg_base_value
index|[
name|regno
index|]
condition|)
return|return
name|reg_base_value
index|[
name|regno
index|]
return|;
block|}
return|return
literal|0
return|;
case|case
name|MEM
case|:
comment|/* Check for an argument passed in memory.  Only record in the 	 copying-arguments block; it is too hard to track changes 	 otherwise.  */
if|if
condition|(
name|copying_arguments
operator|&&
operator|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
operator|==
name|arg_pointer_rtx
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|arg_pointer_rtx
operator|)
operator|)
condition|)
return|return
name|gen_rtx_ADDRESS
argument_list|(
name|VOIDmode
argument_list|,
name|src
argument_list|)
return|;
return|return
literal|0
return|;
case|case
name|CONST
case|:
name|src
operator|=
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|!=
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|!=
name|MINUS
condition|)
break|break;
comment|/* ... fall through ...  */
case|case
name|PLUS
case|:
case|case
name|MINUS
case|:
block|{
name|rtx
name|temp
decl_stmt|,
name|src_0
init|=
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
decl_stmt|,
name|src_1
init|=
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|/* If either operand is a REG that is a known pointer, then it 	   is the base.  */
if|if
condition|(
name|REG_P
argument_list|(
name|src_0
argument_list|)
operator|&&
name|REG_POINTER
argument_list|(
name|src_0
argument_list|)
condition|)
return|return
name|find_base_value
argument_list|(
name|src_0
argument_list|)
return|;
if|if
condition|(
name|REG_P
argument_list|(
name|src_1
argument_list|)
operator|&&
name|REG_POINTER
argument_list|(
name|src_1
argument_list|)
condition|)
return|return
name|find_base_value
argument_list|(
name|src_1
argument_list|)
return|;
comment|/* If either operand is a REG, then see if we already have 	   a known value for it.  */
if|if
condition|(
name|REG_P
argument_list|(
name|src_0
argument_list|)
condition|)
block|{
name|temp
operator|=
name|find_base_value
argument_list|(
name|src_0
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
literal|0
condition|)
name|src_0
operator|=
name|temp
expr_stmt|;
block|}
if|if
condition|(
name|REG_P
argument_list|(
name|src_1
argument_list|)
condition|)
block|{
name|temp
operator|=
name|find_base_value
argument_list|(
name|src_1
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
literal|0
condition|)
name|src_1
operator|=
name|temp
expr_stmt|;
block|}
comment|/* If either base is named object or a special address 	   (like an argument or stack reference), then use it for the 	   base term.  */
if|if
condition|(
name|src_0
operator|!=
literal|0
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|src_0
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|src_0
argument_list|)
operator|==
name|LABEL_REF
operator|||
operator|(
name|GET_CODE
argument_list|(
name|src_0
argument_list|)
operator|==
name|ADDRESS
operator|&&
name|GET_MODE
argument_list|(
name|src_0
argument_list|)
operator|!=
name|VOIDmode
operator|)
operator|)
condition|)
return|return
name|src_0
return|;
if|if
condition|(
name|src_1
operator|!=
literal|0
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|src_1
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|src_1
argument_list|)
operator|==
name|LABEL_REF
operator|||
operator|(
name|GET_CODE
argument_list|(
name|src_1
argument_list|)
operator|==
name|ADDRESS
operator|&&
name|GET_MODE
argument_list|(
name|src_1
argument_list|)
operator|!=
name|VOIDmode
operator|)
operator|)
condition|)
return|return
name|src_1
return|;
comment|/* Guess which operand is the base address: 	   If either operand is a symbol, then it is the base.  If 	   either operand is a CONST_INT, then the other is the base.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|src_1
argument_list|)
operator|==
name|CONST_INT
operator|||
name|CONSTANT_P
argument_list|(
name|src_0
argument_list|)
condition|)
return|return
name|find_base_value
argument_list|(
name|src_0
argument_list|)
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|src_0
argument_list|)
operator|==
name|CONST_INT
operator|||
name|CONSTANT_P
argument_list|(
name|src_1
argument_list|)
condition|)
return|return
name|find_base_value
argument_list|(
name|src_1
argument_list|)
return|;
return|return
literal|0
return|;
block|}
case|case
name|LO_SUM
case|:
comment|/* The standard form is (lo_sum reg sym) so look only at the 	 second operand.  */
return|return
name|find_base_value
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
case|case
name|AND
case|:
comment|/* If the second operand is constant set the base 	 address to the first operand.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|find_base_value
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
return|return
literal|0
return|;
case|case
name|TRUNCATE
case|:
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|src
argument_list|)
argument_list|)
operator|<
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
condition|)
break|break;
comment|/* Fall through.  */
case|case
name|HIGH
case|:
case|case
name|PRE_INC
case|:
case|case
name|PRE_DEC
case|:
case|case
name|POST_INC
case|:
case|case
name|POST_DEC
case|:
case|case
name|PRE_MODIFY
case|:
case|case
name|POST_MODIFY
case|:
return|return
name|find_base_value
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|ZERO_EXTEND
case|:
case|case
name|SIGN_EXTEND
case|:
comment|/* used for NT/Alpha pointers */
block|{
name|rtx
name|temp
init|=
name|find_base_value
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|POINTERS_EXTEND_UNSIGNED
if|if
condition|(
name|temp
operator|!=
literal|0
operator|&&
name|CONSTANT_P
argument_list|(
name|temp
argument_list|)
operator|&&
name|GET_MODE
argument_list|(
name|temp
argument_list|)
operator|!=
name|Pmode
condition|)
name|temp
operator|=
name|convert_memory_address
argument_list|(
name|Pmode
argument_list|,
name|temp
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|temp
return|;
block|}
default|default:
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Called from init_alias_analysis indirectly through note_stores.  */
end_comment

begin_comment
comment|/* While scanning insns to find base values, reg_seen[N] is nonzero if    register N has been set in this function.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|reg_seen
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Addresses which are known not to alias anything else are identified    by a unique integer.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|unique_id
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|record_set
parameter_list|(
name|dest
parameter_list|,
name|set
parameter_list|,
name|data
parameter_list|)
name|rtx
name|dest
decl_stmt|,
name|set
decl_stmt|;
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|unsigned
name|regno
decl_stmt|;
name|rtx
name|src
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|!=
name|REG
condition|)
return|return;
name|regno
operator|=
name|REGNO
argument_list|(
name|dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|>=
name|reg_base_value_size
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|set
condition|)
block|{
comment|/* A CLOBBER wipes out any old value but does not prevent a previously 	 unset register from acquiring a base address (i.e. reg_seen is not 	 set).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|set
argument_list|)
operator|==
name|CLOBBER
condition|)
block|{
name|new_reg_base_value
index|[
name|regno
index|]
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|src
operator|=
name|SET_SRC
argument_list|(
name|set
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|reg_seen
index|[
name|regno
index|]
condition|)
block|{
name|new_reg_base_value
index|[
name|regno
index|]
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|reg_seen
index|[
name|regno
index|]
operator|=
literal|1
expr_stmt|;
name|new_reg_base_value
index|[
name|regno
index|]
operator|=
name|gen_rtx_ADDRESS
argument_list|(
name|Pmode
argument_list|,
name|GEN_INT
argument_list|(
name|unique_id
operator|++
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* This is not the first set.  If the new value is not related to the      old value, forget the base value. Note that the following code is      not detected:      extern int x, y;  int *p =&x; p += (&y-&x);      ANSI C does not allow computing the difference of addresses      of distinct top level objects.  */
if|if
condition|(
name|new_reg_base_value
index|[
name|regno
index|]
condition|)
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
condition|)
block|{
case|case
name|LO_SUM
case|:
case|case
name|MINUS
case|:
if|if
condition|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
operator|!=
name|dest
operator|&&
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
operator|!=
name|dest
condition|)
name|new_reg_base_value
index|[
name|regno
index|]
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|PLUS
case|:
comment|/* If the value we add in the PLUS is also a valid base value, 	   this might be the actual base value, and the original value 	   an index.  */
block|{
name|rtx
name|other
init|=
name|NULL_RTX
decl_stmt|;
if|if
condition|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
operator|==
name|dest
condition|)
name|other
operator|=
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
operator|==
name|dest
condition|)
name|other
operator|=
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|other
operator|||
name|find_base_value
argument_list|(
name|other
argument_list|)
condition|)
name|new_reg_base_value
index|[
name|regno
index|]
operator|=
literal|0
expr_stmt|;
break|break;
block|}
case|case
name|AND
case|:
if|if
condition|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
operator|!=
name|dest
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
condition|)
name|new_reg_base_value
index|[
name|regno
index|]
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|new_reg_base_value
index|[
name|regno
index|]
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* If this is the first set of a register, record the value.  */
elseif|else
if|if
condition|(
operator|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|||
operator|!
name|fixed_regs
index|[
name|regno
index|]
operator|)
operator|&&
operator|!
name|reg_seen
index|[
name|regno
index|]
operator|&&
name|new_reg_base_value
index|[
name|regno
index|]
operator|==
literal|0
condition|)
name|new_reg_base_value
index|[
name|regno
index|]
operator|=
name|find_base_value
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|reg_seen
index|[
name|regno
index|]
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called from loop optimization when a new pseudo-register is    created.  It indicates that REGNO is being set to VAL.  f INVARIANT    is true then this value also describes an invariant relationship    which can be used to deduce that two registers with unknown values    are different.  */
end_comment

begin_function
name|void
name|record_base_value
parameter_list|(
name|regno
parameter_list|,
name|val
parameter_list|,
name|invariant
parameter_list|)
name|unsigned
name|int
name|regno
decl_stmt|;
name|rtx
name|val
decl_stmt|;
name|int
name|invariant
decl_stmt|;
block|{
if|if
condition|(
name|regno
operator|>=
name|reg_base_value_size
condition|)
return|return;
if|if
condition|(
name|invariant
operator|&&
name|alias_invariant
condition|)
name|alias_invariant
index|[
name|regno
index|]
operator|=
name|val
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|val
argument_list|)
operator|==
name|REG
condition|)
block|{
if|if
condition|(
name|REGNO
argument_list|(
name|val
argument_list|)
operator|<
name|reg_base_value_size
condition|)
name|reg_base_value
index|[
name|regno
index|]
operator|=
name|reg_base_value
index|[
name|REGNO
argument_list|(
name|val
argument_list|)
index|]
expr_stmt|;
return|return;
block|}
name|reg_base_value
index|[
name|regno
index|]
operator|=
name|find_base_value
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Clear alias info for a register.  This is used if an RTL transformation    changes the value of a register.  This is used in flow by AUTO_INC_DEC    optimizations.  We don't need to clear reg_base_value, since flow only    changes the offset.  */
end_comment

begin_function
name|void
name|clear_reg_alias_info
parameter_list|(
name|reg
parameter_list|)
name|rtx
name|reg
decl_stmt|;
block|{
name|unsigned
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|reg
argument_list|)
decl_stmt|;
if|if
condition|(
name|regno
operator|<
name|reg_known_value_size
operator|&&
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
name|reg_known_value
index|[
name|regno
index|]
operator|=
name|reg
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns a canonical version of X, from the point of view alias    analysis.  (For example, if X is a MEM whose address is a register,    and the register has a known value (say a SYMBOL_REF), then a MEM    whose address is the SYMBOL_REF is returned.)  */
end_comment

begin_function
name|rtx
name|canon_rtx
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
comment|/* Recursively look for equivalences.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|x
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|REGNO
argument_list|(
name|x
argument_list|)
operator|<
name|reg_known_value_size
condition|)
return|return
name|reg_known_value
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
operator|==
name|x
condition|?
name|x
else|:
name|canon_rtx
argument_list|(
name|reg_known_value
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
argument_list|)
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|rtx
name|x0
init|=
name|canon_rtx
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|x1
init|=
name|canon_rtx
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|x0
operator|!=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|||
name|x1
operator|!=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x0
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|plus_constant
argument_list|(
name|x1
argument_list|,
name|INTVAL
argument_list|(
name|x0
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x1
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|plus_constant
argument_list|(
name|x0
argument_list|,
name|INTVAL
argument_list|(
name|x1
argument_list|)
argument_list|)
return|;
return|return
name|gen_rtx_PLUS
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|x0
argument_list|,
name|x1
argument_list|)
return|;
block|}
block|}
comment|/* This gives us much better alias analysis when called from      the loop optimizer.   Note we want to leave the original      MEM alone, but need to return the canonicalized MEM with      all the flags with their original values.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
condition|)
name|x
operator|=
name|replace_equiv_address_nv
argument_list|(
name|x
argument_list|,
name|canon_rtx
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if X and Y are identical-looking rtx's.     We use the data in reg_known_value above to see if two registers with    different numbers are, in fact, equivalent.  */
end_comment

begin_function
specifier|static
name|int
name|rtx_equal_for_memref_p
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|y
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|j
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
operator|&&
name|y
operator|==
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|x
operator|==
literal|0
operator|||
name|y
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|x
operator|=
name|canon_rtx
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|y
operator|=
name|canon_rtx
argument_list|(
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|==
name|y
condition|)
return|return
literal|1
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* Rtx's of different codes cannot be equal.  */
if|if
condition|(
name|code
operator|!=
name|GET_CODE
argument_list|(
name|y
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* (MULT:SI x y) and (MULT:HI x y) are NOT equivalent.      (REG:SI x) and (REG:HI x) are NOT equivalent.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|y
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Some RTL can be compared without a recursive examination.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|VALUE
case|:
return|return
name|CSELIB_VAL_PTR
argument_list|(
name|x
argument_list|)
operator|==
name|CSELIB_VAL_PTR
argument_list|(
name|y
argument_list|)
return|;
case|case
name|REG
case|:
return|return
name|REGNO
argument_list|(
name|x
argument_list|)
operator|==
name|REGNO
argument_list|(
name|y
argument_list|)
return|;
case|case
name|LABEL_REF
case|:
return|return
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|SYMBOL_REF
case|:
return|return
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|XSTR
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
comment|/* There's no need to compare the contents of CONST_DOUBLEs or 	 CONST_INTs because pointer equality is a good enough 	 comparison for these nodes.  */
return|return
literal|0
return|;
case|case
name|ADDRESSOF
case|:
return|return
operator|(
name|XINT
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|==
name|XINT
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
operator|&&
name|rtx_equal_for_memref_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
return|;
default|default:
break|break;
block|}
comment|/* For commutative operations, the RTX match if the operand match in any      order.  Also handle the simple binary and unary cases without a loop.  */
if|if
condition|(
name|code
operator|==
name|EQ
operator|||
name|code
operator|==
name|NE
operator|||
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'c'
condition|)
return|return
operator|(
operator|(
name|rtx_equal_for_memref_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|rtx_equal_for_memref_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|rtx_equal_for_memref_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|rtx_equal_for_memref_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|)
return|;
elseif|else
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'<'
operator|||
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'2'
condition|)
return|return
operator|(
name|rtx_equal_for_memref_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|rtx_equal_for_memref_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'1'
condition|)
return|return
name|rtx_equal_for_memref_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
comment|/* Compare the elements.  If any pair of corresponding elements      fail to match, return 0 for the whole things.       Limit cases to types which actually appear in addresses.  */
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
switch|switch
condition|(
name|fmt
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'i'
case|:
if|if
condition|(
name|XINT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
name|XINT
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'E'
case|:
comment|/* Two vectors must have the same length.  */
if|if
condition|(
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
name|XVECLEN
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* And the corresponding elements must match.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|rtx_equal_for_memref_p
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|XVECEXP
argument_list|(
name|y
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'e'
case|:
if|if
condition|(
name|rtx_equal_for_memref_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
break|break;
comment|/* This can happen for asm operands.  */
case|case
literal|'s'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|XSTR
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|XSTR
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
comment|/* This can happen for an asm which clobbers memory.  */
case|case
literal|'0'
case|:
break|break;
comment|/* It is believed that rtx's at this level will never 	     contain anything but integers and other rtx's, 	     except for within LABEL_REFs and SYMBOL_REFs.  */
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Given an rtx X, find a SYMBOL_REF or LABEL_REF within    X and return it, or return 0 if none found.  */
end_comment

begin_function
specifier|static
name|rtx
name|find_symbolic_term
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|SYMBOL_REF
operator|||
name|code
operator|==
name|LABEL_REF
condition|)
return|return
name|x
return|;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'o'
condition|)
return|return
literal|0
return|;
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|rtx
name|t
decl_stmt|;
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
name|t
operator|=
name|find_symbolic_term
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|!=
literal|0
condition|)
return|return
name|t
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|rtx
name|find_base_term
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
name|cselib_val
modifier|*
name|val
decl_stmt|;
name|struct
name|elt_loc_list
modifier|*
name|l
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|FIND_BASE_TERM
argument_list|)
comment|/* Try machine-dependent ways to find the base term.  */
name|x
operator|=
name|FIND_BASE_TERM
argument_list|(
name|x
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|REG
case|:
return|return
name|REG_BASE_VALUE
argument_list|(
name|x
argument_list|)
return|;
case|case
name|TRUNCATE
case|:
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|<
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Fall through.  */
case|case
name|HIGH
case|:
case|case
name|PRE_INC
case|:
case|case
name|PRE_DEC
case|:
case|case
name|POST_INC
case|:
case|case
name|POST_DEC
case|:
case|case
name|PRE_MODIFY
case|:
case|case
name|POST_MODIFY
case|:
return|return
name|find_base_term
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|ZERO_EXTEND
case|:
case|case
name|SIGN_EXTEND
case|:
comment|/* Used for Alpha/NT pointers */
block|{
name|rtx
name|temp
init|=
name|find_base_term
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|POINTERS_EXTEND_UNSIGNED
if|if
condition|(
name|temp
operator|!=
literal|0
operator|&&
name|CONSTANT_P
argument_list|(
name|temp
argument_list|)
operator|&&
name|GET_MODE
argument_list|(
name|temp
argument_list|)
operator|!=
name|Pmode
condition|)
name|temp
operator|=
name|convert_memory_address
argument_list|(
name|Pmode
argument_list|,
name|temp
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|temp
return|;
block|}
case|case
name|VALUE
case|:
name|val
operator|=
name|CSELIB_VAL_PTR
argument_list|(
name|x
argument_list|)
expr_stmt|;
for|for
control|(
name|l
operator|=
name|val
operator|->
name|locs
init|;
name|l
condition|;
name|l
operator|=
name|l
operator|->
name|next
control|)
if|if
condition|(
operator|(
name|x
operator|=
name|find_base_term
argument_list|(
name|l
operator|->
name|loc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|x
return|;
return|return
literal|0
return|;
case|case
name|CONST
case|:
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|MINUS
condition|)
return|return
literal|0
return|;
comment|/* fall through */
case|case
name|LO_SUM
case|:
case|case
name|PLUS
case|:
case|case
name|MINUS
case|:
block|{
name|rtx
name|tmp1
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|tmp2
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|/* This is a little bit tricky since we have to determine which of 	   the two operands represents the real base address.  Otherwise this 	   routine may return the index register instead of the base register.  	   That may cause us to believe no aliasing was possible, when in 	   fact aliasing is possible.  	   We use a few simple tests to guess the base register.  Additional 	   tests can certainly be added.  For example, if one of the operands 	   is a shift or multiply, then it must be the index register and the 	   other operand is the base register.  */
if|if
condition|(
name|tmp1
operator|==
name|pic_offset_table_rtx
operator|&&
name|CONSTANT_P
argument_list|(
name|tmp2
argument_list|)
condition|)
return|return
name|find_base_term
argument_list|(
name|tmp2
argument_list|)
return|;
comment|/* If either operand is known to be a pointer, then use it 	   to determine the base term.  */
if|if
condition|(
name|REG_P
argument_list|(
name|tmp1
argument_list|)
operator|&&
name|REG_POINTER
argument_list|(
name|tmp1
argument_list|)
condition|)
return|return
name|find_base_term
argument_list|(
name|tmp1
argument_list|)
return|;
if|if
condition|(
name|REG_P
argument_list|(
name|tmp2
argument_list|)
operator|&&
name|REG_POINTER
argument_list|(
name|tmp2
argument_list|)
condition|)
return|return
name|find_base_term
argument_list|(
name|tmp2
argument_list|)
return|;
comment|/* Neither operand was known to be a pointer.  Go ahead and find the 	   base term for both operands.  */
name|tmp1
operator|=
name|find_base_term
argument_list|(
name|tmp1
argument_list|)
expr_stmt|;
name|tmp2
operator|=
name|find_base_term
argument_list|(
name|tmp2
argument_list|)
expr_stmt|;
comment|/* If either base term is named object or a special address 	   (like an argument or stack reference), then use it for the 	   base term.  */
if|if
condition|(
name|tmp1
operator|!=
literal|0
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|tmp1
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|tmp1
argument_list|)
operator|==
name|LABEL_REF
operator|||
operator|(
name|GET_CODE
argument_list|(
name|tmp1
argument_list|)
operator|==
name|ADDRESS
operator|&&
name|GET_MODE
argument_list|(
name|tmp1
argument_list|)
operator|!=
name|VOIDmode
operator|)
operator|)
condition|)
return|return
name|tmp1
return|;
if|if
condition|(
name|tmp2
operator|!=
literal|0
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|tmp2
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|tmp2
argument_list|)
operator|==
name|LABEL_REF
operator|||
operator|(
name|GET_CODE
argument_list|(
name|tmp2
argument_list|)
operator|==
name|ADDRESS
operator|&&
name|GET_MODE
argument_list|(
name|tmp2
argument_list|)
operator|!=
name|VOIDmode
operator|)
operator|)
condition|)
return|return
name|tmp2
return|;
comment|/* We could not determine which of the two operands was the 	   base register and which was the index.  So we can determine 	   nothing from the base alias check.  */
return|return
literal|0
return|;
block|}
case|case
name|AND
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|find_base_term
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
return|return
literal|0
return|;
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
return|return
name|x
return|;
case|case
name|ADDRESSOF
case|:
return|return
name|REG_BASE_VALUE
argument_list|(
name|frame_pointer_rtx
argument_list|)
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return 0 if the addresses X and Y are known to point to different    objects, 1 if they might be pointers to the same object.  */
end_comment

begin_function
specifier|static
name|int
name|base_alias_check
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|x_mode
parameter_list|,
name|y_mode
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|y
decl_stmt|;
name|enum
name|machine_mode
name|x_mode
decl_stmt|,
name|y_mode
decl_stmt|;
block|{
name|rtx
name|x_base
init|=
name|find_base_term
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|rtx
name|y_base
init|=
name|find_base_term
argument_list|(
name|y
argument_list|)
decl_stmt|;
comment|/* If the address itself has no known base see if a known equivalent      value has one.  If either address still has no known base, nothing      is known about aliasing.  */
if|if
condition|(
name|x_base
operator|==
literal|0
condition|)
block|{
name|rtx
name|x_c
decl_stmt|;
if|if
condition|(
operator|!
name|flag_expensive_optimizations
operator|||
operator|(
name|x_c
operator|=
name|canon_rtx
argument_list|(
name|x
argument_list|)
operator|)
operator|==
name|x
condition|)
return|return
literal|1
return|;
name|x_base
operator|=
name|find_base_term
argument_list|(
name|x_c
argument_list|)
expr_stmt|;
if|if
condition|(
name|x_base
operator|==
literal|0
condition|)
return|return
literal|1
return|;
block|}
if|if
condition|(
name|y_base
operator|==
literal|0
condition|)
block|{
name|rtx
name|y_c
decl_stmt|;
if|if
condition|(
operator|!
name|flag_expensive_optimizations
operator|||
operator|(
name|y_c
operator|=
name|canon_rtx
argument_list|(
name|y
argument_list|)
operator|)
operator|==
name|y
condition|)
return|return
literal|1
return|;
name|y_base
operator|=
name|find_base_term
argument_list|(
name|y_c
argument_list|)
expr_stmt|;
if|if
condition|(
name|y_base
operator|==
literal|0
condition|)
return|return
literal|1
return|;
block|}
comment|/* If the base addresses are equal nothing is known about aliasing.  */
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|x_base
argument_list|,
name|y_base
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* The base addresses of the read and write are different expressions.      If they are both symbols and they are not accessed via AND, there is      no conflict.  We can bring knowledge of object alignment into play      here.  For example, on alpha, "char a, b;" can alias one another,      though "char a; long b;" cannot.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x_base
argument_list|)
operator|!=
name|ADDRESS
operator|&&
name|GET_CODE
argument_list|(
name|y_base
argument_list|)
operator|!=
name|ADDRESS
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|AND
operator|&&
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|AND
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|AND
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
operator|||
operator|(
name|int
operator|)
name|GET_MODE_UNIT_SIZE
argument_list|(
name|y_mode
argument_list|)
operator|<
operator|-
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|AND
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
operator|||
operator|(
name|int
operator|)
name|GET_MODE_UNIT_SIZE
argument_list|(
name|x_mode
argument_list|)
operator|<
operator|-
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
condition|)
return|return
literal|1
return|;
comment|/* Differing symbols never alias.  */
return|return
literal|0
return|;
block|}
comment|/* If one address is a stack reference there can be no alias:      stack references using different base registers do not alias,      a stack reference can not alias a parameter, and a stack reference      can not alias a global.  */
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|x_base
argument_list|)
operator|==
name|ADDRESS
operator|&&
name|GET_MODE
argument_list|(
name|x_base
argument_list|)
operator|==
name|Pmode
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|y_base
argument_list|)
operator|==
name|ADDRESS
operator|&&
name|GET_MODE
argument_list|(
name|y_base
argument_list|)
operator|==
name|Pmode
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|flag_argument_noalias
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|flag_argument_noalias
operator|>
literal|1
condition|)
return|return
literal|0
return|;
comment|/* Weak noalias assertion (arguments are distinct, but may match globals).  */
return|return
operator|!
operator|(
name|GET_MODE
argument_list|(
name|x_base
argument_list|)
operator|==
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|y_base
argument_list|)
operator|==
name|VOIDmode
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Convert the address X into something we can use.  This is done by returning    it unchanged unless it is a value; in the latter case we call cselib to get    a more useful rtx.  */
end_comment

begin_function
name|rtx
name|get_addr
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
name|cselib_val
modifier|*
name|v
decl_stmt|;
name|struct
name|elt_loc_list
modifier|*
name|l
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|VALUE
condition|)
return|return
name|x
return|;
name|v
operator|=
name|CSELIB_VAL_PTR
argument_list|(
name|x
argument_list|)
expr_stmt|;
for|for
control|(
name|l
operator|=
name|v
operator|->
name|locs
init|;
name|l
condition|;
name|l
operator|=
name|l
operator|->
name|next
control|)
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|l
operator|->
name|loc
argument_list|)
condition|)
return|return
name|l
operator|->
name|loc
return|;
for|for
control|(
name|l
operator|=
name|v
operator|->
name|locs
init|;
name|l
condition|;
name|l
operator|=
name|l
operator|->
name|next
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|l
operator|->
name|loc
argument_list|)
operator|!=
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|l
operator|->
name|loc
argument_list|)
operator|!=
name|MEM
condition|)
return|return
name|l
operator|->
name|loc
return|;
if|if
condition|(
name|v
operator|->
name|locs
condition|)
return|return
name|v
operator|->
name|locs
operator|->
name|loc
return|;
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/*  Return the address of the (N_REFS + 1)th memory reference to ADDR     where SIZE is the size in bytes of the memory reference.  If ADDR     is not modified by the memory reference then ADDR is returned.  */
end_comment

begin_function
name|rtx
name|addr_side_effect_eval
parameter_list|(
name|addr
parameter_list|,
name|size
parameter_list|,
name|n_refs
parameter_list|)
name|rtx
name|addr
decl_stmt|;
name|int
name|size
decl_stmt|;
name|int
name|n_refs
decl_stmt|;
block|{
name|int
name|offset
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
condition|)
block|{
case|case
name|PRE_INC
case|:
name|offset
operator|=
operator|(
name|n_refs
operator|+
literal|1
operator|)
operator|*
name|size
expr_stmt|;
break|break;
case|case
name|PRE_DEC
case|:
name|offset
operator|=
operator|-
operator|(
name|n_refs
operator|+
literal|1
operator|)
operator|*
name|size
expr_stmt|;
break|break;
case|case
name|POST_INC
case|:
name|offset
operator|=
name|n_refs
operator|*
name|size
expr_stmt|;
break|break;
case|case
name|POST_DEC
case|:
name|offset
operator|=
operator|-
name|n_refs
operator|*
name|size
expr_stmt|;
break|break;
default|default:
return|return
name|addr
return|;
block|}
if|if
condition|(
name|offset
condition|)
name|addr
operator|=
name|gen_rtx_PLUS
argument_list|(
name|GET_MODE
argument_list|(
name|addr
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|offset
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|addr
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if X and Y (memory addresses) could reference the    same location in memory.  C is an offset accumulator.  When    C is nonzero, we are testing aliases between X and Y + C.    XSIZE is the size in bytes of the X reference,    similarly YSIZE is the size in bytes for Y.     If XSIZE or YSIZE is zero, we do not know the amount of memory being    referenced (the reference was BLKmode), so make the most pessimistic    assumptions.     If XSIZE or YSIZE is negative, we may access memory outside the object    being referenced as a side effect.  This can happen when using AND to    align memory references, as is done on the Alpha.     Nice to notice that varying addresses cannot conflict with fp if no    local variables had their addresses taken, but that's too hard now.  */
end_comment

begin_function
specifier|static
name|int
name|memrefs_conflict_p
parameter_list|(
name|xsize
parameter_list|,
name|x
parameter_list|,
name|ysize
parameter_list|,
name|y
parameter_list|,
name|c
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|y
decl_stmt|;
name|int
name|xsize
decl_stmt|,
name|ysize
decl_stmt|;
name|HOST_WIDE_INT
name|c
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|VALUE
condition|)
name|x
operator|=
name|get_addr
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|VALUE
condition|)
name|y
operator|=
name|get_addr
argument_list|(
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|HIGH
condition|)
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|LO_SUM
condition|)
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|x
operator|=
name|canon_rtx
argument_list|(
name|addr_side_effect_eval
argument_list|(
name|x
argument_list|,
name|xsize
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|HIGH
condition|)
name|y
operator|=
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|LO_SUM
condition|)
name|y
operator|=
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|y
operator|=
name|canon_rtx
argument_list|(
name|addr_side_effect_eval
argument_list|(
name|y
argument_list|,
name|ysize
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtx_equal_for_memref_p
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
condition|)
block|{
if|if
condition|(
name|xsize
operator|<=
literal|0
operator|||
name|ysize
operator|<=
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|c
operator|>=
literal|0
operator|&&
name|xsize
operator|>
name|c
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|c
operator|<
literal|0
operator|&&
name|ysize
operator|+
name|c
operator|>
literal|0
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
comment|/* This code used to check for conflicts involving stack references and      globals but the base address alias code now handles these cases.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
condition|)
block|{
comment|/* The fact that X is canonicalized means that this 	 PLUS rtx is canonicalized.  */
name|rtx
name|x0
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|x1
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|PLUS
condition|)
block|{
comment|/* The fact that Y is canonicalized means that this 	     PLUS rtx is canonicalized.  */
name|rtx
name|y0
init|=
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|y1
init|=
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|rtx_equal_for_memref_p
argument_list|(
name|x1
argument_list|,
name|y1
argument_list|)
condition|)
return|return
name|memrefs_conflict_p
argument_list|(
name|xsize
argument_list|,
name|x0
argument_list|,
name|ysize
argument_list|,
name|y0
argument_list|,
name|c
argument_list|)
return|;
if|if
condition|(
name|rtx_equal_for_memref_p
argument_list|(
name|x0
argument_list|,
name|y0
argument_list|)
condition|)
return|return
name|memrefs_conflict_p
argument_list|(
name|xsize
argument_list|,
name|x1
argument_list|,
name|ysize
argument_list|,
name|y1
argument_list|,
name|c
argument_list|)
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x1
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|y1
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|memrefs_conflict_p
argument_list|(
name|xsize
argument_list|,
name|x0
argument_list|,
name|ysize
argument_list|,
name|y0
argument_list|,
name|c
operator|-
name|INTVAL
argument_list|(
name|x1
argument_list|)
operator|+
name|INTVAL
argument_list|(
name|y1
argument_list|)
argument_list|)
return|;
else|else
return|return
name|memrefs_conflict_p
argument_list|(
name|xsize
argument_list|,
name|x0
argument_list|,
name|ysize
argument_list|,
name|y
argument_list|,
name|c
operator|-
name|INTVAL
argument_list|(
name|x1
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|y1
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|memrefs_conflict_p
argument_list|(
name|xsize
argument_list|,
name|x
argument_list|,
name|ysize
argument_list|,
name|y0
argument_list|,
name|c
operator|+
name|INTVAL
argument_list|(
name|y1
argument_list|)
argument_list|)
return|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x1
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|memrefs_conflict_p
argument_list|(
name|xsize
argument_list|,
name|x0
argument_list|,
name|ysize
argument_list|,
name|y
argument_list|,
name|c
operator|-
name|INTVAL
argument_list|(
name|x1
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|PLUS
condition|)
block|{
comment|/* The fact that Y is canonicalized means that this 	 PLUS rtx is canonicalized.  */
name|rtx
name|y0
init|=
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|y1
init|=
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|y1
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|memrefs_conflict_p
argument_list|(
name|xsize
argument_list|,
name|x
argument_list|,
name|ysize
argument_list|,
name|y0
argument_list|,
name|c
operator|+
name|INTVAL
argument_list|(
name|y1
argument_list|)
argument_list|)
return|;
else|else
return|return
literal|1
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|GET_CODE
argument_list|(
name|y
argument_list|)
condition|)
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|MULT
case|:
block|{
comment|/* Handle cases where we expect the second operands to be the 	     same, and check only whether the first operand would conflict 	     or not.  */
name|rtx
name|x0
decl_stmt|,
name|y0
decl_stmt|;
name|rtx
name|x1
init|=
name|canon_rtx
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|y1
init|=
name|canon_rtx
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|rtx_equal_for_memref_p
argument_list|(
name|x1
argument_list|,
name|y1
argument_list|)
condition|)
return|return
literal|1
return|;
name|x0
operator|=
name|canon_rtx
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|y0
operator|=
name|canon_rtx
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtx_equal_for_memref_p
argument_list|(
name|x0
argument_list|,
name|y0
argument_list|)
condition|)
return|return
operator|(
name|xsize
operator|==
literal|0
operator|||
name|ysize
operator|==
literal|0
operator|||
operator|(
name|c
operator|>=
literal|0
operator|&&
name|xsize
operator|>
name|c
operator|)
operator|||
operator|(
name|c
operator|<
literal|0
operator|&&
name|ysize
operator|+
name|c
operator|>
literal|0
operator|)
operator|)
return|;
comment|/* Can't properly adjust our sizes.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x1
argument_list|)
operator|!=
name|CONST_INT
condition|)
return|return
literal|1
return|;
name|xsize
operator|/=
name|INTVAL
argument_list|(
name|x1
argument_list|)
expr_stmt|;
name|ysize
operator|/=
name|INTVAL
argument_list|(
name|x1
argument_list|)
expr_stmt|;
name|c
operator|/=
name|INTVAL
argument_list|(
name|x1
argument_list|)
expr_stmt|;
return|return
name|memrefs_conflict_p
argument_list|(
name|xsize
argument_list|,
name|x0
argument_list|,
name|ysize
argument_list|,
name|y0
argument_list|,
name|c
argument_list|)
return|;
block|}
case|case
name|REG
case|:
comment|/* Are these registers known not to be equal?  */
if|if
condition|(
name|alias_invariant
condition|)
block|{
name|unsigned
name|int
name|r_x
init|=
name|REGNO
argument_list|(
name|x
argument_list|)
decl_stmt|,
name|r_y
init|=
name|REGNO
argument_list|(
name|y
argument_list|)
decl_stmt|;
name|rtx
name|i_x
decl_stmt|,
name|i_y
decl_stmt|;
comment|/* invariant relationships of X and Y */
name|i_x
operator|=
name|r_x
operator|>=
name|reg_base_value_size
condition|?
literal|0
else|:
name|alias_invariant
index|[
name|r_x
index|]
expr_stmt|;
name|i_y
operator|=
name|r_y
operator|>=
name|reg_base_value_size
condition|?
literal|0
else|:
name|alias_invariant
index|[
name|r_y
index|]
expr_stmt|;
if|if
condition|(
name|i_x
operator|==
literal|0
operator|&&
name|i_y
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
operator|!
name|memrefs_conflict_p
argument_list|(
name|xsize
argument_list|,
name|i_x
condition|?
name|i_x
else|:
name|x
argument_list|,
name|ysize
argument_list|,
name|i_y
condition|?
name|i_y
else|:
name|y
argument_list|,
name|c
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
break|break;
default|default:
break|break;
block|}
comment|/* Treat an access through an AND (e.g. a subword access on an Alpha)      as an access with indeterminate size.  Assume that references      besides AND are aligned, so if the size of the other reference is      at least as large as the alignment, assume no other overlap.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|AND
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|AND
operator|||
name|ysize
operator|<
operator|-
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
name|xsize
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|memrefs_conflict_p
argument_list|(
name|xsize
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|ysize
argument_list|,
name|y
argument_list|,
name|c
argument_list|)
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|AND
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
comment|/* ??? If we are indexing far enough into the array/structure, we 	 may yet be able to determine that we can not overlap.  But we 	 also need to that we are far enough from the end not to overlap 	 a following reference, so we do nothing with that for now.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|AND
operator|||
name|xsize
operator|<
operator|-
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
name|ysize
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|memrefs_conflict_p
argument_list|(
name|xsize
argument_list|,
name|x
argument_list|,
name|ysize
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|,
name|c
argument_list|)
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|ADDRESSOF
condition|)
block|{
if|if
condition|(
name|y
operator|==
name|frame_pointer_rtx
operator|||
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|ADDRESSOF
condition|)
return|return
name|xsize
operator|<=
literal|0
operator|||
name|ysize
operator|<=
literal|0
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|ADDRESSOF
condition|)
block|{
if|if
condition|(
name|x
operator|==
name|frame_pointer_rtx
condition|)
return|return
name|xsize
operator|<=
literal|0
operator|||
name|ysize
operator|<=
literal|0
return|;
block|}
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|c
operator|+=
operator|(
name|INTVAL
argument_list|(
name|y
argument_list|)
operator|-
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|)
expr_stmt|;
return|return
operator|(
name|xsize
operator|<=
literal|0
operator|||
name|ysize
operator|<=
literal|0
operator|||
operator|(
name|c
operator|>=
literal|0
operator|&&
name|xsize
operator|>
name|c
operator|)
operator|||
operator|(
name|c
operator|<
literal|0
operator|&&
name|ysize
operator|+
name|c
operator|>
literal|0
operator|)
operator|)
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|CONST
condition|)
return|return
name|memrefs_conflict_p
argument_list|(
name|xsize
argument_list|,
name|canon_rtx
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|ysize
argument_list|,
name|canon_rtx
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|c
argument_list|)
return|;
else|else
return|return
name|memrefs_conflict_p
argument_list|(
name|xsize
argument_list|,
name|canon_rtx
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|ysize
argument_list|,
name|y
argument_list|,
name|c
argument_list|)
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|CONST
condition|)
return|return
name|memrefs_conflict_p
argument_list|(
name|xsize
argument_list|,
name|x
argument_list|,
name|ysize
argument_list|,
name|canon_rtx
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|c
argument_list|)
return|;
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|y
argument_list|)
condition|)
return|return
operator|(
name|xsize
operator|<=
literal|0
operator|||
name|ysize
operator|<=
literal|0
operator|||
operator|(
name|rtx_equal_for_memref_p
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
operator|&&
operator|(
operator|(
name|c
operator|>=
literal|0
operator|&&
name|xsize
operator|>
name|c
operator|)
operator|||
operator|(
name|c
operator|<
literal|0
operator|&&
name|ysize
operator|+
name|c
operator|>
literal|0
operator|)
operator|)
operator|)
operator|)
return|;
return|return
literal|1
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Functions to compute memory dependencies.     Since we process the insns in execution order, we can build tables    to keep track of what registers are fixed (and not aliased), what registers    are varying in known ways, and what registers are varying in unknown    ways.     If both memory references are volatile, then there must always be a    dependence between the two references, since their order can not be    changed.  A volatile and non-volatile reference can be interchanged    though.     A MEM_IN_STRUCT reference at a non-AND varying address can never    conflict with a non-MEM_IN_STRUCT reference at a fixed address.  We    also must allow AND addresses, because they may generate accesses    outside the object being referenced.  This is used to generate    aligned addresses from unaligned addresses, for instance, the alpha    storeqi_unaligned pattern.  */
end_comment

begin_comment
comment|/* Read dependence: X is read after read in MEM takes place.  There can    only be a dependence here if both reads are volatile.  */
end_comment

begin_function
name|int
name|read_dependence
parameter_list|(
name|mem
parameter_list|,
name|x
parameter_list|)
name|rtx
name|mem
decl_stmt|;
name|rtx
name|x
decl_stmt|;
block|{
return|return
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
operator|&&
name|MEM_VOLATILE_P
argument_list|(
name|mem
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns MEM1 if and only if MEM1 is a scalar at a fixed address and    MEM2 is a reference to a structure at a varying address, or returns    MEM2 if vice versa.  Otherwise, returns NULL_RTX.  If a non-NULL    value is returned MEM1 and MEM2 can never alias.  VARIES_P is used    to decide whether or not an address may vary; it should return    nonzero whenever variation is possible.    MEM1_ADDR and MEM2_ADDR are the addresses of MEM1 and MEM2.  */
end_comment

begin_function_decl
specifier|static
name|rtx
name|fixed_scalar_and_varying_struct_p
parameter_list|(
name|mem1
parameter_list|,
name|mem2
parameter_list|,
name|mem1_addr
parameter_list|,
name|mem2_addr
parameter_list|,
name|varies_p
parameter_list|)
name|rtx
name|mem1
decl_stmt|,
name|mem2
decl_stmt|;
name|rtx
name|mem1_addr
decl_stmt|,
name|mem2_addr
decl_stmt|;
function_decl|int
parameter_list|(
function_decl|*varies_p
end_function_decl

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
operator|!
name|flag_strict_aliasing
condition|)
return|return
name|NULL_RTX
return|;
if|if
condition|(
name|MEM_SCALAR_P
argument_list|(
name|mem1
argument_list|)
operator|&&
name|MEM_IN_STRUCT_P
argument_list|(
name|mem2
argument_list|)
operator|&&
operator|!
name|varies_p
argument_list|(
name|mem1_addr
argument_list|,
literal|1
argument_list|)
operator|&&
name|varies_p
argument_list|(
name|mem2_addr
argument_list|,
literal|1
argument_list|)
condition|)
comment|/* MEM1 is a scalar at a fixed address; MEM2 is a struct at a        varying address.  */
return|return
name|mem1
return|;
if|if
condition|(
name|MEM_IN_STRUCT_P
argument_list|(
name|mem1
argument_list|)
operator|&&
name|MEM_SCALAR_P
argument_list|(
name|mem2
argument_list|)
operator|&&
name|varies_p
argument_list|(
name|mem1_addr
argument_list|,
literal|1
argument_list|)
operator|&&
operator|!
name|varies_p
argument_list|(
name|mem2_addr
argument_list|,
literal|1
argument_list|)
condition|)
comment|/* MEM2 is a scalar at a fixed address; MEM1 is a struct at a        varying address.  */
return|return
name|mem2
return|;
return|return
name|NULL_RTX
return|;
block|}
end_block

begin_comment
comment|/* Returns nonzero if something about the mode or address format MEM1    indicates that it might well alias *anything*.  */
end_comment

begin_function
specifier|static
name|int
name|aliases_everything_p
parameter_list|(
name|mem
parameter_list|)
name|rtx
name|mem
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|mem
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|AND
condition|)
comment|/* If the address is an AND, its very hard to know at what it is        actually pointing.  */
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return true if we can determine that the fields referenced cannot    overlap for any pair of objects.  */
end_comment

begin_function
specifier|static
name|bool
name|nonoverlapping_component_refs_p
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
name|tree
name|x
decl_stmt|,
name|y
decl_stmt|;
block|{
name|tree
name|fieldx
decl_stmt|,
name|fieldy
decl_stmt|,
name|typex
decl_stmt|,
name|typey
decl_stmt|,
name|orig_y
decl_stmt|;
do|do
block|{
comment|/* The comparison has to be done at a common type, since we don't 	 know how the inheritance hierarchy works.  */
name|orig_y
operator|=
name|y
expr_stmt|;
do|do
block|{
name|fieldx
operator|=
name|TREE_OPERAND
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|typex
operator|=
name|DECL_FIELD_CONTEXT
argument_list|(
name|fieldx
argument_list|)
expr_stmt|;
name|y
operator|=
name|orig_y
expr_stmt|;
do|do
block|{
name|fieldy
operator|=
name|TREE_OPERAND
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|typey
operator|=
name|DECL_FIELD_CONTEXT
argument_list|(
name|fieldy
argument_list|)
expr_stmt|;
if|if
condition|(
name|typex
operator|==
name|typey
condition|)
goto|goto
name|found
goto|;
name|y
operator|=
name|TREE_OPERAND
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|y
operator|&&
name|TREE_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
do|;
name|x
operator|=
name|TREE_OPERAND
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|x
operator|&&
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
do|;
comment|/* Never found a common type.  */
return|return
name|false
return|;
name|found
label|:
comment|/* If we're left with accessing different fields of a structure, 	 then no overlap.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|typex
argument_list|)
operator|==
name|RECORD_TYPE
operator|&&
name|fieldx
operator|!=
name|fieldy
condition|)
return|return
name|true
return|;
comment|/* The comparison on the current field failed.  If we're accessing 	 a very nested structure, look at the next outer level.  */
name|x
operator|=
name|TREE_OPERAND
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|y
operator|=
name|TREE_OPERAND
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|x
operator|&&
name|y
operator|&&
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|COMPONENT_REF
operator|&&
name|TREE_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
do|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Look at the bottom of the COMPONENT_REF list for a DECL, and return it.  */
end_comment

begin_function
specifier|static
name|tree
name|decl_for_component_ref
parameter_list|(
name|x
parameter_list|)
name|tree
name|x
decl_stmt|;
block|{
do|do
block|{
name|x
operator|=
name|TREE_OPERAND
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|x
operator|&&
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
do|;
return|return
name|x
operator|&&
name|DECL_P
argument_list|(
name|x
argument_list|)
condition|?
name|x
else|:
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Walk up the COMPONENT_REF list and adjust OFFSET to compensate for the    offset of the field reference.  */
end_comment

begin_function
specifier|static
name|rtx
name|adjust_offset_for_component_ref
parameter_list|(
name|x
parameter_list|,
name|offset
parameter_list|)
name|tree
name|x
decl_stmt|;
name|rtx
name|offset
decl_stmt|;
block|{
name|HOST_WIDE_INT
name|ioffset
decl_stmt|;
if|if
condition|(
operator|!
name|offset
condition|)
return|return
name|NULL_RTX
return|;
name|ioffset
operator|=
name|INTVAL
argument_list|(
name|offset
argument_list|)
expr_stmt|;
do|do
block|{
name|tree
name|field
init|=
name|TREE_OPERAND
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|host_integerp
argument_list|(
name|DECL_FIELD_OFFSET
argument_list|(
name|field
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|NULL_RTX
return|;
name|ioffset
operator|+=
operator|(
name|tree_low_cst
argument_list|(
name|DECL_FIELD_OFFSET
argument_list|(
name|field
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|+
operator|(
name|tree_low_cst
argument_list|(
name|DECL_FIELD_BIT_OFFSET
argument_list|(
name|field
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|/
name|BITS_PER_UNIT
operator|)
operator|)
expr_stmt|;
name|x
operator|=
name|TREE_OPERAND
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|x
operator|&&
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
do|;
return|return
name|GEN_INT
argument_list|(
name|ioffset
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if we can deterimine the exprs corresponding to memrefs    X and Y and they do not overlap.  */
end_comment

begin_function
specifier|static
name|int
name|nonoverlapping_memrefs_p
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|y
decl_stmt|;
block|{
name|tree
name|exprx
init|=
name|MEM_EXPR
argument_list|(
name|x
argument_list|)
decl_stmt|,
name|expry
init|=
name|MEM_EXPR
argument_list|(
name|y
argument_list|)
decl_stmt|;
name|rtx
name|rtlx
decl_stmt|,
name|rtly
decl_stmt|;
name|rtx
name|basex
decl_stmt|,
name|basey
decl_stmt|;
name|rtx
name|moffsetx
decl_stmt|,
name|moffsety
decl_stmt|;
name|HOST_WIDE_INT
name|offsetx
init|=
literal|0
decl_stmt|,
name|offsety
init|=
literal|0
decl_stmt|,
name|sizex
decl_stmt|,
name|sizey
decl_stmt|,
name|tem
decl_stmt|;
comment|/* Unless both have exprs, we can't tell anything.  */
if|if
condition|(
name|exprx
operator|==
literal|0
operator|||
name|expry
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* If both are field references, we may be able to determine something.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exprx
argument_list|)
operator|==
name|COMPONENT_REF
operator|&&
name|TREE_CODE
argument_list|(
name|expry
argument_list|)
operator|==
name|COMPONENT_REF
operator|&&
name|nonoverlapping_component_refs_p
argument_list|(
name|exprx
argument_list|,
name|expry
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* If the field reference test failed, look at the DECLs involved.  */
name|moffsetx
operator|=
name|MEM_OFFSET
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exprx
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
block|{
name|tree
name|t
init|=
name|decl_for_component_ref
argument_list|(
name|exprx
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|t
condition|)
return|return
literal|0
return|;
name|moffsetx
operator|=
name|adjust_offset_for_component_ref
argument_list|(
name|exprx
argument_list|,
name|moffsetx
argument_list|)
expr_stmt|;
name|exprx
operator|=
name|t
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exprx
argument_list|)
operator|==
name|INDIRECT_REF
condition|)
block|{
name|exprx
operator|=
name|TREE_OPERAND
argument_list|(
name|exprx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_argument_noalias
operator|<
literal|2
operator|||
name|TREE_CODE
argument_list|(
name|exprx
argument_list|)
operator|!=
name|PARM_DECL
condition|)
return|return
literal|0
return|;
block|}
name|moffsety
operator|=
name|MEM_OFFSET
argument_list|(
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expry
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
block|{
name|tree
name|t
init|=
name|decl_for_component_ref
argument_list|(
name|expry
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|t
condition|)
return|return
literal|0
return|;
name|moffsety
operator|=
name|adjust_offset_for_component_ref
argument_list|(
name|expry
argument_list|,
name|moffsety
argument_list|)
expr_stmt|;
name|expry
operator|=
name|t
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expry
argument_list|)
operator|==
name|INDIRECT_REF
condition|)
block|{
name|expry
operator|=
name|TREE_OPERAND
argument_list|(
name|expry
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_argument_noalias
operator|<
literal|2
operator|||
name|TREE_CODE
argument_list|(
name|expry
argument_list|)
operator|!=
name|PARM_DECL
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|DECL_P
argument_list|(
name|exprx
argument_list|)
operator|||
operator|!
name|DECL_P
argument_list|(
name|expry
argument_list|)
condition|)
return|return
literal|0
return|;
name|rtlx
operator|=
name|DECL_RTL
argument_list|(
name|exprx
argument_list|)
expr_stmt|;
name|rtly
operator|=
name|DECL_RTL
argument_list|(
name|expry
argument_list|)
expr_stmt|;
comment|/* If either RTL is not a MEM, it must be a REG or CONCAT, meaning they      can't overlap unless they are the same because we never reuse that part      of the stack frame used for locals for spilled pseudos.  */
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|rtlx
argument_list|)
operator|!=
name|MEM
operator|||
name|GET_CODE
argument_list|(
name|rtly
argument_list|)
operator|!=
name|MEM
operator|)
operator|&&
operator|!
name|rtx_equal_p
argument_list|(
name|rtlx
argument_list|,
name|rtly
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Get the base and offsets of both decls.  If either is a register, we      know both are and are the same, so use that as the base.  The only      we can avoid overlap is if we can deduce that they are nonoverlapping      pieces of that decl, which is very rare.  */
name|basex
operator|=
name|GET_CODE
argument_list|(
name|rtlx
argument_list|)
operator|==
name|MEM
condition|?
name|XEXP
argument_list|(
name|rtlx
argument_list|,
literal|0
argument_list|)
else|:
name|rtlx
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|basex
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|basex
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
name|offsetx
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|basex
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|,
name|basex
operator|=
name|XEXP
argument_list|(
name|basex
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|basey
operator|=
name|GET_CODE
argument_list|(
name|rtly
argument_list|)
operator|==
name|MEM
condition|?
name|XEXP
argument_list|(
name|rtly
argument_list|,
literal|0
argument_list|)
else|:
name|rtly
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|basey
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|basey
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
name|offsety
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|basey
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|,
name|basey
operator|=
name|XEXP
argument_list|(
name|basey
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If the bases are different, we know they do not overlap if both      are constants or if one is a constant and the other a pointer into the      stack frame.  Otherwise a different base means we can't tell if they      overlap or not.  */
if|if
condition|(
operator|!
name|rtx_equal_p
argument_list|(
name|basex
argument_list|,
name|basey
argument_list|)
condition|)
return|return
operator|(
operator|(
name|CONSTANT_P
argument_list|(
name|basex
argument_list|)
operator|&&
name|CONSTANT_P
argument_list|(
name|basey
argument_list|)
operator|)
operator|||
operator|(
name|CONSTANT_P
argument_list|(
name|basex
argument_list|)
operator|&&
name|REG_P
argument_list|(
name|basey
argument_list|)
operator|&&
name|REGNO_PTR_FRAME_P
argument_list|(
name|REGNO
argument_list|(
name|basey
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|CONSTANT_P
argument_list|(
name|basey
argument_list|)
operator|&&
name|REG_P
argument_list|(
name|basex
argument_list|)
operator|&&
name|REGNO_PTR_FRAME_P
argument_list|(
name|REGNO
argument_list|(
name|basex
argument_list|)
argument_list|)
operator|)
operator|)
return|;
name|sizex
operator|=
operator|(
name|GET_CODE
argument_list|(
name|rtlx
argument_list|)
operator|!=
name|MEM
condition|?
operator|(
name|int
operator|)
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|rtlx
argument_list|)
argument_list|)
else|:
name|MEM_SIZE
argument_list|(
name|rtlx
argument_list|)
condition|?
name|INTVAL
argument_list|(
name|MEM_SIZE
argument_list|(
name|rtlx
argument_list|)
argument_list|)
else|:
operator|-
literal|1
operator|)
expr_stmt|;
name|sizey
operator|=
operator|(
name|GET_CODE
argument_list|(
name|rtly
argument_list|)
operator|!=
name|MEM
condition|?
operator|(
name|int
operator|)
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|rtly
argument_list|)
argument_list|)
else|:
name|MEM_SIZE
argument_list|(
name|rtly
argument_list|)
condition|?
name|INTVAL
argument_list|(
name|MEM_SIZE
argument_list|(
name|rtly
argument_list|)
argument_list|)
else|:
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* If we have an offset for either memref, it can update the values computed      above.  */
if|if
condition|(
name|moffsetx
condition|)
name|offsetx
operator|+=
name|INTVAL
argument_list|(
name|moffsetx
argument_list|)
operator|,
name|sizex
operator|-=
name|INTVAL
argument_list|(
name|moffsetx
argument_list|)
expr_stmt|;
if|if
condition|(
name|moffsety
condition|)
name|offsety
operator|+=
name|INTVAL
argument_list|(
name|moffsety
argument_list|)
operator|,
name|sizey
operator|-=
name|INTVAL
argument_list|(
name|moffsety
argument_list|)
expr_stmt|;
comment|/* If a memref has both a size and an offset, we can use the smaller size.      We can't do this if the offset isn't known because we must view this      memref as being anywhere inside the DECL's MEM.  */
if|if
condition|(
name|MEM_SIZE
argument_list|(
name|x
argument_list|)
operator|&&
name|moffsetx
condition|)
name|sizex
operator|=
name|INTVAL
argument_list|(
name|MEM_SIZE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|MEM_SIZE
argument_list|(
name|y
argument_list|)
operator|&&
name|moffsety
condition|)
name|sizey
operator|=
name|INTVAL
argument_list|(
name|MEM_SIZE
argument_list|(
name|y
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Put the values of the memref with the lower offset in X's values.  */
if|if
condition|(
name|offsetx
operator|>
name|offsety
condition|)
block|{
name|tem
operator|=
name|offsetx
operator|,
name|offsetx
operator|=
name|offsety
operator|,
name|offsety
operator|=
name|tem
expr_stmt|;
name|tem
operator|=
name|sizex
operator|,
name|sizex
operator|=
name|sizey
operator|,
name|sizey
operator|=
name|tem
expr_stmt|;
block|}
comment|/* If we don't know the size of the lower-offset value, we can't tell      if they conflict.  Otherwise, we do the test.  */
return|return
name|sizex
operator|>=
literal|0
operator|&&
name|offsety
operator|>=
name|offsetx
operator|+
name|sizex
return|;
block|}
end_function

begin_comment
comment|/* True dependence: X is read after store in MEM takes place.  */
end_comment

begin_function_decl
name|int
name|true_dependence
parameter_list|(
name|mem
parameter_list|,
name|mem_mode
parameter_list|,
name|x
parameter_list|,
name|varies
parameter_list|)
name|rtx
name|mem
decl_stmt|;
name|enum
name|machine_mode
name|mem_mode
decl_stmt|;
name|rtx
name|x
decl_stmt|;
function_decl|int
parameter_list|(
function_decl|*varies
end_function_decl

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|rtx
name|x_addr
decl_stmt|,
name|mem_addr
decl_stmt|;
name|rtx
name|base
decl_stmt|;
if|if
condition|(
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
operator|&&
name|MEM_VOLATILE_P
argument_list|(
name|mem
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* (mem:BLK (scratch)) is a special mechanism to conflict with everything.      This is used in epilogue deallocation functions.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|BLKmode
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SCRATCH
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|mem
argument_list|)
operator|==
name|BLKmode
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|mem
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SCRATCH
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|DIFFERENT_ALIAS_SETS_P
argument_list|(
name|x
argument_list|,
name|mem
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Unchanging memory can't conflict with non-unchanging memory.      A non-unchanging read can conflict with a non-unchanging write.      An unchanging read can conflict with an unchanging write since      there may be a single store to this address to initialize it.      Note that an unchanging store can conflict with a non-unchanging read      since we have to make conservative assumptions when we have a      record with readonly fields and we are copying the whole thing.      Just fall through to the code below to resolve potential conflicts.      This won't handle all cases optimally, but the possible performance      loss should be negligible.  */
if|if
condition|(
name|RTX_UNCHANGING_P
argument_list|(
name|x
argument_list|)
operator|&&
operator|!
name|RTX_UNCHANGING_P
argument_list|(
name|mem
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|nonoverlapping_memrefs_p
argument_list|(
name|mem
argument_list|,
name|x
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|mem_mode
operator|==
name|VOIDmode
condition|)
name|mem_mode
operator|=
name|GET_MODE
argument_list|(
name|mem
argument_list|)
expr_stmt|;
name|x_addr
operator|=
name|get_addr
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|mem_addr
operator|=
name|get_addr
argument_list|(
name|XEXP
argument_list|(
name|mem
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|base
operator|=
name|find_base_term
argument_list|(
name|x_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|base
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|LABEL_REF
operator|||
operator|(
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|base
argument_list|)
operator|)
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|base_alias_check
argument_list|(
name|x_addr
argument_list|,
name|mem_addr
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|mem_mode
argument_list|)
condition|)
return|return
literal|0
return|;
name|x_addr
operator|=
name|canon_rtx
argument_list|(
name|x_addr
argument_list|)
expr_stmt|;
name|mem_addr
operator|=
name|canon_rtx
argument_list|(
name|mem_addr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|memrefs_conflict_p
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|mem_mode
argument_list|)
argument_list|,
name|mem_addr
argument_list|,
name|SIZE_FOR_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|x_addr
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|aliases_everything_p
argument_list|(
name|x
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* We cannot use aliases_everything_p to test MEM, since we must look      at MEM_MODE, rather than GET_MODE (MEM).  */
if|if
condition|(
name|mem_mode
operator|==
name|QImode
operator|||
name|GET_CODE
argument_list|(
name|mem_addr
argument_list|)
operator|==
name|AND
condition|)
return|return
literal|1
return|;
comment|/* In true_dependence we also allow BLKmode to alias anything.  Why      don't we do this in anti_dependence and output_dependence?  */
if|if
condition|(
name|mem_mode
operator|==
name|BLKmode
operator|||
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|BLKmode
condition|)
return|return
literal|1
return|;
return|return
operator|!
name|fixed_scalar_and_varying_struct_p
argument_list|(
name|mem
argument_list|,
name|x
argument_list|,
name|mem_addr
argument_list|,
name|x_addr
argument_list|,
name|varies
argument_list|)
return|;
block|}
end_block

begin_comment
comment|/* Canonical true dependence: X is read after store in MEM takes place.    Variant of true_dependence which assumes MEM has already been    canonicalized (hence we no longer do that here).    The mem_addr argument has been added, since true_dependence computed    this value prior to canonicalizing.  */
end_comment

begin_function_decl
name|int
name|canon_true_dependence
parameter_list|(
name|mem
parameter_list|,
name|mem_mode
parameter_list|,
name|mem_addr
parameter_list|,
name|x
parameter_list|,
name|varies
parameter_list|)
name|rtx
name|mem
decl_stmt|,
name|mem_addr
decl_stmt|,
name|x
decl_stmt|;
name|enum
name|machine_mode
name|mem_mode
decl_stmt|;
function_decl|int
parameter_list|(
function_decl|*varies
end_function_decl

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|rtx
name|x_addr
decl_stmt|;
if|if
condition|(
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
operator|&&
name|MEM_VOLATILE_P
argument_list|(
name|mem
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* (mem:BLK (scratch)) is a special mechanism to conflict with everything.      This is used in epilogue deallocation functions.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|BLKmode
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SCRATCH
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|mem
argument_list|)
operator|==
name|BLKmode
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|mem
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SCRATCH
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|DIFFERENT_ALIAS_SETS_P
argument_list|(
name|x
argument_list|,
name|mem
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* If X is an unchanging read, then it can't possibly conflict with any      non-unchanging store.  It may conflict with an unchanging write though,      because there may be a single store to this address to initialize it.      Just fall through to the code below to resolve the case where we have      both an unchanging read and an unchanging write.  This won't handle all      cases optimally, but the possible performance loss should be      negligible.  */
if|if
condition|(
name|RTX_UNCHANGING_P
argument_list|(
name|x
argument_list|)
operator|&&
operator|!
name|RTX_UNCHANGING_P
argument_list|(
name|mem
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|nonoverlapping_memrefs_p
argument_list|(
name|x
argument_list|,
name|mem
argument_list|)
condition|)
return|return
literal|0
return|;
name|x_addr
operator|=
name|get_addr
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|base_alias_check
argument_list|(
name|x_addr
argument_list|,
name|mem_addr
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|mem_mode
argument_list|)
condition|)
return|return
literal|0
return|;
name|x_addr
operator|=
name|canon_rtx
argument_list|(
name|x_addr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|memrefs_conflict_p
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|mem_mode
argument_list|)
argument_list|,
name|mem_addr
argument_list|,
name|SIZE_FOR_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|x_addr
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|aliases_everything_p
argument_list|(
name|x
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* We cannot use aliases_everything_p to test MEM, since we must look      at MEM_MODE, rather than GET_MODE (MEM).  */
if|if
condition|(
name|mem_mode
operator|==
name|QImode
operator|||
name|GET_CODE
argument_list|(
name|mem_addr
argument_list|)
operator|==
name|AND
condition|)
return|return
literal|1
return|;
comment|/* In true_dependence we also allow BLKmode to alias anything.  Why      don't we do this in anti_dependence and output_dependence?  */
if|if
condition|(
name|mem_mode
operator|==
name|BLKmode
operator|||
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|BLKmode
condition|)
return|return
literal|1
return|;
return|return
operator|!
name|fixed_scalar_and_varying_struct_p
argument_list|(
name|mem
argument_list|,
name|x
argument_list|,
name|mem_addr
argument_list|,
name|x_addr
argument_list|,
name|varies
argument_list|)
return|;
block|}
end_block

begin_comment
comment|/* Returns nonzero if a write to X might alias a previous read from    (or, if WRITEP is nonzero, a write to) MEM.  */
end_comment

begin_function
specifier|static
name|int
name|write_dependence_p
parameter_list|(
name|mem
parameter_list|,
name|x
parameter_list|,
name|writep
parameter_list|)
name|rtx
name|mem
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|int
name|writep
decl_stmt|;
block|{
name|rtx
name|x_addr
decl_stmt|,
name|mem_addr
decl_stmt|;
name|rtx
name|fixed_scalar
decl_stmt|;
name|rtx
name|base
decl_stmt|;
if|if
condition|(
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
operator|&&
name|MEM_VOLATILE_P
argument_list|(
name|mem
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* (mem:BLK (scratch)) is a special mechanism to conflict with everything.      This is used in epilogue deallocation functions.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|BLKmode
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SCRATCH
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|mem
argument_list|)
operator|==
name|BLKmode
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|mem
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SCRATCH
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|DIFFERENT_ALIAS_SETS_P
argument_list|(
name|x
argument_list|,
name|mem
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Unchanging memory can't conflict with non-unchanging memory.  */
if|if
condition|(
name|RTX_UNCHANGING_P
argument_list|(
name|x
argument_list|)
operator|!=
name|RTX_UNCHANGING_P
argument_list|(
name|mem
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* If MEM is an unchanging read, then it can't possibly conflict with      the store to X, because there is at most one store to MEM, and it must      have occurred somewhere before MEM.  */
if|if
condition|(
operator|!
name|writep
operator|&&
name|RTX_UNCHANGING_P
argument_list|(
name|mem
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|nonoverlapping_memrefs_p
argument_list|(
name|x
argument_list|,
name|mem
argument_list|)
condition|)
return|return
literal|0
return|;
name|x_addr
operator|=
name|get_addr
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|mem_addr
operator|=
name|get_addr
argument_list|(
name|XEXP
argument_list|(
name|mem
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|writep
condition|)
block|{
name|base
operator|=
name|find_base_term
argument_list|(
name|mem_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|base
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|LABEL_REF
operator|||
operator|(
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|base
argument_list|)
operator|)
operator|)
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|base_alias_check
argument_list|(
name|x_addr
argument_list|,
name|mem_addr
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|mem
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
name|x_addr
operator|=
name|canon_rtx
argument_list|(
name|x_addr
argument_list|)
expr_stmt|;
name|mem_addr
operator|=
name|canon_rtx
argument_list|(
name|mem_addr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|memrefs_conflict_p
argument_list|(
name|SIZE_FOR_MODE
argument_list|(
name|mem
argument_list|)
argument_list|,
name|mem_addr
argument_list|,
name|SIZE_FOR_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|x_addr
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|0
return|;
name|fixed_scalar
operator|=
name|fixed_scalar_and_varying_struct_p
argument_list|(
name|mem
argument_list|,
name|x
argument_list|,
name|mem_addr
argument_list|,
name|x_addr
argument_list|,
name|rtx_addr_varies_p
argument_list|)
expr_stmt|;
return|return
operator|(
operator|!
operator|(
name|fixed_scalar
operator|==
name|mem
operator|&&
operator|!
name|aliases_everything_p
argument_list|(
name|x
argument_list|)
operator|)
operator|&&
operator|!
operator|(
name|fixed_scalar
operator|==
name|x
operator|&&
operator|!
name|aliases_everything_p
argument_list|(
name|mem
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Anti dependence: X is written after read in MEM takes place.  */
end_comment

begin_function
name|int
name|anti_dependence
parameter_list|(
name|mem
parameter_list|,
name|x
parameter_list|)
name|rtx
name|mem
decl_stmt|;
name|rtx
name|x
decl_stmt|;
block|{
return|return
name|write_dependence_p
argument_list|(
name|mem
argument_list|,
name|x
argument_list|,
comment|/*writep=*/
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Output dependence: X is written after store in MEM takes place.  */
end_comment

begin_function
name|int
name|output_dependence
parameter_list|(
name|mem
parameter_list|,
name|x
parameter_list|)
name|rtx
name|mem
decl_stmt|;
name|rtx
name|x
decl_stmt|;
block|{
return|return
name|write_dependence_p
argument_list|(
name|mem
argument_list|,
name|x
argument_list|,
comment|/*writep=*/
literal|1
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* A subroutine of nonlocal_mentioned_p, returns 1 if *LOC mentions    something which is not local to the function and is not constant.  */
end_comment

begin_function
specifier|static
name|int
name|nonlocal_mentioned_p_1
parameter_list|(
name|loc
parameter_list|,
name|data
parameter_list|)
name|rtx
modifier|*
name|loc
decl_stmt|;
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|rtx
name|x
init|=
operator|*
name|loc
decl_stmt|;
name|rtx
name|base
decl_stmt|;
name|int
name|regno
decl_stmt|;
if|if
condition|(
operator|!
name|x
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|SUBREG
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
comment|/* Global registers are not local.  */
if|if
condition|(
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|global_regs
index|[
name|subreg_regno
argument_list|(
name|x
argument_list|)
index|]
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
break|break;
case|case
name|REG
case|:
name|regno
operator|=
name|REGNO
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* Global registers are not local.  */
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|global_regs
index|[
name|regno
index|]
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
case|case
name|SCRATCH
case|:
case|case
name|PC
case|:
case|case
name|CC0
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CONST_VECTOR
case|:
case|case
name|CONST
case|:
case|case
name|LABEL_REF
case|:
return|return
literal|0
return|;
case|case
name|SYMBOL_REF
case|:
comment|/* Constants in the function's constants pool are constant.  */
if|if
condition|(
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|x
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
case|case
name|CALL
case|:
comment|/* Non-constant calls and recursion are not local.  */
return|return
literal|1
return|;
case|case
name|MEM
case|:
comment|/* Be overly conservative and consider any volatile memory 	 reference as not local.  */
if|if
condition|(
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
condition|)
return|return
literal|1
return|;
name|base
operator|=
name|find_base_term
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|base
condition|)
block|{
comment|/* A Pmode ADDRESS could be a reference via the structure value 	     address or static chain.  Such memory references are nonlocal.  	     Thus, we have to examine the contents of the ADDRESS to find 	     out if this is a local reference or not.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|ADDRESS
operator|&&
name|GET_MODE
argument_list|(
name|base
argument_list|)
operator|==
name|Pmode
operator|&&
operator|(
name|XEXP
argument_list|(
name|base
argument_list|,
literal|0
argument_list|)
operator|==
name|stack_pointer_rtx
operator|||
name|XEXP
argument_list|(
name|base
argument_list|,
literal|0
argument_list|)
operator|==
name|arg_pointer_rtx
if|#
directive|if
name|HARD_FRAME_POINTER_REGNUM
operator|!=
name|FRAME_POINTER_REGNUM
operator|||
name|XEXP
argument_list|(
name|base
argument_list|,
literal|0
argument_list|)
operator|==
name|hard_frame_pointer_rtx
endif|#
directive|endif
operator|||
name|XEXP
argument_list|(
name|base
argument_list|,
literal|0
argument_list|)
operator|==
name|frame_pointer_rtx
operator|)
condition|)
return|return
literal|0
return|;
comment|/* Constants in the function's constant pool are constant.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|base
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
case|case
name|UNSPEC_VOLATILE
case|:
case|case
name|ASM_INPUT
case|:
return|return
literal|1
return|;
case|case
name|ASM_OPERANDS
case|:
if|if
condition|(
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* FALLTHROUGH */
default|default:
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Returns nonzero if X might mention something which is not    local to the function and is not constant.  */
end_comment

begin_function
specifier|static
name|int
name|nonlocal_mentioned_p
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
if|if
condition|(
name|INSN_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
if|if
condition|(
operator|!
name|CONST_OR_PURE_CALL_P
argument_list|(
name|x
argument_list|)
condition|)
return|return
literal|1
return|;
name|x
operator|=
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return
literal|0
return|;
block|}
else|else
name|x
operator|=
name|PATTERN
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
return|return
name|for_each_rtx
argument_list|(
operator|&
name|x
argument_list|,
name|nonlocal_mentioned_p_1
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* A subroutine of nonlocal_referenced_p, returns 1 if *LOC references    something which is not local to the function and is not constant.  */
end_comment

begin_function
specifier|static
name|int
name|nonlocal_referenced_p_1
parameter_list|(
name|loc
parameter_list|,
name|data
parameter_list|)
name|rtx
modifier|*
name|loc
decl_stmt|;
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|rtx
name|x
init|=
operator|*
name|loc
decl_stmt|;
if|if
condition|(
operator|!
name|x
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|MEM
case|:
case|case
name|REG
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|SUBREG
case|:
return|return
name|nonlocal_mentioned_p
argument_list|(
name|x
argument_list|)
return|;
case|case
name|CALL
case|:
comment|/* Non-constant calls and recursion are not local.  */
return|return
literal|1
return|;
case|case
name|SET
case|:
if|if
condition|(
name|nonlocal_mentioned_p
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
return|return
name|nonlocal_mentioned_p
argument_list|(
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
comment|/* If the destination is anything other than a CC0, PC, 	 MEM, REG, or a SUBREG of a REG that occupies all of 	 the REG, then X references nonlocal memory if it is 	 mentioned in the destination.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|CC0
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|PC
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|REG
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
operator|(
operator|(
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|+
operator|(
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|)
operator|/
name|UNITS_PER_WORD
operator|)
operator|==
operator|(
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|+
operator|(
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|)
operator|/
name|UNITS_PER_WORD
operator|)
operator|)
operator|)
condition|)
return|return
name|nonlocal_mentioned_p
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
return|;
return|return
literal|0
return|;
case|case
name|CLOBBER
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
return|return
name|nonlocal_mentioned_p
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
return|return
literal|0
return|;
case|case
name|USE
case|:
return|return
name|nonlocal_mentioned_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|ASM_INPUT
case|:
case|case
name|UNSPEC_VOLATILE
case|:
return|return
literal|1
return|;
case|case
name|ASM_OPERANDS
case|:
if|if
condition|(
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* FALLTHROUGH */
default|default:
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Returns nonzero if X might reference something which is not    local to the function and is not constant.  */
end_comment

begin_function
specifier|static
name|int
name|nonlocal_referenced_p
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
if|if
condition|(
name|INSN_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
if|if
condition|(
operator|!
name|CONST_OR_PURE_CALL_P
argument_list|(
name|x
argument_list|)
condition|)
return|return
literal|1
return|;
name|x
operator|=
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return
literal|0
return|;
block|}
else|else
name|x
operator|=
name|PATTERN
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
return|return
name|for_each_rtx
argument_list|(
operator|&
name|x
argument_list|,
name|nonlocal_referenced_p_1
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* A subroutine of nonlocal_set_p, returns 1 if *LOC sets    something which is not local to the function and is not constant.  */
end_comment

begin_function
specifier|static
name|int
name|nonlocal_set_p_1
parameter_list|(
name|loc
parameter_list|,
name|data
parameter_list|)
name|rtx
modifier|*
name|loc
decl_stmt|;
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|rtx
name|x
init|=
operator|*
name|loc
decl_stmt|;
if|if
condition|(
operator|!
name|x
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|CALL
case|:
comment|/* Non-constant calls and recursion are not local.  */
return|return
literal|1
return|;
case|case
name|PRE_INC
case|:
case|case
name|PRE_DEC
case|:
case|case
name|POST_INC
case|:
case|case
name|POST_DEC
case|:
case|case
name|PRE_MODIFY
case|:
case|case
name|POST_MODIFY
case|:
return|return
name|nonlocal_mentioned_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|SET
case|:
if|if
condition|(
name|nonlocal_mentioned_p
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
name|nonlocal_set_p
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
return|;
case|case
name|CLOBBER
case|:
return|return
name|nonlocal_mentioned_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|USE
case|:
return|return
literal|0
return|;
case|case
name|ASM_INPUT
case|:
case|case
name|UNSPEC_VOLATILE
case|:
return|return
literal|1
return|;
case|case
name|ASM_OPERANDS
case|:
if|if
condition|(
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* FALLTHROUGH */
default|default:
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Returns nonzero if X might set something which is not    local to the function and is not constant.  */
end_comment

begin_function
specifier|static
name|int
name|nonlocal_set_p
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
if|if
condition|(
name|INSN_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
if|if
condition|(
operator|!
name|CONST_OR_PURE_CALL_P
argument_list|(
name|x
argument_list|)
condition|)
return|return
literal|1
return|;
name|x
operator|=
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return
literal|0
return|;
block|}
else|else
name|x
operator|=
name|PATTERN
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
return|return
name|for_each_rtx
argument_list|(
operator|&
name|x
argument_list|,
name|nonlocal_set_p_1
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Mark the function if it is constant.  */
end_comment

begin_function
name|void
name|mark_constant_function
parameter_list|()
block|{
name|rtx
name|insn
decl_stmt|;
name|int
name|nonlocal_memory_referenced
decl_stmt|;
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|current_function_decl
argument_list|)
operator|||
name|DECL_IS_PURE
argument_list|(
name|current_function_decl
argument_list|)
operator|||
name|TREE_THIS_VOLATILE
argument_list|(
name|current_function_decl
argument_list|)
operator|||
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
operator|==
name|VOIDmode
operator|||
name|current_function_has_nonlocal_goto
operator|||
operator|!
call|(
modifier|*
name|targetm
operator|.
name|binds_local_p
call|)
argument_list|(
name|current_function_decl
argument_list|)
condition|)
return|return;
comment|/* A loop might not return which counts as a side effect.  */
if|if
condition|(
name|mark_dfs_back_edges
argument_list|()
condition|)
return|return;
name|nonlocal_memory_referenced
operator|=
literal|0
expr_stmt|;
name|init_alias_analysis
argument_list|()
expr_stmt|;
comment|/* Determine if this is a constant or pure function.  */
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|nonlocal_set_p
argument_list|(
name|insn
argument_list|)
operator|||
name|global_reg_mentioned_p
argument_list|(
name|insn
argument_list|)
operator|||
name|volatile_refs_p
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|!
name|nonlocal_memory_referenced
condition|)
name|nonlocal_memory_referenced
operator|=
name|nonlocal_referenced_p
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
name|end_alias_analysis
argument_list|()
expr_stmt|;
comment|/* Mark the function.  */
if|if
condition|(
name|insn
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|nonlocal_memory_referenced
condition|)
name|DECL_IS_PURE
argument_list|(
name|current_function_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
else|else
name|TREE_READONLY
argument_list|(
name|current_function_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|init_alias_once
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
ifndef|#
directive|ifndef
name|OUTGOING_REGNO
define|#
directive|define
name|OUTGOING_REGNO
parameter_list|(
name|N
parameter_list|)
value|N
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
comment|/* Check whether this register can hold an incoming pointer        argument.  FUNCTION_ARG_REGNO_P tests outgoing register        numbers, so translate if necessary due to register windows.  */
if|if
condition|(
name|FUNCTION_ARG_REGNO_P
argument_list|(
name|OUTGOING_REGNO
argument_list|(
name|i
argument_list|)
argument_list|)
operator|&&
name|HARD_REGNO_MODE_OK
argument_list|(
name|i
argument_list|,
name|Pmode
argument_list|)
condition|)
name|static_reg_base_value
index|[
name|i
index|]
operator|=
name|gen_rtx_ADDRESS
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|static_reg_base_value
index|[
name|STACK_POINTER_REGNUM
index|]
operator|=
name|gen_rtx_ADDRESS
argument_list|(
name|Pmode
argument_list|,
name|stack_pointer_rtx
argument_list|)
expr_stmt|;
name|static_reg_base_value
index|[
name|ARG_POINTER_REGNUM
index|]
operator|=
name|gen_rtx_ADDRESS
argument_list|(
name|Pmode
argument_list|,
name|arg_pointer_rtx
argument_list|)
expr_stmt|;
name|static_reg_base_value
index|[
name|FRAME_POINTER_REGNUM
index|]
operator|=
name|gen_rtx_ADDRESS
argument_list|(
name|Pmode
argument_list|,
name|frame_pointer_rtx
argument_list|)
expr_stmt|;
if|#
directive|if
name|HARD_FRAME_POINTER_REGNUM
operator|!=
name|FRAME_POINTER_REGNUM
name|static_reg_base_value
index|[
name|HARD_FRAME_POINTER_REGNUM
index|]
operator|=
name|gen_rtx_ADDRESS
argument_list|(
name|Pmode
argument_list|,
name|hard_frame_pointer_rtx
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|alias_sets
operator|=
name|splay_tree_new
argument_list|(
name|splay_tree_compare_ints
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize the aliasing machinery.  Initialize the REG_KNOWN_VALUE    array.  */
end_comment

begin_function
name|void
name|init_alias_analysis
parameter_list|()
block|{
name|int
name|maxreg
init|=
name|max_reg_num
argument_list|()
decl_stmt|;
name|int
name|changed
decl_stmt|,
name|pass
decl_stmt|;
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|ui
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|reg_known_value_size
operator|=
name|maxreg
expr_stmt|;
name|reg_known_value
operator|=
operator|(
name|rtx
operator|*
operator|)
name|xcalloc
argument_list|(
operator|(
name|maxreg
operator|-
name|FIRST_PSEUDO_REGISTER
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
operator|-
name|FIRST_PSEUDO_REGISTER
expr_stmt|;
name|reg_known_equiv_p
operator|=
operator|(
name|char
operator|*
operator|)
name|xcalloc
argument_list|(
operator|(
name|maxreg
operator|-
name|FIRST_PSEUDO_REGISTER
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
operator|-
name|FIRST_PSEUDO_REGISTER
expr_stmt|;
comment|/* Overallocate reg_base_value to allow some growth during loop      optimization.  Loop unrolling can create a large number of      registers.  */
name|reg_base_value_size
operator|=
name|maxreg
operator|*
literal|2
expr_stmt|;
name|reg_base_value
operator|=
operator|(
name|rtx
operator|*
operator|)
name|ggc_alloc_cleared
argument_list|(
name|reg_base_value_size
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|new_reg_base_value
operator|=
operator|(
name|rtx
operator|*
operator|)
name|xmalloc
argument_list|(
name|reg_base_value_size
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|reg_seen
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|reg_base_value_size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|reload_completed
operator|&&
name|flag_unroll_loops
condition|)
block|{
comment|/* ??? Why are we realloc'ing if we're just going to zero it?  */
name|alias_invariant
operator|=
operator|(
name|rtx
operator|*
operator|)
name|xrealloc
argument_list|(
name|alias_invariant
argument_list|,
name|reg_base_value_size
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|alias_invariant
argument_list|,
literal|0
argument_list|,
name|reg_base_value_size
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* The basic idea is that each pass through this loop will use the      "constant" information from the previous pass to propagate alias      information through another level of assignments.       This could get expensive if the assignment chains are long.  Maybe      we should throttle the number of iterations, possibly based on      the optimization level or flag_expensive_optimizations.       We could propagate more information in the first pass by making use      of REG_N_SETS to determine immediately that the alias information      for a pseudo is "constant".       A program with an uninitialized variable can cause an infinite loop      here.  Instead of doing a full dataflow analysis to detect such problems      we just cap the number of iterations for the loop.       The state of the arrays for the set chain in question does not matter      since the program has undefined behavior.  */
name|pass
operator|=
literal|0
expr_stmt|;
do|do
block|{
comment|/* Assume nothing will change this iteration of the loop.  */
name|changed
operator|=
literal|0
expr_stmt|;
comment|/* We want to assign the same IDs each iteration of this loop, so 	 start counting from zero each iteration of the loop.  */
name|unique_id
operator|=
literal|0
expr_stmt|;
comment|/* We're at the start of the function each iteration through the 	 loop, so we're copying arguments.  */
name|copying_arguments
operator|=
name|true
expr_stmt|;
comment|/* Wipe the potential alias information clean for this pass.  */
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|new_reg_base_value
argument_list|,
literal|0
argument_list|,
name|reg_base_value_size
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Wipe the reg_seen array clean.  */
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|reg_seen
argument_list|,
literal|0
argument_list|,
name|reg_base_value_size
argument_list|)
expr_stmt|;
comment|/* Mark all hard registers which may contain an address. 	 The stack, frame and argument pointers may contain an address. 	 An argument register which can hold a Pmode value may contain 	 an address even if it is not in BASE_REGS.  	 The address expression is VOIDmode for an argument and 	 Pmode for other registers.  */
name|memcpy
argument_list|(
name|new_reg_base_value
argument_list|,
name|static_reg_base_value
argument_list|,
name|FIRST_PSEUDO_REGISTER
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Walk the insns adding values to the new_reg_base_value array.  */
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|rtx
name|note
decl_stmt|,
name|set
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_prologue
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_epilogue
argument_list|)
comment|/* The prologue/epilogue insns are not threaded onto the 		 insn chain until after reload has completed.  Thus, 		 there is no sense wasting time checking if INSN is in 		 the prologue/epilogue until after reload has completed.  */
if|if
condition|(
name|reload_completed
operator|&&
name|prologue_epilogue_contains
argument_list|(
name|insn
argument_list|)
condition|)
continue|continue;
endif|#
directive|endif
comment|/* If this insn has a noalias note, process it,  Otherwise, 	         scan for sets.  A simple set will have no side effects 	         which could change the base value of any other register.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|!=
literal|0
operator|&&
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_NOALIAS
argument_list|,
name|NULL_RTX
argument_list|)
condition|)
name|record_set
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|record_set
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|set
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|unsigned
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|src
init|=
name|SET_SRC
argument_list|(
name|set
argument_list|)
decl_stmt|;
if|if
condition|(
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|!=
literal|0
operator|&&
operator|(
operator|(
operator|(
name|note
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_EQUAL
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|REG_N_SETS
argument_list|(
name|regno
argument_list|)
operator|==
literal|1
operator|)
operator|||
operator|(
name|note
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_EQUIV
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
operator|!=
literal|0
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|EXPR_LIST
operator|&&
operator|!
name|rtx_varies_p
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|&&
operator|!
name|reg_overlap_mentioned_p
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|reg_known_value
index|[
name|regno
index|]
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|reg_known_equiv_p
index|[
name|regno
index|]
operator|=
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
operator|==
name|REG_EQUIV
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|REG_N_SETS
argument_list|(
name|regno
argument_list|)
operator|==
literal|1
operator|&&
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
operator|(
name|reg_known_value
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|rtx
name|op0
init|=
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|op0
operator|=
name|reg_known_value
index|[
name|REGNO
argument_list|(
name|op0
argument_list|)
index|]
expr_stmt|;
name|reg_known_value
index|[
name|regno
index|]
operator|=
name|plus_constant
argument_list|(
name|op0
argument_list|,
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|reg_known_equiv_p
index|[
name|regno
index|]
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|REG_N_SETS
argument_list|(
name|regno
argument_list|)
operator|==
literal|1
operator|&&
operator|!
name|rtx_varies_p
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|reg_known_value
index|[
name|regno
index|]
operator|=
name|src
expr_stmt|;
name|reg_known_equiv_p
index|[
name|regno
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_FUNCTION_BEG
condition|)
name|copying_arguments
operator|=
name|false
expr_stmt|;
block|}
comment|/* Now propagate values from new_reg_base_value to reg_base_value.  */
for|for
control|(
name|ui
operator|=
literal|0
init|;
name|ui
operator|<
name|reg_base_value_size
condition|;
name|ui
operator|++
control|)
block|{
if|if
condition|(
name|new_reg_base_value
index|[
name|ui
index|]
operator|&&
name|new_reg_base_value
index|[
name|ui
index|]
operator|!=
name|reg_base_value
index|[
name|ui
index|]
operator|&&
operator|!
name|rtx_equal_p
argument_list|(
name|new_reg_base_value
index|[
name|ui
index|]
argument_list|,
name|reg_base_value
index|[
name|ui
index|]
argument_list|)
condition|)
block|{
name|reg_base_value
index|[
name|ui
index|]
operator|=
name|new_reg_base_value
index|[
name|ui
index|]
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
name|changed
operator|&&
operator|++
name|pass
operator|<
name|MAX_ALIAS_LOOP_PASSES
condition|)
do|;
comment|/* Fill in the remaining entries.  */
for|for
control|(
name|i
operator|=
name|FIRST_PSEUDO_REGISTER
init|;
name|i
operator|<
name|maxreg
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|reg_known_value
index|[
name|i
index|]
operator|==
literal|0
condition|)
name|reg_known_value
index|[
name|i
index|]
operator|=
name|regno_reg_rtx
index|[
name|i
index|]
expr_stmt|;
comment|/* Simplify the reg_base_value array so that no register refers to      another register, except to special registers indirectly through      ADDRESS expressions.       In theory this loop can take as long as O(registers^2), but unless      there are very long dependency chains it will run in close to linear      time.       This loop may not be needed any longer now that the main loop does      a better job at propagating alias information.  */
name|pass
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|changed
operator|=
literal|0
expr_stmt|;
name|pass
operator|++
expr_stmt|;
for|for
control|(
name|ui
operator|=
literal|0
init|;
name|ui
operator|<
name|reg_base_value_size
condition|;
name|ui
operator|++
control|)
block|{
name|rtx
name|base
init|=
name|reg_base_value
index|[
name|ui
index|]
decl_stmt|;
if|if
condition|(
name|base
operator|&&
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|REG
condition|)
block|{
name|unsigned
name|int
name|base_regno
init|=
name|REGNO
argument_list|(
name|base
argument_list|)
decl_stmt|;
if|if
condition|(
name|base_regno
operator|==
name|ui
condition|)
comment|/* register set from itself */
name|reg_base_value
index|[
name|ui
index|]
operator|=
literal|0
expr_stmt|;
else|else
name|reg_base_value
index|[
name|ui
index|]
operator|=
name|reg_base_value
index|[
name|base_regno
index|]
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
name|changed
operator|&&
name|pass
operator|<
name|MAX_ALIAS_LOOP_PASSES
condition|)
do|;
comment|/* Clean up.  */
name|free
argument_list|(
name|new_reg_base_value
argument_list|)
expr_stmt|;
name|new_reg_base_value
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|reg_seen
argument_list|)
expr_stmt|;
name|reg_seen
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|end_alias_analysis
parameter_list|()
block|{
name|free
argument_list|(
name|reg_known_value
operator|+
name|FIRST_PSEUDO_REGISTER
argument_list|)
expr_stmt|;
name|reg_known_value
operator|=
literal|0
expr_stmt|;
name|reg_known_value_size
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|reg_known_equiv_p
operator|+
name|FIRST_PSEUDO_REGISTER
argument_list|)
expr_stmt|;
name|reg_known_equiv_p
operator|=
literal|0
expr_stmt|;
name|reg_base_value
operator|=
literal|0
expr_stmt|;
name|reg_base_value_size
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|alias_invariant
condition|)
block|{
name|free
argument_list|(
name|alias_invariant
argument_list|)
expr_stmt|;
name|alias_invariant
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_include
include|#
directive|include
file|"gt-alias.h"
end_include

end_unit

