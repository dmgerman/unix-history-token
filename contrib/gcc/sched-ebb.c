begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Instruction scheduling pass.    Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.    Contributed by Michael Tiemann (tiemann@cygnus.com) Enhanced by,    and currently maintained by, Jim Wilson (wilson@cygnus.com)  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_escape
end_escape

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"insn-attr.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"cfglayout.h"
end_include

begin_include
include|#
directive|include
file|"params.h"
end_include

begin_include
include|#
directive|include
file|"sched-int.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_escape
end_escape

begin_comment
comment|/* The number of insns scheduled so far.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|sched_n_insns
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of insns to be scheduled in total.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|n_insns
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set of blocks, that already have their dependencies calculated.  */
end_comment

begin_decl_stmt
specifier|static
name|bitmap_head
name|dont_calc_deps
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set of basic blocks, that are ebb heads of tails respectively.  */
end_comment

begin_decl_stmt
specifier|static
name|bitmap_head
name|ebb_head
decl_stmt|,
name|ebb_tail
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Last basic block in current ebb.  */
end_comment

begin_decl_stmt
specifier|static
name|basic_block
name|last_bb
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Implementations of the sched_info functions for region scheduling.  */
end_comment

begin_function_decl
specifier|static
name|void
name|init_ready_list
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|begin_schedule_ready
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|schedule_more_p
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|ebb_print_insn
parameter_list|(
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rank
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|contributes_to_priority
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|compute_jump_reg_dependencies
parameter_list|(
name|rtx
parameter_list|,
name|regset
parameter_list|,
name|regset
parameter_list|,
name|regset
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|basic_block
name|earliest_block_with_similiar_load
parameter_list|(
name|basic_block
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_deps_for_risky_insns
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|basic_block
name|schedule_ebb
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_remove_insn
parameter_list|(
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_block1
parameter_list|(
name|basic_block
parameter_list|,
name|basic_block
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|basic_block
name|advance_target_bb
parameter_list|(
name|basic_block
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fix_recovery_cfg
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
end_ifdef

begin_function_decl
specifier|static
name|int
name|ebb_head_or_leaf_p
parameter_list|(
name|basic_block
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Return nonzero if there are more insns that should be scheduled.  */
end_comment

begin_function
specifier|static
name|int
name|schedule_more_p
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|sched_n_insns
operator|<
name|n_insns
return|;
block|}
end_function

begin_comment
comment|/* Add all insns that are initially ready to the ready list READY.  Called    once before scheduling a set of insns.  */
end_comment

begin_function
specifier|static
name|void
name|init_ready_list
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|n
init|=
literal|0
decl_stmt|;
name|rtx
name|prev_head
init|=
name|current_sched_info
operator|->
name|prev_head
decl_stmt|;
name|rtx
name|next_tail
init|=
name|current_sched_info
operator|->
name|next_tail
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|sched_n_insns
operator|=
literal|0
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Print debugging information.  */
block|if (sched_verbose>= 5)     debug_dependencies ();
endif|#
directive|endif
comment|/* Initialize ready list with all 'ready' insns in target block.      Count number of insns in the target block being scheduled.  */
for|for
control|(
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|prev_head
argument_list|)
init|;
name|insn
operator|!=
name|next_tail
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|try_ready
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|n
operator|++
expr_stmt|;
block|}
name|gcc_assert
argument_list|(
name|n
operator|==
name|n_insns
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* INSN is being scheduled after LAST.  Update counters.  */
end_comment

begin_function
specifier|static
name|void
name|begin_schedule_ready
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|rtx
name|last
parameter_list|)
block|{
name|sched_n_insns
operator|++
expr_stmt|;
if|if
condition|(
name|BLOCK_FOR_INSN
argument_list|(
name|insn
argument_list|)
operator|==
name|last_bb
comment|/* INSN is a jump in the last block, ...  */
operator|&&
name|control_flow_insn_p
argument_list|(
name|insn
argument_list|)
comment|/* that is going to be moved over some instructions.  */
operator|&&
name|last
operator|!=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
comment|/* An obscure special case, where we do have partially dead 	 instruction scheduled after last control flow instruction. 	 In this case we can create new basic block.  It is 	 always exactly one basic block last in the sequence.  */
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|last_bb->succs
argument_list|)
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
condition|)
break|break;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
name|gcc_assert
argument_list|(
operator|!
name|e
operator|||
operator|!
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_COMPLEX
operator|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|BLOCK_FOR_INSN
argument_list|(
name|insn
argument_list|)
operator|==
name|last_bb
operator|&&
operator|!
name|IS_SPECULATION_CHECK_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|BB_HEAD
argument_list|(
name|last_bb
argument_list|)
operator|!=
name|insn
operator|&&
name|BB_END
argument_list|(
name|last_bb
argument_list|)
operator|==
name|insn
argument_list|)
expr_stmt|;
block|{
name|rtx
name|x
decl_stmt|;
name|x
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
condition|)
name|gcc_assert
argument_list|(
name|NOTE_P
argument_list|(
name|x
argument_list|)
operator|||
name|LABEL_P
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|gcc_assert
argument_list|(
name|BARRIER_P
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|e
condition|)
block|{
name|bb
operator|=
name|split_edge
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|NOTE_INSN_BASIC_BLOCK_P
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Create an empty unreachable block after the INSN.  */
name|bb
operator|=
name|create_basic_block
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|last_bb
argument_list|)
expr_stmt|;
comment|/* split_edge () creates BB before E->DEST.  Keep in mind, that 	 this operation extends scheduling region till the end of BB. 	 Hence, we need to shift NEXT_TAIL, so haifa-sched.c won't go out 	 of the scheduling region.  */
name|current_sched_info
operator|->
name|next_tail
operator|=
name|NEXT_INSN
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|current_sched_info
operator|->
name|next_tail
argument_list|)
expr_stmt|;
name|add_block
argument_list|(
name|bb
argument_list|,
name|last_bb
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|last_bb
operator|==
name|bb
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return a string that contains the insn uid and optionally anything else    necessary to identify this insn in an output.  It's valid to use a    static buffer for this.  The ALIGNED parameter should cause the string    to be formatted so that multiple output lines will line up nicely.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|ebb_print_insn
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|int
name|aligned
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
specifier|static
name|char
name|tmp
index|[
literal|80
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"%4d"
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|tmp
return|;
block|}
end_function

begin_comment
comment|/* Compare priority of two insns.  Return a positive number if the second    insn is to be preferred for scheduling, and a negative one if the first    is to be preferred.  Zero if they are equally good.  */
end_comment

begin_function
specifier|static
name|int
name|rank
parameter_list|(
name|rtx
name|insn1
parameter_list|,
name|rtx
name|insn2
parameter_list|)
block|{
name|basic_block
name|bb1
init|=
name|BLOCK_FOR_INSN
argument_list|(
name|insn1
argument_list|)
decl_stmt|;
name|basic_block
name|bb2
init|=
name|BLOCK_FOR_INSN
argument_list|(
name|insn2
argument_list|)
decl_stmt|;
if|if
condition|(
name|bb1
operator|->
name|count
operator|>
name|bb2
operator|->
name|count
operator|||
name|bb1
operator|->
name|frequency
operator|>
name|bb2
operator|->
name|frequency
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|bb1
operator|->
name|count
operator|<
name|bb2
operator|->
name|count
operator|||
name|bb1
operator|->
name|frequency
operator|<
name|bb2
operator|->
name|frequency
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* NEXT is an instruction that depends on INSN (a backward dependence);    return nonzero if we should include this dependence in priority    calculations.  */
end_comment

begin_function
specifier|static
name|int
name|contributes_to_priority
parameter_list|(
name|rtx
name|next
name|ATTRIBUTE_UNUSED
parameter_list|,
name|rtx
name|insn
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* INSN is a JUMP_INSN, COND_SET is the set of registers that are     conditionally set before INSN.  Store the set of registers that     must be considered as used by this jump in USED and that of     registers that must be considered as set in SET.  */
end_comment

begin_function
specifier|static
name|void
name|compute_jump_reg_dependencies
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|regset
name|cond_set
parameter_list|,
name|regset
name|used
parameter_list|,
name|regset
name|set
parameter_list|)
block|{
name|basic_block
name|b
init|=
name|BLOCK_FOR_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|b->succs
argument_list|)
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
condition|)
comment|/* The jump may be a by-product of a branch that has been merged 	 in the main codepath after being conditionalized.  Therefore 	 it may guard the fallthrough block from using a value that has 	 conditionally overwritten that of the main codepath.  So we 	 consider that it restores the value of the main codepath.  */
name|bitmap_and
argument_list|(
name|set
argument_list|,
name|glat_start
index|[
name|e
operator|->
name|dest
operator|->
name|index
index|]
argument_list|,
name|cond_set
argument_list|)
expr_stmt|;
else|else
name|bitmap_ior_into
argument_list|(
name|used
argument_list|,
name|glat_start
index|[
name|e
operator|->
name|dest
operator|->
name|index
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Used in schedule_insns to initialize current_sched_info for scheduling    regions (or single basic blocks).  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|sched_info
name|ebb_sched_info
init|=
block|{
name|init_ready_list
block|,
name|NULL
block|,
name|schedule_more_p
block|,
name|NULL
block|,
name|rank
block|,
name|ebb_print_insn
block|,
name|contributes_to_priority
block|,
name|compute_jump_reg_dependencies
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
name|add_remove_insn
block|,
name|begin_schedule_ready
block|,
name|add_block1
block|,
name|advance_target_bb
block|,
name|fix_recovery_cfg
block|,
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
name|ebb_head_or_leaf_p
block|,
endif|#
directive|endif
comment|/* We need to DETACH_LIVE_INFO to be able to create new basic blocks.      See begin_schedule_ready ().  */
name|SCHED_EBB
operator||
name|USE_GLAT
operator||
name|DETACH_LIFE_INFO
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Returns the earliest block in EBB currently being processed where a    "similar load" 'insn2' is found, and hence LOAD_INSN can move    speculatively into the found block.  All the following must hold:     (1) both loads have 1 base register (PFREE_CANDIDATEs).    (2) load_insn and load2 have a def-use dependence upon    the same insn 'insn1'.     From all these we can conclude that the two loads access memory    addresses that differ at most by a constant, and hence if moving    load_insn would cause an exception, it would have been caused by    load2 anyhow.     The function uses list (given by LAST_BLOCK) of already processed    blocks in EBB.  The list is formed in `add_deps_for_risky_insns'.  */
end_comment

begin_function
specifier|static
name|basic_block
name|earliest_block_with_similiar_load
parameter_list|(
name|basic_block
name|last_block
parameter_list|,
name|rtx
name|load_insn
parameter_list|)
block|{
name|rtx
name|back_link
decl_stmt|;
name|basic_block
name|bb
decl_stmt|,
name|earliest_block
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|back_link
operator|=
name|LOG_LINKS
argument_list|(
name|load_insn
argument_list|)
init|;
name|back_link
condition|;
name|back_link
operator|=
name|XEXP
argument_list|(
name|back_link
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|rtx
name|insn1
init|=
name|XEXP
argument_list|(
name|back_link
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|back_link
argument_list|)
operator|==
name|VOIDmode
condition|)
block|{
comment|/* Found a DEF-USE dependence (insn1, load_insn).  */
name|rtx
name|fore_link
decl_stmt|;
for|for
control|(
name|fore_link
operator|=
name|INSN_DEPEND
argument_list|(
name|insn1
argument_list|)
init|;
name|fore_link
condition|;
name|fore_link
operator|=
name|XEXP
argument_list|(
name|fore_link
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|rtx
name|insn2
init|=
name|XEXP
argument_list|(
name|fore_link
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|basic_block
name|insn2_block
init|=
name|BLOCK_FOR_INSN
argument_list|(
name|insn2
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|fore_link
argument_list|)
operator|==
name|VOIDmode
condition|)
block|{
if|if
condition|(
name|earliest_block
operator|!=
name|NULL
operator|&&
name|earliest_block
operator|->
name|index
operator|<
name|insn2_block
operator|->
name|index
condition|)
continue|continue;
comment|/* Found a DEF-USE dependence (insn1, insn2).  */
if|if
condition|(
name|haifa_classify_insn
argument_list|(
name|insn2
argument_list|)
operator|!=
name|PFREE_CANDIDATE
condition|)
comment|/* insn2 not guaranteed to be a 1 base reg load.  */
continue|continue;
for|for
control|(
name|bb
operator|=
name|last_block
init|;
name|bb
condition|;
name|bb
operator|=
name|bb
operator|->
name|aux
control|)
if|if
condition|(
name|insn2_block
operator|==
name|bb
condition|)
break|break;
if|if
condition|(
operator|!
name|bb
condition|)
comment|/* insn2 is the similar load.  */
name|earliest_block
operator|=
name|insn2_block
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|earliest_block
return|;
block|}
end_function

begin_comment
comment|/* The following function adds dependencies between jumps and risky    insns in given ebb.  */
end_comment

begin_function
specifier|static
name|void
name|add_deps_for_risky_insns
parameter_list|(
name|rtx
name|head
parameter_list|,
name|rtx
name|tail
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|,
name|prev
decl_stmt|;
name|int
name|class
decl_stmt|;
name|rtx
name|last_jump
init|=
name|NULL_RTX
decl_stmt|;
name|rtx
name|next_tail
init|=
name|NEXT_INSN
argument_list|(
name|tail
argument_list|)
decl_stmt|;
name|basic_block
name|last_block
init|=
name|NULL
decl_stmt|,
name|bb
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|head
init|;
name|insn
operator|!=
name|next_tail
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|control_flow_insn_p
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|bb
operator|=
name|BLOCK_FOR_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|bb
operator|->
name|aux
operator|=
name|last_block
expr_stmt|;
name|last_block
operator|=
name|bb
expr_stmt|;
name|last_jump
operator|=
name|insn
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|last_jump
operator|!=
name|NULL_RTX
condition|)
block|{
name|class
operator|=
name|haifa_classify_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|prev
operator|=
name|last_jump
expr_stmt|;
switch|switch
condition|(
name|class
condition|)
block|{
case|case
name|PFREE_CANDIDATE
case|:
if|if
condition|(
name|flag_schedule_speculative_load
condition|)
block|{
name|bb
operator|=
name|earliest_block_with_similiar_load
argument_list|(
name|last_block
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|bb
condition|)
block|{
name|bb
operator|=
name|bb
operator|->
name|aux
expr_stmt|;
if|if
condition|(
operator|!
name|bb
condition|)
break|break;
name|prev
operator|=
name|BB_END
argument_list|(
name|bb
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Fall through.  */
case|case
name|TRAP_RISKY
case|:
case|case
name|IRISKY
case|:
case|case
name|PRISKY_CANDIDATE
case|:
comment|/* ??? We could implement better checking PRISKY_CANDIDATEs 	       analogous to sched-rgn.c.  */
comment|/* We can not change the mode of the backward 	       dependency because REG_DEP_ANTI has the lowest 	       rank.  */
if|if
condition|(
operator|!
name|sched_insns_conditions_mutex_p
argument_list|(
name|insn
argument_list|,
name|prev
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|current_sched_info
operator|->
name|flags
operator|&
name|DO_SPECULATION
operator|)
condition|)
block|{
name|enum
name|DEPS_ADJUST_RESULT
name|res
decl_stmt|;
name|res
operator|=
name|add_or_update_back_dep
argument_list|(
name|insn
argument_list|,
name|prev
argument_list|,
name|REG_DEP_ANTI
argument_list|,
name|DEP_ANTI
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|DEP_CREATED
condition|)
name|add_forw_dep
argument_list|(
name|insn
argument_list|,
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|gcc_assert
argument_list|(
name|res
operator|!=
name|DEP_CHANGED
argument_list|)
expr_stmt|;
block|}
else|else
name|add_or_update_back_forw_dep
argument_list|(
name|insn
argument_list|,
name|prev
argument_list|,
name|REG_DEP_ANTI
argument_list|,
name|set_dep_weak
argument_list|(
name|DEP_ANTI
argument_list|,
name|BEGIN_CONTROL
argument_list|,
name|MAX_DEP_WEAK
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
block|}
comment|/* Maintain the invariant that bb->aux is clear after use.  */
while|while
condition|(
name|last_block
condition|)
block|{
name|bb
operator|=
name|last_block
operator|->
name|aux
expr_stmt|;
name|last_block
operator|->
name|aux
operator|=
name|NULL
expr_stmt|;
name|last_block
operator|=
name|bb
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Schedule a single extended basic block, defined by the boundaries HEAD    and TAIL.  */
end_comment

begin_function
specifier|static
name|basic_block
name|schedule_ebb
parameter_list|(
name|rtx
name|head
parameter_list|,
name|rtx
name|tail
parameter_list|)
block|{
name|basic_block
name|first_bb
decl_stmt|,
name|target_bb
decl_stmt|;
name|struct
name|deps
name|tmp_deps
decl_stmt|;
name|first_bb
operator|=
name|BLOCK_FOR_INSN
argument_list|(
name|head
argument_list|)
expr_stmt|;
name|last_bb
operator|=
name|BLOCK_FOR_INSN
argument_list|(
name|tail
argument_list|)
expr_stmt|;
if|if
condition|(
name|no_real_insns_p
argument_list|(
name|head
argument_list|,
name|tail
argument_list|)
condition|)
return|return
name|BLOCK_FOR_INSN
argument_list|(
name|tail
argument_list|)
return|;
name|gcc_assert
argument_list|(
name|INSN_P
argument_list|(
name|head
argument_list|)
operator|&&
name|INSN_P
argument_list|(
name|tail
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bitmap_bit_p
argument_list|(
operator|&
name|dont_calc_deps
argument_list|,
name|first_bb
operator|->
name|index
argument_list|)
condition|)
block|{
name|init_deps_global
argument_list|()
expr_stmt|;
comment|/* Compute LOG_LINKS.  */
name|init_deps
argument_list|(
operator|&
name|tmp_deps
argument_list|)
expr_stmt|;
name|sched_analyze
argument_list|(
operator|&
name|tmp_deps
argument_list|,
name|head
argument_list|,
name|tail
argument_list|)
expr_stmt|;
name|free_deps
argument_list|(
operator|&
name|tmp_deps
argument_list|)
expr_stmt|;
comment|/* Compute INSN_DEPEND.  */
name|compute_forward_dependences
argument_list|(
name|head
argument_list|,
name|tail
argument_list|)
expr_stmt|;
name|add_deps_for_risky_insns
argument_list|(
name|head
argument_list|,
name|tail
argument_list|)
expr_stmt|;
if|if
condition|(
name|targetm
operator|.
name|sched
operator|.
name|dependencies_evaluation_hook
condition|)
name|targetm
operator|.
name|sched
operator|.
name|dependencies_evaluation_hook
argument_list|(
name|head
argument_list|,
name|tail
argument_list|)
expr_stmt|;
name|finish_deps_global
argument_list|()
expr_stmt|;
block|}
else|else
comment|/* Only recovery blocks can have their dependencies already calculated,        and they always are single block ebbs.  */
name|gcc_assert
argument_list|(
name|first_bb
operator|==
name|last_bb
argument_list|)
expr_stmt|;
comment|/* Set priorities.  */
name|current_sched_info
operator|->
name|sched_max_insns_priority
operator|=
literal|0
expr_stmt|;
name|n_insns
operator|=
name|set_priorities
argument_list|(
name|head
argument_list|,
name|tail
argument_list|)
expr_stmt|;
name|current_sched_info
operator|->
name|sched_max_insns_priority
operator|++
expr_stmt|;
name|current_sched_info
operator|->
name|prev_head
operator|=
name|PREV_INSN
argument_list|(
name|head
argument_list|)
expr_stmt|;
name|current_sched_info
operator|->
name|next_tail
operator|=
name|NEXT_INSN
argument_list|(
name|tail
argument_list|)
expr_stmt|;
if|if
condition|(
name|write_symbols
operator|!=
name|NO_DEBUG
condition|)
block|{
name|save_line_notes
argument_list|(
name|first_bb
operator|->
name|index
argument_list|,
name|head
argument_list|,
name|tail
argument_list|)
expr_stmt|;
name|rm_line_notes
argument_list|(
name|head
argument_list|,
name|tail
argument_list|)
expr_stmt|;
block|}
comment|/* rm_other_notes only removes notes which are _inside_ the      block---that is, it won't remove notes before the first real insn      or after the last real insn of the block.  So if the first insn      has a REG_SAVE_NOTE which would otherwise be emitted before the      insn, it is redundant with the note before the start of the      block, and so we have to take it out.  */
if|if
condition|(
name|INSN_P
argument_list|(
name|head
argument_list|)
condition|)
block|{
name|rtx
name|note
decl_stmt|;
for|for
control|(
name|note
operator|=
name|REG_NOTES
argument_list|(
name|head
argument_list|)
init|;
name|note
condition|;
name|note
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
operator|==
name|REG_SAVE_NOTE
condition|)
name|remove_note
argument_list|(
name|head
argument_list|,
name|note
argument_list|)
expr_stmt|;
block|}
comment|/* Remove remaining note insns from the block, save them in      note_list.  These notes are restored at the end of      schedule_block ().  */
name|rm_other_notes
argument_list|(
name|head
argument_list|,
name|tail
argument_list|)
expr_stmt|;
name|unlink_bb_notes
argument_list|(
name|first_bb
argument_list|,
name|last_bb
argument_list|)
expr_stmt|;
name|current_sched_info
operator|->
name|queue_must_finish_empty
operator|=
literal|1
expr_stmt|;
name|target_bb
operator|=
name|first_bb
expr_stmt|;
name|schedule_block
argument_list|(
operator|&
name|target_bb
argument_list|,
name|n_insns
argument_list|)
expr_stmt|;
comment|/* We might pack all instructions into fewer blocks,      so we may made some of them empty.  Can't assert (b == last_bb).  */
comment|/* Sanity check: verify that all region insns were scheduled.  */
name|gcc_assert
argument_list|(
name|sched_n_insns
operator|==
name|n_insns
argument_list|)
expr_stmt|;
name|head
operator|=
name|current_sched_info
operator|->
name|head
expr_stmt|;
name|tail
operator|=
name|current_sched_info
operator|->
name|tail
expr_stmt|;
if|if
condition|(
name|write_symbols
operator|!=
name|NO_DEBUG
condition|)
name|restore_line_notes
argument_list|(
name|head
argument_list|,
name|tail
argument_list|)
expr_stmt|;
if|if
condition|(
name|EDGE_COUNT
argument_list|(
name|last_bb
operator|->
name|preds
argument_list|)
operator|==
literal|0
condition|)
comment|/* LAST_BB is unreachable.  */
block|{
name|gcc_assert
argument_list|(
name|first_bb
operator|!=
name|last_bb
operator|&&
name|EDGE_COUNT
argument_list|(
name|last_bb
operator|->
name|succs
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|last_bb
operator|=
name|last_bb
operator|->
name|prev_bb
expr_stmt|;
name|delete_basic_block
argument_list|(
name|last_bb
operator|->
name|next_bb
argument_list|)
expr_stmt|;
block|}
return|return
name|last_bb
return|;
block|}
end_function

begin_comment
comment|/* The one entry point in this file.  */
end_comment

begin_function
name|void
name|schedule_ebbs
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|int
name|probability_cutoff
decl_stmt|;
name|rtx
name|tail
decl_stmt|;
name|sbitmap
name|large_region_blocks
decl_stmt|,
name|blocks
decl_stmt|;
name|int
name|any_large_regions
decl_stmt|;
if|if
condition|(
name|profile_info
operator|&&
name|flag_branch_probabilities
condition|)
name|probability_cutoff
operator|=
name|PARAM_VALUE
argument_list|(
name|TRACER_MIN_BRANCH_PROBABILITY_FEEDBACK
argument_list|)
expr_stmt|;
else|else
name|probability_cutoff
operator|=
name|PARAM_VALUE
argument_list|(
name|TRACER_MIN_BRANCH_PROBABILITY
argument_list|)
expr_stmt|;
name|probability_cutoff
operator|=
name|REG_BR_PROB_BASE
operator|/
literal|100
operator|*
name|probability_cutoff
expr_stmt|;
comment|/* Taking care of this degenerate case makes the rest of      this code simpler.  */
if|if
condition|(
name|n_basic_blocks
operator|==
name|NUM_FIXED_BLOCKS
condition|)
return|return;
comment|/* We need current_sched_info in init_dependency_caches, which is      invoked via sched_init.  */
name|current_sched_info
operator|=
operator|&
name|ebb_sched_info
expr_stmt|;
name|sched_init
argument_list|()
expr_stmt|;
name|compute_bb_for_insn
argument_list|()
expr_stmt|;
comment|/* Initialize DONT_CALC_DEPS and ebb-{start, end} markers.  */
name|bitmap_initialize
argument_list|(
operator|&
name|dont_calc_deps
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bitmap_clear
argument_list|(
operator|&
name|dont_calc_deps
argument_list|)
expr_stmt|;
name|bitmap_initialize
argument_list|(
operator|&
name|ebb_head
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bitmap_clear
argument_list|(
operator|&
name|ebb_head
argument_list|)
expr_stmt|;
name|bitmap_initialize
argument_list|(
operator|&
name|ebb_tail
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bitmap_clear
argument_list|(
operator|&
name|ebb_tail
argument_list|)
expr_stmt|;
comment|/* Schedule every region in the subroutine.  */
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|rtx
name|head
init|=
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|tail
operator|=
name|BB_END
argument_list|(
name|bb
argument_list|)
expr_stmt|;
if|if
condition|(
name|bb
operator|->
name|next_bb
operator|==
name|EXIT_BLOCK_PTR
operator|||
name|LABEL_P
argument_list|(
name|BB_HEAD
argument_list|(
name|bb
operator|->
name|next_bb
argument_list|)
argument_list|)
condition|)
break|break;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
if|if
condition|(
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
operator|)
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
operator|!
name|e
condition|)
break|break;
if|if
condition|(
name|e
operator|->
name|probability
operator|<=
name|probability_cutoff
condition|)
break|break;
name|bb
operator|=
name|bb
operator|->
name|next_bb
expr_stmt|;
block|}
comment|/* Blah.  We should fix the rest of the code not to get confused by 	 a note or two.  */
while|while
condition|(
name|head
operator|!=
name|tail
condition|)
block|{
if|if
condition|(
name|NOTE_P
argument_list|(
name|head
argument_list|)
condition|)
name|head
operator|=
name|NEXT_INSN
argument_list|(
name|head
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|NOTE_P
argument_list|(
name|tail
argument_list|)
condition|)
name|tail
operator|=
name|PREV_INSN
argument_list|(
name|tail
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|LABEL_P
argument_list|(
name|head
argument_list|)
condition|)
name|head
operator|=
name|NEXT_INSN
argument_list|(
name|head
argument_list|)
expr_stmt|;
else|else
break|break;
block|}
name|bitmap_set_bit
argument_list|(
operator|&
name|ebb_head
argument_list|,
name|BLOCK_NUM
argument_list|(
name|head
argument_list|)
argument_list|)
expr_stmt|;
name|bb
operator|=
name|schedule_ebb
argument_list|(
name|head
argument_list|,
name|tail
argument_list|)
expr_stmt|;
name|bitmap_set_bit
argument_list|(
operator|&
name|ebb_tail
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
name|bitmap_clear
argument_list|(
operator|&
name|dont_calc_deps
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|current_sched_info
operator|->
name|flags
operator|&
name|DETACH_LIFE_INFO
argument_list|)
expr_stmt|;
comment|/* We can create new basic blocks during scheduling, and      attach_life_info () will create regsets for them      (along with attaching existing info back).  */
name|attach_life_info
argument_list|()
expr_stmt|;
comment|/* Updating register live information.  */
name|allocate_reg_life_data
argument_list|()
expr_stmt|;
name|any_large_regions
operator|=
literal|0
expr_stmt|;
name|large_region_blocks
operator|=
name|sbitmap_alloc
argument_list|(
name|last_basic_block
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|large_region_blocks
argument_list|)
expr_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
name|SET_BIT
argument_list|(
name|large_region_blocks
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|blocks
operator|=
name|sbitmap_alloc
argument_list|(
name|last_basic_block
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|blocks
argument_list|)
expr_stmt|;
comment|/* Update life information.  For regions consisting of multiple blocks      we've possibly done interblock scheduling that affects global liveness.      For regions consisting of single blocks we need to do only local      liveness.  */
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|int
name|bbi
decl_stmt|;
name|bbi
operator|=
name|bb
operator|->
name|index
expr_stmt|;
if|if
condition|(
operator|!
name|bitmap_bit_p
argument_list|(
operator|&
name|ebb_head
argument_list|,
name|bbi
argument_list|)
operator|||
operator|!
name|bitmap_bit_p
argument_list|(
operator|&
name|ebb_tail
argument_list|,
name|bbi
argument_list|)
comment|/* New blocks (e.g. recovery blocks) should be processed 	     as parts of large regions.  */
operator|||
operator|!
name|glat_start
index|[
name|bbi
index|]
condition|)
name|any_large_regions
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|SET_BIT
argument_list|(
name|blocks
argument_list|,
name|bbi
argument_list|)
expr_stmt|;
name|RESET_BIT
argument_list|(
name|large_region_blocks
argument_list|,
name|bbi
argument_list|)
expr_stmt|;
block|}
block|}
name|update_life_info
argument_list|(
name|blocks
argument_list|,
name|UPDATE_LIFE_LOCAL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sbitmap_free
argument_list|(
name|blocks
argument_list|)
expr_stmt|;
if|if
condition|(
name|any_large_regions
condition|)
block|{
name|update_life_info
argument_list|(
name|large_region_blocks
argument_list|,
name|UPDATE_LIFE_GLOBAL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
comment|/* !!! We can't check reg_live_info here because of the fact, 	 that destination registers of COND_EXEC's may be dead 	 before scheduling (while they should be alive).  Don't know why.  */
comment|/*check_reg_live (true);*/
endif|#
directive|endif
block|}
name|sbitmap_free
argument_list|(
name|large_region_blocks
argument_list|)
expr_stmt|;
name|bitmap_clear
argument_list|(
operator|&
name|ebb_head
argument_list|)
expr_stmt|;
name|bitmap_clear
argument_list|(
operator|&
name|ebb_tail
argument_list|)
expr_stmt|;
comment|/* Reposition the prologue and epilogue notes in case we moved the      prologue/epilogue insns.  */
if|if
condition|(
name|reload_completed
condition|)
name|reposition_prologue_and_epilogue_notes
argument_list|(
name|get_insns
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|write_symbols
operator|!=
name|NO_DEBUG
condition|)
name|rm_redundant_line_notes
argument_list|()
expr_stmt|;
name|sched_finish
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* INSN has been added to/removed from current ebb.  */
end_comment

begin_function
specifier|static
name|void
name|add_remove_insn
parameter_list|(
name|rtx
name|insn
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|remove_p
parameter_list|)
block|{
if|if
condition|(
operator|!
name|remove_p
condition|)
name|n_insns
operator|++
expr_stmt|;
else|else
name|n_insns
operator|--
expr_stmt|;
block|}
end_function

begin_comment
comment|/* BB was added to ebb after AFTER.  */
end_comment

begin_function
specifier|static
name|void
name|add_block1
parameter_list|(
name|basic_block
name|bb
parameter_list|,
name|basic_block
name|after
parameter_list|)
block|{
comment|/* Recovery blocks are always bounded by BARRIERS,       therefore, they always form single block EBB,      therefore, we can use rec->index to identify such EBBs.  */
if|if
condition|(
name|after
operator|==
name|EXIT_BLOCK_PTR
condition|)
name|bitmap_set_bit
argument_list|(
operator|&
name|dont_calc_deps
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|after
operator|==
name|last_bb
condition|)
name|last_bb
operator|=
name|bb
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return next block in ebb chain.  For parameter meaning please refer to    sched-int.h: struct sched_info: advance_target_bb.  */
end_comment

begin_function
specifier|static
name|basic_block
name|advance_target_bb
parameter_list|(
name|basic_block
name|bb
parameter_list|,
name|rtx
name|insn
parameter_list|)
block|{
if|if
condition|(
name|insn
condition|)
block|{
if|if
condition|(
name|BLOCK_FOR_INSN
argument_list|(
name|insn
argument_list|)
operator|!=
name|bb
operator|&&
name|control_flow_insn_p
argument_list|(
name|insn
argument_list|)
comment|/* We handle interblock movement of the speculation check 	     or over a speculation check in 	     haifa-sched.c: move_block_after_check ().  */
operator|&&
operator|!
name|IS_SPECULATION_BRANCHY_CHECK_P
argument_list|(
name|insn
argument_list|)
operator|&&
operator|!
name|IS_SPECULATION_BRANCHY_CHECK_P
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Assert that we don't move jumps across blocks.  */
name|gcc_assert
argument_list|(
operator|!
name|control_flow_insn_p
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
operator|&&
name|NOTE_INSN_BASIC_BLOCK_P
argument_list|(
name|BB_HEAD
argument_list|(
name|bb
operator|->
name|next_bb
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|bb
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
else|else
comment|/* Return next non empty block.  */
block|{
do|do
block|{
name|gcc_assert
argument_list|(
name|bb
operator|!=
name|last_bb
argument_list|)
expr_stmt|;
name|bb
operator|=
name|bb
operator|->
name|next_bb
expr_stmt|;
block|}
do|while
condition|(
name|bb_note
argument_list|(
name|bb
argument_list|)
operator|==
name|BB_END
argument_list|(
name|bb
argument_list|)
condition|)
do|;
return|return
name|bb
return|;
block|}
block|}
end_function

begin_comment
comment|/* Fix internal data after interblock movement of jump instruction.    For parameter meaning please refer to    sched-int.h: struct sched_info: fix_recovery_cfg.  */
end_comment

begin_function
specifier|static
name|void
name|fix_recovery_cfg
parameter_list|(
name|int
name|bbi
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|jump_bbi
parameter_list|,
name|int
name|jump_bb_nexti
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|last_bb
operator|->
name|index
operator|!=
name|bbi
argument_list|)
expr_stmt|;
if|if
condition|(
name|jump_bb_nexti
operator|==
name|last_bb
operator|->
name|index
condition|)
name|last_bb
operator|=
name|BASIC_BLOCK
argument_list|(
name|jump_bbi
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
end_ifdef

begin_comment
comment|/* Return non zero, if BB is first or last (depending of LEAF_P) block in    current ebb.  For more information please refer to    sched-int.h: struct sched_info: region_head_or_leaf_p.  */
end_comment

begin_function
specifier|static
name|int
name|ebb_head_or_leaf_p
parameter_list|(
name|basic_block
name|bb
parameter_list|,
name|int
name|leaf_p
parameter_list|)
block|{
if|if
condition|(
operator|!
name|leaf_p
condition|)
return|return
name|bitmap_bit_p
argument_list|(
operator|&
name|ebb_head
argument_list|,
name|bb
operator|->
name|index
argument_list|)
return|;
else|else
return|return
name|bitmap_bit_p
argument_list|(
operator|&
name|ebb_tail
argument_list|,
name|bb
operator|->
name|index
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ENABLE_CHECKING  */
end_comment

end_unit

