begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Instruction scheduling pass.    Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2000, 2001 Free Software Foundation, Inc.    Contributed by Michael Tiemann (tiemann@cygnus.com) Enhanced by,    and currently maintained by, Jim Wilson (wilson@cygnus.com)  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_escape
end_escape

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"insn-attr.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"cfglayout.h"
end_include

begin_include
include|#
directive|include
file|"sched-int.h"
end_include

begin_escape
end_escape

begin_comment
comment|/* The number of insns to be scheduled in total.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|target_n_insns
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of insns scheduled so far.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|sched_n_insns
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Implementations of the sched_info functions for region scheduling.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|init_ready_list
name|PARAMS
argument_list|(
operator|(
expr|struct
name|ready_list
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|can_schedule_ready_p
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|new_ready
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|schedule_more_p
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|print_insn
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|rank
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|contributes_to_priority
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|compute_jump_reg_dependencies
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|regset
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|schedule_ebb
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return nonzero if there are more insns that should be scheduled.  */
end_comment

begin_function
specifier|static
name|int
name|schedule_more_p
parameter_list|()
block|{
return|return
name|sched_n_insns
operator|<
name|target_n_insns
return|;
block|}
end_function

begin_comment
comment|/* Add all insns that are initially ready to the ready list READY.  Called    once before scheduling a set of insns.  */
end_comment

begin_function
specifier|static
name|void
name|init_ready_list
parameter_list|(
name|ready
parameter_list|)
name|struct
name|ready_list
modifier|*
name|ready
decl_stmt|;
block|{
name|rtx
name|prev_head
init|=
name|current_sched_info
operator|->
name|prev_head
decl_stmt|;
name|rtx
name|next_tail
init|=
name|current_sched_info
operator|->
name|next_tail
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|target_n_insns
operator|=
literal|0
expr_stmt|;
name|sched_n_insns
operator|=
literal|0
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Print debugging information.  */
block|if (sched_verbose>= 5)     debug_dependencies ();
endif|#
directive|endif
comment|/* Initialize ready list with all 'ready' insns in target block.      Count number of insns in the target block being scheduled.  */
for|for
control|(
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|prev_head
argument_list|)
init|;
name|insn
operator|!=
name|next_tail
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|rtx
name|next
decl_stmt|;
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
continue|continue;
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|INSN_DEP_COUNT
argument_list|(
name|insn
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|SCHED_GROUP_P
argument_list|(
name|next
argument_list|)
operator|==
literal|0
operator|||
operator|!
name|INSN_P
argument_list|(
name|next
argument_list|)
operator|)
condition|)
name|ready_add
argument_list|(
name|ready
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|SCHED_GROUP_P
argument_list|(
name|insn
argument_list|)
operator|)
condition|)
name|target_n_insns
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Called after taking INSN from the ready list.  Returns nonzero if this    insn can be scheduled, nonzero if we should silently discard it.  */
end_comment

begin_function
specifier|static
name|int
name|can_schedule_ready_p
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|sched_n_insns
operator|++
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Called after INSN has all its dependencies resolved.  Return nonzero    if it should be moved to the ready list or the queue, or zero if we    should silently discard it.  */
end_comment

begin_function
specifier|static
name|int
name|new_ready
parameter_list|(
name|next
parameter_list|)
name|rtx
name|next
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return a string that contains the insn uid and optionally anything else    necessary to identify this insn in an output.  It's valid to use a    static buffer for this.  The ALIGNED parameter should cause the string    to be formatted so that multiple output lines will line up nicely.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|print_insn
parameter_list|(
name|insn
parameter_list|,
name|aligned
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|int
name|aligned
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
specifier|static
name|char
name|tmp
index|[
literal|80
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"%4d"
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|tmp
return|;
block|}
end_function

begin_comment
comment|/* Compare priority of two insns.  Return a positive number if the second    insn is to be preferred for scheduling, and a negative one if the first    is to be preferred.  Zero if they are equally good.  */
end_comment

begin_function
specifier|static
name|int
name|rank
parameter_list|(
name|insn1
parameter_list|,
name|insn2
parameter_list|)
name|rtx
name|insn1
name|ATTRIBUTE_UNUSED
decl_stmt|,
name|insn2
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* NEXT is an instruction that depends on INSN (a backward dependence);    return nonzero if we should include this dependence in priority    calculations.  */
end_comment

begin_function
specifier|static
name|int
name|contributes_to_priority
parameter_list|(
name|next
parameter_list|,
name|insn
parameter_list|)
name|rtx
name|next
name|ATTRIBUTE_UNUSED
decl_stmt|,
name|insn
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* INSN is a JUMP_INSN.  Store the set of registers that must be considered    to be set by this jump in SET.  */
end_comment

begin_function
specifier|static
name|void
name|compute_jump_reg_dependencies
parameter_list|(
name|insn
parameter_list|,
name|set
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|regset
name|set
decl_stmt|;
block|{
name|basic_block
name|b
init|=
name|BLOCK_FOR_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|edge
name|e
decl_stmt|;
for|for
control|(
name|e
operator|=
name|b
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
if|if
condition|(
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
operator|)
operator|==
literal|0
condition|)
block|{
name|bitmap_operation
argument_list|(
name|set
argument_list|,
name|set
argument_list|,
name|e
operator|->
name|dest
operator|->
name|global_live_at_start
argument_list|,
name|BITMAP_IOR
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Used in schedule_insns to initialize current_sched_info for scheduling    regions (or single basic blocks).  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|sched_info
name|ebb_sched_info
init|=
block|{
name|init_ready_list
block|,
name|can_schedule_ready_p
block|,
name|schedule_more_p
block|,
name|new_ready
block|,
name|rank
block|,
name|print_insn
block|,
name|contributes_to_priority
block|,
name|compute_jump_reg_dependencies
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Schedule a single extended basic block, defined by the boundaries HEAD    and TAIL.  */
end_comment

begin_function
specifier|static
name|void
name|schedule_ebb
parameter_list|(
name|head
parameter_list|,
name|tail
parameter_list|)
name|rtx
name|head
decl_stmt|,
name|tail
decl_stmt|;
block|{
name|int
name|n_insns
decl_stmt|;
name|struct
name|deps
name|tmp_deps
decl_stmt|;
if|if
condition|(
name|no_real_insns_p
argument_list|(
name|head
argument_list|,
name|tail
argument_list|)
condition|)
return|return;
name|init_deps_global
argument_list|()
expr_stmt|;
comment|/* Compute LOG_LINKS.  */
name|init_deps
argument_list|(
operator|&
name|tmp_deps
argument_list|)
expr_stmt|;
name|sched_analyze
argument_list|(
operator|&
name|tmp_deps
argument_list|,
name|head
argument_list|,
name|tail
argument_list|)
expr_stmt|;
name|free_deps
argument_list|(
operator|&
name|tmp_deps
argument_list|)
expr_stmt|;
comment|/* Compute INSN_DEPEND.  */
name|compute_forward_dependences
argument_list|(
name|head
argument_list|,
name|tail
argument_list|)
expr_stmt|;
comment|/* Set priorities.  */
name|n_insns
operator|=
name|set_priorities
argument_list|(
name|head
argument_list|,
name|tail
argument_list|)
expr_stmt|;
name|current_sched_info
operator|->
name|prev_head
operator|=
name|PREV_INSN
argument_list|(
name|head
argument_list|)
expr_stmt|;
name|current_sched_info
operator|->
name|next_tail
operator|=
name|NEXT_INSN
argument_list|(
name|tail
argument_list|)
expr_stmt|;
if|if
condition|(
name|write_symbols
operator|!=
name|NO_DEBUG
condition|)
block|{
name|save_line_notes
argument_list|(
literal|0
argument_list|,
name|head
argument_list|,
name|tail
argument_list|)
expr_stmt|;
name|rm_line_notes
argument_list|(
name|head
argument_list|,
name|tail
argument_list|)
expr_stmt|;
block|}
comment|/* rm_other_notes only removes notes which are _inside_ the      block---that is, it won't remove notes before the first real insn      or after the last real insn of the block.  So if the first insn      has a REG_SAVE_NOTE which would otherwise be emitted before the      insn, it is redundant with the note before the start of the      block, and so we have to take it out.  */
if|if
condition|(
name|INSN_P
argument_list|(
name|head
argument_list|)
condition|)
block|{
name|rtx
name|note
decl_stmt|;
for|for
control|(
name|note
operator|=
name|REG_NOTES
argument_list|(
name|head
argument_list|)
init|;
name|note
condition|;
name|note
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
operator|==
name|REG_SAVE_NOTE
condition|)
block|{
name|remove_note
argument_list|(
name|head
argument_list|,
name|note
argument_list|)
expr_stmt|;
name|note
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|remove_note
argument_list|(
name|head
argument_list|,
name|note
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Remove remaining note insns from the block, save them in      note_list.  These notes are restored at the end of      schedule_block ().  */
name|rm_other_notes
argument_list|(
name|head
argument_list|,
name|tail
argument_list|)
expr_stmt|;
name|current_sched_info
operator|->
name|queue_must_finish_empty
operator|=
literal|1
expr_stmt|;
name|schedule_block
argument_list|(
operator|-
literal|1
argument_list|,
name|n_insns
argument_list|)
expr_stmt|;
comment|/* Sanity check: verify that all region insns were scheduled.  */
if|if
condition|(
name|sched_n_insns
operator|!=
name|n_insns
condition|)
name|abort
argument_list|()
expr_stmt|;
name|head
operator|=
name|current_sched_info
operator|->
name|head
expr_stmt|;
name|tail
operator|=
name|current_sched_info
operator|->
name|tail
expr_stmt|;
if|if
condition|(
name|write_symbols
operator|!=
name|NO_DEBUG
condition|)
name|restore_line_notes
argument_list|(
name|head
argument_list|,
name|tail
argument_list|)
expr_stmt|;
name|finish_deps_global
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The one entry point in this file.  DUMP_FILE is the dump file for    this pass.  */
end_comment

begin_function
name|void
name|schedule_ebbs
parameter_list|(
name|dump_file
parameter_list|)
name|FILE
modifier|*
name|dump_file
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
comment|/* Taking care of this degenerate case makes the rest of      this code simpler.  */
if|if
condition|(
name|n_basic_blocks
operator|==
literal|0
condition|)
return|return;
name|scope_to_insns_initialize
argument_list|()
expr_stmt|;
name|sched_init
argument_list|(
name|dump_file
argument_list|)
expr_stmt|;
name|current_sched_info
operator|=
operator|&
name|ebb_sched_info
expr_stmt|;
name|allocate_reg_life_data
argument_list|()
expr_stmt|;
name|compute_bb_for_insn
argument_list|(
name|get_max_uid
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Schedule every region in the subroutine.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|head
init|=
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
operator|->
name|head
decl_stmt|;
name|rtx
name|tail
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|basic_block
name|b
init|=
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|tail
operator|=
name|b
operator|->
name|end
expr_stmt|;
if|if
condition|(
name|i
operator|+
literal|1
operator|==
name|n_basic_blocks
operator|||
name|GET_CODE
argument_list|(
name|BLOCK_HEAD
argument_list|(
name|i
operator|+
literal|1
argument_list|)
argument_list|)
operator|==
name|CODE_LABEL
condition|)
break|break;
for|for
control|(
name|e
operator|=
name|b
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
if|if
condition|(
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
operator|)
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
operator|!
name|e
condition|)
break|break;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tail
argument_list|)
operator|==
name|JUMP_INSN
condition|)
block|{
name|rtx
name|x
init|=
name|find_reg_note
argument_list|(
name|tail
argument_list|,
name|REG_BR_PROB
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|x
condition|)
block|{
name|int
name|pred_val
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|pred_val
operator|>
name|REG_BR_PROB_BASE
operator|/
literal|2
condition|)
break|break;
block|}
block|}
name|i
operator|++
expr_stmt|;
block|}
comment|/* Blah.  We should fix the rest of the code not to get confused by 	 a note or two.  */
while|while
condition|(
name|head
operator|!=
name|tail
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|head
argument_list|)
operator|==
name|NOTE
condition|)
name|head
operator|=
name|NEXT_INSN
argument_list|(
name|head
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|tail
argument_list|)
operator|==
name|NOTE
condition|)
name|tail
operator|=
name|PREV_INSN
argument_list|(
name|tail
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|head
argument_list|)
operator|==
name|CODE_LABEL
condition|)
name|head
operator|=
name|NEXT_INSN
argument_list|(
name|head
argument_list|)
expr_stmt|;
else|else
break|break;
block|}
name|schedule_ebb
argument_list|(
name|head
argument_list|,
name|tail
argument_list|)
expr_stmt|;
block|}
comment|/* It doesn't make much sense to try and update life information here - we      probably messed up even the flow graph.  */
comment|/* Reposition the prologue and epilogue notes in case we moved the      prologue/epilogue insns.  */
if|if
condition|(
name|reload_completed
condition|)
name|reposition_prologue_and_epilogue_notes
argument_list|(
name|get_insns
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|write_symbols
operator|!=
name|NO_DEBUG
condition|)
name|rm_redundant_line_notes
argument_list|()
expr_stmt|;
name|scope_to_insns_finalize
argument_list|()
expr_stmt|;
name|sched_finish
argument_list|()
expr_stmt|;
block|}
end_function

end_unit

