begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Allocate registers for pseudo-registers that span basic blocks.    Copyright (C) 1987, 1988, 1991, 1994, 1996, 1997, 1998,    1999, 2000, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"machmode.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"reload.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"tree-pass.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"vecprim.h"
end_include

begin_comment
comment|/* This pass of the compiler performs global register allocation.    It assigns hard register numbers to all the pseudo registers    that were not handled in local_alloc.  Assignments are recorded    in the vector reg_renumber, not by changing the rtl code.    (Such changes are made by final).  The entry point is    the function global_alloc.     After allocation is complete, the reload pass is run as a subroutine    of this pass, so that when a pseudo reg loses its hard reg due to    spilling it is possible to make a second attempt to find a hard    reg for it.  The reload pass is independent in other respects    and it is run even when stupid register allocation is in use.     1. Assign allocation-numbers (allocnos) to the pseudo-registers    still needing allocations and to the pseudo-registers currently    allocated by local-alloc which may be spilled by reload.    Set up tables reg_allocno and allocno_reg to map    reg numbers to allocnos and vice versa.    max_allocno gets the number of allocnos in use.     2. Allocate a max_allocno by max_allocno conflict bit matrix and clear it.    Allocate a max_allocno by FIRST_PSEUDO_REGISTER conflict matrix    for conflicts between allocnos and explicit hard register use    (which includes use of pseudo-registers allocated by local_alloc).     3. For each basic block     walk forward through the block, recording which     pseudo-registers and which hardware registers are live.     Build the conflict matrix between the pseudo-registers     and another of pseudo-registers versus hardware registers.     Also record the preferred hardware registers     for each pseudo-register.     4. Sort a table of the allocnos into order of    desirability of the variables.     5. Allocate the variables in that order; each if possible into    a preferred register, else into another register.  */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Number of pseudo-registers which are candidates for allocation.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|max_allocno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by (pseudo) reg number, gives the allocno, or -1    for pseudo registers which are not to be allocated.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|reg_allocno
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|allocno
block|{
name|int
name|reg
decl_stmt|;
comment|/* Gives the number of consecutive hard registers needed by that      pseudo reg.  */
name|int
name|size
decl_stmt|;
comment|/* Number of calls crossed by each allocno.  */
name|int
name|calls_crossed
decl_stmt|;
comment|/* Number of calls that might throw crossed by each allocno.  */
name|int
name|throwing_calls_crossed
decl_stmt|;
comment|/* Number of refs to each allocno.  */
name|int
name|n_refs
decl_stmt|;
comment|/* Frequency of uses of each allocno.  */
name|int
name|freq
decl_stmt|;
comment|/* Guess at live length of each allocno.      This is actually the max of the live lengths of the regs.  */
name|int
name|live_length
decl_stmt|;
comment|/* Set of hard regs conflicting with allocno N.  */
name|HARD_REG_SET
name|hard_reg_conflicts
decl_stmt|;
comment|/* Set of hard regs preferred by allocno N.      This is used to make allocnos go into regs that are copied to or from them,      when possible, to reduce register shuffling.  */
name|HARD_REG_SET
name|hard_reg_preferences
decl_stmt|;
comment|/* Similar, but just counts register preferences made in simple copy      operations, rather than arithmetic.  These are given priority because      we can always eliminate an insn by using these, but using a register      in the above list won't always eliminate an insn.  */
name|HARD_REG_SET
name|hard_reg_copy_preferences
decl_stmt|;
comment|/* Similar to hard_reg_preferences, but includes bits for subsequent      registers when an allocno is multi-word.  The above variable is used for      allocation while this is used to build reg_someone_prefers, below.  */
name|HARD_REG_SET
name|hard_reg_full_preferences
decl_stmt|;
comment|/* Set of hard registers that some later allocno has a preference for.  */
name|HARD_REG_SET
name|regs_someone_prefers
decl_stmt|;
ifdef|#
directive|ifdef
name|STACK_REGS
comment|/* Set to true if allocno can't be allocated in the stack register.  */
name|bool
name|no_stack_reg
decl_stmt|;
endif|#
directive|endif
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|allocno
modifier|*
name|allocno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A vector of the integers from 0 to max_allocno-1,    sorted in the order of first-to-be-allocated first.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|allocno_order
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by (pseudo) reg number, gives the number of another    lower-numbered pseudo reg which can share a hard reg with this pseudo    *even if the two pseudos would otherwise appear to conflict*.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|reg_may_share
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Define the number of bits in each element of `conflicts' and what    type that element has.  We use the largest integer format on the    host machine.  */
end_comment

begin_define
define|#
directive|define
name|INT_BITS
value|HOST_BITS_PER_WIDE_INT
end_define

begin_define
define|#
directive|define
name|INT_TYPE
value|HOST_WIDE_INT
end_define

begin_comment
comment|/* max_allocno by max_allocno array of bits,    recording whether two allocno's conflict (can't go in the same    hardware register).     `conflicts' is symmetric after the call to mirror_conflicts.  */
end_comment

begin_decl_stmt
specifier|static
name|INT_TYPE
modifier|*
name|conflicts
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of ints required to hold max_allocno bits.    This is the length of a row in `conflicts'.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|allocno_row_words
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Two macros to test or store 1 in an element of `conflicts'.  */
end_comment

begin_define
define|#
directive|define
name|CONFLICTP
parameter_list|(
name|I
parameter_list|,
name|J
parameter_list|)
define|\
value|(conflicts[(I) * allocno_row_words + (unsigned) (J) / INT_BITS]	\& ((INT_TYPE) 1<< ((unsigned) (J) % INT_BITS)))
end_define

begin_comment
comment|/* For any allocno set in ALLOCNO_SET, set ALLOCNO to that allocno,    and execute CODE.  */
end_comment

begin_define
define|#
directive|define
name|EXECUTE_IF_SET_IN_ALLOCNO_SET
parameter_list|(
name|ALLOCNO_SET
parameter_list|,
name|ALLOCNO
parameter_list|,
name|CODE
parameter_list|)
define|\
value|do {									\   int i_;								\   int allocno_;								\   INT_TYPE *p_ = (ALLOCNO_SET);						\ 									\   for (i_ = allocno_row_words - 1, allocno_ = 0; i_>= 0;		\        i_--, allocno_ += INT_BITS)					\     {									\       unsigned INT_TYPE word_ = (unsigned INT_TYPE) *p_++;		\ 									\       for ((ALLOCNO) = allocno_; word_; word_>>= 1, (ALLOCNO)++)	\ 	{								\ 	  if (word_& 1)						\ 	    {CODE;}							\ 	}								\     }									\ } while (0)
end_define

begin_comment
comment|/* This doesn't work for non-GNU C due to the way CODE is macro expanded.  */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* For any allocno that conflicts with IN_ALLOCNO, set OUT_ALLOCNO to    the conflicting allocno, and execute CODE.  This macro assumes that    mirror_conflicts has been run.  */
end_comment

begin_define
define|#
directive|define
name|EXECUTE_IF_CONFLICT
parameter_list|(
name|IN_ALLOCNO
parameter_list|,
name|OUT_ALLOCNO
parameter_list|,
name|CODE
parameter_list|)
define|\
value|EXECUTE_IF_SET_IN_ALLOCNO_SET (conflicts + (IN_ALLOCNO) * allocno_row_words,\ 				 OUT_ALLOCNO, (CODE))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Set of hard regs currently live (during scan of all insns).  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
name|hard_regs_live
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set of registers that global-alloc isn't supposed to use.  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
name|no_global_alloc_regs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set of registers used so far.  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
name|regs_used_so_far
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of refs to each hard reg, as used by local alloc.    It is zero for a reg that contains global pseudos or is explicitly used.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|local_reg_n_refs
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Frequency of uses of given hard reg.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|local_reg_freq
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Guess at live length of each hard reg, as used by local alloc.    This is actually the sum of the live lengths of the specific regs.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|local_reg_live_length
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set to 1 a bit in a vector TABLE of HARD_REG_SETs, for vector    element I, and hard register number J.  */
end_comment

begin_define
define|#
directive|define
name|SET_REGBIT
parameter_list|(
name|TABLE
parameter_list|,
name|I
parameter_list|,
name|J
parameter_list|)
value|SET_HARD_REG_BIT (allocno[I].TABLE, J)
end_define

begin_comment
comment|/* Bit mask for allocnos live at current point in the scan.  */
end_comment

begin_decl_stmt
specifier|static
name|INT_TYPE
modifier|*
name|allocnos_live
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Test, set or clear bit number I in allocnos_live,    a bit vector indexed by allocno.  */
end_comment

begin_define
define|#
directive|define
name|SET_ALLOCNO_LIVE
parameter_list|(
name|I
parameter_list|)
define|\
value|(allocnos_live[(unsigned) (I) / INT_BITS]		\      |= ((INT_TYPE) 1<< ((unsigned) (I) % INT_BITS)))
end_define

begin_define
define|#
directive|define
name|CLEAR_ALLOCNO_LIVE
parameter_list|(
name|I
parameter_list|)
define|\
value|(allocnos_live[(unsigned) (I) / INT_BITS]		\&= ~((INT_TYPE) 1<< ((unsigned) (I) % INT_BITS)))
end_define

begin_comment
comment|/* This is turned off because it doesn't work right for DImode.    (And it is only used for DImode, so the other cases are worthless.)    The problem is that it isn't true that there is NO possibility of conflict;    only that there is no conflict if the two pseudos get the exact same regs.    If they were allocated with a partial overlap, there would be a conflict.    We can't safely turn off the conflict unless we have another way to    prevent the partial overlap.     Idea: change hard_reg_conflicts so that instead of recording which    hard regs the allocno may not overlap, it records where the allocno    may not start.  Change both where it is used and where it is updated.    Then there is a way to record that (reg:DI 108) may start at 10    but not at 9 or 11.  There is still the question of how to record    this semi-conflict between two pseudos.  */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Reg pairs for which conflict after the current insn    is inhibited by a REG_NO_CONFLICT note.    If the table gets full, we ignore any other notes--that is conservative.  */
end_comment

begin_define
define|#
directive|define
name|NUM_NO_CONFLICT_PAIRS
value|4
end_define

begin_comment
comment|/* Number of pairs in use in this insn.  */
end_comment

begin_endif
unit|int n_no_conflict_pairs; static struct { int allocno1, allocno2;}   no_conflict_pairs[NUM_NO_CONFLICT_PAIRS];
endif|#
directive|endif
end_endif

begin_comment
comment|/* 0 */
end_comment

begin_comment
comment|/* Record all regs that are set in any one insn.    Communication from mark_reg_{store,clobber} and global_conflicts.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
modifier|*
name|regs_set
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|n_regs_set
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* All registers that can be eliminated.  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
name|eliminable_regset
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|allocno_compare
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|global_conflicts
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mirror_conflicts
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|expand_preferences
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|prune_preferences
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|find_reg
parameter_list|(
name|int
parameter_list|,
name|HARD_REG_SET
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|record_one_conflict
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|record_conflicts
parameter_list|(
name|int
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mark_reg_store
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mark_reg_clobber
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mark_reg_conflicts
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mark_reg_death
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mark_reg_live_nc
parameter_list|(
name|int
parameter_list|,
name|enum
name|machine_mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_preference
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_conflicts
parameter_list|(
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|reg_becomes_live
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|reg_dies
parameter_list|(
name|int
parameter_list|,
name|enum
name|machine_mode
parameter_list|,
name|struct
name|insn_chain
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|allocate_bb_info
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_bb_info
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|check_earlyclobber
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mark_reg_use_for_earlyclobber_1
parameter_list|(
name|rtx
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mark_reg_use_for_earlyclobber
parameter_list|(
name|rtx
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|calculate_local_reg_bb_info
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_up_bb_rts_numbers
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rpost_cmp
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|calculate_reg_pav
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|modify_reg_pav
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|make_accurate_live_analysis
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* Perform allocation of pseudo-registers not allocated by local_alloc.     Return value is nonzero if reload failed    and we must not do any more for this function.  */
end_comment

begin_function
specifier|static
name|int
name|global_alloc
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|retval
decl_stmt|;
ifdef|#
directive|ifdef
name|ELIMINABLE_REGS
specifier|static
specifier|const
struct|struct
block|{
specifier|const
name|int
name|from
decl_stmt|,
name|to
decl_stmt|;
block|}
name|eliminables
index|[]
init|=
name|ELIMINABLE_REGS
struct|;
endif|#
directive|endif
name|int
name|need_fp
init|=
operator|(
operator|!
name|flag_omit_frame_pointer
operator|||
operator|(
name|current_function_calls_alloca
operator|&&
name|EXIT_IGNORE_STACK
operator|)
operator|||
name|FRAME_POINTER_REQUIRED
operator|)
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|make_accurate_live_analysis
argument_list|()
expr_stmt|;
name|max_allocno
operator|=
literal|0
expr_stmt|;
comment|/* A machine may have certain hard registers that      are safe to use only within a basic block.  */
name|CLEAR_HARD_REG_SET
argument_list|(
name|no_global_alloc_regs
argument_list|)
expr_stmt|;
comment|/* Build the regset of all eliminable registers and show we can't use those      that we already know won't be eliminated.  */
ifdef|#
directive|ifdef
name|ELIMINABLE_REGS
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|eliminables
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|bool
name|cannot_elim
init|=
operator|(
operator|!
name|CAN_ELIMINATE
argument_list|(
name|eliminables
index|[
name|i
index|]
operator|.
name|from
argument_list|,
name|eliminables
index|[
name|i
index|]
operator|.
name|to
argument_list|)
operator|||
operator|(
name|eliminables
index|[
name|i
index|]
operator|.
name|to
operator|==
name|STACK_POINTER_REGNUM
operator|&&
name|need_fp
operator|)
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|regs_asm_clobbered
index|[
name|eliminables
index|[
name|i
index|]
operator|.
name|from
index|]
condition|)
block|{
name|SET_HARD_REG_BIT
argument_list|(
name|eliminable_regset
argument_list|,
name|eliminables
index|[
name|i
index|]
operator|.
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
name|cannot_elim
condition|)
name|SET_HARD_REG_BIT
argument_list|(
name|no_global_alloc_regs
argument_list|,
name|eliminables
index|[
name|i
index|]
operator|.
name|from
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cannot_elim
condition|)
name|error
argument_list|(
literal|"%s cannot be used in asm here"
argument_list|,
name|reg_names
index|[
name|eliminables
index|[
name|i
index|]
operator|.
name|from
index|]
argument_list|)
expr_stmt|;
else|else
name|regs_ever_live
index|[
name|eliminables
index|[
name|i
index|]
operator|.
name|from
index|]
operator|=
literal|1
expr_stmt|;
block|}
if|#
directive|if
name|FRAME_POINTER_REGNUM
operator|!=
name|HARD_FRAME_POINTER_REGNUM
if|if
condition|(
operator|!
name|regs_asm_clobbered
index|[
name|HARD_FRAME_POINTER_REGNUM
index|]
condition|)
block|{
name|SET_HARD_REG_BIT
argument_list|(
name|eliminable_regset
argument_list|,
name|HARD_FRAME_POINTER_REGNUM
argument_list|)
expr_stmt|;
if|if
condition|(
name|need_fp
condition|)
name|SET_HARD_REG_BIT
argument_list|(
name|no_global_alloc_regs
argument_list|,
name|HARD_FRAME_POINTER_REGNUM
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|need_fp
condition|)
name|error
argument_list|(
literal|"%s cannot be used in asm here"
argument_list|,
name|reg_names
index|[
name|HARD_FRAME_POINTER_REGNUM
index|]
argument_list|)
expr_stmt|;
else|else
name|regs_ever_live
index|[
name|HARD_FRAME_POINTER_REGNUM
index|]
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
if|if
condition|(
operator|!
name|regs_asm_clobbered
index|[
name|FRAME_POINTER_REGNUM
index|]
condition|)
block|{
name|SET_HARD_REG_BIT
argument_list|(
name|eliminable_regset
argument_list|,
name|FRAME_POINTER_REGNUM
argument_list|)
expr_stmt|;
if|if
condition|(
name|need_fp
condition|)
name|SET_HARD_REG_BIT
argument_list|(
name|no_global_alloc_regs
argument_list|,
name|FRAME_POINTER_REGNUM
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|need_fp
condition|)
name|error
argument_list|(
literal|"%s cannot be used in asm here"
argument_list|,
name|reg_names
index|[
name|FRAME_POINTER_REGNUM
index|]
argument_list|)
expr_stmt|;
else|else
name|regs_ever_live
index|[
name|FRAME_POINTER_REGNUM
index|]
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* Track which registers have already been used.  Start with registers      explicitly in the rtl, then registers allocated by local register      allocation.  */
name|CLEAR_HARD_REG_SET
argument_list|(
name|regs_used_so_far
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LEAF_REGISTERS
comment|/* If we are doing the leaf function optimization, and this is a leaf      function, it means that the registers that take work to save are those      that need a register window.  So prefer the ones that can be used in      a leaf function.  */
block|{
specifier|const
name|char
modifier|*
name|cheap_regs
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|leaf_regs
init|=
name|LEAF_REGISTERS
decl_stmt|;
if|if
condition|(
name|only_leaf_regs_used
argument_list|()
operator|&&
name|leaf_function_p
argument_list|()
condition|)
name|cheap_regs
operator|=
name|leaf_regs
expr_stmt|;
else|else
name|cheap_regs
operator|=
name|call_used_regs
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|i
index|]
operator|||
name|cheap_regs
index|[
name|i
index|]
condition|)
name|SET_HARD_REG_BIT
argument_list|(
name|regs_used_so_far
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* We consider registers that do not have to be saved over calls as if      they were already used since there is no cost in using them.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|i
index|]
operator|||
name|call_used_regs
index|[
name|i
index|]
condition|)
name|SET_HARD_REG_BIT
argument_list|(
name|regs_used_so_far
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
name|FIRST_PSEUDO_REGISTER
init|;
name|i
operator|<
operator|(
name|size_t
operator|)
name|max_regno
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|reg_renumber
index|[
name|i
index|]
operator|>=
literal|0
condition|)
name|SET_HARD_REG_BIT
argument_list|(
name|regs_used_so_far
argument_list|,
name|reg_renumber
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* Establish mappings from register number to allocation number      and vice versa.  In the process, count the allocnos.  */
name|reg_allocno
operator|=
name|XNEWVEC
argument_list|(
name|int
argument_list|,
name|max_regno
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
name|reg_allocno
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Initialize the shared-hard-reg mapping      from the list of pairs that may share.  */
name|reg_may_share
operator|=
name|XCNEWVEC
argument_list|(
name|int
argument_list|,
name|max_regno
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
name|regs_may_share
init|;
name|x
condition|;
name|x
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|int
name|r1
init|=
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|r2
init|=
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|r1
operator|>
name|r2
condition|)
name|reg_may_share
index|[
name|r1
index|]
operator|=
name|r2
expr_stmt|;
else|else
name|reg_may_share
index|[
name|r2
index|]
operator|=
name|r1
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|FIRST_PSEUDO_REGISTER
init|;
name|i
operator|<
operator|(
name|size_t
operator|)
name|max_regno
condition|;
name|i
operator|++
control|)
comment|/* Note that reg_live_length[i]< 0 indicates a "constant" reg        that we are supposed to refrain from putting in a hard reg.        -2 means do make an allocno but don't allocate it.  */
if|if
condition|(
name|REG_N_REFS
argument_list|(
name|i
argument_list|)
operator|!=
literal|0
operator|&&
name|REG_LIVE_LENGTH
argument_list|(
name|i
argument_list|)
operator|!=
operator|-
literal|1
comment|/* Don't allocate pseudos that cross calls, 	   if this function receives a nonlocal goto.  */
operator|&&
operator|(
operator|!
name|current_function_has_nonlocal_label
operator|||
name|REG_N_CALLS_CROSSED
argument_list|(
name|i
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|reg_renumber
index|[
name|i
index|]
operator|<
literal|0
operator|&&
name|reg_may_share
index|[
name|i
index|]
operator|&&
name|reg_allocno
index|[
name|reg_may_share
index|[
name|i
index|]
index|]
operator|>=
literal|0
condition|)
name|reg_allocno
index|[
name|i
index|]
operator|=
name|reg_allocno
index|[
name|reg_may_share
index|[
name|i
index|]
index|]
expr_stmt|;
else|else
name|reg_allocno
index|[
name|i
index|]
operator|=
name|max_allocno
operator|++
expr_stmt|;
name|gcc_assert
argument_list|(
name|REG_LIVE_LENGTH
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|reg_allocno
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|allocno
operator|=
name|XCNEWVEC
argument_list|(
expr|struct
name|allocno
argument_list|,
name|max_allocno
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|FIRST_PSEUDO_REGISTER
init|;
name|i
operator|<
operator|(
name|size_t
operator|)
name|max_regno
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|reg_allocno
index|[
name|i
index|]
operator|>=
literal|0
condition|)
block|{
name|int
name|num
init|=
name|reg_allocno
index|[
name|i
index|]
decl_stmt|;
name|allocno
index|[
name|num
index|]
operator|.
name|reg
operator|=
name|i
expr_stmt|;
name|allocno
index|[
name|num
index|]
operator|.
name|size
operator|=
name|PSEUDO_REGNO_SIZE
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|allocno
index|[
name|num
index|]
operator|.
name|calls_crossed
operator|+=
name|REG_N_CALLS_CROSSED
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|allocno
index|[
name|num
index|]
operator|.
name|throwing_calls_crossed
operator|+=
name|REG_N_THROWING_CALLS_CROSSED
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|allocno
index|[
name|num
index|]
operator|.
name|n_refs
operator|+=
name|REG_N_REFS
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|allocno
index|[
name|num
index|]
operator|.
name|freq
operator|+=
name|REG_FREQ
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|allocno
index|[
name|num
index|]
operator|.
name|live_length
operator|<
name|REG_LIVE_LENGTH
argument_list|(
name|i
argument_list|)
condition|)
name|allocno
index|[
name|num
index|]
operator|.
name|live_length
operator|=
name|REG_LIVE_LENGTH
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
comment|/* Calculate amount of usage of each hard reg by pseudos      allocated by local-alloc.  This is to see if we want to      override it.  */
name|memset
argument_list|(
name|local_reg_live_length
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|local_reg_live_length
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|local_reg_n_refs
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|local_reg_n_refs
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|local_reg_freq
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|local_reg_freq
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|FIRST_PSEUDO_REGISTER
init|;
name|i
operator|<
operator|(
name|size_t
operator|)
name|max_regno
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|reg_renumber
index|[
name|i
index|]
operator|>=
literal|0
condition|)
block|{
name|int
name|regno
init|=
name|reg_renumber
index|[
name|i
index|]
decl_stmt|;
name|int
name|endregno
init|=
name|regno
operator|+
name|hard_regno_nregs
index|[
name|regno
index|]
index|[
name|PSEUDO_REGNO_MODE
argument_list|(
name|i
argument_list|)
index|]
decl_stmt|;
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|regno
init|;
name|j
operator|<
name|endregno
condition|;
name|j
operator|++
control|)
block|{
name|local_reg_n_refs
index|[
name|j
index|]
operator|+=
name|REG_N_REFS
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|local_reg_freq
index|[
name|j
index|]
operator|+=
name|REG_FREQ
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|local_reg_live_length
index|[
name|j
index|]
operator|+=
name|REG_LIVE_LENGTH
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* We can't override local-alloc for a reg used not just by local-alloc.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|i
index|]
condition|)
name|local_reg_n_refs
index|[
name|i
index|]
operator|=
literal|0
operator|,
name|local_reg_freq
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|allocno_row_words
operator|=
operator|(
name|max_allocno
operator|+
name|INT_BITS
operator|-
literal|1
operator|)
operator|/
name|INT_BITS
expr_stmt|;
comment|/* We used to use alloca here, but the size of what it would try to      allocate would occasionally cause it to exceed the stack limit and      cause unpredictable core dumps.  Some examples were> 2Mb in size.  */
name|conflicts
operator|=
name|XCNEWVEC
argument_list|(
name|INT_TYPE
argument_list|,
name|max_allocno
operator|*
name|allocno_row_words
argument_list|)
expr_stmt|;
name|allocnos_live
operator|=
name|XNEWVEC
argument_list|(
name|INT_TYPE
argument_list|,
name|allocno_row_words
argument_list|)
expr_stmt|;
comment|/* If there is work to be done (at least one reg to allocate),      perform global conflict analysis and allocate the regs.  */
if|if
condition|(
name|max_allocno
operator|>
literal|0
condition|)
block|{
comment|/* Scan all the insns and compute the conflicts among allocnos 	 and between allocnos and hard regs.  */
name|global_conflicts
argument_list|()
expr_stmt|;
name|mirror_conflicts
argument_list|()
expr_stmt|;
comment|/* Eliminate conflicts between pseudos and eliminable registers.  If 	 the register is not eliminated, the pseudo won't really be able to 	 live in the eliminable register, so the conflict doesn't matter. 	 If we do eliminate the register, the conflict will no longer exist. 	 So in either case, we can ignore the conflict.  Likewise for 	 preferences.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|size_t
operator|)
name|max_allocno
condition|;
name|i
operator|++
control|)
block|{
name|AND_COMPL_HARD_REG_SET
argument_list|(
name|allocno
index|[
name|i
index|]
operator|.
name|hard_reg_conflicts
argument_list|,
name|eliminable_regset
argument_list|)
expr_stmt|;
name|AND_COMPL_HARD_REG_SET
argument_list|(
name|allocno
index|[
name|i
index|]
operator|.
name|hard_reg_copy_preferences
argument_list|,
name|eliminable_regset
argument_list|)
expr_stmt|;
name|AND_COMPL_HARD_REG_SET
argument_list|(
name|allocno
index|[
name|i
index|]
operator|.
name|hard_reg_preferences
argument_list|,
name|eliminable_regset
argument_list|)
expr_stmt|;
block|}
comment|/* Try to expand the preferences by merging them between allocnos.  */
name|expand_preferences
argument_list|()
expr_stmt|;
comment|/* Determine the order to allocate the remaining pseudo registers.  */
name|allocno_order
operator|=
name|XNEWVEC
argument_list|(
name|int
argument_list|,
name|max_allocno
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|size_t
operator|)
name|max_allocno
condition|;
name|i
operator|++
control|)
name|allocno_order
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
comment|/* Default the size to 1, since allocno_compare uses it to divide by. 	 Also convert allocno_live_length of zero to -1.  A length of zero 	 can occur when all the registers for that allocno have reg_live_length 	 equal to -2.  In this case, we want to make an allocno, but not 	 allocate it.  So avoid the divide-by-zero and set it to a low 	 priority.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|size_t
operator|)
name|max_allocno
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|allocno
index|[
name|i
index|]
operator|.
name|size
operator|==
literal|0
condition|)
name|allocno
index|[
name|i
index|]
operator|.
name|size
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|allocno
index|[
name|i
index|]
operator|.
name|live_length
operator|==
literal|0
condition|)
name|allocno
index|[
name|i
index|]
operator|.
name|live_length
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|qsort
argument_list|(
name|allocno_order
argument_list|,
name|max_allocno
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
name|allocno_compare
argument_list|)
expr_stmt|;
name|prune_preferences
argument_list|()
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
name|dump_conflicts
argument_list|(
name|dump_file
argument_list|)
expr_stmt|;
comment|/* Try allocating them, one by one, in that order, 	 except for parameters marked with reg_live_length[regno] == -2.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|size_t
operator|)
name|max_allocno
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|reg_renumber
index|[
name|allocno
index|[
name|allocno_order
index|[
name|i
index|]
index|]
operator|.
name|reg
index|]
operator|<
literal|0
operator|&&
name|REG_LIVE_LENGTH
argument_list|(
name|allocno
index|[
name|allocno_order
index|[
name|i
index|]
index|]
operator|.
name|reg
argument_list|)
operator|>=
literal|0
condition|)
block|{
comment|/* If we have more than one register class, 	       first try allocating in the class that is cheapest 	       for this pseudo-reg.  If that fails, try any reg.  */
if|if
condition|(
name|N_REG_CLASSES
operator|>
literal|1
condition|)
block|{
name|find_reg
argument_list|(
name|allocno_order
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_renumber
index|[
name|allocno
index|[
name|allocno_order
index|[
name|i
index|]
index|]
operator|.
name|reg
index|]
operator|>=
literal|0
condition|)
continue|continue;
block|}
if|if
condition|(
name|reg_alternate_class
argument_list|(
name|allocno
index|[
name|allocno_order
index|[
name|i
index|]
index|]
operator|.
name|reg
argument_list|)
operator|!=
name|NO_REGS
condition|)
name|find_reg
argument_list|(
name|allocno_order
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|allocno_order
argument_list|)
expr_stmt|;
block|}
comment|/* Do the reloads now while the allocno data still exists, so that we can      try to assign new hard regs to any pseudo regs that are spilled.  */
if|#
directive|if
literal|0
comment|/* We need to eliminate regs even if there is no rtl code, 	 for the sake of debugging information.  */
block|if (n_basic_blocks> NUM_FIXED_BLOCKS)
endif|#
directive|endif
block|{
name|build_insn_chain
argument_list|(
name|get_insns
argument_list|()
argument_list|)
expr_stmt|;
name|retval
operator|=
name|reload
argument_list|(
name|get_insns
argument_list|()
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Clean up.  */
name|free
argument_list|(
name|reg_allocno
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|reg_may_share
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|allocno
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|conflicts
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|allocnos_live
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* Sort predicate for ordering the allocnos.    Returns -1 (1) if *v1 should be allocated before (after) *v2.  */
end_comment

begin_function
specifier|static
name|int
name|allocno_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|v1p
parameter_list|,
specifier|const
name|void
modifier|*
name|v2p
parameter_list|)
block|{
name|int
name|v1
init|=
operator|*
operator|(
specifier|const
name|int
operator|*
operator|)
name|v1p
decl_stmt|,
name|v2
init|=
operator|*
operator|(
specifier|const
name|int
operator|*
operator|)
name|v2p
decl_stmt|;
comment|/* Note that the quotient will never be bigger than      the value of floor_log2 times the maximum number of      times a register can occur in one insn (surely less than 100)      weighted by the frequency (maximally REG_FREQ_MAX).      Multiplying this by 10000/REG_FREQ_MAX can't overflow.  */
name|int
name|pri1
init|=
operator|(
operator|(
call|(
name|double
call|)
argument_list|(
name|floor_log2
argument_list|(
name|allocno
index|[
name|v1
index|]
operator|.
name|n_refs
argument_list|)
operator|*
name|allocno
index|[
name|v1
index|]
operator|.
name|freq
argument_list|)
operator|/
name|allocno
index|[
name|v1
index|]
operator|.
name|live_length
operator|)
operator|*
operator|(
literal|10000
operator|/
name|REG_FREQ_MAX
operator|)
operator|*
name|allocno
index|[
name|v1
index|]
operator|.
name|size
operator|)
decl_stmt|;
name|int
name|pri2
init|=
operator|(
operator|(
call|(
name|double
call|)
argument_list|(
name|floor_log2
argument_list|(
name|allocno
index|[
name|v2
index|]
operator|.
name|n_refs
argument_list|)
operator|*
name|allocno
index|[
name|v2
index|]
operator|.
name|freq
argument_list|)
operator|/
name|allocno
index|[
name|v2
index|]
operator|.
name|live_length
operator|)
operator|*
operator|(
literal|10000
operator|/
name|REG_FREQ_MAX
operator|)
operator|*
name|allocno
index|[
name|v2
index|]
operator|.
name|size
operator|)
decl_stmt|;
if|if
condition|(
name|pri2
operator|-
name|pri1
condition|)
return|return
name|pri2
operator|-
name|pri1
return|;
comment|/* If regs are equally good, sort by allocno,      so that the results of qsort leave nothing to chance.  */
return|return
name|v1
operator|-
name|v2
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Scan the rtl code and record all conflicts and register preferences in the    conflict matrices and preference tables.  */
end_comment

begin_function
specifier|static
name|void
name|global_conflicts
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
name|basic_block
name|b
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|int
modifier|*
name|block_start_allocnos
decl_stmt|;
comment|/* Make a vector that mark_reg_{store,clobber} will store in.  */
name|regs_set
operator|=
name|XNEWVEC
argument_list|(
name|rtx
argument_list|,
name|max_parallel
operator|*
literal|2
argument_list|)
expr_stmt|;
name|block_start_allocnos
operator|=
name|XNEWVEC
argument_list|(
name|int
argument_list|,
name|max_allocno
argument_list|)
expr_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|b
argument_list|)
block|{
name|memset
argument_list|(
name|allocnos_live
argument_list|,
literal|0
argument_list|,
name|allocno_row_words
operator|*
sizeof|sizeof
argument_list|(
name|INT_TYPE
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Initialize table of registers currently live 	 to the state at the beginning of this basic block. 	 This also marks the conflicts among hard registers 	 and any allocnos that are live.  	 For pseudo-regs, there is only one bit for each one 	 no matter how many hard regs it occupies. 	 This is ok; we know the size from PSEUDO_REGNO_SIZE. 	 For explicit hard regs, we cannot know the size that way 	 since one hard reg can be used with various sizes. 	 Therefore, we must require that all the hard regs 	 implicitly live as part of a multi-word hard reg 	 be explicitly marked in basic_block_live_at_start.  */
block|{
name|regset
name|old
init|=
name|b
operator|->
name|il
operator|.
name|rtl
operator|->
name|global_live_at_start
decl_stmt|;
name|int
name|ax
init|=
literal|0
decl_stmt|;
name|reg_set_iterator
name|rsi
decl_stmt|;
name|REG_SET_TO_HARD_REG_SET
argument_list|(
name|hard_regs_live
argument_list|,
name|old
argument_list|)
expr_stmt|;
name|EXECUTE_IF_SET_IN_REG_SET
argument_list|(
argument|old
argument_list|,
argument|FIRST_PSEUDO_REGISTER
argument_list|,
argument|i
argument_list|,
argument|rsi
argument_list|)
block|{
name|int
name|a
init|=
name|reg_allocno
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|a
operator|>=
literal|0
condition|)
block|{
name|SET_ALLOCNO_LIVE
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|block_start_allocnos
index|[
name|ax
operator|++
index|]
operator|=
name|a
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|a
operator|=
name|reg_renumber
index|[
name|i
index|]
operator|)
operator|>=
literal|0
condition|)
name|mark_reg_live_nc
argument_list|(
name|a
argument_list|,
name|PSEUDO_REGNO_MODE
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Record that each allocno now live conflicts with each hard reg 	   now live.  	   It is not necessary to mark any conflicts between pseudos at 	   this point, even for pseudos which are live at the start of 	   the basic block.  	     Given two pseudos X and Y and any point in the CFG P.  	     On any path to point P where X and Y are live one of the 	     following conditions must be true:  		1. X is live at some instruction on the path that 		   evaluates Y.  		2. Y is live at some instruction on the path that 		   evaluates X.  		3. Either X or Y is not evaluated on the path to P 		   (i.e. it is used uninitialized) and thus the 		   conflict can be ignored.  	    In cases #1 and #2 the conflict will be recorded when we 	    scan the instruction that makes either X or Y become live.  */
name|record_conflicts
argument_list|(
name|block_start_allocnos
argument_list|,
name|ax
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EH_RETURN_DATA_REGNO
if|if
condition|(
name|bb_has_eh_pred
argument_list|(
name|b
argument_list|)
condition|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
condition|;
operator|++
name|i
control|)
block|{
name|unsigned
name|int
name|regno
init|=
name|EH_RETURN_DATA_REGNO
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|regno
operator|==
name|INVALID_REGNUM
condition|)
break|break;
name|record_one_conflict
argument_list|(
name|regno
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* Pseudos can't go in stack regs at the start of a basic block that 	   is reached by an abnormal edge. Likewise for call clobbered regs, 	   because caller-save, fixup_abnormal_edges and possibly the table 	   driven EH machinery are not quite ready to handle such regs live 	   across such edges.  */
block|{
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|b->preds
argument_list|)
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_ABNORMAL
condition|)
break|break;
if|if
condition|(
name|e
operator|!=
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|STACK_REGS
name|EXECUTE_IF_SET_IN_ALLOCNO_SET
argument_list|(
argument|allocnos_live
argument_list|,
argument|ax
argument_list|,
argument|{ 					       allocno[ax].no_stack_reg =
literal|1
argument|; 					     }
argument_list|)
empty_stmt|;
for|for
control|(
name|ax
operator|=
name|FIRST_STACK_REG
init|;
name|ax
operator|<=
name|LAST_STACK_REG
condition|;
name|ax
operator|++
control|)
name|record_one_conflict
argument_list|(
name|ax
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* No need to record conflicts for call clobbered regs if we have 		 nonlocal labels around, as we don't ever try to allocate such 		 regs in this case.  */
if|if
condition|(
operator|!
name|current_function_has_nonlocal_label
condition|)
for|for
control|(
name|ax
operator|=
literal|0
init|;
name|ax
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|ax
operator|++
control|)
if|if
condition|(
name|call_used_regs
index|[
name|ax
index|]
condition|)
name|record_one_conflict
argument_list|(
name|ax
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|insn
operator|=
name|BB_HEAD
argument_list|(
name|b
argument_list|)
expr_stmt|;
comment|/* Scan the code of this basic block, noting which allocnos 	 and hard regs are born or die.  When one is born, 	 record a conflict with all others currently live.  */
while|while
condition|(
literal|1
condition|)
block|{
name|RTX_CODE
name|code
init|=
name|GET_CODE
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|link
decl_stmt|;
comment|/* Make regs_set an empty set.  */
name|n_regs_set
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|INSN
operator|||
name|code
operator|==
name|CALL_INSN
operator|||
name|code
operator|==
name|JUMP_INSN
condition|)
block|{
if|#
directive|if
literal|0
block|int i = 0; 	      for (link = REG_NOTES (insn); 		   link&& i< NUM_NO_CONFLICT_PAIRS; 		   link = XEXP (link, 1)) 		if (REG_NOTE_KIND (link) == REG_NO_CONFLICT) 		  { 		    no_conflict_pairs[i].allocno1 		      = reg_allocno[REGNO (SET_DEST (PATTERN (insn)))]; 		    no_conflict_pairs[i].allocno2 		      = reg_allocno[REGNO (XEXP (link, 0))]; 		    i++; 		  }
endif|#
directive|endif
comment|/* 0 */
comment|/* Mark any registers clobbered by INSN as live, 		 so they conflict with the inputs.  */
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|mark_reg_clobber
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Mark any registers dead after INSN as dead now.  */
for|for
control|(
name|link
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
name|REG_DEAD
condition|)
name|mark_reg_death
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Mark any registers set in INSN as live, 		 and mark them as conflicting with all other live regs. 		 Clobbers are processed again, so they conflict with 		 the registers that are set.  */
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|mark_reg_store
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AUTO_INC_DEC
for|for
control|(
name|link
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
name|REG_INC
condition|)
name|mark_reg_store
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* If INSN has multiple outputs, then any reg that dies here 		 and is used inside of an output 		 must conflict with the other outputs.  		 It is unsafe to use !single_set here since it will ignore an 		 unused output.  Just because an output is unused does not mean 		 the compiler can assume the side effect will not occur. 		 Consider if REG appears in the address of an output and we 		 reload the output.  If we allocate REG to the same hard 		 register as an unused output we could set the hard register 		 before the output reload insn.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|multiple_sets
argument_list|(
name|insn
argument_list|)
condition|)
for|for
control|(
name|link
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
name|REG_DEAD
condition|)
block|{
name|int
name|used_in_output
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|rtx
name|reg
init|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|rtx
name|set
init|=
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|set
argument_list|)
operator|==
name|SET
operator|&&
operator|!
name|REG_P
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|&&
operator|!
name|rtx_equal_p
argument_list|(
name|reg
argument_list|,
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|reg
argument_list|,
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
condition|)
name|used_in_output
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|used_in_output
condition|)
name|mark_reg_conflicts
argument_list|(
name|reg
argument_list|)
expr_stmt|;
block|}
comment|/* Mark any registers set in INSN and then never used.  */
while|while
condition|(
name|n_regs_set
operator|--
operator|>
literal|0
condition|)
block|{
name|rtx
name|note
init|=
name|find_regno_note
argument_list|(
name|insn
argument_list|,
name|REG_UNUSED
argument_list|,
name|REGNO
argument_list|(
name|regs_set
index|[
name|n_regs_set
index|]
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|note
condition|)
name|mark_reg_death
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|insn
operator|==
name|BB_END
argument_list|(
name|b
argument_list|)
condition|)
break|break;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Clean up.  */
name|free
argument_list|(
name|block_start_allocnos
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|regs_set
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Expand the preference information by looking for cases where one allocno    dies in an insn that sets an allocno.  If those two allocnos don't conflict,    merge any preferences between those allocnos.  */
end_comment

begin_function
specifier|static
name|void
name|expand_preferences
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
name|rtx
name|link
decl_stmt|;
name|rtx
name|set
decl_stmt|;
comment|/* We only try to handle the most common cases here.  Most of the cases      where this wins are reg-reg copies.  */
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
operator|(
name|set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|REG_P
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|&&
name|reg_allocno
index|[
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
index|]
operator|>=
literal|0
condition|)
for|for
control|(
name|link
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
name|REG_DEAD
operator|&&
name|REG_P
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|reg_allocno
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
operator|>=
literal|0
operator|&&
operator|!
name|CONFLICTP
argument_list|(
name|reg_allocno
index|[
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
index|]
argument_list|,
name|reg_allocno
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
argument_list|)
condition|)
block|{
name|int
name|a1
init|=
name|reg_allocno
index|[
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
index|]
decl_stmt|;
name|int
name|a2
init|=
name|reg_allocno
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
decl_stmt|;
if|if
condition|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
operator|==
name|SET_SRC
argument_list|(
name|set
argument_list|)
condition|)
block|{
name|IOR_HARD_REG_SET
argument_list|(
name|allocno
index|[
name|a1
index|]
operator|.
name|hard_reg_copy_preferences
argument_list|,
name|allocno
index|[
name|a2
index|]
operator|.
name|hard_reg_copy_preferences
argument_list|)
expr_stmt|;
name|IOR_HARD_REG_SET
argument_list|(
name|allocno
index|[
name|a2
index|]
operator|.
name|hard_reg_copy_preferences
argument_list|,
name|allocno
index|[
name|a1
index|]
operator|.
name|hard_reg_copy_preferences
argument_list|)
expr_stmt|;
block|}
name|IOR_HARD_REG_SET
argument_list|(
name|allocno
index|[
name|a1
index|]
operator|.
name|hard_reg_preferences
argument_list|,
name|allocno
index|[
name|a2
index|]
operator|.
name|hard_reg_preferences
argument_list|)
expr_stmt|;
name|IOR_HARD_REG_SET
argument_list|(
name|allocno
index|[
name|a2
index|]
operator|.
name|hard_reg_preferences
argument_list|,
name|allocno
index|[
name|a1
index|]
operator|.
name|hard_reg_preferences
argument_list|)
expr_stmt|;
name|IOR_HARD_REG_SET
argument_list|(
name|allocno
index|[
name|a1
index|]
operator|.
name|hard_reg_full_preferences
argument_list|,
name|allocno
index|[
name|a2
index|]
operator|.
name|hard_reg_full_preferences
argument_list|)
expr_stmt|;
name|IOR_HARD_REG_SET
argument_list|(
name|allocno
index|[
name|a2
index|]
operator|.
name|hard_reg_full_preferences
argument_list|,
name|allocno
index|[
name|a1
index|]
operator|.
name|hard_reg_full_preferences
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Prune the preferences for global registers to exclude registers that cannot    be used.     Compute `regs_someone_prefers', which is a bitmask of the hard registers    that are preferred by conflicting registers of lower priority.  If possible,    we will avoid using these registers.  */
end_comment

begin_function
specifier|static
name|void
name|prune_preferences
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|num
decl_stmt|;
name|int
modifier|*
name|allocno_to_order
init|=
name|XNEWVEC
argument_list|(
name|int
argument_list|,
name|max_allocno
argument_list|)
decl_stmt|;
comment|/* Scan least most important to most important.      For each allocno, remove from preferences registers that cannot be used,      either because of conflicts or register type.  Then compute all registers      preferred by each lower-priority register that conflicts.  */
for|for
control|(
name|i
operator|=
name|max_allocno
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|HARD_REG_SET
name|temp
decl_stmt|;
name|num
operator|=
name|allocno_order
index|[
name|i
index|]
expr_stmt|;
name|allocno_to_order
index|[
name|num
index|]
operator|=
name|i
expr_stmt|;
name|COPY_HARD_REG_SET
argument_list|(
name|temp
argument_list|,
name|allocno
index|[
name|num
index|]
operator|.
name|hard_reg_conflicts
argument_list|)
expr_stmt|;
if|if
condition|(
name|allocno
index|[
name|num
index|]
operator|.
name|calls_crossed
operator|==
literal|0
condition|)
name|IOR_HARD_REG_SET
argument_list|(
name|temp
argument_list|,
name|fixed_reg_set
argument_list|)
expr_stmt|;
else|else
name|IOR_HARD_REG_SET
argument_list|(
name|temp
argument_list|,
name|call_used_reg_set
argument_list|)
expr_stmt|;
name|IOR_COMPL_HARD_REG_SET
argument_list|(
name|temp
argument_list|,
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|reg_preferred_class
argument_list|(
name|allocno
index|[
name|num
index|]
operator|.
name|reg
argument_list|)
index|]
argument_list|)
expr_stmt|;
name|AND_COMPL_HARD_REG_SET
argument_list|(
name|allocno
index|[
name|num
index|]
operator|.
name|hard_reg_preferences
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|AND_COMPL_HARD_REG_SET
argument_list|(
name|allocno
index|[
name|num
index|]
operator|.
name|hard_reg_copy_preferences
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|AND_COMPL_HARD_REG_SET
argument_list|(
name|allocno
index|[
name|num
index|]
operator|.
name|hard_reg_full_preferences
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|max_allocno
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
comment|/* Merge in the preferences of lower-priority registers (they have 	 already been pruned).  If we also prefer some of those registers, 	 don't exclude them unless we are of a smaller size (in which case 	 we want to give the lower-priority allocno the first chance for 	 these registers).  */
name|HARD_REG_SET
name|temp
decl_stmt|,
name|temp2
decl_stmt|;
name|int
name|allocno2
decl_stmt|;
name|num
operator|=
name|allocno_order
index|[
name|i
index|]
expr_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|temp2
argument_list|)
expr_stmt|;
name|EXECUTE_IF_SET_IN_ALLOCNO_SET
argument_list|(
argument|conflicts + num * allocno_row_words
argument_list|,
argument|allocno2
argument_list|,
argument|{ 	  if (allocno_to_order[allocno2]> i) 	    { 	      if (allocno[allocno2].size<= allocno[num].size) 		IOR_HARD_REG_SET (temp, 				  allocno[allocno2].hard_reg_full_preferences); 	      else 		IOR_HARD_REG_SET (temp2, 				  allocno[allocno2].hard_reg_full_preferences); 	    } 	}
argument_list|)
empty_stmt|;
name|AND_COMPL_HARD_REG_SET
argument_list|(
name|temp
argument_list|,
name|allocno
index|[
name|num
index|]
operator|.
name|hard_reg_full_preferences
argument_list|)
expr_stmt|;
name|IOR_HARD_REG_SET
argument_list|(
name|temp
argument_list|,
name|temp2
argument_list|)
expr_stmt|;
name|COPY_HARD_REG_SET
argument_list|(
name|allocno
index|[
name|num
index|]
operator|.
name|regs_someone_prefers
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|allocno_to_order
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Assign a hard register to allocno NUM; look for one that is the beginning    of a long enough stretch of hard regs none of which conflicts with ALLOCNO.    The registers marked in PREFREGS are tried first.     LOSERS, if nonzero, is a HARD_REG_SET indicating registers that cannot    be used for this allocation.     If ALT_REGS_P is zero, consider only the preferred class of ALLOCNO's reg.    Otherwise ignore that preferred class and use the alternate class.     If ACCEPT_CALL_CLOBBERED is nonzero, accept a call-clobbered hard reg that    will have to be saved and restored at calls.     RETRYING is nonzero if this is called from retry_global_alloc.     If we find one, record it in reg_renumber.    If not, do nothing.  */
end_comment

begin_function
specifier|static
name|void
name|find_reg
parameter_list|(
name|int
name|num
parameter_list|,
name|HARD_REG_SET
name|losers
parameter_list|,
name|int
name|alt_regs_p
parameter_list|,
name|int
name|accept_call_clobbered
parameter_list|,
name|int
name|retrying
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|best_reg
decl_stmt|,
name|pass
decl_stmt|;
name|HARD_REG_SET
name|used
decl_stmt|,
name|used1
decl_stmt|,
name|used2
decl_stmt|;
name|enum
name|reg_class
name|class
init|=
operator|(
name|alt_regs_p
condition|?
name|reg_alternate_class
argument_list|(
name|allocno
index|[
name|num
index|]
operator|.
name|reg
argument_list|)
else|:
name|reg_preferred_class
argument_list|(
name|allocno
index|[
name|num
index|]
operator|.
name|reg
argument_list|)
operator|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|PSEUDO_REGNO_MODE
argument_list|(
name|allocno
index|[
name|num
index|]
operator|.
name|reg
argument_list|)
decl_stmt|;
if|if
condition|(
name|accept_call_clobbered
condition|)
name|COPY_HARD_REG_SET
argument_list|(
name|used1
argument_list|,
name|call_fixed_reg_set
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|allocno
index|[
name|num
index|]
operator|.
name|calls_crossed
operator|==
literal|0
condition|)
name|COPY_HARD_REG_SET
argument_list|(
name|used1
argument_list|,
name|fixed_reg_set
argument_list|)
expr_stmt|;
else|else
name|COPY_HARD_REG_SET
argument_list|(
name|used1
argument_list|,
name|call_used_reg_set
argument_list|)
expr_stmt|;
comment|/* Some registers should not be allocated in global-alloc.  */
name|IOR_HARD_REG_SET
argument_list|(
name|used1
argument_list|,
name|no_global_alloc_regs
argument_list|)
expr_stmt|;
if|if
condition|(
name|losers
condition|)
name|IOR_HARD_REG_SET
argument_list|(
name|used1
argument_list|,
name|losers
argument_list|)
expr_stmt|;
name|IOR_COMPL_HARD_REG_SET
argument_list|(
name|used1
argument_list|,
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|class
index|]
argument_list|)
expr_stmt|;
name|COPY_HARD_REG_SET
argument_list|(
name|used2
argument_list|,
name|used1
argument_list|)
expr_stmt|;
name|IOR_HARD_REG_SET
argument_list|(
name|used1
argument_list|,
name|allocno
index|[
name|num
index|]
operator|.
name|hard_reg_conflicts
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CANNOT_CHANGE_MODE_CLASS
name|cannot_change_mode_set_regs
argument_list|(
operator|&
name|used1
argument_list|,
name|mode
argument_list|,
name|allocno
index|[
name|num
index|]
operator|.
name|reg
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Try each hard reg to see if it fits.  Do this in two passes.      In the first pass, skip registers that are preferred by some other pseudo      to give it a better chance of getting one of those registers.  Only if      we can't get a register when excluding those do we take one of them.      However, we never allocate a register for the first time in pass 0.  */
name|COPY_HARD_REG_SET
argument_list|(
name|used
argument_list|,
name|used1
argument_list|)
expr_stmt|;
name|IOR_COMPL_HARD_REG_SET
argument_list|(
name|used
argument_list|,
name|regs_used_so_far
argument_list|)
expr_stmt|;
name|IOR_HARD_REG_SET
argument_list|(
name|used
argument_list|,
name|allocno
index|[
name|num
index|]
operator|.
name|regs_someone_prefers
argument_list|)
expr_stmt|;
name|best_reg
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
name|FIRST_PSEUDO_REGISTER
operator|,
name|pass
operator|=
literal|0
init|;
name|pass
operator|<=
literal|1
operator|&&
name|i
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|;
name|pass
operator|++
control|)
block|{
if|if
condition|(
name|pass
operator|==
literal|1
condition|)
name|COPY_HARD_REG_SET
argument_list|(
name|used
argument_list|,
name|used1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
block|{
ifdef|#
directive|ifdef
name|REG_ALLOC_ORDER
name|int
name|regno
init|=
name|reg_alloc_order
index|[
name|i
index|]
decl_stmt|;
else|#
directive|else
name|int
name|regno
init|=
name|i
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|used
argument_list|,
name|regno
argument_list|)
operator|&&
name|HARD_REGNO_MODE_OK
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
operator|&&
operator|(
name|allocno
index|[
name|num
index|]
operator|.
name|calls_crossed
operator|==
literal|0
operator|||
name|accept_call_clobbered
operator|||
operator|!
name|HARD_REGNO_CALL_PART_CLOBBERED
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
operator|)
condition|)
block|{
name|int
name|j
decl_stmt|;
name|int
name|lim
init|=
name|regno
operator|+
name|hard_regno_nregs
index|[
name|regno
index|]
index|[
name|mode
index|]
decl_stmt|;
for|for
control|(
name|j
operator|=
name|regno
operator|+
literal|1
init|;
operator|(
name|j
operator|<
name|lim
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|used
argument_list|,
name|j
argument_list|)
operator|)
condition|;
name|j
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|j
operator|==
name|lim
condition|)
block|{
name|best_reg
operator|=
name|regno
expr_stmt|;
break|break;
block|}
ifndef|#
directive|ifndef
name|REG_ALLOC_ORDER
name|i
operator|=
name|j
expr_stmt|;
comment|/* Skip starting points we know will lose */
endif|#
directive|endif
block|}
block|}
block|}
comment|/* See if there is a preferred register with the same class as the register      we allocated above.  Making this restriction prevents register      preferencing from creating worse register allocation.       Remove from the preferred registers and conflicting registers.  Note that      additional conflicts may have been added after `prune_preferences' was      called.       First do this for those register with copy preferences, then all      preferred registers.  */
name|AND_COMPL_HARD_REG_SET
argument_list|(
name|allocno
index|[
name|num
index|]
operator|.
name|hard_reg_copy_preferences
argument_list|,
name|used
argument_list|)
expr_stmt|;
name|GO_IF_HARD_REG_SUBSET
argument_list|(
name|allocno
index|[
name|num
index|]
operator|.
name|hard_reg_copy_preferences
argument_list|,
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|NO_REGS
index|]
argument_list|,
name|no_copy_prefs
argument_list|)
expr_stmt|;
if|if
condition|(
name|best_reg
operator|>=
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|allocno
index|[
name|num
index|]
operator|.
name|hard_reg_copy_preferences
argument_list|,
name|i
argument_list|)
operator|&&
name|HARD_REGNO_MODE_OK
argument_list|(
name|i
argument_list|,
name|mode
argument_list|)
operator|&&
operator|(
name|allocno
index|[
name|num
index|]
operator|.
name|calls_crossed
operator|==
literal|0
operator|||
name|accept_call_clobbered
operator|||
operator|!
name|HARD_REGNO_CALL_PART_CLOBBERED
argument_list|(
name|i
argument_list|,
name|mode
argument_list|)
operator|)
operator|&&
operator|(
name|REGNO_REG_CLASS
argument_list|(
name|i
argument_list|)
operator|==
name|REGNO_REG_CLASS
argument_list|(
name|best_reg
argument_list|)
operator|||
name|reg_class_subset_p
argument_list|(
name|REGNO_REG_CLASS
argument_list|(
name|i
argument_list|)
argument_list|,
name|REGNO_REG_CLASS
argument_list|(
name|best_reg
argument_list|)
argument_list|)
operator|||
name|reg_class_subset_p
argument_list|(
name|REGNO_REG_CLASS
argument_list|(
name|best_reg
argument_list|)
argument_list|,
name|REGNO_REG_CLASS
argument_list|(
name|i
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|int
name|j
decl_stmt|;
name|int
name|lim
init|=
name|i
operator|+
name|hard_regno_nregs
index|[
name|i
index|]
index|[
name|mode
index|]
decl_stmt|;
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
operator|(
name|j
operator|<
name|lim
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|used
argument_list|,
name|j
argument_list|)
operator|&&
operator|(
name|REGNO_REG_CLASS
argument_list|(
name|j
argument_list|)
operator|==
name|REGNO_REG_CLASS
argument_list|(
name|best_reg
operator|+
operator|(
name|j
operator|-
name|i
operator|)
argument_list|)
operator|||
name|reg_class_subset_p
argument_list|(
name|REGNO_REG_CLASS
argument_list|(
name|j
argument_list|)
argument_list|,
name|REGNO_REG_CLASS
argument_list|(
name|best_reg
operator|+
operator|(
name|j
operator|-
name|i
operator|)
argument_list|)
argument_list|)
operator|||
name|reg_class_subset_p
argument_list|(
name|REGNO_REG_CLASS
argument_list|(
name|best_reg
operator|+
operator|(
name|j
operator|-
name|i
operator|)
argument_list|)
argument_list|,
name|REGNO_REG_CLASS
argument_list|(
name|j
argument_list|)
argument_list|)
operator|)
operator|)
condition|;
name|j
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|j
operator|==
name|lim
condition|)
block|{
name|best_reg
operator|=
name|i
expr_stmt|;
goto|goto
name|no_prefs
goto|;
block|}
block|}
block|}
name|no_copy_prefs
label|:
name|AND_COMPL_HARD_REG_SET
argument_list|(
name|allocno
index|[
name|num
index|]
operator|.
name|hard_reg_preferences
argument_list|,
name|used
argument_list|)
expr_stmt|;
name|GO_IF_HARD_REG_SUBSET
argument_list|(
name|allocno
index|[
name|num
index|]
operator|.
name|hard_reg_preferences
argument_list|,
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|NO_REGS
index|]
argument_list|,
name|no_prefs
argument_list|)
expr_stmt|;
if|if
condition|(
name|best_reg
operator|>=
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|allocno
index|[
name|num
index|]
operator|.
name|hard_reg_preferences
argument_list|,
name|i
argument_list|)
operator|&&
name|HARD_REGNO_MODE_OK
argument_list|(
name|i
argument_list|,
name|mode
argument_list|)
operator|&&
operator|(
name|allocno
index|[
name|num
index|]
operator|.
name|calls_crossed
operator|==
literal|0
operator|||
name|accept_call_clobbered
operator|||
operator|!
name|HARD_REGNO_CALL_PART_CLOBBERED
argument_list|(
name|i
argument_list|,
name|mode
argument_list|)
operator|)
operator|&&
operator|(
name|REGNO_REG_CLASS
argument_list|(
name|i
argument_list|)
operator|==
name|REGNO_REG_CLASS
argument_list|(
name|best_reg
argument_list|)
operator|||
name|reg_class_subset_p
argument_list|(
name|REGNO_REG_CLASS
argument_list|(
name|i
argument_list|)
argument_list|,
name|REGNO_REG_CLASS
argument_list|(
name|best_reg
argument_list|)
argument_list|)
operator|||
name|reg_class_subset_p
argument_list|(
name|REGNO_REG_CLASS
argument_list|(
name|best_reg
argument_list|)
argument_list|,
name|REGNO_REG_CLASS
argument_list|(
name|i
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|int
name|j
decl_stmt|;
name|int
name|lim
init|=
name|i
operator|+
name|hard_regno_nregs
index|[
name|i
index|]
index|[
name|mode
index|]
decl_stmt|;
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
operator|(
name|j
operator|<
name|lim
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|used
argument_list|,
name|j
argument_list|)
operator|&&
operator|(
name|REGNO_REG_CLASS
argument_list|(
name|j
argument_list|)
operator|==
name|REGNO_REG_CLASS
argument_list|(
name|best_reg
operator|+
operator|(
name|j
operator|-
name|i
operator|)
argument_list|)
operator|||
name|reg_class_subset_p
argument_list|(
name|REGNO_REG_CLASS
argument_list|(
name|j
argument_list|)
argument_list|,
name|REGNO_REG_CLASS
argument_list|(
name|best_reg
operator|+
operator|(
name|j
operator|-
name|i
operator|)
argument_list|)
argument_list|)
operator|||
name|reg_class_subset_p
argument_list|(
name|REGNO_REG_CLASS
argument_list|(
name|best_reg
operator|+
operator|(
name|j
operator|-
name|i
operator|)
argument_list|)
argument_list|,
name|REGNO_REG_CLASS
argument_list|(
name|j
argument_list|)
argument_list|)
operator|)
operator|)
condition|;
name|j
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|j
operator|==
name|lim
condition|)
block|{
name|best_reg
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
block|}
name|no_prefs
label|:
comment|/* If we haven't succeeded yet, try with caller-saves.      We need not check to see if the current function has nonlocal      labels because we don't put any pseudos that are live over calls in      registers in that case.  */
if|if
condition|(
name|flag_caller_saves
operator|&&
name|best_reg
operator|<
literal|0
condition|)
block|{
comment|/* Did not find a register.  If it would be profitable to 	 allocate a call-clobbered register and save and restore it 	 around calls, do that.  Don't do this if it crosses any calls 	 that might throw.  */
if|if
condition|(
operator|!
name|accept_call_clobbered
operator|&&
name|allocno
index|[
name|num
index|]
operator|.
name|calls_crossed
operator|!=
literal|0
operator|&&
name|allocno
index|[
name|num
index|]
operator|.
name|throwing_calls_crossed
operator|==
literal|0
operator|&&
name|CALLER_SAVE_PROFITABLE
argument_list|(
name|allocno
index|[
name|num
index|]
operator|.
name|n_refs
argument_list|,
name|allocno
index|[
name|num
index|]
operator|.
name|calls_crossed
argument_list|)
condition|)
block|{
name|HARD_REG_SET
name|new_losers
decl_stmt|;
if|if
condition|(
operator|!
name|losers
condition|)
name|CLEAR_HARD_REG_SET
argument_list|(
name|new_losers
argument_list|)
expr_stmt|;
else|else
name|COPY_HARD_REG_SET
argument_list|(
name|new_losers
argument_list|,
name|losers
argument_list|)
expr_stmt|;
name|IOR_HARD_REG_SET
argument_list|(
name|new_losers
argument_list|,
name|losing_caller_save_reg_set
argument_list|)
expr_stmt|;
name|find_reg
argument_list|(
name|num
argument_list|,
name|new_losers
argument_list|,
name|alt_regs_p
argument_list|,
literal|1
argument_list|,
name|retrying
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_renumber
index|[
name|allocno
index|[
name|num
index|]
operator|.
name|reg
index|]
operator|>=
literal|0
condition|)
block|{
name|caller_save_needed
operator|=
literal|1
expr_stmt|;
return|return;
block|}
block|}
block|}
comment|/* If we haven't succeeded yet,      see if some hard reg that conflicts with us      was utilized poorly by local-alloc.      If so, kick out the regs that were put there by local-alloc      so we can use it instead.  */
if|if
condition|(
name|best_reg
operator|<
literal|0
operator|&&
operator|!
name|retrying
comment|/* Let's not bother with multi-reg allocnos.  */
operator|&&
name|allocno
index|[
name|num
index|]
operator|.
name|size
operator|==
literal|1
operator|&&
name|REG_BASIC_BLOCK
argument_list|(
name|allocno
index|[
name|num
index|]
operator|.
name|reg
argument_list|)
operator|==
name|REG_BLOCK_GLOBAL
condition|)
block|{
comment|/* Count from the end, to find the least-used ones first.  */
for|for
control|(
name|i
operator|=
name|FIRST_PSEUDO_REGISTER
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
ifdef|#
directive|ifdef
name|REG_ALLOC_ORDER
name|int
name|regno
init|=
name|reg_alloc_order
index|[
name|i
index|]
decl_stmt|;
else|#
directive|else
name|int
name|regno
init|=
name|i
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|local_reg_n_refs
index|[
name|regno
index|]
operator|!=
literal|0
comment|/* Don't use a reg no good for this pseudo.  */
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|used2
argument_list|,
name|regno
argument_list|)
operator|&&
name|HARD_REGNO_MODE_OK
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
comment|/* The code below assumes that we need only a single 		 register, but the check of allocno[num].size above 		 was not enough.  Sometimes we need more than one 		 register for a single-word value.  */
operator|&&
name|hard_regno_nregs
index|[
name|regno
index|]
index|[
name|mode
index|]
operator|==
literal|1
operator|&&
operator|(
name|allocno
index|[
name|num
index|]
operator|.
name|calls_crossed
operator|==
literal|0
operator|||
name|accept_call_clobbered
operator|||
operator|!
name|HARD_REGNO_CALL_PART_CLOBBERED
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
operator|)
ifdef|#
directive|ifdef
name|CANNOT_CHANGE_MODE_CLASS
operator|&&
operator|!
name|invalid_mode_change_p
argument_list|(
name|regno
argument_list|,
name|REGNO_REG_CLASS
argument_list|(
name|regno
argument_list|)
argument_list|,
name|mode
argument_list|)
endif|#
directive|endif
ifdef|#
directive|ifdef
name|STACK_REGS
operator|&&
operator|(
operator|!
name|allocno
index|[
name|num
index|]
operator|.
name|no_stack_reg
operator|||
name|regno
operator|<
name|FIRST_STACK_REG
operator|||
name|regno
operator|>
name|LAST_STACK_REG
operator|)
endif|#
directive|endif
condition|)
block|{
comment|/* We explicitly evaluate the divide results into temporary 		 variables so as to avoid excess precision problems that occur 		 on an i386-unknown-sysv4.2 (unixware) host.  */
name|double
name|tmp1
init|=
operator|(
operator|(
name|double
operator|)
name|local_reg_freq
index|[
name|regno
index|]
operator|*
name|local_reg_n_refs
index|[
name|regno
index|]
operator|/
name|local_reg_live_length
index|[
name|regno
index|]
operator|)
decl_stmt|;
name|double
name|tmp2
init|=
operator|(
operator|(
name|double
operator|)
name|allocno
index|[
name|num
index|]
operator|.
name|freq
operator|*
name|allocno
index|[
name|num
index|]
operator|.
name|n_refs
operator|/
name|allocno
index|[
name|num
index|]
operator|.
name|live_length
operator|)
decl_stmt|;
if|if
condition|(
name|tmp1
operator|<
name|tmp2
condition|)
block|{
comment|/* Hard reg REGNO was used less in total by local regs 		     than it would be used by this one allocno!  */
name|int
name|k
decl_stmt|;
if|if
condition|(
name|dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Regno %d better for global %d, "
argument_list|,
name|regno
argument_list|,
name|allocno
index|[
name|num
index|]
operator|.
name|reg
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"fr:%d, ll:%d, nr:%d "
argument_list|,
name|allocno
index|[
name|num
index|]
operator|.
name|freq
argument_list|,
name|allocno
index|[
name|num
index|]
operator|.
name|live_length
argument_list|,
name|allocno
index|[
name|num
index|]
operator|.
name|n_refs
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"(was: fr:%d, ll:%d, nr:%d)\n"
argument_list|,
name|local_reg_freq
index|[
name|regno
index|]
argument_list|,
name|local_reg_live_length
index|[
name|regno
index|]
argument_list|,
name|local_reg_n_refs
index|[
name|regno
index|]
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|max_regno
condition|;
name|k
operator|++
control|)
if|if
condition|(
name|reg_renumber
index|[
name|k
index|]
operator|>=
literal|0
condition|)
block|{
name|int
name|r
init|=
name|reg_renumber
index|[
name|k
index|]
decl_stmt|;
name|int
name|endregno
init|=
name|r
operator|+
name|hard_regno_nregs
index|[
name|r
index|]
index|[
name|PSEUDO_REGNO_MODE
argument_list|(
name|k
argument_list|)
index|]
decl_stmt|;
if|if
condition|(
name|regno
operator|>=
name|r
operator|&&
name|regno
operator|<
name|endregno
condition|)
block|{
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Local Reg %d now on stack\n"
argument_list|,
name|k
argument_list|)
expr_stmt|;
name|reg_renumber
index|[
name|k
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
name|best_reg
operator|=
name|regno
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
comment|/* Did we find a register?  */
if|if
condition|(
name|best_reg
operator|>=
literal|0
condition|)
block|{
name|int
name|lim
decl_stmt|,
name|j
decl_stmt|;
name|HARD_REG_SET
name|this_reg
decl_stmt|;
comment|/* Yes.  Record it as the hard register of this pseudo-reg.  */
name|reg_renumber
index|[
name|allocno
index|[
name|num
index|]
operator|.
name|reg
index|]
operator|=
name|best_reg
expr_stmt|;
comment|/* Also of any pseudo-regs that share with it.  */
if|if
condition|(
name|reg_may_share
index|[
name|allocno
index|[
name|num
index|]
operator|.
name|reg
index|]
condition|)
for|for
control|(
name|j
operator|=
name|FIRST_PSEUDO_REGISTER
init|;
name|j
operator|<
name|max_regno
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|reg_allocno
index|[
name|j
index|]
operator|==
name|num
condition|)
name|reg_renumber
index|[
name|j
index|]
operator|=
name|best_reg
expr_stmt|;
comment|/* Make a set of the hard regs being allocated.  */
name|CLEAR_HARD_REG_SET
argument_list|(
name|this_reg
argument_list|)
expr_stmt|;
name|lim
operator|=
name|best_reg
operator|+
name|hard_regno_nregs
index|[
name|best_reg
index|]
index|[
name|mode
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
name|best_reg
init|;
name|j
operator|<
name|lim
condition|;
name|j
operator|++
control|)
block|{
name|SET_HARD_REG_BIT
argument_list|(
name|this_reg
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|SET_HARD_REG_BIT
argument_list|(
name|regs_used_so_far
argument_list|,
name|j
argument_list|)
expr_stmt|;
comment|/* This is no longer a reg used just by local regs.  */
name|local_reg_n_refs
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
name|local_reg_freq
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/* For each other pseudo-reg conflicting with this one, 	 mark it as conflicting with the hard regs this one occupies.  */
name|lim
operator|=
name|num
expr_stmt|;
name|EXECUTE_IF_SET_IN_ALLOCNO_SET
argument_list|(
argument|conflicts + lim * allocno_row_words
argument_list|,
argument|j
argument_list|,
argument|{ 	  IOR_HARD_REG_SET (allocno[j].hard_reg_conflicts, this_reg); 	}
argument_list|)
empty_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Called from `reload' to look for a hard reg to put pseudo reg REGNO in.    Perhaps it had previously seemed not worth a hard reg,    or perhaps its old hard reg has been commandeered for reloads.    FORBIDDEN_REGS indicates certain hard regs that may not be used, even if    they do not appear to be allocated.    If FORBIDDEN_REGS is zero, no regs are forbidden.  */
end_comment

begin_function
name|void
name|retry_global_alloc
parameter_list|(
name|int
name|regno
parameter_list|,
name|HARD_REG_SET
name|forbidden_regs
parameter_list|)
block|{
name|int
name|alloc_no
init|=
name|reg_allocno
index|[
name|regno
index|]
decl_stmt|;
if|if
condition|(
name|alloc_no
operator|>=
literal|0
condition|)
block|{
comment|/* If we have more than one register class, 	 first try allocating in the class that is cheapest 	 for this pseudo-reg.  If that fails, try any reg.  */
if|if
condition|(
name|N_REG_CLASSES
operator|>
literal|1
condition|)
name|find_reg
argument_list|(
name|alloc_no
argument_list|,
name|forbidden_regs
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_renumber
index|[
name|regno
index|]
operator|<
literal|0
operator|&&
name|reg_alternate_class
argument_list|(
name|regno
argument_list|)
operator|!=
name|NO_REGS
condition|)
name|find_reg
argument_list|(
name|alloc_no
argument_list|,
name|forbidden_regs
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* If we found a register, modify the RTL for the register to 	 show the hard register, and mark that register live.  */
if|if
condition|(
name|reg_renumber
index|[
name|regno
index|]
operator|>=
literal|0
condition|)
block|{
name|REGNO
argument_list|(
name|regno_reg_rtx
index|[
name|regno
index|]
argument_list|)
operator|=
name|reg_renumber
index|[
name|regno
index|]
expr_stmt|;
name|mark_home_live
argument_list|(
name|regno
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Record a conflict between register REGNO    and everything currently live.    REGNO must not be a pseudo reg that was allocated    by local_alloc; such numbers must be translated through    reg_renumber before calling here.  */
end_comment

begin_function
specifier|static
name|void
name|record_one_conflict
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
name|int
name|j
decl_stmt|;
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
comment|/* When a hard register becomes live,        record conflicts with live pseudo regs.  */
name|EXECUTE_IF_SET_IN_ALLOCNO_SET
argument_list|(
argument|allocnos_live
argument_list|,
argument|j
argument_list|,
argument|{ 	SET_HARD_REG_BIT (allocno[j].hard_reg_conflicts, regno);       }
argument_list|)
empty_stmt|;
else|else
comment|/* When a pseudo-register becomes live,        record conflicts first with hard regs,        then with other pseudo regs.  */
block|{
name|int
name|ialloc
init|=
name|reg_allocno
index|[
name|regno
index|]
decl_stmt|;
name|int
name|ialloc_prod
init|=
name|ialloc
operator|*
name|allocno_row_words
decl_stmt|;
name|IOR_HARD_REG_SET
argument_list|(
name|allocno
index|[
name|ialloc
index|]
operator|.
name|hard_reg_conflicts
argument_list|,
name|hard_regs_live
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
name|allocno_row_words
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
name|conflicts
index|[
name|ialloc_prod
operator|+
name|j
index|]
operator||=
name|allocnos_live
index|[
name|j
index|]
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Record all allocnos currently live as conflicting    with all hard regs currently live.     ALLOCNO_VEC is a vector of LEN allocnos, all allocnos that    are currently live.  Their bits are also flagged in allocnos_live.  */
end_comment

begin_function
specifier|static
name|void
name|record_conflicts
parameter_list|(
name|int
modifier|*
name|allocno_vec
parameter_list|,
name|int
name|len
parameter_list|)
block|{
while|while
condition|(
operator|--
name|len
operator|>=
literal|0
condition|)
name|IOR_HARD_REG_SET
argument_list|(
name|allocno
index|[
name|allocno_vec
index|[
name|len
index|]
index|]
operator|.
name|hard_reg_conflicts
argument_list|,
name|hard_regs_live
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If CONFLICTP (i, j) is true, make sure CONFLICTP (j, i) is also true.  */
end_comment

begin_function
specifier|static
name|void
name|mirror_conflicts
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|rw
init|=
name|allocno_row_words
decl_stmt|;
name|int
name|rwb
init|=
name|rw
operator|*
name|INT_BITS
decl_stmt|;
name|INT_TYPE
modifier|*
name|p
init|=
name|conflicts
decl_stmt|;
name|INT_TYPE
modifier|*
name|q0
init|=
name|conflicts
decl_stmt|,
modifier|*
name|q1
decl_stmt|,
modifier|*
name|q2
decl_stmt|;
name|unsigned
name|INT_TYPE
name|mask
decl_stmt|;
for|for
control|(
name|i
operator|=
name|max_allocno
operator|-
literal|1
operator|,
name|mask
operator|=
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
operator|,
name|mask
operator|<<=
literal|1
control|)
block|{
if|if
condition|(
operator|!
name|mask
condition|)
block|{
name|mask
operator|=
literal|1
expr_stmt|;
name|q0
operator|++
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
name|allocno_row_words
operator|-
literal|1
operator|,
name|q1
operator|=
name|q0
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
operator|,
name|q1
operator|+=
name|rwb
control|)
block|{
name|unsigned
name|INT_TYPE
name|word
decl_stmt|;
for|for
control|(
name|word
operator|=
operator|(
name|unsigned
name|INT_TYPE
operator|)
operator|*
name|p
operator|++
operator|,
name|q2
operator|=
name|q1
init|;
name|word
condition|;
name|word
operator|>>=
literal|1
operator|,
name|q2
operator|+=
name|rw
control|)
block|{
if|if
condition|(
name|word
operator|&
literal|1
condition|)
operator|*
name|q2
operator||=
name|mask
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Handle the case where REG is set by the insn being scanned,    during the forward scan to accumulate conflicts.    Store a 1 in regs_live or allocnos_live for this register, record how many    consecutive hardware registers it actually needs,    and record a conflict with all other registers already live.     Note that even if REG does not remain alive after this insn,    we must mark it here as live, to ensure a conflict between    REG and any other regs set in this insn that really do live.    This is because those other regs could be considered after this.     REG might actually be something other than a register;    if so, we do nothing.     SETTER is 0 if this register was modified by an auto-increment (i.e.,    a REG_INC note was found for it).  */
end_comment

begin_function
specifier|static
name|void
name|mark_reg_store
parameter_list|(
name|rtx
name|reg
parameter_list|,
name|rtx
name|setter
parameter_list|,
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|int
name|regno
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SUBREG
condition|)
name|reg
operator|=
name|SUBREG_REG
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|REG_P
argument_list|(
name|reg
argument_list|)
condition|)
return|return;
name|regs_set
index|[
name|n_regs_set
operator|++
index|]
operator|=
name|reg
expr_stmt|;
if|if
condition|(
name|setter
operator|&&
name|GET_CODE
argument_list|(
name|setter
argument_list|)
operator|!=
name|CLOBBER
condition|)
name|set_preference
argument_list|(
name|reg
argument_list|,
name|SET_SRC
argument_list|(
name|setter
argument_list|)
argument_list|)
expr_stmt|;
name|regno
operator|=
name|REGNO
argument_list|(
name|reg
argument_list|)
expr_stmt|;
comment|/* Either this is one of the max_allocno pseudo regs not allocated,      or it is or has a hardware reg.  First handle the pseudo-regs.  */
if|if
condition|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
if|if
condition|(
name|reg_allocno
index|[
name|regno
index|]
operator|>=
literal|0
condition|)
block|{
name|SET_ALLOCNO_LIVE
argument_list|(
name|reg_allocno
index|[
name|regno
index|]
argument_list|)
expr_stmt|;
name|record_one_conflict
argument_list|(
name|regno
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|reg_renumber
index|[
name|regno
index|]
operator|>=
literal|0
condition|)
name|regno
operator|=
name|reg_renumber
index|[
name|regno
index|]
expr_stmt|;
comment|/* Handle hardware regs (and pseudos allocated to hard regs).  */
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
operator|!
name|fixed_regs
index|[
name|regno
index|]
condition|)
block|{
name|int
name|last
init|=
name|regno
operator|+
name|hard_regno_nregs
index|[
name|regno
index|]
index|[
name|GET_MODE
argument_list|(
name|reg
argument_list|)
index|]
decl_stmt|;
while|while
condition|(
name|regno
operator|<
name|last
condition|)
block|{
name|record_one_conflict
argument_list|(
name|regno
argument_list|)
expr_stmt|;
name|SET_HARD_REG_BIT
argument_list|(
name|hard_regs_live
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|regno
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Like mark_reg_store except notice just CLOBBERs; ignore SETs.  */
end_comment

begin_function
specifier|static
name|void
name|mark_reg_clobber
parameter_list|(
name|rtx
name|reg
parameter_list|,
name|rtx
name|setter
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|setter
argument_list|)
operator|==
name|CLOBBER
condition|)
name|mark_reg_store
argument_list|(
name|reg
argument_list|,
name|setter
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Record that REG has conflicts with all the regs currently live.    Do not mark REG itself as live.  */
end_comment

begin_function
specifier|static
name|void
name|mark_reg_conflicts
parameter_list|(
name|rtx
name|reg
parameter_list|)
block|{
name|int
name|regno
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SUBREG
condition|)
name|reg
operator|=
name|SUBREG_REG
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|REG_P
argument_list|(
name|reg
argument_list|)
condition|)
return|return;
name|regno
operator|=
name|REGNO
argument_list|(
name|reg
argument_list|)
expr_stmt|;
comment|/* Either this is one of the max_allocno pseudo regs not allocated,      or it is or has a hardware reg.  First handle the pseudo-regs.  */
if|if
condition|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
if|if
condition|(
name|reg_allocno
index|[
name|regno
index|]
operator|>=
literal|0
condition|)
name|record_one_conflict
argument_list|(
name|regno
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|reg_renumber
index|[
name|regno
index|]
operator|>=
literal|0
condition|)
name|regno
operator|=
name|reg_renumber
index|[
name|regno
index|]
expr_stmt|;
comment|/* Handle hardware regs (and pseudos allocated to hard regs).  */
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
operator|!
name|fixed_regs
index|[
name|regno
index|]
condition|)
block|{
name|int
name|last
init|=
name|regno
operator|+
name|hard_regno_nregs
index|[
name|regno
index|]
index|[
name|GET_MODE
argument_list|(
name|reg
argument_list|)
index|]
decl_stmt|;
while|while
condition|(
name|regno
operator|<
name|last
condition|)
block|{
name|record_one_conflict
argument_list|(
name|regno
argument_list|)
expr_stmt|;
name|regno
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Mark REG as being dead (following the insn being scanned now).    Store a 0 in regs_live or allocnos_live for this register.  */
end_comment

begin_function
specifier|static
name|void
name|mark_reg_death
parameter_list|(
name|rtx
name|reg
parameter_list|)
block|{
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|reg
argument_list|)
decl_stmt|;
comment|/* Either this is one of the max_allocno pseudo regs not allocated,      or it is a hardware reg.  First handle the pseudo-regs.  */
if|if
condition|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
if|if
condition|(
name|reg_allocno
index|[
name|regno
index|]
operator|>=
literal|0
condition|)
name|CLEAR_ALLOCNO_LIVE
argument_list|(
name|reg_allocno
index|[
name|regno
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* For pseudo reg, see if it has been assigned a hardware reg.  */
if|if
condition|(
name|reg_renumber
index|[
name|regno
index|]
operator|>=
literal|0
condition|)
name|regno
operator|=
name|reg_renumber
index|[
name|regno
index|]
expr_stmt|;
comment|/* Handle hardware regs (and pseudos allocated to hard regs).  */
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
operator|!
name|fixed_regs
index|[
name|regno
index|]
condition|)
block|{
comment|/* Pseudo regs already assigned hardware regs are treated 	 almost the same as explicit hardware regs.  */
name|int
name|last
init|=
name|regno
operator|+
name|hard_regno_nregs
index|[
name|regno
index|]
index|[
name|GET_MODE
argument_list|(
name|reg
argument_list|)
index|]
decl_stmt|;
while|while
condition|(
name|regno
operator|<
name|last
condition|)
block|{
name|CLEAR_HARD_REG_BIT
argument_list|(
name|hard_regs_live
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|regno
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Mark hard reg REGNO as currently live, assuming machine mode MODE    for the value stored in it.  MODE determines how many consecutive    registers are actually in use.  Do not record conflicts;    it is assumed that the caller will do that.  */
end_comment

begin_function
specifier|static
name|void
name|mark_reg_live_nc
parameter_list|(
name|int
name|regno
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|int
name|last
init|=
name|regno
operator|+
name|hard_regno_nregs
index|[
name|regno
index|]
index|[
name|mode
index|]
decl_stmt|;
while|while
condition|(
name|regno
operator|<
name|last
condition|)
block|{
name|SET_HARD_REG_BIT
argument_list|(
name|hard_regs_live
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|regno
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Try to set a preference for an allocno to a hard register.    We are passed DEST and SRC which are the operands of a SET.  It is known    that SRC is a register.  If SRC or the first operand of SRC is a register,    try to set a preference.  If one of the two is a hard register and the other    is a pseudo-register, mark the preference.     Note that we are not as aggressive as local-alloc in trying to tie a    pseudo-register to a hard register.  */
end_comment

begin_function
specifier|static
name|void
name|set_preference
parameter_list|(
name|rtx
name|dest
parameter_list|,
name|rtx
name|src
parameter_list|)
block|{
name|unsigned
name|int
name|src_regno
decl_stmt|,
name|dest_regno
decl_stmt|;
comment|/* Amount to add to the hard regno for SRC, or subtract from that for DEST,      to compensate for subregs in SRC or DEST.  */
name|int
name|offset
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|int
name|copy
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
argument_list|)
index|[
literal|0
index|]
operator|==
literal|'e'
condition|)
name|src
operator|=
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
operator|,
name|copy
operator|=
literal|0
expr_stmt|;
comment|/* Get the reg number for both SRC and DEST.      If neither is a reg, give up.  */
if|if
condition|(
name|REG_P
argument_list|(
name|src
argument_list|)
condition|)
name|src_regno
operator|=
name|REGNO
argument_list|(
name|src
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|SUBREG
operator|&&
name|REG_P
argument_list|(
name|SUBREG_REG
argument_list|(
name|src
argument_list|)
argument_list|)
condition|)
block|{
name|src_regno
operator|=
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|src
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|src
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
name|offset
operator|+=
name|subreg_regno_offset
argument_list|(
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|src
argument_list|)
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|src
argument_list|)
argument_list|)
argument_list|,
name|SUBREG_BYTE
argument_list|(
name|src
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|src
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|offset
operator|+=
operator|(
name|SUBREG_BYTE
argument_list|(
name|src
argument_list|)
operator|/
name|REGMODE_NATURAL_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|src
argument_list|)
argument_list|)
operator|)
expr_stmt|;
block|}
else|else
return|return;
if|if
condition|(
name|REG_P
argument_list|(
name|dest
argument_list|)
condition|)
name|dest_regno
operator|=
name|REGNO
argument_list|(
name|dest
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
operator|&&
name|REG_P
argument_list|(
name|SUBREG_REG
argument_list|(
name|dest
argument_list|)
argument_list|)
condition|)
block|{
name|dest_regno
operator|=
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
name|offset
operator|-=
name|subreg_regno_offset
argument_list|(
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|dest
argument_list|)
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|dest
argument_list|)
argument_list|)
argument_list|,
name|SUBREG_BYTE
argument_list|(
name|dest
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|offset
operator|-=
operator|(
name|SUBREG_BYTE
argument_list|(
name|dest
argument_list|)
operator|/
name|REGMODE_NATURAL_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|)
expr_stmt|;
block|}
else|else
return|return;
comment|/* Convert either or both to hard reg numbers.  */
if|if
condition|(
name|reg_renumber
index|[
name|src_regno
index|]
operator|>=
literal|0
condition|)
name|src_regno
operator|=
name|reg_renumber
index|[
name|src_regno
index|]
expr_stmt|;
if|if
condition|(
name|reg_renumber
index|[
name|dest_regno
index|]
operator|>=
literal|0
condition|)
name|dest_regno
operator|=
name|reg_renumber
index|[
name|dest_regno
index|]
expr_stmt|;
comment|/* Now if one is a hard reg and the other is a global pseudo      then give the other a preference.  */
if|if
condition|(
name|dest_regno
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|src_regno
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|reg_allocno
index|[
name|src_regno
index|]
operator|>=
literal|0
condition|)
block|{
name|dest_regno
operator|-=
name|offset
expr_stmt|;
if|if
condition|(
name|dest_regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
if|if
condition|(
name|copy
condition|)
name|SET_REGBIT
argument_list|(
name|hard_reg_copy_preferences
argument_list|,
name|reg_allocno
index|[
name|src_regno
index|]
argument_list|,
name|dest_regno
argument_list|)
expr_stmt|;
name|SET_REGBIT
argument_list|(
name|hard_reg_preferences
argument_list|,
name|reg_allocno
index|[
name|src_regno
index|]
argument_list|,
name|dest_regno
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|dest_regno
init|;
name|i
operator|<
name|dest_regno
operator|+
name|hard_regno_nregs
index|[
name|dest_regno
index|]
index|[
name|GET_MODE
argument_list|(
name|dest
argument_list|)
index|]
condition|;
name|i
operator|++
control|)
name|SET_REGBIT
argument_list|(
name|hard_reg_full_preferences
argument_list|,
name|reg_allocno
index|[
name|src_regno
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|src_regno
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|dest_regno
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|reg_allocno
index|[
name|dest_regno
index|]
operator|>=
literal|0
condition|)
block|{
name|src_regno
operator|+=
name|offset
expr_stmt|;
if|if
condition|(
name|src_regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
if|if
condition|(
name|copy
condition|)
name|SET_REGBIT
argument_list|(
name|hard_reg_copy_preferences
argument_list|,
name|reg_allocno
index|[
name|dest_regno
index|]
argument_list|,
name|src_regno
argument_list|)
expr_stmt|;
name|SET_REGBIT
argument_list|(
name|hard_reg_preferences
argument_list|,
name|reg_allocno
index|[
name|dest_regno
index|]
argument_list|,
name|src_regno
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|src_regno
init|;
name|i
operator|<
name|src_regno
operator|+
name|hard_regno_nregs
index|[
name|src_regno
index|]
index|[
name|GET_MODE
argument_list|(
name|src
argument_list|)
index|]
condition|;
name|i
operator|++
control|)
name|SET_REGBIT
argument_list|(
name|hard_reg_full_preferences
argument_list|,
name|reg_allocno
index|[
name|dest_regno
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Indicate that hard register number FROM was eliminated and replaced with    an offset from hard register number TO.  The status of hard registers live    at the start of a basic block is updated by replacing a use of FROM with    a use of TO.  */
end_comment

begin_function
name|void
name|mark_elimination
parameter_list|(
name|int
name|from
parameter_list|,
name|int
name|to
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|regset
name|r
init|=
name|bb
operator|->
name|il
operator|.
name|rtl
operator|->
name|global_live_at_start
decl_stmt|;
if|if
condition|(
name|REGNO_REG_SET_P
argument_list|(
name|r
argument_list|,
name|from
argument_list|)
condition|)
block|{
name|CLEAR_REGNO_REG_SET
argument_list|(
name|r
argument_list|,
name|from
argument_list|)
expr_stmt|;
name|SET_REGNO_REG_SET
argument_list|(
name|r
argument_list|,
name|to
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Used for communication between the following functions.  Holds the    current life information.  */
end_comment

begin_decl_stmt
specifier|static
name|regset
name|live_relevant_regs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Record in live_relevant_regs and REGS_SET that register REG became live.    This is called via note_stores.  */
end_comment

begin_function
specifier|static
name|void
name|reg_becomes_live
parameter_list|(
name|rtx
name|reg
parameter_list|,
name|rtx
name|setter
name|ATTRIBUTE_UNUSED
parameter_list|,
name|void
modifier|*
name|regs_set
parameter_list|)
block|{
name|int
name|regno
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SUBREG
condition|)
name|reg
operator|=
name|SUBREG_REG
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|REG_P
argument_list|(
name|reg
argument_list|)
condition|)
return|return;
name|regno
operator|=
name|REGNO
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|int
name|nregs
init|=
name|hard_regno_nregs
index|[
name|regno
index|]
index|[
name|GET_MODE
argument_list|(
name|reg
argument_list|)
index|]
decl_stmt|;
while|while
condition|(
name|nregs
operator|--
operator|>
literal|0
condition|)
block|{
name|SET_REGNO_REG_SET
argument_list|(
name|live_relevant_regs
argument_list|,
name|regno
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fixed_regs
index|[
name|regno
index|]
condition|)
name|SET_REGNO_REG_SET
argument_list|(
operator|(
name|regset
operator|)
name|regs_set
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|regno
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|reg_renumber
index|[
name|regno
index|]
operator|>=
literal|0
condition|)
block|{
name|SET_REGNO_REG_SET
argument_list|(
name|live_relevant_regs
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|SET_REGNO_REG_SET
argument_list|(
operator|(
name|regset
operator|)
name|regs_set
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Record in live_relevant_regs that register REGNO died.  */
end_comment

begin_function
specifier|static
name|void
name|reg_dies
parameter_list|(
name|int
name|regno
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|struct
name|insn_chain
modifier|*
name|chain
parameter_list|)
block|{
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|int
name|nregs
init|=
name|hard_regno_nregs
index|[
name|regno
index|]
index|[
name|mode
index|]
decl_stmt|;
while|while
condition|(
name|nregs
operator|--
operator|>
literal|0
condition|)
block|{
name|CLEAR_REGNO_REG_SET
argument_list|(
name|live_relevant_regs
argument_list|,
name|regno
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fixed_regs
index|[
name|regno
index|]
condition|)
name|SET_REGNO_REG_SET
argument_list|(
operator|&
name|chain
operator|->
name|dead_or_set
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|regno
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
name|CLEAR_REGNO_REG_SET
argument_list|(
name|live_relevant_regs
argument_list|,
name|regno
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_renumber
index|[
name|regno
index|]
operator|>=
literal|0
condition|)
name|SET_REGNO_REG_SET
argument_list|(
operator|&
name|chain
operator|->
name|dead_or_set
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Walk the insns of the current function and build reload_insn_chain,    and record register life information.  */
end_comment

begin_function
name|void
name|build_insn_chain
parameter_list|(
name|rtx
name|first
parameter_list|)
block|{
name|struct
name|insn_chain
modifier|*
modifier|*
name|p
init|=
operator|&
name|reload_insn_chain
decl_stmt|;
name|struct
name|insn_chain
modifier|*
name|prev
init|=
literal|0
decl_stmt|;
name|basic_block
name|b
init|=
name|ENTRY_BLOCK_PTR
operator|->
name|next_bb
decl_stmt|;
name|live_relevant_regs
operator|=
name|ALLOC_REG_SET
argument_list|(
operator|&
name|reg_obstack
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|first
condition|;
name|first
operator|=
name|NEXT_INSN
argument_list|(
name|first
argument_list|)
control|)
block|{
name|struct
name|insn_chain
modifier|*
name|c
decl_stmt|;
if|if
condition|(
name|first
operator|==
name|BB_HEAD
argument_list|(
name|b
argument_list|)
condition|)
block|{
name|unsigned
name|i
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
name|CLEAR_REG_SET
argument_list|(
name|live_relevant_regs
argument_list|)
expr_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|b->il.rtl->global_live_at_start
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|bi
argument_list|)
block|{
if|if
condition|(
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|?
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|eliminable_regset
argument_list|,
name|i
argument_list|)
else|:
name|reg_renumber
index|[
name|i
index|]
operator|>=
literal|0
condition|)
name|SET_REGNO_REG_SET
argument_list|(
name|live_relevant_regs
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|NOTE_P
argument_list|(
name|first
argument_list|)
operator|&&
operator|!
name|BARRIER_P
argument_list|(
name|first
argument_list|)
condition|)
block|{
name|c
operator|=
name|new_insn_chain
argument_list|()
expr_stmt|;
name|c
operator|->
name|prev
operator|=
name|prev
expr_stmt|;
name|prev
operator|=
name|c
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
name|p
operator|=
operator|&
name|c
operator|->
name|next
expr_stmt|;
name|c
operator|->
name|insn
operator|=
name|first
expr_stmt|;
name|c
operator|->
name|block
operator|=
name|b
operator|->
name|index
expr_stmt|;
if|if
condition|(
name|INSN_P
argument_list|(
name|first
argument_list|)
condition|)
block|{
name|rtx
name|link
decl_stmt|;
comment|/* Mark the death of everything that dies in this instruction.  */
for|for
control|(
name|link
operator|=
name|REG_NOTES
argument_list|(
name|first
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
name|REG_DEAD
operator|&&
name|REG_P
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|reg_dies
argument_list|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|COPY_REG_SET
argument_list|(
operator|&
name|c
operator|->
name|live_throughout
argument_list|,
name|live_relevant_regs
argument_list|)
expr_stmt|;
comment|/* Mark everything born in this instruction as live.  */
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|first
argument_list|)
argument_list|,
name|reg_becomes_live
argument_list|,
operator|&
name|c
operator|->
name|dead_or_set
argument_list|)
expr_stmt|;
block|}
else|else
name|COPY_REG_SET
argument_list|(
operator|&
name|c
operator|->
name|live_throughout
argument_list|,
name|live_relevant_regs
argument_list|)
expr_stmt|;
if|if
condition|(
name|INSN_P
argument_list|(
name|first
argument_list|)
condition|)
block|{
name|rtx
name|link
decl_stmt|;
comment|/* Mark anything that is set in this insn and then unused as dying.  */
for|for
control|(
name|link
operator|=
name|REG_NOTES
argument_list|(
name|first
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
name|REG_UNUSED
operator|&&
name|REG_P
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|reg_dies
argument_list|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|first
operator|==
name|BB_END
argument_list|(
name|b
argument_list|)
condition|)
name|b
operator|=
name|b
operator|->
name|next_bb
expr_stmt|;
comment|/* Stop after we pass the end of the last basic block.  Verify that 	 no real insns are after the end of the last basic block.  	 We may want to reorganize the loop somewhat since this test should 	 always be the right exit test.  Allow an ADDR_VEC or ADDR_DIF_VEC if 	 the previous real insn is a JUMP_INSN.  */
if|if
condition|(
name|b
operator|==
name|EXIT_BLOCK_PTR
condition|)
block|{
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
for|for
control|(
name|first
operator|=
name|NEXT_INSN
argument_list|(
name|first
argument_list|)
init|;
name|first
condition|;
name|first
operator|=
name|NEXT_INSN
argument_list|(
name|first
argument_list|)
control|)
name|gcc_assert
argument_list|(
operator|!
name|INSN_P
argument_list|(
name|first
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|first
argument_list|)
argument_list|)
operator|==
name|USE
operator|||
operator|(
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|first
argument_list|)
argument_list|)
operator|==
name|ADDR_VEC
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|first
argument_list|)
argument_list|)
operator|==
name|ADDR_DIFF_VEC
operator|)
operator|&&
name|prev_real_insn
argument_list|(
name|first
argument_list|)
operator|!=
literal|0
operator|&&
name|JUMP_P
argument_list|(
name|prev_real_insn
argument_list|(
name|first
argument_list|)
argument_list|)
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
block|}
name|FREE_REG_SET
argument_list|(
name|live_relevant_regs
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print debugging trace information if -dg switch is given,    showing the information on which the allocation decisions are based.  */
end_comment

begin_function
specifier|static
name|void
name|dump_conflicts
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|has_preferences
decl_stmt|;
name|int
name|nregs
decl_stmt|;
name|nregs
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_allocno
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|reg_renumber
index|[
name|allocno
index|[
name|allocno_order
index|[
name|i
index|]
index|]
operator|.
name|reg
index|]
operator|>=
literal|0
condition|)
continue|continue;
name|nregs
operator|++
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|";; %d regs to allocate:"
argument_list|,
name|nregs
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_allocno
condition|;
name|i
operator|++
control|)
block|{
name|int
name|j
decl_stmt|;
if|if
condition|(
name|reg_renumber
index|[
name|allocno
index|[
name|allocno_order
index|[
name|i
index|]
index|]
operator|.
name|reg
index|]
operator|>=
literal|0
condition|)
continue|continue;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %d"
argument_list|,
name|allocno
index|[
name|allocno_order
index|[
name|i
index|]
index|]
operator|.
name|reg
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|max_regno
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|reg_allocno
index|[
name|j
index|]
operator|==
name|allocno_order
index|[
name|i
index|]
operator|&&
name|j
operator|!=
name|allocno
index|[
name|allocno_order
index|[
name|i
index|]
index|]
operator|.
name|reg
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"+%d"
argument_list|,
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|allocno
index|[
name|allocno_order
index|[
name|i
index|]
index|]
operator|.
name|size
operator|!=
literal|1
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" (%d)"
argument_list|,
name|allocno
index|[
name|allocno_order
index|[
name|i
index|]
index|]
operator|.
name|size
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_allocno
condition|;
name|i
operator|++
control|)
block|{
name|int
name|j
decl_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|";; %d conflicts:"
argument_list|,
name|allocno
index|[
name|i
index|]
operator|.
name|reg
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|max_allocno
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|CONFLICTP
argument_list|(
name|j
argument_list|,
name|i
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %d"
argument_list|,
name|allocno
index|[
name|j
index|]
operator|.
name|reg
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|allocno
index|[
name|i
index|]
operator|.
name|hard_reg_conflicts
argument_list|,
name|j
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %d"
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|has_preferences
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|allocno
index|[
name|i
index|]
operator|.
name|hard_reg_preferences
argument_list|,
name|j
argument_list|)
condition|)
name|has_preferences
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|has_preferences
condition|)
continue|continue;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|";; %d preferences:"
argument_list|,
name|allocno
index|[
name|i
index|]
operator|.
name|reg
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|allocno
index|[
name|i
index|]
operator|.
name|hard_reg_preferences
argument_list|,
name|j
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %d"
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dump_global_regs
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|";; Register dispositions:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|FIRST_PSEUDO_REGISTER
operator|,
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|max_regno
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|reg_renumber
index|[
name|i
index|]
operator|>=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d in %d  "
argument_list|,
name|i
argument_list|,
name|reg_renumber
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|j
operator|%
literal|6
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n\n;; Hard regs used: "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|i
index|]
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This page contains code to make live information more accurate.    The accurate register liveness at program point P means:      o there is a path from P to usage of the register and the        register is not redefined or killed on the path.      o register at P is partially available, i.e. there is a path from        a register definition to the point P and the register is not        killed (clobbered) on the path     The standard GCC live information means only the first condition.    Without the partial availability, there will be more register    conflicts and as a consequence worse register allocation.  The    typical example where the information can be different is a    register initialized in the loop at the basic block preceding the    loop in CFG.  */
end_comment

begin_comment
comment|/* The following structure contains basic block data flow information    used to calculate partial availability of registers.  */
end_comment

begin_struct
struct|struct
name|bb_info
block|{
comment|/* The basic block reverse post-order number.  */
name|int
name|rts_number
decl_stmt|;
comment|/* Registers used uninitialized in an insn in which there is an      early clobbered register might get the same hard register.  */
name|bitmap
name|earlyclobber
decl_stmt|;
comment|/* Registers correspondingly killed (clobbered) and defined but not      killed afterward in the basic block.  */
name|bitmap
name|killed
decl_stmt|,
name|avloc
decl_stmt|;
comment|/* Registers partially available and living (in other words whose      values were calculated and used) correspondingly at the start      and end of the basic block.  */
name|bitmap
name|live_pavin
decl_stmt|,
name|live_pavout
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Macros for accessing data flow information of basic blocks.  */
end_comment

begin_define
define|#
directive|define
name|BB_INFO
parameter_list|(
name|BB
parameter_list|)
value|((struct bb_info *) (BB)->aux)
end_define

begin_define
define|#
directive|define
name|BB_INFO_BY_INDEX
parameter_list|(
name|N
parameter_list|)
value|BB_INFO (BASIC_BLOCK(N))
end_define

begin_decl_stmt
specifier|static
name|struct
name|bitmap_obstack
name|greg_obstack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The function allocates the info structures of each basic block.  It    also initialized LIVE_PAVIN and LIVE_PAVOUT as if all hard    registers were partially available.  */
end_comment

begin_function
specifier|static
name|void
name|allocate_bb_info
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|struct
name|bb_info
modifier|*
name|bb_info
decl_stmt|;
name|bitmap
name|init
decl_stmt|;
name|alloc_aux_for_blocks
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|bb_info
argument_list|)
argument_list|)
expr_stmt|;
name|init
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
name|bitmap_set_bit
argument_list|(
name|init
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|bitmap_obstack_initialize
argument_list|(
operator|&
name|greg_obstack
argument_list|)
expr_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|bb_info
operator|=
name|bb
operator|->
name|aux
expr_stmt|;
name|bb_info
operator|->
name|earlyclobber
operator|=
name|BITMAP_ALLOC
argument_list|(
operator|&
name|greg_obstack
argument_list|)
expr_stmt|;
name|bb_info
operator|->
name|avloc
operator|=
name|BITMAP_ALLOC
argument_list|(
operator|&
name|greg_obstack
argument_list|)
expr_stmt|;
name|bb_info
operator|->
name|killed
operator|=
name|BITMAP_ALLOC
argument_list|(
operator|&
name|greg_obstack
argument_list|)
expr_stmt|;
name|bb_info
operator|->
name|live_pavin
operator|=
name|BITMAP_ALLOC
argument_list|(
operator|&
name|greg_obstack
argument_list|)
expr_stmt|;
name|bb_info
operator|->
name|live_pavout
operator|=
name|BITMAP_ALLOC
argument_list|(
operator|&
name|greg_obstack
argument_list|)
expr_stmt|;
name|bitmap_copy
argument_list|(
name|bb_info
operator|->
name|live_pavin
argument_list|,
name|init
argument_list|)
expr_stmt|;
name|bitmap_copy
argument_list|(
name|bb_info
operator|->
name|live_pavout
argument_list|,
name|init
argument_list|)
expr_stmt|;
block|}
name|BITMAP_FREE
argument_list|(
name|init
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The function frees the allocated info of all basic blocks.  */
end_comment

begin_function
specifier|static
name|void
name|free_bb_info
parameter_list|(
name|void
parameter_list|)
block|{
name|bitmap_obstack_release
argument_list|(
operator|&
name|greg_obstack
argument_list|)
expr_stmt|;
name|free_aux_for_blocks
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The function modifies local info for register REG being changed in    SETTER.  DATA is used to pass the current basic block info.  */
end_comment

begin_function
specifier|static
name|void
name|mark_reg_change
parameter_list|(
name|rtx
name|reg
parameter_list|,
name|rtx
name|setter
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|int
name|regno
decl_stmt|;
name|basic_block
name|bb
init|=
name|data
decl_stmt|;
name|struct
name|bb_info
modifier|*
name|bb_info
init|=
name|BB_INFO
argument_list|(
name|bb
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SUBREG
condition|)
name|reg
operator|=
name|SUBREG_REG
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|REG_P
argument_list|(
name|reg
argument_list|)
condition|)
return|return;
name|regno
operator|=
name|REGNO
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|bitmap_set_bit
argument_list|(
name|bb_info
operator|->
name|killed
argument_list|,
name|regno
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|setter
argument_list|)
operator|!=
name|CLOBBER
condition|)
name|bitmap_set_bit
argument_list|(
name|bb_info
operator|->
name|avloc
argument_list|,
name|regno
argument_list|)
expr_stmt|;
else|else
name|bitmap_clear_bit
argument_list|(
name|bb_info
operator|->
name|avloc
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Classes of registers which could be early clobbered in the current    insn.  */
end_comment

begin_expr_stmt
specifier|static
name|VEC
argument_list|(
name|int
argument_list|,
name|heap
argument_list|)
operator|*
name|earlyclobber_regclass
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* This function finds and stores register classes that could be early    clobbered in INSN.  If any earlyclobber classes are found, the function    returns TRUE, in all other cases it returns FALSE.  */
end_comment

begin_function
specifier|static
name|bool
name|check_earlyclobber
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|int
name|opno
decl_stmt|;
name|bool
name|found
init|=
name|false
decl_stmt|;
name|extract_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|VEC_truncate
argument_list|(
name|int
argument_list|,
name|earlyclobber_regclass
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|opno
operator|=
literal|0
init|;
name|opno
operator|<
name|recog_data
operator|.
name|n_operands
condition|;
name|opno
operator|++
control|)
block|{
name|char
name|c
decl_stmt|;
name|bool
name|amp_p
decl_stmt|;
name|int
name|i
decl_stmt|;
name|enum
name|reg_class
name|class
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
init|=
name|recog_data
operator|.
name|constraints
index|[
name|opno
index|]
decl_stmt|;
name|class
operator|=
name|NO_REGS
expr_stmt|;
name|amp_p
operator|=
name|false
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
operator|*
name|p
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'='
case|:
case|case
literal|'+'
case|:
case|case
literal|'?'
case|:
case|case
literal|'#'
case|:
case|case
literal|'!'
case|:
case|case
literal|'*'
case|:
case|case
literal|'%'
case|:
case|case
literal|'m'
case|:
case|case
literal|'<'
case|:
case|case
literal|'>'
case|:
case|case
literal|'V'
case|:
case|case
literal|'o'
case|:
case|case
literal|'E'
case|:
case|case
literal|'F'
case|:
case|case
literal|'G'
case|:
case|case
literal|'H'
case|:
case|case
literal|'s'
case|:
case|case
literal|'i'
case|:
case|case
literal|'n'
case|:
case|case
literal|'I'
case|:
case|case
literal|'J'
case|:
case|case
literal|'K'
case|:
case|case
literal|'L'
case|:
case|case
literal|'M'
case|:
case|case
literal|'N'
case|:
case|case
literal|'O'
case|:
case|case
literal|'P'
case|:
case|case
literal|'X'
case|:
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
comment|/* These don't say anything we care about.  */
break|break;
case|case
literal|'&'
case|:
name|amp_p
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'\0'
case|:
case|case
literal|','
case|:
if|if
condition|(
name|amp_p
operator|&&
name|class
operator|!=
name|NO_REGS
condition|)
block|{
name|int
name|rc
decl_stmt|;
name|found
operator|=
name|true
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|int
argument_list|,
name|earlyclobber_regclass
argument_list|,
name|i
argument_list|,
name|rc
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|rc
operator|==
operator|(
name|int
operator|)
name|class
condition|)
goto|goto
name|found_rc
goto|;
block|}
comment|/* We use VEC_quick_push here because 		     earlyclobber_regclass holds no more than 		     N_REG_CLASSES elements. */
name|VEC_quick_push
argument_list|(
name|int
argument_list|,
name|earlyclobber_regclass
argument_list|,
operator|(
name|int
operator|)
name|class
argument_list|)
expr_stmt|;
name|found_rc
label|:
empty_stmt|;
block|}
name|amp_p
operator|=
name|false
expr_stmt|;
name|class
operator|=
name|NO_REGS
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|class
operator|=
name|GENERAL_REGS
expr_stmt|;
break|break;
default|default:
name|class
operator|=
name|REG_CLASS_FROM_CONSTRAINT
argument_list|(
name|c
argument_list|,
name|p
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
break|break;
name|p
operator|+=
name|CONSTRAINT_LEN
argument_list|(
name|c
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|found
return|;
block|}
end_function

begin_comment
comment|/* The function checks that pseudo-register *X has a class    intersecting with the class of pseudo-register could be early    clobbered in the same insn.    This function is a no-op if earlyclobber_regclass is empty.  */
end_comment

begin_function
specifier|static
name|int
name|mark_reg_use_for_earlyclobber
parameter_list|(
name|rtx
modifier|*
name|x
parameter_list|,
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|enum
name|reg_class
name|pref_class
decl_stmt|,
name|alt_class
decl_stmt|;
name|int
name|i
decl_stmt|,
name|regno
decl_stmt|;
name|basic_block
name|bb
init|=
name|data
decl_stmt|;
name|struct
name|bb_info
modifier|*
name|bb_info
init|=
name|BB_INFO
argument_list|(
name|bb
argument_list|)
decl_stmt|;
if|if
condition|(
name|REG_P
argument_list|(
operator|*
name|x
argument_list|)
operator|&&
name|REGNO
argument_list|(
operator|*
name|x
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|int
name|rc
decl_stmt|;
name|regno
operator|=
name|REGNO
argument_list|(
operator|*
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitmap_bit_p
argument_list|(
name|bb_info
operator|->
name|killed
argument_list|,
name|regno
argument_list|)
operator|||
name|bitmap_bit_p
argument_list|(
name|bb_info
operator|->
name|avloc
argument_list|,
name|regno
argument_list|)
condition|)
return|return
literal|0
return|;
name|pref_class
operator|=
name|reg_preferred_class
argument_list|(
name|regno
argument_list|)
expr_stmt|;
name|alt_class
operator|=
name|reg_alternate_class
argument_list|(
name|regno
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|int
argument_list|,
name|earlyclobber_regclass
argument_list|,
name|i
argument_list|,
name|rc
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|reg_classes_intersect_p
argument_list|(
name|rc
argument_list|,
name|pref_class
argument_list|)
operator|||
operator|(
name|rc
operator|!=
name|NO_REGS
operator|&&
name|reg_classes_intersect_p
argument_list|(
name|rc
argument_list|,
name|alt_class
argument_list|)
operator|)
condition|)
block|{
name|bitmap_set_bit
argument_list|(
name|bb_info
operator|->
name|earlyclobber
argument_list|,
name|regno
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* The function processes all pseudo-registers in *X with the aid of    previous function.  */
end_comment

begin_function
specifier|static
name|void
name|mark_reg_use_for_earlyclobber_1
parameter_list|(
name|rtx
modifier|*
name|x
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|for_each_rtx
argument_list|(
name|x
argument_list|,
name|mark_reg_use_for_earlyclobber
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The function calculates local info for each basic block.  */
end_comment

begin_function
specifier|static
name|void
name|calculate_local_reg_bb_info
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|rtx
name|insn
decl_stmt|,
name|bound
decl_stmt|;
comment|/* We know that earlyclobber_regclass holds no more than     N_REG_CLASSES elements.  See check_earlyclobber.  */
name|earlyclobber_regclass
operator|=
name|VEC_alloc
argument_list|(
name|int
argument_list|,
name|heap
argument_list|,
name|N_REG_CLASSES
argument_list|)
expr_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|bound
operator|=
name|NEXT_INSN
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
init|;
name|insn
operator|!=
name|bound
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|mark_reg_change
argument_list|,
name|bb
argument_list|)
expr_stmt|;
if|if
condition|(
name|check_earlyclobber
argument_list|(
name|insn
argument_list|)
condition|)
name|note_uses
argument_list|(
operator|&
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|mark_reg_use_for_earlyclobber_1
argument_list|,
name|bb
argument_list|)
expr_stmt|;
block|}
block|}
name|VEC_free
argument_list|(
name|int
argument_list|,
name|heap
argument_list|,
name|earlyclobber_regclass
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The function sets up reverse post-order number of each basic    block.  */
end_comment

begin_function
specifier|static
name|void
name|set_up_bb_rts_numbers
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
modifier|*
name|rts_order
decl_stmt|;
name|rts_order
operator|=
name|XNEWVEC
argument_list|(
name|int
argument_list|,
name|n_basic_blocks
operator|-
name|NUM_FIXED_BLOCKS
argument_list|)
expr_stmt|;
name|post_order_compute
argument_list|(
name|rts_order
argument_list|,
name|false
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_basic_blocks
operator|-
name|NUM_FIXED_BLOCKS
condition|;
name|i
operator|++
control|)
name|BB_INFO_BY_INDEX
argument_list|(
name|rts_order
index|[
name|i
index|]
argument_list|)
operator|->
name|rts_number
operator|=
name|i
expr_stmt|;
name|free
argument_list|(
name|rts_order
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compare function for sorting blocks in reverse postorder.  */
end_comment

begin_function
specifier|static
name|int
name|rpost_cmp
parameter_list|(
specifier|const
name|void
modifier|*
name|bb1
parameter_list|,
specifier|const
name|void
modifier|*
name|bb2
parameter_list|)
block|{
name|basic_block
name|b1
init|=
operator|*
operator|(
name|basic_block
operator|*
operator|)
name|bb1
decl_stmt|,
name|b2
init|=
operator|*
operator|(
name|basic_block
operator|*
operator|)
name|bb2
decl_stmt|;
return|return
name|BB_INFO
argument_list|(
name|b2
argument_list|)
operator|->
name|rts_number
operator|-
name|BB_INFO
argument_list|(
name|b1
argument_list|)
operator|->
name|rts_number
return|;
block|}
end_function

begin_comment
comment|/* Temporary bitmap used for live_pavin, live_pavout calculation.  */
end_comment

begin_decl_stmt
specifier|static
name|bitmap
name|temp_bitmap
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The function calculates partial register availability according to    the following equations:       bb.live_pavin        = empty for entry block          | union (live_pavout of predecessors)& global_live_at_start      bb.live_pavout = union (bb.live_pavin - bb.killed, bb.avloc)& global_live_at_end  */
end_comment

begin_function
specifier|static
name|void
name|calculate_reg_pav
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|,
name|succ
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|int
name|i
decl_stmt|,
name|nel
decl_stmt|;
name|VEC
argument_list|(
name|basic_block
argument_list|,
name|heap
argument_list|)
operator|*
name|bbs
operator|,
operator|*
name|new_bbs
operator|,
operator|*
name|temp
expr_stmt|;
name|basic_block
modifier|*
name|bb_array
decl_stmt|;
name|sbitmap
name|wset
decl_stmt|;
name|bbs
operator|=
name|VEC_alloc
argument_list|(
name|basic_block
argument_list|,
name|heap
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|new_bbs
operator|=
name|VEC_alloc
argument_list|(
name|basic_block
argument_list|,
name|heap
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|temp_bitmap
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|VEC_quick_push
argument_list|(
name|basic_block
argument_list|,
name|bbs
argument_list|,
name|bb
argument_list|)
expr_stmt|;
block|}
name|wset
operator|=
name|sbitmap_alloc
argument_list|(
name|n_basic_blocks
operator|+
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|VEC_length
argument_list|(
name|basic_block
argument_list|,
name|bbs
argument_list|)
condition|)
block|{
name|bb_array
operator|=
name|VEC_address
argument_list|(
name|basic_block
argument_list|,
name|bbs
argument_list|)
expr_stmt|;
name|nel
operator|=
name|VEC_length
argument_list|(
name|basic_block
argument_list|,
name|bbs
argument_list|)
expr_stmt|;
name|qsort
argument_list|(
name|bb_array
argument_list|,
name|nel
argument_list|,
sizeof|sizeof
argument_list|(
name|basic_block
argument_list|)
argument_list|,
name|rpost_cmp
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|wset
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nel
condition|;
name|i
operator|++
control|)
block|{
name|edge_iterator
name|ei
decl_stmt|;
name|struct
name|bb_info
modifier|*
name|bb_info
decl_stmt|;
name|bitmap
name|bb_live_pavin
decl_stmt|,
name|bb_live_pavout
decl_stmt|;
name|bb
operator|=
name|bb_array
index|[
name|i
index|]
expr_stmt|;
name|bb_info
operator|=
name|BB_INFO
argument_list|(
name|bb
argument_list|)
expr_stmt|;
name|bb_live_pavin
operator|=
name|bb_info
operator|->
name|live_pavin
expr_stmt|;
name|bb_live_pavout
operator|=
name|bb_info
operator|->
name|live_pavout
expr_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->preds
argument_list|)
block|{
name|basic_block
name|pred
init|=
name|e
operator|->
name|src
decl_stmt|;
if|if
condition|(
name|pred
operator|->
name|index
operator|!=
name|ENTRY_BLOCK
condition|)
name|bitmap_ior_into
argument_list|(
name|bb_live_pavin
argument_list|,
name|BB_INFO
argument_list|(
name|pred
argument_list|)
operator|->
name|live_pavout
argument_list|)
expr_stmt|;
block|}
name|bitmap_and_into
argument_list|(
name|bb_live_pavin
argument_list|,
name|bb
operator|->
name|il
operator|.
name|rtl
operator|->
name|global_live_at_start
argument_list|)
expr_stmt|;
name|bitmap_ior_and_compl
argument_list|(
name|temp_bitmap
argument_list|,
name|bb_info
operator|->
name|avloc
argument_list|,
name|bb_live_pavin
argument_list|,
name|bb_info
operator|->
name|killed
argument_list|)
expr_stmt|;
name|bitmap_and_into
argument_list|(
name|temp_bitmap
argument_list|,
name|bb
operator|->
name|il
operator|.
name|rtl
operator|->
name|global_live_at_end
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bitmap_equal_p
argument_list|(
name|temp_bitmap
argument_list|,
name|bb_live_pavout
argument_list|)
condition|)
block|{
name|bitmap_copy
argument_list|(
name|bb_live_pavout
argument_list|,
name|temp_bitmap
argument_list|)
expr_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
block|{
name|succ
operator|=
name|e
operator|->
name|dest
expr_stmt|;
if|if
condition|(
name|succ
operator|->
name|index
operator|!=
name|EXIT_BLOCK
operator|&&
operator|!
name|TEST_BIT
argument_list|(
name|wset
argument_list|,
name|succ
operator|->
name|index
argument_list|)
condition|)
block|{
name|SET_BIT
argument_list|(
name|wset
argument_list|,
name|succ
operator|->
name|index
argument_list|)
expr_stmt|;
name|VEC_quick_push
argument_list|(
name|basic_block
argument_list|,
name|new_bbs
argument_list|,
name|succ
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|temp
operator|=
name|bbs
expr_stmt|;
name|bbs
operator|=
name|new_bbs
expr_stmt|;
name|new_bbs
operator|=
name|temp
expr_stmt|;
name|VEC_truncate
argument_list|(
name|basic_block
argument_list|,
name|new_bbs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|sbitmap_free
argument_list|(
name|wset
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|temp_bitmap
argument_list|)
expr_stmt|;
name|VEC_free
argument_list|(
name|basic_block
argument_list|,
name|heap
argument_list|,
name|new_bbs
argument_list|)
expr_stmt|;
name|VEC_free
argument_list|(
name|basic_block
argument_list|,
name|heap
argument_list|,
name|bbs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The function modifies partial availability information for two    special cases to prevent incorrect work of the subsequent passes    with the accurate live information based on the partial    availability.  */
end_comment

begin_function
specifier|static
name|void
name|modify_reg_pav
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|struct
name|bb_info
modifier|*
name|bb_info
decl_stmt|;
ifdef|#
directive|ifdef
name|STACK_REGS
name|int
name|i
decl_stmt|;
name|HARD_REG_SET
name|zero
decl_stmt|,
name|stack_hard_regs
decl_stmt|,
name|used
decl_stmt|;
name|bitmap
name|stack_regs
decl_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|zero
argument_list|)
expr_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|stack_hard_regs
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|FIRST_STACK_REG
init|;
name|i
operator|<=
name|LAST_STACK_REG
condition|;
name|i
operator|++
control|)
name|SET_HARD_REG_BIT
argument_list|(
name|stack_hard_regs
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|stack_regs
operator|=
name|BITMAP_ALLOC
argument_list|(
operator|&
name|greg_obstack
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|FIRST_PSEUDO_REGISTER
init|;
name|i
operator|<
name|max_regno
condition|;
name|i
operator|++
control|)
block|{
name|COPY_HARD_REG_SET
argument_list|(
name|used
argument_list|,
name|reg_class_contents
index|[
name|reg_preferred_class
argument_list|(
name|i
argument_list|)
index|]
argument_list|)
expr_stmt|;
name|IOR_HARD_REG_SET
argument_list|(
name|used
argument_list|,
name|reg_class_contents
index|[
name|reg_alternate_class
argument_list|(
name|i
argument_list|)
index|]
argument_list|)
expr_stmt|;
name|AND_HARD_REG_SET
argument_list|(
name|used
argument_list|,
name|stack_hard_regs
argument_list|)
expr_stmt|;
name|GO_IF_HARD_REG_EQUAL
argument_list|(
name|used
argument_list|,
name|zero
argument_list|,
name|skip
argument_list|)
expr_stmt|;
name|bitmap_set_bit
argument_list|(
name|stack_regs
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|skip
label|:
empty_stmt|;
block|}
endif|#
directive|endif
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|bb_info
operator|=
name|BB_INFO
argument_list|(
name|bb
argument_list|)
expr_stmt|;
comment|/* Reload can assign the same hard register to uninitialized 	 pseudo-register and early clobbered pseudo-register in an 	 insn if the pseudo-register is used first time in given BB 	 and not lived at the BB start.  To prevent this we don't 	 change life information for such pseudo-registers.  */
name|bitmap_ior_into
argument_list|(
name|bb_info
operator|->
name|live_pavin
argument_list|,
name|bb_info
operator|->
name|earlyclobber
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|STACK_REGS
comment|/* We can not use the same stack register for uninitialized 	 pseudo-register and another living pseudo-register because if the 	 uninitialized pseudo-register dies, subsequent pass reg-stack 	 will be confused (it will believe that the other register 	 dies).  */
name|bitmap_ior_into
argument_list|(
name|bb_info
operator|->
name|live_pavin
argument_list|,
name|stack_regs
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|STACK_REGS
name|BITMAP_FREE
argument_list|(
name|stack_regs
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* The following function makes live information more accurate by    modifying global_live_at_start and global_live_at_end of basic    blocks.     The standard GCC life analysis permits registers to live    uninitialized, for example:         R is never used        .....        Loop:          R is defined        ...        R is used.     With normal life_analysis, R would be live before "Loop:".    The result is that R causes many interferences that do not    serve any purpose.     After the function call a register lives at a program point    only if it is initialized on a path from CFG entry to the    program point.  */
end_comment

begin_function
specifier|static
name|void
name|make_accurate_live_analysis
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|struct
name|bb_info
modifier|*
name|bb_info
decl_stmt|;
name|max_regno
operator|=
name|max_reg_num
argument_list|()
expr_stmt|;
name|compact_blocks
argument_list|()
expr_stmt|;
name|allocate_bb_info
argument_list|()
expr_stmt|;
name|calculate_local_reg_bb_info
argument_list|()
expr_stmt|;
name|set_up_bb_rts_numbers
argument_list|()
expr_stmt|;
name|calculate_reg_pav
argument_list|()
expr_stmt|;
name|modify_reg_pav
argument_list|()
expr_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|bb_info
operator|=
name|BB_INFO
argument_list|(
name|bb
argument_list|)
expr_stmt|;
name|bitmap_and_into
argument_list|(
name|bb
operator|->
name|il
operator|.
name|rtl
operator|->
name|global_live_at_start
argument_list|,
name|bb_info
operator|->
name|live_pavin
argument_list|)
expr_stmt|;
name|bitmap_and_into
argument_list|(
name|bb
operator|->
name|il
operator|.
name|rtl
operator|->
name|global_live_at_end
argument_list|,
name|bb_info
operator|->
name|live_pavout
argument_list|)
expr_stmt|;
block|}
name|free_bb_info
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Run old register allocator.  Return TRUE if we must exit    rest_of_compilation upon return.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|rest_of_handle_global_alloc
parameter_list|(
name|void
parameter_list|)
block|{
name|bool
name|failure
decl_stmt|;
comment|/* If optimizing, allocate remaining pseudo-regs.  Do the reload      pass fixing up any insns that are invalid.  */
if|if
condition|(
name|optimize
condition|)
name|failure
operator|=
name|global_alloc
argument_list|()
expr_stmt|;
else|else
block|{
name|build_insn_chain
argument_list|(
name|get_insns
argument_list|()
argument_list|)
expr_stmt|;
name|failure
operator|=
name|reload
argument_list|(
name|get_insns
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dump_enabled_p
argument_list|(
name|pass_global_alloc
operator|.
name|static_pass_number
argument_list|)
condition|)
block|{
name|timevar_push
argument_list|(
name|TV_DUMP
argument_list|)
expr_stmt|;
name|dump_global_regs
argument_list|(
name|dump_file
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_DUMP
argument_list|)
expr_stmt|;
block|}
name|gcc_assert
argument_list|(
name|reload_completed
operator|||
name|failure
argument_list|)
expr_stmt|;
name|reload_completed
operator|=
operator|!
name|failure
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|tree_opt_pass
name|pass_global_alloc
init|=
block|{
literal|"greg"
block|,
comment|/* name */
name|NULL
block|,
comment|/* gate */
name|rest_of_handle_global_alloc
block|,
comment|/* execute */
name|NULL
block|,
comment|/* sub */
name|NULL
block|,
comment|/* next */
literal|0
block|,
comment|/* static_pass_number */
name|TV_GLOBAL_ALLOC
block|,
comment|/* tv_id */
literal|0
block|,
comment|/* properties_required */
literal|0
block|,
comment|/* properties_provided */
literal|0
block|,
comment|/* properties_destroyed */
literal|0
block|,
comment|/* todo_flags_start */
name|TODO_dump_func
operator||
name|TODO_ggc_collect
block|,
comment|/* todo_flags_finish */
literal|'g'
comment|/* letter */
block|}
decl_stmt|;
end_decl_stmt

end_unit

