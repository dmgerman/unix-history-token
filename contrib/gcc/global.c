begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Allocate registers for pseudo-registers that span basic blocks.    Copyright (C) 1987, 88, 91, 94, 96-98, 1999 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"machmode.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"reload.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_comment
comment|/* This pass of the compiler performs global register allocation.    It assigns hard register numbers to all the pseudo registers    that were not handled in local_alloc.  Assignments are recorded    in the vector reg_renumber, not by changing the rtl code.    (Such changes are made by final).  The entry point is    the function global_alloc.     After allocation is complete, the reload pass is run as a subroutine    of this pass, so that when a pseudo reg loses its hard reg due to    spilling it is possible to make a second attempt to find a hard    reg for it.  The reload pass is independent in other respects    and it is run even when stupid register allocation is in use.     1. Assign allocation-numbers (allocnos) to the pseudo-registers    still needing allocations and to the pseudo-registers currently    allocated by local-alloc which may be spilled by reload.    Set up tables reg_allocno and allocno_reg to map     reg numbers to allocnos and vice versa.    max_allocno gets the number of allocnos in use.     2. Allocate a max_allocno by max_allocno conflict bit matrix and clear it.    Allocate a max_allocno by FIRST_PSEUDO_REGISTER conflict matrix    for conflicts between allocnos and explicit hard register use    (which includes use of pseudo-registers allocated by local_alloc).     3. For each basic block     walk forward through the block, recording which     pseudo-registers and which hardware registers are live.     Build the conflict matrix between the pseudo-registers     and another of pseudo-registers versus hardware registers.     Also record the preferred hardware registers     for each pseudo-register.     4. Sort a table of the allocnos into order of    desirability of the variables.     5. Allocate the variables in that order; each if possible into    a preferred register, else into another register.  */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Number of pseudo-registers which are candidates for allocation. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|max_allocno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by (pseudo) reg number, gives the allocno, or -1    for pseudo registers which are not to be allocated.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|reg_allocno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by allocno, gives the reg number.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|allocno_reg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A vector of the integers from 0 to max_allocno-1,    sorted in the order of first-to-be-allocated first.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|allocno_order
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by an allocno, gives the number of consecutive    hard registers needed by that pseudo reg.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|allocno_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by (pseudo) reg number, gives the number of another    lower-numbered pseudo reg which can share a hard reg with this pseudo    *even if the two pseudos would otherwise appear to conflict*.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|reg_may_share
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Define the number of bits in each element of `conflicts' and what    type that element has.  We use the largest integer format on the    host machine.  */
end_comment

begin_define
define|#
directive|define
name|INT_BITS
value|HOST_BITS_PER_WIDE_INT
end_define

begin_define
define|#
directive|define
name|INT_TYPE
value|HOST_WIDE_INT
end_define

begin_comment
comment|/* max_allocno by max_allocno array of bits,    recording whether two allocno's conflict (can't go in the same    hardware register).     `conflicts' is not symmetric; a conflict between allocno's i and j    is recorded either in element i,j or in element j,i.  */
end_comment

begin_decl_stmt
specifier|static
name|INT_TYPE
modifier|*
name|conflicts
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of ints require to hold max_allocno bits.    This is the length of a row in `conflicts'.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|allocno_row_words
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Two macros to test or store 1 in an element of `conflicts'.  */
end_comment

begin_define
define|#
directive|define
name|CONFLICTP
parameter_list|(
name|I
parameter_list|,
name|J
parameter_list|)
define|\
value|(conflicts[(I) * allocno_row_words + (J) / INT_BITS]	\& ((INT_TYPE) 1<< ((J) % INT_BITS)))
end_define

begin_define
define|#
directive|define
name|SET_CONFLICT
parameter_list|(
name|I
parameter_list|,
name|J
parameter_list|)
define|\
value|(conflicts[(I) * allocno_row_words + (J) / INT_BITS]	\   |= ((INT_TYPE) 1<< ((J) % INT_BITS)))
end_define

begin_comment
comment|/* Set of hard regs currently live (during scan of all insns).  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
name|hard_regs_live
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by N, set of hard regs conflicting with allocno N.  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
modifier|*
name|hard_reg_conflicts
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by N, set of hard regs preferred by allocno N.    This is used to make allocnos go into regs that are copied to or from them,    when possible, to reduce register shuffling.  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
modifier|*
name|hard_reg_preferences
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Similar, but just counts register preferences made in simple copy    operations, rather than arithmetic.  These are given priority because    we can always eliminate an insn by using these, but using a register    in the above list won't always eliminate an insn.  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
modifier|*
name|hard_reg_copy_preferences
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Similar to hard_reg_preferences, but includes bits for subsequent    registers when an allocno is multi-word.  The above variable is used for    allocation while this is used to build reg_someone_prefers, below.  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
modifier|*
name|hard_reg_full_preferences
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by N, set of hard registers that some later allocno has a    preference for.  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
modifier|*
name|regs_someone_prefers
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set of registers that global-alloc isn't supposed to use.  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
name|no_global_alloc_regs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set of registers used so far.  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
name|regs_used_so_far
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of calls crossed by each allocno.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|allocno_calls_crossed
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of refs (weighted) to each allocno.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|allocno_n_refs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Guess at live length of each allocno.    This is actually the max of the live lengths of the regs.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|allocno_live_length
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of refs (weighted) to each hard reg, as used by local alloc.    It is zero for a reg that contains global pseudos or is explicitly used.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|local_reg_n_refs
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Guess at live length of each hard reg, as used by local alloc.    This is actually the sum of the live lengths of the specific regs.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|local_reg_live_length
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Test a bit in TABLE, a vector of HARD_REG_SETs,    for vector element I, and hard register number J.  */
end_comment

begin_define
define|#
directive|define
name|REGBITP
parameter_list|(
name|TABLE
parameter_list|,
name|I
parameter_list|,
name|J
parameter_list|)
value|TEST_HARD_REG_BIT (TABLE[I], J)
end_define

begin_comment
comment|/* Set to 1 a bit in a vector of HARD_REG_SETs.  Works like REGBITP.  */
end_comment

begin_define
define|#
directive|define
name|SET_REGBIT
parameter_list|(
name|TABLE
parameter_list|,
name|I
parameter_list|,
name|J
parameter_list|)
value|SET_HARD_REG_BIT (TABLE[I], J)
end_define

begin_comment
comment|/* Bit mask for allocnos live at current point in the scan.  */
end_comment

begin_decl_stmt
specifier|static
name|INT_TYPE
modifier|*
name|allocnos_live
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Test, set or clear bit number I in allocnos_live,    a bit vector indexed by allocno.  */
end_comment

begin_define
define|#
directive|define
name|ALLOCNO_LIVE_P
parameter_list|(
name|I
parameter_list|)
define|\
value|(allocnos_live[(I) / INT_BITS]& ((INT_TYPE) 1<< ((I) % INT_BITS)))
end_define

begin_define
define|#
directive|define
name|SET_ALLOCNO_LIVE
parameter_list|(
name|I
parameter_list|)
define|\
value|(allocnos_live[(I) / INT_BITS] |= ((INT_TYPE) 1<< ((I) % INT_BITS)))
end_define

begin_define
define|#
directive|define
name|CLEAR_ALLOCNO_LIVE
parameter_list|(
name|I
parameter_list|)
define|\
value|(allocnos_live[(I) / INT_BITS]&= ~((INT_TYPE) 1<< ((I) % INT_BITS)))
end_define

begin_comment
comment|/* This is turned off because it doesn't work right for DImode.    (And it is only used for DImode, so the other cases are worthless.)    The problem is that it isn't true that there is NO possibility of conflict;    only that there is no conflict if the two pseudos get the exact same regs.    If they were allocated with a partial overlap, there would be a conflict.    We can't safely turn off the conflict unless we have another way to    prevent the partial overlap.     Idea: change hard_reg_conflicts so that instead of recording which    hard regs the allocno may not overlap, it records where the allocno    may not start.  Change both where it is used and where it is updated.    Then there is a way to record that (reg:DI 108) may start at 10    but not at 9 or 11.  There is still the question of how to record    this semi-conflict between two pseudos.  */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Reg pairs for which conflict after the current insn    is inhibited by a REG_NO_CONFLICT note.    If the table gets full, we ignore any other notes--that is conservative.  */
end_comment

begin_define
define|#
directive|define
name|NUM_NO_CONFLICT_PAIRS
value|4
end_define

begin_comment
comment|/* Number of pairs in use in this insn.  */
end_comment

begin_endif
unit|int n_no_conflict_pairs; static struct { int allocno1, allocno2;}   no_conflict_pairs[NUM_NO_CONFLICT_PAIRS];
endif|#
directive|endif
end_endif

begin_comment
comment|/* 0 */
end_comment

begin_comment
comment|/* Record all regs that are set in any one insn.    Communication from mark_reg_{store,clobber} and global_conflicts.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
modifier|*
name|regs_set
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|n_regs_set
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* All registers that can be eliminated.  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
name|eliminable_regset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|allocno_compare
name|PROTO
argument_list|(
operator|(
specifier|const
name|GENERIC_PTR
operator|,
specifier|const
name|GENERIC_PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|global_conflicts
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|expand_preferences
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|prune_preferences
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|find_reg
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|HARD_REG_SET
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|record_one_conflict
name|PROTO
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|record_conflicts
name|PROTO
argument_list|(
operator|(
name|int
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mark_reg_store
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mark_reg_clobber
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mark_reg_conflicts
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mark_reg_death
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mark_reg_live_nc
name|PROTO
argument_list|(
operator|(
name|int
operator|,
expr|enum
name|machine_mode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_preference
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dump_conflicts
name|PROTO
argument_list|(
operator|(
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|reg_becomes_live
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|reg_dies
name|PROTO
argument_list|(
operator|(
name|int
operator|,
expr|enum
name|machine_mode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|build_insn_chain
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Perform allocation of pseudo-registers not allocated by local_alloc.    FILE is a file to output debugging information on,    or zero if such output is not desired.     Return value is nonzero if reload failed    and we must not do any more for this function.  */
end_comment

begin_function
name|int
name|global_alloc
parameter_list|(
name|file
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
name|int
name|retval
decl_stmt|;
ifdef|#
directive|ifdef
name|ELIMINABLE_REGS
specifier|static
struct|struct
block|{
name|int
name|from
decl_stmt|,
name|to
decl_stmt|;
block|}
name|eliminables
index|[]
init|=
name|ELIMINABLE_REGS
struct|;
endif|#
directive|endif
name|int
name|need_fp
init|=
operator|(
operator|!
name|flag_omit_frame_pointer
ifdef|#
directive|ifdef
name|EXIT_IGNORE_STACK
operator|||
operator|(
name|current_function_calls_alloca
operator|&&
name|EXIT_IGNORE_STACK
operator|)
endif|#
directive|endif
operator|||
name|FRAME_POINTER_REQUIRED
operator|)
decl_stmt|;
specifier|register
name|size_t
name|i
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|max_allocno
operator|=
literal|0
expr_stmt|;
comment|/* A machine may have certain hard registers that      are safe to use only within a basic block.  */
name|CLEAR_HARD_REG_SET
argument_list|(
name|no_global_alloc_regs
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OVERLAPPING_REGNO_P
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|OVERLAPPING_REGNO_P
argument_list|(
name|i
argument_list|)
condition|)
name|SET_HARD_REG_BIT
argument_list|(
name|no_global_alloc_regs
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Build the regset of all eliminable registers and show we can't use those      that we already know won't be eliminated.  */
ifdef|#
directive|ifdef
name|ELIMINABLE_REGS
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
name|eliminables
operator|/
sizeof|sizeof
name|eliminables
index|[
literal|0
index|]
condition|;
name|i
operator|++
control|)
block|{
name|SET_HARD_REG_BIT
argument_list|(
name|eliminable_regset
argument_list|,
name|eliminables
index|[
name|i
index|]
operator|.
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CAN_ELIMINATE
argument_list|(
name|eliminables
index|[
name|i
index|]
operator|.
name|from
argument_list|,
name|eliminables
index|[
name|i
index|]
operator|.
name|to
argument_list|)
operator|||
operator|(
name|eliminables
index|[
name|i
index|]
operator|.
name|to
operator|==
name|STACK_POINTER_REGNUM
operator|&&
name|need_fp
operator|)
condition|)
name|SET_HARD_REG_BIT
argument_list|(
name|no_global_alloc_regs
argument_list|,
name|eliminables
index|[
name|i
index|]
operator|.
name|from
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|FRAME_POINTER_REGNUM
operator|!=
name|HARD_FRAME_POINTER_REGNUM
name|SET_HARD_REG_BIT
argument_list|(
name|eliminable_regset
argument_list|,
name|HARD_FRAME_POINTER_REGNUM
argument_list|)
expr_stmt|;
if|if
condition|(
name|need_fp
condition|)
name|SET_HARD_REG_BIT
argument_list|(
name|no_global_alloc_regs
argument_list|,
name|HARD_FRAME_POINTER_REGNUM
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
name|SET_HARD_REG_BIT
argument_list|(
name|eliminable_regset
argument_list|,
name|FRAME_POINTER_REGNUM
argument_list|)
expr_stmt|;
if|if
condition|(
name|need_fp
condition|)
name|SET_HARD_REG_BIT
argument_list|(
name|no_global_alloc_regs
argument_list|,
name|FRAME_POINTER_REGNUM
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Track which registers have already been used.  Start with registers      explicitly in the rtl, then registers allocated by local register      allocation.  */
name|CLEAR_HARD_REG_SET
argument_list|(
name|regs_used_so_far
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LEAF_REGISTERS
comment|/* If we are doing the leaf function optimization, and this is a leaf      function, it means that the registers that take work to save are those      that need a register window.  So prefer the ones that can be used in      a leaf function.  */
block|{
name|char
modifier|*
name|cheap_regs
decl_stmt|;
specifier|static
name|char
name|leaf_regs
index|[]
init|=
name|LEAF_REGISTERS
decl_stmt|;
if|if
condition|(
name|only_leaf_regs_used
argument_list|()
operator|&&
name|leaf_function_p
argument_list|()
condition|)
name|cheap_regs
operator|=
name|leaf_regs
expr_stmt|;
else|else
name|cheap_regs
operator|=
name|call_used_regs
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|i
index|]
operator|||
name|cheap_regs
index|[
name|i
index|]
condition|)
name|SET_HARD_REG_BIT
argument_list|(
name|regs_used_so_far
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* We consider registers that do not have to be saved over calls as if      they were already used since there is no cost in using them.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|i
index|]
operator|||
name|call_used_regs
index|[
name|i
index|]
condition|)
name|SET_HARD_REG_BIT
argument_list|(
name|regs_used_so_far
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
name|FIRST_PSEUDO_REGISTER
init|;
name|i
operator|<
operator|(
name|size_t
operator|)
name|max_regno
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|reg_renumber
index|[
name|i
index|]
operator|>=
literal|0
condition|)
name|SET_HARD_REG_BIT
argument_list|(
name|regs_used_so_far
argument_list|,
name|reg_renumber
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* Establish mappings from register number to allocation number      and vice versa.  In the process, count the allocnos.  */
name|reg_allocno
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
name|reg_allocno
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Initialize the shared-hard-reg mapping      from the list of pairs that may share.  */
name|reg_may_share
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|reg_may_share
argument_list|,
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
name|regs_may_share
init|;
name|x
condition|;
name|x
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|int
name|r1
init|=
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|r2
init|=
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|r1
operator|>
name|r2
condition|)
name|reg_may_share
index|[
name|r1
index|]
operator|=
name|r2
expr_stmt|;
else|else
name|reg_may_share
index|[
name|r2
index|]
operator|=
name|r1
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|FIRST_PSEUDO_REGISTER
init|;
name|i
operator|<
operator|(
name|size_t
operator|)
name|max_regno
condition|;
name|i
operator|++
control|)
comment|/* Note that reg_live_length[i]< 0 indicates a "constant" reg        that we are supposed to refrain from putting in a hard reg.        -2 means do make an allocno but don't allocate it.  */
if|if
condition|(
name|REG_N_REFS
argument_list|(
name|i
argument_list|)
operator|!=
literal|0
operator|&&
name|REG_LIVE_LENGTH
argument_list|(
name|i
argument_list|)
operator|!=
operator|-
literal|1
comment|/* Don't allocate pseudos that cross calls, 	   if this function receives a nonlocal goto.  */
operator|&&
operator|(
operator|!
name|current_function_has_nonlocal_label
operator|||
name|REG_N_CALLS_CROSSED
argument_list|(
name|i
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|reg_renumber
index|[
name|i
index|]
operator|<
literal|0
operator|&&
name|reg_may_share
index|[
name|i
index|]
operator|&&
name|reg_allocno
index|[
name|reg_may_share
index|[
name|i
index|]
index|]
operator|>=
literal|0
condition|)
name|reg_allocno
index|[
name|i
index|]
operator|=
name|reg_allocno
index|[
name|reg_may_share
index|[
name|i
index|]
index|]
expr_stmt|;
else|else
name|reg_allocno
index|[
name|i
index|]
operator|=
name|max_allocno
operator|++
expr_stmt|;
if|if
condition|(
name|REG_LIVE_LENGTH
argument_list|(
name|i
argument_list|)
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
else|else
name|reg_allocno
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|allocno_reg
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|max_allocno
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|allocno_size
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|max_allocno
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|allocno_calls_crossed
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|max_allocno
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|allocno_n_refs
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|max_allocno
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|allocno_live_length
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|max_allocno
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|allocno_size
argument_list|,
name|max_allocno
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|allocno_calls_crossed
argument_list|,
name|max_allocno
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|allocno_n_refs
argument_list|,
name|max_allocno
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|allocno_live_length
argument_list|,
name|max_allocno
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|FIRST_PSEUDO_REGISTER
init|;
name|i
operator|<
operator|(
name|size_t
operator|)
name|max_regno
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|reg_allocno
index|[
name|i
index|]
operator|>=
literal|0
condition|)
block|{
name|int
name|allocno
init|=
name|reg_allocno
index|[
name|i
index|]
decl_stmt|;
name|allocno_reg
index|[
name|allocno
index|]
operator|=
name|i
expr_stmt|;
name|allocno_size
index|[
name|allocno
index|]
operator|=
name|PSEUDO_REGNO_SIZE
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|allocno_calls_crossed
index|[
name|allocno
index|]
operator|+=
name|REG_N_CALLS_CROSSED
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|allocno_n_refs
index|[
name|allocno
index|]
operator|+=
name|REG_N_REFS
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|allocno_live_length
index|[
name|allocno
index|]
operator|<
name|REG_LIVE_LENGTH
argument_list|(
name|i
argument_list|)
condition|)
name|allocno_live_length
index|[
name|allocno
index|]
operator|=
name|REG_LIVE_LENGTH
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
comment|/* Calculate amount of usage of each hard reg by pseudos      allocated by local-alloc.  This is to see if we want to      override it.  */
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|local_reg_live_length
argument_list|,
sizeof|sizeof
name|local_reg_live_length
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|local_reg_n_refs
argument_list|,
sizeof|sizeof
name|local_reg_n_refs
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|FIRST_PSEUDO_REGISTER
init|;
name|i
operator|<
operator|(
name|size_t
operator|)
name|max_regno
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|reg_renumber
index|[
name|i
index|]
operator|>=
literal|0
condition|)
block|{
name|int
name|regno
init|=
name|reg_renumber
index|[
name|i
index|]
decl_stmt|;
name|int
name|endregno
init|=
name|regno
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|PSEUDO_REGNO_MODE
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|regno
init|;
name|j
operator|<
name|endregno
condition|;
name|j
operator|++
control|)
block|{
name|local_reg_n_refs
index|[
name|j
index|]
operator|+=
name|REG_N_REFS
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|local_reg_live_length
index|[
name|j
index|]
operator|+=
name|REG_LIVE_LENGTH
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* We can't override local-alloc for a reg used not just by local-alloc.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|i
index|]
condition|)
name|local_reg_n_refs
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Allocate the space for the conflict and preference tables and      initialize them.  */
name|hard_reg_conflicts
operator|=
operator|(
name|HARD_REG_SET
operator|*
operator|)
name|alloca
argument_list|(
name|max_allocno
operator|*
sizeof|sizeof
argument_list|(
name|HARD_REG_SET
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|hard_reg_conflicts
argument_list|,
name|max_allocno
operator|*
sizeof|sizeof
argument_list|(
name|HARD_REG_SET
argument_list|)
argument_list|)
expr_stmt|;
name|hard_reg_preferences
operator|=
operator|(
name|HARD_REG_SET
operator|*
operator|)
name|alloca
argument_list|(
name|max_allocno
operator|*
sizeof|sizeof
argument_list|(
name|HARD_REG_SET
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|hard_reg_preferences
argument_list|,
name|max_allocno
operator|*
sizeof|sizeof
argument_list|(
name|HARD_REG_SET
argument_list|)
argument_list|)
expr_stmt|;
name|hard_reg_copy_preferences
operator|=
operator|(
name|HARD_REG_SET
operator|*
operator|)
name|alloca
argument_list|(
name|max_allocno
operator|*
sizeof|sizeof
argument_list|(
name|HARD_REG_SET
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|hard_reg_copy_preferences
argument_list|,
name|max_allocno
operator|*
sizeof|sizeof
argument_list|(
name|HARD_REG_SET
argument_list|)
argument_list|)
expr_stmt|;
name|hard_reg_full_preferences
operator|=
operator|(
name|HARD_REG_SET
operator|*
operator|)
name|alloca
argument_list|(
name|max_allocno
operator|*
sizeof|sizeof
argument_list|(
name|HARD_REG_SET
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|hard_reg_full_preferences
argument_list|,
name|max_allocno
operator|*
sizeof|sizeof
argument_list|(
name|HARD_REG_SET
argument_list|)
argument_list|)
expr_stmt|;
name|regs_someone_prefers
operator|=
operator|(
name|HARD_REG_SET
operator|*
operator|)
name|alloca
argument_list|(
name|max_allocno
operator|*
sizeof|sizeof
argument_list|(
name|HARD_REG_SET
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|regs_someone_prefers
argument_list|,
name|max_allocno
operator|*
sizeof|sizeof
argument_list|(
name|HARD_REG_SET
argument_list|)
argument_list|)
expr_stmt|;
name|allocno_row_words
operator|=
operator|(
name|max_allocno
operator|+
name|INT_BITS
operator|-
literal|1
operator|)
operator|/
name|INT_BITS
expr_stmt|;
comment|/* We used to use alloca here, but the size of what it would try to      allocate would occasionally cause it to exceed the stack limit and      cause unpredictable core dumps.  Some examples were> 2Mb in size.  */
name|conflicts
operator|=
operator|(
name|INT_TYPE
operator|*
operator|)
name|xmalloc
argument_list|(
name|max_allocno
operator|*
name|allocno_row_words
operator|*
sizeof|sizeof
argument_list|(
name|INT_TYPE
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|conflicts
argument_list|,
name|max_allocno
operator|*
name|allocno_row_words
operator|*
sizeof|sizeof
argument_list|(
name|INT_TYPE
argument_list|)
argument_list|)
expr_stmt|;
name|allocnos_live
operator|=
operator|(
name|INT_TYPE
operator|*
operator|)
name|alloca
argument_list|(
name|allocno_row_words
operator|*
sizeof|sizeof
argument_list|(
name|INT_TYPE
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If there is work to be done (at least one reg to allocate),      perform global conflict analysis and allocate the regs.  */
if|if
condition|(
name|max_allocno
operator|>
literal|0
condition|)
block|{
comment|/* Scan all the insns and compute the conflicts among allocnos 	 and between allocnos and hard regs.  */
name|global_conflicts
argument_list|()
expr_stmt|;
comment|/* Eliminate conflicts between pseudos and eliminable registers.  If 	 the register is not eliminated, the pseudo won't really be able to 	 live in the eliminable register, so the conflict doesn't matter. 	 If we do eliminate the register, the conflict will no longer exist. 	 So in either case, we can ignore the conflict.  Likewise for 	 preferences.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|size_t
operator|)
name|max_allocno
condition|;
name|i
operator|++
control|)
block|{
name|AND_COMPL_HARD_REG_SET
argument_list|(
name|hard_reg_conflicts
index|[
name|i
index|]
argument_list|,
name|eliminable_regset
argument_list|)
expr_stmt|;
name|AND_COMPL_HARD_REG_SET
argument_list|(
name|hard_reg_copy_preferences
index|[
name|i
index|]
argument_list|,
name|eliminable_regset
argument_list|)
expr_stmt|;
name|AND_COMPL_HARD_REG_SET
argument_list|(
name|hard_reg_preferences
index|[
name|i
index|]
argument_list|,
name|eliminable_regset
argument_list|)
expr_stmt|;
block|}
comment|/* Try to expand the preferences by merging them between allocnos.  */
name|expand_preferences
argument_list|()
expr_stmt|;
comment|/* Determine the order to allocate the remaining pseudo registers.  */
name|allocno_order
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|max_allocno
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|size_t
operator|)
name|max_allocno
condition|;
name|i
operator|++
control|)
name|allocno_order
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
comment|/* Default the size to 1, since allocno_compare uses it to divide by. 	 Also convert allocno_live_length of zero to -1.  A length of zero 	 can occur when all the registers for that allocno have reg_live_length 	 equal to -2.  In this case, we want to make an allocno, but not 	 allocate it.  So avoid the divide-by-zero and set it to a low 	 priority.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|size_t
operator|)
name|max_allocno
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|allocno_size
index|[
name|i
index|]
operator|==
literal|0
condition|)
name|allocno_size
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|allocno_live_length
index|[
name|i
index|]
operator|==
literal|0
condition|)
name|allocno_live_length
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|qsort
argument_list|(
name|allocno_order
argument_list|,
name|max_allocno
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
name|allocno_compare
argument_list|)
expr_stmt|;
name|prune_preferences
argument_list|()
expr_stmt|;
if|if
condition|(
name|file
condition|)
name|dump_conflicts
argument_list|(
name|file
argument_list|)
expr_stmt|;
comment|/* Try allocating them, one by one, in that order, 	 except for parameters marked with reg_live_length[regno] == -2.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|size_t
operator|)
name|max_allocno
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|reg_renumber
index|[
name|allocno_reg
index|[
name|allocno_order
index|[
name|i
index|]
index|]
index|]
operator|<
literal|0
operator|&&
name|REG_LIVE_LENGTH
argument_list|(
name|allocno_reg
index|[
name|allocno_order
index|[
name|i
index|]
index|]
argument_list|)
operator|>=
literal|0
condition|)
block|{
comment|/* If we have more than one register class, 	       first try allocating in the class that is cheapest 	       for this pseudo-reg.  If that fails, try any reg.  */
if|if
condition|(
name|N_REG_CLASSES
operator|>
literal|1
condition|)
block|{
name|find_reg
argument_list|(
name|allocno_order
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_renumber
index|[
name|allocno_reg
index|[
name|allocno_order
index|[
name|i
index|]
index|]
index|]
operator|>=
literal|0
condition|)
continue|continue;
block|}
if|if
condition|(
name|reg_alternate_class
argument_list|(
name|allocno_reg
index|[
name|allocno_order
index|[
name|i
index|]
index|]
argument_list|)
operator|!=
name|NO_REGS
condition|)
name|find_reg
argument_list|(
name|allocno_order
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Do the reloads now while the allocno data still exist, so that we can      try to assign new hard regs to any pseudo regs that are spilled.  */
if|#
directive|if
literal|0
comment|/* We need to eliminate regs even if there is no rtl code, 	 for the sake of debugging information.  */
block|if (n_basic_blocks> 0)
endif|#
directive|endif
block|{
name|build_insn_chain
argument_list|(
name|get_insns
argument_list|()
argument_list|)
expr_stmt|;
name|retval
operator|=
name|reload
argument_list|(
name|get_insns
argument_list|()
argument_list|,
literal|1
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|conflicts
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* Sort predicate for ordering the allocnos.    Returns -1 (1) if *v1 should be allocated before (after) *v2.  */
end_comment

begin_function
specifier|static
name|int
name|allocno_compare
parameter_list|(
name|v1p
parameter_list|,
name|v2p
parameter_list|)
specifier|const
name|GENERIC_PTR
name|v1p
decl_stmt|;
specifier|const
name|GENERIC_PTR
name|v2p
decl_stmt|;
block|{
name|int
name|v1
init|=
operator|*
operator|(
name|int
operator|*
operator|)
name|v1p
decl_stmt|,
name|v2
init|=
operator|*
operator|(
name|int
operator|*
operator|)
name|v2p
decl_stmt|;
comment|/* Note that the quotient will never be bigger than      the value of floor_log2 times the maximum number of      times a register can occur in one insn (surely less than 100).      Multiplying this by 10000 can't overflow.  */
specifier|register
name|int
name|pri1
init|=
operator|(
operator|(
call|(
name|double
call|)
argument_list|(
name|floor_log2
argument_list|(
name|allocno_n_refs
index|[
name|v1
index|]
argument_list|)
operator|*
name|allocno_n_refs
index|[
name|v1
index|]
argument_list|)
operator|/
name|allocno_live_length
index|[
name|v1
index|]
operator|)
operator|*
literal|10000
operator|*
name|allocno_size
index|[
name|v1
index|]
operator|)
decl_stmt|;
specifier|register
name|int
name|pri2
init|=
operator|(
operator|(
call|(
name|double
call|)
argument_list|(
name|floor_log2
argument_list|(
name|allocno_n_refs
index|[
name|v2
index|]
argument_list|)
operator|*
name|allocno_n_refs
index|[
name|v2
index|]
argument_list|)
operator|/
name|allocno_live_length
index|[
name|v2
index|]
operator|)
operator|*
literal|10000
operator|*
name|allocno_size
index|[
name|v2
index|]
operator|)
decl_stmt|;
if|if
condition|(
name|pri2
operator|-
name|pri1
condition|)
return|return
name|pri2
operator|-
name|pri1
return|;
comment|/* If regs are equally good, sort by allocno,      so that the results of qsort leave nothing to chance.  */
return|return
name|v1
operator|-
name|v2
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Scan the rtl code and record all conflicts and register preferences in the    conflict matrices and preference tables.  */
end_comment

begin_function
specifier|static
name|void
name|global_conflicts
parameter_list|()
block|{
specifier|register
name|int
name|b
decl_stmt|,
name|i
decl_stmt|;
specifier|register
name|rtx
name|insn
decl_stmt|;
name|int
modifier|*
name|block_start_allocnos
decl_stmt|;
comment|/* Make a vector that mark_reg_{store,clobber} will store in.  */
name|regs_set
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|max_parallel
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
operator|*
literal|2
argument_list|)
expr_stmt|;
name|block_start_allocnos
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|max_allocno
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|n_basic_blocks
condition|;
name|b
operator|++
control|)
block|{
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|allocnos_live
argument_list|,
name|allocno_row_words
operator|*
sizeof|sizeof
argument_list|(
name|INT_TYPE
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Initialize table of registers currently live 	 to the state at the beginning of this basic block. 	 This also marks the conflicts among them.  	 For pseudo-regs, there is only one bit for each one 	 no matter how many hard regs it occupies. 	 This is ok; we know the size from PSEUDO_REGNO_SIZE. 	 For explicit hard regs, we cannot know the size that way 	 since one hard reg can be used with various sizes. 	 Therefore, we must require that all the hard regs 	 implicitly live as part of a multi-word hard reg 	 are explicitly marked in basic_block_live_at_start.  */
block|{
specifier|register
name|regset
name|old
init|=
name|BASIC_BLOCK
argument_list|(
name|b
argument_list|)
operator|->
name|global_live_at_start
decl_stmt|;
name|int
name|ax
init|=
literal|0
decl_stmt|;
name|REG_SET_TO_HARD_REG_SET
argument_list|(
name|hard_regs_live
argument_list|,
name|old
argument_list|)
expr_stmt|;
name|EXECUTE_IF_SET_IN_REG_SET
argument_list|(
argument|old
argument_list|,
argument|FIRST_PSEUDO_REGISTER
argument_list|,
argument|i
argument_list|,
argument|{ 				     register int a = reg_allocno[i]; 				     if (a>=
literal|0
argument|) 				       { 					 SET_ALLOCNO_LIVE (a); 					 block_start_allocnos[ax++] = a; 				       } 				     else if ((a = reg_renumber[i])>=
literal|0
argument|) 				       mark_reg_live_nc 					 (a, PSEUDO_REGNO_MODE (i)); 				   }
argument_list|)
empty_stmt|;
comment|/* Record that each allocno now live conflicts with each other 	   allocno now live, and with each hard reg now live.  */
name|record_conflicts
argument_list|(
name|block_start_allocnos
argument_list|,
name|ax
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|STACK_REGS
block|{
comment|/* Pseudos can't go in stack regs at the start of a basic block 	     that can be reached through a computed goto, since reg-stack 	     can't handle computed gotos.  */
comment|/* ??? Seems more likely that reg-stack can't handle any abnormal 	     edges, critical or not, computed goto or otherwise.  */
name|edge
name|e
decl_stmt|;
for|for
control|(
name|e
operator|=
name|BASIC_BLOCK
argument_list|(
name|b
argument_list|)
operator|->
name|pred
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|pred_next
control|)
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_ABNORMAL
condition|)
break|break;
if|if
condition|(
name|e
operator|!=
name|NULL
condition|)
for|for
control|(
name|ax
operator|=
name|FIRST_STACK_REG
init|;
name|ax
operator|<=
name|LAST_STACK_REG
condition|;
name|ax
operator|++
control|)
name|record_one_conflict
argument_list|(
name|ax
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
name|insn
operator|=
name|BLOCK_HEAD
argument_list|(
name|b
argument_list|)
expr_stmt|;
comment|/* Scan the code of this basic block, noting which allocnos 	 and hard regs are born or die.  When one is born, 	 record a conflict with all others currently live.  */
while|while
condition|(
literal|1
condition|)
block|{
specifier|register
name|RTX_CODE
name|code
init|=
name|GET_CODE
argument_list|(
name|insn
argument_list|)
decl_stmt|;
specifier|register
name|rtx
name|link
decl_stmt|;
comment|/* Make regs_set an empty set.  */
name|n_regs_set
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|INSN
operator|||
name|code
operator|==
name|CALL_INSN
operator|||
name|code
operator|==
name|JUMP_INSN
condition|)
block|{
if|#
directive|if
literal|0
block|int i = 0; 	      for (link = REG_NOTES (insn); 		   link&& i< NUM_NO_CONFLICT_PAIRS; 		   link = XEXP (link, 1)) 		if (REG_NOTE_KIND (link) == REG_NO_CONFLICT) 		  { 		    no_conflict_pairs[i].allocno1 		      = reg_allocno[REGNO (SET_DEST (PATTERN (insn)))]; 		    no_conflict_pairs[i].allocno2 		      = reg_allocno[REGNO (XEXP (link, 0))]; 		    i++; 		  }
endif|#
directive|endif
comment|/* 0 */
comment|/* Mark any registers clobbered by INSN as live, 		 so they conflict with the inputs.  */
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|mark_reg_clobber
argument_list|)
expr_stmt|;
comment|/* Mark any registers dead after INSN as dead now.  */
for|for
control|(
name|link
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
name|REG_DEAD
condition|)
name|mark_reg_death
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Mark any registers set in INSN as live, 		 and mark them as conflicting with all other live regs. 		 Clobbers are processed again, so they conflict with 		 the registers that are set.  */
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|mark_reg_store
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AUTO_INC_DEC
for|for
control|(
name|link
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
name|REG_INC
condition|)
name|mark_reg_store
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* If INSN has multiple outputs, then any reg that dies here 		 and is used inside of an output 		 must conflict with the other outputs.  		 It is unsafe to use !single_set here since it will ignore an 		 unused output.  Just because an output is unused does not mean 		 the compiler can assume the side effect will not occur. 		 Consider if REG appears in the address of an output and we 		 reload the output.  If we allocate REG to the same hard 		 register as an unused output we could set the hard register 		 before the output reload insn.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|multiple_sets
argument_list|(
name|insn
argument_list|)
condition|)
for|for
control|(
name|link
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
name|REG_DEAD
condition|)
block|{
name|int
name|used_in_output
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|rtx
name|reg
init|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|rtx
name|set
init|=
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|set
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|!=
name|REG
operator|&&
operator|!
name|rtx_equal_p
argument_list|(
name|reg
argument_list|,
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|reg
argument_list|,
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
condition|)
name|used_in_output
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|used_in_output
condition|)
name|mark_reg_conflicts
argument_list|(
name|reg
argument_list|)
expr_stmt|;
block|}
comment|/* Mark any registers set in INSN and then never used.  */
while|while
condition|(
name|n_regs_set
operator|>
literal|0
condition|)
if|if
condition|(
name|find_regno_note
argument_list|(
name|insn
argument_list|,
name|REG_UNUSED
argument_list|,
name|REGNO
argument_list|(
name|regs_set
index|[
operator|--
name|n_regs_set
index|]
argument_list|)
argument_list|)
condition|)
name|mark_reg_death
argument_list|(
name|regs_set
index|[
name|n_regs_set
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|insn
operator|==
name|BLOCK_END
argument_list|(
name|b
argument_list|)
condition|)
break|break;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Expand the preference information by looking for cases where one allocno    dies in an insn that sets an allocno.  If those two allocnos don't conflict,    merge any preferences between those allocnos.  */
end_comment

begin_function
specifier|static
name|void
name|expand_preferences
parameter_list|()
block|{
name|rtx
name|insn
decl_stmt|;
name|rtx
name|link
decl_stmt|;
name|rtx
name|set
decl_stmt|;
comment|/* We only try to handle the most common cases here.  Most of the cases      where this wins are reg-reg copies.  */
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
literal|'i'
operator|&&
operator|(
name|set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|reg_allocno
index|[
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
index|]
operator|>=
literal|0
condition|)
for|for
control|(
name|link
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
name|REG_DEAD
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|reg_allocno
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
operator|>=
literal|0
operator|&&
operator|!
name|CONFLICTP
argument_list|(
name|reg_allocno
index|[
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
index|]
argument_list|,
name|reg_allocno
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
argument_list|)
operator|&&
operator|!
name|CONFLICTP
argument_list|(
name|reg_allocno
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
argument_list|,
name|reg_allocno
index|[
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
index|]
argument_list|)
condition|)
block|{
name|int
name|a1
init|=
name|reg_allocno
index|[
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
index|]
decl_stmt|;
name|int
name|a2
init|=
name|reg_allocno
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
decl_stmt|;
if|if
condition|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
operator|==
name|SET_SRC
argument_list|(
name|set
argument_list|)
condition|)
block|{
name|IOR_HARD_REG_SET
argument_list|(
name|hard_reg_copy_preferences
index|[
name|a1
index|]
argument_list|,
name|hard_reg_copy_preferences
index|[
name|a2
index|]
argument_list|)
expr_stmt|;
name|IOR_HARD_REG_SET
argument_list|(
name|hard_reg_copy_preferences
index|[
name|a2
index|]
argument_list|,
name|hard_reg_copy_preferences
index|[
name|a1
index|]
argument_list|)
expr_stmt|;
block|}
name|IOR_HARD_REG_SET
argument_list|(
name|hard_reg_preferences
index|[
name|a1
index|]
argument_list|,
name|hard_reg_preferences
index|[
name|a2
index|]
argument_list|)
expr_stmt|;
name|IOR_HARD_REG_SET
argument_list|(
name|hard_reg_preferences
index|[
name|a2
index|]
argument_list|,
name|hard_reg_preferences
index|[
name|a1
index|]
argument_list|)
expr_stmt|;
name|IOR_HARD_REG_SET
argument_list|(
name|hard_reg_full_preferences
index|[
name|a1
index|]
argument_list|,
name|hard_reg_full_preferences
index|[
name|a2
index|]
argument_list|)
expr_stmt|;
name|IOR_HARD_REG_SET
argument_list|(
name|hard_reg_full_preferences
index|[
name|a2
index|]
argument_list|,
name|hard_reg_full_preferences
index|[
name|a1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Prune the preferences for global registers to exclude registers that cannot    be used.        Compute `regs_someone_prefers', which is a bitmask of the hard registers    that are preferred by conflicting registers of lower priority.  If possible,    we will avoid using these registers.  */
end_comment

begin_function
specifier|static
name|void
name|prune_preferences
parameter_list|()
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|allocno
decl_stmt|;
comment|/* Scan least most important to most important.      For each allocno, remove from preferences registers that cannot be used,      either because of conflicts or register type.  Then compute all registers      preferred by each lower-priority register that conflicts.  */
for|for
control|(
name|i
operator|=
name|max_allocno
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|HARD_REG_SET
name|temp
decl_stmt|;
name|allocno
operator|=
name|allocno_order
index|[
name|i
index|]
expr_stmt|;
name|COPY_HARD_REG_SET
argument_list|(
name|temp
argument_list|,
name|hard_reg_conflicts
index|[
name|allocno
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|allocno_calls_crossed
index|[
name|allocno
index|]
operator|==
literal|0
condition|)
name|IOR_HARD_REG_SET
argument_list|(
name|temp
argument_list|,
name|fixed_reg_set
argument_list|)
expr_stmt|;
else|else
name|IOR_HARD_REG_SET
argument_list|(
name|temp
argument_list|,
name|call_used_reg_set
argument_list|)
expr_stmt|;
name|IOR_COMPL_HARD_REG_SET
argument_list|(
name|temp
argument_list|,
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|reg_preferred_class
argument_list|(
name|allocno_reg
index|[
name|allocno
index|]
argument_list|)
index|]
argument_list|)
expr_stmt|;
name|AND_COMPL_HARD_REG_SET
argument_list|(
name|hard_reg_preferences
index|[
name|allocno
index|]
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|AND_COMPL_HARD_REG_SET
argument_list|(
name|hard_reg_copy_preferences
index|[
name|allocno
index|]
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|AND_COMPL_HARD_REG_SET
argument_list|(
name|hard_reg_full_preferences
index|[
name|allocno
index|]
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|regs_someone_prefers
index|[
name|allocno
index|]
argument_list|)
expr_stmt|;
comment|/* Merge in the preferences of lower-priority registers (they have 	 already been pruned).  If we also prefer some of those registers, 	 don't exclude them unless we are of a smaller size (in which case 	 we want to give the lower-priority allocno the first chance for 	 these registers).  */
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
name|max_allocno
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|CONFLICTP
argument_list|(
name|allocno
argument_list|,
name|allocno_order
index|[
name|j
index|]
argument_list|)
operator|||
name|CONFLICTP
argument_list|(
name|allocno_order
index|[
name|j
index|]
argument_list|,
name|allocno
argument_list|)
condition|)
block|{
name|COPY_HARD_REG_SET
argument_list|(
name|temp
argument_list|,
name|hard_reg_full_preferences
index|[
name|allocno_order
index|[
name|j
index|]
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|allocno_size
index|[
name|allocno_order
index|[
name|j
index|]
index|]
operator|<=
name|allocno_size
index|[
name|allocno
index|]
condition|)
name|AND_COMPL_HARD_REG_SET
argument_list|(
name|temp
argument_list|,
name|hard_reg_full_preferences
index|[
name|allocno
index|]
argument_list|)
expr_stmt|;
name|IOR_HARD_REG_SET
argument_list|(
name|regs_someone_prefers
index|[
name|allocno
index|]
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Assign a hard register to ALLOCNO; look for one that is the beginning    of a long enough stretch of hard regs none of which conflicts with ALLOCNO.    The registers marked in PREFREGS are tried first.     LOSERS, if non-zero, is a HARD_REG_SET indicating registers that cannot    be used for this allocation.     If ALT_REGS_P is zero, consider only the preferred class of ALLOCNO's reg.    Otherwise ignore that preferred class and use the alternate class.     If ACCEPT_CALL_CLOBBERED is nonzero, accept a call-clobbered hard reg that    will have to be saved and restored at calls.     RETRYING is nonzero if this is called from retry_global_alloc.     If we find one, record it in reg_renumber.    If not, do nothing.  */
end_comment

begin_function
specifier|static
name|void
name|find_reg
parameter_list|(
name|allocno
parameter_list|,
name|losers
parameter_list|,
name|alt_regs_p
parameter_list|,
name|accept_call_clobbered
parameter_list|,
name|retrying
parameter_list|)
name|int
name|allocno
decl_stmt|;
name|HARD_REG_SET
name|losers
decl_stmt|;
name|int
name|alt_regs_p
decl_stmt|;
name|int
name|accept_call_clobbered
decl_stmt|;
name|int
name|retrying
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|best_reg
decl_stmt|,
name|pass
decl_stmt|;
ifdef|#
directive|ifdef
name|HARD_REG_SET
specifier|register
comment|/* Declare it register if it's a scalar.  */
endif|#
directive|endif
name|HARD_REG_SET
name|used
decl_stmt|,
name|used1
decl_stmt|,
name|used2
decl_stmt|;
name|enum
name|reg_class
name|class
init|=
operator|(
name|alt_regs_p
condition|?
name|reg_alternate_class
argument_list|(
name|allocno_reg
index|[
name|allocno
index|]
argument_list|)
else|:
name|reg_preferred_class
argument_list|(
name|allocno_reg
index|[
name|allocno
index|]
argument_list|)
operator|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|PSEUDO_REGNO_MODE
argument_list|(
name|allocno_reg
index|[
name|allocno
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|accept_call_clobbered
condition|)
name|COPY_HARD_REG_SET
argument_list|(
name|used1
argument_list|,
name|call_fixed_reg_set
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|allocno_calls_crossed
index|[
name|allocno
index|]
operator|==
literal|0
condition|)
name|COPY_HARD_REG_SET
argument_list|(
name|used1
argument_list|,
name|fixed_reg_set
argument_list|)
expr_stmt|;
else|else
name|COPY_HARD_REG_SET
argument_list|(
name|used1
argument_list|,
name|call_used_reg_set
argument_list|)
expr_stmt|;
comment|/* Some registers should not be allocated in global-alloc.  */
name|IOR_HARD_REG_SET
argument_list|(
name|used1
argument_list|,
name|no_global_alloc_regs
argument_list|)
expr_stmt|;
if|if
condition|(
name|losers
condition|)
name|IOR_HARD_REG_SET
argument_list|(
name|used1
argument_list|,
name|losers
argument_list|)
expr_stmt|;
name|IOR_COMPL_HARD_REG_SET
argument_list|(
name|used1
argument_list|,
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|class
index|]
argument_list|)
expr_stmt|;
name|COPY_HARD_REG_SET
argument_list|(
name|used2
argument_list|,
name|used1
argument_list|)
expr_stmt|;
name|IOR_HARD_REG_SET
argument_list|(
name|used1
argument_list|,
name|hard_reg_conflicts
index|[
name|allocno
index|]
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CLASS_CANNOT_CHANGE_SIZE
if|if
condition|(
name|REG_CHANGES_SIZE
argument_list|(
name|allocno_reg
index|[
name|allocno
index|]
argument_list|)
condition|)
name|IOR_HARD_REG_SET
argument_list|(
name|used1
argument_list|,
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|CLASS_CANNOT_CHANGE_SIZE
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Try each hard reg to see if it fits.  Do this in two passes.      In the first pass, skip registers that are preferred by some other pseudo      to give it a better chance of getting one of those registers.  Only if      we can't get a register when excluding those do we take one of them.      However, we never allocate a register for the first time in pass 0.  */
name|COPY_HARD_REG_SET
argument_list|(
name|used
argument_list|,
name|used1
argument_list|)
expr_stmt|;
name|IOR_COMPL_HARD_REG_SET
argument_list|(
name|used
argument_list|,
name|regs_used_so_far
argument_list|)
expr_stmt|;
name|IOR_HARD_REG_SET
argument_list|(
name|used
argument_list|,
name|regs_someone_prefers
index|[
name|allocno
index|]
argument_list|)
expr_stmt|;
name|best_reg
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
name|FIRST_PSEUDO_REGISTER
operator|,
name|pass
operator|=
literal|0
init|;
name|pass
operator|<=
literal|1
operator|&&
name|i
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|;
name|pass
operator|++
control|)
block|{
if|if
condition|(
name|pass
operator|==
literal|1
condition|)
name|COPY_HARD_REG_SET
argument_list|(
name|used
argument_list|,
name|used1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
block|{
ifdef|#
directive|ifdef
name|REG_ALLOC_ORDER
name|int
name|regno
init|=
name|reg_alloc_order
index|[
name|i
index|]
decl_stmt|;
else|#
directive|else
name|int
name|regno
init|=
name|i
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|used
argument_list|,
name|regno
argument_list|)
operator|&&
name|HARD_REGNO_MODE_OK
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
operator|&&
operator|(
name|allocno_calls_crossed
index|[
name|allocno
index|]
operator|==
literal|0
operator|||
name|accept_call_clobbered
operator|||
operator|!
name|HARD_REGNO_CALL_PART_CLOBBERED
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
operator|)
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
specifier|register
name|int
name|lim
init|=
name|regno
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
decl_stmt|;
for|for
control|(
name|j
operator|=
name|regno
operator|+
literal|1
init|;
operator|(
name|j
operator|<
name|lim
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|used
argument_list|,
name|j
argument_list|)
operator|)
condition|;
name|j
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|j
operator|==
name|lim
condition|)
block|{
name|best_reg
operator|=
name|regno
expr_stmt|;
break|break;
block|}
ifndef|#
directive|ifndef
name|REG_ALLOC_ORDER
name|i
operator|=
name|j
expr_stmt|;
comment|/* Skip starting points we know will lose */
endif|#
directive|endif
block|}
block|}
block|}
comment|/* See if there is a preferred register with the same class as the register      we allocated above.  Making this restriction prevents register      preferencing from creating worse register allocation.       Remove from the preferred registers and conflicting registers.  Note that      additional conflicts may have been added after `prune_preferences' was      called.        First do this for those register with copy preferences, then all      preferred registers.  */
name|AND_COMPL_HARD_REG_SET
argument_list|(
name|hard_reg_copy_preferences
index|[
name|allocno
index|]
argument_list|,
name|used
argument_list|)
expr_stmt|;
name|GO_IF_HARD_REG_SUBSET
argument_list|(
name|hard_reg_copy_preferences
index|[
name|allocno
index|]
argument_list|,
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|NO_REGS
index|]
argument_list|,
name|no_copy_prefs
argument_list|)
expr_stmt|;
if|if
condition|(
name|best_reg
operator|>=
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|hard_reg_copy_preferences
index|[
name|allocno
index|]
argument_list|,
name|i
argument_list|)
operator|&&
name|HARD_REGNO_MODE_OK
argument_list|(
name|i
argument_list|,
name|mode
argument_list|)
operator|&&
operator|(
name|REGNO_REG_CLASS
argument_list|(
name|i
argument_list|)
operator|==
name|REGNO_REG_CLASS
argument_list|(
name|best_reg
argument_list|)
operator|||
name|reg_class_subset_p
argument_list|(
name|REGNO_REG_CLASS
argument_list|(
name|i
argument_list|)
argument_list|,
name|REGNO_REG_CLASS
argument_list|(
name|best_reg
argument_list|)
argument_list|)
operator|||
name|reg_class_subset_p
argument_list|(
name|REGNO_REG_CLASS
argument_list|(
name|best_reg
argument_list|)
argument_list|,
name|REGNO_REG_CLASS
argument_list|(
name|i
argument_list|)
argument_list|)
operator|)
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
specifier|register
name|int
name|lim
init|=
name|i
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|i
argument_list|,
name|mode
argument_list|)
decl_stmt|;
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
operator|(
name|j
operator|<
name|lim
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|used
argument_list|,
name|j
argument_list|)
operator|&&
operator|(
name|REGNO_REG_CLASS
argument_list|(
name|j
argument_list|)
operator|==
name|REGNO_REG_CLASS
argument_list|(
name|best_reg
operator|+
operator|(
name|j
operator|-
name|i
operator|)
argument_list|)
operator|||
name|reg_class_subset_p
argument_list|(
name|REGNO_REG_CLASS
argument_list|(
name|j
argument_list|)
argument_list|,
name|REGNO_REG_CLASS
argument_list|(
name|best_reg
operator|+
operator|(
name|j
operator|-
name|i
operator|)
argument_list|)
argument_list|)
operator|||
name|reg_class_subset_p
argument_list|(
name|REGNO_REG_CLASS
argument_list|(
name|best_reg
operator|+
operator|(
name|j
operator|-
name|i
operator|)
argument_list|)
argument_list|,
name|REGNO_REG_CLASS
argument_list|(
name|j
argument_list|)
argument_list|)
operator|)
operator|)
condition|;
name|j
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|j
operator|==
name|lim
condition|)
block|{
name|best_reg
operator|=
name|i
expr_stmt|;
goto|goto
name|no_prefs
goto|;
block|}
block|}
block|}
name|no_copy_prefs
label|:
name|AND_COMPL_HARD_REG_SET
argument_list|(
name|hard_reg_preferences
index|[
name|allocno
index|]
argument_list|,
name|used
argument_list|)
expr_stmt|;
name|GO_IF_HARD_REG_SUBSET
argument_list|(
name|hard_reg_preferences
index|[
name|allocno
index|]
argument_list|,
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|NO_REGS
index|]
argument_list|,
name|no_prefs
argument_list|)
expr_stmt|;
if|if
condition|(
name|best_reg
operator|>=
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|hard_reg_preferences
index|[
name|allocno
index|]
argument_list|,
name|i
argument_list|)
operator|&&
name|HARD_REGNO_MODE_OK
argument_list|(
name|i
argument_list|,
name|mode
argument_list|)
operator|&&
operator|(
name|REGNO_REG_CLASS
argument_list|(
name|i
argument_list|)
operator|==
name|REGNO_REG_CLASS
argument_list|(
name|best_reg
argument_list|)
operator|||
name|reg_class_subset_p
argument_list|(
name|REGNO_REG_CLASS
argument_list|(
name|i
argument_list|)
argument_list|,
name|REGNO_REG_CLASS
argument_list|(
name|best_reg
argument_list|)
argument_list|)
operator|||
name|reg_class_subset_p
argument_list|(
name|REGNO_REG_CLASS
argument_list|(
name|best_reg
argument_list|)
argument_list|,
name|REGNO_REG_CLASS
argument_list|(
name|i
argument_list|)
argument_list|)
operator|)
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
specifier|register
name|int
name|lim
init|=
name|i
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|i
argument_list|,
name|mode
argument_list|)
decl_stmt|;
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
operator|(
name|j
operator|<
name|lim
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|used
argument_list|,
name|j
argument_list|)
operator|&&
operator|(
name|REGNO_REG_CLASS
argument_list|(
name|j
argument_list|)
operator|==
name|REGNO_REG_CLASS
argument_list|(
name|best_reg
operator|+
operator|(
name|j
operator|-
name|i
operator|)
argument_list|)
operator|||
name|reg_class_subset_p
argument_list|(
name|REGNO_REG_CLASS
argument_list|(
name|j
argument_list|)
argument_list|,
name|REGNO_REG_CLASS
argument_list|(
name|best_reg
operator|+
operator|(
name|j
operator|-
name|i
operator|)
argument_list|)
argument_list|)
operator|||
name|reg_class_subset_p
argument_list|(
name|REGNO_REG_CLASS
argument_list|(
name|best_reg
operator|+
operator|(
name|j
operator|-
name|i
operator|)
argument_list|)
argument_list|,
name|REGNO_REG_CLASS
argument_list|(
name|j
argument_list|)
argument_list|)
operator|)
operator|)
condition|;
name|j
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|j
operator|==
name|lim
condition|)
block|{
name|best_reg
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
block|}
name|no_prefs
label|:
comment|/* If we haven't succeeded yet, try with caller-saves.       We need not check to see if the current function has nonlocal      labels because we don't put any pseudos that are live over calls in      registers in that case.  */
if|if
condition|(
name|flag_caller_saves
operator|&&
name|best_reg
operator|<
literal|0
condition|)
block|{
comment|/* Did not find a register.  If it would be profitable to 	 allocate a call-clobbered register and save and restore it 	 around calls, do that.  */
if|if
condition|(
operator|!
name|accept_call_clobbered
operator|&&
name|allocno_calls_crossed
index|[
name|allocno
index|]
operator|!=
literal|0
operator|&&
name|CALLER_SAVE_PROFITABLE
argument_list|(
name|allocno_n_refs
index|[
name|allocno
index|]
argument_list|,
name|allocno_calls_crossed
index|[
name|allocno
index|]
argument_list|)
condition|)
block|{
name|HARD_REG_SET
name|new_losers
decl_stmt|;
if|if
condition|(
operator|!
name|losers
condition|)
name|CLEAR_HARD_REG_SET
argument_list|(
name|new_losers
argument_list|)
expr_stmt|;
else|else
name|COPY_HARD_REG_SET
argument_list|(
name|new_losers
argument_list|,
name|losers
argument_list|)
expr_stmt|;
name|IOR_HARD_REG_SET
argument_list|(
name|new_losers
argument_list|,
name|losing_caller_save_reg_set
argument_list|)
expr_stmt|;
name|find_reg
argument_list|(
name|allocno
argument_list|,
name|new_losers
argument_list|,
name|alt_regs_p
argument_list|,
literal|1
argument_list|,
name|retrying
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_renumber
index|[
name|allocno_reg
index|[
name|allocno
index|]
index|]
operator|>=
literal|0
condition|)
block|{
name|caller_save_needed
operator|=
literal|1
expr_stmt|;
return|return;
block|}
block|}
block|}
comment|/* If we haven't succeeded yet,      see if some hard reg that conflicts with us      was utilized poorly by local-alloc.      If so, kick out the regs that were put there by local-alloc      so we can use it instead.  */
if|if
condition|(
name|best_reg
operator|<
literal|0
operator|&&
operator|!
name|retrying
comment|/* Let's not bother with multi-reg allocnos.  */
operator|&&
name|allocno_size
index|[
name|allocno
index|]
operator|==
literal|1
condition|)
block|{
comment|/* Count from the end, to find the least-used ones first.  */
for|for
control|(
name|i
operator|=
name|FIRST_PSEUDO_REGISTER
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
ifdef|#
directive|ifdef
name|REG_ALLOC_ORDER
name|int
name|regno
init|=
name|reg_alloc_order
index|[
name|i
index|]
decl_stmt|;
else|#
directive|else
name|int
name|regno
init|=
name|i
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|local_reg_n_refs
index|[
name|regno
index|]
operator|!=
literal|0
comment|/* Don't use a reg no good for this pseudo.  */
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|used2
argument_list|,
name|regno
argument_list|)
operator|&&
name|HARD_REGNO_MODE_OK
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
ifdef|#
directive|ifdef
name|CLASS_CANNOT_CHANGE_SIZE
operator|&&
operator|!
operator|(
name|REG_CHANGES_SIZE
argument_list|(
name|allocno_reg
index|[
name|allocno
index|]
argument_list|)
operator|&&
operator|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|CLASS_CANNOT_CHANGE_SIZE
index|]
argument_list|,
name|regno
argument_list|)
operator|)
operator|)
endif|#
directive|endif
condition|)
block|{
comment|/* We explicitly evaluate the divide results into temporary 		 variables so as to avoid excess precision problems that occur 		 on a i386-unknown-sysv4.2 (unixware) host.  */
name|double
name|tmp1
init|=
operator|(
operator|(
name|double
operator|)
name|local_reg_n_refs
index|[
name|regno
index|]
operator|/
name|local_reg_live_length
index|[
name|regno
index|]
operator|)
decl_stmt|;
name|double
name|tmp2
init|=
operator|(
operator|(
name|double
operator|)
name|allocno_n_refs
index|[
name|allocno
index|]
operator|/
name|allocno_live_length
index|[
name|allocno
index|]
operator|)
decl_stmt|;
if|if
condition|(
name|tmp1
operator|<
name|tmp2
condition|)
block|{
comment|/* Hard reg REGNO was used less in total by local regs 		     than it would be used by this one allocno!  */
name|int
name|k
decl_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|max_regno
condition|;
name|k
operator|++
control|)
if|if
condition|(
name|reg_renumber
index|[
name|k
index|]
operator|>=
literal|0
condition|)
block|{
name|int
name|r
init|=
name|reg_renumber
index|[
name|k
index|]
decl_stmt|;
name|int
name|endregno
init|=
name|r
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|r
argument_list|,
name|PSEUDO_REGNO_MODE
argument_list|(
name|k
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|regno
operator|>=
name|r
operator|&&
name|regno
operator|<
name|endregno
condition|)
name|reg_renumber
index|[
name|k
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|best_reg
operator|=
name|regno
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
comment|/* Did we find a register?  */
if|if
condition|(
name|best_reg
operator|>=
literal|0
condition|)
block|{
specifier|register
name|int
name|lim
decl_stmt|,
name|j
decl_stmt|;
name|HARD_REG_SET
name|this_reg
decl_stmt|;
comment|/* Yes.  Record it as the hard register of this pseudo-reg.  */
name|reg_renumber
index|[
name|allocno_reg
index|[
name|allocno
index|]
index|]
operator|=
name|best_reg
expr_stmt|;
comment|/* Also of any pseudo-regs that share with it.  */
if|if
condition|(
name|reg_may_share
index|[
name|allocno_reg
index|[
name|allocno
index|]
index|]
condition|)
for|for
control|(
name|j
operator|=
name|FIRST_PSEUDO_REGISTER
init|;
name|j
operator|<
name|max_regno
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|reg_allocno
index|[
name|j
index|]
operator|==
name|allocno
condition|)
name|reg_renumber
index|[
name|j
index|]
operator|=
name|best_reg
expr_stmt|;
comment|/* Make a set of the hard regs being allocated.  */
name|CLEAR_HARD_REG_SET
argument_list|(
name|this_reg
argument_list|)
expr_stmt|;
name|lim
operator|=
name|best_reg
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|best_reg
argument_list|,
name|mode
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
name|best_reg
init|;
name|j
operator|<
name|lim
condition|;
name|j
operator|++
control|)
block|{
name|SET_HARD_REG_BIT
argument_list|(
name|this_reg
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|SET_HARD_REG_BIT
argument_list|(
name|regs_used_so_far
argument_list|,
name|j
argument_list|)
expr_stmt|;
comment|/* This is no longer a reg used just by local regs.  */
name|local_reg_n_refs
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/* For each other pseudo-reg conflicting with this one, 	 mark it as conflicting with the hard regs this one occupies.  */
name|lim
operator|=
name|allocno
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|max_allocno
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|CONFLICTP
argument_list|(
name|lim
argument_list|,
name|j
argument_list|)
operator|||
name|CONFLICTP
argument_list|(
name|j
argument_list|,
name|lim
argument_list|)
condition|)
block|{
name|IOR_HARD_REG_SET
argument_list|(
name|hard_reg_conflicts
index|[
name|j
index|]
argument_list|,
name|this_reg
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Called from `reload' to look for a hard reg to put pseudo reg REGNO in.    Perhaps it had previously seemed not worth a hard reg,    or perhaps its old hard reg has been commandeered for reloads.    FORBIDDEN_REGS indicates certain hard regs that may not be used, even if    they do not appear to be allocated.    If FORBIDDEN_REGS is zero, no regs are forbidden.  */
end_comment

begin_function
name|void
name|retry_global_alloc
parameter_list|(
name|regno
parameter_list|,
name|forbidden_regs
parameter_list|)
name|int
name|regno
decl_stmt|;
name|HARD_REG_SET
name|forbidden_regs
decl_stmt|;
block|{
name|int
name|allocno
init|=
name|reg_allocno
index|[
name|regno
index|]
decl_stmt|;
if|if
condition|(
name|allocno
operator|>=
literal|0
condition|)
block|{
comment|/* If we have more than one register class, 	 first try allocating in the class that is cheapest 	 for this pseudo-reg.  If that fails, try any reg.  */
if|if
condition|(
name|N_REG_CLASSES
operator|>
literal|1
condition|)
name|find_reg
argument_list|(
name|allocno
argument_list|,
name|forbidden_regs
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_renumber
index|[
name|regno
index|]
operator|<
literal|0
operator|&&
name|reg_alternate_class
argument_list|(
name|regno
argument_list|)
operator|!=
name|NO_REGS
condition|)
name|find_reg
argument_list|(
name|allocno
argument_list|,
name|forbidden_regs
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* If we found a register, modify the RTL for the register to 	 show the hard register, and mark that register live.  */
if|if
condition|(
name|reg_renumber
index|[
name|regno
index|]
operator|>=
literal|0
condition|)
block|{
name|REGNO
argument_list|(
name|regno_reg_rtx
index|[
name|regno
index|]
argument_list|)
operator|=
name|reg_renumber
index|[
name|regno
index|]
expr_stmt|;
name|mark_home_live
argument_list|(
name|regno
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Record a conflict between register REGNO    and everything currently live.    REGNO must not be a pseudo reg that was allocated    by local_alloc; such numbers must be translated through    reg_renumber before calling here.  */
end_comment

begin_function
specifier|static
name|void
name|record_one_conflict
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
specifier|register
name|int
name|j
decl_stmt|;
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
comment|/* When a hard register becomes live,        record conflicts with live pseudo regs.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|max_allocno
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|ALLOCNO_LIVE_P
argument_list|(
name|j
argument_list|)
condition|)
name|SET_HARD_REG_BIT
argument_list|(
name|hard_reg_conflicts
index|[
name|j
index|]
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* When a pseudo-register becomes live,        record conflicts first with hard regs,        then with other pseudo regs.  */
block|{
specifier|register
name|int
name|ialloc
init|=
name|reg_allocno
index|[
name|regno
index|]
decl_stmt|;
specifier|register
name|int
name|ialloc_prod
init|=
name|ialloc
operator|*
name|allocno_row_words
decl_stmt|;
name|IOR_HARD_REG_SET
argument_list|(
name|hard_reg_conflicts
index|[
name|ialloc
index|]
argument_list|,
name|hard_regs_live
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
name|allocno_row_words
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
block|{
if|#
directive|if
literal|0
block|int k; 	  for (k = 0; k< n_no_conflict_pairs; k++) 	    if (! ((j == no_conflict_pairs[k].allocno1&& ialloc == no_conflict_pairs[k].allocno2) 		   || 		   (j == no_conflict_pairs[k].allocno2&& ialloc == no_conflict_pairs[k].allocno1)))
endif|#
directive|endif
comment|/* 0 */
name|conflicts
index|[
name|ialloc_prod
operator|+
name|j
index|]
operator||=
name|allocnos_live
index|[
name|j
index|]
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Record all allocnos currently live as conflicting    with each other and with all hard regs currently live.    ALLOCNO_VEC is a vector of LEN allocnos, all allocnos that    are currently live.  Their bits are also flagged in allocnos_live.  */
end_comment

begin_function
specifier|static
name|void
name|record_conflicts
parameter_list|(
name|allocno_vec
parameter_list|,
name|len
parameter_list|)
specifier|register
name|int
modifier|*
name|allocno_vec
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
block|{
specifier|register
name|int
name|allocno
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
specifier|register
name|int
name|ialloc_prod
decl_stmt|;
while|while
condition|(
operator|--
name|len
operator|>=
literal|0
condition|)
block|{
name|allocno
operator|=
name|allocno_vec
index|[
name|len
index|]
expr_stmt|;
name|ialloc_prod
operator|=
name|allocno
operator|*
name|allocno_row_words
expr_stmt|;
name|IOR_HARD_REG_SET
argument_list|(
name|hard_reg_conflicts
index|[
name|allocno
index|]
argument_list|,
name|hard_regs_live
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
name|allocno_row_words
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
name|conflicts
index|[
name|ialloc_prod
operator|+
name|j
index|]
operator||=
name|allocnos_live
index|[
name|j
index|]
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Handle the case where REG is set by the insn being scanned,    during the forward scan to accumulate conflicts.    Store a 1 in regs_live or allocnos_live for this register, record how many    consecutive hardware registers it actually needs,    and record a conflict with all other registers already live.     Note that even if REG does not remain alive after this insn,    we must mark it here as live, to ensure a conflict between    REG and any other regs set in this insn that really do live.    This is because those other regs could be considered after this.     REG might actually be something other than a register;    if so, we do nothing.     SETTER is 0 if this register was modified by an auto-increment (i.e.,    a REG_INC note was found for it).  */
end_comment

begin_function
specifier|static
name|void
name|mark_reg_store
parameter_list|(
name|reg
parameter_list|,
name|setter
parameter_list|)
name|rtx
name|reg
decl_stmt|,
name|setter
decl_stmt|;
block|{
specifier|register
name|int
name|regno
decl_stmt|;
comment|/* WORD is which word of a multi-register group is being stored.      For the case where the store is actually into a SUBREG of REG.      Except we don't use it; I believe the entire REG needs to be      made live.  */
name|int
name|word
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
name|word
operator|=
name|SUBREG_WORD
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|reg
operator|=
name|SUBREG_REG
argument_list|(
name|reg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|!=
name|REG
condition|)
return|return;
name|regs_set
index|[
name|n_regs_set
operator|++
index|]
operator|=
name|reg
expr_stmt|;
if|if
condition|(
name|setter
operator|&&
name|GET_CODE
argument_list|(
name|setter
argument_list|)
operator|!=
name|CLOBBER
condition|)
name|set_preference
argument_list|(
name|reg
argument_list|,
name|SET_SRC
argument_list|(
name|setter
argument_list|)
argument_list|)
expr_stmt|;
name|regno
operator|=
name|REGNO
argument_list|(
name|reg
argument_list|)
expr_stmt|;
comment|/* Either this is one of the max_allocno pseudo regs not allocated,      or it is or has a hardware reg.  First handle the pseudo-regs.  */
if|if
condition|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
if|if
condition|(
name|reg_allocno
index|[
name|regno
index|]
operator|>=
literal|0
condition|)
block|{
name|SET_ALLOCNO_LIVE
argument_list|(
name|reg_allocno
index|[
name|regno
index|]
argument_list|)
expr_stmt|;
name|record_one_conflict
argument_list|(
name|regno
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|reg_renumber
index|[
name|regno
index|]
operator|>=
literal|0
condition|)
name|regno
operator|=
name|reg_renumber
index|[
name|regno
index|]
comment|/* + word */
expr_stmt|;
comment|/* Handle hardware regs (and pseudos allocated to hard regs).  */
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
operator|!
name|fixed_regs
index|[
name|regno
index|]
condition|)
block|{
specifier|register
name|int
name|last
init|=
name|regno
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
name|regno
operator|<
name|last
condition|)
block|{
name|record_one_conflict
argument_list|(
name|regno
argument_list|)
expr_stmt|;
name|SET_HARD_REG_BIT
argument_list|(
name|hard_regs_live
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|regno
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Like mark_reg_set except notice just CLOBBERs; ignore SETs.  */
end_comment

begin_function
specifier|static
name|void
name|mark_reg_clobber
parameter_list|(
name|reg
parameter_list|,
name|setter
parameter_list|)
name|rtx
name|reg
decl_stmt|,
name|setter
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|setter
argument_list|)
operator|==
name|CLOBBER
condition|)
name|mark_reg_store
argument_list|(
name|reg
argument_list|,
name|setter
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Record that REG has conflicts with all the regs currently live.    Do not mark REG itself as live.  */
end_comment

begin_function
specifier|static
name|void
name|mark_reg_conflicts
parameter_list|(
name|reg
parameter_list|)
name|rtx
name|reg
decl_stmt|;
block|{
specifier|register
name|int
name|regno
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SUBREG
condition|)
name|reg
operator|=
name|SUBREG_REG
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|!=
name|REG
condition|)
return|return;
name|regno
operator|=
name|REGNO
argument_list|(
name|reg
argument_list|)
expr_stmt|;
comment|/* Either this is one of the max_allocno pseudo regs not allocated,      or it is or has a hardware reg.  First handle the pseudo-regs.  */
if|if
condition|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
if|if
condition|(
name|reg_allocno
index|[
name|regno
index|]
operator|>=
literal|0
condition|)
name|record_one_conflict
argument_list|(
name|regno
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|reg_renumber
index|[
name|regno
index|]
operator|>=
literal|0
condition|)
name|regno
operator|=
name|reg_renumber
index|[
name|regno
index|]
expr_stmt|;
comment|/* Handle hardware regs (and pseudos allocated to hard regs).  */
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
operator|!
name|fixed_regs
index|[
name|regno
index|]
condition|)
block|{
specifier|register
name|int
name|last
init|=
name|regno
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
name|regno
operator|<
name|last
condition|)
block|{
name|record_one_conflict
argument_list|(
name|regno
argument_list|)
expr_stmt|;
name|regno
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Mark REG as being dead (following the insn being scanned now).    Store a 0 in regs_live or allocnos_live for this register.  */
end_comment

begin_function
specifier|static
name|void
name|mark_reg_death
parameter_list|(
name|reg
parameter_list|)
name|rtx
name|reg
decl_stmt|;
block|{
specifier|register
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|reg
argument_list|)
decl_stmt|;
comment|/* Either this is one of the max_allocno pseudo regs not allocated,      or it is a hardware reg.  First handle the pseudo-regs.  */
if|if
condition|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
if|if
condition|(
name|reg_allocno
index|[
name|regno
index|]
operator|>=
literal|0
condition|)
name|CLEAR_ALLOCNO_LIVE
argument_list|(
name|reg_allocno
index|[
name|regno
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* For pseudo reg, see if it has been assigned a hardware reg.  */
if|if
condition|(
name|reg_renumber
index|[
name|regno
index|]
operator|>=
literal|0
condition|)
name|regno
operator|=
name|reg_renumber
index|[
name|regno
index|]
expr_stmt|;
comment|/* Handle hardware regs (and pseudos allocated to hard regs).  */
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
operator|!
name|fixed_regs
index|[
name|regno
index|]
condition|)
block|{
comment|/* Pseudo regs already assigned hardware regs are treated 	 almost the same as explicit hardware regs.  */
specifier|register
name|int
name|last
init|=
name|regno
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
name|regno
operator|<
name|last
condition|)
block|{
name|CLEAR_HARD_REG_BIT
argument_list|(
name|hard_regs_live
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|regno
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Mark hard reg REGNO as currently live, assuming machine mode MODE    for the value stored in it.  MODE determines how many consecutive    registers are actually in use.  Do not record conflicts;    it is assumed that the caller will do that.  */
end_comment

begin_function
specifier|static
name|void
name|mark_reg_live_nc
parameter_list|(
name|regno
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|int
name|regno
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
specifier|register
name|int
name|last
init|=
name|regno
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
decl_stmt|;
while|while
condition|(
name|regno
operator|<
name|last
condition|)
block|{
name|SET_HARD_REG_BIT
argument_list|(
name|hard_regs_live
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|regno
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Try to set a preference for an allocno to a hard register.    We are passed DEST and SRC which are the operands of a SET.  It is known    that SRC is a register.  If SRC or the first operand of SRC is a register,    try to set a preference.  If one of the two is a hard register and the other    is a pseudo-register, mark the preference.        Note that we are not as aggressive as local-alloc in trying to tie a    pseudo-register to a hard register.  */
end_comment

begin_function
specifier|static
name|void
name|set_preference
parameter_list|(
name|dest
parameter_list|,
name|src
parameter_list|)
name|rtx
name|dest
decl_stmt|,
name|src
decl_stmt|;
block|{
name|int
name|src_regno
decl_stmt|,
name|dest_regno
decl_stmt|;
comment|/* Amount to add to the hard regno for SRC, or subtract from that for DEST,      to compensate for subregs in SRC or DEST.  */
name|int
name|offset
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|copy
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
argument_list|)
index|[
literal|0
index|]
operator|==
literal|'e'
condition|)
name|src
operator|=
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
operator|,
name|copy
operator|=
literal|0
expr_stmt|;
comment|/* Get the reg number for both SRC and DEST.      If neither is a reg, give up.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|REG
condition|)
name|src_regno
operator|=
name|REGNO
argument_list|(
name|src
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|src
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|src_regno
operator|=
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|src
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|SUBREG_WORD
argument_list|(
name|src
argument_list|)
expr_stmt|;
block|}
else|else
return|return;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
condition|)
name|dest_regno
operator|=
name|REGNO
argument_list|(
name|dest
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|dest_regno
operator|=
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|-=
name|SUBREG_WORD
argument_list|(
name|dest
argument_list|)
expr_stmt|;
block|}
else|else
return|return;
comment|/* Convert either or both to hard reg numbers.  */
if|if
condition|(
name|reg_renumber
index|[
name|src_regno
index|]
operator|>=
literal|0
condition|)
name|src_regno
operator|=
name|reg_renumber
index|[
name|src_regno
index|]
expr_stmt|;
if|if
condition|(
name|reg_renumber
index|[
name|dest_regno
index|]
operator|>=
literal|0
condition|)
name|dest_regno
operator|=
name|reg_renumber
index|[
name|dest_regno
index|]
expr_stmt|;
comment|/* Now if one is a hard reg and the other is a global pseudo      then give the other a preference.  */
if|if
condition|(
name|dest_regno
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|src_regno
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|reg_allocno
index|[
name|src_regno
index|]
operator|>=
literal|0
condition|)
block|{
name|dest_regno
operator|-=
name|offset
expr_stmt|;
if|if
condition|(
name|dest_regno
operator|>=
literal|0
operator|&&
name|dest_regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
if|if
condition|(
name|copy
condition|)
name|SET_REGBIT
argument_list|(
name|hard_reg_copy_preferences
argument_list|,
name|reg_allocno
index|[
name|src_regno
index|]
argument_list|,
name|dest_regno
argument_list|)
expr_stmt|;
name|SET_REGBIT
argument_list|(
name|hard_reg_preferences
argument_list|,
name|reg_allocno
index|[
name|src_regno
index|]
argument_list|,
name|dest_regno
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|dest_regno
init|;
name|i
operator|<
name|dest_regno
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|dest_regno
argument_list|,
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
condition|;
name|i
operator|++
control|)
name|SET_REGBIT
argument_list|(
name|hard_reg_full_preferences
argument_list|,
name|reg_allocno
index|[
name|src_regno
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|src_regno
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|dest_regno
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|reg_allocno
index|[
name|dest_regno
index|]
operator|>=
literal|0
condition|)
block|{
name|src_regno
operator|+=
name|offset
expr_stmt|;
if|if
condition|(
name|src_regno
operator|>=
literal|0
operator|&&
name|src_regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
if|if
condition|(
name|copy
condition|)
name|SET_REGBIT
argument_list|(
name|hard_reg_copy_preferences
argument_list|,
name|reg_allocno
index|[
name|dest_regno
index|]
argument_list|,
name|src_regno
argument_list|)
expr_stmt|;
name|SET_REGBIT
argument_list|(
name|hard_reg_preferences
argument_list|,
name|reg_allocno
index|[
name|dest_regno
index|]
argument_list|,
name|src_regno
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|src_regno
init|;
name|i
operator|<
name|src_regno
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|src_regno
argument_list|,
name|GET_MODE
argument_list|(
name|src
argument_list|)
argument_list|)
condition|;
name|i
operator|++
control|)
name|SET_REGBIT
argument_list|(
name|hard_reg_full_preferences
argument_list|,
name|reg_allocno
index|[
name|dest_regno
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Indicate that hard register number FROM was eliminated and replaced with    an offset from hard register number TO.  The status of hard registers live    at the start of a basic block is updated by replacing a use of FROM with    a use of TO.  */
end_comment

begin_function
name|void
name|mark_elimination
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|)
name|int
name|from
decl_stmt|,
name|to
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
name|i
operator|++
control|)
block|{
specifier|register
name|regset
name|r
init|=
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
operator|->
name|global_live_at_start
decl_stmt|;
if|if
condition|(
name|REGNO_REG_SET_P
argument_list|(
name|r
argument_list|,
name|from
argument_list|)
condition|)
block|{
name|CLEAR_REGNO_REG_SET
argument_list|(
name|r
argument_list|,
name|from
argument_list|)
expr_stmt|;
name|SET_REGNO_REG_SET
argument_list|(
name|r
argument_list|,
name|to
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Used for communication between the following functions.  Holds the    current life information.  */
end_comment

begin_decl_stmt
specifier|static
name|regset
name|live_relevant_regs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Record in live_relevant_regs that register REG became live.  This    is called via note_stores.  */
end_comment

begin_function
specifier|static
name|void
name|reg_becomes_live
parameter_list|(
name|reg
parameter_list|,
name|setter
parameter_list|)
name|rtx
name|reg
decl_stmt|;
name|rtx
name|setter
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|int
name|regno
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SUBREG
condition|)
name|reg
operator|=
name|SUBREG_REG
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|!=
name|REG
condition|)
return|return;
name|regno
operator|=
name|REGNO
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|int
name|nregs
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
name|nregs
operator|--
operator|>
literal|0
condition|)
name|SET_REGNO_REG_SET
argument_list|(
name|live_relevant_regs
argument_list|,
name|regno
operator|++
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|reg_renumber
index|[
name|regno
index|]
operator|>=
literal|0
condition|)
name|SET_REGNO_REG_SET
argument_list|(
name|live_relevant_regs
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Record in live_relevant_regs that register REGNO died.  */
end_comment

begin_function
specifier|static
name|void
name|reg_dies
parameter_list|(
name|regno
parameter_list|,
name|mode
parameter_list|)
name|int
name|regno
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|int
name|nregs
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
decl_stmt|;
while|while
condition|(
name|nregs
operator|--
operator|>
literal|0
condition|)
name|CLEAR_REGNO_REG_SET
argument_list|(
name|live_relevant_regs
argument_list|,
name|regno
operator|++
argument_list|)
expr_stmt|;
block|}
else|else
name|CLEAR_REGNO_REG_SET
argument_list|(
name|live_relevant_regs
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Walk the insns of the current function and build reload_insn_chain,    and record register life information.  */
end_comment

begin_function
specifier|static
name|void
name|build_insn_chain
parameter_list|(
name|first
parameter_list|)
name|rtx
name|first
decl_stmt|;
block|{
name|struct
name|insn_chain
modifier|*
modifier|*
name|p
init|=
operator|&
name|reload_insn_chain
decl_stmt|;
name|struct
name|insn_chain
modifier|*
name|prev
init|=
literal|0
decl_stmt|;
name|int
name|b
init|=
literal|0
decl_stmt|;
name|live_relevant_regs
operator|=
name|ALLOCA_REG_SET
argument_list|()
expr_stmt|;
for|for
control|(
init|;
name|first
condition|;
name|first
operator|=
name|NEXT_INSN
argument_list|(
name|first
argument_list|)
control|)
block|{
name|struct
name|insn_chain
modifier|*
name|c
decl_stmt|;
if|if
condition|(
name|first
operator|==
name|BLOCK_HEAD
argument_list|(
name|b
argument_list|)
condition|)
block|{
name|int
name|i
decl_stmt|;
name|CLEAR_REG_SET
argument_list|(
name|live_relevant_regs
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|REGNO_REG_SET_P
argument_list|(
name|BASIC_BLOCK
argument_list|(
name|b
argument_list|)
operator|->
name|global_live_at_start
argument_list|,
name|i
argument_list|)
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|eliminable_regset
argument_list|,
name|i
argument_list|)
condition|)
name|SET_REGNO_REG_SET
argument_list|(
name|live_relevant_regs
argument_list|,
name|i
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|max_regno
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|reg_renumber
index|[
name|i
index|]
operator|>=
literal|0
operator|&&
name|REGNO_REG_SET_P
argument_list|(
name|BASIC_BLOCK
argument_list|(
name|b
argument_list|)
operator|->
name|global_live_at_start
argument_list|,
name|i
argument_list|)
condition|)
name|SET_REGNO_REG_SET
argument_list|(
name|live_relevant_regs
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|first
argument_list|)
operator|!=
name|NOTE
operator|&&
name|GET_CODE
argument_list|(
name|first
argument_list|)
operator|!=
name|BARRIER
condition|)
block|{
name|c
operator|=
name|new_insn_chain
argument_list|()
expr_stmt|;
name|c
operator|->
name|prev
operator|=
name|prev
expr_stmt|;
name|prev
operator|=
name|c
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
name|p
operator|=
operator|&
name|c
operator|->
name|next
expr_stmt|;
name|c
operator|->
name|insn
operator|=
name|first
expr_stmt|;
name|c
operator|->
name|block
operator|=
name|b
expr_stmt|;
name|COPY_REG_SET
argument_list|(
name|c
operator|->
name|live_before
argument_list|,
name|live_relevant_regs
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|first
argument_list|)
argument_list|)
operator|==
literal|'i'
condition|)
block|{
name|rtx
name|link
decl_stmt|;
comment|/* Mark the death of everything that dies in this instruction.  */
for|for
control|(
name|link
operator|=
name|REG_NOTES
argument_list|(
name|first
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
name|REG_DEAD
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
name|reg_dies
argument_list|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Mark everything born in this instruction as live.  */
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|first
argument_list|)
argument_list|,
name|reg_becomes_live
argument_list|)
expr_stmt|;
block|}
comment|/* Remember which registers are live at the end of the insn, before 	     killing those with REG_UNUSED notes.  */
name|COPY_REG_SET
argument_list|(
name|c
operator|->
name|live_after
argument_list|,
name|live_relevant_regs
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|first
argument_list|)
argument_list|)
operator|==
literal|'i'
condition|)
block|{
name|rtx
name|link
decl_stmt|;
comment|/* Mark anything that is set in this insn and then unused as dying.  */
for|for
control|(
name|link
operator|=
name|REG_NOTES
argument_list|(
name|first
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
name|REG_UNUSED
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
name|reg_dies
argument_list|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|first
operator|==
name|BLOCK_END
argument_list|(
name|b
argument_list|)
condition|)
name|b
operator|++
expr_stmt|;
comment|/* Stop after we pass the end of the last basic block.  Verify that 	 no real insns are after the end of the last basic block.  	 We may want to reorganize the loop somewhat since this test should 	 always be the right exit test.  */
if|if
condition|(
name|b
operator|==
name|n_basic_blocks
condition|)
block|{
for|for
control|(
name|first
operator|=
name|NEXT_INSN
argument_list|(
name|first
argument_list|)
init|;
name|first
condition|;
name|first
operator|=
name|NEXT_INSN
argument_list|(
name|first
argument_list|)
control|)
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|first
argument_list|)
argument_list|)
operator|==
literal|'i'
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|first
argument_list|)
argument_list|)
operator|!=
name|USE
condition|)
name|abort
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
name|FREE_REG_SET
argument_list|(
name|live_relevant_regs
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print debugging trace information if -greg switch is given,    showing the information on which the allocation decisions are based.  */
end_comment

begin_function
specifier|static
name|void
name|dump_conflicts
parameter_list|(
name|file
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|has_preferences
decl_stmt|;
specifier|register
name|int
name|nregs
decl_stmt|;
name|nregs
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_allocno
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|reg_renumber
index|[
name|allocno_reg
index|[
name|allocno_order
index|[
name|i
index|]
index|]
index|]
operator|>=
literal|0
condition|)
continue|continue;
name|nregs
operator|++
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|";; %d regs to allocate:"
argument_list|,
name|nregs
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_allocno
condition|;
name|i
operator|++
control|)
block|{
name|int
name|j
decl_stmt|;
if|if
condition|(
name|reg_renumber
index|[
name|allocno_reg
index|[
name|allocno_order
index|[
name|i
index|]
index|]
index|]
operator|>=
literal|0
condition|)
continue|continue;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %d"
argument_list|,
name|allocno_reg
index|[
name|allocno_order
index|[
name|i
index|]
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|max_regno
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|reg_allocno
index|[
name|j
index|]
operator|==
name|allocno_order
index|[
name|i
index|]
operator|&&
name|j
operator|!=
name|allocno_reg
index|[
name|allocno_order
index|[
name|i
index|]
index|]
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"+%d"
argument_list|,
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|allocno_size
index|[
name|allocno_order
index|[
name|i
index|]
index|]
operator|!=
literal|1
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" (%d)"
argument_list|,
name|allocno_size
index|[
name|allocno_order
index|[
name|i
index|]
index|]
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_allocno
condition|;
name|i
operator|++
control|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|";; %d conflicts:"
argument_list|,
name|allocno_reg
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|max_allocno
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|CONFLICTP
argument_list|(
name|i
argument_list|,
name|j
argument_list|)
operator|||
name|CONFLICTP
argument_list|(
name|j
argument_list|,
name|i
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %d"
argument_list|,
name|allocno_reg
index|[
name|j
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|hard_reg_conflicts
index|[
name|i
index|]
argument_list|,
name|j
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %d"
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|has_preferences
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|hard_reg_preferences
index|[
name|i
index|]
argument_list|,
name|j
argument_list|)
condition|)
name|has_preferences
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|has_preferences
condition|)
continue|continue;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|";; %d preferences:"
argument_list|,
name|allocno_reg
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|hard_reg_preferences
index|[
name|i
index|]
argument_list|,
name|j
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %d"
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dump_global_regs
parameter_list|(
name|file
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|";; Register dispositions:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|FIRST_PSEUDO_REGISTER
operator|,
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|max_regno
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|reg_renumber
index|[
name|i
index|]
operator|>=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d in %d  "
argument_list|,
name|i
argument_list|,
name|reg_renumber
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|j
operator|%
literal|6
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n\n;; Hard regs used: "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|i
index|]
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n\n"
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

