begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Interprocedural analyses.    Copyright (C) 2005 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"cgraph.h"
end_include

begin_include
include|#
directive|include
file|"ipa-prop.h"
end_include

begin_include
include|#
directive|include
file|"tree-flow.h"
end_include

begin_include
include|#
directive|include
file|"tree-pass.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_comment
comment|/* This file contains interfaces that can be used for various IPA     optimizations:     - ipa_methodlist interface - It is used to create and handle a temporary     worklist used in  the propagation stage of IPCP. (can be used for more     IPA optimizations).       - ipa_callsite interface - for each callsite this interface creates and     handles ipa_edge structure associated with it.     - ipa_method interface - for each method this interface creates and     handles ipa_node structure associated with it.  */
end_comment

begin_comment
comment|/* ipa_methodlist interface.  */
end_comment

begin_comment
comment|/* Create a new worklist node.  */
end_comment

begin_function
specifier|static
specifier|inline
name|ipa_methodlist_p
name|ipa_create_methodlist_node
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|ipa_methodlist_p
operator|)
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ipa_methodlist
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if worklist WL is empty.  */
end_comment

begin_function
name|bool
name|ipa_methodlist_not_empty
parameter_list|(
name|ipa_methodlist_p
name|wl
parameter_list|)
block|{
return|return
operator|(
name|wl
operator|!=
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the method in worklist element WL.  */
end_comment

begin_function
specifier|static
specifier|inline
name|struct
name|cgraph_node
modifier|*
name|ipa_methodlist_method
parameter_list|(
name|ipa_methodlist_p
name|wl
parameter_list|)
block|{
return|return
name|wl
operator|->
name|method_p
return|;
block|}
end_function

begin_comment
comment|/* Make worklist element WL point to method MT in the callgraph.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|ipa_methodlist_method_set
parameter_list|(
name|ipa_methodlist_p
name|wl
parameter_list|,
name|struct
name|cgraph_node
modifier|*
name|mt
parameter_list|)
block|{
name|wl
operator|->
name|method_p
operator|=
name|mt
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the next element in the worklist following worklist     element WL.  */
end_comment

begin_function
specifier|static
specifier|inline
name|ipa_methodlist_p
name|ipa_methodlist_next_method
parameter_list|(
name|ipa_methodlist_p
name|wl
parameter_list|)
block|{
return|return
name|wl
operator|->
name|next_method
return|;
block|}
end_function

begin_comment
comment|/* Set worklist element WL1 to point to worklist element WL2.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|ipa_methodlist_next_method_set
parameter_list|(
name|ipa_methodlist_p
name|wl1
parameter_list|,
name|ipa_methodlist_p
name|wl2
parameter_list|)
block|{
name|wl1
operator|->
name|next_method
operator|=
name|wl2
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize worklist to contain all methods.  */
end_comment

begin_function
name|ipa_methodlist_p
name|ipa_methodlist_init
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|cgraph_node
modifier|*
name|node
decl_stmt|;
name|ipa_methodlist_p
name|wl
decl_stmt|;
name|wl
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|node
operator|=
name|cgraph_nodes
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
name|ipa_add_method
argument_list|(
operator|&
name|wl
argument_list|,
name|node
argument_list|)
expr_stmt|;
return|return
name|wl
return|;
block|}
end_function

begin_comment
comment|/* Add method MT to the worklist. Set worklist element WL      to point to MT.  */
end_comment

begin_function
name|void
name|ipa_add_method
parameter_list|(
name|ipa_methodlist_p
modifier|*
name|wl
parameter_list|,
name|struct
name|cgraph_node
modifier|*
name|mt
parameter_list|)
block|{
name|ipa_methodlist_p
name|temp
decl_stmt|;
name|temp
operator|=
name|ipa_create_methodlist_node
argument_list|()
expr_stmt|;
name|ipa_methodlist_method_set
argument_list|(
name|temp
argument_list|,
name|mt
argument_list|)
expr_stmt|;
name|ipa_methodlist_next_method_set
argument_list|(
name|temp
argument_list|,
operator|*
name|wl
argument_list|)
expr_stmt|;
operator|*
name|wl
operator|=
name|temp
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Remove a method from the worklist. WL points to the first     element in the list, which is removed.  */
end_comment

begin_function
name|struct
name|cgraph_node
modifier|*
name|ipa_remove_method
parameter_list|(
name|ipa_methodlist_p
modifier|*
name|wl
parameter_list|)
block|{
name|ipa_methodlist_p
name|first
decl_stmt|;
name|struct
name|cgraph_node
modifier|*
name|return_method
decl_stmt|;
name|first
operator|=
operator|*
name|wl
expr_stmt|;
operator|*
name|wl
operator|=
name|ipa_methodlist_next_method
argument_list|(
operator|*
name|wl
argument_list|)
expr_stmt|;
name|return_method
operator|=
name|ipa_methodlist_method
argument_list|(
name|first
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|first
argument_list|)
expr_stmt|;
return|return
name|return_method
return|;
block|}
end_function

begin_comment
comment|/* ipa_method interface.  */
end_comment

begin_comment
comment|/* Return number of formals of method MT.  */
end_comment

begin_function
name|int
name|ipa_method_formal_count
parameter_list|(
name|struct
name|cgraph_node
modifier|*
name|mt
parameter_list|)
block|{
return|return
name|IPA_NODE_REF
argument_list|(
name|mt
argument_list|)
operator|->
name|ipa_arg_num
return|;
block|}
end_function

begin_comment
comment|/* Set number of formals of method MT to I.  */
end_comment

begin_function
name|void
name|ipa_method_formal_count_set
parameter_list|(
name|struct
name|cgraph_node
modifier|*
name|mt
parameter_list|,
name|int
name|i
parameter_list|)
block|{
name|IPA_NODE_REF
argument_list|(
name|mt
argument_list|)
operator|->
name|ipa_arg_num
operator|=
name|i
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return whether I-th formal of MT is modified in MT.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|ipa_method_is_modified
parameter_list|(
name|struct
name|cgraph_node
modifier|*
name|mt
parameter_list|,
name|int
name|i
parameter_list|)
block|{
return|return
name|IPA_NODE_REF
argument_list|(
name|mt
argument_list|)
operator|->
name|ipa_mod
index|[
name|i
index|]
return|;
block|}
end_function

begin_comment
comment|/* Return the tree of I-th formal of MT.  */
end_comment

begin_function
name|tree
name|ipa_method_get_tree
parameter_list|(
name|struct
name|cgraph_node
modifier|*
name|mt
parameter_list|,
name|int
name|i
parameter_list|)
block|{
return|return
name|IPA_NODE_REF
argument_list|(
name|mt
argument_list|)
operator|->
name|ipa_param_tree
index|[
name|i
index|]
return|;
block|}
end_function

begin_comment
comment|/* Create tree map structure for MT.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|ipa_method_tree_map_create
parameter_list|(
name|struct
name|cgraph_node
modifier|*
name|mt
parameter_list|)
block|{
name|IPA_NODE_REF
argument_list|(
name|mt
argument_list|)
operator|->
name|ipa_param_tree
operator|=
name|XCNEWVEC
argument_list|(
name|tree
argument_list|,
name|ipa_method_formal_count
argument_list|(
name|mt
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create modify structure for MT.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|ipa_method_modify_create
parameter_list|(
name|struct
name|cgraph_node
modifier|*
name|mt
parameter_list|)
block|{
operator|(
operator|(
expr|struct
name|ipa_node
operator|*
operator|)
name|mt
operator|->
name|aux
operator|)
operator|->
name|ipa_mod
operator|=
name|XCNEWVEC
argument_list|(
name|bool
argument_list|,
name|ipa_method_formal_count
argument_list|(
name|mt
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set modify of I-th formal of MT to VAL.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|ipa_method_modify_set
parameter_list|(
name|struct
name|cgraph_node
modifier|*
name|mt
parameter_list|,
name|int
name|i
parameter_list|,
name|bool
name|val
parameter_list|)
block|{
name|IPA_NODE_REF
argument_list|(
name|mt
argument_list|)
operator|->
name|ipa_mod
index|[
name|i
index|]
operator|=
name|val
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return index of the formal whose tree is PTREE in method MT.  */
end_comment

begin_function
specifier|static
name|int
name|ipa_method_tree_map
parameter_list|(
name|struct
name|cgraph_node
modifier|*
name|mt
parameter_list|,
name|tree
name|ptree
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|count
decl_stmt|;
name|count
operator|=
name|ipa_method_formal_count
argument_list|(
name|mt
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|IPA_NODE_REF
argument_list|(
name|mt
argument_list|)
operator|->
name|ipa_param_tree
index|[
name|i
index|]
operator|==
name|ptree
condition|)
return|return
name|i
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Insert the formal trees to the ipa_param_tree array in method MT.  */
end_comment

begin_function
name|void
name|ipa_method_compute_tree_map
parameter_list|(
name|struct
name|cgraph_node
modifier|*
name|mt
parameter_list|)
block|{
name|tree
name|fndecl
decl_stmt|;
name|tree
name|fnargs
decl_stmt|;
name|tree
name|parm
decl_stmt|;
name|int
name|param_num
decl_stmt|;
name|ipa_method_tree_map_create
argument_list|(
name|mt
argument_list|)
expr_stmt|;
name|fndecl
operator|=
name|mt
operator|->
name|decl
expr_stmt|;
name|fnargs
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
name|param_num
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|parm
operator|=
name|fnargs
init|;
name|parm
condition|;
name|parm
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
control|)
block|{
name|IPA_NODE_REF
argument_list|(
name|mt
argument_list|)
operator|->
name|ipa_param_tree
index|[
name|param_num
index|]
operator|=
name|parm
expr_stmt|;
name|param_num
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Count number of formals in MT. Insert the result to the     ipa_node.  */
end_comment

begin_function
name|void
name|ipa_method_formal_compute_count
parameter_list|(
name|struct
name|cgraph_node
modifier|*
name|mt
parameter_list|)
block|{
name|tree
name|fndecl
decl_stmt|;
name|tree
name|fnargs
decl_stmt|;
name|tree
name|parm
decl_stmt|;
name|int
name|param_num
decl_stmt|;
name|fndecl
operator|=
name|mt
operator|->
name|decl
expr_stmt|;
name|fnargs
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
name|param_num
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|parm
operator|=
name|fnargs
init|;
name|parm
condition|;
name|parm
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
control|)
name|param_num
operator|++
expr_stmt|;
name|ipa_method_formal_count_set
argument_list|(
name|mt
argument_list|,
name|param_num
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Check STMT to detect whether a formal is modified within MT,    the appropriate entry is updated in the ipa_mod array of ipa_node    (associated with MT).  */
end_comment

begin_function
specifier|static
name|void
name|ipa_method_modify_stmt
parameter_list|(
name|struct
name|cgraph_node
modifier|*
name|mt
parameter_list|,
name|tree
name|stmt
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
condition|)
block|{
case|case
name|MODIFY_EXPR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PARM_DECL
condition|)
block|{
name|i
operator|=
name|ipa_method_tree_map
argument_list|(
name|mt
argument_list|,
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
name|ipa_method_modify_set
argument_list|(
name|mt
argument_list|,
name|i
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ASM_EXPR
case|:
comment|/* Asm code could modify any of the parameters.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ipa_method_formal_count
argument_list|(
name|mt
argument_list|)
condition|;
name|j
operator|++
control|)
name|ipa_method_modify_set
argument_list|(
name|mt
argument_list|,
name|j
argument_list|,
name|true
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Initialize ipa_mod array of MT.  */
end_comment

begin_function
specifier|static
name|void
name|ipa_method_modify_init
parameter_list|(
name|struct
name|cgraph_node
modifier|*
name|mt
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|count
decl_stmt|;
name|ipa_method_modify_create
argument_list|(
name|mt
argument_list|)
expr_stmt|;
name|count
operator|=
name|ipa_method_formal_count
argument_list|(
name|mt
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
name|ipa_method_modify_set
argument_list|(
name|mt
argument_list|,
name|i
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The modify computation driver for MT. Compute which formal arguments     of method MT are locally modified.  Formals may be modified in MT     if their address is taken, or if    they appear on the left hand side of an assignment.  */
end_comment

begin_function
name|void
name|ipa_method_compute_modify
parameter_list|(
name|struct
name|cgraph_node
modifier|*
name|mt
parameter_list|)
block|{
name|tree
name|decl
decl_stmt|;
name|tree
name|body
decl_stmt|;
name|int
name|j
decl_stmt|,
name|count
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|struct
name|function
modifier|*
name|func
decl_stmt|;
name|block_stmt_iterator
name|bsi
decl_stmt|;
name|tree
name|stmt
decl_stmt|,
name|parm_tree
decl_stmt|;
name|ipa_method_modify_init
argument_list|(
name|mt
argument_list|)
expr_stmt|;
name|decl
operator|=
name|mt
operator|->
name|decl
expr_stmt|;
name|count
operator|=
name|ipa_method_formal_count
argument_list|(
name|mt
argument_list|)
expr_stmt|;
comment|/* ??? Handle pending sizes case. Set all parameters       of the method to be modified.  */
if|if
condition|(
name|DECL_UNINLINABLE
argument_list|(
name|decl
argument_list|)
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|count
condition|;
name|j
operator|++
control|)
name|ipa_method_modify_set
argument_list|(
name|mt
argument_list|,
name|j
argument_list|,
name|true
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Formals whose address is taken are considered modified.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|count
condition|;
name|j
operator|++
control|)
block|{
name|parm_tree
operator|=
name|ipa_method_get_tree
argument_list|(
name|mt
argument_list|,
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_ADDRESSABLE
argument_list|(
name|parm_tree
argument_list|)
condition|)
name|ipa_method_modify_set
argument_list|(
name|mt
argument_list|,
name|j
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
name|body
operator|=
name|DECL_SAVED_TREE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|body
operator|!=
name|NULL
condition|)
block|{
name|func
operator|=
name|DECL_STRUCT_FUNCTION
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|FOR_EACH_BB_FN
argument_list|(
argument|bb
argument_list|,
argument|func
argument_list|)
block|{
for|for
control|(
name|bsi
operator|=
name|bsi_start
argument_list|(
name|bb
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|;
name|bsi_next
argument_list|(
operator|&
name|bsi
argument_list|)
control|)
block|{
name|stmt
operator|=
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
expr_stmt|;
name|ipa_method_modify_stmt
argument_list|(
name|mt
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* ipa_callsite interface.  */
end_comment

begin_comment
comment|/* Return number of arguments in callsite CS.  */
end_comment

begin_function
name|int
name|ipa_callsite_param_count
parameter_list|(
name|struct
name|cgraph_edge
modifier|*
name|cs
parameter_list|)
block|{
return|return
name|IPA_EDGE_REF
argument_list|(
name|cs
argument_list|)
operator|->
name|ipa_param_num
return|;
block|}
end_function

begin_comment
comment|/* Set number of arguments in callsite CS to I.  */
end_comment

begin_function
name|void
name|ipa_callsite_param_count_set
parameter_list|(
name|struct
name|cgraph_edge
modifier|*
name|cs
parameter_list|,
name|int
name|i
parameter_list|)
block|{
name|IPA_EDGE_REF
argument_list|(
name|cs
argument_list|)
operator|->
name|ipa_param_num
operator|=
name|i
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the jump function (ipa_jump_func struct) for argument I of     callsite CS.  */
end_comment

begin_function
name|struct
name|ipa_jump_func
modifier|*
name|ipa_callsite_param
parameter_list|(
name|struct
name|cgraph_edge
modifier|*
name|cs
parameter_list|,
name|int
name|i
parameter_list|)
block|{
return|return
operator|&
operator|(
name|IPA_EDGE_REF
argument_list|(
name|cs
argument_list|)
operator|->
name|ipa_param_map
index|[
name|i
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/* return the callee (cgraph_node) of callsite CS.  */
end_comment

begin_function
name|struct
name|cgraph_node
modifier|*
name|ipa_callsite_callee
parameter_list|(
name|struct
name|cgraph_edge
modifier|*
name|cs
parameter_list|)
block|{
return|return
name|cs
operator|->
name|callee
return|;
block|}
end_function

begin_comment
comment|/* Set field 'type' of jump function (ipa_jump_func struct) of argument I     in callsite CS.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|ipa_callsite_param_set_type
parameter_list|(
name|struct
name|cgraph_edge
modifier|*
name|cs
parameter_list|,
name|int
name|i
parameter_list|,
name|enum
name|jump_func_type
name|type1
parameter_list|)
block|{
name|IPA_EDGE_REF
argument_list|(
name|cs
argument_list|)
operator|->
name|ipa_param_map
index|[
name|i
index|]
operator|.
name|type
operator|=
name|type1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set FORMAL as 'info_type' field of jump function (ipa_jump_func struct)    of argument I of callsite CS.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|ipa_callsite_param_set_info_type_formal
parameter_list|(
name|struct
name|cgraph_edge
modifier|*
name|cs
parameter_list|,
name|int
name|i
parameter_list|,
name|unsigned
name|int
name|formal
parameter_list|)
block|{
name|ipa_callsite_param
argument_list|(
name|cs
argument_list|,
name|i
argument_list|)
operator|->
name|info_type
operator|.
name|formal_id
operator|=
name|formal
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set int-valued INFO_TYPE1 as 'info_type' field of     jump function (ipa_jump_func struct) of argument I of callsite CS.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|ipa_callsite_param_set_info_type
parameter_list|(
name|struct
name|cgraph_edge
modifier|*
name|cs
parameter_list|,
name|int
name|i
parameter_list|,
name|tree
name|info_type1
parameter_list|)
block|{
name|ipa_callsite_param
argument_list|(
name|cs
argument_list|,
name|i
argument_list|)
operator|->
name|info_type
operator|.
name|value
operator|=
name|info_type1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Allocate space for callsite CS.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|ipa_callsite_param_map_create
parameter_list|(
name|struct
name|cgraph_edge
modifier|*
name|cs
parameter_list|)
block|{
name|IPA_EDGE_REF
argument_list|(
name|cs
argument_list|)
operator|->
name|ipa_param_map
operator|=
name|XCNEWVEC
argument_list|(
expr|struct
name|ipa_jump_func
argument_list|,
name|ipa_callsite_param_count
argument_list|(
name|cs
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the call expr tree related to callsite CS.  */
end_comment

begin_function
specifier|static
specifier|inline
name|tree
name|ipa_callsite_tree
parameter_list|(
name|struct
name|cgraph_edge
modifier|*
name|cs
parameter_list|)
block|{
return|return
name|cs
operator|->
name|call_stmt
return|;
block|}
end_function

begin_comment
comment|/* Return the caller (cgraph_node) of CS.  */
end_comment

begin_function
specifier|static
specifier|inline
name|struct
name|cgraph_node
modifier|*
name|ipa_callsite_caller
parameter_list|(
name|struct
name|cgraph_edge
modifier|*
name|cs
parameter_list|)
block|{
return|return
name|cs
operator|->
name|caller
return|;
block|}
end_function

begin_comment
comment|/* Count number of arguments callsite CS has and store it in     ipa_edge structure corresponding to this callsite.  */
end_comment

begin_function
name|void
name|ipa_callsite_compute_count
parameter_list|(
name|struct
name|cgraph_edge
modifier|*
name|cs
parameter_list|)
block|{
name|tree
name|call_tree
decl_stmt|;
name|tree
name|arg
decl_stmt|;
name|int
name|arg_num
decl_stmt|;
name|call_tree
operator|=
name|get_call_expr_in
argument_list|(
name|ipa_callsite_tree
argument_list|(
name|cs
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|call_tree
argument_list|)
operator|==
name|CALL_EXPR
argument_list|)
expr_stmt|;
name|arg
operator|=
name|TREE_OPERAND
argument_list|(
name|call_tree
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|arg_num
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|arg
operator|!=
name|NULL_TREE
condition|;
name|arg
operator|=
name|TREE_CHAIN
argument_list|(
name|arg
argument_list|)
control|)
name|arg_num
operator|++
expr_stmt|;
name|ipa_callsite_param_count_set
argument_list|(
name|cs
argument_list|,
name|arg_num
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compute jump function for all arguments of callsite CS     and insert the information in the ipa_param_map array     in the ipa_edge corresponding to this callsite. (Explanation     on jump functions is in ipa-prop.h).  */
end_comment

begin_function
name|void
name|ipa_callsite_compute_param
parameter_list|(
name|struct
name|cgraph_edge
modifier|*
name|cs
parameter_list|)
block|{
name|tree
name|call_tree
decl_stmt|;
name|tree
name|arg
decl_stmt|,
name|cst_decl
decl_stmt|;
name|int
name|arg_num
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|cgraph_node
modifier|*
name|mt
decl_stmt|;
if|if
condition|(
name|ipa_callsite_param_count
argument_list|(
name|cs
argument_list|)
operator|==
literal|0
condition|)
return|return;
name|ipa_callsite_param_map_create
argument_list|(
name|cs
argument_list|)
expr_stmt|;
name|call_tree
operator|=
name|get_call_expr_in
argument_list|(
name|ipa_callsite_tree
argument_list|(
name|cs
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|call_tree
argument_list|)
operator|==
name|CALL_EXPR
argument_list|)
expr_stmt|;
name|arg
operator|=
name|TREE_OPERAND
argument_list|(
name|call_tree
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|arg_num
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|arg
operator|!=
name|NULL_TREE
condition|;
name|arg
operator|=
name|TREE_CHAIN
argument_list|(
name|arg
argument_list|)
control|)
block|{
comment|/* If the formal parameter was passed as argument, we store           FORMAL_IPATYPE and its index in the caller as the jump function           of this argument.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
name|PARM_DECL
condition|)
block|{
name|mt
operator|=
name|ipa_callsite_caller
argument_list|(
name|cs
argument_list|)
expr_stmt|;
name|i
operator|=
name|ipa_method_tree_map
argument_list|(
name|mt
argument_list|,
name|TREE_VALUE
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
operator|||
name|ipa_method_is_modified
argument_list|(
name|mt
argument_list|,
name|i
argument_list|)
condition|)
name|ipa_callsite_param_set_type
argument_list|(
name|cs
argument_list|,
name|arg_num
argument_list|,
name|UNKNOWN_IPATYPE
argument_list|)
expr_stmt|;
else|else
block|{
name|ipa_callsite_param_set_type
argument_list|(
name|cs
argument_list|,
name|arg_num
argument_list|,
name|FORMAL_IPATYPE
argument_list|)
expr_stmt|;
name|ipa_callsite_param_set_info_type_formal
argument_list|(
name|cs
argument_list|,
name|arg_num
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If a constant value was passed as argument,           we store CONST_IPATYPE and its value as the jump function           of this argument.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|||
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
name|REAL_CST
condition|)
block|{
name|ipa_callsite_param_set_type
argument_list|(
name|cs
argument_list|,
name|arg_num
argument_list|,
name|CONST_IPATYPE
argument_list|)
expr_stmt|;
name|ipa_callsite_param_set_info_type
argument_list|(
name|cs
argument_list|,
name|arg_num
argument_list|,
name|TREE_VALUE
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* This is for the case of Fortran. If the address of a const_decl           was passed as argument then we store           CONST_IPATYPE_REF/CONST_IPATYPE_REF and the constant           value as the jump function corresponding to this argument.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_VALUE
argument_list|(
name|arg
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CONST_DECL
condition|)
block|{
name|cst_decl
operator|=
name|TREE_OPERAND
argument_list|(
name|TREE_VALUE
argument_list|(
name|arg
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|DECL_INITIAL
argument_list|(
name|cst_decl
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|||
name|TREE_CODE
argument_list|(
name|DECL_INITIAL
argument_list|(
name|cst_decl
argument_list|)
argument_list|)
operator|==
name|REAL_CST
condition|)
block|{
name|ipa_callsite_param_set_type
argument_list|(
name|cs
argument_list|,
name|arg_num
argument_list|,
name|CONST_IPATYPE_REF
argument_list|)
expr_stmt|;
name|ipa_callsite_param_set_info_type
argument_list|(
name|cs
argument_list|,
name|arg_num
argument_list|,
name|DECL_INITIAL
argument_list|(
name|cst_decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|ipa_callsite_param_set_type
argument_list|(
name|cs
argument_list|,
name|arg_num
argument_list|,
name|UNKNOWN_IPATYPE
argument_list|)
expr_stmt|;
name|arg_num
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return type of jump function JF.  */
end_comment

begin_function
name|enum
name|jump_func_type
name|get_type
parameter_list|(
name|struct
name|ipa_jump_func
modifier|*
name|jf
parameter_list|)
block|{
return|return
name|jf
operator|->
name|type
return|;
block|}
end_function

begin_comment
comment|/* Return info type of jump function JF.  */
end_comment

begin_function
name|union
name|parameter_info
modifier|*
name|ipa_jf_get_info_type
parameter_list|(
name|struct
name|ipa_jump_func
modifier|*
name|jf
parameter_list|)
block|{
return|return
operator|&
operator|(
name|jf
operator|->
name|info_type
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Allocate and initialize ipa_node structure.      cgraph_node NODE points to the new allocated ipa_node.  */
end_comment

begin_function
name|void
name|ipa_node_create
parameter_list|(
name|struct
name|cgraph_node
modifier|*
name|node
parameter_list|)
block|{
name|node
operator|->
name|aux
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ipa_node
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Allocate and initialize ipa_node structure for all    nodes in callgraph.  */
end_comment

begin_function
name|void
name|ipa_nodes_create
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|cgraph_node
modifier|*
name|node
decl_stmt|;
for|for
control|(
name|node
operator|=
name|cgraph_nodes
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
name|ipa_node_create
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Allocate and initialize ipa_edge structure.  */
end_comment

begin_function
name|void
name|ipa_edges_create
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|cgraph_node
modifier|*
name|node
decl_stmt|;
name|struct
name|cgraph_edge
modifier|*
name|cs
decl_stmt|;
for|for
control|(
name|node
operator|=
name|cgraph_nodes
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
for|for
control|(
name|cs
operator|=
name|node
operator|->
name|callees
init|;
name|cs
condition|;
name|cs
operator|=
name|cs
operator|->
name|next_callee
control|)
name|cs
operator|->
name|aux
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ipa_edge
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Free ipa_node structure.  */
end_comment

begin_function
name|void
name|ipa_nodes_free
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|cgraph_node
modifier|*
name|node
decl_stmt|;
for|for
control|(
name|node
operator|=
name|cgraph_nodes
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
block|{
name|free
argument_list|(
name|node
operator|->
name|aux
argument_list|)
expr_stmt|;
name|node
operator|->
name|aux
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Free ipa_edge structure.  */
end_comment

begin_function
name|void
name|ipa_edges_free
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|cgraph_node
modifier|*
name|node
decl_stmt|;
name|struct
name|cgraph_edge
modifier|*
name|cs
decl_stmt|;
for|for
control|(
name|node
operator|=
name|cgraph_nodes
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
for|for
control|(
name|cs
operator|=
name|node
operator|->
name|callees
init|;
name|cs
condition|;
name|cs
operator|=
name|cs
operator|->
name|next_callee
control|)
block|{
name|free
argument_list|(
name|cs
operator|->
name|aux
argument_list|)
expr_stmt|;
name|cs
operator|->
name|aux
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Free ipa data structures of ipa_node and ipa_edge.  */
end_comment

begin_function
name|void
name|ipa_free
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|cgraph_node
modifier|*
name|node
decl_stmt|;
name|struct
name|cgraph_edge
modifier|*
name|cs
decl_stmt|;
for|for
control|(
name|node
operator|=
name|cgraph_nodes
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
block|{
if|if
condition|(
name|node
operator|->
name|aux
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|IPA_NODE_REF
argument_list|(
name|node
argument_list|)
operator|->
name|ipcp_cval
condition|)
name|free
argument_list|(
name|IPA_NODE_REF
argument_list|(
name|node
argument_list|)
operator|->
name|ipcp_cval
argument_list|)
expr_stmt|;
if|if
condition|(
name|IPA_NODE_REF
argument_list|(
name|node
argument_list|)
operator|->
name|ipa_param_tree
condition|)
name|free
argument_list|(
name|IPA_NODE_REF
argument_list|(
name|node
argument_list|)
operator|->
name|ipa_param_tree
argument_list|)
expr_stmt|;
if|if
condition|(
name|IPA_NODE_REF
argument_list|(
name|node
argument_list|)
operator|->
name|ipa_mod
condition|)
name|free
argument_list|(
name|IPA_NODE_REF
argument_list|(
name|node
argument_list|)
operator|->
name|ipa_mod
argument_list|)
expr_stmt|;
for|for
control|(
name|cs
operator|=
name|node
operator|->
name|callees
init|;
name|cs
condition|;
name|cs
operator|=
name|cs
operator|->
name|next_callee
control|)
block|{
if|if
condition|(
name|cs
operator|->
name|aux
condition|)
if|if
condition|(
name|IPA_EDGE_REF
argument_list|(
name|cs
argument_list|)
operator|->
name|ipa_param_map
condition|)
name|free
argument_list|(
name|IPA_EDGE_REF
argument_list|(
name|cs
argument_list|)
operator|->
name|ipa_param_map
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Print ipa_tree_map data structures of all methods in the     callgraph to F.  */
end_comment

begin_function
name|void
name|ipa_method_tree_print
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|count
decl_stmt|;
name|tree
name|temp
decl_stmt|;
name|struct
name|cgraph_node
modifier|*
name|node
decl_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\nPARAM TREE MAP PRINT\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|node
operator|=
name|cgraph_nodes
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"method  %s Trees :: \n"
argument_list|,
name|cgraph_node_name
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|count
operator|=
name|ipa_method_formal_count
argument_list|(
name|node
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|temp
operator|=
name|ipa_method_get_tree
argument_list|(
name|node
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|temp
argument_list|)
operator|==
name|PARM_DECL
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"  param [%d] : %s\n"
argument_list|,
name|i
argument_list|,
call|(
modifier|*
name|lang_hooks
operator|.
name|decl_printable_name
call|)
argument_list|(
name|temp
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Print ipa_modify data structures of all methods in the     callgraph to F.  */
end_comment

begin_function
name|void
name|ipa_method_modify_print
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|count
decl_stmt|;
name|bool
name|temp
decl_stmt|;
name|struct
name|cgraph_node
modifier|*
name|node
decl_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\nMODIFY PRINT\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|node
operator|=
name|cgraph_nodes
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"method  %s :: \n"
argument_list|,
name|cgraph_node_name
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|count
operator|=
name|ipa_method_formal_count
argument_list|(
name|node
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|temp
operator|=
name|ipa_method_is_modified
argument_list|(
name|node
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|" param [%d] true \n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|f
argument_list|,
literal|" param [%d] false \n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

end_unit

