begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Medium-level subroutines: convert bit-field store and extract    and shifts, multiplies and divides to rtl instructions.    Copyright (C) 1987, 88, 89, 92-97, 1998 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"insn-flags.h"
end_include

begin_include
include|#
directive|include
file|"insn-codes.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_decl_stmt
specifier|static
name|void
name|store_fixed_bit_field
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|store_split_bit_field
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|,
name|int
operator|,
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|extract_fixed_bit_field
name|PROTO
argument_list|(
operator|(
expr|enum
name|machine_mode
operator|,
name|rtx
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|rtx
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|mask_rtx
name|PROTO
argument_list|(
operator|(
expr|enum
name|machine_mode
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|lshift_value
name|PROTO
argument_list|(
operator|(
expr|enum
name|machine_mode
operator|,
name|rtx
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|extract_split_bit_field
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_cmp_and_jump
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
expr|enum
name|rtx_code
operator|,
expr|enum
name|machine_mode
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CEIL
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|(((x) + (y) - 1) / (y))
end_define

begin_comment
comment|/* Non-zero means divides or modulus operations are relatively cheap for    powers of two, so don't use branches; emit the operation instead.     Usually, this will mean that the MD file will emit non-branch    sequences.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|sdiv_pow2_cheap
decl_stmt|,
name|smod_pow2_cheap
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|SLOW_UNALIGNED_ACCESS
end_ifndef

begin_define
define|#
directive|define
name|SLOW_UNALIGNED_ACCESS
value|STRICT_ALIGNMENT
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* For compilers that support multiple targets with different word sizes,    MAX_BITS_PER_WORD contains the biggest value of BITS_PER_WORD.  An example    is the H8/300(H) compiler.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MAX_BITS_PER_WORD
end_ifndef

begin_define
define|#
directive|define
name|MAX_BITS_PER_WORD
value|BITS_PER_WORD
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Cost of various pieces of RTL.  Note that some of these are indexed by shift count,    and some by mode.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|add_cost
decl_stmt|,
name|negate_cost
decl_stmt|,
name|zero_cost
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|shift_cost
index|[
name|MAX_BITS_PER_WORD
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|shiftadd_cost
index|[
name|MAX_BITS_PER_WORD
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|shiftsub_cost
index|[
name|MAX_BITS_PER_WORD
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mul_cost
index|[
name|NUM_MACHINE_MODES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|div_cost
index|[
name|NUM_MACHINE_MODES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mul_widen_cost
index|[
name|NUM_MACHINE_MODES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mul_highpart_cost
index|[
name|NUM_MACHINE_MODES
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|init_expmed
parameter_list|()
block|{
name|char
modifier|*
name|free_point
decl_stmt|;
comment|/* This is "some random pseudo register" for purposes of calling recog      to see what insns exist.  */
name|rtx
name|reg
init|=
name|gen_rtx_REG
argument_list|(
name|word_mode
argument_list|,
literal|10000
argument_list|)
decl_stmt|;
name|rtx
name|shift_insn
decl_stmt|,
name|shiftadd_insn
decl_stmt|,
name|shiftsub_insn
decl_stmt|;
name|int
name|dummy
decl_stmt|;
name|int
name|m
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|,
name|wider_mode
decl_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
comment|/* Since we are on the permanent obstack, we must be sure we save this      spot AFTER we call start_sequence, since it will reuse the rtl it      makes.  */
name|free_point
operator|=
operator|(
name|char
operator|*
operator|)
name|oballoc
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|reg
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|word_mode
argument_list|,
literal|10000
argument_list|)
expr_stmt|;
name|zero_cost
operator|=
name|rtx_cost
argument_list|(
name|const0_rtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_cost
operator|=
name|rtx_cost
argument_list|(
name|gen_rtx_PLUS
argument_list|(
name|word_mode
argument_list|,
name|reg
argument_list|,
name|reg
argument_list|)
argument_list|,
name|SET
argument_list|)
expr_stmt|;
name|shift_insn
operator|=
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|reg
argument_list|,
name|gen_rtx_ASHIFT
argument_list|(
name|word_mode
argument_list|,
name|reg
argument_list|,
name|const0_rtx
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|shiftadd_insn
operator|=
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|reg
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|word_mode
argument_list|,
name|gen_rtx_MULT
argument_list|(
name|word_mode
argument_list|,
name|reg
argument_list|,
name|const0_rtx
argument_list|)
argument_list|,
name|reg
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|shiftsub_insn
operator|=
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|reg
argument_list|,
name|gen_rtx_MINUS
argument_list|(
name|word_mode
argument_list|,
name|gen_rtx_MULT
argument_list|(
name|word_mode
argument_list|,
name|reg
argument_list|,
name|const0_rtx
argument_list|)
argument_list|,
name|reg
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|init_recog
argument_list|()
expr_stmt|;
name|shift_cost
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|shiftadd_cost
index|[
literal|0
index|]
operator|=
name|shiftsub_cost
index|[
literal|0
index|]
operator|=
name|add_cost
expr_stmt|;
for|for
control|(
name|m
operator|=
literal|1
init|;
name|m
operator|<
name|MAX_BITS_PER_WORD
condition|;
name|m
operator|++
control|)
block|{
name|shift_cost
index|[
name|m
index|]
operator|=
name|shiftadd_cost
index|[
name|m
index|]
operator|=
name|shiftsub_cost
index|[
name|m
index|]
operator|=
literal|32000
expr_stmt|;
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|shift_insn
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|=
name|GEN_INT
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|recog
argument_list|(
name|PATTERN
argument_list|(
name|shift_insn
argument_list|)
argument_list|,
name|shift_insn
argument_list|,
operator|&
name|dummy
argument_list|)
operator|>=
literal|0
condition|)
name|shift_cost
index|[
name|m
index|]
operator|=
name|rtx_cost
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|shift_insn
argument_list|)
argument_list|)
argument_list|,
name|SET
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|shiftadd_insn
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|=
name|GEN_INT
argument_list|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|recog
argument_list|(
name|PATTERN
argument_list|(
name|shiftadd_insn
argument_list|)
argument_list|,
name|shiftadd_insn
argument_list|,
operator|&
name|dummy
argument_list|)
operator|>=
literal|0
condition|)
name|shiftadd_cost
index|[
name|m
index|]
operator|=
name|rtx_cost
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|shiftadd_insn
argument_list|)
argument_list|)
argument_list|,
name|SET
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|shiftsub_insn
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|=
name|GEN_INT
argument_list|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|recog
argument_list|(
name|PATTERN
argument_list|(
name|shiftsub_insn
argument_list|)
argument_list|,
name|shiftsub_insn
argument_list|,
operator|&
name|dummy
argument_list|)
operator|>=
literal|0
condition|)
name|shiftsub_cost
index|[
name|m
index|]
operator|=
name|rtx_cost
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|shiftsub_insn
argument_list|)
argument_list|)
argument_list|,
name|SET
argument_list|)
expr_stmt|;
block|}
name|negate_cost
operator|=
name|rtx_cost
argument_list|(
name|gen_rtx_NEG
argument_list|(
name|word_mode
argument_list|,
name|reg
argument_list|)
argument_list|,
name|SET
argument_list|)
expr_stmt|;
name|sdiv_pow2_cheap
operator|=
operator|(
name|rtx_cost
argument_list|(
name|gen_rtx_DIV
argument_list|(
name|word_mode
argument_list|,
name|reg
argument_list|,
name|GEN_INT
argument_list|(
literal|32
argument_list|)
argument_list|)
argument_list|,
name|SET
argument_list|)
operator|<=
literal|2
operator|*
name|add_cost
operator|)
expr_stmt|;
name|smod_pow2_cheap
operator|=
operator|(
name|rtx_cost
argument_list|(
name|gen_rtx_MOD
argument_list|(
name|word_mode
argument_list|,
name|reg
argument_list|,
name|GEN_INT
argument_list|(
literal|32
argument_list|)
argument_list|)
argument_list|,
name|SET
argument_list|)
operator|<=
literal|2
operator|*
name|add_cost
operator|)
expr_stmt|;
for|for
control|(
name|mode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_INT
argument_list|)
init|;
name|mode
operator|!=
name|VOIDmode
condition|;
name|mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
control|)
block|{
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
literal|10000
argument_list|)
expr_stmt|;
name|div_cost
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|=
name|rtx_cost
argument_list|(
name|gen_rtx_UDIV
argument_list|(
name|mode
argument_list|,
name|reg
argument_list|,
name|reg
argument_list|)
argument_list|,
name|SET
argument_list|)
expr_stmt|;
name|mul_cost
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|=
name|rtx_cost
argument_list|(
name|gen_rtx_MULT
argument_list|(
name|mode
argument_list|,
name|reg
argument_list|,
name|reg
argument_list|)
argument_list|,
name|SET
argument_list|)
expr_stmt|;
name|wider_mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|wider_mode
operator|!=
name|VOIDmode
condition|)
block|{
name|mul_widen_cost
index|[
operator|(
name|int
operator|)
name|wider_mode
index|]
operator|=
name|rtx_cost
argument_list|(
name|gen_rtx_MULT
argument_list|(
name|wider_mode
argument_list|,
name|gen_rtx_ZERO_EXTEND
argument_list|(
name|wider_mode
argument_list|,
name|reg
argument_list|)
argument_list|,
name|gen_rtx_ZERO_EXTEND
argument_list|(
name|wider_mode
argument_list|,
name|reg
argument_list|)
argument_list|)
argument_list|,
name|SET
argument_list|)
expr_stmt|;
name|mul_highpart_cost
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|=
name|rtx_cost
argument_list|(
name|gen_rtx_TRUNCATE
argument_list|(
name|mode
argument_list|,
name|gen_rtx_LSHIFTRT
argument_list|(
name|wider_mode
argument_list|,
name|gen_rtx_MULT
argument_list|(
name|wider_mode
argument_list|,
name|gen_rtx_ZERO_EXTEND
argument_list|(
name|wider_mode
argument_list|,
name|reg
argument_list|)
argument_list|,
name|gen_rtx_ZERO_EXTEND
argument_list|(
name|wider_mode
argument_list|,
name|reg
argument_list|)
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|SET
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Free the objects we just allocated.  */
name|end_sequence
argument_list|()
expr_stmt|;
name|obfree
argument_list|(
name|free_point
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return an rtx representing minus the value of X.    MODE is the intended mode of the result,    useful if X is a CONST_INT.  */
end_comment

begin_function
name|rtx
name|negate_rtx
parameter_list|(
name|mode
parameter_list|,
name|x
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|x
decl_stmt|;
block|{
name|rtx
name|result
init|=
name|simplify_unary_operation
argument_list|(
name|NEG
argument_list|,
name|mode
argument_list|,
name|x
argument_list|,
name|mode
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|==
literal|0
condition|)
name|result
operator|=
name|expand_unop
argument_list|(
name|mode
argument_list|,
name|neg_optab
argument_list|,
name|x
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate code to store value from rtx VALUE    into a bit-field within structure STR_RTX    containing BITSIZE bits starting at bit BITNUM.    FIELDMODE is the machine-mode of the FIELD_DECL node for this field.    ALIGN is the alignment that STR_RTX is known to have, measured in bytes.    TOTAL_SIZE is the size of the structure in bytes, or -1 if varying.  */
end_comment

begin_comment
comment|/* ??? Note that there are two different ideas here for how    to determine the size to count bits within, for a register.    One is BITS_PER_WORD, and the other is the size of operand 3    of the insv pattern.  (The latter assumes that an n-bit machine    will be able to insert bit fields up to n bits wide.)    It isn't certain that either of these is right.    extract_bit_field has the same quandary.  */
end_comment

begin_function
name|rtx
name|store_bit_field
parameter_list|(
name|str_rtx
parameter_list|,
name|bitsize
parameter_list|,
name|bitnum
parameter_list|,
name|fieldmode
parameter_list|,
name|value
parameter_list|,
name|align
parameter_list|,
name|total_size
parameter_list|)
name|rtx
name|str_rtx
decl_stmt|;
specifier|register
name|int
name|bitsize
decl_stmt|;
name|int
name|bitnum
decl_stmt|;
name|enum
name|machine_mode
name|fieldmode
decl_stmt|;
name|rtx
name|value
decl_stmt|;
name|int
name|align
decl_stmt|;
name|int
name|total_size
decl_stmt|;
block|{
name|int
name|unit
init|=
operator|(
name|GET_CODE
argument_list|(
name|str_rtx
argument_list|)
operator|==
name|MEM
operator|)
condition|?
name|BITS_PER_UNIT
else|:
name|BITS_PER_WORD
decl_stmt|;
specifier|register
name|int
name|offset
init|=
name|bitnum
operator|/
name|unit
decl_stmt|;
specifier|register
name|int
name|bitpos
init|=
name|bitnum
operator|%
name|unit
decl_stmt|;
specifier|register
name|rtx
name|op0
init|=
name|str_rtx
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|str_rtx
argument_list|)
operator|==
name|MEM
operator|&&
operator|!
name|MEM_IN_STRUCT_P
argument_list|(
name|str_rtx
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Discount the part of the structure before the desired byte.      We need to know how many bytes are safe to reference after it.  */
if|if
condition|(
name|total_size
operator|>=
literal|0
condition|)
name|total_size
operator|-=
operator|(
name|bitpos
operator|/
name|BIGGEST_ALIGNMENT
operator|*
operator|(
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
operator|)
operator|)
expr_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
comment|/* The following line once was done only if WORDS_BIG_ENDIAN, 	 but I think that is a mistake.  WORDS_BIG_ENDIAN is 	 meaningful at a much higher level; when structures are copied 	 between memory and regs, the higher-numbered regs 	 always get higher addresses.  */
name|offset
operator|+=
name|SUBREG_WORD
argument_list|(
name|op0
argument_list|)
expr_stmt|;
comment|/* We used to adjust BITPOS here, but now we do the whole adjustment 	 right after the loop.  */
name|op0
operator|=
name|SUBREG_REG
argument_list|(
name|op0
argument_list|)
expr_stmt|;
block|}
comment|/* If OP0 is a register, BITPOS must count within a word.      But as we have it, it counts within whatever size OP0 now has.      On a bigendian machine, these are not the same, so convert.  */
if|if
condition|(
name|BYTES_BIG_ENDIAN
operator|&&
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|MEM
operator|&&
name|unit
operator|>
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
condition|)
name|bitpos
operator|+=
name|unit
operator|-
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
expr_stmt|;
name|value
operator|=
name|protect_from_queue
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_force_mem
condition|)
name|value
operator|=
name|force_not_mem
argument_list|(
name|value
argument_list|)
expr_stmt|;
comment|/* Note that the adjustment of BITPOS above has no effect on whether      BITPOS is 0 in a REG bigger than a word.  */
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|fieldmode
argument_list|)
operator|>=
name|UNITS_PER_WORD
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|MEM
operator|||
operator|!
name|SLOW_UNALIGNED_ACCESS
operator|||
operator|(
name|offset
operator|*
name|BITS_PER_UNIT
operator|%
name|bitsize
operator|==
literal|0
operator|&&
name|align
operator|%
name|GET_MODE_SIZE
argument_list|(
name|fieldmode
argument_list|)
operator|==
literal|0
operator|)
operator|)
operator|&&
name|bitpos
operator|==
literal|0
operator|&&
name|bitsize
operator|==
name|GET_MODE_BITSIZE
argument_list|(
name|fieldmode
argument_list|)
condition|)
block|{
comment|/* Storing in a full-word or multi-word field in a register 	 can be done with just SUBREG.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|fieldmode
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|REG
condition|)
name|op0
operator|=
name|gen_rtx_SUBREG
argument_list|(
name|fieldmode
argument_list|,
name|op0
argument_list|,
name|offset
argument_list|)
expr_stmt|;
else|else
name|op0
operator|=
name|change_address
argument_list|(
name|op0
argument_list|,
name|fieldmode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|emit_move_insn
argument_list|(
name|op0
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
comment|/* Storing an lsb-aligned field in a register      can be done with a movestrict instruction.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|MEM
operator|&&
operator|(
name|BYTES_BIG_ENDIAN
condition|?
name|bitpos
operator|+
name|bitsize
operator|==
name|unit
else|:
name|bitpos
operator|==
literal|0
operator|)
operator|&&
name|bitsize
operator|==
name|GET_MODE_BITSIZE
argument_list|(
name|fieldmode
argument_list|)
operator|&&
operator|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|==
name|fieldmode
operator|||
operator|(
name|movstrict_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|fieldmode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
operator|)
operator|)
condition|)
block|{
comment|/* Get appropriate low part of the value being stored.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|CONST_INT
operator|||
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|REG
condition|)
name|value
operator|=
name|gen_lowpart
argument_list|(
name|fieldmode
argument_list|,
name|value
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|LABEL_REF
operator|||
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|CONST
operator|)
condition|)
name|value
operator|=
name|convert_to_mode
argument_list|(
name|fieldmode
argument_list|,
name|value
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|==
name|fieldmode
condition|)
name|emit_move_insn
argument_list|(
name|op0
argument_list|,
name|value
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|icode
init|=
name|movstrict_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|fieldmode
index|]
operator|.
name|insn_code
decl_stmt|;
if|if
condition|(
operator|!
call|(
modifier|*
name|insn_operand_predicate
index|[
name|icode
index|]
index|[
literal|1
index|]
call|)
argument_list|(
name|value
argument_list|,
name|fieldmode
argument_list|)
condition|)
name|value
operator|=
name|copy_to_mode_reg
argument_list|(
name|fieldmode
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|gen_rtx_SUBREG
argument_list|(
name|fieldmode
argument_list|,
name|op0
argument_list|,
name|offset
argument_list|)
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|value
return|;
block|}
comment|/* Handle fields bigger than a word.  */
if|if
condition|(
name|bitsize
operator|>
name|BITS_PER_WORD
condition|)
block|{
comment|/* Here we transfer the words of the field 	 in the order least significant first. 	 This is because the most significant word is the one which may 	 be less than full. 	 However, only do that if the value is not BLKmode.  */
name|int
name|backwards
init|=
name|WORDS_BIG_ENDIAN
operator|&&
name|fieldmode
operator|!=
name|BLKmode
decl_stmt|;
name|int
name|nwords
init|=
operator|(
name|bitsize
operator|+
operator|(
name|BITS_PER_WORD
operator|-
literal|1
operator|)
operator|)
operator|/
name|BITS_PER_WORD
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* This is the mode we must force value to, so that there will be enough 	 subwords to extract.  Note that fieldmode will often (always?) be 	 VOIDmode, because that is what store_field uses to indicate that this 	 is a bit field, but passing VOIDmode to operand_subword_force will 	 result in an abort.  */
name|fieldmode
operator|=
name|mode_for_size
argument_list|(
name|nwords
operator|*
name|BITS_PER_WORD
argument_list|,
name|MODE_INT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nwords
condition|;
name|i
operator|++
control|)
block|{
comment|/* If I is 0, use the low-order word in both field and target; 	     if I is 1, use the next to lowest word; and so on.  */
name|int
name|wordnum
init|=
operator|(
name|backwards
condition|?
name|nwords
operator|-
name|i
operator|-
literal|1
else|:
name|i
operator|)
decl_stmt|;
name|int
name|bit_offset
init|=
operator|(
name|backwards
condition|?
name|MAX
argument_list|(
name|bitsize
operator|-
operator|(
name|i
operator|+
literal|1
operator|)
operator|*
name|BITS_PER_WORD
argument_list|,
literal|0
argument_list|)
else|:
name|i
operator|*
name|BITS_PER_WORD
operator|)
decl_stmt|;
name|store_bit_field
argument_list|(
name|op0
argument_list|,
name|MIN
argument_list|(
name|BITS_PER_WORD
argument_list|,
name|bitsize
operator|-
name|i
operator|*
name|BITS_PER_WORD
argument_list|)
argument_list|,
name|bitnum
operator|+
name|bit_offset
argument_list|,
name|word_mode
argument_list|,
name|operand_subword_force
argument_list|(
name|value
argument_list|,
name|wordnum
argument_list|,
operator|(
name|GET_MODE
argument_list|(
name|value
argument_list|)
operator|==
name|VOIDmode
condition|?
name|fieldmode
else|:
name|GET_MODE
argument_list|(
name|value
argument_list|)
operator|)
argument_list|)
argument_list|,
name|align
argument_list|,
name|total_size
argument_list|)
expr_stmt|;
block|}
return|return
name|value
return|;
block|}
comment|/* From here on we can assume that the field to be stored in is      a full-word (whatever type that is), since it is shorter than a word.  */
comment|/* OFFSET is the number of words or bytes (UNIT says which)      from STR_RTX to the first word or byte containing part of the field.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|REG
condition|)
block|{
if|if
condition|(
name|offset
operator|!=
literal|0
operator|||
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|>
name|UNITS_PER_WORD
condition|)
name|op0
operator|=
name|gen_rtx_SUBREG
argument_list|(
name|TYPE_MODE
argument_list|(
name|type_for_size
argument_list|(
name|BITS_PER_WORD
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|op0
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|op0
operator|=
name|protect_from_queue
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* If VALUE is a floating-point mode, access it as an integer of the      corresponding size.  This can occur on a machine with 64 bit registers      that uses SFmode for float.  This can also occur for unaligned float      structure fields.  */
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|==
name|MODE_FLOAT
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|!=
name|REG
condition|)
name|value
operator|=
name|copy_to_reg
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|value
operator|=
name|gen_rtx_SUBREG
argument_list|(
name|word_mode
argument_list|,
name|value
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Now OFFSET is nonzero only if OP0 is memory      and is therefore always measured in bytes.  */
ifdef|#
directive|ifdef
name|HAVE_insv
if|if
condition|(
name|HAVE_insv
operator|&&
name|GET_MODE
argument_list|(
name|value
argument_list|)
operator|!=
name|BLKmode
operator|&&
operator|!
operator|(
name|bitsize
operator|==
literal|1
operator|&&
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|CONST_INT
operator|)
comment|/* Ensure insv's size is wide enough for this field.  */
operator|&&
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|insn_operand_mode
index|[
operator|(
name|int
operator|)
name|CODE_FOR_insv
index|]
index|[
literal|3
index|]
argument_list|)
operator|>=
name|bitsize
operator|)
operator|&&
operator|!
operator|(
operator|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|SUBREG
operator|)
operator|&&
operator|(
name|bitsize
operator|+
name|bitpos
operator|>
name|GET_MODE_BITSIZE
argument_list|(
name|insn_operand_mode
index|[
operator|(
name|int
operator|)
name|CODE_FOR_insv
index|]
index|[
literal|3
index|]
argument_list|)
operator|)
operator|)
condition|)
block|{
name|int
name|xbitpos
init|=
name|bitpos
decl_stmt|;
name|rtx
name|value1
decl_stmt|;
name|rtx
name|xop0
init|=
name|op0
decl_stmt|;
name|rtx
name|last
init|=
name|get_last_insn
argument_list|()
decl_stmt|;
name|rtx
name|pat
decl_stmt|;
name|enum
name|machine_mode
name|maxmode
init|=
name|insn_operand_mode
index|[
operator|(
name|int
operator|)
name|CODE_FOR_insv
index|]
index|[
literal|3
index|]
decl_stmt|;
name|int
name|save_volatile_ok
init|=
name|volatile_ok
decl_stmt|;
name|volatile_ok
operator|=
literal|1
expr_stmt|;
comment|/* If this machine's insv can only insert into a register, copy OP0 	 into a register and save it back later.  */
comment|/* This used to check flag_force_mem, but that was a serious 	 de-optimization now that flag_force_mem is enabled by -O2.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|MEM
operator|&&
operator|!
operator|(
call|(
modifier|*
name|insn_operand_predicate
index|[
operator|(
name|int
operator|)
name|CODE_FOR_insv
index|]
index|[
literal|0
index|]
call|)
argument_list|(
name|op0
argument_list|,
name|VOIDmode
argument_list|)
operator|)
condition|)
block|{
name|rtx
name|tempreg
decl_stmt|;
name|enum
name|machine_mode
name|bestmode
decl_stmt|;
comment|/* Get the mode to use for inserting into this field.  If OP0 is 	     BLKmode, get the smallest mode consistent with the alignment. If 	     OP0 is a non-BLKmode object that is no wider than MAXMODE, use its 	     mode. Otherwise, use the smallest mode containing the field.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|==
name|BLKmode
operator|||
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|maxmode
argument_list|)
condition|)
name|bestmode
operator|=
name|get_best_mode
argument_list|(
name|bitsize
argument_list|,
name|bitnum
argument_list|,
name|align
operator|*
name|BITS_PER_UNIT
argument_list|,
name|maxmode
argument_list|,
name|MEM_VOLATILE_P
argument_list|(
name|op0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|bestmode
operator|=
name|GET_MODE
argument_list|(
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
name|bestmode
operator|==
name|VOIDmode
operator|||
operator|(
name|SLOW_UNALIGNED_ACCESS
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|bestmode
argument_list|)
operator|>
name|align
operator|)
condition|)
goto|goto
name|insv_loses
goto|;
comment|/* Adjust address to point to the containing unit of that mode.  */
name|unit
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|bestmode
argument_list|)
expr_stmt|;
comment|/* Compute offset as multiple of this unit, counting in bytes.  */
name|offset
operator|=
operator|(
name|bitnum
operator|/
name|unit
operator|)
operator|*
name|GET_MODE_SIZE
argument_list|(
name|bestmode
argument_list|)
expr_stmt|;
name|bitpos
operator|=
name|bitnum
operator|%
name|unit
expr_stmt|;
name|op0
operator|=
name|change_address
argument_list|(
name|op0
argument_list|,
name|bestmode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fetch that unit, store the bitfield in it, then store the unit.  */
name|tempreg
operator|=
name|copy_to_reg
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|store_bit_field
argument_list|(
name|tempreg
argument_list|,
name|bitsize
argument_list|,
name|bitpos
argument_list|,
name|fieldmode
argument_list|,
name|value
argument_list|,
name|align
argument_list|,
name|total_size
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|op0
argument_list|,
name|tempreg
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
name|volatile_ok
operator|=
name|save_volatile_ok
expr_stmt|;
comment|/* Add OFFSET into OP0's address.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|xop0
argument_list|)
operator|==
name|MEM
condition|)
name|xop0
operator|=
name|change_address
argument_list|(
name|xop0
argument_list|,
name|byte_mode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|xop0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If xop0 is a register, we need it in MAXMODE 	 to make it acceptable to the format of insv.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|xop0
argument_list|)
operator|==
name|SUBREG
condition|)
comment|/* We can't just change the mode, because this might clobber op0, 	   and we will need the original value of op0 if insv fails.  */
name|xop0
operator|=
name|gen_rtx_SUBREG
argument_list|(
name|maxmode
argument_list|,
name|SUBREG_REG
argument_list|(
name|xop0
argument_list|)
argument_list|,
name|SUBREG_WORD
argument_list|(
name|xop0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|xop0
argument_list|)
operator|==
name|REG
operator|&&
name|GET_MODE
argument_list|(
name|xop0
argument_list|)
operator|!=
name|maxmode
condition|)
name|xop0
operator|=
name|gen_rtx_SUBREG
argument_list|(
name|maxmode
argument_list|,
name|xop0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* On big-endian machines, we count bits from the most significant. 	 If the bit field insn does not, we must invert.  */
if|if
condition|(
name|BITS_BIG_ENDIAN
operator|!=
name|BYTES_BIG_ENDIAN
condition|)
name|xbitpos
operator|=
name|unit
operator|-
name|bitsize
operator|-
name|xbitpos
expr_stmt|;
comment|/* We have been counting XBITPOS within UNIT. 	 Count instead within the size of the register.  */
if|if
condition|(
name|BITS_BIG_ENDIAN
operator|&&
name|GET_CODE
argument_list|(
name|xop0
argument_list|)
operator|!=
name|MEM
condition|)
name|xbitpos
operator|+=
name|GET_MODE_BITSIZE
argument_list|(
name|maxmode
argument_list|)
operator|-
name|unit
expr_stmt|;
name|unit
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|maxmode
argument_list|)
expr_stmt|;
comment|/* Convert VALUE to maxmode (which insv insn wants) in VALUE1.  */
name|value1
operator|=
name|value
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|value
argument_list|)
operator|!=
name|maxmode
condition|)
block|{
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|>=
name|bitsize
condition|)
block|{
comment|/* Optimization: Don't bother really extending VALUE 		 if it has all the bits we will actually use.  However, 		 if we must narrow it, be sure we do it correctly.  */
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|<
name|GET_MODE_SIZE
argument_list|(
name|maxmode
argument_list|)
condition|)
block|{
comment|/* Avoid making subreg of a subreg, or of a mem.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|value1
argument_list|)
operator|!=
name|REG
condition|)
name|value1
operator|=
name|copy_to_reg
argument_list|(
name|value1
argument_list|)
expr_stmt|;
name|value1
operator|=
name|gen_rtx_SUBREG
argument_list|(
name|maxmode
argument_list|,
name|value1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|value1
operator|=
name|gen_lowpart
argument_list|(
name|maxmode
argument_list|,
name|value1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|CONSTANT_P
argument_list|(
name|value
argument_list|)
condition|)
comment|/* Parse phase is supposed to make VALUE's data type 	       match that of the component reference, which is a type 	       at least as wide as the field; so VALUE should have 	       a mode that corresponds to that type.  */
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* If this machine's insv insists on a register, 	 get VALUE1 into a register.  */
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|insn_operand_predicate
index|[
operator|(
name|int
operator|)
name|CODE_FOR_insv
index|]
index|[
literal|3
index|]
call|)
argument_list|(
name|value1
argument_list|,
name|maxmode
argument_list|)
operator|)
condition|)
name|value1
operator|=
name|force_reg
argument_list|(
name|maxmode
argument_list|,
name|value1
argument_list|)
expr_stmt|;
name|pat
operator|=
name|gen_insv
argument_list|(
name|xop0
argument_list|,
name|GEN_INT
argument_list|(
name|bitsize
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|xbitpos
argument_list|)
argument_list|,
name|value1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pat
condition|)
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
else|else
block|{
name|delete_insns_since
argument_list|(
name|last
argument_list|)
expr_stmt|;
name|store_fixed_bit_field
argument_list|(
name|op0
argument_list|,
name|offset
argument_list|,
name|bitsize
argument_list|,
name|bitpos
argument_list|,
name|value
argument_list|,
name|align
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|insv_loses
label|:
endif|#
directive|endif
comment|/* Insv is not available; store using shifts and boolean ops.  */
name|store_fixed_bit_field
argument_list|(
name|op0
argument_list|,
name|offset
argument_list|,
name|bitsize
argument_list|,
name|bitpos
argument_list|,
name|value
argument_list|,
name|align
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Use shifts and boolean operations to store VALUE    into a bit field of width BITSIZE    in a memory location specified by OP0 except offset by OFFSET bytes.      (OFFSET must be 0 if OP0 is a register.)    The field starts at position BITPOS within the byte.     (If OP0 is a register, it may be a full word or a narrower mode,      but BITPOS still counts within a full word,      which is significant on bigendian machines.)    STRUCT_ALIGN is the alignment the structure is known to have (in bytes).     Note that protect_from_queue has already been done on OP0 and VALUE.  */
end_comment

begin_function
specifier|static
name|void
name|store_fixed_bit_field
parameter_list|(
name|op0
parameter_list|,
name|offset
parameter_list|,
name|bitsize
parameter_list|,
name|bitpos
parameter_list|,
name|value
parameter_list|,
name|struct_align
parameter_list|)
specifier|register
name|rtx
name|op0
decl_stmt|;
specifier|register
name|int
name|offset
decl_stmt|,
name|bitsize
decl_stmt|,
name|bitpos
decl_stmt|;
specifier|register
name|rtx
name|value
decl_stmt|;
name|int
name|struct_align
decl_stmt|;
block|{
specifier|register
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|total_bits
init|=
name|BITS_PER_WORD
decl_stmt|;
name|rtx
name|subtarget
decl_stmt|,
name|temp
decl_stmt|;
name|int
name|all_zero
init|=
literal|0
decl_stmt|;
name|int
name|all_one
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|SLOW_UNALIGNED_ACCESS
condition|)
name|struct_align
operator|=
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
expr_stmt|;
comment|/* There is a case not handled here:      a structure with a known alignment of just a halfword      and a field split across two aligned halfwords within the structure.      Or likewise a structure with a known alignment of just a byte      and a field split across two bytes.      Such cases are not supposed to be able to occur.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
if|if
condition|(
name|offset
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Special treatment for a bit field split across two registers.  */
if|if
condition|(
name|bitsize
operator|+
name|bitpos
operator|>
name|BITS_PER_WORD
condition|)
block|{
name|store_split_bit_field
argument_list|(
name|op0
argument_list|,
name|bitsize
argument_list|,
name|bitpos
argument_list|,
name|value
argument_list|,
name|BITS_PER_WORD
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
comment|/* Get the proper mode to use for this field.  We want a mode that 	 includes the entire field.  If such a mode would be larger than 	 a word, we won't be doing the extraction the normal way.  */
name|mode
operator|=
name|get_best_mode
argument_list|(
name|bitsize
argument_list|,
name|bitpos
operator|+
name|offset
operator|*
name|BITS_PER_UNIT
argument_list|,
name|struct_align
operator|*
name|BITS_PER_UNIT
argument_list|,
name|word_mode
argument_list|,
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|MEM
operator|&&
name|MEM_VOLATILE_P
argument_list|(
name|op0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
block|{
comment|/* The only way this should occur is if the field spans word 	     boundaries.  */
name|store_split_bit_field
argument_list|(
name|op0
argument_list|,
name|bitsize
argument_list|,
name|bitpos
operator|+
name|offset
operator|*
name|BITS_PER_UNIT
argument_list|,
name|value
argument_list|,
name|struct_align
argument_list|)
expr_stmt|;
return|return;
block|}
name|total_bits
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
comment|/* Make sure bitpos is valid for the chosen mode.  Adjust BITPOS to 	 be in the range 0 to total_bits-1, and put any excess bytes in 	 OFFSET.  */
if|if
condition|(
name|bitpos
operator|>=
name|total_bits
condition|)
block|{
name|offset
operator|+=
operator|(
name|bitpos
operator|/
name|total_bits
operator|)
operator|*
operator|(
name|total_bits
operator|/
name|BITS_PER_UNIT
operator|)
expr_stmt|;
name|bitpos
operator|-=
operator|(
operator|(
name|bitpos
operator|/
name|total_bits
operator|)
operator|*
operator|(
name|total_bits
operator|/
name|BITS_PER_UNIT
operator|)
operator|*
name|BITS_PER_UNIT
operator|)
expr_stmt|;
block|}
comment|/* Get ref to an aligned byte, halfword, or word containing the field. 	 Adjust BITPOS to be position within a word, 	 and OFFSET to be the offset of that word. 	 Then alter OP0 to refer to that word.  */
name|bitpos
operator|+=
operator|(
name|offset
operator|%
operator|(
name|total_bits
operator|/
name|BITS_PER_UNIT
operator|)
operator|)
operator|*
name|BITS_PER_UNIT
expr_stmt|;
name|offset
operator|-=
operator|(
name|offset
operator|%
operator|(
name|total_bits
operator|/
name|BITS_PER_UNIT
operator|)
operator|)
expr_stmt|;
name|op0
operator|=
name|change_address
argument_list|(
name|op0
argument_list|,
name|mode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|mode
operator|=
name|GET_MODE
argument_list|(
name|op0
argument_list|)
expr_stmt|;
comment|/* Now MODE is either some integral mode for a MEM as OP0,      or is a full-word for a REG as OP0.  TOTAL_BITS corresponds.      The bit field is contained entirely within OP0.      BITPOS is the starting bit number within OP0.      (OP0's mode may actually be narrower than MODE.)  */
if|if
condition|(
name|BYTES_BIG_ENDIAN
condition|)
comment|/* BITPOS is the distance between our msb 	 and that of the containing datum. 	 Convert it to the distance from the lsb.  */
name|bitpos
operator|=
name|total_bits
operator|-
name|bitsize
operator|-
name|bitpos
expr_stmt|;
comment|/* Now BITPOS is always the distance between our lsb      and that of OP0.  */
comment|/* Shift VALUE left by BITPOS bits.  If VALUE is not constant,      we must first convert its mode to MODE.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
specifier|register
name|HOST_WIDE_INT
name|v
init|=
name|INTVAL
argument_list|(
name|value
argument_list|)
decl_stmt|;
if|if
condition|(
name|bitsize
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|)
name|v
operator|&=
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|bitsize
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|v
operator|==
literal|0
condition|)
name|all_zero
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|bitsize
operator|<
name|HOST_BITS_PER_WIDE_INT
operator|&&
name|v
operator|==
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|bitsize
operator|)
operator|-
literal|1
operator|)
operator|||
operator|(
name|bitsize
operator|==
name|HOST_BITS_PER_WIDE_INT
operator|&&
name|v
operator|==
operator|-
literal|1
operator|)
condition|)
name|all_one
operator|=
literal|1
expr_stmt|;
name|value
operator|=
name|lshift_value
argument_list|(
name|mode
argument_list|,
name|value
argument_list|,
name|bitpos
argument_list|,
name|bitsize
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|must_and
init|=
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|!=
name|bitsize
operator|&&
name|bitpos
operator|+
name|bitsize
operator|!=
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|value
argument_list|)
operator|!=
name|mode
condition|)
block|{
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|SUBREG
operator|)
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|<
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|value
argument_list|)
argument_list|)
condition|)
name|value
operator|=
name|gen_lowpart
argument_list|(
name|mode
argument_list|,
name|value
argument_list|)
expr_stmt|;
else|else
name|value
operator|=
name|convert_to_mode
argument_list|(
name|mode
argument_list|,
name|value
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|must_and
condition|)
name|value
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|and_optab
argument_list|,
name|value
argument_list|,
name|mask_rtx
argument_list|(
name|mode
argument_list|,
literal|0
argument_list|,
name|bitsize
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitpos
operator|>
literal|0
condition|)
name|value
operator|=
name|expand_shift
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|mode
argument_list|,
name|value
argument_list|,
name|build_int_2
argument_list|(
name|bitpos
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Now clear the chosen bits in OP0,      except that if VALUE is -1 we need not bother.  */
name|subtarget
operator|=
operator|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|REG
operator|||
operator|!
name|flag_force_mem
operator|)
condition|?
name|op0
else|:
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|all_one
condition|)
block|{
name|temp
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|and_optab
argument_list|,
name|op0
argument_list|,
name|mask_rtx
argument_list|(
name|mode
argument_list|,
name|bitpos
argument_list|,
name|bitsize
argument_list|,
literal|1
argument_list|)
argument_list|,
name|subtarget
argument_list|,
literal|1
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
name|subtarget
operator|=
name|temp
expr_stmt|;
block|}
else|else
name|temp
operator|=
name|op0
expr_stmt|;
comment|/* Now logical-or VALUE into OP0, unless it is zero.  */
if|if
condition|(
operator|!
name|all_zero
condition|)
name|temp
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|ior_optab
argument_list|,
name|temp
argument_list|,
name|value
argument_list|,
name|subtarget
argument_list|,
literal|1
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|op0
operator|!=
name|temp
condition|)
name|emit_move_insn
argument_list|(
name|op0
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Store a bit field that is split across multiple accessible memory objects.     OP0 is the REG, SUBREG or MEM rtx for the first of the objects.    BITSIZE is the field width; BITPOS the position of its first bit    (within the word).    VALUE is the value to store.    ALIGN is the known alignment of OP0, measured in bytes.    This is also the size of the memory objects to be used.     This does not yet handle fields wider than BITS_PER_WORD.  */
end_comment

begin_function
specifier|static
name|void
name|store_split_bit_field
parameter_list|(
name|op0
parameter_list|,
name|bitsize
parameter_list|,
name|bitpos
parameter_list|,
name|value
parameter_list|,
name|align
parameter_list|)
name|rtx
name|op0
decl_stmt|;
name|int
name|bitsize
decl_stmt|,
name|bitpos
decl_stmt|;
name|rtx
name|value
decl_stmt|;
name|int
name|align
decl_stmt|;
block|{
name|int
name|unit
decl_stmt|;
name|int
name|bitsdone
init|=
literal|0
decl_stmt|;
comment|/* Make sure UNIT isn't larger than BITS_PER_WORD, we can only handle that      much at a time.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|SUBREG
condition|)
name|unit
operator|=
name|BITS_PER_WORD
expr_stmt|;
else|else
name|unit
operator|=
name|MIN
argument_list|(
name|align
operator|*
name|BITS_PER_UNIT
argument_list|,
name|BITS_PER_WORD
argument_list|)
expr_stmt|;
comment|/* If VALUE is a constant other than a CONST_INT, get it into a register in      WORD_MODE.  If we can do this using gen_lowpart_common, do so.  Note      that VALUE might be a floating-point constant.  */
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|value
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|!=
name|CONST_INT
condition|)
block|{
name|rtx
name|word
init|=
name|gen_lowpart_common
argument_list|(
name|word_mode
argument_list|,
name|value
argument_list|)
decl_stmt|;
if|if
condition|(
name|word
operator|&&
operator|(
name|value
operator|!=
name|word
operator|)
condition|)
name|value
operator|=
name|word
expr_stmt|;
else|else
name|value
operator|=
name|gen_lowpart_common
argument_list|(
name|word_mode
argument_list|,
name|force_reg
argument_list|(
name|GET_MODE
argument_list|(
name|value
argument_list|)
operator|!=
name|VOIDmode
condition|?
name|GET_MODE
argument_list|(
name|value
argument_list|)
else|:
name|word_mode
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|ADDRESSOF
condition|)
name|value
operator|=
name|copy_to_reg
argument_list|(
name|value
argument_list|)
expr_stmt|;
while|while
condition|(
name|bitsdone
operator|<
name|bitsize
condition|)
block|{
name|int
name|thissize
decl_stmt|;
name|rtx
name|part
decl_stmt|,
name|word
decl_stmt|;
name|int
name|thispos
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|offset
operator|=
operator|(
name|bitpos
operator|+
name|bitsdone
operator|)
operator|/
name|unit
expr_stmt|;
name|thispos
operator|=
operator|(
name|bitpos
operator|+
name|bitsdone
operator|)
operator|%
name|unit
expr_stmt|;
comment|/* THISSIZE must not overrun a word boundary.  Otherwise, 	 store_fixed_bit_field will call us again, and we will mutually 	 recurse forever.  */
name|thissize
operator|=
name|MIN
argument_list|(
name|bitsize
operator|-
name|bitsdone
argument_list|,
name|BITS_PER_WORD
argument_list|)
expr_stmt|;
name|thissize
operator|=
name|MIN
argument_list|(
name|thissize
argument_list|,
name|unit
operator|-
name|thispos
argument_list|)
expr_stmt|;
if|if
condition|(
name|BYTES_BIG_ENDIAN
condition|)
block|{
name|int
name|total_bits
decl_stmt|;
comment|/* We must do an endian conversion exactly the same way as it is 	     done in extract_bit_field, so that the two calls to 	     extract_fixed_bit_field will have comparable arguments.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|!=
name|MEM
operator|||
name|GET_MODE
argument_list|(
name|value
argument_list|)
operator|==
name|BLKmode
condition|)
name|total_bits
operator|=
name|BITS_PER_WORD
expr_stmt|;
else|else
name|total_bits
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fetch successively less significant portions.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|CONST_INT
condition|)
name|part
operator|=
name|GEN_INT
argument_list|(
operator|(
call|(
name|unsigned
name|HOST_WIDE_INT
call|)
argument_list|(
name|INTVAL
argument_list|(
name|value
argument_list|)
argument_list|)
operator|>>
operator|(
name|bitsize
operator|-
name|bitsdone
operator|-
name|thissize
operator|)
operator|)
operator|&
operator|(
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|thissize
operator|)
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
else|else
comment|/* The args are chosen so that the last part includes the 	       lsb.  Give extract_bit_field the value it needs (with 	       endianness compensation) to fetch the piece we want.  	       ??? We have no idea what the alignment of VALUE is, so 	       we have to use a guess.  */
name|part
operator|=
name|extract_fixed_bit_field
argument_list|(
name|word_mode
argument_list|,
name|value
argument_list|,
literal|0
argument_list|,
name|thissize
argument_list|,
name|total_bits
operator|-
name|bitsize
operator|+
name|bitsdone
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|,
name|GET_MODE
argument_list|(
name|value
argument_list|)
operator|==
name|VOIDmode
condition|?
name|UNITS_PER_WORD
else|:
operator|(
name|GET_MODE
argument_list|(
name|value
argument_list|)
operator|==
name|BLKmode
condition|?
literal|1
else|:
name|GET_MODE_ALIGNMENT
argument_list|(
name|GET_MODE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|/
name|BITS_PER_UNIT
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Fetch successively more significant portions.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|CONST_INT
condition|)
name|part
operator|=
name|GEN_INT
argument_list|(
operator|(
call|(
name|unsigned
name|HOST_WIDE_INT
call|)
argument_list|(
name|INTVAL
argument_list|(
name|value
argument_list|)
argument_list|)
operator|>>
name|bitsdone
operator|)
operator|&
operator|(
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|thissize
operator|)
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
else|else
name|part
operator|=
name|extract_fixed_bit_field
argument_list|(
name|word_mode
argument_list|,
name|value
argument_list|,
literal|0
argument_list|,
name|thissize
argument_list|,
name|bitsdone
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|,
name|GET_MODE
argument_list|(
name|value
argument_list|)
operator|==
name|VOIDmode
condition|?
name|UNITS_PER_WORD
else|:
operator|(
name|GET_MODE
argument_list|(
name|value
argument_list|)
operator|==
name|BLKmode
condition|?
literal|1
else|:
name|GET_MODE_ALIGNMENT
argument_list|(
name|GET_MODE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|/
name|BITS_PER_UNIT
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* If OP0 is a register, then handle OFFSET here.  	 When handling multiword bitfields, extract_bit_field may pass 	 down a word_mode SUBREG of a larger REG for a bitfield that actually 	 crosses a word boundary.  Thus, for a SUBREG, we must find 	 the current word starting from the base register.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
name|word
operator|=
name|operand_subword_force
argument_list|(
name|SUBREG_REG
argument_list|(
name|op0
argument_list|)
argument_list|,
name|SUBREG_WORD
argument_list|(
name|op0
argument_list|)
operator|+
name|offset
argument_list|,
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|REG
condition|)
block|{
name|word
operator|=
name|operand_subword_force
argument_list|(
name|op0
argument_list|,
name|offset
argument_list|,
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|word
operator|=
name|op0
expr_stmt|;
comment|/* OFFSET is in UNITs, and UNIT is in bits.          store_fixed_bit_field wants offset in bytes.  */
name|store_fixed_bit_field
argument_list|(
name|word
argument_list|,
name|offset
operator|*
name|unit
operator|/
name|BITS_PER_UNIT
argument_list|,
name|thissize
argument_list|,
name|thispos
argument_list|,
name|part
argument_list|,
name|align
argument_list|)
expr_stmt|;
name|bitsdone
operator|+=
name|thissize
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate code to extract a byte-field from STR_RTX    containing BITSIZE bits, starting at BITNUM,    and put it in TARGET if possible (if TARGET is nonzero).    Regardless of TARGET, we return the rtx for where the value is placed.    It may be a QUEUED.     STR_RTX is the structure containing the byte (a REG or MEM).    UNSIGNEDP is nonzero if this is an unsigned bit field.    MODE is the natural mode of the field value once extracted.    TMODE is the mode the caller would like the value to have;    but the value may be returned with type MODE instead.     ALIGN is the alignment that STR_RTX is known to have, measured in bytes.    TOTAL_SIZE is the size in bytes of the containing structure,    or -1 if varying.     If a TARGET is specified and we can store in it at no extra cost,    we do so, and return TARGET.    Otherwise, we return a REG of mode TMODE or MODE, with TMODE preferred    if they are equally easy.  */
end_comment

begin_function
name|rtx
name|extract_bit_field
parameter_list|(
name|str_rtx
parameter_list|,
name|bitsize
parameter_list|,
name|bitnum
parameter_list|,
name|unsignedp
parameter_list|,
name|target
parameter_list|,
name|mode
parameter_list|,
name|tmode
parameter_list|,
name|align
parameter_list|,
name|total_size
parameter_list|)
name|rtx
name|str_rtx
decl_stmt|;
specifier|register
name|int
name|bitsize
decl_stmt|;
name|int
name|bitnum
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
name|rtx
name|target
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|,
name|tmode
decl_stmt|;
name|int
name|align
decl_stmt|;
name|int
name|total_size
decl_stmt|;
block|{
name|int
name|unit
init|=
operator|(
name|GET_CODE
argument_list|(
name|str_rtx
argument_list|)
operator|==
name|MEM
operator|)
condition|?
name|BITS_PER_UNIT
else|:
name|BITS_PER_WORD
decl_stmt|;
specifier|register
name|int
name|offset
init|=
name|bitnum
operator|/
name|unit
decl_stmt|;
specifier|register
name|int
name|bitpos
init|=
name|bitnum
operator|%
name|unit
decl_stmt|;
specifier|register
name|rtx
name|op0
init|=
name|str_rtx
decl_stmt|;
name|rtx
name|spec_target
init|=
name|target
decl_stmt|;
name|rtx
name|spec_target_subreg
init|=
literal|0
decl_stmt|;
comment|/* Discount the part of the structure before the desired byte.      We need to know how many bytes are safe to reference after it.  */
if|if
condition|(
name|total_size
operator|>=
literal|0
condition|)
name|total_size
operator|-=
operator|(
name|bitpos
operator|/
name|BIGGEST_ALIGNMENT
operator|*
operator|(
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|tmode
operator|==
name|VOIDmode
condition|)
name|tmode
operator|=
name|mode
expr_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
name|int
name|outer_size
init|=
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|inner_size
init|=
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op0
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|offset
operator|+=
name|SUBREG_WORD
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|inner_size
operator|=
name|MIN
argument_list|(
name|inner_size
argument_list|,
name|BITS_PER_WORD
argument_list|)
expr_stmt|;
if|if
condition|(
name|BYTES_BIG_ENDIAN
operator|&&
operator|(
name|outer_size
operator|<
name|inner_size
operator|)
condition|)
block|{
name|bitpos
operator|+=
name|inner_size
operator|-
name|outer_size
expr_stmt|;
if|if
condition|(
name|bitpos
operator|>
name|unit
condition|)
block|{
name|offset
operator|+=
operator|(
name|bitpos
operator|/
name|unit
operator|)
expr_stmt|;
name|bitpos
operator|%=
name|unit
expr_stmt|;
block|}
block|}
name|op0
operator|=
name|SUBREG_REG
argument_list|(
name|op0
argument_list|)
expr_stmt|;
block|}
comment|/* ??? We currently assume TARGET is at least as big as BITSIZE.      If that's wrong, the solution is to test for it and set TARGET to 0      if needed.  */
comment|/* If OP0 is a register, BITPOS must count within a word.      But as we have it, it counts within whatever size OP0 now has.      On a bigendian machine, these are not the same, so convert.  */
if|if
condition|(
name|BYTES_BIG_ENDIAN
operator|&&
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|MEM
operator|&&
name|unit
operator|>
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
condition|)
name|bitpos
operator|+=
name|unit
operator|-
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Extracting a full-word or multi-word value      from a structure in a register or aligned memory.      This can be done with just SUBREG.      So too extracting a subword value in      the least significant part of the register.  */
if|if
condition|(
operator|(
operator|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|REG
operator|&&
name|TRULY_NOOP_TRUNCATION
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
argument_list|,
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|MEM
operator|&&
operator|(
operator|!
name|SLOW_UNALIGNED_ACCESS
operator|||
operator|(
name|offset
operator|*
name|BITS_PER_UNIT
operator|%
name|bitsize
operator|==
literal|0
operator|&&
name|align
operator|*
name|BITS_PER_UNIT
operator|%
name|bitsize
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
operator|&&
operator|(
operator|(
name|bitsize
operator|>=
name|BITS_PER_WORD
operator|&&
name|bitsize
operator|==
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|&&
name|bitpos
operator|%
name|BITS_PER_WORD
operator|==
literal|0
operator|)
operator|||
operator|(
name|mode_for_size
argument_list|(
name|bitsize
argument_list|,
name|GET_MODE_CLASS
argument_list|(
name|tmode
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|!=
name|BLKmode
operator|&&
operator|(
name|BYTES_BIG_ENDIAN
condition|?
name|bitpos
operator|+
name|bitsize
operator|==
name|BITS_PER_WORD
else|:
name|bitpos
operator|==
literal|0
operator|)
operator|)
operator|)
condition|)
block|{
name|enum
name|machine_mode
name|mode1
init|=
name|mode_for_size
argument_list|(
name|bitsize
argument_list|,
name|GET_MODE_CLASS
argument_list|(
name|tmode
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|mode1
operator|!=
name|GET_MODE
argument_list|(
name|op0
argument_list|)
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|REG
condition|)
name|op0
operator|=
name|gen_rtx_SUBREG
argument_list|(
name|mode1
argument_list|,
name|op0
argument_list|,
name|offset
argument_list|)
expr_stmt|;
else|else
name|op0
operator|=
name|change_address
argument_list|(
name|op0
argument_list|,
name|mode1
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mode1
operator|!=
name|mode
condition|)
return|return
name|convert_to_mode
argument_list|(
name|tmode
argument_list|,
name|op0
argument_list|,
name|unsignedp
argument_list|)
return|;
return|return
name|op0
return|;
block|}
comment|/* Handle fields bigger than a word.  */
if|if
condition|(
name|bitsize
operator|>
name|BITS_PER_WORD
condition|)
block|{
comment|/* Here we transfer the words of the field 	 in the order least significant first. 	 This is because the most significant word is the one which may 	 be less than full.  */
name|int
name|nwords
init|=
operator|(
name|bitsize
operator|+
operator|(
name|BITS_PER_WORD
operator|-
literal|1
operator|)
operator|)
operator|/
name|BITS_PER_WORD
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|target
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|!=
name|REG
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
comment|/* Indicate for flow that the entire target reg is being set.  */
name|emit_insn
argument_list|(
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|target
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nwords
condition|;
name|i
operator|++
control|)
block|{
comment|/* If I is 0, use the low-order word in both field and target; 	     if I is 1, use the next to lowest word; and so on.  */
comment|/* Word number in TARGET to use.  */
name|int
name|wordnum
init|=
operator|(
name|WORDS_BIG_ENDIAN
condition|?
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|target
argument_list|)
argument_list|)
operator|/
name|UNITS_PER_WORD
operator|-
name|i
operator|-
literal|1
else|:
name|i
operator|)
decl_stmt|;
comment|/* Offset from start of field in OP0.  */
name|int
name|bit_offset
init|=
operator|(
name|WORDS_BIG_ENDIAN
condition|?
name|MAX
argument_list|(
literal|0
argument_list|,
name|bitsize
operator|-
operator|(
name|i
operator|+
literal|1
operator|)
operator|*
name|BITS_PER_WORD
argument_list|)
else|:
name|i
operator|*
name|BITS_PER_WORD
operator|)
decl_stmt|;
name|rtx
name|target_part
init|=
name|operand_subword
argument_list|(
name|target
argument_list|,
name|wordnum
argument_list|,
literal|1
argument_list|,
name|VOIDmode
argument_list|)
decl_stmt|;
name|rtx
name|result_part
init|=
name|extract_bit_field
argument_list|(
name|op0
argument_list|,
name|MIN
argument_list|(
name|BITS_PER_WORD
argument_list|,
name|bitsize
operator|-
name|i
operator|*
name|BITS_PER_WORD
argument_list|)
argument_list|,
name|bitnum
operator|+
name|bit_offset
argument_list|,
literal|1
argument_list|,
name|target_part
argument_list|,
name|mode
argument_list|,
name|word_mode
argument_list|,
name|align
argument_list|,
name|total_size
argument_list|)
decl_stmt|;
if|if
condition|(
name|target_part
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|result_part
operator|!=
name|target_part
condition|)
name|emit_move_insn
argument_list|(
name|target_part
argument_list|,
name|result_part
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|unsignedp
condition|)
block|{
comment|/* Unless we've filled TARGET, the upper regs in a multi-reg value 	     need to be zero'd out.  */
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|target
argument_list|)
argument_list|)
operator|>
name|nwords
operator|*
name|UNITS_PER_WORD
condition|)
block|{
name|int
name|i
decl_stmt|,
name|total_words
decl_stmt|;
name|total_words
operator|=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|target
argument_list|)
argument_list|)
operator|/
name|UNITS_PER_WORD
expr_stmt|;
for|for
control|(
name|i
operator|=
name|nwords
init|;
name|i
operator|<
name|total_words
condition|;
name|i
operator|++
control|)
block|{
name|int
name|wordnum
init|=
name|WORDS_BIG_ENDIAN
condition|?
name|total_words
operator|-
name|i
operator|-
literal|1
else|:
name|i
decl_stmt|;
name|rtx
name|target_part
init|=
name|operand_subword
argument_list|(
name|target
argument_list|,
name|wordnum
argument_list|,
literal|1
argument_list|,
name|VOIDmode
argument_list|)
decl_stmt|;
name|emit_move_insn
argument_list|(
name|target_part
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|target
return|;
block|}
comment|/* Signed bit field: sign-extend with two arithmetic shifts.  */
name|target
operator|=
name|expand_shift
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|mode
argument_list|,
name|target
argument_list|,
name|build_int_2
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|-
name|bitsize
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|expand_shift
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|mode
argument_list|,
name|target
argument_list|,
name|build_int_2
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|-
name|bitsize
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|/* From here on we know the desired field is smaller than a word      so we can assume it is an integer.  So we can safely extract it as one      size of integer, if necessary, and then truncate or extend      to the size that is wanted.  */
comment|/* OFFSET is the number of words or bytes (UNIT says which)      from STR_RTX to the first word or byte containing part of the field.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|REG
condition|)
block|{
if|if
condition|(
name|offset
operator|!=
literal|0
operator|||
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|>
name|UNITS_PER_WORD
condition|)
name|op0
operator|=
name|gen_rtx_SUBREG
argument_list|(
name|TYPE_MODE
argument_list|(
name|type_for_size
argument_list|(
name|BITS_PER_WORD
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|op0
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|op0
operator|=
name|protect_from_queue
argument_list|(
name|str_rtx
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Now OFFSET is nonzero only for memory operands.  */
if|if
condition|(
name|unsignedp
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_extzv
if|if
condition|(
name|HAVE_extzv
operator|&&
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|insn_operand_mode
index|[
operator|(
name|int
operator|)
name|CODE_FOR_extzv
index|]
index|[
literal|0
index|]
argument_list|)
operator|>=
name|bitsize
operator|)
operator|&&
operator|!
operator|(
operator|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|SUBREG
operator|)
operator|&&
operator|(
name|bitsize
operator|+
name|bitpos
operator|>
name|GET_MODE_BITSIZE
argument_list|(
name|insn_operand_mode
index|[
operator|(
name|int
operator|)
name|CODE_FOR_extzv
index|]
index|[
literal|0
index|]
argument_list|)
operator|)
operator|)
condition|)
block|{
name|int
name|xbitpos
init|=
name|bitpos
decl_stmt|,
name|xoffset
init|=
name|offset
decl_stmt|;
name|rtx
name|bitsize_rtx
decl_stmt|,
name|bitpos_rtx
decl_stmt|;
name|rtx
name|last
init|=
name|get_last_insn
argument_list|()
decl_stmt|;
name|rtx
name|xop0
init|=
name|op0
decl_stmt|;
name|rtx
name|xtarget
init|=
name|target
decl_stmt|;
name|rtx
name|xspec_target
init|=
name|spec_target
decl_stmt|;
name|rtx
name|xspec_target_subreg
init|=
name|spec_target_subreg
decl_stmt|;
name|rtx
name|pat
decl_stmt|;
name|enum
name|machine_mode
name|maxmode
init|=
name|insn_operand_mode
index|[
operator|(
name|int
operator|)
name|CODE_FOR_extzv
index|]
index|[
literal|0
index|]
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|xop0
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|int
name|save_volatile_ok
init|=
name|volatile_ok
decl_stmt|;
name|volatile_ok
operator|=
literal|1
expr_stmt|;
comment|/* Is the memory operand acceptable?  */
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|insn_operand_predicate
index|[
operator|(
name|int
operator|)
name|CODE_FOR_extzv
index|]
index|[
literal|1
index|]
call|)
argument_list|(
name|xop0
argument_list|,
name|GET_MODE
argument_list|(
name|xop0
argument_list|)
argument_list|)
operator|)
condition|)
block|{
comment|/* No, load into a reg and extract from there.  */
name|enum
name|machine_mode
name|bestmode
decl_stmt|;
comment|/* Get the mode to use for inserting into this field.  If 		     OP0 is BLKmode, get the smallest mode consistent with the 		     alignment. If OP0 is a non-BLKmode object that is no 		     wider than MAXMODE, use its mode. Otherwise, use the 		     smallest mode containing the field.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|xop0
argument_list|)
operator|==
name|BLKmode
operator|||
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|maxmode
argument_list|)
operator|)
condition|)
name|bestmode
operator|=
name|get_best_mode
argument_list|(
name|bitsize
argument_list|,
name|bitnum
argument_list|,
name|align
operator|*
name|BITS_PER_UNIT
argument_list|,
name|maxmode
argument_list|,
name|MEM_VOLATILE_P
argument_list|(
name|xop0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|bestmode
operator|=
name|GET_MODE
argument_list|(
name|xop0
argument_list|)
expr_stmt|;
if|if
condition|(
name|bestmode
operator|==
name|VOIDmode
operator|||
operator|(
name|SLOW_UNALIGNED_ACCESS
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|bestmode
argument_list|)
operator|>
name|align
operator|)
condition|)
goto|goto
name|extzv_loses
goto|;
comment|/* Compute offset as multiple of this unit, 		     counting in bytes.  */
name|unit
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|bestmode
argument_list|)
expr_stmt|;
name|xoffset
operator|=
operator|(
name|bitnum
operator|/
name|unit
operator|)
operator|*
name|GET_MODE_SIZE
argument_list|(
name|bestmode
argument_list|)
expr_stmt|;
name|xbitpos
operator|=
name|bitnum
operator|%
name|unit
expr_stmt|;
name|xop0
operator|=
name|change_address
argument_list|(
name|xop0
argument_list|,
name|bestmode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|xop0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|xoffset
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fetch it to a register in that size.  */
name|xop0
operator|=
name|force_reg
argument_list|(
name|bestmode
argument_list|,
name|xop0
argument_list|)
expr_stmt|;
comment|/* XBITPOS counts within UNIT, which is what is expected.  */
block|}
else|else
comment|/* Get ref to first byte containing part of the field.  */
name|xop0
operator|=
name|change_address
argument_list|(
name|xop0
argument_list|,
name|byte_mode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|xop0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|xoffset
argument_list|)
argument_list|)
expr_stmt|;
name|volatile_ok
operator|=
name|save_volatile_ok
expr_stmt|;
block|}
comment|/* If op0 is a register, we need it in MAXMODE (which is usually 	     SImode). to make it acceptable to the format of extzv.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|xop0
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_MODE
argument_list|(
name|xop0
argument_list|)
operator|!=
name|maxmode
condition|)
goto|goto
name|extzv_loses
goto|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|xop0
argument_list|)
operator|==
name|REG
operator|&&
name|GET_MODE
argument_list|(
name|xop0
argument_list|)
operator|!=
name|maxmode
condition|)
name|xop0
operator|=
name|gen_rtx_SUBREG
argument_list|(
name|maxmode
argument_list|,
name|xop0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* On big-endian machines, we count bits from the most significant. 	     If the bit field insn does not, we must invert.  */
if|if
condition|(
name|BITS_BIG_ENDIAN
operator|!=
name|BYTES_BIG_ENDIAN
condition|)
name|xbitpos
operator|=
name|unit
operator|-
name|bitsize
operator|-
name|xbitpos
expr_stmt|;
comment|/* Now convert from counting within UNIT to counting in MAXMODE.  */
if|if
condition|(
name|BITS_BIG_ENDIAN
operator|&&
name|GET_CODE
argument_list|(
name|xop0
argument_list|)
operator|!=
name|MEM
condition|)
name|xbitpos
operator|+=
name|GET_MODE_BITSIZE
argument_list|(
name|maxmode
argument_list|)
operator|-
name|unit
expr_stmt|;
name|unit
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|maxmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|xtarget
operator|==
literal|0
operator|||
operator|(
name|flag_force_mem
operator|&&
name|GET_CODE
argument_list|(
name|xtarget
argument_list|)
operator|==
name|MEM
operator|)
condition|)
name|xtarget
operator|=
name|xspec_target
operator|=
name|gen_reg_rtx
argument_list|(
name|tmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|xtarget
argument_list|)
operator|!=
name|maxmode
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|xtarget
argument_list|)
operator|==
name|REG
condition|)
block|{
name|int
name|wider
init|=
operator|(
name|GET_MODE_SIZE
argument_list|(
name|maxmode
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|xtarget
argument_list|)
argument_list|)
operator|)
decl_stmt|;
name|xtarget
operator|=
name|gen_lowpart
argument_list|(
name|maxmode
argument_list|,
name|xtarget
argument_list|)
expr_stmt|;
if|if
condition|(
name|wider
condition|)
name|xspec_target_subreg
operator|=
name|xtarget
expr_stmt|;
block|}
else|else
name|xtarget
operator|=
name|gen_reg_rtx
argument_list|(
name|maxmode
argument_list|)
expr_stmt|;
block|}
comment|/* If this machine's extzv insists on a register target, 	     make sure we have one.  */
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|insn_operand_predicate
index|[
operator|(
name|int
operator|)
name|CODE_FOR_extzv
index|]
index|[
literal|0
index|]
call|)
argument_list|(
name|xtarget
argument_list|,
name|maxmode
argument_list|)
operator|)
condition|)
name|xtarget
operator|=
name|gen_reg_rtx
argument_list|(
name|maxmode
argument_list|)
expr_stmt|;
name|bitsize_rtx
operator|=
name|GEN_INT
argument_list|(
name|bitsize
argument_list|)
expr_stmt|;
name|bitpos_rtx
operator|=
name|GEN_INT
argument_list|(
name|xbitpos
argument_list|)
expr_stmt|;
name|pat
operator|=
name|gen_extzv
argument_list|(
name|protect_from_queue
argument_list|(
name|xtarget
argument_list|,
literal|1
argument_list|)
argument_list|,
name|xop0
argument_list|,
name|bitsize_rtx
argument_list|,
name|bitpos_rtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|pat
condition|)
block|{
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
name|target
operator|=
name|xtarget
expr_stmt|;
name|spec_target
operator|=
name|xspec_target
expr_stmt|;
name|spec_target_subreg
operator|=
name|xspec_target_subreg
expr_stmt|;
block|}
else|else
block|{
name|delete_insns_since
argument_list|(
name|last
argument_list|)
expr_stmt|;
name|target
operator|=
name|extract_fixed_bit_field
argument_list|(
name|tmode
argument_list|,
name|op0
argument_list|,
name|offset
argument_list|,
name|bitsize
argument_list|,
name|bitpos
argument_list|,
name|target
argument_list|,
literal|1
argument_list|,
name|align
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|extzv_loses
label|:
endif|#
directive|endif
name|target
operator|=
name|extract_fixed_bit_field
argument_list|(
name|tmode
argument_list|,
name|op0
argument_list|,
name|offset
argument_list|,
name|bitsize
argument_list|,
name|bitpos
argument_list|,
name|target
argument_list|,
literal|1
argument_list|,
name|align
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|HAVE_extv
if|if
condition|(
name|HAVE_extv
operator|&&
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|insn_operand_mode
index|[
operator|(
name|int
operator|)
name|CODE_FOR_extv
index|]
index|[
literal|0
index|]
argument_list|)
operator|>=
name|bitsize
operator|)
operator|&&
operator|!
operator|(
operator|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|SUBREG
operator|)
operator|&&
operator|(
name|bitsize
operator|+
name|bitpos
operator|>
name|GET_MODE_BITSIZE
argument_list|(
name|insn_operand_mode
index|[
operator|(
name|int
operator|)
name|CODE_FOR_extv
index|]
index|[
literal|0
index|]
argument_list|)
operator|)
operator|)
condition|)
block|{
name|int
name|xbitpos
init|=
name|bitpos
decl_stmt|,
name|xoffset
init|=
name|offset
decl_stmt|;
name|rtx
name|bitsize_rtx
decl_stmt|,
name|bitpos_rtx
decl_stmt|;
name|rtx
name|last
init|=
name|get_last_insn
argument_list|()
decl_stmt|;
name|rtx
name|xop0
init|=
name|op0
decl_stmt|,
name|xtarget
init|=
name|target
decl_stmt|;
name|rtx
name|xspec_target
init|=
name|spec_target
decl_stmt|;
name|rtx
name|xspec_target_subreg
init|=
name|spec_target_subreg
decl_stmt|;
name|rtx
name|pat
decl_stmt|;
name|enum
name|machine_mode
name|maxmode
init|=
name|insn_operand_mode
index|[
operator|(
name|int
operator|)
name|CODE_FOR_extv
index|]
index|[
literal|0
index|]
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|xop0
argument_list|)
operator|==
name|MEM
condition|)
block|{
comment|/* Is the memory operand acceptable?  */
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|insn_operand_predicate
index|[
operator|(
name|int
operator|)
name|CODE_FOR_extv
index|]
index|[
literal|1
index|]
call|)
argument_list|(
name|xop0
argument_list|,
name|GET_MODE
argument_list|(
name|xop0
argument_list|)
argument_list|)
operator|)
condition|)
block|{
comment|/* No, load into a reg and extract from there.  */
name|enum
name|machine_mode
name|bestmode
decl_stmt|;
comment|/* Get the mode to use for inserting into this field.  If 		     OP0 is BLKmode, get the smallest mode consistent with the 		     alignment. If OP0 is a non-BLKmode object that is no 		     wider than MAXMODE, use its mode. Otherwise, use the 		     smallest mode containing the field.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|xop0
argument_list|)
operator|==
name|BLKmode
operator|||
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|maxmode
argument_list|)
operator|)
condition|)
name|bestmode
operator|=
name|get_best_mode
argument_list|(
name|bitsize
argument_list|,
name|bitnum
argument_list|,
name|align
operator|*
name|BITS_PER_UNIT
argument_list|,
name|maxmode
argument_list|,
name|MEM_VOLATILE_P
argument_list|(
name|xop0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|bestmode
operator|=
name|GET_MODE
argument_list|(
name|xop0
argument_list|)
expr_stmt|;
if|if
condition|(
name|bestmode
operator|==
name|VOIDmode
operator|||
operator|(
name|SLOW_UNALIGNED_ACCESS
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|bestmode
argument_list|)
operator|>
name|align
operator|)
condition|)
goto|goto
name|extv_loses
goto|;
comment|/* Compute offset as multiple of this unit, 		     counting in bytes.  */
name|unit
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|bestmode
argument_list|)
expr_stmt|;
name|xoffset
operator|=
operator|(
name|bitnum
operator|/
name|unit
operator|)
operator|*
name|GET_MODE_SIZE
argument_list|(
name|bestmode
argument_list|)
expr_stmt|;
name|xbitpos
operator|=
name|bitnum
operator|%
name|unit
expr_stmt|;
name|xop0
operator|=
name|change_address
argument_list|(
name|xop0
argument_list|,
name|bestmode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|xop0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|xoffset
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fetch it to a register in that size.  */
name|xop0
operator|=
name|force_reg
argument_list|(
name|bestmode
argument_list|,
name|xop0
argument_list|)
expr_stmt|;
comment|/* XBITPOS counts within UNIT, which is what is expected.  */
block|}
else|else
comment|/* Get ref to first byte containing part of the field.  */
name|xop0
operator|=
name|change_address
argument_list|(
name|xop0
argument_list|,
name|byte_mode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|xop0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|xoffset
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If op0 is a register, we need it in MAXMODE (which is usually 	     SImode) to make it acceptable to the format of extv.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|xop0
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_MODE
argument_list|(
name|xop0
argument_list|)
operator|!=
name|maxmode
condition|)
goto|goto
name|extv_loses
goto|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|xop0
argument_list|)
operator|==
name|REG
operator|&&
name|GET_MODE
argument_list|(
name|xop0
argument_list|)
operator|!=
name|maxmode
condition|)
name|xop0
operator|=
name|gen_rtx_SUBREG
argument_list|(
name|maxmode
argument_list|,
name|xop0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* On big-endian machines, we count bits from the most significant. 	     If the bit field insn does not, we must invert.  */
if|if
condition|(
name|BITS_BIG_ENDIAN
operator|!=
name|BYTES_BIG_ENDIAN
condition|)
name|xbitpos
operator|=
name|unit
operator|-
name|bitsize
operator|-
name|xbitpos
expr_stmt|;
comment|/* XBITPOS counts within a size of UNIT. 	     Adjust to count within a size of MAXMODE.  */
if|if
condition|(
name|BITS_BIG_ENDIAN
operator|&&
name|GET_CODE
argument_list|(
name|xop0
argument_list|)
operator|!=
name|MEM
condition|)
name|xbitpos
operator|+=
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|maxmode
argument_list|)
operator|-
name|unit
operator|)
expr_stmt|;
name|unit
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|maxmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|xtarget
operator|==
literal|0
operator|||
operator|(
name|flag_force_mem
operator|&&
name|GET_CODE
argument_list|(
name|xtarget
argument_list|)
operator|==
name|MEM
operator|)
condition|)
name|xtarget
operator|=
name|xspec_target
operator|=
name|gen_reg_rtx
argument_list|(
name|tmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|xtarget
argument_list|)
operator|!=
name|maxmode
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|xtarget
argument_list|)
operator|==
name|REG
condition|)
block|{
name|int
name|wider
init|=
operator|(
name|GET_MODE_SIZE
argument_list|(
name|maxmode
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|xtarget
argument_list|)
argument_list|)
operator|)
decl_stmt|;
name|xtarget
operator|=
name|gen_lowpart
argument_list|(
name|maxmode
argument_list|,
name|xtarget
argument_list|)
expr_stmt|;
if|if
condition|(
name|wider
condition|)
name|xspec_target_subreg
operator|=
name|xtarget
expr_stmt|;
block|}
else|else
name|xtarget
operator|=
name|gen_reg_rtx
argument_list|(
name|maxmode
argument_list|)
expr_stmt|;
block|}
comment|/* If this machine's extv insists on a register target, 	     make sure we have one.  */
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|insn_operand_predicate
index|[
operator|(
name|int
operator|)
name|CODE_FOR_extv
index|]
index|[
literal|0
index|]
call|)
argument_list|(
name|xtarget
argument_list|,
name|maxmode
argument_list|)
operator|)
condition|)
name|xtarget
operator|=
name|gen_reg_rtx
argument_list|(
name|maxmode
argument_list|)
expr_stmt|;
name|bitsize_rtx
operator|=
name|GEN_INT
argument_list|(
name|bitsize
argument_list|)
expr_stmt|;
name|bitpos_rtx
operator|=
name|GEN_INT
argument_list|(
name|xbitpos
argument_list|)
expr_stmt|;
name|pat
operator|=
name|gen_extv
argument_list|(
name|protect_from_queue
argument_list|(
name|xtarget
argument_list|,
literal|1
argument_list|)
argument_list|,
name|xop0
argument_list|,
name|bitsize_rtx
argument_list|,
name|bitpos_rtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|pat
condition|)
block|{
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
name|target
operator|=
name|xtarget
expr_stmt|;
name|spec_target
operator|=
name|xspec_target
expr_stmt|;
name|spec_target_subreg
operator|=
name|xspec_target_subreg
expr_stmt|;
block|}
else|else
block|{
name|delete_insns_since
argument_list|(
name|last
argument_list|)
expr_stmt|;
name|target
operator|=
name|extract_fixed_bit_field
argument_list|(
name|tmode
argument_list|,
name|op0
argument_list|,
name|offset
argument_list|,
name|bitsize
argument_list|,
name|bitpos
argument_list|,
name|target
argument_list|,
literal|0
argument_list|,
name|align
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|extv_loses
label|:
endif|#
directive|endif
name|target
operator|=
name|extract_fixed_bit_field
argument_list|(
name|tmode
argument_list|,
name|op0
argument_list|,
name|offset
argument_list|,
name|bitsize
argument_list|,
name|bitpos
argument_list|,
name|target
argument_list|,
literal|0
argument_list|,
name|align
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|target
operator|==
name|spec_target
condition|)
return|return
name|target
return|;
if|if
condition|(
name|target
operator|==
name|spec_target_subreg
condition|)
return|return
name|spec_target
return|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|tmode
operator|&&
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|mode
condition|)
block|{
comment|/* If the target mode is floating-point, first convert to the 	 integer mode of that size and then access it as a floating-point 	 value via a SUBREG.  */
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|tmode
argument_list|)
operator|==
name|MODE_FLOAT
condition|)
block|{
name|target
operator|=
name|convert_to_mode
argument_list|(
name|mode_for_size
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|tmode
argument_list|)
argument_list|,
name|MODE_INT
argument_list|,
literal|0
argument_list|)
argument_list|,
name|target
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|!=
name|REG
condition|)
name|target
operator|=
name|copy_to_reg
argument_list|(
name|target
argument_list|)
expr_stmt|;
return|return
name|gen_rtx_SUBREG
argument_list|(
name|tmode
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
return|;
block|}
else|else
return|return
name|convert_to_mode
argument_list|(
name|tmode
argument_list|,
name|target
argument_list|,
name|unsignedp
argument_list|)
return|;
block|}
return|return
name|target
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Extract a bit field using shifts and boolean operations    Returns an rtx to represent the value.    OP0 addresses a register (word) or memory (byte).    BITPOS says which bit within the word or byte the bit field starts in.    OFFSET says how many bytes farther the bit field starts;     it is 0 if OP0 is a register.    BITSIZE says how many bits long the bit field is.     (If OP0 is a register, it may be narrower than a full word,      but BITPOS still counts within a full word,      which is significant on bigendian machines.)     UNSIGNEDP is nonzero for an unsigned bit field (don't sign-extend value).    If TARGET is nonzero, attempts to store the value there    and return TARGET, but this is not guaranteed.    If TARGET is not used, create a pseudo-reg of mode TMODE for the value.     ALIGN is the alignment that STR_RTX is known to have, measured in bytes.  */
end_comment

begin_function
specifier|static
name|rtx
name|extract_fixed_bit_field
parameter_list|(
name|tmode
parameter_list|,
name|op0
parameter_list|,
name|offset
parameter_list|,
name|bitsize
parameter_list|,
name|bitpos
parameter_list|,
name|target
parameter_list|,
name|unsignedp
parameter_list|,
name|align
parameter_list|)
name|enum
name|machine_mode
name|tmode
decl_stmt|;
specifier|register
name|rtx
name|op0
decl_stmt|,
name|target
decl_stmt|;
specifier|register
name|int
name|offset
decl_stmt|,
name|bitsize
decl_stmt|,
name|bitpos
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
name|int
name|align
decl_stmt|;
block|{
name|int
name|total_bits
init|=
name|BITS_PER_WORD
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|REG
condition|)
block|{
comment|/* Special treatment for a bit field split across two registers.  */
if|if
condition|(
name|bitsize
operator|+
name|bitpos
operator|>
name|BITS_PER_WORD
condition|)
return|return
name|extract_split_bit_field
argument_list|(
name|op0
argument_list|,
name|bitsize
argument_list|,
name|bitpos
argument_list|,
name|unsignedp
argument_list|,
name|align
argument_list|)
return|;
block|}
else|else
block|{
comment|/* Get the proper mode to use for this field.  We want a mode that 	 includes the entire field.  If such a mode would be larger than 	 a word, we won't be doing the extraction the normal way.  */
name|mode
operator|=
name|get_best_mode
argument_list|(
name|bitsize
argument_list|,
name|bitpos
operator|+
name|offset
operator|*
name|BITS_PER_UNIT
argument_list|,
name|align
operator|*
name|BITS_PER_UNIT
argument_list|,
name|word_mode
argument_list|,
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|MEM
operator|&&
name|MEM_VOLATILE_P
argument_list|(
name|op0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
comment|/* The only way this should occur is if the field spans word 	   boundaries.  */
return|return
name|extract_split_bit_field
argument_list|(
name|op0
argument_list|,
name|bitsize
argument_list|,
name|bitpos
operator|+
name|offset
operator|*
name|BITS_PER_UNIT
argument_list|,
name|unsignedp
argument_list|,
name|align
argument_list|)
return|;
name|total_bits
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
comment|/* Make sure bitpos is valid for the chosen mode.  Adjust BITPOS to 	 be in the range 0 to total_bits-1, and put any excess bytes in 	 OFFSET.  */
if|if
condition|(
name|bitpos
operator|>=
name|total_bits
condition|)
block|{
name|offset
operator|+=
operator|(
name|bitpos
operator|/
name|total_bits
operator|)
operator|*
operator|(
name|total_bits
operator|/
name|BITS_PER_UNIT
operator|)
expr_stmt|;
name|bitpos
operator|-=
operator|(
operator|(
name|bitpos
operator|/
name|total_bits
operator|)
operator|*
operator|(
name|total_bits
operator|/
name|BITS_PER_UNIT
operator|)
operator|*
name|BITS_PER_UNIT
operator|)
expr_stmt|;
block|}
comment|/* Get ref to an aligned byte, halfword, or word containing the field. 	 Adjust BITPOS to be position within a word, 	 and OFFSET to be the offset of that word. 	 Then alter OP0 to refer to that word.  */
name|bitpos
operator|+=
operator|(
name|offset
operator|%
operator|(
name|total_bits
operator|/
name|BITS_PER_UNIT
operator|)
operator|)
operator|*
name|BITS_PER_UNIT
expr_stmt|;
name|offset
operator|-=
operator|(
name|offset
operator|%
operator|(
name|total_bits
operator|/
name|BITS_PER_UNIT
operator|)
operator|)
expr_stmt|;
name|op0
operator|=
name|change_address
argument_list|(
name|op0
argument_list|,
name|mode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|mode
operator|=
name|GET_MODE
argument_list|(
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
name|BYTES_BIG_ENDIAN
condition|)
block|{
comment|/* BITPOS is the distance between our msb and that of OP0. 	 Convert it to the distance from the lsb.  */
name|bitpos
operator|=
name|total_bits
operator|-
name|bitsize
operator|-
name|bitpos
expr_stmt|;
block|}
comment|/* Now BITPOS is always the distance between the field's lsb and that of OP0.      We have reduced the big-endian case to the little-endian case.  */
if|if
condition|(
name|unsignedp
condition|)
block|{
if|if
condition|(
name|bitpos
condition|)
block|{
comment|/* If the field does not already start at the lsb, 	     shift it so it does.  */
name|tree
name|amount
init|=
name|build_int_2
argument_list|(
name|bitpos
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* Maybe propagate the target for the shift.  */
comment|/* But not if we will return it--could confuse integrate.c.  */
name|rtx
name|subtarget
init|=
operator|(
name|target
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|REG
operator|&&
operator|!
name|REG_FUNCTION_VALUE_P
argument_list|(
name|target
argument_list|)
condition|?
name|target
else|:
literal|0
operator|)
decl_stmt|;
if|if
condition|(
name|tmode
operator|!=
name|mode
condition|)
name|subtarget
operator|=
literal|0
expr_stmt|;
name|op0
operator|=
name|expand_shift
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|amount
argument_list|,
name|subtarget
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Convert the value to the desired mode.  */
if|if
condition|(
name|mode
operator|!=
name|tmode
condition|)
name|op0
operator|=
name|convert_to_mode
argument_list|(
name|tmode
argument_list|,
name|op0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Unless the msb of the field used to be the msb when we shifted, 	 mask out the upper bits.  */
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|!=
name|bitpos
operator|+
name|bitsize
if|#
directive|if
literal|0
ifdef|#
directive|ifdef
name|SLOW_ZERO_EXTEND
comment|/* Always generate an `and' if 	     we just zero-extended op0 and SLOW_ZERO_EXTEND, since it 	     will combine fruitfully with the zero-extend.  */
condition||| tmode != mode
endif|#
directive|endif
endif|#
directive|endif
condition|)
return|return
name|expand_binop
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|,
name|and_optab
argument_list|,
name|op0
argument_list|,
name|mask_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|,
literal|0
argument_list|,
name|bitsize
argument_list|,
literal|0
argument_list|)
argument_list|,
name|target
argument_list|,
literal|1
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
return|;
return|return
name|op0
return|;
block|}
comment|/* To extract a signed bit-field, first shift its msb to the msb of the word,      then arithmetic-shift its lsb to the lsb of the word.  */
name|op0
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|!=
name|tmode
condition|)
name|target
operator|=
literal|0
expr_stmt|;
comment|/* Find the narrowest integer mode that contains the field.  */
for|for
control|(
name|mode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_INT
argument_list|)
init|;
name|mode
operator|!=
name|VOIDmode
condition|;
name|mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
control|)
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|>=
name|bitsize
operator|+
name|bitpos
condition|)
block|{
name|op0
operator|=
name|convert_to_mode
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|!=
operator|(
name|bitsize
operator|+
name|bitpos
operator|)
condition|)
block|{
name|tree
name|amount
init|=
name|build_int_2
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|-
operator|(
name|bitsize
operator|+
name|bitpos
operator|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* Maybe propagate the target for the shift.  */
comment|/* But not if we will return the result--could confuse integrate.c.  */
name|rtx
name|subtarget
init|=
operator|(
name|target
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|REG
operator|&&
operator|!
name|REG_FUNCTION_VALUE_P
argument_list|(
name|target
argument_list|)
condition|?
name|target
else|:
literal|0
operator|)
decl_stmt|;
name|op0
operator|=
name|expand_shift
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|amount
argument_list|,
name|subtarget
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|expand_shift
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|build_int_2
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|-
name|bitsize
argument_list|,
literal|0
argument_list|)
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return a constant integer (CONST_INT or CONST_DOUBLE) mask value    of mode MODE with BITSIZE ones followed by BITPOS zeros, or the    complement of that if COMPLEMENT.  The mask is truncated if    necessary to the width of mode MODE.  The mask is zero-extended if    BITSIZE+BITPOS is too small for MODE.  */
end_comment

begin_function
specifier|static
name|rtx
name|mask_rtx
parameter_list|(
name|mode
parameter_list|,
name|bitpos
parameter_list|,
name|bitsize
parameter_list|,
name|complement
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|bitpos
decl_stmt|,
name|bitsize
decl_stmt|,
name|complement
decl_stmt|;
block|{
name|HOST_WIDE_INT
name|masklow
decl_stmt|,
name|maskhigh
decl_stmt|;
if|if
condition|(
name|bitpos
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|)
name|masklow
operator|=
operator|(
name|HOST_WIDE_INT
operator|)
operator|-
literal|1
operator|<<
name|bitpos
expr_stmt|;
else|else
name|masklow
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bitpos
operator|+
name|bitsize
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|)
name|masklow
operator|&=
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
operator|-
literal|1
operator|>>
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|-
name|bitpos
operator|-
name|bitsize
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|bitpos
operator|<=
name|HOST_BITS_PER_WIDE_INT
condition|)
name|maskhigh
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|maskhigh
operator|=
operator|(
name|HOST_WIDE_INT
operator|)
operator|-
literal|1
operator|<<
operator|(
name|bitpos
operator|-
name|HOST_BITS_PER_WIDE_INT
operator|)
expr_stmt|;
if|if
condition|(
name|bitpos
operator|+
name|bitsize
operator|>
name|HOST_BITS_PER_WIDE_INT
condition|)
name|maskhigh
operator|&=
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
operator|-
literal|1
operator|>>
operator|(
literal|2
operator|*
name|HOST_BITS_PER_WIDE_INT
operator|-
name|bitpos
operator|-
name|bitsize
operator|)
operator|)
expr_stmt|;
else|else
name|maskhigh
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|complement
condition|)
block|{
name|maskhigh
operator|=
operator|~
name|maskhigh
expr_stmt|;
name|masklow
operator|=
operator|~
name|masklow
expr_stmt|;
block|}
return|return
name|immed_double_const
argument_list|(
name|masklow
argument_list|,
name|maskhigh
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return a constant integer (CONST_INT or CONST_DOUBLE) rtx with the value    VALUE truncated to BITSIZE bits and then shifted left BITPOS bits.  */
end_comment

begin_function
specifier|static
name|rtx
name|lshift_value
parameter_list|(
name|mode
parameter_list|,
name|value
parameter_list|,
name|bitpos
parameter_list|,
name|bitsize
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|value
decl_stmt|;
name|int
name|bitpos
decl_stmt|,
name|bitsize
decl_stmt|;
block|{
name|unsigned
name|HOST_WIDE_INT
name|v
init|=
name|INTVAL
argument_list|(
name|value
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|low
decl_stmt|,
name|high
decl_stmt|;
if|if
condition|(
name|bitsize
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|)
name|v
operator|&=
operator|~
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
operator|-
literal|1
operator|<<
name|bitsize
operator|)
expr_stmt|;
if|if
condition|(
name|bitpos
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
name|low
operator|=
name|v
operator|<<
name|bitpos
expr_stmt|;
name|high
operator|=
operator|(
name|bitpos
operator|>
literal|0
condition|?
operator|(
name|v
operator|>>
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|-
name|bitpos
operator|)
operator|)
else|:
literal|0
operator|)
expr_stmt|;
block|}
else|else
block|{
name|low
operator|=
literal|0
expr_stmt|;
name|high
operator|=
name|v
operator|<<
operator|(
name|bitpos
operator|-
name|HOST_BITS_PER_WIDE_INT
operator|)
expr_stmt|;
block|}
return|return
name|immed_double_const
argument_list|(
name|low
argument_list|,
name|high
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Extract a bit field that is split across two words    and return an RTX for the result.     OP0 is the REG, SUBREG or MEM rtx for the first of the two words.    BITSIZE is the field width; BITPOS, position of its first bit, in the word.    UNSIGNEDP is 1 if should zero-extend the contents; else sign-extend.     ALIGN is the known alignment of OP0, measured in bytes.    This is also the size of the memory objects to be used.  */
end_comment

begin_function
specifier|static
name|rtx
name|extract_split_bit_field
parameter_list|(
name|op0
parameter_list|,
name|bitsize
parameter_list|,
name|bitpos
parameter_list|,
name|unsignedp
parameter_list|,
name|align
parameter_list|)
name|rtx
name|op0
decl_stmt|;
name|int
name|bitsize
decl_stmt|,
name|bitpos
decl_stmt|,
name|unsignedp
decl_stmt|,
name|align
decl_stmt|;
block|{
name|int
name|unit
decl_stmt|;
name|int
name|bitsdone
init|=
literal|0
decl_stmt|;
name|rtx
name|result
init|=
name|NULL_RTX
decl_stmt|;
name|int
name|first
init|=
literal|1
decl_stmt|;
comment|/* Make sure UNIT isn't larger than BITS_PER_WORD, we can only handle that      much at a time.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|SUBREG
condition|)
name|unit
operator|=
name|BITS_PER_WORD
expr_stmt|;
else|else
name|unit
operator|=
name|MIN
argument_list|(
name|align
operator|*
name|BITS_PER_UNIT
argument_list|,
name|BITS_PER_WORD
argument_list|)
expr_stmt|;
while|while
condition|(
name|bitsdone
operator|<
name|bitsize
condition|)
block|{
name|int
name|thissize
decl_stmt|;
name|rtx
name|part
decl_stmt|,
name|word
decl_stmt|;
name|int
name|thispos
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|offset
operator|=
operator|(
name|bitpos
operator|+
name|bitsdone
operator|)
operator|/
name|unit
expr_stmt|;
name|thispos
operator|=
operator|(
name|bitpos
operator|+
name|bitsdone
operator|)
operator|%
name|unit
expr_stmt|;
comment|/* THISSIZE must not overrun a word boundary.  Otherwise, 	 extract_fixed_bit_field will call us again, and we will mutually 	 recurse forever.  */
name|thissize
operator|=
name|MIN
argument_list|(
name|bitsize
operator|-
name|bitsdone
argument_list|,
name|BITS_PER_WORD
argument_list|)
expr_stmt|;
name|thissize
operator|=
name|MIN
argument_list|(
name|thissize
argument_list|,
name|unit
operator|-
name|thispos
argument_list|)
expr_stmt|;
comment|/* If OP0 is a register, then handle OFFSET here.  	 When handling multiword bitfields, extract_bit_field may pass 	 down a word_mode SUBREG of a larger REG for a bitfield that actually 	 crosses a word boundary.  Thus, for a SUBREG, we must find 	 the current word starting from the base register.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
name|word
operator|=
name|operand_subword_force
argument_list|(
name|SUBREG_REG
argument_list|(
name|op0
argument_list|)
argument_list|,
name|SUBREG_WORD
argument_list|(
name|op0
argument_list|)
operator|+
name|offset
argument_list|,
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|REG
condition|)
block|{
name|word
operator|=
name|operand_subword_force
argument_list|(
name|op0
argument_list|,
name|offset
argument_list|,
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|word
operator|=
name|op0
expr_stmt|;
comment|/* Extract the parts in bit-counting order, 	 whose meaning is determined by BYTES_PER_UNIT. 	 OFFSET is in UNITs, and UNIT is in bits. 	 extract_fixed_bit_field wants offset in bytes.  */
name|part
operator|=
name|extract_fixed_bit_field
argument_list|(
name|word_mode
argument_list|,
name|word
argument_list|,
name|offset
operator|*
name|unit
operator|/
name|BITS_PER_UNIT
argument_list|,
name|thissize
argument_list|,
name|thispos
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|align
argument_list|)
expr_stmt|;
name|bitsdone
operator|+=
name|thissize
expr_stmt|;
comment|/* Shift this part into place for the result.  */
if|if
condition|(
name|BYTES_BIG_ENDIAN
condition|)
block|{
if|if
condition|(
name|bitsize
operator|!=
name|bitsdone
condition|)
name|part
operator|=
name|expand_shift
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|word_mode
argument_list|,
name|part
argument_list|,
name|build_int_2
argument_list|(
name|bitsize
operator|-
name|bitsdone
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|bitsdone
operator|!=
name|thissize
condition|)
name|part
operator|=
name|expand_shift
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|word_mode
argument_list|,
name|part
argument_list|,
name|build_int_2
argument_list|(
name|bitsdone
operator|-
name|thissize
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|first
condition|)
name|result
operator|=
name|part
expr_stmt|;
else|else
comment|/* Combine the parts with bitwise or.  This works 	   because we extracted each part as an unsigned bit field.  */
name|result
operator|=
name|expand_binop
argument_list|(
name|word_mode
argument_list|,
name|ior_optab
argument_list|,
name|part
argument_list|,
name|result
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Unsigned bit field: we are done.  */
if|if
condition|(
name|unsignedp
condition|)
return|return
name|result
return|;
comment|/* Signed bit field: sign-extend with two arithmetic shifts.  */
name|result
operator|=
name|expand_shift
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|word_mode
argument_list|,
name|result
argument_list|,
name|build_int_2
argument_list|(
name|BITS_PER_WORD
operator|-
name|bitsize
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|expand_shift
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|word_mode
argument_list|,
name|result
argument_list|,
name|build_int_2
argument_list|(
name|BITS_PER_WORD
operator|-
name|bitsize
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Add INC into TARGET.  */
end_comment

begin_function
name|void
name|expand_inc
parameter_list|(
name|target
parameter_list|,
name|inc
parameter_list|)
name|rtx
name|target
decl_stmt|,
name|inc
decl_stmt|;
block|{
name|rtx
name|value
init|=
name|expand_binop
argument_list|(
name|GET_MODE
argument_list|(
name|target
argument_list|)
argument_list|,
name|add_optab
argument_list|,
name|target
argument_list|,
name|inc
argument_list|,
name|target
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|!=
name|target
condition|)
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Subtract DEC from TARGET.  */
end_comment

begin_function
name|void
name|expand_dec
parameter_list|(
name|target
parameter_list|,
name|dec
parameter_list|)
name|rtx
name|target
decl_stmt|,
name|dec
decl_stmt|;
block|{
name|rtx
name|value
init|=
name|expand_binop
argument_list|(
name|GET_MODE
argument_list|(
name|target
argument_list|)
argument_list|,
name|sub_optab
argument_list|,
name|target
argument_list|,
name|dec
argument_list|,
name|target
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|!=
name|target
condition|)
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output a shift instruction for expression code CODE,    with SHIFTED being the rtx for the value to shift,    and AMOUNT the tree for the amount to shift by.    Store the result in the rtx TARGET, if that is convenient.    If UNSIGNEDP is nonzero, do a logical shift; otherwise, arithmetic.    Return the rtx for where the value is.  */
end_comment

begin_function
name|rtx
name|expand_shift
parameter_list|(
name|code
parameter_list|,
name|mode
parameter_list|,
name|shifted
parameter_list|,
name|amount
parameter_list|,
name|target
parameter_list|,
name|unsignedp
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
specifier|register
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|shifted
decl_stmt|;
name|tree
name|amount
decl_stmt|;
specifier|register
name|rtx
name|target
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
block|{
specifier|register
name|rtx
name|op1
decl_stmt|,
name|temp
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|left
init|=
operator|(
name|code
operator|==
name|LSHIFT_EXPR
operator|||
name|code
operator|==
name|LROTATE_EXPR
operator|)
decl_stmt|;
specifier|register
name|int
name|rotate
init|=
operator|(
name|code
operator|==
name|LROTATE_EXPR
operator|||
name|code
operator|==
name|RROTATE_EXPR
operator|)
decl_stmt|;
name|int
name|try
decl_stmt|;
comment|/* Previously detected shift-counts computed by NEGATE_EXPR      and shifted in the other direction; but that does not work      on all machines.  */
name|op1
operator|=
name|expand_expr
argument_list|(
name|amount
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SHIFT_COUNT_TRUNCATED
if|if
condition|(
name|SHIFT_COUNT_TRUNCATED
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|>=
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
condition|)
name|op1
operator|=
name|GEN_INT
argument_list|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|%
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|SUBREG
operator|&&
name|SUBREG_WORD
argument_list|(
name|op1
argument_list|)
operator|==
literal|0
condition|)
name|op1
operator|=
name|SUBREG_REG
argument_list|(
name|op1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|op1
operator|==
name|const0_rtx
condition|)
return|return
name|shifted
return|;
for|for
control|(
name|try
operator|=
literal|0
init|;
name|temp
operator|==
literal|0
operator|&&
name|try
operator|<
literal|3
condition|;
name|try
operator|++
control|)
block|{
name|enum
name|optab_methods
name|methods
decl_stmt|;
if|if
condition|(
name|try
operator|==
literal|0
condition|)
name|methods
operator|=
name|OPTAB_DIRECT
expr_stmt|;
elseif|else
if|if
condition|(
name|try
operator|==
literal|1
condition|)
name|methods
operator|=
name|OPTAB_WIDEN
expr_stmt|;
else|else
name|methods
operator|=
name|OPTAB_LIB_WIDEN
expr_stmt|;
if|if
condition|(
name|rotate
condition|)
block|{
comment|/* Widening does not work for rotation.  */
if|if
condition|(
name|methods
operator|==
name|OPTAB_WIDEN
condition|)
continue|continue;
elseif|else
if|if
condition|(
name|methods
operator|==
name|OPTAB_LIB_WIDEN
condition|)
block|{
comment|/* If we have been unable to open-code this by a rotation, 		 do it as the IOR of two shifts.  I.e., to rotate A 		 by N bits, compute (A<< N) | ((unsigned) A>> (C - N)) 		 where C is the bitsize of A.  		 It is theoretically possible that the target machine might 		 not be able to perform either shift and hence we would 		 be making two libcalls rather than just the one for the 		 shift (similarly if IOR could not be done).  We will allow 		 this extremely unlikely lossage to avoid complicating the 		 code below.  */
name|rtx
name|subtarget
init|=
name|target
operator|==
name|shifted
condition|?
literal|0
else|:
name|target
decl_stmt|;
name|rtx
name|temp1
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|amount
argument_list|)
decl_stmt|;
name|tree
name|new_amount
init|=
name|make_tree
argument_list|(
name|type
argument_list|,
name|op1
argument_list|)
decl_stmt|;
name|tree
name|other_amount
init|=
name|fold
argument_list|(
name|build
argument_list|(
name|MINUS_EXPR
argument_list|,
name|type
argument_list|,
name|convert
argument_list|(
name|type
argument_list|,
name|build_int_2
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|amount
argument_list|)
argument_list|)
decl_stmt|;
name|shifted
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|shifted
argument_list|)
expr_stmt|;
name|temp
operator|=
name|expand_shift
argument_list|(
name|left
condition|?
name|LSHIFT_EXPR
else|:
name|RSHIFT_EXPR
argument_list|,
name|mode
argument_list|,
name|shifted
argument_list|,
name|new_amount
argument_list|,
name|subtarget
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|temp1
operator|=
name|expand_shift
argument_list|(
name|left
condition|?
name|RSHIFT_EXPR
else|:
name|LSHIFT_EXPR
argument_list|,
name|mode
argument_list|,
name|shifted
argument_list|,
name|other_amount
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|ior_optab
argument_list|,
name|temp
argument_list|,
name|temp1
argument_list|,
name|target
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|)
return|;
block|}
name|temp
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|left
condition|?
name|rotl_optab
else|:
name|rotr_optab
argument_list|,
name|shifted
argument_list|,
name|op1
argument_list|,
name|target
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|)
expr_stmt|;
comment|/* If we don't have the rotate, but we are rotating by a constant 	     that is in range, try a rotate in the opposite direction.  */
if|if
condition|(
name|temp
operator|==
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|>
literal|0
operator|&&
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|<
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
condition|)
name|temp
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|left
condition|?
name|rotr_optab
else|:
name|rotl_optab
argument_list|,
name|shifted
argument_list|,
name|GEN_INT
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|-
name|INTVAL
argument_list|(
name|op1
argument_list|)
argument_list|)
argument_list|,
name|target
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|unsignedp
condition|)
name|temp
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|left
condition|?
name|ashl_optab
else|:
name|lshr_optab
argument_list|,
name|shifted
argument_list|,
name|op1
argument_list|,
name|target
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|)
expr_stmt|;
comment|/* Do arithmetic shifts. 	 Also, if we are going to widen the operand, we can just as well 	 use an arithmetic right-shift instead of a logical one.  */
if|if
condition|(
name|temp
operator|==
literal|0
operator|&&
operator|!
name|rotate
operator|&&
operator|(
operator|!
name|unsignedp
operator|||
operator|(
operator|!
name|left
operator|&&
name|methods
operator|==
name|OPTAB_WIDEN
operator|)
operator|)
condition|)
block|{
name|enum
name|optab_methods
name|methods1
init|=
name|methods
decl_stmt|;
comment|/* If trying to widen a log shift to an arithmetic shift, 	     don't accept an arithmetic shift of the same size.  */
if|if
condition|(
name|unsignedp
condition|)
name|methods1
operator|=
name|OPTAB_MUST_WIDEN
expr_stmt|;
comment|/* Arithmetic shift */
name|temp
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|left
condition|?
name|ashl_optab
else|:
name|ashr_optab
argument_list|,
name|shifted
argument_list|,
name|op1
argument_list|,
name|target
argument_list|,
name|unsignedp
argument_list|,
name|methods1
argument_list|)
expr_stmt|;
block|}
comment|/* We used to try extzv here for logical right shifts, but that was 	 only useful for one machine, the VAX, and caused poor code  	 generation there for lshrdi3, so the code was deleted and a 	 define_expand for lshrsi3 was added to vax.md.  */
block|}
if|if
condition|(
name|temp
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|temp
return|;
block|}
end_function

begin_escape
end_escape

begin_enum
enum|enum
name|alg_code
block|{
name|alg_zero
block|,
name|alg_m
block|,
name|alg_shift
block|,
name|alg_add_t_m2
block|,
name|alg_sub_t_m2
block|,
name|alg_add_factor
block|,
name|alg_sub_factor
block|,
name|alg_add_t2_m
block|,
name|alg_sub_t2_m
block|,
name|alg_add
block|,
name|alg_subtract
block|,
name|alg_factor
block|,
name|alg_shiftop
block|}
enum|;
end_enum

begin_comment
comment|/* This structure records a sequence of operations.    `ops' is the number of operations recorded.    `cost' is their total cost.    The operations are stored in `op' and the corresponding    logarithms of the integer coefficients in `log'.     These are the operations:    alg_zero		total := 0;    alg_m		total := multiplicand;    alg_shift		total := total * coeff    alg_add_t_m2		total := total + multiplicand * coeff;    alg_sub_t_m2		total := total - multiplicand * coeff;    alg_add_factor	total := total * coeff + total;    alg_sub_factor	total := total * coeff - total;    alg_add_t2_m		total := total * coeff + multiplicand;    alg_sub_t2_m		total := total * coeff - multiplicand;     The first operand must be either alg_zero or alg_m.  */
end_comment

begin_struct
struct|struct
name|algorithm
block|{
name|short
name|cost
decl_stmt|;
name|short
name|ops
decl_stmt|;
comment|/* The size of the OP and LOG fields are not directly related to the      word size, but the worst-case algorithms will be if we have few      consecutive ones or zeros, i.e., a multiplicand like 10101010101...      In that case we will generate shift-by-2, add, shift-by-2, add,...,      in total wordsize operations.  */
name|enum
name|alg_code
name|op
index|[
name|MAX_BITS_PER_WORD
index|]
decl_stmt|;
name|char
name|log
index|[
name|MAX_BITS_PER_WORD
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|void
name|synth_mult
name|PROTO
argument_list|(
operator|(
expr|struct
name|algorithm
operator|*
operator|,
name|unsigned
name|HOST_WIDE_INT
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|HOST_WIDE_INT
name|choose_multiplier
name|PROTO
argument_list|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|,
name|int
operator|,
name|int
operator|,
name|unsigned
name|HOST_WIDE_INT
operator|*
operator|,
name|int
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|HOST_WIDE_INT
name|invert_mod2n
name|PROTO
argument_list|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Compute and return the best algorithm for multiplying by T.    The algorithm must cost less than cost_limit    If retval.cost>= COST_LIMIT, no algorithm was found and all    other field of the returned struct are undefined.  */
end_comment

begin_function
specifier|static
name|void
name|synth_mult
parameter_list|(
name|alg_out
parameter_list|,
name|t
parameter_list|,
name|cost_limit
parameter_list|)
name|struct
name|algorithm
modifier|*
name|alg_out
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|t
decl_stmt|;
name|int
name|cost_limit
decl_stmt|;
block|{
name|int
name|m
decl_stmt|;
name|struct
name|algorithm
modifier|*
name|alg_in
decl_stmt|,
modifier|*
name|best_alg
decl_stmt|;
name|unsigned
name|int
name|cost
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|q
decl_stmt|;
comment|/* Indicate that no algorithm is yet found.  If no algorithm      is found, this value will be returned and indicate failure.  */
name|alg_out
operator|->
name|cost
operator|=
name|cost_limit
expr_stmt|;
if|if
condition|(
name|cost_limit
operator|<=
literal|0
condition|)
return|return;
comment|/* t == 1 can be done in zero cost.  */
if|if
condition|(
name|t
operator|==
literal|1
condition|)
block|{
name|alg_out
operator|->
name|ops
operator|=
literal|1
expr_stmt|;
name|alg_out
operator|->
name|cost
operator|=
literal|0
expr_stmt|;
name|alg_out
operator|->
name|op
index|[
literal|0
index|]
operator|=
name|alg_m
expr_stmt|;
return|return;
block|}
comment|/* t == 0 sometimes has a cost.  If it does and it exceeds our limit,      fail now.  */
if|if
condition|(
name|t
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|zero_cost
operator|>=
name|cost_limit
condition|)
return|return;
else|else
block|{
name|alg_out
operator|->
name|ops
operator|=
literal|1
expr_stmt|;
name|alg_out
operator|->
name|cost
operator|=
name|zero_cost
expr_stmt|;
name|alg_out
operator|->
name|op
index|[
literal|0
index|]
operator|=
name|alg_zero
expr_stmt|;
return|return;
block|}
block|}
comment|/* We'll be needing a couple extra algorithm structures now.  */
name|alg_in
operator|=
operator|(
expr|struct
name|algorithm
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|algorithm
argument_list|)
argument_list|)
expr_stmt|;
name|best_alg
operator|=
operator|(
expr|struct
name|algorithm
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|algorithm
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we have a group of zero bits at the low-order part of T, try      multiplying by the remaining bits and then doing a shift.  */
if|if
condition|(
operator|(
name|t
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
name|m
operator|=
name|floor_log2
argument_list|(
name|t
operator|&
operator|-
name|t
argument_list|)
expr_stmt|;
comment|/* m = number of low zero bits */
name|q
operator|=
name|t
operator|>>
name|m
expr_stmt|;
name|cost
operator|=
name|shift_cost
index|[
name|m
index|]
expr_stmt|;
name|synth_mult
argument_list|(
name|alg_in
argument_list|,
name|q
argument_list|,
name|cost_limit
operator|-
name|cost
argument_list|)
expr_stmt|;
name|cost
operator|+=
name|alg_in
operator|->
name|cost
expr_stmt|;
if|if
condition|(
name|cost
operator|<
name|cost_limit
condition|)
block|{
name|struct
name|algorithm
modifier|*
name|x
decl_stmt|;
name|x
operator|=
name|alg_in
operator|,
name|alg_in
operator|=
name|best_alg
operator|,
name|best_alg
operator|=
name|x
expr_stmt|;
name|best_alg
operator|->
name|log
index|[
name|best_alg
operator|->
name|ops
index|]
operator|=
name|m
expr_stmt|;
name|best_alg
operator|->
name|op
index|[
name|best_alg
operator|->
name|ops
index|]
operator|=
name|alg_shift
expr_stmt|;
name|cost_limit
operator|=
name|cost
expr_stmt|;
block|}
block|}
comment|/* If we have an odd number, add or subtract one.  */
if|if
condition|(
operator|(
name|t
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|w
decl_stmt|;
for|for
control|(
name|w
operator|=
literal|1
init|;
operator|(
name|w
operator|&
name|t
operator|)
operator|!=
literal|0
condition|;
name|w
operator|<<=
literal|1
control|)
empty_stmt|;
comment|/* If T was -1, then W will be zero after the loop.  This is another 	 case where T ends with ...111.  Handling this with (T + 1) and  	 subtract 1 produces slightly better code and results in algorithm 	 selection much faster than treating it like the ...0111 case 	 below.  */
if|if
condition|(
name|w
operator|==
literal|0
operator|||
operator|(
name|w
operator|>
literal|2
comment|/* Reject the case where t is 3. 		 Thus we prefer addition in that case.  */
operator|&&
name|t
operator|!=
literal|3
operator|)
condition|)
block|{
comment|/* T ends with ...111.  Multiply by (T + 1) and subtract 1.  */
name|cost
operator|=
name|add_cost
expr_stmt|;
name|synth_mult
argument_list|(
name|alg_in
argument_list|,
name|t
operator|+
literal|1
argument_list|,
name|cost_limit
operator|-
name|cost
argument_list|)
expr_stmt|;
name|cost
operator|+=
name|alg_in
operator|->
name|cost
expr_stmt|;
if|if
condition|(
name|cost
operator|<
name|cost_limit
condition|)
block|{
name|struct
name|algorithm
modifier|*
name|x
decl_stmt|;
name|x
operator|=
name|alg_in
operator|,
name|alg_in
operator|=
name|best_alg
operator|,
name|best_alg
operator|=
name|x
expr_stmt|;
name|best_alg
operator|->
name|log
index|[
name|best_alg
operator|->
name|ops
index|]
operator|=
literal|0
expr_stmt|;
name|best_alg
operator|->
name|op
index|[
name|best_alg
operator|->
name|ops
index|]
operator|=
name|alg_sub_t_m2
expr_stmt|;
name|cost_limit
operator|=
name|cost
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* T ends with ...01 or ...011.  Multiply by (T - 1) and add 1.  */
name|cost
operator|=
name|add_cost
expr_stmt|;
name|synth_mult
argument_list|(
name|alg_in
argument_list|,
name|t
operator|-
literal|1
argument_list|,
name|cost_limit
operator|-
name|cost
argument_list|)
expr_stmt|;
name|cost
operator|+=
name|alg_in
operator|->
name|cost
expr_stmt|;
if|if
condition|(
name|cost
operator|<
name|cost_limit
condition|)
block|{
name|struct
name|algorithm
modifier|*
name|x
decl_stmt|;
name|x
operator|=
name|alg_in
operator|,
name|alg_in
operator|=
name|best_alg
operator|,
name|best_alg
operator|=
name|x
expr_stmt|;
name|best_alg
operator|->
name|log
index|[
name|best_alg
operator|->
name|ops
index|]
operator|=
literal|0
expr_stmt|;
name|best_alg
operator|->
name|op
index|[
name|best_alg
operator|->
name|ops
index|]
operator|=
name|alg_add_t_m2
expr_stmt|;
name|cost_limit
operator|=
name|cost
expr_stmt|;
block|}
block|}
block|}
comment|/* Look for factors of t of the form      t = q(2**m +- 1), 2<= m<= floor(log2(t - 1)).      If we find such a factor, we can multiply by t using an algorithm that      multiplies by q, shift the result by m and add/subtract it to itself.       We search for large factors first and loop down, even if large factors      are less probable than small; if we find a large factor we will find a      good sequence quickly, and therefore be able to prune (by decreasing      COST_LIMIT) the search.  */
for|for
control|(
name|m
operator|=
name|floor_log2
argument_list|(
name|t
operator|-
literal|1
argument_list|)
init|;
name|m
operator|>=
literal|2
condition|;
name|m
operator|--
control|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|d
decl_stmt|;
name|d
operator|=
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|m
operator|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|t
operator|%
name|d
operator|==
literal|0
operator|&&
name|t
operator|>
name|d
condition|)
block|{
name|cost
operator|=
name|MIN
argument_list|(
name|shiftadd_cost
index|[
name|m
index|]
argument_list|,
name|add_cost
operator|+
name|shift_cost
index|[
name|m
index|]
argument_list|)
expr_stmt|;
name|synth_mult
argument_list|(
name|alg_in
argument_list|,
name|t
operator|/
name|d
argument_list|,
name|cost_limit
operator|-
name|cost
argument_list|)
expr_stmt|;
name|cost
operator|+=
name|alg_in
operator|->
name|cost
expr_stmt|;
if|if
condition|(
name|cost
operator|<
name|cost_limit
condition|)
block|{
name|struct
name|algorithm
modifier|*
name|x
decl_stmt|;
name|x
operator|=
name|alg_in
operator|,
name|alg_in
operator|=
name|best_alg
operator|,
name|best_alg
operator|=
name|x
expr_stmt|;
name|best_alg
operator|->
name|log
index|[
name|best_alg
operator|->
name|ops
index|]
operator|=
name|m
expr_stmt|;
name|best_alg
operator|->
name|op
index|[
name|best_alg
operator|->
name|ops
index|]
operator|=
name|alg_add_factor
expr_stmt|;
name|cost_limit
operator|=
name|cost
expr_stmt|;
block|}
comment|/* Other factors will have been taken care of in the recursion.  */
break|break;
block|}
name|d
operator|=
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|m
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|t
operator|%
name|d
operator|==
literal|0
operator|&&
name|t
operator|>
name|d
condition|)
block|{
name|cost
operator|=
name|MIN
argument_list|(
name|shiftsub_cost
index|[
name|m
index|]
argument_list|,
name|add_cost
operator|+
name|shift_cost
index|[
name|m
index|]
argument_list|)
expr_stmt|;
name|synth_mult
argument_list|(
name|alg_in
argument_list|,
name|t
operator|/
name|d
argument_list|,
name|cost_limit
operator|-
name|cost
argument_list|)
expr_stmt|;
name|cost
operator|+=
name|alg_in
operator|->
name|cost
expr_stmt|;
if|if
condition|(
name|cost
operator|<
name|cost_limit
condition|)
block|{
name|struct
name|algorithm
modifier|*
name|x
decl_stmt|;
name|x
operator|=
name|alg_in
operator|,
name|alg_in
operator|=
name|best_alg
operator|,
name|best_alg
operator|=
name|x
expr_stmt|;
name|best_alg
operator|->
name|log
index|[
name|best_alg
operator|->
name|ops
index|]
operator|=
name|m
expr_stmt|;
name|best_alg
operator|->
name|op
index|[
name|best_alg
operator|->
name|ops
index|]
operator|=
name|alg_sub_factor
expr_stmt|;
name|cost_limit
operator|=
name|cost
expr_stmt|;
block|}
break|break;
block|}
block|}
comment|/* Try shift-and-add (load effective address) instructions,      i.e. do a*3, a*5, a*9.  */
if|if
condition|(
operator|(
name|t
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
block|{
name|q
operator|=
name|t
operator|-
literal|1
expr_stmt|;
name|q
operator|=
name|q
operator|&
operator|-
name|q
expr_stmt|;
name|m
operator|=
name|exact_log2
argument_list|(
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|>=
literal|0
condition|)
block|{
name|cost
operator|=
name|shiftadd_cost
index|[
name|m
index|]
expr_stmt|;
name|synth_mult
argument_list|(
name|alg_in
argument_list|,
operator|(
name|t
operator|-
literal|1
operator|)
operator|>>
name|m
argument_list|,
name|cost_limit
operator|-
name|cost
argument_list|)
expr_stmt|;
name|cost
operator|+=
name|alg_in
operator|->
name|cost
expr_stmt|;
if|if
condition|(
name|cost
operator|<
name|cost_limit
condition|)
block|{
name|struct
name|algorithm
modifier|*
name|x
decl_stmt|;
name|x
operator|=
name|alg_in
operator|,
name|alg_in
operator|=
name|best_alg
operator|,
name|best_alg
operator|=
name|x
expr_stmt|;
name|best_alg
operator|->
name|log
index|[
name|best_alg
operator|->
name|ops
index|]
operator|=
name|m
expr_stmt|;
name|best_alg
operator|->
name|op
index|[
name|best_alg
operator|->
name|ops
index|]
operator|=
name|alg_add_t2_m
expr_stmt|;
name|cost_limit
operator|=
name|cost
expr_stmt|;
block|}
block|}
name|q
operator|=
name|t
operator|+
literal|1
expr_stmt|;
name|q
operator|=
name|q
operator|&
operator|-
name|q
expr_stmt|;
name|m
operator|=
name|exact_log2
argument_list|(
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|>=
literal|0
condition|)
block|{
name|cost
operator|=
name|shiftsub_cost
index|[
name|m
index|]
expr_stmt|;
name|synth_mult
argument_list|(
name|alg_in
argument_list|,
operator|(
name|t
operator|+
literal|1
operator|)
operator|>>
name|m
argument_list|,
name|cost_limit
operator|-
name|cost
argument_list|)
expr_stmt|;
name|cost
operator|+=
name|alg_in
operator|->
name|cost
expr_stmt|;
if|if
condition|(
name|cost
operator|<
name|cost_limit
condition|)
block|{
name|struct
name|algorithm
modifier|*
name|x
decl_stmt|;
name|x
operator|=
name|alg_in
operator|,
name|alg_in
operator|=
name|best_alg
operator|,
name|best_alg
operator|=
name|x
expr_stmt|;
name|best_alg
operator|->
name|log
index|[
name|best_alg
operator|->
name|ops
index|]
operator|=
name|m
expr_stmt|;
name|best_alg
operator|->
name|op
index|[
name|best_alg
operator|->
name|ops
index|]
operator|=
name|alg_sub_t2_m
expr_stmt|;
name|cost_limit
operator|=
name|cost
expr_stmt|;
block|}
block|}
block|}
comment|/* If cost_limit has not decreased since we stored it in alg_out->cost,      we have not found any algorithm.  */
if|if
condition|(
name|cost_limit
operator|==
name|alg_out
operator|->
name|cost
condition|)
return|return;
comment|/* If we are getting a too long sequence for `struct algorithm'      to record, make this search fail.  */
if|if
condition|(
name|best_alg
operator|->
name|ops
operator|==
name|MAX_BITS_PER_WORD
condition|)
return|return;
comment|/* Copy the algorithm from temporary space to the space at alg_out.      We avoid using structure assignment because the majority of      best_alg is normally undefined, and this is a critical function.  */
name|alg_out
operator|->
name|ops
operator|=
name|best_alg
operator|->
name|ops
operator|+
literal|1
expr_stmt|;
name|alg_out
operator|->
name|cost
operator|=
name|cost_limit
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|best_alg
operator|->
name|op
argument_list|,
operator|(
name|char
operator|*
operator|)
name|alg_out
operator|->
name|op
argument_list|,
name|alg_out
operator|->
name|ops
operator|*
sizeof|sizeof
expr|*
name|alg_out
operator|->
name|op
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|best_alg
operator|->
name|log
argument_list|,
operator|(
name|char
operator|*
operator|)
name|alg_out
operator|->
name|log
argument_list|,
name|alg_out
operator|->
name|ops
operator|*
sizeof|sizeof
expr|*
name|alg_out
operator|->
name|log
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Perform a multiplication and return an rtx for the result.    MODE is mode of value; OP0 and OP1 are what to multiply (rtx's);    TARGET is a suggestion for where to store the result (an rtx).     We check specially for a constant integer as OP1.    If you want this check for OP0 as well, then before calling    you should swap the two operands if OP0 would be constant.  */
end_comment

begin_function
name|rtx
name|expand_mult
parameter_list|(
name|mode
parameter_list|,
name|op0
parameter_list|,
name|op1
parameter_list|,
name|target
parameter_list|,
name|unsignedp
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
specifier|register
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|,
name|target
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
block|{
name|rtx
name|const_op1
init|=
name|op1
decl_stmt|;
comment|/* synth_mult does an `unsigned int' multiply.  As long as the mode is      less than or equal in size to `unsigned int' this doesn't matter.      If the mode is larger than `unsigned int', then synth_mult works only      if the constant value exactly fits in an `unsigned int' without any      truncation.  This means that multiplying by negative values does      not work; results are off by 2^32 on a 32 bit machine.  */
comment|/* If we are multiplying in DImode, it may still be a win      to try to work with shifts and adds.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|op1
argument_list|)
argument_list|)
operator|==
name|MODE_INT
operator|&&
name|HOST_BITS_PER_INT
operator|>=
name|BITS_PER_WORD
operator|&&
name|CONST_DOUBLE_HIGH
argument_list|(
name|op1
argument_list|)
operator|==
literal|0
condition|)
name|const_op1
operator|=
name|GEN_INT
argument_list|(
name|CONST_DOUBLE_LOW
argument_list|(
name|op1
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|HOST_BITS_PER_INT
operator|<
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|<
literal|0
condition|)
name|const_op1
operator|=
literal|0
expr_stmt|;
comment|/* We used to test optimize here, on the grounds that it's better to      produce a smaller program when -O is not used.      But this causes such a terrible slowdown sometimes      that it seems better to use synth_mult always.  */
if|if
condition|(
name|const_op1
operator|&&
name|GET_CODE
argument_list|(
name|const_op1
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|struct
name|algorithm
name|alg
decl_stmt|;
name|struct
name|algorithm
name|alg2
decl_stmt|;
name|HOST_WIDE_INT
name|val
init|=
name|INTVAL
argument_list|(
name|op1
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|val_so_far
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|int
name|mult_cost
decl_stmt|;
enum|enum
block|{
name|basic_variant
block|,
name|negate_variant
block|,
name|add_variant
block|}
name|variant
init|=
name|basic_variant
enum|;
comment|/* Try to do the computation three ways: multiply by the negative of OP1 	 and then negate, do the multiplication directly, or do multiplication 	 by OP1 - 1.  */
name|mult_cost
operator|=
name|rtx_cost
argument_list|(
name|gen_rtx_MULT
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
argument_list|,
name|SET
argument_list|)
expr_stmt|;
name|mult_cost
operator|=
name|MIN
argument_list|(
literal|12
operator|*
name|add_cost
argument_list|,
name|mult_cost
argument_list|)
expr_stmt|;
name|synth_mult
argument_list|(
operator|&
name|alg
argument_list|,
name|val
argument_list|,
name|mult_cost
argument_list|)
expr_stmt|;
comment|/* This works only if the inverted value actually fits in an 	 `unsigned int' */
if|if
condition|(
name|HOST_BITS_PER_INT
operator|>=
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
condition|)
block|{
name|synth_mult
argument_list|(
operator|&
name|alg2
argument_list|,
operator|-
name|val
argument_list|,
operator|(
name|alg
operator|.
name|cost
operator|<
name|mult_cost
condition|?
name|alg
operator|.
name|cost
else|:
name|mult_cost
operator|)
operator|-
name|negate_cost
argument_list|)
expr_stmt|;
if|if
condition|(
name|alg2
operator|.
name|cost
operator|+
name|negate_cost
operator|<
name|alg
operator|.
name|cost
condition|)
name|alg
operator|=
name|alg2
operator|,
name|variant
operator|=
name|negate_variant
expr_stmt|;
block|}
comment|/* This proves very useful for division-by-constant.  */
name|synth_mult
argument_list|(
operator|&
name|alg2
argument_list|,
name|val
operator|-
literal|1
argument_list|,
operator|(
name|alg
operator|.
name|cost
operator|<
name|mult_cost
condition|?
name|alg
operator|.
name|cost
else|:
name|mult_cost
operator|)
operator|-
name|add_cost
argument_list|)
expr_stmt|;
if|if
condition|(
name|alg2
operator|.
name|cost
operator|+
name|add_cost
operator|<
name|alg
operator|.
name|cost
condition|)
name|alg
operator|=
name|alg2
operator|,
name|variant
operator|=
name|add_variant
expr_stmt|;
if|if
condition|(
name|alg
operator|.
name|cost
operator|<
name|mult_cost
condition|)
block|{
comment|/* We found something cheaper than a multiply insn.  */
name|int
name|opno
decl_stmt|;
name|rtx
name|accum
decl_stmt|,
name|tem
decl_stmt|;
name|op0
operator|=
name|protect_from_queue
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Avoid referencing memory over and over. 	     For speed, but also for correctness when mem is volatile.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|MEM
condition|)
name|op0
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
comment|/* ACCUM starts out either as OP0 or as a zero, depending on 	     the first operation.  */
if|if
condition|(
name|alg
operator|.
name|op
index|[
literal|0
index|]
operator|==
name|alg_zero
condition|)
block|{
name|accum
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|val_so_far
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|alg
operator|.
name|op
index|[
literal|0
index|]
operator|==
name|alg_m
condition|)
block|{
name|accum
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|val_so_far
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
for|for
control|(
name|opno
operator|=
literal|1
init|;
name|opno
operator|<
name|alg
operator|.
name|ops
condition|;
name|opno
operator|++
control|)
block|{
name|int
name|log
init|=
name|alg
operator|.
name|log
index|[
name|opno
index|]
decl_stmt|;
name|int
name|preserve
init|=
name|preserve_subexpressions_p
argument_list|()
decl_stmt|;
name|rtx
name|shift_subtarget
init|=
name|preserve
condition|?
literal|0
else|:
name|accum
decl_stmt|;
name|rtx
name|add_target
init|=
operator|(
name|opno
operator|==
name|alg
operator|.
name|ops
operator|-
literal|1
operator|&&
name|target
operator|!=
literal|0
operator|&&
name|variant
operator|!=
name|add_variant
operator|&&
operator|!
name|preserve
operator|)
condition|?
name|target
else|:
literal|0
decl_stmt|;
name|rtx
name|accum_target
init|=
name|preserve
condition|?
literal|0
else|:
name|accum
decl_stmt|;
switch|switch
condition|(
name|alg
operator|.
name|op
index|[
name|opno
index|]
condition|)
block|{
case|case
name|alg_shift
case|:
name|accum
operator|=
name|expand_shift
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|mode
argument_list|,
name|accum
argument_list|,
name|build_int_2
argument_list|(
name|log
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|val_so_far
operator|<<=
name|log
expr_stmt|;
break|break;
case|case
name|alg_add_t_m2
case|:
name|tem
operator|=
name|expand_shift
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|build_int_2
argument_list|(
name|log
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|accum
operator|=
name|force_operand
argument_list|(
name|gen_rtx_PLUS
argument_list|(
name|mode
argument_list|,
name|accum
argument_list|,
name|tem
argument_list|)
argument_list|,
name|add_target
condition|?
name|add_target
else|:
name|accum_target
argument_list|)
expr_stmt|;
name|val_so_far
operator|+=
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|log
expr_stmt|;
break|break;
case|case
name|alg_sub_t_m2
case|:
name|tem
operator|=
name|expand_shift
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|build_int_2
argument_list|(
name|log
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|accum
operator|=
name|force_operand
argument_list|(
name|gen_rtx_MINUS
argument_list|(
name|mode
argument_list|,
name|accum
argument_list|,
name|tem
argument_list|)
argument_list|,
name|add_target
condition|?
name|add_target
else|:
name|accum_target
argument_list|)
expr_stmt|;
name|val_so_far
operator|-=
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|log
expr_stmt|;
break|break;
case|case
name|alg_add_t2_m
case|:
name|accum
operator|=
name|expand_shift
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|mode
argument_list|,
name|accum
argument_list|,
name|build_int_2
argument_list|(
name|log
argument_list|,
literal|0
argument_list|)
argument_list|,
name|shift_subtarget
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|accum
operator|=
name|force_operand
argument_list|(
name|gen_rtx_PLUS
argument_list|(
name|mode
argument_list|,
name|accum
argument_list|,
name|op0
argument_list|)
argument_list|,
name|add_target
condition|?
name|add_target
else|:
name|accum_target
argument_list|)
expr_stmt|;
name|val_so_far
operator|=
operator|(
name|val_so_far
operator|<<
name|log
operator|)
operator|+
literal|1
expr_stmt|;
break|break;
case|case
name|alg_sub_t2_m
case|:
name|accum
operator|=
name|expand_shift
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|mode
argument_list|,
name|accum
argument_list|,
name|build_int_2
argument_list|(
name|log
argument_list|,
literal|0
argument_list|)
argument_list|,
name|shift_subtarget
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|accum
operator|=
name|force_operand
argument_list|(
name|gen_rtx_MINUS
argument_list|(
name|mode
argument_list|,
name|accum
argument_list|,
name|op0
argument_list|)
argument_list|,
name|add_target
condition|?
name|add_target
else|:
name|accum_target
argument_list|)
expr_stmt|;
name|val_so_far
operator|=
operator|(
name|val_so_far
operator|<<
name|log
operator|)
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|alg_add_factor
case|:
name|tem
operator|=
name|expand_shift
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|mode
argument_list|,
name|accum
argument_list|,
name|build_int_2
argument_list|(
name|log
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|accum
operator|=
name|force_operand
argument_list|(
name|gen_rtx_PLUS
argument_list|(
name|mode
argument_list|,
name|accum
argument_list|,
name|tem
argument_list|)
argument_list|,
name|add_target
condition|?
name|add_target
else|:
name|accum_target
argument_list|)
expr_stmt|;
name|val_so_far
operator|+=
name|val_so_far
operator|<<
name|log
expr_stmt|;
break|break;
case|case
name|alg_sub_factor
case|:
name|tem
operator|=
name|expand_shift
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|mode
argument_list|,
name|accum
argument_list|,
name|build_int_2
argument_list|(
name|log
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|accum
operator|=
name|force_operand
argument_list|(
name|gen_rtx_MINUS
argument_list|(
name|mode
argument_list|,
name|tem
argument_list|,
name|accum
argument_list|)
argument_list|,
operator|(
name|add_target
condition|?
name|add_target
else|:
name|preserve
condition|?
literal|0
else|:
name|tem
operator|)
argument_list|)
expr_stmt|;
name|val_so_far
operator|=
operator|(
name|val_so_far
operator|<<
name|log
operator|)
operator|-
name|val_so_far
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
empty_stmt|;
block|}
comment|/* Write a REG_EQUAL note on the last insn so that we can cse 		 multiplication sequences.  */
name|insn
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_EQUAL
argument_list|,
name|gen_rtx_MULT
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|,
name|GEN_INT
argument_list|(
name|val_so_far
argument_list|)
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|variant
operator|==
name|negate_variant
condition|)
block|{
name|val_so_far
operator|=
operator|-
name|val_so_far
expr_stmt|;
name|accum
operator|=
name|expand_unop
argument_list|(
name|mode
argument_list|,
name|neg_optab
argument_list|,
name|accum
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|variant
operator|==
name|add_variant
condition|)
block|{
name|val_so_far
operator|=
name|val_so_far
operator|+
literal|1
expr_stmt|;
name|accum
operator|=
name|force_operand
argument_list|(
name|gen_rtx_PLUS
argument_list|(
name|mode
argument_list|,
name|accum
argument_list|,
name|op0
argument_list|)
argument_list|,
name|target
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|!=
name|val_so_far
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|accum
return|;
block|}
block|}
comment|/* This used to use umul_optab if unsigned, but for non-widening multiply      there is no difference between signed and unsigned.  */
name|op0
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|smul_optab
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|target
argument_list|,
name|unsignedp
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|op0
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|op0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the smallest n such that 2**n>= X.  */
end_comment

begin_function
name|int
name|ceil_log2
parameter_list|(
name|x
parameter_list|)
name|unsigned
name|HOST_WIDE_INT
name|x
decl_stmt|;
block|{
return|return
name|floor_log2
argument_list|(
name|x
operator|-
literal|1
argument_list|)
operator|+
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Choose a minimal N + 1 bit approximation to 1/D that can be used to    replace division by D, and put the least significant N bits of the result    in *MULTIPLIER_PTR and return the most significant bit.     The width of operations is N (should be<= HOST_BITS_PER_WIDE_INT), the    needed precision is in PRECISION (should be<= N).     PRECISION should be as small as possible so this function can choose    multiplier more freely.     The rounded-up logarithm of D is placed in *lgup_ptr.  A shift count that    is to be used for a final right shift is placed in *POST_SHIFT_PTR.     Using this function, x/D will be equal to (x * m)>> (*POST_SHIFT_PTR),    where m is the full HOST_BITS_PER_WIDE_INT + 1 bit multiplier.  */
end_comment

begin_function
specifier|static
name|unsigned
name|HOST_WIDE_INT
name|choose_multiplier
parameter_list|(
name|d
parameter_list|,
name|n
parameter_list|,
name|precision
parameter_list|,
name|multiplier_ptr
parameter_list|,
name|post_shift_ptr
parameter_list|,
name|lgup_ptr
parameter_list|)
name|unsigned
name|HOST_WIDE_INT
name|d
decl_stmt|;
name|int
name|n
decl_stmt|;
name|int
name|precision
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
modifier|*
name|multiplier_ptr
decl_stmt|;
name|int
modifier|*
name|post_shift_ptr
decl_stmt|;
name|int
modifier|*
name|lgup_ptr
decl_stmt|;
block|{
name|unsigned
name|HOST_WIDE_INT
name|mhigh_hi
decl_stmt|,
name|mhigh_lo
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|mlow_hi
decl_stmt|,
name|mlow_lo
decl_stmt|;
name|int
name|lgup
decl_stmt|,
name|post_shift
decl_stmt|;
name|int
name|pow
decl_stmt|,
name|pow2
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|nh
decl_stmt|,
name|nl
decl_stmt|,
name|dummy1
decl_stmt|,
name|dummy2
decl_stmt|;
comment|/* lgup = ceil(log2(divisor)); */
name|lgup
operator|=
name|ceil_log2
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|lgup
operator|>
name|n
condition|)
name|abort
argument_list|()
expr_stmt|;
name|pow
operator|=
name|n
operator|+
name|lgup
expr_stmt|;
name|pow2
operator|=
name|n
operator|+
name|lgup
operator|-
name|precision
expr_stmt|;
if|if
condition|(
name|pow
operator|==
literal|2
operator|*
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
comment|/* We could handle this with some effort, but this case is much better 	 handled directly with a scc insn, so rely on caller using that.  */
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* mlow = 2^(N + lgup)/d */
if|if
condition|(
name|pow
operator|>=
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
name|nh
operator|=
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|pow
operator|-
name|HOST_BITS_PER_WIDE_INT
operator|)
expr_stmt|;
name|nl
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|nh
operator|=
literal|0
expr_stmt|;
name|nl
operator|=
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|pow
expr_stmt|;
block|}
name|div_and_round_double
argument_list|(
name|TRUNC_DIV_EXPR
argument_list|,
literal|1
argument_list|,
name|nl
argument_list|,
name|nh
argument_list|,
name|d
argument_list|,
operator|(
name|HOST_WIDE_INT
operator|)
literal|0
argument_list|,
operator|&
name|mlow_lo
argument_list|,
operator|&
name|mlow_hi
argument_list|,
operator|&
name|dummy1
argument_list|,
operator|&
name|dummy2
argument_list|)
expr_stmt|;
comment|/* mhigh = (2^(N + lgup) + 2^N + lgup - precision)/d */
if|if
condition|(
name|pow2
operator|>=
name|HOST_BITS_PER_WIDE_INT
condition|)
name|nh
operator||=
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|pow2
operator|-
name|HOST_BITS_PER_WIDE_INT
operator|)
expr_stmt|;
else|else
name|nl
operator||=
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|pow2
expr_stmt|;
name|div_and_round_double
argument_list|(
name|TRUNC_DIV_EXPR
argument_list|,
literal|1
argument_list|,
name|nl
argument_list|,
name|nh
argument_list|,
name|d
argument_list|,
operator|(
name|HOST_WIDE_INT
operator|)
literal|0
argument_list|,
operator|&
name|mhigh_lo
argument_list|,
operator|&
name|mhigh_hi
argument_list|,
operator|&
name|dummy1
argument_list|,
operator|&
name|dummy2
argument_list|)
expr_stmt|;
if|if
condition|(
name|mhigh_hi
operator|&&
name|nh
operator|-
name|d
operator|>=
name|d
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|mhigh_hi
operator|>
literal|1
operator|||
name|mlow_hi
operator|>
literal|1
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* assert that mlow< mhigh.  */
if|if
condition|(
operator|!
operator|(
name|mlow_hi
operator|<
name|mhigh_hi
operator|||
operator|(
name|mlow_hi
operator|==
name|mhigh_hi
operator|&&
name|mlow_lo
operator|<
name|mhigh_lo
operator|)
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* If precision == N, then mlow, mhigh exceed 2^N      (but they do not exceed 2^(N+1)).  */
comment|/* Reduce to lowest terms */
for|for
control|(
name|post_shift
operator|=
name|lgup
init|;
name|post_shift
operator|>
literal|0
condition|;
name|post_shift
operator|--
control|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|ml_lo
init|=
operator|(
name|mlow_hi
operator|<<
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|-
literal|1
operator|)
operator|)
operator||
operator|(
name|mlow_lo
operator|>>
literal|1
operator|)
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|mh_lo
init|=
operator|(
name|mhigh_hi
operator|<<
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|-
literal|1
operator|)
operator|)
operator||
operator|(
name|mhigh_lo
operator|>>
literal|1
operator|)
decl_stmt|;
if|if
condition|(
name|ml_lo
operator|>=
name|mh_lo
condition|)
break|break;
name|mlow_hi
operator|=
literal|0
expr_stmt|;
name|mlow_lo
operator|=
name|ml_lo
expr_stmt|;
name|mhigh_hi
operator|=
literal|0
expr_stmt|;
name|mhigh_lo
operator|=
name|mh_lo
expr_stmt|;
block|}
operator|*
name|post_shift_ptr
operator|=
name|post_shift
expr_stmt|;
operator|*
name|lgup_ptr
operator|=
name|lgup
expr_stmt|;
if|if
condition|(
name|n
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|mask
init|=
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|n
operator|)
operator|-
literal|1
decl_stmt|;
operator|*
name|multiplier_ptr
operator|=
name|mhigh_lo
operator|&
name|mask
expr_stmt|;
return|return
name|mhigh_lo
operator|>=
name|mask
return|;
block|}
else|else
block|{
operator|*
name|multiplier_ptr
operator|=
name|mhigh_lo
expr_stmt|;
return|return
name|mhigh_hi
return|;
block|}
block|}
end_function

begin_comment
comment|/* Compute the inverse of X mod 2**n, i.e., find Y such that X * Y is    congruent to 1 (mod 2**N).  */
end_comment

begin_function
specifier|static
name|unsigned
name|HOST_WIDE_INT
name|invert_mod2n
parameter_list|(
name|x
parameter_list|,
name|n
parameter_list|)
name|unsigned
name|HOST_WIDE_INT
name|x
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
comment|/* Solve x*y == 1 (mod 2^n), where x is odd.  Return y.  */
comment|/* The algorithm notes that the choice y = x satisfies      x*y == 1 mod 2^3, since x is assumed odd.      Each iteration doubles the number of bits of significance in y.  */
name|unsigned
name|HOST_WIDE_INT
name|mask
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|y
init|=
name|x
decl_stmt|;
name|int
name|nbit
init|=
literal|3
decl_stmt|;
name|mask
operator|=
operator|(
name|n
operator|==
name|HOST_BITS_PER_WIDE_INT
condition|?
operator|~
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|0
else|:
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|n
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
while|while
condition|(
name|nbit
operator|<
name|n
condition|)
block|{
name|y
operator|=
name|y
operator|*
operator|(
literal|2
operator|-
name|x
operator|*
name|y
operator|)
operator|&
name|mask
expr_stmt|;
comment|/* Modulo 2^N */
name|nbit
operator|*=
literal|2
expr_stmt|;
block|}
return|return
name|y
return|;
block|}
end_function

begin_comment
comment|/* Emit code to adjust ADJ_OPERAND after multiplication of wrong signedness    flavor of OP0 and OP1.  ADJ_OPERAND is already the high half of the    product OP0 x OP1.  If UNSIGNEDP is nonzero, adjust the signed product    to become unsigned, if UNSIGNEDP is zero, adjust the unsigned product to    become signed.     The result is put in TARGET if that is convenient.     MODE is the mode of operation.  */
end_comment

begin_function
name|rtx
name|expand_mult_highpart_adjust
parameter_list|(
name|mode
parameter_list|,
name|adj_operand
parameter_list|,
name|op0
parameter_list|,
name|op1
parameter_list|,
name|target
parameter_list|,
name|unsignedp
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
specifier|register
name|rtx
name|adj_operand
decl_stmt|,
name|op0
decl_stmt|,
name|op1
decl_stmt|,
name|target
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
block|{
name|rtx
name|tem
decl_stmt|;
name|enum
name|rtx_code
name|adj_code
init|=
name|unsignedp
condition|?
name|PLUS
else|:
name|MINUS
decl_stmt|;
name|tem
operator|=
name|expand_shift
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|build_int_2
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tem
operator|=
name|expand_and
argument_list|(
name|tem
argument_list|,
name|op1
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|adj_operand
operator|=
name|force_operand
argument_list|(
name|gen_rtx_fmt_ee
argument_list|(
name|adj_code
argument_list|,
name|mode
argument_list|,
name|adj_operand
argument_list|,
name|tem
argument_list|)
argument_list|,
name|adj_operand
argument_list|)
expr_stmt|;
name|tem
operator|=
name|expand_shift
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|mode
argument_list|,
name|op1
argument_list|,
name|build_int_2
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tem
operator|=
name|expand_and
argument_list|(
name|tem
argument_list|,
name|op0
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|target
operator|=
name|force_operand
argument_list|(
name|gen_rtx_fmt_ee
argument_list|(
name|adj_code
argument_list|,
name|mode
argument_list|,
name|adj_operand
argument_list|,
name|tem
argument_list|)
argument_list|,
name|target
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
end_function

begin_comment
comment|/* Emit code to multiply OP0 and CNST1, putting the high half of the result    in TARGET if that is convenient, and return where the result is.  If the    operation can not be performed, 0 is returned.     MODE is the mode of operation and result.     UNSIGNEDP nonzero means unsigned multiply.     MAX_COST is the total allowed cost for the expanded RTL.  */
end_comment

begin_function
name|rtx
name|expand_mult_highpart
parameter_list|(
name|mode
parameter_list|,
name|op0
parameter_list|,
name|cnst1
parameter_list|,
name|target
parameter_list|,
name|unsignedp
parameter_list|,
name|max_cost
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
specifier|register
name|rtx
name|op0
decl_stmt|,
name|target
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|cnst1
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
name|int
name|max_cost
decl_stmt|;
block|{
name|enum
name|machine_mode
name|wider_mode
init|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|optab
name|mul_highpart_optab
decl_stmt|;
name|optab
name|moptab
decl_stmt|;
name|rtx
name|tem
decl_stmt|;
name|int
name|size
init|=
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|rtx
name|op1
decl_stmt|,
name|wide_op1
decl_stmt|;
comment|/* We can't support modes wider than HOST_BITS_PER_INT.  */
if|if
condition|(
name|size
operator|>
name|HOST_BITS_PER_WIDE_INT
condition|)
name|abort
argument_list|()
expr_stmt|;
name|op1
operator|=
name|GEN_INT
argument_list|(
name|cnst1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|wider_mode
argument_list|)
operator|<=
name|HOST_BITS_PER_INT
condition|)
name|wide_op1
operator|=
name|op1
expr_stmt|;
else|else
name|wide_op1
operator|=
name|immed_double_const
argument_list|(
name|cnst1
argument_list|,
operator|(
name|unsignedp
condition|?
operator|(
name|HOST_WIDE_INT
operator|)
literal|0
else|:
operator|-
operator|(
name|cnst1
operator|>>
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|-
literal|1
operator|)
operator|)
operator|)
argument_list|,
name|wider_mode
argument_list|)
expr_stmt|;
comment|/* expand_mult handles constant multiplication of word_mode      or narrower.  It does a poor job for large modes.  */
if|if
condition|(
name|size
operator|<
name|BITS_PER_WORD
operator|&&
name|mul_cost
index|[
operator|(
name|int
operator|)
name|wider_mode
index|]
operator|+
name|shift_cost
index|[
name|size
operator|-
literal|1
index|]
operator|<
name|max_cost
condition|)
block|{
comment|/* We have to do this, since expand_binop doesn't do conversion for 	 multiply.  Maybe change expand_binop to handle widening multiply?  */
name|op0
operator|=
name|convert_to_mode
argument_list|(
name|wider_mode
argument_list|,
name|op0
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
name|tem
operator|=
name|expand_mult
argument_list|(
name|wider_mode
argument_list|,
name|op0
argument_list|,
name|wide_op1
argument_list|,
name|NULL_RTX
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
name|tem
operator|=
name|expand_shift
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|wider_mode
argument_list|,
name|tem
argument_list|,
name|build_int_2
argument_list|(
name|size
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|convert_modes
argument_list|(
name|mode
argument_list|,
name|wider_mode
argument_list|,
name|tem
argument_list|,
name|unsignedp
argument_list|)
return|;
block|}
if|if
condition|(
name|target
operator|==
literal|0
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
comment|/* Firstly, try using a multiplication insn that only generates the needed      high part of the product, and in the sign flavor of unsignedp.  */
if|if
condition|(
name|mul_highpart_cost
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|<
name|max_cost
condition|)
block|{
name|mul_highpart_optab
operator|=
name|unsignedp
condition|?
name|umul_highpart_optab
else|:
name|smul_highpart_optab
expr_stmt|;
name|target
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|mul_highpart_optab
argument_list|,
name|op0
argument_list|,
name|wide_op1
argument_list|,
name|target
argument_list|,
name|unsignedp
argument_list|,
name|OPTAB_DIRECT
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
block|}
comment|/* Secondly, same as above, but use sign flavor opposite of unsignedp.      Need to adjust the result after the multiplication.  */
if|if
condition|(
name|mul_highpart_cost
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|+
literal|2
operator|*
name|shift_cost
index|[
name|size
operator|-
literal|1
index|]
operator|+
literal|4
operator|*
name|add_cost
operator|<
name|max_cost
condition|)
block|{
name|mul_highpart_optab
operator|=
name|unsignedp
condition|?
name|smul_highpart_optab
else|:
name|umul_highpart_optab
expr_stmt|;
name|target
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|mul_highpart_optab
argument_list|,
name|op0
argument_list|,
name|wide_op1
argument_list|,
name|target
argument_list|,
name|unsignedp
argument_list|,
name|OPTAB_DIRECT
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
comment|/* We used the wrong signedness.  Adjust the result.  */
return|return
name|expand_mult_highpart_adjust
argument_list|(
name|mode
argument_list|,
name|target
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|target
argument_list|,
name|unsignedp
argument_list|)
return|;
block|}
comment|/* Try widening multiplication.  */
name|moptab
operator|=
name|unsignedp
condition|?
name|umul_widen_optab
else|:
name|smul_widen_optab
expr_stmt|;
if|if
condition|(
name|moptab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|wider_mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
operator|&&
name|mul_widen_cost
index|[
operator|(
name|int
operator|)
name|wider_mode
index|]
operator|<
name|max_cost
condition|)
block|{
name|op1
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|op1
argument_list|)
expr_stmt|;
goto|goto
name|try
goto|;
block|}
comment|/* Try widening the mode and perform a non-widening multiplication.  */
name|moptab
operator|=
name|smul_optab
expr_stmt|;
if|if
condition|(
name|smul_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|wider_mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
operator|&&
name|mul_cost
index|[
operator|(
name|int
operator|)
name|wider_mode
index|]
operator|+
name|shift_cost
index|[
name|size
operator|-
literal|1
index|]
operator|<
name|max_cost
condition|)
block|{
name|op1
operator|=
name|wide_op1
expr_stmt|;
goto|goto
name|try
goto|;
block|}
comment|/* Try widening multiplication of opposite signedness, and adjust.  */
name|moptab
operator|=
name|unsignedp
condition|?
name|smul_widen_optab
else|:
name|umul_widen_optab
expr_stmt|;
if|if
condition|(
name|moptab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|wider_mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
operator|&&
operator|(
name|mul_widen_cost
index|[
operator|(
name|int
operator|)
name|wider_mode
index|]
operator|+
literal|2
operator|*
name|shift_cost
index|[
name|size
operator|-
literal|1
index|]
operator|+
literal|4
operator|*
name|add_cost
operator|<
name|max_cost
operator|)
condition|)
block|{
name|rtx
name|regop1
init|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|op1
argument_list|)
decl_stmt|;
name|tem
operator|=
name|expand_binop
argument_list|(
name|wider_mode
argument_list|,
name|moptab
argument_list|,
name|op0
argument_list|,
name|regop1
argument_list|,
name|NULL_RTX
argument_list|,
operator|!
name|unsignedp
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
operator|!=
literal|0
condition|)
block|{
comment|/* Extract the high half of the just generated product.  */
name|tem
operator|=
name|expand_shift
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|wider_mode
argument_list|,
name|tem
argument_list|,
name|build_int_2
argument_list|(
name|size
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tem
operator|=
name|convert_modes
argument_list|(
name|mode
argument_list|,
name|wider_mode
argument_list|,
name|tem
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
comment|/* We used the wrong signedness.  Adjust the result.  */
return|return
name|expand_mult_highpart_adjust
argument_list|(
name|mode
argument_list|,
name|tem
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|target
argument_list|,
name|unsignedp
argument_list|)
return|;
block|}
block|}
return|return
literal|0
return|;
name|try
label|:
comment|/* Pass NULL_RTX as target since TARGET has wrong mode.  */
name|tem
operator|=
name|expand_binop
argument_list|(
name|wider_mode
argument_list|,
name|moptab
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|NULL_RTX
argument_list|,
name|unsignedp
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Extract the high half of the just generated product.  */
if|if
condition|(
name|mode
operator|==
name|word_mode
condition|)
block|{
return|return
name|gen_highpart
argument_list|(
name|mode
argument_list|,
name|tem
argument_list|)
return|;
block|}
else|else
block|{
name|tem
operator|=
name|expand_shift
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|wider_mode
argument_list|,
name|tem
argument_list|,
name|build_int_2
argument_list|(
name|size
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|convert_modes
argument_list|(
name|mode
argument_list|,
name|wider_mode
argument_list|,
name|tem
argument_list|,
name|unsignedp
argument_list|)
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Emit the code to divide OP0 by OP1, putting the result in TARGET    if that is convenient, and returning where the result is.    You may request either the quotient or the remainder as the result;    specify REM_FLAG nonzero to get the remainder.     CODE is the expression code for which kind of division this is;    it controls how rounding is done.  MODE is the machine mode to use.    UNSIGNEDP nonzero means do unsigned division.  */
end_comment

begin_comment
comment|/* ??? For CEIL_MOD_EXPR, can compute incorrect remainder with ANDI    and then correct it by or'ing in missing high bits    if result of ANDI is nonzero.    For ROUND_MOD_EXPR, can use ANDI and then sign-extend the result.    This could optimize to a bfexts instruction.    But C doesn't use these operations, so their optimizations are    left for later.  */
end_comment

begin_define
define|#
directive|define
name|EXACT_POWER_OF_2_OR_ZERO_P
parameter_list|(
name|x
parameter_list|)
value|(((x)& ((x) - 1)) == 0)
end_define

begin_function
name|rtx
name|expand_divmod
parameter_list|(
name|rem_flag
parameter_list|,
name|code
parameter_list|,
name|mode
parameter_list|,
name|op0
parameter_list|,
name|op1
parameter_list|,
name|target
parameter_list|,
name|unsignedp
parameter_list|)
name|int
name|rem_flag
decl_stmt|;
name|enum
name|tree_code
name|code
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
specifier|register
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|,
name|target
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
block|{
name|enum
name|machine_mode
name|compute_mode
decl_stmt|;
specifier|register
name|rtx
name|tquotient
decl_stmt|;
name|rtx
name|quotient
init|=
literal|0
decl_stmt|,
name|remainder
init|=
literal|0
decl_stmt|;
name|rtx
name|last
decl_stmt|;
name|int
name|size
decl_stmt|;
name|rtx
name|insn
decl_stmt|,
name|set
decl_stmt|;
name|optab
name|optab1
decl_stmt|,
name|optab2
decl_stmt|;
name|int
name|op1_is_constant
decl_stmt|,
name|op1_is_pow2
decl_stmt|;
name|int
name|max_cost
decl_stmt|,
name|extra_cost
decl_stmt|;
specifier|static
name|HOST_WIDE_INT
name|last_div_const
init|=
literal|0
decl_stmt|;
name|op1_is_constant
operator|=
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
expr_stmt|;
name|op1_is_pow2
operator|=
operator|(
name|op1_is_constant
operator|&&
operator|(
operator|(
name|EXACT_POWER_OF_2_OR_ZERO_P
argument_list|(
name|INTVAL
argument_list|(
name|op1
argument_list|)
argument_list|)
operator|||
operator|(
operator|!
name|unsignedp
operator|&&
name|EXACT_POWER_OF_2_OR_ZERO_P
argument_list|(
operator|-
name|INTVAL
argument_list|(
name|op1
argument_list|)
argument_list|)
operator|)
operator|)
operator|)
operator|)
expr_stmt|;
comment|/*      This is the structure of expand_divmod:       First comes code to fix up the operands so we can perform the operations      correctly and efficiently.       Second comes a switch statement with code specific for each rounding mode.      For some special operands this code emits all RTL for the desired      operation, for other cases, it generates only a quotient and stores it in      QUOTIENT.  The case for trunc division/remainder might leave quotient = 0,      to indicate that it has not done anything.       Last comes code that finishes the operation.  If QUOTIENT is set and      REM_FLAG is set, the remainder is computed as OP0 - QUOTIENT * OP1.  If      QUOTIENT is not set, it is computed using trunc rounding.       We try to generate special code for division and remainder when OP1 is a      constant.  If |OP1| = 2**n we can use shifts and some other fast      operations.  For other values of OP1, we compute a carefully selected      fixed-point approximation m = 1/OP1, and generate code that multiplies OP0      by m.       In all cases but EXACT_DIV_EXPR, this multiplication requires the upper      half of the product.  Different strategies for generating the product are      implemented in expand_mult_highpart.       If what we actually want is the remainder, we generate that by another      by-constant multiplication and a subtraction.  */
comment|/* We shouldn't be called with OP1 == const1_rtx, but some of the      code below will malfunction if we are, so check here and handle      the special case if so.  */
if|if
condition|(
name|op1
operator|==
name|const1_rtx
condition|)
return|return
name|rem_flag
condition|?
name|const0_rtx
else|:
name|op0
return|;
if|if
condition|(
name|target
comment|/* Don't use the function value register as a target 	 since we have to read it as well as write it, 	 and function-inlining gets confused by this.  */
operator|&&
operator|(
operator|(
name|REG_P
argument_list|(
name|target
argument_list|)
operator|&&
name|REG_FUNCTION_VALUE_P
argument_list|(
name|target
argument_list|)
operator|)
comment|/* Don't clobber an operand while doing a multi-step calculation.  */
operator|||
operator|(
operator|(
name|rem_flag
operator|||
name|op1_is_constant
operator|)
operator|&&
operator|(
name|reg_mentioned_p
argument_list|(
name|target
argument_list|,
name|op0
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|MEM
operator|)
operator|)
operator|)
operator|||
name|reg_mentioned_p
argument_list|(
name|target
argument_list|,
name|op1
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|MEM
operator|)
operator|)
condition|)
name|target
operator|=
literal|0
expr_stmt|;
comment|/* Get the mode in which to perform this computation.  Normally it will      be MODE, but sometimes we can't do the desired operation in MODE.      If so, pick a wider mode in which we can do the operation.  Convert      to that mode at the start to avoid repeated conversions.       First see what operations we need.  These depend on the expression      we are evaluating.  (We assume that divxx3 insns exist under the      same conditions that modxx3 insns and that these insns don't normally      fail.  If these assumptions are not correct, we may generate less      efficient code in some cases.)       Then see if we find a mode in which we can open-code that operation      (either a division, modulus, or shift).  Finally, check for the smallest      mode for which we can do the operation with a library call.  */
comment|/* We might want to refine this now that we have division-by-constant      optimization.  Since expand_mult_highpart tries so many variants, it is      not straightforward to generalize this.  Maybe we should make an array      of possible modes in init_expmed?  Save this for GCC 2.7.  */
name|optab1
operator|=
operator|(
name|op1_is_pow2
condition|?
operator|(
name|unsignedp
condition|?
name|lshr_optab
else|:
name|ashr_optab
operator|)
else|:
operator|(
name|unsignedp
condition|?
name|udiv_optab
else|:
name|sdiv_optab
operator|)
operator|)
expr_stmt|;
name|optab2
operator|=
operator|(
name|op1_is_pow2
condition|?
name|optab1
else|:
operator|(
name|unsignedp
condition|?
name|udivmod_optab
else|:
name|sdivmod_optab
operator|)
operator|)
expr_stmt|;
for|for
control|(
name|compute_mode
operator|=
name|mode
init|;
name|compute_mode
operator|!=
name|VOIDmode
condition|;
name|compute_mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|compute_mode
argument_list|)
control|)
if|if
condition|(
name|optab1
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|compute_mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
operator|||
name|optab2
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|compute_mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
condition|)
break|break;
if|if
condition|(
name|compute_mode
operator|==
name|VOIDmode
condition|)
for|for
control|(
name|compute_mode
operator|=
name|mode
init|;
name|compute_mode
operator|!=
name|VOIDmode
condition|;
name|compute_mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|compute_mode
argument_list|)
control|)
if|if
condition|(
name|optab1
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|compute_mode
index|]
operator|.
name|libfunc
operator|||
name|optab2
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|compute_mode
index|]
operator|.
name|libfunc
condition|)
break|break;
comment|/* If we still couldn't find a mode, use MODE, but we'll probably abort      in expand_binop.  */
if|if
condition|(
name|compute_mode
operator|==
name|VOIDmode
condition|)
name|compute_mode
operator|=
name|mode
expr_stmt|;
if|if
condition|(
name|target
operator|&&
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|==
name|compute_mode
condition|)
name|tquotient
operator|=
name|target
expr_stmt|;
else|else
name|tquotient
operator|=
name|gen_reg_rtx
argument_list|(
name|compute_mode
argument_list|)
expr_stmt|;
name|size
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|compute_mode
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* It should be possible to restrict the precision to GET_MODE_BITSIZE      (mode), and thereby get better code when OP1 is a constant.  Do that      later.  It will require going over all usages of SIZE below.  */
block|size = GET_MODE_BITSIZE (mode);
endif|#
directive|endif
comment|/* Only deduct something for a REM if the last divide done was      for a different constant.   Then set the constant of the last      divide.  */
name|max_cost
operator|=
name|div_cost
index|[
operator|(
name|int
operator|)
name|compute_mode
index|]
operator|-
operator|(
name|rem_flag
operator|&&
operator|!
operator|(
name|last_div_const
operator|!=
literal|0
operator|&&
name|op1_is_constant
operator|&&
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|==
name|last_div_const
operator|)
condition|?
name|mul_cost
index|[
operator|(
name|int
operator|)
name|compute_mode
index|]
operator|+
name|add_cost
else|:
literal|0
operator|)
expr_stmt|;
name|last_div_const
operator|=
operator|!
name|rem_flag
operator|&&
name|op1_is_constant
condition|?
name|INTVAL
argument_list|(
name|op1
argument_list|)
else|:
literal|0
expr_stmt|;
comment|/* Now convert to the best mode to use.  */
if|if
condition|(
name|compute_mode
operator|!=
name|mode
condition|)
block|{
name|op0
operator|=
name|convert_modes
argument_list|(
name|compute_mode
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
name|op1
operator|=
name|convert_modes
argument_list|(
name|compute_mode
argument_list|,
name|mode
argument_list|,
name|op1
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
comment|/* convert_modes may have placed op1 into a register, so we 	 must recompute the following.  */
name|op1_is_constant
operator|=
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
expr_stmt|;
name|op1_is_pow2
operator|=
operator|(
name|op1_is_constant
operator|&&
operator|(
operator|(
name|EXACT_POWER_OF_2_OR_ZERO_P
argument_list|(
name|INTVAL
argument_list|(
name|op1
argument_list|)
argument_list|)
operator|||
operator|(
operator|!
name|unsignedp
operator|&&
name|EXACT_POWER_OF_2_OR_ZERO_P
argument_list|(
operator|-
name|INTVAL
argument_list|(
name|op1
argument_list|)
argument_list|)
operator|)
operator|)
operator|)
operator|)
expr_stmt|;
block|}
comment|/* If one of the operands is a volatile MEM, copy it into a register.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|MEM
operator|&&
name|MEM_VOLATILE_P
argument_list|(
name|op0
argument_list|)
condition|)
name|op0
operator|=
name|force_reg
argument_list|(
name|compute_mode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|MEM
operator|&&
name|MEM_VOLATILE_P
argument_list|(
name|op1
argument_list|)
condition|)
name|op1
operator|=
name|force_reg
argument_list|(
name|compute_mode
argument_list|,
name|op1
argument_list|)
expr_stmt|;
comment|/* If we need the remainder or if OP1 is constant, we need to      put OP0 in a register in case it has any queued subexpressions.  */
if|if
condition|(
name|rem_flag
operator|||
name|op1_is_constant
condition|)
name|op0
operator|=
name|force_reg
argument_list|(
name|compute_mode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|last
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
comment|/* Promote floor rounding to trunc rounding for unsigned operations.  */
if|if
condition|(
name|unsignedp
condition|)
block|{
if|if
condition|(
name|code
operator|==
name|FLOOR_DIV_EXPR
condition|)
name|code
operator|=
name|TRUNC_DIV_EXPR
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|FLOOR_MOD_EXPR
condition|)
name|code
operator|=
name|TRUNC_MOD_EXPR
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|EXACT_DIV_EXPR
operator|&&
name|op1_is_pow2
condition|)
name|code
operator|=
name|TRUNC_DIV_EXPR
expr_stmt|;
block|}
if|if
condition|(
name|op1
operator|!=
name|const0_rtx
condition|)
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|TRUNC_MOD_EXPR
case|:
case|case
name|TRUNC_DIV_EXPR
case|:
if|if
condition|(
name|op1_is_constant
condition|)
block|{
if|if
condition|(
name|unsignedp
condition|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|mh
decl_stmt|,
name|ml
decl_stmt|;
name|int
name|pre_shift
decl_stmt|,
name|post_shift
decl_stmt|;
name|int
name|dummy
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|d
init|=
name|INTVAL
argument_list|(
name|op1
argument_list|)
decl_stmt|;
if|if
condition|(
name|EXACT_POWER_OF_2_OR_ZERO_P
argument_list|(
name|d
argument_list|)
condition|)
block|{
name|pre_shift
operator|=
name|floor_log2
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|rem_flag
condition|)
block|{
name|remainder
operator|=
name|expand_binop
argument_list|(
name|compute_mode
argument_list|,
name|and_optab
argument_list|,
name|op0
argument_list|,
name|GEN_INT
argument_list|(
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|pre_shift
operator|)
operator|-
literal|1
argument_list|)
argument_list|,
name|remainder
argument_list|,
literal|1
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|remainder
condition|)
return|return
name|gen_lowpart
argument_list|(
name|mode
argument_list|,
name|remainder
argument_list|)
return|;
block|}
name|quotient
operator|=
name|expand_shift
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|compute_mode
argument_list|,
name|op0
argument_list|,
name|build_int_2
argument_list|(
name|pre_shift
argument_list|,
literal|0
argument_list|)
argument_list|,
name|tquotient
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|size
operator|<=
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
if|if
condition|(
name|d
operator|>=
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|size
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
comment|/* Most significant bit of divisor is set; emit an scc 			   insn.  */
name|quotient
operator|=
name|emit_store_flag
argument_list|(
name|tquotient
argument_list|,
name|GEU
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|compute_mode
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|quotient
operator|==
literal|0
condition|)
goto|goto
name|fail1
goto|;
block|}
else|else
block|{
comment|/* Find a suitable multiplier and right shift count 			   instead of multiplying with D.  */
name|mh
operator|=
name|choose_multiplier
argument_list|(
name|d
argument_list|,
name|size
argument_list|,
name|size
argument_list|,
operator|&
name|ml
argument_list|,
operator|&
name|post_shift
argument_list|,
operator|&
name|dummy
argument_list|)
expr_stmt|;
comment|/* If the suggested multiplier is more than SIZE bits, 			   we can do better for even divisors, using an 			   initial right shift.  */
if|if
condition|(
name|mh
operator|!=
literal|0
operator|&&
operator|(
name|d
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
name|pre_shift
operator|=
name|floor_log2
argument_list|(
name|d
operator|&
operator|-
name|d
argument_list|)
expr_stmt|;
name|mh
operator|=
name|choose_multiplier
argument_list|(
name|d
operator|>>
name|pre_shift
argument_list|,
name|size
argument_list|,
name|size
operator|-
name|pre_shift
argument_list|,
operator|&
name|ml
argument_list|,
operator|&
name|post_shift
argument_list|,
operator|&
name|dummy
argument_list|)
expr_stmt|;
if|if
condition|(
name|mh
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
else|else
name|pre_shift
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mh
operator|!=
literal|0
condition|)
block|{
name|rtx
name|t1
decl_stmt|,
name|t2
decl_stmt|,
name|t3
decl_stmt|,
name|t4
decl_stmt|;
name|extra_cost
operator|=
operator|(
name|shift_cost
index|[
name|post_shift
operator|-
literal|1
index|]
operator|+
name|shift_cost
index|[
literal|1
index|]
operator|+
literal|2
operator|*
name|add_cost
operator|)
expr_stmt|;
name|t1
operator|=
name|expand_mult_highpart
argument_list|(
name|compute_mode
argument_list|,
name|op0
argument_list|,
name|ml
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|,
name|max_cost
operator|-
name|extra_cost
argument_list|)
expr_stmt|;
if|if
condition|(
name|t1
operator|==
literal|0
condition|)
goto|goto
name|fail1
goto|;
name|t2
operator|=
name|force_operand
argument_list|(
name|gen_rtx_MINUS
argument_list|(
name|compute_mode
argument_list|,
name|op0
argument_list|,
name|t1
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|t3
operator|=
name|expand_shift
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|compute_mode
argument_list|,
name|t2
argument_list|,
name|build_int_2
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|t4
operator|=
name|force_operand
argument_list|(
name|gen_rtx_PLUS
argument_list|(
name|compute_mode
argument_list|,
name|t1
argument_list|,
name|t3
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|quotient
operator|=
name|expand_shift
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|compute_mode
argument_list|,
name|t4
argument_list|,
name|build_int_2
argument_list|(
name|post_shift
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|tquotient
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|t1
decl_stmt|,
name|t2
decl_stmt|;
name|t1
operator|=
name|expand_shift
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|compute_mode
argument_list|,
name|op0
argument_list|,
name|build_int_2
argument_list|(
name|pre_shift
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|extra_cost
operator|=
operator|(
name|shift_cost
index|[
name|pre_shift
index|]
operator|+
name|shift_cost
index|[
name|post_shift
index|]
operator|)
expr_stmt|;
name|t2
operator|=
name|expand_mult_highpart
argument_list|(
name|compute_mode
argument_list|,
name|t1
argument_list|,
name|ml
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|,
name|max_cost
operator|-
name|extra_cost
argument_list|)
expr_stmt|;
if|if
condition|(
name|t2
operator|==
literal|0
condition|)
goto|goto
name|fail1
goto|;
name|quotient
operator|=
name|expand_shift
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|compute_mode
argument_list|,
name|t2
argument_list|,
name|build_int_2
argument_list|(
name|post_shift
argument_list|,
literal|0
argument_list|)
argument_list|,
name|tquotient
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
comment|/* Too wide mode to use tricky code */
break|break;
name|insn
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
if|if
condition|(
name|insn
operator|!=
name|last
operator|&&
operator|(
name|set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|SET_DEST
argument_list|(
name|set
argument_list|)
operator|==
name|quotient
condition|)
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_EQUAL
argument_list|,
name|gen_rtx_UDIV
argument_list|(
name|compute_mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* TRUNC_DIV, signed */
block|{
name|unsigned
name|HOST_WIDE_INT
name|ml
decl_stmt|;
name|int
name|lgup
decl_stmt|,
name|post_shift
decl_stmt|;
name|HOST_WIDE_INT
name|d
init|=
name|INTVAL
argument_list|(
name|op1
argument_list|)
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|abs_d
init|=
name|d
operator|>=
literal|0
condition|?
name|d
else|:
operator|-
name|d
decl_stmt|;
comment|/* n rem d = n rem -d */
if|if
condition|(
name|rem_flag
operator|&&
name|d
operator|<
literal|0
condition|)
block|{
name|d
operator|=
name|abs_d
expr_stmt|;
name|op1
operator|=
name|GEN_INT
argument_list|(
name|abs_d
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|d
operator|==
literal|1
condition|)
name|quotient
operator|=
name|op0
expr_stmt|;
elseif|else
if|if
condition|(
name|d
operator|==
operator|-
literal|1
condition|)
name|quotient
operator|=
name|expand_unop
argument_list|(
name|compute_mode
argument_list|,
name|neg_optab
argument_list|,
name|op0
argument_list|,
name|tquotient
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|abs_d
operator|==
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|size
operator|-
literal|1
operator|)
condition|)
block|{
comment|/* This case is not handled correctly below.  */
name|quotient
operator|=
name|emit_store_flag
argument_list|(
name|tquotient
argument_list|,
name|EQ
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|compute_mode
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|quotient
operator|==
literal|0
condition|)
goto|goto
name|fail1
goto|;
block|}
elseif|else
if|if
condition|(
name|EXACT_POWER_OF_2_OR_ZERO_P
argument_list|(
name|d
argument_list|)
operator|&&
operator|(
name|rem_flag
condition|?
name|smod_pow2_cheap
else|:
name|sdiv_pow2_cheap
operator|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|EXACT_POWER_OF_2_OR_ZERO_P
argument_list|(
name|abs_d
argument_list|)
condition|)
block|{
name|lgup
operator|=
name|floor_log2
argument_list|(
name|abs_d
argument_list|)
expr_stmt|;
if|if
condition|(
name|abs_d
operator|!=
literal|2
operator|&&
name|BRANCH_COST
operator|<
literal|3
condition|)
block|{
name|rtx
name|label
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|rtx
name|t1
decl_stmt|;
name|t1
operator|=
name|copy_to_mode_reg
argument_list|(
name|compute_mode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|do_cmp_and_jump
argument_list|(
name|t1
argument_list|,
name|const0_rtx
argument_list|,
name|GE
argument_list|,
name|compute_mode
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|expand_inc
argument_list|(
name|t1
argument_list|,
name|GEN_INT
argument_list|(
name|abs_d
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|quotient
operator|=
name|expand_shift
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|compute_mode
argument_list|,
name|t1
argument_list|,
name|build_int_2
argument_list|(
name|lgup
argument_list|,
literal|0
argument_list|)
argument_list|,
name|tquotient
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|t1
decl_stmt|,
name|t2
decl_stmt|,
name|t3
decl_stmt|;
name|t1
operator|=
name|expand_shift
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|compute_mode
argument_list|,
name|op0
argument_list|,
name|build_int_2
argument_list|(
name|size
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t2
operator|=
name|expand_shift
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|compute_mode
argument_list|,
name|t1
argument_list|,
name|build_int_2
argument_list|(
name|size
operator|-
name|lgup
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|t3
operator|=
name|force_operand
argument_list|(
name|gen_rtx_PLUS
argument_list|(
name|compute_mode
argument_list|,
name|op0
argument_list|,
name|t2
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|quotient
operator|=
name|expand_shift
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|compute_mode
argument_list|,
name|t3
argument_list|,
name|build_int_2
argument_list|(
name|lgup
argument_list|,
literal|0
argument_list|)
argument_list|,
name|tquotient
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* We have computed OP0 / abs(OP1).  If OP1 is negative, negate 		       the quotient.  */
if|if
condition|(
name|d
operator|<
literal|0
condition|)
block|{
name|insn
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
if|if
condition|(
name|insn
operator|!=
name|last
operator|&&
operator|(
name|set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|SET_DEST
argument_list|(
name|set
argument_list|)
operator|==
name|quotient
condition|)
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_EQUAL
argument_list|,
name|gen_rtx_DIV
argument_list|(
name|compute_mode
argument_list|,
name|op0
argument_list|,
name|GEN_INT
argument_list|(
name|abs_d
argument_list|)
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|quotient
operator|=
name|expand_unop
argument_list|(
name|compute_mode
argument_list|,
name|neg_optab
argument_list|,
name|quotient
argument_list|,
name|quotient
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|size
operator|<=
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
name|choose_multiplier
argument_list|(
name|abs_d
argument_list|,
name|size
argument_list|,
name|size
operator|-
literal|1
argument_list|,
operator|&
name|ml
argument_list|,
operator|&
name|post_shift
argument_list|,
operator|&
name|lgup
argument_list|)
expr_stmt|;
if|if
condition|(
name|ml
operator|<
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|size
operator|-
literal|1
operator|)
condition|)
block|{
name|rtx
name|t1
decl_stmt|,
name|t2
decl_stmt|,
name|t3
decl_stmt|;
name|extra_cost
operator|=
operator|(
name|shift_cost
index|[
name|post_shift
index|]
operator|+
name|shift_cost
index|[
name|size
operator|-
literal|1
index|]
operator|+
name|add_cost
operator|)
expr_stmt|;
name|t1
operator|=
name|expand_mult_highpart
argument_list|(
name|compute_mode
argument_list|,
name|op0
argument_list|,
name|ml
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|,
name|max_cost
operator|-
name|extra_cost
argument_list|)
expr_stmt|;
if|if
condition|(
name|t1
operator|==
literal|0
condition|)
goto|goto
name|fail1
goto|;
name|t2
operator|=
name|expand_shift
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|compute_mode
argument_list|,
name|t1
argument_list|,
name|build_int_2
argument_list|(
name|post_shift
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t3
operator|=
name|expand_shift
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|compute_mode
argument_list|,
name|op0
argument_list|,
name|build_int_2
argument_list|(
name|size
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|<
literal|0
condition|)
name|quotient
operator|=
name|force_operand
argument_list|(
name|gen_rtx_MINUS
argument_list|(
name|compute_mode
argument_list|,
name|t3
argument_list|,
name|t2
argument_list|)
argument_list|,
name|tquotient
argument_list|)
expr_stmt|;
else|else
name|quotient
operator|=
name|force_operand
argument_list|(
name|gen_rtx_MINUS
argument_list|(
name|compute_mode
argument_list|,
name|t2
argument_list|,
name|t3
argument_list|)
argument_list|,
name|tquotient
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|t1
decl_stmt|,
name|t2
decl_stmt|,
name|t3
decl_stmt|,
name|t4
decl_stmt|;
name|ml
operator||=
operator|(
operator|~
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|0
operator|)
operator|<<
operator|(
name|size
operator|-
literal|1
operator|)
expr_stmt|;
name|extra_cost
operator|=
operator|(
name|shift_cost
index|[
name|post_shift
index|]
operator|+
name|shift_cost
index|[
name|size
operator|-
literal|1
index|]
operator|+
literal|2
operator|*
name|add_cost
operator|)
expr_stmt|;
name|t1
operator|=
name|expand_mult_highpart
argument_list|(
name|compute_mode
argument_list|,
name|op0
argument_list|,
name|ml
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|,
name|max_cost
operator|-
name|extra_cost
argument_list|)
expr_stmt|;
if|if
condition|(
name|t1
operator|==
literal|0
condition|)
goto|goto
name|fail1
goto|;
name|t2
operator|=
name|force_operand
argument_list|(
name|gen_rtx_PLUS
argument_list|(
name|compute_mode
argument_list|,
name|t1
argument_list|,
name|op0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|t3
operator|=
name|expand_shift
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|compute_mode
argument_list|,
name|t2
argument_list|,
name|build_int_2
argument_list|(
name|post_shift
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t4
operator|=
name|expand_shift
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|compute_mode
argument_list|,
name|op0
argument_list|,
name|build_int_2
argument_list|(
name|size
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|<
literal|0
condition|)
name|quotient
operator|=
name|force_operand
argument_list|(
name|gen_rtx_MINUS
argument_list|(
name|compute_mode
argument_list|,
name|t4
argument_list|,
name|t3
argument_list|)
argument_list|,
name|tquotient
argument_list|)
expr_stmt|;
else|else
name|quotient
operator|=
name|force_operand
argument_list|(
name|gen_rtx_MINUS
argument_list|(
name|compute_mode
argument_list|,
name|t3
argument_list|,
name|t4
argument_list|)
argument_list|,
name|tquotient
argument_list|)
expr_stmt|;
block|}
block|}
else|else
comment|/* Too wide mode to use tricky code */
break|break;
name|insn
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
if|if
condition|(
name|insn
operator|!=
name|last
operator|&&
operator|(
name|set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|SET_DEST
argument_list|(
name|set
argument_list|)
operator|==
name|quotient
condition|)
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_EQUAL
argument_list|,
name|gen_rtx_DIV
argument_list|(
name|compute_mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|fail1
label|:
name|delete_insns_since
argument_list|(
name|last
argument_list|)
expr_stmt|;
break|break;
case|case
name|FLOOR_DIV_EXPR
case|:
case|case
name|FLOOR_MOD_EXPR
case|:
comment|/* We will come here only for signed operations.  */
if|if
condition|(
name|op1_is_constant
operator|&&
name|HOST_BITS_PER_WIDE_INT
operator|>=
name|size
condition|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|mh
decl_stmt|,
name|ml
decl_stmt|;
name|int
name|pre_shift
decl_stmt|,
name|lgup
decl_stmt|,
name|post_shift
decl_stmt|;
name|HOST_WIDE_INT
name|d
init|=
name|INTVAL
argument_list|(
name|op1
argument_list|)
decl_stmt|;
if|if
condition|(
name|d
operator|>
literal|0
condition|)
block|{
comment|/* We could just as easily deal with negative constants here, 		   but it does not seem worth the trouble for GCC 2.6.  */
if|if
condition|(
name|EXACT_POWER_OF_2_OR_ZERO_P
argument_list|(
name|d
argument_list|)
condition|)
block|{
name|pre_shift
operator|=
name|floor_log2
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|rem_flag
condition|)
block|{
name|remainder
operator|=
name|expand_binop
argument_list|(
name|compute_mode
argument_list|,
name|and_optab
argument_list|,
name|op0
argument_list|,
name|GEN_INT
argument_list|(
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|pre_shift
operator|)
operator|-
literal|1
argument_list|)
argument_list|,
name|remainder
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|remainder
condition|)
return|return
name|gen_lowpart
argument_list|(
name|mode
argument_list|,
name|remainder
argument_list|)
return|;
block|}
name|quotient
operator|=
name|expand_shift
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|compute_mode
argument_list|,
name|op0
argument_list|,
name|build_int_2
argument_list|(
name|pre_shift
argument_list|,
literal|0
argument_list|)
argument_list|,
name|tquotient
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|t1
decl_stmt|,
name|t2
decl_stmt|,
name|t3
decl_stmt|,
name|t4
decl_stmt|;
name|mh
operator|=
name|choose_multiplier
argument_list|(
name|d
argument_list|,
name|size
argument_list|,
name|size
operator|-
literal|1
argument_list|,
operator|&
name|ml
argument_list|,
operator|&
name|post_shift
argument_list|,
operator|&
name|lgup
argument_list|)
expr_stmt|;
if|if
condition|(
name|mh
condition|)
name|abort
argument_list|()
expr_stmt|;
name|t1
operator|=
name|expand_shift
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|compute_mode
argument_list|,
name|op0
argument_list|,
name|build_int_2
argument_list|(
name|size
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t2
operator|=
name|expand_binop
argument_list|(
name|compute_mode
argument_list|,
name|xor_optab
argument_list|,
name|op0
argument_list|,
name|t1
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
name|extra_cost
operator|=
operator|(
name|shift_cost
index|[
name|post_shift
index|]
operator|+
name|shift_cost
index|[
name|size
operator|-
literal|1
index|]
operator|+
literal|2
operator|*
name|add_cost
operator|)
expr_stmt|;
name|t3
operator|=
name|expand_mult_highpart
argument_list|(
name|compute_mode
argument_list|,
name|t2
argument_list|,
name|ml
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|,
name|max_cost
operator|-
name|extra_cost
argument_list|)
expr_stmt|;
if|if
condition|(
name|t3
operator|!=
literal|0
condition|)
block|{
name|t4
operator|=
name|expand_shift
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|compute_mode
argument_list|,
name|t3
argument_list|,
name|build_int_2
argument_list|(
name|post_shift
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|quotient
operator|=
name|expand_binop
argument_list|(
name|compute_mode
argument_list|,
name|xor_optab
argument_list|,
name|t4
argument_list|,
name|t1
argument_list|,
name|tquotient
argument_list|,
literal|0
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|rtx
name|nsign
decl_stmt|,
name|t1
decl_stmt|,
name|t2
decl_stmt|,
name|t3
decl_stmt|,
name|t4
decl_stmt|;
name|t1
operator|=
name|force_operand
argument_list|(
name|gen_rtx_PLUS
argument_list|(
name|compute_mode
argument_list|,
name|op0
argument_list|,
name|constm1_rtx
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|t2
operator|=
name|expand_binop
argument_list|(
name|compute_mode
argument_list|,
name|ior_optab
argument_list|,
name|op0
argument_list|,
name|t1
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
name|nsign
operator|=
name|expand_shift
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|compute_mode
argument_list|,
name|t2
argument_list|,
name|build_int_2
argument_list|(
name|size
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t3
operator|=
name|force_operand
argument_list|(
name|gen_rtx_MINUS
argument_list|(
name|compute_mode
argument_list|,
name|t1
argument_list|,
name|nsign
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|t4
operator|=
name|expand_divmod
argument_list|(
literal|0
argument_list|,
name|TRUNC_DIV_EXPR
argument_list|,
name|compute_mode
argument_list|,
name|t3
argument_list|,
name|op1
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|t4
condition|)
block|{
name|rtx
name|t5
decl_stmt|;
name|t5
operator|=
name|expand_unop
argument_list|(
name|compute_mode
argument_list|,
name|one_cmpl_optab
argument_list|,
name|nsign
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|quotient
operator|=
name|force_operand
argument_list|(
name|gen_rtx_PLUS
argument_list|(
name|compute_mode
argument_list|,
name|t4
argument_list|,
name|t5
argument_list|)
argument_list|,
name|tquotient
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|quotient
operator|!=
literal|0
condition|)
break|break;
name|delete_insns_since
argument_list|(
name|last
argument_list|)
expr_stmt|;
comment|/* Try using an instruction that produces both the quotient and 	   remainder, using truncation.  We can easily compensate the quotient 	   or remainder to get floor rounding, once we have the remainder. 	   Notice that we compute also the final remainder value here, 	   and return the result right away.  */
if|if
condition|(
name|target
operator|==
literal|0
operator|||
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|compute_mode
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|compute_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|rem_flag
condition|)
block|{
name|remainder
operator|=
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|REG
condition|?
name|target
else|:
name|gen_reg_rtx
argument_list|(
name|compute_mode
argument_list|)
expr_stmt|;
name|quotient
operator|=
name|gen_reg_rtx
argument_list|(
name|compute_mode
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|quotient
operator|=
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|REG
condition|?
name|target
else|:
name|gen_reg_rtx
argument_list|(
name|compute_mode
argument_list|)
expr_stmt|;
name|remainder
operator|=
name|gen_reg_rtx
argument_list|(
name|compute_mode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|expand_twoval_binop
argument_list|(
name|sdivmod_optab
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|quotient
argument_list|,
name|remainder
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|/* This could be computed with a branch-less sequence. 	       Save that for later.  */
name|rtx
name|tem
decl_stmt|;
name|rtx
name|label
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|do_cmp_and_jump
argument_list|(
name|remainder
argument_list|,
name|const0_rtx
argument_list|,
name|EQ
argument_list|,
name|compute_mode
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|tem
operator|=
name|expand_binop
argument_list|(
name|compute_mode
argument_list|,
name|xor_optab
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
name|do_cmp_and_jump
argument_list|(
name|tem
argument_list|,
name|const0_rtx
argument_list|,
name|GE
argument_list|,
name|compute_mode
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|expand_dec
argument_list|(
name|quotient
argument_list|,
name|const1_rtx
argument_list|)
expr_stmt|;
name|expand_inc
argument_list|(
name|remainder
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
return|return
name|gen_lowpart
argument_list|(
name|mode
argument_list|,
name|rem_flag
condition|?
name|remainder
else|:
name|quotient
argument_list|)
return|;
block|}
comment|/* No luck with division elimination or divmod.  Have to do it 	   by conditionally adjusting op0 *and* the result.  */
block|{
name|rtx
name|label1
decl_stmt|,
name|label2
decl_stmt|,
name|label3
decl_stmt|,
name|label4
decl_stmt|,
name|label5
decl_stmt|;
name|rtx
name|adjusted_op0
decl_stmt|;
name|rtx
name|tem
decl_stmt|;
name|quotient
operator|=
name|gen_reg_rtx
argument_list|(
name|compute_mode
argument_list|)
expr_stmt|;
name|adjusted_op0
operator|=
name|copy_to_mode_reg
argument_list|(
name|compute_mode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|label1
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|label2
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|label3
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|label4
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|label5
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|do_cmp_and_jump
argument_list|(
name|op1
argument_list|,
name|const0_rtx
argument_list|,
name|LT
argument_list|,
name|compute_mode
argument_list|,
name|label2
argument_list|)
expr_stmt|;
name|do_cmp_and_jump
argument_list|(
name|adjusted_op0
argument_list|,
name|const0_rtx
argument_list|,
name|LT
argument_list|,
name|compute_mode
argument_list|,
name|label1
argument_list|)
expr_stmt|;
name|tem
operator|=
name|expand_binop
argument_list|(
name|compute_mode
argument_list|,
name|sdiv_optab
argument_list|,
name|adjusted_op0
argument_list|,
name|op1
argument_list|,
name|quotient
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
operator|!=
name|quotient
condition|)
name|emit_move_insn
argument_list|(
name|quotient
argument_list|,
name|tem
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_jump
argument_list|(
name|label5
argument_list|)
argument_list|)
expr_stmt|;
name|emit_barrier
argument_list|()
expr_stmt|;
name|emit_label
argument_list|(
name|label1
argument_list|)
expr_stmt|;
name|expand_inc
argument_list|(
name|adjusted_op0
argument_list|,
name|const1_rtx
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_jump
argument_list|(
name|label4
argument_list|)
argument_list|)
expr_stmt|;
name|emit_barrier
argument_list|()
expr_stmt|;
name|emit_label
argument_list|(
name|label2
argument_list|)
expr_stmt|;
name|do_cmp_and_jump
argument_list|(
name|adjusted_op0
argument_list|,
name|const0_rtx
argument_list|,
name|GT
argument_list|,
name|compute_mode
argument_list|,
name|label3
argument_list|)
expr_stmt|;
name|tem
operator|=
name|expand_binop
argument_list|(
name|compute_mode
argument_list|,
name|sdiv_optab
argument_list|,
name|adjusted_op0
argument_list|,
name|op1
argument_list|,
name|quotient
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
operator|!=
name|quotient
condition|)
name|emit_move_insn
argument_list|(
name|quotient
argument_list|,
name|tem
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_jump
argument_list|(
name|label5
argument_list|)
argument_list|)
expr_stmt|;
name|emit_barrier
argument_list|()
expr_stmt|;
name|emit_label
argument_list|(
name|label3
argument_list|)
expr_stmt|;
name|expand_dec
argument_list|(
name|adjusted_op0
argument_list|,
name|const1_rtx
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|label4
argument_list|)
expr_stmt|;
name|tem
operator|=
name|expand_binop
argument_list|(
name|compute_mode
argument_list|,
name|sdiv_optab
argument_list|,
name|adjusted_op0
argument_list|,
name|op1
argument_list|,
name|quotient
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
operator|!=
name|quotient
condition|)
name|emit_move_insn
argument_list|(
name|quotient
argument_list|,
name|tem
argument_list|)
expr_stmt|;
name|expand_dec
argument_list|(
name|quotient
argument_list|,
name|const1_rtx
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|label5
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CEIL_DIV_EXPR
case|:
case|case
name|CEIL_MOD_EXPR
case|:
if|if
condition|(
name|unsignedp
condition|)
block|{
if|if
condition|(
name|op1_is_constant
operator|&&
name|EXACT_POWER_OF_2_OR_ZERO_P
argument_list|(
name|INTVAL
argument_list|(
name|op1
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|t1
decl_stmt|,
name|t2
decl_stmt|,
name|t3
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|d
init|=
name|INTVAL
argument_list|(
name|op1
argument_list|)
decl_stmt|;
name|t1
operator|=
name|expand_shift
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|compute_mode
argument_list|,
name|op0
argument_list|,
name|build_int_2
argument_list|(
name|floor_log2
argument_list|(
name|d
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|tquotient
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|t2
operator|=
name|expand_binop
argument_list|(
name|compute_mode
argument_list|,
name|and_optab
argument_list|,
name|op0
argument_list|,
name|GEN_INT
argument_list|(
name|d
operator|-
literal|1
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
name|t3
operator|=
name|gen_reg_rtx
argument_list|(
name|compute_mode
argument_list|)
expr_stmt|;
name|t3
operator|=
name|emit_store_flag
argument_list|(
name|t3
argument_list|,
name|NE
argument_list|,
name|t2
argument_list|,
name|const0_rtx
argument_list|,
name|compute_mode
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|t3
operator|==
literal|0
condition|)
block|{
name|rtx
name|lab
decl_stmt|;
name|lab
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|do_cmp_and_jump
argument_list|(
name|t2
argument_list|,
name|const0_rtx
argument_list|,
name|EQ
argument_list|,
name|compute_mode
argument_list|,
name|lab
argument_list|)
expr_stmt|;
name|expand_inc
argument_list|(
name|t1
argument_list|,
name|const1_rtx
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|lab
argument_list|)
expr_stmt|;
name|quotient
operator|=
name|t1
expr_stmt|;
block|}
else|else
name|quotient
operator|=
name|force_operand
argument_list|(
name|gen_rtx_PLUS
argument_list|(
name|compute_mode
argument_list|,
name|t1
argument_list|,
name|t3
argument_list|)
argument_list|,
name|tquotient
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Try using an instruction that produces both the quotient and 	       remainder, using truncation.  We can easily compensate the 	       quotient or remainder to get ceiling rounding, once we have the 	       remainder.  Notice that we compute also the final remainder 	       value here, and return the result right away.  */
if|if
condition|(
name|target
operator|==
literal|0
operator|||
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|compute_mode
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|compute_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|rem_flag
condition|)
block|{
name|remainder
operator|=
operator|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|REG
condition|?
name|target
else|:
name|gen_reg_rtx
argument_list|(
name|compute_mode
argument_list|)
operator|)
expr_stmt|;
name|quotient
operator|=
name|gen_reg_rtx
argument_list|(
name|compute_mode
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|quotient
operator|=
operator|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|REG
condition|?
name|target
else|:
name|gen_reg_rtx
argument_list|(
name|compute_mode
argument_list|)
operator|)
expr_stmt|;
name|remainder
operator|=
name|gen_reg_rtx
argument_list|(
name|compute_mode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|expand_twoval_binop
argument_list|(
name|udivmod_optab
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|quotient
argument_list|,
name|remainder
argument_list|,
literal|1
argument_list|)
condition|)
block|{
comment|/* This could be computed with a branch-less sequence. 		   Save that for later.  */
name|rtx
name|label
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|do_cmp_and_jump
argument_list|(
name|remainder
argument_list|,
name|const0_rtx
argument_list|,
name|EQ
argument_list|,
name|compute_mode
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|expand_inc
argument_list|(
name|quotient
argument_list|,
name|const1_rtx
argument_list|)
expr_stmt|;
name|expand_dec
argument_list|(
name|remainder
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
return|return
name|gen_lowpart
argument_list|(
name|mode
argument_list|,
name|rem_flag
condition|?
name|remainder
else|:
name|quotient
argument_list|)
return|;
block|}
comment|/* No luck with division elimination or divmod.  Have to do it 	       by conditionally adjusting op0 *and* the result.  */
block|{
name|rtx
name|label1
decl_stmt|,
name|label2
decl_stmt|;
name|rtx
name|adjusted_op0
decl_stmt|,
name|tem
decl_stmt|;
name|quotient
operator|=
name|gen_reg_rtx
argument_list|(
name|compute_mode
argument_list|)
expr_stmt|;
name|adjusted_op0
operator|=
name|copy_to_mode_reg
argument_list|(
name|compute_mode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|label1
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|label2
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|do_cmp_and_jump
argument_list|(
name|adjusted_op0
argument_list|,
name|const0_rtx
argument_list|,
name|NE
argument_list|,
name|compute_mode
argument_list|,
name|label1
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|quotient
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_jump
argument_list|(
name|label2
argument_list|)
argument_list|)
expr_stmt|;
name|emit_barrier
argument_list|()
expr_stmt|;
name|emit_label
argument_list|(
name|label1
argument_list|)
expr_stmt|;
name|expand_dec
argument_list|(
name|adjusted_op0
argument_list|,
name|const1_rtx
argument_list|)
expr_stmt|;
name|tem
operator|=
name|expand_binop
argument_list|(
name|compute_mode
argument_list|,
name|udiv_optab
argument_list|,
name|adjusted_op0
argument_list|,
name|op1
argument_list|,
name|quotient
argument_list|,
literal|1
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
operator|!=
name|quotient
condition|)
name|emit_move_insn
argument_list|(
name|quotient
argument_list|,
name|tem
argument_list|)
expr_stmt|;
name|expand_inc
argument_list|(
name|quotient
argument_list|,
name|const1_rtx
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|label2
argument_list|)
expr_stmt|;
block|}
block|}
else|else
comment|/* signed */
block|{
if|if
condition|(
name|op1_is_constant
operator|&&
name|EXACT_POWER_OF_2_OR_ZERO_P
argument_list|(
name|INTVAL
argument_list|(
name|op1
argument_list|)
argument_list|)
operator|&&
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|>=
literal|0
condition|)
block|{
comment|/* This is extremely similar to the code for the unsigned case 		   above.  For 2.7 we should merge these variants, but for 		   2.6.1 I don't want to touch the code for unsigned since that 		   get used in C.  The signed case will only be used by other 		   languages (Ada).  */
name|rtx
name|t1
decl_stmt|,
name|t2
decl_stmt|,
name|t3
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|d
init|=
name|INTVAL
argument_list|(
name|op1
argument_list|)
decl_stmt|;
name|t1
operator|=
name|expand_shift
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|compute_mode
argument_list|,
name|op0
argument_list|,
name|build_int_2
argument_list|(
name|floor_log2
argument_list|(
name|d
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|tquotient
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t2
operator|=
name|expand_binop
argument_list|(
name|compute_mode
argument_list|,
name|and_optab
argument_list|,
name|op0
argument_list|,
name|GEN_INT
argument_list|(
name|d
operator|-
literal|1
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
name|t3
operator|=
name|gen_reg_rtx
argument_list|(
name|compute_mode
argument_list|)
expr_stmt|;
name|t3
operator|=
name|emit_store_flag
argument_list|(
name|t3
argument_list|,
name|NE
argument_list|,
name|t2
argument_list|,
name|const0_rtx
argument_list|,
name|compute_mode
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|t3
operator|==
literal|0
condition|)
block|{
name|rtx
name|lab
decl_stmt|;
name|lab
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|do_cmp_and_jump
argument_list|(
name|t2
argument_list|,
name|const0_rtx
argument_list|,
name|EQ
argument_list|,
name|compute_mode
argument_list|,
name|lab
argument_list|)
expr_stmt|;
name|expand_inc
argument_list|(
name|t1
argument_list|,
name|const1_rtx
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|lab
argument_list|)
expr_stmt|;
name|quotient
operator|=
name|t1
expr_stmt|;
block|}
else|else
name|quotient
operator|=
name|force_operand
argument_list|(
name|gen_rtx_PLUS
argument_list|(
name|compute_mode
argument_list|,
name|t1
argument_list|,
name|t3
argument_list|)
argument_list|,
name|tquotient
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Try using an instruction that produces both the quotient and 	       remainder, using truncation.  We can easily compensate the 	       quotient or remainder to get ceiling rounding, once we have the 	       remainder.  Notice that we compute also the final remainder 	       value here, and return the result right away.  */
if|if
condition|(
name|target
operator|==
literal|0
operator|||
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|compute_mode
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|compute_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|rem_flag
condition|)
block|{
name|remainder
operator|=
operator|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|REG
condition|?
name|target
else|:
name|gen_reg_rtx
argument_list|(
name|compute_mode
argument_list|)
operator|)
expr_stmt|;
name|quotient
operator|=
name|gen_reg_rtx
argument_list|(
name|compute_mode
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|quotient
operator|=
operator|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|REG
condition|?
name|target
else|:
name|gen_reg_rtx
argument_list|(
name|compute_mode
argument_list|)
operator|)
expr_stmt|;
name|remainder
operator|=
name|gen_reg_rtx
argument_list|(
name|compute_mode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|expand_twoval_binop
argument_list|(
name|sdivmod_optab
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|quotient
argument_list|,
name|remainder
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|/* This could be computed with a branch-less sequence. 		   Save that for later.  */
name|rtx
name|tem
decl_stmt|;
name|rtx
name|label
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|do_cmp_and_jump
argument_list|(
name|remainder
argument_list|,
name|const0_rtx
argument_list|,
name|EQ
argument_list|,
name|compute_mode
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|tem
operator|=
name|expand_binop
argument_list|(
name|compute_mode
argument_list|,
name|xor_optab
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
name|do_cmp_and_jump
argument_list|(
name|tem
argument_list|,
name|const0_rtx
argument_list|,
name|LT
argument_list|,
name|compute_mode
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|expand_inc
argument_list|(
name|quotient
argument_list|,
name|const1_rtx
argument_list|)
expr_stmt|;
name|expand_dec
argument_list|(
name|remainder
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
return|return
name|gen_lowpart
argument_list|(
name|mode
argument_list|,
name|rem_flag
condition|?
name|remainder
else|:
name|quotient
argument_list|)
return|;
block|}
comment|/* No luck with division elimination or divmod.  Have to do it 	       by conditionally adjusting op0 *and* the result.  */
block|{
name|rtx
name|label1
decl_stmt|,
name|label2
decl_stmt|,
name|label3
decl_stmt|,
name|label4
decl_stmt|,
name|label5
decl_stmt|;
name|rtx
name|adjusted_op0
decl_stmt|;
name|rtx
name|tem
decl_stmt|;
name|quotient
operator|=
name|gen_reg_rtx
argument_list|(
name|compute_mode
argument_list|)
expr_stmt|;
name|adjusted_op0
operator|=
name|copy_to_mode_reg
argument_list|(
name|compute_mode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|label1
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|label2
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|label3
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|label4
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|label5
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|do_cmp_and_jump
argument_list|(
name|op1
argument_list|,
name|const0_rtx
argument_list|,
name|LT
argument_list|,
name|compute_mode
argument_list|,
name|label2
argument_list|)
expr_stmt|;
name|do_cmp_and_jump
argument_list|(
name|adjusted_op0
argument_list|,
name|const0_rtx
argument_list|,
name|GT
argument_list|,
name|compute_mode
argument_list|,
name|label1
argument_list|)
expr_stmt|;
name|tem
operator|=
name|expand_binop
argument_list|(
name|compute_mode
argument_list|,
name|sdiv_optab
argument_list|,
name|adjusted_op0
argument_list|,
name|op1
argument_list|,
name|quotient
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
operator|!=
name|quotient
condition|)
name|emit_move_insn
argument_list|(
name|quotient
argument_list|,
name|tem
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_jump
argument_list|(
name|label5
argument_list|)
argument_list|)
expr_stmt|;
name|emit_barrier
argument_list|()
expr_stmt|;
name|emit_label
argument_list|(
name|label1
argument_list|)
expr_stmt|;
name|expand_dec
argument_list|(
name|adjusted_op0
argument_list|,
name|const1_rtx
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_jump
argument_list|(
name|label4
argument_list|)
argument_list|)
expr_stmt|;
name|emit_barrier
argument_list|()
expr_stmt|;
name|emit_label
argument_list|(
name|label2
argument_list|)
expr_stmt|;
name|do_cmp_and_jump
argument_list|(
name|adjusted_op0
argument_list|,
name|const0_rtx
argument_list|,
name|LT
argument_list|,
name|compute_mode
argument_list|,
name|label3
argument_list|)
expr_stmt|;
name|tem
operator|=
name|expand_binop
argument_list|(
name|compute_mode
argument_list|,
name|sdiv_optab
argument_list|,
name|adjusted_op0
argument_list|,
name|op1
argument_list|,
name|quotient
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
operator|!=
name|quotient
condition|)
name|emit_move_insn
argument_list|(
name|quotient
argument_list|,
name|tem
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_jump
argument_list|(
name|label5
argument_list|)
argument_list|)
expr_stmt|;
name|emit_barrier
argument_list|()
expr_stmt|;
name|emit_label
argument_list|(
name|label3
argument_list|)
expr_stmt|;
name|expand_inc
argument_list|(
name|adjusted_op0
argument_list|,
name|const1_rtx
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|label4
argument_list|)
expr_stmt|;
name|tem
operator|=
name|expand_binop
argument_list|(
name|compute_mode
argument_list|,
name|sdiv_optab
argument_list|,
name|adjusted_op0
argument_list|,
name|op1
argument_list|,
name|quotient
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
operator|!=
name|quotient
condition|)
name|emit_move_insn
argument_list|(
name|quotient
argument_list|,
name|tem
argument_list|)
expr_stmt|;
name|expand_inc
argument_list|(
name|quotient
argument_list|,
name|const1_rtx
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|label5
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|EXACT_DIV_EXPR
case|:
if|if
condition|(
name|op1_is_constant
operator|&&
name|HOST_BITS_PER_WIDE_INT
operator|>=
name|size
condition|)
block|{
name|HOST_WIDE_INT
name|d
init|=
name|INTVAL
argument_list|(
name|op1
argument_list|)
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|ml
decl_stmt|;
name|int
name|post_shift
decl_stmt|;
name|rtx
name|t1
decl_stmt|;
name|post_shift
operator|=
name|floor_log2
argument_list|(
name|d
operator|&
operator|-
name|d
argument_list|)
expr_stmt|;
name|ml
operator|=
name|invert_mod2n
argument_list|(
name|d
operator|>>
name|post_shift
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|t1
operator|=
name|expand_mult
argument_list|(
name|compute_mode
argument_list|,
name|op0
argument_list|,
name|GEN_INT
argument_list|(
name|ml
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
name|quotient
operator|=
name|expand_shift
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|compute_mode
argument_list|,
name|t1
argument_list|,
name|build_int_2
argument_list|(
name|post_shift
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
name|insn
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_EQUAL
argument_list|,
name|gen_rtx_fmt_ee
argument_list|(
name|unsignedp
condition|?
name|UDIV
else|:
name|DIV
argument_list|,
name|compute_mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ROUND_DIV_EXPR
case|:
case|case
name|ROUND_MOD_EXPR
case|:
if|if
condition|(
name|unsignedp
condition|)
block|{
name|rtx
name|tem
decl_stmt|;
name|rtx
name|label
decl_stmt|;
name|label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|quotient
operator|=
name|gen_reg_rtx
argument_list|(
name|compute_mode
argument_list|)
expr_stmt|;
name|remainder
operator|=
name|gen_reg_rtx
argument_list|(
name|compute_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|expand_twoval_binop
argument_list|(
name|udivmod_optab
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|quotient
argument_list|,
name|remainder
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|rtx
name|tem
decl_stmt|;
name|quotient
operator|=
name|expand_binop
argument_list|(
name|compute_mode
argument_list|,
name|udiv_optab
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|quotient
argument_list|,
literal|1
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
name|tem
operator|=
name|expand_mult
argument_list|(
name|compute_mode
argument_list|,
name|quotient
argument_list|,
name|op1
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|remainder
operator|=
name|expand_binop
argument_list|(
name|compute_mode
argument_list|,
name|sub_optab
argument_list|,
name|op0
argument_list|,
name|tem
argument_list|,
name|remainder
argument_list|,
literal|1
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
block|}
name|tem
operator|=
name|plus_constant
argument_list|(
name|op1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|tem
operator|=
name|expand_shift
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|compute_mode
argument_list|,
name|tem
argument_list|,
name|build_int_2
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|do_cmp_and_jump
argument_list|(
name|remainder
argument_list|,
name|tem
argument_list|,
name|LEU
argument_list|,
name|compute_mode
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|expand_inc
argument_list|(
name|quotient
argument_list|,
name|const1_rtx
argument_list|)
expr_stmt|;
name|expand_dec
argument_list|(
name|remainder
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|abs_rem
decl_stmt|,
name|abs_op1
decl_stmt|,
name|tem
decl_stmt|,
name|mask
decl_stmt|;
name|rtx
name|label
decl_stmt|;
name|label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|quotient
operator|=
name|gen_reg_rtx
argument_list|(
name|compute_mode
argument_list|)
expr_stmt|;
name|remainder
operator|=
name|gen_reg_rtx
argument_list|(
name|compute_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|expand_twoval_binop
argument_list|(
name|sdivmod_optab
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|quotient
argument_list|,
name|remainder
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
block|{
name|rtx
name|tem
decl_stmt|;
name|quotient
operator|=
name|expand_binop
argument_list|(
name|compute_mode
argument_list|,
name|sdiv_optab
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|quotient
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
name|tem
operator|=
name|expand_mult
argument_list|(
name|compute_mode
argument_list|,
name|quotient
argument_list|,
name|op1
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|remainder
operator|=
name|expand_binop
argument_list|(
name|compute_mode
argument_list|,
name|sub_optab
argument_list|,
name|op0
argument_list|,
name|tem
argument_list|,
name|remainder
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
block|}
name|abs_rem
operator|=
name|expand_abs
argument_list|(
name|compute_mode
argument_list|,
name|remainder
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|abs_op1
operator|=
name|expand_abs
argument_list|(
name|compute_mode
argument_list|,
name|op1
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tem
operator|=
name|expand_shift
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|compute_mode
argument_list|,
name|abs_rem
argument_list|,
name|build_int_2
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|do_cmp_and_jump
argument_list|(
name|tem
argument_list|,
name|abs_op1
argument_list|,
name|LTU
argument_list|,
name|compute_mode
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|tem
operator|=
name|expand_binop
argument_list|(
name|compute_mode
argument_list|,
name|xor_optab
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
name|mask
operator|=
name|expand_shift
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|compute_mode
argument_list|,
name|tem
argument_list|,
name|build_int_2
argument_list|(
name|size
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tem
operator|=
name|expand_binop
argument_list|(
name|compute_mode
argument_list|,
name|xor_optab
argument_list|,
name|mask
argument_list|,
name|const1_rtx
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
name|tem
operator|=
name|expand_binop
argument_list|(
name|compute_mode
argument_list|,
name|sub_optab
argument_list|,
name|tem
argument_list|,
name|mask
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
name|expand_inc
argument_list|(
name|quotient
argument_list|,
name|tem
argument_list|)
expr_stmt|;
name|tem
operator|=
name|expand_binop
argument_list|(
name|compute_mode
argument_list|,
name|xor_optab
argument_list|,
name|mask
argument_list|,
name|op1
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
name|tem
operator|=
name|expand_binop
argument_list|(
name|compute_mode
argument_list|,
name|sub_optab
argument_list|,
name|tem
argument_list|,
name|mask
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
name|expand_dec
argument_list|(
name|remainder
argument_list|,
name|tem
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
block|}
return|return
name|gen_lowpart
argument_list|(
name|mode
argument_list|,
name|rem_flag
condition|?
name|remainder
else|:
name|quotient
argument_list|)
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|quotient
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|target
operator|&&
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|compute_mode
condition|)
name|target
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rem_flag
condition|)
block|{
comment|/* Try to produce the remainder directly without a library call.  */
name|remainder
operator|=
name|sign_expand_binop
argument_list|(
name|compute_mode
argument_list|,
name|umod_optab
argument_list|,
name|smod_optab
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|target
argument_list|,
name|unsignedp
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|remainder
operator|==
literal|0
condition|)
block|{
comment|/* No luck there.  Can we do remainder and divide at once 		 without a library call?  */
name|remainder
operator|=
name|gen_reg_rtx
argument_list|(
name|compute_mode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|expand_twoval_binop
argument_list|(
operator|(
name|unsignedp
condition|?
name|udivmod_optab
else|:
name|sdivmod_optab
operator|)
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|NULL_RTX
argument_list|,
name|remainder
argument_list|,
name|unsignedp
argument_list|)
condition|)
name|remainder
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|remainder
condition|)
return|return
name|gen_lowpart
argument_list|(
name|mode
argument_list|,
name|remainder
argument_list|)
return|;
block|}
comment|/* Produce the quotient.  Try a quotient insn, but not a library call. 	 If we have a divmod in this mode, use it in preference to widening 	 the div (for this test we assume it will not fail). Note that optab2 	 is set to the one of the two optabs that the call below will use.  */
name|quotient
operator|=
name|sign_expand_binop
argument_list|(
name|compute_mode
argument_list|,
name|udiv_optab
argument_list|,
name|sdiv_optab
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|rem_flag
condition|?
name|NULL_RTX
else|:
name|target
argument_list|,
name|unsignedp
argument_list|,
operator|(
operator|(
name|optab2
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|compute_mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
operator|)
condition|?
name|OPTAB_DIRECT
else|:
name|OPTAB_WIDEN
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|quotient
operator|==
literal|0
condition|)
block|{
comment|/* No luck there.  Try a quotient-and-remainder insn, 	     keeping the quotient alone.  */
name|quotient
operator|=
name|gen_reg_rtx
argument_list|(
name|compute_mode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|expand_twoval_binop
argument_list|(
name|unsignedp
condition|?
name|udivmod_optab
else|:
name|sdivmod_optab
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|quotient
argument_list|,
name|NULL_RTX
argument_list|,
name|unsignedp
argument_list|)
condition|)
block|{
name|quotient
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|rem_flag
condition|)
comment|/* Still no luck.  If we are not computing the remainder, 		   use a library call for the quotient.  */
name|quotient
operator|=
name|sign_expand_binop
argument_list|(
name|compute_mode
argument_list|,
name|udiv_optab
argument_list|,
name|sdiv_optab
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|target
argument_list|,
name|unsignedp
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|rem_flag
condition|)
block|{
if|if
condition|(
name|target
operator|&&
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|compute_mode
condition|)
name|target
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|quotient
operator|==
literal|0
condition|)
comment|/* No divide instruction either.  Use library for remainder.  */
name|remainder
operator|=
name|sign_expand_binop
argument_list|(
name|compute_mode
argument_list|,
name|umod_optab
argument_list|,
name|smod_optab
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|target
argument_list|,
name|unsignedp
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* We divided.  Now finish doing X - Y * (X / Y).  */
name|remainder
operator|=
name|expand_mult
argument_list|(
name|compute_mode
argument_list|,
name|quotient
argument_list|,
name|op1
argument_list|,
name|NULL_RTX
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
name|remainder
operator|=
name|expand_binop
argument_list|(
name|compute_mode
argument_list|,
name|sub_optab
argument_list|,
name|op0
argument_list|,
name|remainder
argument_list|,
name|target
argument_list|,
name|unsignedp
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|gen_lowpart
argument_list|(
name|mode
argument_list|,
name|rem_flag
condition|?
name|remainder
else|:
name|quotient
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return a tree node with data type TYPE, describing the value of X.    Usually this is an RTL_EXPR, if there is no obvious better choice.    X may be an expression, however we only support those expressions    generated by loop.c.   */
end_comment

begin_function
name|tree
name|make_tree
parameter_list|(
name|type
parameter_list|,
name|x
parameter_list|)
name|tree
name|type
decl_stmt|;
name|rtx
name|x
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|CONST_INT
case|:
name|t
operator|=
name|build_int_2
argument_list|(
name|INTVAL
argument_list|(
name|x
argument_list|)
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
operator|||
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|>=
literal|0
condition|?
literal|0
else|:
operator|-
literal|1
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|type
expr_stmt|;
return|return
name|t
return|;
case|case
name|CONST_DOUBLE
case|:
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|VOIDmode
condition|)
block|{
name|t
operator|=
name|build_int_2
argument_list|(
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
argument_list|,
name|CONST_DOUBLE_HIGH
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|type
expr_stmt|;
block|}
else|else
block|{
name|REAL_VALUE_TYPE
name|d
decl_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|d
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_real
argument_list|(
name|type
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
return|return
name|t
return|;
case|case
name|PLUS
case|:
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|type
argument_list|,
name|make_tree
argument_list|(
name|type
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|make_tree
argument_list|(
name|type
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|MINUS
case|:
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|MINUS_EXPR
argument_list|,
name|type
argument_list|,
name|make_tree
argument_list|(
name|type
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|make_tree
argument_list|(
name|type
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|NEG
case|:
return|return
name|fold
argument_list|(
name|build1
argument_list|(
name|NEGATE_EXPR
argument_list|,
name|type
argument_list|,
name|make_tree
argument_list|(
name|type
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|MULT
case|:
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|MULT_EXPR
argument_list|,
name|type
argument_list|,
name|make_tree
argument_list|(
name|type
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|make_tree
argument_list|(
name|type
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|ASHIFT
case|:
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|type
argument_list|,
name|make_tree
argument_list|(
name|type
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|make_tree
argument_list|(
name|type
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|LSHIFTRT
case|:
return|return
name|fold
argument_list|(
name|convert
argument_list|(
name|type
argument_list|,
name|build
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|unsigned_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|make_tree
argument_list|(
name|unsigned_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|make_tree
argument_list|(
name|type
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|ASHIFTRT
case|:
return|return
name|fold
argument_list|(
name|convert
argument_list|(
name|type
argument_list|,
name|build
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|signed_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|make_tree
argument_list|(
name|signed_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|make_tree
argument_list|(
name|type
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|DIV
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|REAL_TYPE
condition|)
name|t
operator|=
name|signed_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
else|else
name|t
operator|=
name|type
expr_stmt|;
return|return
name|fold
argument_list|(
name|convert
argument_list|(
name|type
argument_list|,
name|build
argument_list|(
name|TRUNC_DIV_EXPR
argument_list|,
name|t
argument_list|,
name|make_tree
argument_list|(
name|t
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|make_tree
argument_list|(
name|t
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|UDIV
case|:
name|t
operator|=
name|unsigned_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return
name|fold
argument_list|(
name|convert
argument_list|(
name|type
argument_list|,
name|build
argument_list|(
name|TRUNC_DIV_EXPR
argument_list|,
name|t
argument_list|,
name|make_tree
argument_list|(
name|t
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|make_tree
argument_list|(
name|t
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
default|default:
name|t
operator|=
name|make_node
argument_list|(
name|RTL_EXPR
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|type
expr_stmt|;
name|RTL_EXPR_RTL
argument_list|(
name|t
argument_list|)
operator|=
name|x
expr_stmt|;
comment|/* There are no insns to be output 	 when this rtl_expr is used.  */
name|RTL_EXPR_SEQUENCE
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return
name|t
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return an rtx representing the value of X * MULT + ADD.    TARGET is a suggestion for where to store the result (an rtx).    MODE is the machine mode for the computation.    X and MULT must have mode MODE.  ADD may have a different mode.    So can X (defaults to same as MODE).    UNSIGNEDP is non-zero to do unsigned multiplication.    This may emit insns.  */
end_comment

begin_function
name|rtx
name|expand_mult_add
parameter_list|(
name|x
parameter_list|,
name|target
parameter_list|,
name|mult
parameter_list|,
name|add
parameter_list|,
name|mode
parameter_list|,
name|unsignedp
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|target
decl_stmt|,
name|mult
decl_stmt|,
name|add
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
block|{
name|tree
name|type
init|=
name|type_for_mode
argument_list|(
name|mode
argument_list|,
name|unsignedp
argument_list|)
decl_stmt|;
name|tree
name|add_type
init|=
operator|(
name|GET_MODE
argument_list|(
name|add
argument_list|)
operator|==
name|VOIDmode
condition|?
name|type
else|:
name|type_for_mode
argument_list|(
name|GET_MODE
argument_list|(
name|add
argument_list|)
argument_list|,
name|unsignedp
argument_list|)
operator|)
decl_stmt|;
name|tree
name|result
init|=
name|fold
argument_list|(
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|type
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|MULT_EXPR
argument_list|,
name|type
argument_list|,
name|make_tree
argument_list|(
name|type
argument_list|,
name|x
argument_list|)
argument_list|,
name|make_tree
argument_list|(
name|type
argument_list|,
name|mult
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|make_tree
argument_list|(
name|add_type
argument_list|,
name|add
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|expand_expr
argument_list|(
name|result
argument_list|,
name|target
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Compute the logical-and of OP0 and OP1, storing it in TARGET    and returning TARGET.     If TARGET is 0, a pseudo-register or constant is returned.  */
end_comment

begin_function
name|rtx
name|expand_and
parameter_list|(
name|op0
parameter_list|,
name|op1
parameter_list|,
name|target
parameter_list|)
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|,
name|target
decl_stmt|;
block|{
name|enum
name|machine_mode
name|mode
init|=
name|VOIDmode
decl_stmt|;
name|rtx
name|tem
decl_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|VOIDmode
condition|)
name|mode
operator|=
name|GET_MODE
argument_list|(
name|op0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|op1
argument_list|)
operator|!=
name|VOIDmode
condition|)
name|mode
operator|=
name|GET_MODE
argument_list|(
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
condition|)
name|tem
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|and_optab
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|target
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
condition|)
name|tem
operator|=
name|GEN_INT
argument_list|(
name|INTVAL
argument_list|(
name|op0
argument_list|)
operator|&
name|INTVAL
argument_list|(
name|op1
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|target
operator|==
literal|0
condition|)
name|target
operator|=
name|tem
expr_stmt|;
elseif|else
if|if
condition|(
name|tem
operator|!=
name|target
condition|)
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|tem
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Emit a store-flags instruction for comparison CODE on OP0 and OP1    and storing in TARGET.  Normally return TARGET.    Return 0 if that cannot be done.     MODE is the mode to use for OP0 and OP1 should they be CONST_INTs.  If    it is VOIDmode, they cannot both be CONST_INT.       UNSIGNEDP is for the case where we have to widen the operands    to perform the operation.  It says to use zero-extension.     NORMALIZEP is 1 if we should convert the result to be either zero    or one.  Normalize is -1 if we should convert the result to be    either zero or -1.  If NORMALIZEP is zero, the result will be left    "raw" out of the scc insn.  */
end_comment

begin_function
name|rtx
name|emit_store_flag
parameter_list|(
name|target
parameter_list|,
name|code
parameter_list|,
name|op0
parameter_list|,
name|op1
parameter_list|,
name|mode
parameter_list|,
name|unsignedp
parameter_list|,
name|normalizep
parameter_list|)
name|rtx
name|target
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
name|int
name|normalizep
decl_stmt|;
block|{
name|rtx
name|subtarget
decl_stmt|;
name|enum
name|insn_code
name|icode
decl_stmt|;
name|enum
name|machine_mode
name|compare_mode
decl_stmt|;
name|enum
name|machine_mode
name|target_mode
init|=
name|GET_MODE
argument_list|(
name|target
argument_list|)
decl_stmt|;
name|rtx
name|tem
decl_stmt|;
name|rtx
name|last
init|=
name|get_last_insn
argument_list|()
decl_stmt|;
name|rtx
name|pattern
decl_stmt|,
name|comparison
decl_stmt|;
comment|/* If one operand is constant, make it the second one.  Only do this      if the other operand is not constant as well.  */
if|if
condition|(
operator|(
name|CONSTANT_P
argument_list|(
name|op0
argument_list|)
operator|&&
operator|!
name|CONSTANT_P
argument_list|(
name|op1
argument_list|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|!=
name|CONST_INT
operator|)
condition|)
block|{
name|tem
operator|=
name|op0
expr_stmt|;
name|op0
operator|=
name|op1
expr_stmt|;
name|op1
operator|=
name|tem
expr_stmt|;
name|code
operator|=
name|swap_condition
argument_list|(
name|code
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
name|mode
operator|=
name|GET_MODE
argument_list|(
name|op0
argument_list|)
expr_stmt|;
comment|/* For some comparisons with 1 and -1, we can convert this to       comparisons with zero.  This will often produce more opportunities for      store-flag insns.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|LT
case|:
if|if
condition|(
name|op1
operator|==
name|const1_rtx
condition|)
name|op1
operator|=
name|const0_rtx
operator|,
name|code
operator|=
name|LE
expr_stmt|;
break|break;
case|case
name|LE
case|:
if|if
condition|(
name|op1
operator|==
name|constm1_rtx
condition|)
name|op1
operator|=
name|const0_rtx
operator|,
name|code
operator|=
name|LT
expr_stmt|;
break|break;
case|case
name|GE
case|:
if|if
condition|(
name|op1
operator|==
name|const1_rtx
condition|)
name|op1
operator|=
name|const0_rtx
operator|,
name|code
operator|=
name|GT
expr_stmt|;
break|break;
case|case
name|GT
case|:
if|if
condition|(
name|op1
operator|==
name|constm1_rtx
condition|)
name|op1
operator|=
name|const0_rtx
operator|,
name|code
operator|=
name|GE
expr_stmt|;
break|break;
case|case
name|GEU
case|:
if|if
condition|(
name|op1
operator|==
name|const1_rtx
condition|)
name|op1
operator|=
name|const0_rtx
operator|,
name|code
operator|=
name|NE
expr_stmt|;
break|break;
case|case
name|LTU
case|:
if|if
condition|(
name|op1
operator|==
name|const1_rtx
condition|)
name|op1
operator|=
name|const0_rtx
operator|,
name|code
operator|=
name|EQ
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* From now on, we won't change CODE, so set ICODE now.  */
name|icode
operator|=
name|setcc_gen_code
index|[
operator|(
name|int
operator|)
name|code
index|]
expr_stmt|;
comment|/* If this is A< 0 or A>= 0, we can do this by taking the ones      complement of A (for GE) and shifting the sign bit to the low bit.  */
if|if
condition|(
name|op1
operator|==
name|const0_rtx
operator|&&
operator|(
name|code
operator|==
name|LT
operator|||
name|code
operator|==
name|GE
operator|)
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|&&
operator|(
name|normalizep
operator|||
name|STORE_FLAG_VALUE
operator|==
literal|1
operator|||
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|&&
operator|(
operator|(
name|STORE_FLAG_VALUE
operator|&
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
operator|)
operator|==
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|-
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
block|{
name|subtarget
operator|=
name|target
expr_stmt|;
comment|/* If the result is to be wider than OP0, it is best to convert it 	 first.  If it is to be narrower, it is *incorrect* to convert it 	 first.  */
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|target_mode
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
condition|)
block|{
name|op0
operator|=
name|protect_from_queue
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op0
operator|=
name|convert_modes
argument_list|(
name|target_mode
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mode
operator|=
name|target_mode
expr_stmt|;
block|}
if|if
condition|(
name|target_mode
operator|!=
name|mode
condition|)
name|subtarget
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|GE
condition|)
name|op0
operator|=
name|expand_unop
argument_list|(
name|mode
argument_list|,
name|one_cmpl_optab
argument_list|,
name|op0
argument_list|,
operator|(
operator|(
name|STORE_FLAG_VALUE
operator|==
literal|1
operator|||
name|normalizep
operator|)
condition|?
literal|0
else|:
name|subtarget
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|STORE_FLAG_VALUE
operator|==
literal|1
operator|||
name|normalizep
condition|)
comment|/* If we are supposed to produce a 0/1 value, we want to do 	   a logical shift from the sign bit to the low-order bit; for 	   a -1/0 value, we do an arithmetic shift.  */
name|op0
operator|=
name|expand_shift
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|size_int
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|-
literal|1
argument_list|)
argument_list|,
name|subtarget
argument_list|,
name|normalizep
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|!=
name|target_mode
condition|)
name|op0
operator|=
name|convert_modes
argument_list|(
name|target_mode
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|op0
return|;
block|}
if|if
condition|(
name|icode
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
comment|/* We think we may be able to do this with a scc insn.  Emit the 	 comparison and then the scc insn.  	 compare_from_rtx may call emit_queue, which would be deleted below 	 if the scc insn fails.  So call it ourselves before setting LAST.  */
name|emit_queue
argument_list|()
expr_stmt|;
name|last
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
name|comparison
operator|=
name|compare_from_rtx
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|,
name|code
argument_list|,
name|unsignedp
argument_list|,
name|mode
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|comparison
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
operator|(
name|comparison
operator|==
name|const0_rtx
condition|?
name|const0_rtx
else|:
name|normalizep
operator|==
literal|1
condition|?
name|const1_rtx
else|:
name|normalizep
operator|==
operator|-
literal|1
condition|?
name|constm1_rtx
else|:
name|const_true_rtx
operator|)
return|;
comment|/* If the code of COMPARISON doesn't match CODE, something is 	 wrong; we can no longer be sure that we have the operation.   	 We could handle this case, but it should not happen.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|comparison
argument_list|)
operator|!=
name|code
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Get a reference to the target in the proper mode for this insn.  */
name|compare_mode
operator|=
name|insn_operand_mode
index|[
operator|(
name|int
operator|)
name|icode
index|]
index|[
literal|0
index|]
expr_stmt|;
name|subtarget
operator|=
name|target
expr_stmt|;
if|if
condition|(
name|preserve_subexpressions_p
argument_list|()
operator|||
operator|!
call|(
modifier|*
name|insn_operand_predicate
index|[
operator|(
name|int
operator|)
name|icode
index|]
index|[
literal|0
index|]
call|)
argument_list|(
name|subtarget
argument_list|,
name|compare_mode
argument_list|)
condition|)
name|subtarget
operator|=
name|gen_reg_rtx
argument_list|(
name|compare_mode
argument_list|)
expr_stmt|;
name|pattern
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|subtarget
argument_list|)
expr_stmt|;
if|if
condition|(
name|pattern
condition|)
block|{
name|emit_insn
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
comment|/* If we are converting to a wider mode, first convert to 	     TARGET_MODE, then normalize.  This produces better combining 	     opportunities on machines that have a SIGN_EXTRACT when we are 	     testing a single bit.  This mostly benefits the 68k.  	     If STORE_FLAG_VALUE does not have the sign bit set when 	     interpreted in COMPARE_MODE, we can do this conversion as 	     unsigned, which is usually more efficient.  */
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|target_mode
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|compare_mode
argument_list|)
condition|)
block|{
name|convert_move
argument_list|(
name|target
argument_list|,
name|subtarget
argument_list|,
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|compare_mode
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|)
operator|&&
literal|0
operator|==
operator|(
name|STORE_FLAG_VALUE
operator|&
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|compare_mode
argument_list|)
operator|-
literal|1
operator|)
operator|)
operator|)
argument_list|)
expr_stmt|;
name|op0
operator|=
name|target
expr_stmt|;
name|compare_mode
operator|=
name|target_mode
expr_stmt|;
block|}
else|else
name|op0
operator|=
name|subtarget
expr_stmt|;
comment|/* If we want to keep subexpressions around, don't reuse our 	     last target.  */
if|if
condition|(
name|preserve_subexpressions_p
argument_list|()
condition|)
name|subtarget
operator|=
literal|0
expr_stmt|;
comment|/* Now normalize to the proper value in COMPARE_MODE.  Sometimes 	     we don't have to do anything.  */
if|if
condition|(
name|normalizep
operator|==
literal|0
operator|||
name|normalizep
operator|==
name|STORE_FLAG_VALUE
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|normalizep
operator|==
operator|-
name|STORE_FLAG_VALUE
condition|)
name|op0
operator|=
name|expand_unop
argument_list|(
name|compare_mode
argument_list|,
name|neg_optab
argument_list|,
name|op0
argument_list|,
name|subtarget
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* We don't want to use STORE_FLAG_VALUE< 0 below since this 	     makes it hard to use a value of just the sign bit due to 	     ANSI integer constant typing rules.  */
elseif|else
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|compare_mode
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|&&
operator|(
name|STORE_FLAG_VALUE
operator|&
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|compare_mode
argument_list|)
operator|-
literal|1
operator|)
operator|)
operator|)
condition|)
name|op0
operator|=
name|expand_shift
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|compare_mode
argument_list|,
name|op0
argument_list|,
name|size_int
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|compare_mode
argument_list|)
operator|-
literal|1
argument_list|)
argument_list|,
name|subtarget
argument_list|,
name|normalizep
operator|==
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|STORE_FLAG_VALUE
operator|&
literal|1
condition|)
block|{
name|op0
operator|=
name|expand_and
argument_list|(
name|op0
argument_list|,
name|const1_rtx
argument_list|,
name|subtarget
argument_list|)
expr_stmt|;
if|if
condition|(
name|normalizep
operator|==
operator|-
literal|1
condition|)
name|op0
operator|=
name|expand_unop
argument_list|(
name|compare_mode
argument_list|,
name|neg_optab
argument_list|,
name|op0
argument_list|,
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
comment|/* If we were converting to a smaller mode, do the  	     conversion now.  */
if|if
condition|(
name|target_mode
operator|!=
name|compare_mode
condition|)
block|{
name|convert_move
argument_list|(
name|target
argument_list|,
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
else|else
return|return
name|op0
return|;
block|}
block|}
name|delete_insns_since
argument_list|(
name|last
argument_list|)
expr_stmt|;
comment|/* If expensive optimizations, use different pseudo registers for each      insn, instead of reusing the same pseudo.  This leads to better CSE,      but slows down the compiler, since there are more pseudos */
name|subtarget
operator|=
operator|(
operator|!
name|flag_expensive_optimizations
operator|&&
operator|(
name|target_mode
operator|==
name|mode
operator|)
operator|)
condition|?
name|target
else|:
name|NULL_RTX
expr_stmt|;
comment|/* If we reached here, we can't do this with a scc insn.  However, there      are some comparisons that can be done directly.  For example, if      this is an equality comparison of integers, we can try to exclusive-or      (or subtract) the two operands and use a recursive call to try the      comparison with zero.  Don't do any of these cases if branches are      very cheap.  */
if|if
condition|(
name|BRANCH_COST
operator|>
literal|0
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|&&
operator|(
name|code
operator|==
name|EQ
operator|||
name|code
operator|==
name|NE
operator|)
operator|&&
name|op1
operator|!=
name|const0_rtx
condition|)
block|{
name|tem
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|xor_optab
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|subtarget
argument_list|,
literal|1
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
operator|==
literal|0
condition|)
name|tem
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|sub_optab
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|subtarget
argument_list|,
literal|1
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
operator|!=
literal|0
condition|)
name|tem
operator|=
name|emit_store_flag
argument_list|(
name|target
argument_list|,
name|code
argument_list|,
name|tem
argument_list|,
name|const0_rtx
argument_list|,
name|mode
argument_list|,
name|unsignedp
argument_list|,
name|normalizep
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
operator|==
literal|0
condition|)
name|delete_insns_since
argument_list|(
name|last
argument_list|)
expr_stmt|;
return|return
name|tem
return|;
block|}
comment|/* Some other cases we can do are EQ, NE, LE, and GT comparisons with       the constant zero.  Reject all other comparisons at this point.  Only      do LE and GT if branches are expensive since they are expensive on      2-operand machines.  */
if|if
condition|(
name|BRANCH_COST
operator|==
literal|0
operator|||
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|!=
name|MODE_INT
operator|||
name|op1
operator|!=
name|const0_rtx
operator|||
operator|(
name|code
operator|!=
name|EQ
operator|&&
name|code
operator|!=
name|NE
operator|&&
operator|(
name|BRANCH_COST
operator|<=
literal|1
operator|||
operator|(
name|code
operator|!=
name|LE
operator|&&
name|code
operator|!=
name|GT
operator|)
operator|)
operator|)
condition|)
return|return
literal|0
return|;
comment|/* See what we need to return.  We can only return a 1, -1, or the      sign bit.  */
if|if
condition|(
name|normalizep
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|STORE_FLAG_VALUE
operator|==
literal|1
operator|||
name|STORE_FLAG_VALUE
operator|==
operator|-
literal|1
condition|)
name|normalizep
operator|=
name|STORE_FLAG_VALUE
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|&&
operator|(
operator|(
name|STORE_FLAG_VALUE
operator|&
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
operator|)
operator|==
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|-
literal|1
operator|)
operator|)
condition|)
empty_stmt|;
else|else
return|return
literal|0
return|;
block|}
comment|/* Try to put the result of the comparison in the sign bit.  Assume we can't      do the necessary operation below.  */
name|tem
operator|=
literal|0
expr_stmt|;
comment|/* To see if A<= 0, compute (A | (A - 1)).  A<= 0 iff that result has      the sign bit set.  */
if|if
condition|(
name|code
operator|==
name|LE
condition|)
block|{
comment|/* This is destructive, so SUBTARGET can't be OP0.  */
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|subtarget
argument_list|,
name|op0
argument_list|)
condition|)
name|subtarget
operator|=
literal|0
expr_stmt|;
name|tem
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|sub_optab
argument_list|,
name|op0
argument_list|,
name|const1_rtx
argument_list|,
name|subtarget
argument_list|,
literal|0
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
condition|)
name|tem
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|ior_optab
argument_list|,
name|op0
argument_list|,
name|tem
argument_list|,
name|subtarget
argument_list|,
literal|0
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
block|}
comment|/* To see if A> 0, compute (((signed) A)<< BITS) - A, where BITS is the      number of bits in the mode of OP0, minus one.  */
if|if
condition|(
name|code
operator|==
name|GT
condition|)
block|{
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|subtarget
argument_list|,
name|op0
argument_list|)
condition|)
name|subtarget
operator|=
literal|0
expr_stmt|;
name|tem
operator|=
name|expand_shift
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|size_int
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|-
literal|1
argument_list|)
argument_list|,
name|subtarget
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tem
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|sub_optab
argument_list|,
name|tem
argument_list|,
name|op0
argument_list|,
name|subtarget
argument_list|,
literal|0
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|code
operator|==
name|EQ
operator|||
name|code
operator|==
name|NE
condition|)
block|{
comment|/* For EQ or NE, one way to do the comparison is to apply an operation 	 that converts the operand into a positive number if it is non-zero 	 or zero if it was originally zero.  Then, for EQ, we subtract 1 and 	 for NE we negate.  This puts the result in the sign bit.  Then we 	 normalize with a shift, if needed.   	 Two operations that can do the above actions are ABS and FFS, so try 	 them.  If that doesn't work, and MODE is smaller than a full word, 	 we can use zero-extension to the wider mode (an unsigned conversion) 	 as the operation.  */
if|if
condition|(
name|abs_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
condition|)
name|tem
operator|=
name|expand_unop
argument_list|(
name|mode
argument_list|,
name|abs_optab
argument_list|,
name|op0
argument_list|,
name|subtarget
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ffs_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
condition|)
name|tem
operator|=
name|expand_unop
argument_list|(
name|mode
argument_list|,
name|ffs_optab
argument_list|,
name|op0
argument_list|,
name|subtarget
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|<
name|UNITS_PER_WORD
condition|)
block|{
name|op0
operator|=
name|protect_from_queue
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tem
operator|=
name|convert_modes
argument_list|(
name|word_mode
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|mode
operator|=
name|word_mode
expr_stmt|;
block|}
if|if
condition|(
name|tem
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|code
operator|==
name|EQ
condition|)
name|tem
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|sub_optab
argument_list|,
name|tem
argument_list|,
name|const1_rtx
argument_list|,
name|subtarget
argument_list|,
literal|0
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
else|else
name|tem
operator|=
name|expand_unop
argument_list|(
name|mode
argument_list|,
name|neg_optab
argument_list|,
name|tem
argument_list|,
name|subtarget
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* If we couldn't do it that way, for NE we can "or" the two's complement 	 of the value with itself.  For EQ, we take the one's complement of 	 that "or", which is an extra insn, so we only handle EQ if branches 	 are expensive.  */
if|if
condition|(
name|tem
operator|==
literal|0
operator|&&
operator|(
name|code
operator|==
name|NE
operator|||
name|BRANCH_COST
operator|>
literal|1
operator|)
condition|)
block|{
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|subtarget
argument_list|,
name|op0
argument_list|)
condition|)
name|subtarget
operator|=
literal|0
expr_stmt|;
name|tem
operator|=
name|expand_unop
argument_list|(
name|mode
argument_list|,
name|neg_optab
argument_list|,
name|op0
argument_list|,
name|subtarget
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tem
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|ior_optab
argument_list|,
name|tem
argument_list|,
name|op0
argument_list|,
name|subtarget
argument_list|,
literal|0
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
operator|&&
name|code
operator|==
name|EQ
condition|)
name|tem
operator|=
name|expand_unop
argument_list|(
name|mode
argument_list|,
name|one_cmpl_optab
argument_list|,
name|tem
argument_list|,
name|subtarget
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|tem
operator|&&
name|normalizep
condition|)
name|tem
operator|=
name|expand_shift
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|mode
argument_list|,
name|tem
argument_list|,
name|size_int
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|-
literal|1
argument_list|)
argument_list|,
name|subtarget
argument_list|,
name|normalizep
operator|==
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
condition|)
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|tem
argument_list|)
operator|!=
name|target_mode
condition|)
block|{
name|convert_move
argument_list|(
name|target
argument_list|,
name|tem
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tem
operator|=
name|target
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|subtarget
condition|)
block|{
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|tem
argument_list|)
expr_stmt|;
name|tem
operator|=
name|target
expr_stmt|;
block|}
block|}
else|else
name|delete_insns_since
argument_list|(
name|last
argument_list|)
expr_stmt|;
return|return
name|tem
return|;
block|}
end_function

begin_comment
comment|/* Like emit_store_flag, but always succeeds.  */
end_comment

begin_function
name|rtx
name|emit_store_flag_force
parameter_list|(
name|target
parameter_list|,
name|code
parameter_list|,
name|op0
parameter_list|,
name|op1
parameter_list|,
name|mode
parameter_list|,
name|unsignedp
parameter_list|,
name|normalizep
parameter_list|)
name|rtx
name|target
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
name|int
name|normalizep
decl_stmt|;
block|{
name|rtx
name|tem
decl_stmt|,
name|label
decl_stmt|;
comment|/* First see if emit_store_flag can do the job.  */
name|tem
operator|=
name|emit_store_flag
argument_list|(
name|target
argument_list|,
name|code
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|mode
argument_list|,
name|unsignedp
argument_list|,
name|normalizep
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
operator|!=
literal|0
condition|)
return|return
name|tem
return|;
if|if
condition|(
name|normalizep
operator|==
literal|0
condition|)
name|normalizep
operator|=
literal|1
expr_stmt|;
comment|/* If this failed, we have to do this with set/compare/jump/set code.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|!=
name|REG
operator|||
name|reg_mentioned_p
argument_list|(
name|target
argument_list|,
name|op0
argument_list|)
operator|||
name|reg_mentioned_p
argument_list|(
name|target
argument_list|,
name|op1
argument_list|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|const1_rtx
argument_list|)
expr_stmt|;
name|tem
operator|=
name|compare_from_rtx
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|,
name|code
argument_list|,
name|unsignedp
argument_list|,
name|mode
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|tem
return|;
name|label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
if|if
condition|(
name|bcc_gen_fctn
index|[
operator|(
name|int
operator|)
name|code
index|]
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|emit_jump_insn
argument_list|(
call|(
modifier|*
name|bcc_gen_fctn
index|[
operator|(
name|int
operator|)
name|code
index|]
call|)
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Perform possibly multi-word comparison and conditional jump to LABEL    if ARG1 OP ARG2 true where ARG1 and ARG2 are of mode MODE     The algorithm is based on the code in expr.c:do_jump.     Note that this does not perform a general comparison.  Only variants    generated within expmed.c are correctly handled, others abort (but could    be handled if needed).  */
end_comment

begin_function
specifier|static
name|void
name|do_cmp_and_jump
parameter_list|(
name|arg1
parameter_list|,
name|arg2
parameter_list|,
name|op
parameter_list|,
name|mode
parameter_list|,
name|label
parameter_list|)
name|rtx
name|arg1
decl_stmt|,
name|arg2
decl_stmt|,
name|label
decl_stmt|;
name|enum
name|rtx_code
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
comment|/* If this mode is an integer too wide to compare properly,      compare word by word.  Rely on cse to optimize constant cases.  */
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|&&
operator|!
name|can_compare_p
argument_list|(
name|mode
argument_list|)
condition|)
block|{
name|rtx
name|label2
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|LTU
case|:
name|do_jump_by_parts_greater_rtx
argument_list|(
name|mode
argument_list|,
literal|1
argument_list|,
name|arg2
argument_list|,
name|arg1
argument_list|,
name|label2
argument_list|,
name|label
argument_list|)
expr_stmt|;
break|break;
case|case
name|LEU
case|:
name|do_jump_by_parts_greater_rtx
argument_list|(
name|mode
argument_list|,
literal|1
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
name|label
argument_list|,
name|label2
argument_list|)
expr_stmt|;
break|break;
case|case
name|LT
case|:
name|do_jump_by_parts_greater_rtx
argument_list|(
name|mode
argument_list|,
literal|0
argument_list|,
name|arg2
argument_list|,
name|arg1
argument_list|,
name|label2
argument_list|,
name|label
argument_list|)
expr_stmt|;
break|break;
case|case
name|GT
case|:
name|do_jump_by_parts_greater_rtx
argument_list|(
name|mode
argument_list|,
literal|0
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
name|label2
argument_list|,
name|label
argument_list|)
expr_stmt|;
break|break;
case|case
name|GE
case|:
name|do_jump_by_parts_greater_rtx
argument_list|(
name|mode
argument_list|,
literal|0
argument_list|,
name|arg2
argument_list|,
name|arg1
argument_list|,
name|label
argument_list|,
name|label2
argument_list|)
expr_stmt|;
break|break;
comment|/* do_jump_by_parts_equality_rtx compares with zero.  Luckily 	     that's the only equality operations we do */
case|case
name|EQ
case|:
if|if
condition|(
name|arg2
operator|!=
name|const0_rtx
operator|||
name|mode
operator|!=
name|GET_MODE
argument_list|(
name|arg1
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|do_jump_by_parts_equality_rtx
argument_list|(
name|arg1
argument_list|,
name|label2
argument_list|,
name|label
argument_list|)
expr_stmt|;
break|break;
case|case
name|NE
case|:
if|if
condition|(
name|arg2
operator|!=
name|const0_rtx
operator|||
name|mode
operator|!=
name|GET_MODE
argument_list|(
name|arg1
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|do_jump_by_parts_equality_rtx
argument_list|(
name|arg1
argument_list|,
name|label
argument_list|,
name|label2
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|emit_label
argument_list|(
name|label2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|emit_cmp_insn
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|,
name|op
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|bcc_gen_fctn
index|[
operator|(
name|int
operator|)
name|op
index|]
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|emit_jump_insn
argument_list|(
call|(
modifier|*
name|bcc_gen_fctn
index|[
operator|(
name|int
operator|)
name|op
index|]
call|)
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

