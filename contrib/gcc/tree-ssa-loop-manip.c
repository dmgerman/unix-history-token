begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* High-level loop manipulation functions.    Copyright (C) 2004, 2005, 2006, 2007 Free Software Foundation, Inc.     This file is part of GCC.     GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.     GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.     You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_include
include|#
directive|include
file|"tree-flow.h"
end_include

begin_include
include|#
directive|include
file|"tree-dump.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"cfgloop.h"
end_include

begin_include
include|#
directive|include
file|"tree-pass.h"
end_include

begin_include
include|#
directive|include
file|"cfglayout.h"
end_include

begin_include
include|#
directive|include
file|"tree-scalar-evolution.h"
end_include

begin_include
include|#
directive|include
file|"params.h"
end_include

begin_comment
comment|/* Creates an induction variable with value BASE + STEP * iteration in LOOP.    It is expected that neither BASE nor STEP are shared with other expressions    (unless the sharing rules allow this).  Use VAR as a base var_decl for it    (if NULL, a new temporary will be created).  The increment will occur at    INCR_POS (after it if AFTER is true, before it otherwise).  INCR_POS and     AFTER can be computed using standard_iv_increment_position.  The ssa versions    of the variable before and after increment will be stored in VAR_BEFORE and    VAR_AFTER (unless they are NULL).  */
end_comment

begin_function
name|void
name|create_iv
parameter_list|(
name|tree
name|base
parameter_list|,
name|tree
name|step
parameter_list|,
name|tree
name|var
parameter_list|,
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|block_stmt_iterator
modifier|*
name|incr_pos
parameter_list|,
name|bool
name|after
parameter_list|,
name|tree
modifier|*
name|var_before
parameter_list|,
name|tree
modifier|*
name|var_after
parameter_list|)
block|{
name|tree
name|stmt
decl_stmt|,
name|initial
decl_stmt|,
name|step1
decl_stmt|,
name|stmts
decl_stmt|;
name|tree
name|vb
decl_stmt|,
name|va
decl_stmt|;
name|enum
name|tree_code
name|incr_op
init|=
name|PLUS_EXPR
decl_stmt|;
name|edge
name|pe
init|=
name|loop_preheader_edge
argument_list|(
name|loop
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|var
condition|)
block|{
name|var
operator|=
name|create_tmp_var
argument_list|(
name|TREE_TYPE
argument_list|(
name|base
argument_list|)
argument_list|,
literal|"ivtmp"
argument_list|)
expr_stmt|;
name|add_referenced_var
argument_list|(
name|var
argument_list|)
expr_stmt|;
block|}
name|vb
operator|=
name|make_ssa_name
argument_list|(
name|var
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|var_before
condition|)
operator|*
name|var_before
operator|=
name|vb
expr_stmt|;
name|va
operator|=
name|make_ssa_name
argument_list|(
name|var
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|var_after
condition|)
operator|*
name|var_after
operator|=
name|va
expr_stmt|;
comment|/* For easier readability of the created code, produce MINUS_EXPRs      when suitable.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|step
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
if|if
condition|(
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|step
argument_list|)
argument_list|)
condition|)
block|{
name|step1
operator|=
name|fold_build1
argument_list|(
name|NEGATE_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|step
argument_list|)
argument_list|,
name|step
argument_list|)
expr_stmt|;
if|if
condition|(
name|tree_int_cst_lt
argument_list|(
name|step1
argument_list|,
name|step
argument_list|)
condition|)
block|{
name|incr_op
operator|=
name|MINUS_EXPR
expr_stmt|;
name|step
operator|=
name|step1
expr_stmt|;
block|}
block|}
else|else
block|{
name|bool
name|ovf
decl_stmt|;
if|if
condition|(
operator|!
name|tree_expr_nonnegative_warnv_p
argument_list|(
name|step
argument_list|,
operator|&
name|ovf
argument_list|)
operator|&&
name|may_negate_without_overflow_p
argument_list|(
name|step
argument_list|)
condition|)
block|{
name|incr_op
operator|=
name|MINUS_EXPR
expr_stmt|;
name|step
operator|=
name|fold_build1
argument_list|(
name|NEGATE_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|step
argument_list|)
argument_list|,
name|step
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Gimplify the step if necessary.  We put the computations in front of the      loop (i.e. the step should be loop invariant).  */
name|step
operator|=
name|force_gimple_operand
argument_list|(
name|step
argument_list|,
operator|&
name|stmts
argument_list|,
name|true
argument_list|,
name|var
argument_list|)
expr_stmt|;
if|if
condition|(
name|stmts
condition|)
name|bsi_insert_on_edge_immediate_loop
argument_list|(
name|pe
argument_list|,
name|stmts
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|va
argument_list|,
name|build2
argument_list|(
name|incr_op
argument_list|,
name|TREE_TYPE
argument_list|(
name|base
argument_list|)
argument_list|,
name|vb
argument_list|,
name|step
argument_list|)
argument_list|)
expr_stmt|;
name|SSA_NAME_DEF_STMT
argument_list|(
name|va
argument_list|)
operator|=
name|stmt
expr_stmt|;
if|if
condition|(
name|after
condition|)
name|bsi_insert_after
argument_list|(
name|incr_pos
argument_list|,
name|stmt
argument_list|,
name|BSI_NEW_STMT
argument_list|)
expr_stmt|;
else|else
name|bsi_insert_before
argument_list|(
name|incr_pos
argument_list|,
name|stmt
argument_list|,
name|BSI_NEW_STMT
argument_list|)
expr_stmt|;
name|initial
operator|=
name|force_gimple_operand
argument_list|(
name|base
argument_list|,
operator|&
name|stmts
argument_list|,
name|true
argument_list|,
name|var
argument_list|)
expr_stmt|;
if|if
condition|(
name|stmts
condition|)
name|bsi_insert_on_edge_immediate_loop
argument_list|(
name|pe
argument_list|,
name|stmts
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|create_phi_node
argument_list|(
name|vb
argument_list|,
name|loop
operator|->
name|header
argument_list|)
expr_stmt|;
name|SSA_NAME_DEF_STMT
argument_list|(
name|vb
argument_list|)
operator|=
name|stmt
expr_stmt|;
name|add_phi_arg
argument_list|(
name|stmt
argument_list|,
name|initial
argument_list|,
name|loop_preheader_edge
argument_list|(
name|loop
argument_list|)
argument_list|)
expr_stmt|;
name|add_phi_arg
argument_list|(
name|stmt
argument_list|,
name|va
argument_list|,
name|loop_latch_edge
argument_list|(
name|loop
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add exit phis for the USE on EXIT.  */
end_comment

begin_function
specifier|static
name|void
name|add_exit_phis_edge
parameter_list|(
name|basic_block
name|exit
parameter_list|,
name|tree
name|use
parameter_list|)
block|{
name|tree
name|phi
decl_stmt|,
name|def_stmt
init|=
name|SSA_NAME_DEF_STMT
argument_list|(
name|use
argument_list|)
decl_stmt|;
name|basic_block
name|def_bb
init|=
name|bb_for_stmt
argument_list|(
name|def_stmt
argument_list|)
decl_stmt|;
name|struct
name|loop
modifier|*
name|def_loop
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
comment|/* Check that some of the edges entering the EXIT block exits a loop in      that USE is defined.  */
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|exit->preds
argument_list|)
block|{
name|def_loop
operator|=
name|find_common_loop
argument_list|(
name|def_bb
operator|->
name|loop_father
argument_list|,
name|e
operator|->
name|src
operator|->
name|loop_father
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|flow_bb_inside_loop_p
argument_list|(
name|def_loop
argument_list|,
name|e
operator|->
name|dest
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|e
condition|)
return|return;
name|phi
operator|=
name|create_phi_node
argument_list|(
name|use
argument_list|,
name|exit
argument_list|)
expr_stmt|;
name|create_new_def_for
argument_list|(
name|PHI_RESULT
argument_list|(
name|phi
argument_list|)
argument_list|,
name|phi
argument_list|,
name|PHI_RESULT_PTR
argument_list|(
name|phi
argument_list|)
argument_list|)
expr_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|exit->preds
argument_list|)
name|add_phi_arg
argument_list|(
name|phi
argument_list|,
name|use
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add exit phis for VAR that is used in LIVEIN.    Exits of the loops are stored in EXITS.  */
end_comment

begin_function
specifier|static
name|void
name|add_exit_phis_var
parameter_list|(
name|tree
name|var
parameter_list|,
name|bitmap
name|livein
parameter_list|,
name|bitmap
name|exits
parameter_list|)
block|{
name|bitmap
name|def
decl_stmt|;
name|unsigned
name|index
decl_stmt|;
name|basic_block
name|def_bb
init|=
name|bb_for_stmt
argument_list|(
name|SSA_NAME_DEF_STMT
argument_list|(
name|var
argument_list|)
argument_list|)
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
if|if
condition|(
name|is_gimple_reg
argument_list|(
name|var
argument_list|)
condition|)
name|bitmap_clear_bit
argument_list|(
name|livein
argument_list|,
name|def_bb
operator|->
name|index
argument_list|)
expr_stmt|;
else|else
name|bitmap_set_bit
argument_list|(
name|livein
argument_list|,
name|def_bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|def
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|bitmap_set_bit
argument_list|(
name|def
argument_list|,
name|def_bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|compute_global_livein
argument_list|(
name|livein
argument_list|,
name|def
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|def
argument_list|)
expr_stmt|;
name|EXECUTE_IF_AND_IN_BITMAP
argument_list|(
argument|exits
argument_list|,
argument|livein
argument_list|,
literal|0
argument_list|,
argument|index
argument_list|,
argument|bi
argument_list|)
block|{
name|add_exit_phis_edge
argument_list|(
name|BASIC_BLOCK
argument_list|(
name|index
argument_list|)
argument_list|,
name|var
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Add exit phis for the names marked in NAMES_TO_RENAME.    Exits of the loops are stored in EXITS.  Sets of blocks where the ssa    names are used are stored in USE_BLOCKS.  */
end_comment

begin_function
specifier|static
name|void
name|add_exit_phis
parameter_list|(
name|bitmap
name|names_to_rename
parameter_list|,
name|bitmap
modifier|*
name|use_blocks
parameter_list|,
name|bitmap
name|loop_exits
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|names_to_rename
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|bi
argument_list|)
block|{
name|add_exit_phis_var
argument_list|(
name|ssa_name
argument_list|(
name|i
argument_list|)
argument_list|,
name|use_blocks
index|[
name|i
index|]
argument_list|,
name|loop_exits
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Returns a bitmap of all loop exit edge targets.  */
end_comment

begin_function
specifier|static
name|bitmap
name|get_loops_exits
parameter_list|(
name|void
parameter_list|)
block|{
name|bitmap
name|exits
init|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->preds
argument_list|)
if|if
condition|(
name|e
operator|->
name|src
operator|!=
name|ENTRY_BLOCK_PTR
operator|&&
operator|!
name|flow_bb_inside_loop_p
argument_list|(
name|e
operator|->
name|src
operator|->
name|loop_father
argument_list|,
name|bb
argument_list|)
condition|)
block|{
name|bitmap_set_bit
argument_list|(
name|exits
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
name|exits
return|;
block|}
end_function

begin_comment
comment|/* For USE in BB, if it is used outside of the loop it is defined in,    mark it for rewrite.  Record basic block BB where it is used    to USE_BLOCKS.  Record the ssa name index to NEED_PHIS bitmap.  */
end_comment

begin_function
specifier|static
name|void
name|find_uses_to_rename_use
parameter_list|(
name|basic_block
name|bb
parameter_list|,
name|tree
name|use
parameter_list|,
name|bitmap
modifier|*
name|use_blocks
parameter_list|,
name|bitmap
name|need_phis
parameter_list|)
block|{
name|unsigned
name|ver
decl_stmt|;
name|basic_block
name|def_bb
decl_stmt|;
name|struct
name|loop
modifier|*
name|def_loop
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|use
argument_list|)
operator|!=
name|SSA_NAME
condition|)
return|return;
comment|/* We don't need to keep virtual operands in loop-closed form.  */
if|if
condition|(
operator|!
name|is_gimple_reg
argument_list|(
name|use
argument_list|)
condition|)
return|return;
name|ver
operator|=
name|SSA_NAME_VERSION
argument_list|(
name|use
argument_list|)
expr_stmt|;
name|def_bb
operator|=
name|bb_for_stmt
argument_list|(
name|SSA_NAME_DEF_STMT
argument_list|(
name|use
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|def_bb
condition|)
return|return;
name|def_loop
operator|=
name|def_bb
operator|->
name|loop_father
expr_stmt|;
comment|/* If the definition is not inside loop, it is not interesting.  */
if|if
condition|(
operator|!
name|def_loop
operator|->
name|outer
condition|)
return|return;
if|if
condition|(
operator|!
name|use_blocks
index|[
name|ver
index|]
condition|)
name|use_blocks
index|[
name|ver
index|]
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|bitmap_set_bit
argument_list|(
name|use_blocks
index|[
name|ver
index|]
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|bitmap_set_bit
argument_list|(
name|need_phis
argument_list|,
name|ver
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* For uses in STMT, mark names that are used outside of the loop they are    defined to rewrite.  Record the set of blocks in that the ssa    names are defined to USE_BLOCKS and the ssa names themselves to    NEED_PHIS.  */
end_comment

begin_function
specifier|static
name|void
name|find_uses_to_rename_stmt
parameter_list|(
name|tree
name|stmt
parameter_list|,
name|bitmap
modifier|*
name|use_blocks
parameter_list|,
name|bitmap
name|need_phis
parameter_list|)
block|{
name|ssa_op_iter
name|iter
decl_stmt|;
name|tree
name|var
decl_stmt|;
name|basic_block
name|bb
init|=
name|bb_for_stmt
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
name|FOR_EACH_SSA_TREE_OPERAND
argument_list|(
argument|var
argument_list|,
argument|stmt
argument_list|,
argument|iter
argument_list|,
argument|SSA_OP_ALL_USES | SSA_OP_ALL_KILLS
argument_list|)
name|find_uses_to_rename_use
argument_list|(
name|bb
argument_list|,
name|var
argument_list|,
name|use_blocks
argument_list|,
name|need_phis
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Marks names that are used in BB and outside of the loop they are    defined in for rewrite.  Records the set of blocks in that the ssa    names are defined to USE_BLOCKS.  Record the SSA names that will    need exit PHIs in NEED_PHIS.  */
end_comment

begin_function
specifier|static
name|void
name|find_uses_to_rename_bb
parameter_list|(
name|basic_block
name|bb
parameter_list|,
name|bitmap
modifier|*
name|use_blocks
parameter_list|,
name|bitmap
name|need_phis
parameter_list|)
block|{
name|block_stmt_iterator
name|bsi
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|tree
name|phi
decl_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
for|for
control|(
name|phi
operator|=
name|phi_nodes
argument_list|(
name|e
operator|->
name|dest
argument_list|)
init|;
name|phi
condition|;
name|phi
operator|=
name|PHI_CHAIN
argument_list|(
name|phi
argument_list|)
control|)
name|find_uses_to_rename_use
argument_list|(
name|bb
argument_list|,
name|PHI_ARG_DEF_FROM_EDGE
argument_list|(
name|phi
argument_list|,
name|e
argument_list|)
argument_list|,
name|use_blocks
argument_list|,
name|need_phis
argument_list|)
expr_stmt|;
for|for
control|(
name|bsi
operator|=
name|bsi_start
argument_list|(
name|bb
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|;
name|bsi_next
argument_list|(
operator|&
name|bsi
argument_list|)
control|)
name|find_uses_to_rename_stmt
argument_list|(
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
argument_list|,
name|use_blocks
argument_list|,
name|need_phis
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Marks names that are used outside of the loop they are defined in    for rewrite.  Records the set of blocks in that the ssa    names are defined to USE_BLOCKS.  If CHANGED_BBS is not NULL,    scan only blocks in this set.  */
end_comment

begin_function
specifier|static
name|void
name|find_uses_to_rename
parameter_list|(
name|bitmap
name|changed_bbs
parameter_list|,
name|bitmap
modifier|*
name|use_blocks
parameter_list|,
name|bitmap
name|need_phis
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|unsigned
name|index
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
if|if
condition|(
name|changed_bbs
operator|&&
operator|!
name|bitmap_empty_p
argument_list|(
name|changed_bbs
argument_list|)
condition|)
block|{
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|changed_bbs
argument_list|,
literal|0
argument_list|,
argument|index
argument_list|,
argument|bi
argument_list|)
block|{
name|find_uses_to_rename_bb
argument_list|(
name|BASIC_BLOCK
argument_list|(
name|index
argument_list|)
argument_list|,
name|use_blocks
argument_list|,
name|need_phis
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|find_uses_to_rename_bb
argument_list|(
name|bb
argument_list|,
name|use_blocks
argument_list|,
name|need_phis
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Rewrites the program into a loop closed ssa form -- i.e. inserts extra    phi nodes to ensure that no variable is used outside the loop it is    defined in.     This strengthening of the basic ssa form has several advantages:     1) Updating it during unrolling/peeling/versioning is trivial, since       we do not need to care about the uses outside of the loop.    2) The behavior of all uses of an induction variable is the same.       Without this, you need to distinguish the case when the variable       is used outside of the loop it is defined in, for example        for (i = 0; i< 100; i++) 	{ 	  for (j = 0; j< 100; j++) 	    { 	      k = i + j; 	      use1 (k); 	    } 	  use2 (k); 	}        Looking from the outer loop with the normal SSA form, the first use of k       is not well-behaved, while the second one is an induction variable with       base 99 and step 1.              If CHANGED_BBS is not NULL, we look for uses outside loops only in       the basic blocks in this set.        UPDATE_FLAG is used in the call to update_ssa.  See       TODO_update_ssa* for documentation.  */
end_comment

begin_function
name|void
name|rewrite_into_loop_closed_ssa
parameter_list|(
name|bitmap
name|changed_bbs
parameter_list|,
name|unsigned
name|update_flag
parameter_list|)
block|{
name|bitmap
name|loop_exits
init|=
name|get_loops_exits
argument_list|()
decl_stmt|;
name|bitmap
modifier|*
name|use_blocks
decl_stmt|;
name|unsigned
name|i
decl_stmt|,
name|old_num_ssa_names
decl_stmt|;
name|bitmap
name|names_to_rename
init|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
comment|/* If the pass has caused the SSA form to be out-of-date, update it      now.  */
name|update_ssa
argument_list|(
name|update_flag
argument_list|)
expr_stmt|;
name|old_num_ssa_names
operator|=
name|num_ssa_names
expr_stmt|;
name|use_blocks
operator|=
name|XCNEWVEC
argument_list|(
name|bitmap
argument_list|,
name|old_num_ssa_names
argument_list|)
expr_stmt|;
comment|/* Find the uses outside loops.  */
name|find_uses_to_rename
argument_list|(
name|changed_bbs
argument_list|,
name|use_blocks
argument_list|,
name|names_to_rename
argument_list|)
expr_stmt|;
comment|/* Add the PHI nodes on exits of the loops for the names we need to      rewrite.  */
name|add_exit_phis
argument_list|(
name|names_to_rename
argument_list|,
name|use_blocks
argument_list|,
name|loop_exits
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|old_num_ssa_names
condition|;
name|i
operator|++
control|)
name|BITMAP_FREE
argument_list|(
name|use_blocks
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|use_blocks
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|loop_exits
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|names_to_rename
argument_list|)
expr_stmt|;
comment|/* Fix up all the names found to be used outside their original      loops.  */
name|update_ssa
argument_list|(
name|TODO_update_ssa
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Check invariants of the loop closed ssa form for the USE in BB.  */
end_comment

begin_function
specifier|static
name|void
name|check_loop_closed_ssa_use
parameter_list|(
name|basic_block
name|bb
parameter_list|,
name|tree
name|use
parameter_list|)
block|{
name|tree
name|def
decl_stmt|;
name|basic_block
name|def_bb
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|use
argument_list|)
operator|!=
name|SSA_NAME
operator|||
operator|!
name|is_gimple_reg
argument_list|(
name|use
argument_list|)
condition|)
return|return;
name|def
operator|=
name|SSA_NAME_DEF_STMT
argument_list|(
name|use
argument_list|)
expr_stmt|;
name|def_bb
operator|=
name|bb_for_stmt
argument_list|(
name|def
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|def_bb
operator|||
name|flow_bb_inside_loop_p
argument_list|(
name|def_bb
operator|->
name|loop_father
argument_list|,
name|bb
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Checks invariants of loop closed ssa form in statement STMT in BB.  */
end_comment

begin_function
specifier|static
name|void
name|check_loop_closed_ssa_stmt
parameter_list|(
name|basic_block
name|bb
parameter_list|,
name|tree
name|stmt
parameter_list|)
block|{
name|ssa_op_iter
name|iter
decl_stmt|;
name|tree
name|var
decl_stmt|;
name|FOR_EACH_SSA_TREE_OPERAND
argument_list|(
argument|var
argument_list|,
argument|stmt
argument_list|,
argument|iter
argument_list|,
argument|SSA_OP_ALL_USES | SSA_OP_ALL_KILLS
argument_list|)
name|check_loop_closed_ssa_use
argument_list|(
name|bb
argument_list|,
name|var
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Checks that invariants of the loop closed ssa form are preserved.  */
end_comment

begin_function
name|void
name|verify_loop_closed_ssa
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|block_stmt_iterator
name|bsi
decl_stmt|;
name|tree
name|phi
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
if|if
condition|(
name|current_loops
operator|==
name|NULL
condition|)
return|return;
name|verify_ssa
argument_list|(
name|false
argument_list|)
expr_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
for|for
control|(
name|phi
operator|=
name|phi_nodes
argument_list|(
name|bb
argument_list|)
init|;
name|phi
condition|;
name|phi
operator|=
name|PHI_CHAIN
argument_list|(
name|phi
argument_list|)
control|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|unsigned
operator|)
name|PHI_NUM_ARGS
argument_list|(
name|phi
argument_list|)
condition|;
name|i
operator|++
control|)
name|check_loop_closed_ssa_use
argument_list|(
name|PHI_ARG_EDGE
argument_list|(
name|phi
argument_list|,
name|i
argument_list|)
operator|->
name|src
argument_list|,
name|PHI_ARG_DEF
argument_list|(
name|phi
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|bsi
operator|=
name|bsi_start
argument_list|(
name|bb
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|;
name|bsi_next
argument_list|(
operator|&
name|bsi
argument_list|)
control|)
name|check_loop_closed_ssa_stmt
argument_list|(
name|bb
argument_list|,
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Split loop exit edge EXIT.  The things are a bit complicated by a need to    preserve the loop closed ssa form.  */
end_comment

begin_function
name|void
name|split_loop_exit_edge
parameter_list|(
name|edge
name|exit
parameter_list|)
block|{
name|basic_block
name|dest
init|=
name|exit
operator|->
name|dest
decl_stmt|;
name|basic_block
name|bb
init|=
name|loop_split_edge_with
argument_list|(
name|exit
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|tree
name|phi
decl_stmt|,
name|new_phi
decl_stmt|,
name|new_name
decl_stmt|,
name|name
decl_stmt|;
name|use_operand_p
name|op_p
decl_stmt|;
for|for
control|(
name|phi
operator|=
name|phi_nodes
argument_list|(
name|dest
argument_list|)
init|;
name|phi
condition|;
name|phi
operator|=
name|PHI_CHAIN
argument_list|(
name|phi
argument_list|)
control|)
block|{
name|op_p
operator|=
name|PHI_ARG_DEF_PTR_FROM_EDGE
argument_list|(
name|phi
argument_list|,
name|single_succ_edge
argument_list|(
name|bb
argument_list|)
argument_list|)
expr_stmt|;
name|name
operator|=
name|USE_FROM_PTR
argument_list|(
name|op_p
argument_list|)
expr_stmt|;
comment|/* If the argument of the phi node is a constant, we do not need 	 to keep it inside loop.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|!=
name|SSA_NAME
condition|)
continue|continue;
comment|/* Otherwise create an auxiliary phi node that will copy the value 	 of the ssa name out of the loop.  */
name|new_name
operator|=
name|duplicate_ssa_name
argument_list|(
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|new_phi
operator|=
name|create_phi_node
argument_list|(
name|new_name
argument_list|,
name|bb
argument_list|)
expr_stmt|;
name|SSA_NAME_DEF_STMT
argument_list|(
name|new_name
argument_list|)
operator|=
name|new_phi
expr_stmt|;
name|add_phi_arg
argument_list|(
name|new_phi
argument_list|,
name|name
argument_list|,
name|exit
argument_list|)
expr_stmt|;
name|SET_USE
argument_list|(
name|op_p
argument_list|,
name|new_name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Insert statement STMT to the edge E and update the loop structures.    Returns the newly created block (if any).  */
end_comment

begin_function
name|basic_block
name|bsi_insert_on_edge_immediate_loop
parameter_list|(
name|edge
name|e
parameter_list|,
name|tree
name|stmt
parameter_list|)
block|{
name|basic_block
name|src
decl_stmt|,
name|dest
decl_stmt|,
name|new_bb
decl_stmt|;
name|struct
name|loop
modifier|*
name|loop_c
decl_stmt|;
name|src
operator|=
name|e
operator|->
name|src
expr_stmt|;
name|dest
operator|=
name|e
operator|->
name|dest
expr_stmt|;
name|loop_c
operator|=
name|find_common_loop
argument_list|(
name|src
operator|->
name|loop_father
argument_list|,
name|dest
operator|->
name|loop_father
argument_list|)
expr_stmt|;
name|new_bb
operator|=
name|bsi_insert_on_edge_immediate
argument_list|(
name|e
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|new_bb
condition|)
return|return
name|NULL
return|;
name|add_bb_to_loop
argument_list|(
name|new_bb
argument_list|,
name|loop_c
argument_list|)
expr_stmt|;
if|if
condition|(
name|dest
operator|->
name|loop_father
operator|->
name|latch
operator|==
name|src
condition|)
name|dest
operator|->
name|loop_father
operator|->
name|latch
operator|=
name|new_bb
expr_stmt|;
return|return
name|new_bb
return|;
block|}
end_function

begin_comment
comment|/* Returns the basic block in that statements should be emitted for induction    variables incremented at the end of the LOOP.  */
end_comment

begin_function
name|basic_block
name|ip_end_pos
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|)
block|{
return|return
name|loop
operator|->
name|latch
return|;
block|}
end_function

begin_comment
comment|/* Returns the basic block in that statements should be emitted for induction    variables incremented just before exit condition of a LOOP.  */
end_comment

begin_function
name|basic_block
name|ip_normal_pos
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|)
block|{
name|tree
name|last
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|edge
name|exit
decl_stmt|;
if|if
condition|(
operator|!
name|single_pred_p
argument_list|(
name|loop
operator|->
name|latch
argument_list|)
condition|)
return|return
name|NULL
return|;
name|bb
operator|=
name|single_pred
argument_list|(
name|loop
operator|->
name|latch
argument_list|)
expr_stmt|;
name|last
operator|=
name|last_stmt
argument_list|(
name|bb
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|last
argument_list|)
operator|!=
name|COND_EXPR
condition|)
return|return
name|NULL
return|;
name|exit
operator|=
name|EDGE_SUCC
argument_list|(
name|bb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|exit
operator|->
name|dest
operator|==
name|loop
operator|->
name|latch
condition|)
name|exit
operator|=
name|EDGE_SUCC
argument_list|(
name|bb
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|flow_bb_inside_loop_p
argument_list|(
name|loop
argument_list|,
name|exit
operator|->
name|dest
argument_list|)
condition|)
return|return
name|NULL
return|;
return|return
name|bb
return|;
block|}
end_function

begin_comment
comment|/* Stores the standard position for induction variable increment in LOOP    (just before the exit condition if it is available and latch block is empty,    end of the latch block otherwise) to BSI.  INSERT_AFTER is set to true if    the increment should be inserted after *BSI.  */
end_comment

begin_function
name|void
name|standard_iv_increment_position
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|block_stmt_iterator
modifier|*
name|bsi
parameter_list|,
name|bool
modifier|*
name|insert_after
parameter_list|)
block|{
name|basic_block
name|bb
init|=
name|ip_normal_pos
argument_list|(
name|loop
argument_list|)
decl_stmt|,
name|latch
init|=
name|ip_end_pos
argument_list|(
name|loop
argument_list|)
decl_stmt|;
name|tree
name|last
init|=
name|last_stmt
argument_list|(
name|latch
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|bb
operator|||
operator|(
name|last
operator|&&
name|TREE_CODE
argument_list|(
name|last
argument_list|)
operator|!=
name|LABEL_EXPR
operator|)
condition|)
block|{
operator|*
name|bsi
operator|=
name|bsi_last
argument_list|(
name|latch
argument_list|)
expr_stmt|;
operator|*
name|insert_after
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
operator|*
name|bsi
operator|=
name|bsi_last
argument_list|(
name|bb
argument_list|)
expr_stmt|;
operator|*
name|insert_after
operator|=
name|false
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Copies phi node arguments for duplicated blocks.  The index of the first    duplicated block is FIRST_NEW_BLOCK.  */
end_comment

begin_function
specifier|static
name|void
name|copy_phi_node_args
parameter_list|(
name|unsigned
name|first_new_block
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|first_new_block
init|;
name|i
operator|<
operator|(
name|unsigned
operator|)
name|last_basic_block
condition|;
name|i
operator|++
control|)
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
operator|->
name|flags
operator||=
name|BB_DUPLICATED
expr_stmt|;
for|for
control|(
name|i
operator|=
name|first_new_block
init|;
name|i
operator|<
operator|(
name|unsigned
operator|)
name|last_basic_block
condition|;
name|i
operator|++
control|)
name|add_phi_args_after_copy_bb
argument_list|(
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|first_new_block
init|;
name|i
operator|<
operator|(
name|unsigned
operator|)
name|last_basic_block
condition|;
name|i
operator|++
control|)
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
operator|->
name|flags
operator|&=
operator|~
name|BB_DUPLICATED
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The same as cfgloopmanip.c:duplicate_loop_to_header_edge, but also    updates the PHI nodes at start of the copied region.  In order to    achieve this, only loops whose exits all lead to the same location    are handled.     Notice that we do not completely update the SSA web after    duplication.  The caller is responsible for calling update_ssa    after the loop has been duplicated.  */
end_comment

begin_function
name|bool
name|tree_duplicate_loop_to_header_edge
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|edge
name|e
parameter_list|,
name|struct
name|loops
modifier|*
name|loops
parameter_list|,
name|unsigned
name|int
name|ndupl
parameter_list|,
name|sbitmap
name|wont_exit
parameter_list|,
name|edge
name|orig
parameter_list|,
name|edge
modifier|*
name|to_remove
parameter_list|,
name|unsigned
name|int
modifier|*
name|n_to_remove
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|unsigned
name|first_new_block
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|loops
operator|->
name|state
operator|&
name|LOOPS_HAVE_SIMPLE_LATCHES
operator|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
operator|(
name|loops
operator|->
name|state
operator|&
name|LOOPS_HAVE_PREHEADERS
operator|)
condition|)
return|return
name|false
return|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
name|verify_loop_closed_ssa
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|first_new_block
operator|=
name|last_basic_block
expr_stmt|;
if|if
condition|(
operator|!
name|duplicate_loop_to_header_edge
argument_list|(
name|loop
argument_list|,
name|e
argument_list|,
name|loops
argument_list|,
name|ndupl
argument_list|,
name|wont_exit
argument_list|,
name|orig
argument_list|,
name|to_remove
argument_list|,
name|n_to_remove
argument_list|,
name|flags
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Readd the removed phi args for e.  */
name|flush_pending_stmts
argument_list|(
name|e
argument_list|)
expr_stmt|;
comment|/* Copy the phi node arguments.  */
name|copy_phi_node_args
argument_list|(
name|first_new_block
argument_list|)
expr_stmt|;
name|scev_reset
argument_list|()
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Build if (COND) goto THEN_LABEL; else goto ELSE_LABEL;  */
end_comment

begin_function
specifier|static
name|tree
name|build_if_stmt
parameter_list|(
name|tree
name|cond
parameter_list|,
name|tree
name|then_label
parameter_list|,
name|tree
name|else_label
parameter_list|)
block|{
return|return
name|build3
argument_list|(
name|COND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|cond
argument_list|,
name|build1
argument_list|(
name|GOTO_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|then_label
argument_list|)
argument_list|,
name|build1
argument_list|(
name|GOTO_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|else_label
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns true if we can unroll LOOP FACTOR times.  Number    of iterations of the loop is returned in NITER.  */
end_comment

begin_function
name|bool
name|can_unroll_loop_p
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|unsigned
name|factor
parameter_list|,
name|struct
name|tree_niter_desc
modifier|*
name|niter
parameter_list|)
block|{
name|edge
name|exit
decl_stmt|;
comment|/* Check whether unrolling is possible.  We only want to unroll loops      for that we are able to determine number of iterations.  We also      want to split the extra iterations of the loop from its end,      therefore we require that the loop has precisely one      exit.  */
name|exit
operator|=
name|single_dom_exit
argument_list|(
name|loop
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|exit
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|number_of_iterations_exit
argument_list|(
name|loop
argument_list|,
name|exit
argument_list|,
name|niter
argument_list|,
name|false
argument_list|)
operator|||
name|niter
operator|->
name|cmp
operator|==
name|ERROR_MARK
comment|/* Scalar evolutions analysis might have copy propagated 	 the abnormal ssa names into these expressions, hence 	 emiting the computations based on them during loop 	 unrolling might create overlapping life ranges for 	 them, and failures in out-of-ssa.  */
operator|||
name|contains_abnormal_ssa_name_p
argument_list|(
name|niter
operator|->
name|may_be_zero
argument_list|)
operator|||
name|contains_abnormal_ssa_name_p
argument_list|(
name|niter
operator|->
name|control
operator|.
name|base
argument_list|)
operator|||
name|contains_abnormal_ssa_name_p
argument_list|(
name|niter
operator|->
name|control
operator|.
name|step
argument_list|)
operator|||
name|contains_abnormal_ssa_name_p
argument_list|(
name|niter
operator|->
name|bound
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* And of course, we must be able to duplicate the loop.  */
if|if
condition|(
operator|!
name|can_duplicate_loop_p
argument_list|(
name|loop
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* The final loop should be small enough.  */
if|if
condition|(
name|tree_num_loop_insns
argument_list|(
name|loop
argument_list|)
operator|*
name|factor
operator|>
operator|(
name|unsigned
operator|)
name|PARAM_VALUE
argument_list|(
name|PARAM_MAX_UNROLLED_INSNS
argument_list|)
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Determines the conditions that control execution of LOOP unrolled FACTOR    times.  DESC is number of iterations of LOOP.  ENTER_COND is set to    condition that must be true if the main loop can be entered.    EXIT_BASE, EXIT_STEP, EXIT_CMP and EXIT_BOUND are set to values describing    how the exit from the unrolled loop should be controlled.  */
end_comment

begin_function
specifier|static
name|void
name|determine_exit_conditions
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|struct
name|tree_niter_desc
modifier|*
name|desc
parameter_list|,
name|unsigned
name|factor
parameter_list|,
name|tree
modifier|*
name|enter_cond
parameter_list|,
name|tree
modifier|*
name|exit_base
parameter_list|,
name|tree
modifier|*
name|exit_step
parameter_list|,
name|enum
name|tree_code
modifier|*
name|exit_cmp
parameter_list|,
name|tree
modifier|*
name|exit_bound
parameter_list|)
block|{
name|tree
name|stmts
decl_stmt|;
name|tree
name|base
init|=
name|desc
operator|->
name|control
operator|.
name|base
decl_stmt|;
name|tree
name|step
init|=
name|desc
operator|->
name|control
operator|.
name|step
decl_stmt|;
name|tree
name|bound
init|=
name|desc
operator|->
name|bound
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|base
argument_list|)
decl_stmt|;
name|tree
name|bigstep
decl_stmt|,
name|delta
decl_stmt|;
name|tree
name|min
init|=
name|lower_bound_in_type
argument_list|(
name|type
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|tree
name|max
init|=
name|upper_bound_in_type
argument_list|(
name|type
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|enum
name|tree_code
name|cmp
init|=
name|desc
operator|->
name|cmp
decl_stmt|;
name|tree
name|cond
init|=
name|boolean_true_node
decl_stmt|,
name|assum
decl_stmt|;
operator|*
name|enter_cond
operator|=
name|boolean_false_node
expr_stmt|;
operator|*
name|exit_base
operator|=
name|NULL_TREE
expr_stmt|;
operator|*
name|exit_step
operator|=
name|NULL_TREE
expr_stmt|;
operator|*
name|exit_cmp
operator|=
name|ERROR_MARK
expr_stmt|;
operator|*
name|exit_bound
operator|=
name|NULL_TREE
expr_stmt|;
name|gcc_assert
argument_list|(
name|cmp
operator|!=
name|ERROR_MARK
argument_list|)
expr_stmt|;
comment|/* We only need to be correct when we answer question      "Do at least FACTOR more iterations remain?" in the unrolled loop.      Thus, transforming BASE + STEP * i<> BOUND to      BASE + STEP * i< BOUND is ok.  */
if|if
condition|(
name|cmp
operator|==
name|NE_EXPR
condition|)
block|{
if|if
condition|(
name|tree_int_cst_sign_bit
argument_list|(
name|step
argument_list|)
condition|)
name|cmp
operator|=
name|GT_EXPR
expr_stmt|;
else|else
name|cmp
operator|=
name|LT_EXPR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmp
operator|==
name|LT_EXPR
condition|)
block|{
name|gcc_assert
argument_list|(
operator|!
name|tree_int_cst_sign_bit
argument_list|(
name|step
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmp
operator|==
name|GT_EXPR
condition|)
block|{
name|gcc_assert
argument_list|(
name|tree_int_cst_sign_bit
argument_list|(
name|step
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|gcc_unreachable
argument_list|()
expr_stmt|;
comment|/* The main body of the loop may be entered iff:       1) desc->may_be_zero is false.      2) it is possible to check that there are at least FACTOR iterations 	of the loop, i.e., BOUND - step * FACTOR does not overflow.      3) # of iterations is at least FACTOR  */
if|if
condition|(
operator|!
name|zero_p
argument_list|(
name|desc
operator|->
name|may_be_zero
argument_list|)
condition|)
name|cond
operator|=
name|fold_build2
argument_list|(
name|TRUTH_AND_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|invert_truthvalue
argument_list|(
name|desc
operator|->
name|may_be_zero
argument_list|)
argument_list|,
name|cond
argument_list|)
expr_stmt|;
name|bigstep
operator|=
name|fold_build2
argument_list|(
name|MULT_EXPR
argument_list|,
name|type
argument_list|,
name|step
argument_list|,
name|build_int_cst_type
argument_list|(
name|type
argument_list|,
name|factor
argument_list|)
argument_list|)
expr_stmt|;
name|delta
operator|=
name|fold_build2
argument_list|(
name|MINUS_EXPR
argument_list|,
name|type
argument_list|,
name|bigstep
argument_list|,
name|step
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|==
name|LT_EXPR
condition|)
name|assum
operator|=
name|fold_build2
argument_list|(
name|GE_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|bound
argument_list|,
name|fold_build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|type
argument_list|,
name|min
argument_list|,
name|delta
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|assum
operator|=
name|fold_build2
argument_list|(
name|LE_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|bound
argument_list|,
name|fold_build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|type
argument_list|,
name|max
argument_list|,
name|delta
argument_list|)
argument_list|)
expr_stmt|;
name|cond
operator|=
name|fold_build2
argument_list|(
name|TRUTH_AND_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|assum
argument_list|,
name|cond
argument_list|)
expr_stmt|;
name|bound
operator|=
name|fold_build2
argument_list|(
name|MINUS_EXPR
argument_list|,
name|type
argument_list|,
name|bound
argument_list|,
name|delta
argument_list|)
expr_stmt|;
name|assum
operator|=
name|fold_build2
argument_list|(
name|cmp
argument_list|,
name|boolean_type_node
argument_list|,
name|base
argument_list|,
name|bound
argument_list|)
expr_stmt|;
name|cond
operator|=
name|fold_build2
argument_list|(
name|TRUTH_AND_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|assum
argument_list|,
name|cond
argument_list|)
expr_stmt|;
name|cond
operator|=
name|force_gimple_operand
argument_list|(
name|unshare_expr
argument_list|(
name|cond
argument_list|)
argument_list|,
operator|&
name|stmts
argument_list|,
name|false
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|stmts
condition|)
name|bsi_insert_on_edge_immediate_loop
argument_list|(
name|loop_preheader_edge
argument_list|(
name|loop
argument_list|)
argument_list|,
name|stmts
argument_list|)
expr_stmt|;
comment|/* cond now may be a gimple comparison, which would be OK, but also any      other gimple rhs (say a&& b).  In this case we need to force it to      operand.  */
if|if
condition|(
operator|!
name|is_gimple_condexpr
argument_list|(
name|cond
argument_list|)
condition|)
block|{
name|cond
operator|=
name|force_gimple_operand
argument_list|(
name|cond
argument_list|,
operator|&
name|stmts
argument_list|,
name|true
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|stmts
condition|)
name|bsi_insert_on_edge_immediate_loop
argument_list|(
name|loop_preheader_edge
argument_list|(
name|loop
argument_list|)
argument_list|,
name|stmts
argument_list|)
expr_stmt|;
block|}
operator|*
name|enter_cond
operator|=
name|cond
expr_stmt|;
name|base
operator|=
name|force_gimple_operand
argument_list|(
name|unshare_expr
argument_list|(
name|base
argument_list|)
argument_list|,
operator|&
name|stmts
argument_list|,
name|true
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|stmts
condition|)
name|bsi_insert_on_edge_immediate_loop
argument_list|(
name|loop_preheader_edge
argument_list|(
name|loop
argument_list|)
argument_list|,
name|stmts
argument_list|)
expr_stmt|;
name|bound
operator|=
name|force_gimple_operand
argument_list|(
name|unshare_expr
argument_list|(
name|bound
argument_list|)
argument_list|,
operator|&
name|stmts
argument_list|,
name|true
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|stmts
condition|)
name|bsi_insert_on_edge_immediate_loop
argument_list|(
name|loop_preheader_edge
argument_list|(
name|loop
argument_list|)
argument_list|,
name|stmts
argument_list|)
expr_stmt|;
operator|*
name|exit_base
operator|=
name|base
expr_stmt|;
operator|*
name|exit_step
operator|=
name|bigstep
expr_stmt|;
operator|*
name|exit_cmp
operator|=
name|cmp
expr_stmt|;
operator|*
name|exit_bound
operator|=
name|bound
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Unroll LOOP FACTOR times.  LOOPS is the loops tree.  DESC describes    number of iterations of LOOP.  EXIT is the exit of the loop to that    DESC corresponds.        If N is number of iterations of the loop and MAY_BE_ZERO is the condition    under that loop exits in the first iteration even if N != 0,        while (1)      {        x = phi (init, next);         pre;        if (st)          break;        post;      }     becomes (with possibly the exit conditions formulated a bit differently,    avoiding the need to create a new iv):        if (MAY_BE_ZERO || N< FACTOR)      goto rest;     do      {        x = phi (init, next);         pre;        post;        pre;        post;        ...        pre;        post;        N -= FACTOR;              } while (N>= FACTOR);     rest:      init' = phi (init, x);     while (1)      {        x = phi (init', next);         pre;        if (st)          break;        post;      } */
end_comment

begin_function
name|void
name|tree_unroll_loop
parameter_list|(
name|struct
name|loops
modifier|*
name|loops
parameter_list|,
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|unsigned
name|factor
parameter_list|,
name|edge
name|exit
parameter_list|,
name|struct
name|tree_niter_desc
modifier|*
name|desc
parameter_list|)
block|{
name|tree
name|dont_exit
decl_stmt|,
name|exit_if
decl_stmt|,
name|ctr_before
decl_stmt|,
name|ctr_after
decl_stmt|;
name|tree
name|enter_main_cond
decl_stmt|,
name|exit_base
decl_stmt|,
name|exit_step
decl_stmt|,
name|exit_bound
decl_stmt|;
name|enum
name|tree_code
name|exit_cmp
decl_stmt|;
name|tree
name|phi_old_loop
decl_stmt|,
name|phi_new_loop
decl_stmt|,
name|phi_rest
decl_stmt|,
name|init
decl_stmt|,
name|next
decl_stmt|,
name|new_init
decl_stmt|,
name|var
decl_stmt|;
name|struct
name|loop
modifier|*
name|new_loop
decl_stmt|;
name|basic_block
name|rest
decl_stmt|,
name|exit_bb
decl_stmt|;
name|edge
name|old_entry
decl_stmt|,
name|new_entry
decl_stmt|,
name|old_latch
decl_stmt|,
name|precond_edge
decl_stmt|,
name|new_exit
decl_stmt|;
name|edge
name|nonexit
decl_stmt|,
name|new_nonexit
decl_stmt|;
name|block_stmt_iterator
name|bsi
decl_stmt|;
name|use_operand_p
name|op
decl_stmt|;
name|bool
name|ok
decl_stmt|;
name|unsigned
name|est_niter
decl_stmt|;
name|unsigned
name|irr
init|=
name|loop_preheader_edge
argument_list|(
name|loop
argument_list|)
operator|->
name|flags
operator|&
name|EDGE_IRREDUCIBLE_LOOP
decl_stmt|;
name|sbitmap
name|wont_exit
decl_stmt|;
name|est_niter
operator|=
name|expected_loop_iterations
argument_list|(
name|loop
argument_list|)
expr_stmt|;
name|determine_exit_conditions
argument_list|(
name|loop
argument_list|,
name|desc
argument_list|,
name|factor
argument_list|,
operator|&
name|enter_main_cond
argument_list|,
operator|&
name|exit_base
argument_list|,
operator|&
name|exit_step
argument_list|,
operator|&
name|exit_cmp
argument_list|,
operator|&
name|exit_bound
argument_list|)
expr_stmt|;
name|new_loop
operator|=
name|loop_version
argument_list|(
name|loops
argument_list|,
name|loop
argument_list|,
name|enter_main_cond
argument_list|,
name|NULL
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|new_loop
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|update_ssa
argument_list|(
name|TODO_update_ssa
argument_list|)
expr_stmt|;
comment|/* Unroll the loop and remove the old exits.  */
name|dont_exit
operator|=
operator|(
operator|(
name|exit
operator|->
name|flags
operator|&
name|EDGE_TRUE_VALUE
operator|)
condition|?
name|boolean_false_node
else|:
name|boolean_true_node
operator|)
expr_stmt|;
if|if
condition|(
name|exit
operator|==
name|EDGE_SUCC
argument_list|(
name|exit
operator|->
name|src
argument_list|,
literal|0
argument_list|)
condition|)
name|nonexit
operator|=
name|EDGE_SUCC
argument_list|(
name|exit
operator|->
name|src
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|nonexit
operator|=
name|EDGE_SUCC
argument_list|(
name|exit
operator|->
name|src
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|nonexit
operator|->
name|probability
operator|=
name|REG_BR_PROB_BASE
expr_stmt|;
name|exit
operator|->
name|probability
operator|=
literal|0
expr_stmt|;
name|nonexit
operator|->
name|count
operator|+=
name|exit
operator|->
name|count
expr_stmt|;
name|exit
operator|->
name|count
operator|=
literal|0
expr_stmt|;
name|exit_if
operator|=
name|last_stmt
argument_list|(
name|exit
operator|->
name|src
argument_list|)
expr_stmt|;
name|COND_EXPR_COND
argument_list|(
name|exit_if
argument_list|)
operator|=
name|dont_exit
expr_stmt|;
name|update_stmt
argument_list|(
name|exit_if
argument_list|)
expr_stmt|;
name|wont_exit
operator|=
name|sbitmap_alloc
argument_list|(
name|factor
argument_list|)
expr_stmt|;
name|sbitmap_ones
argument_list|(
name|wont_exit
argument_list|)
expr_stmt|;
name|ok
operator|=
name|tree_duplicate_loop_to_header_edge
argument_list|(
name|loop
argument_list|,
name|loop_latch_edge
argument_list|(
name|loop
argument_list|)
argument_list|,
name|loops
argument_list|,
name|factor
operator|-
literal|1
argument_list|,
name|wont_exit
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|DLTHE_FLAG_UPDATE_FREQ
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|wont_exit
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|ok
argument_list|)
expr_stmt|;
name|update_ssa
argument_list|(
name|TODO_update_ssa
argument_list|)
expr_stmt|;
comment|/* Prepare the cfg and update the phi nodes.  */
name|rest
operator|=
name|loop_preheader_edge
argument_list|(
name|new_loop
argument_list|)
operator|->
name|src
expr_stmt|;
name|precond_edge
operator|=
name|single_pred_edge
argument_list|(
name|rest
argument_list|)
expr_stmt|;
name|loop_split_edge_with
argument_list|(
name|loop_latch_edge
argument_list|(
name|loop
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|exit_bb
operator|=
name|single_pred
argument_list|(
name|loop
operator|->
name|latch
argument_list|)
expr_stmt|;
name|new_exit
operator|=
name|make_edge
argument_list|(
name|exit_bb
argument_list|,
name|rest
argument_list|,
name|EDGE_FALSE_VALUE
operator||
name|irr
argument_list|)
expr_stmt|;
name|new_exit
operator|->
name|count
operator|=
name|loop_preheader_edge
argument_list|(
name|loop
argument_list|)
operator|->
name|count
expr_stmt|;
name|est_niter
operator|=
name|est_niter
operator|/
name|factor
operator|+
literal|1
expr_stmt|;
name|new_exit
operator|->
name|probability
operator|=
name|REG_BR_PROB_BASE
operator|/
name|est_niter
expr_stmt|;
name|new_nonexit
operator|=
name|single_pred_edge
argument_list|(
name|loop
operator|->
name|latch
argument_list|)
expr_stmt|;
name|new_nonexit
operator|->
name|flags
operator|=
name|EDGE_TRUE_VALUE
expr_stmt|;
name|new_nonexit
operator|->
name|probability
operator|=
name|REG_BR_PROB_BASE
operator|-
name|new_exit
operator|->
name|probability
expr_stmt|;
name|old_entry
operator|=
name|loop_preheader_edge
argument_list|(
name|loop
argument_list|)
expr_stmt|;
name|new_entry
operator|=
name|loop_preheader_edge
argument_list|(
name|new_loop
argument_list|)
expr_stmt|;
name|old_latch
operator|=
name|loop_latch_edge
argument_list|(
name|loop
argument_list|)
expr_stmt|;
for|for
control|(
name|phi_old_loop
operator|=
name|phi_nodes
argument_list|(
name|loop
operator|->
name|header
argument_list|)
operator|,
name|phi_new_loop
operator|=
name|phi_nodes
argument_list|(
name|new_loop
operator|->
name|header
argument_list|)
init|;
name|phi_old_loop
condition|;
name|phi_old_loop
operator|=
name|PHI_CHAIN
argument_list|(
name|phi_old_loop
argument_list|)
operator|,
name|phi_new_loop
operator|=
name|PHI_CHAIN
argument_list|(
name|phi_new_loop
argument_list|)
control|)
block|{
name|init
operator|=
name|PHI_ARG_DEF_FROM_EDGE
argument_list|(
name|phi_old_loop
argument_list|,
name|old_entry
argument_list|)
expr_stmt|;
name|op
operator|=
name|PHI_ARG_DEF_PTR_FROM_EDGE
argument_list|(
name|phi_new_loop
argument_list|,
name|new_entry
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|operand_equal_for_phi_arg_p
argument_list|(
name|init
argument_list|,
name|USE_FROM_PTR
argument_list|(
name|op
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|next
operator|=
name|PHI_ARG_DEF_FROM_EDGE
argument_list|(
name|phi_old_loop
argument_list|,
name|old_latch
argument_list|)
expr_stmt|;
comment|/* Prefer using original variable as a base for the new ssa name. 	 This is necessary for virtual ops, and useful in order to avoid 	 losing debug info for real ops.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|SSA_NAME
condition|)
name|var
operator|=
name|SSA_NAME_VAR
argument_list|(
name|next
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|SSA_NAME
condition|)
name|var
operator|=
name|SSA_NAME_VAR
argument_list|(
name|init
argument_list|)
expr_stmt|;
else|else
block|{
name|var
operator|=
name|create_tmp_var
argument_list|(
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
argument_list|,
literal|"unrinittmp"
argument_list|)
expr_stmt|;
name|add_referenced_var
argument_list|(
name|var
argument_list|)
expr_stmt|;
block|}
name|new_init
operator|=
name|make_ssa_name
argument_list|(
name|var
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|phi_rest
operator|=
name|create_phi_node
argument_list|(
name|new_init
argument_list|,
name|rest
argument_list|)
expr_stmt|;
name|SSA_NAME_DEF_STMT
argument_list|(
name|new_init
argument_list|)
operator|=
name|phi_rest
expr_stmt|;
name|add_phi_arg
argument_list|(
name|phi_rest
argument_list|,
name|init
argument_list|,
name|precond_edge
argument_list|)
expr_stmt|;
name|add_phi_arg
argument_list|(
name|phi_rest
argument_list|,
name|next
argument_list|,
name|new_exit
argument_list|)
expr_stmt|;
name|SET_USE
argument_list|(
name|op
argument_list|,
name|new_init
argument_list|)
expr_stmt|;
block|}
comment|/* Finally create the new counter for number of iterations and add the new      exit instruction.  */
name|bsi
operator|=
name|bsi_last
argument_list|(
name|exit_bb
argument_list|)
expr_stmt|;
name|create_iv
argument_list|(
name|exit_base
argument_list|,
name|exit_step
argument_list|,
name|NULL_TREE
argument_list|,
name|loop
argument_list|,
operator|&
name|bsi
argument_list|,
name|true
argument_list|,
operator|&
name|ctr_before
argument_list|,
operator|&
name|ctr_after
argument_list|)
expr_stmt|;
name|exit_if
operator|=
name|build_if_stmt
argument_list|(
name|build2
argument_list|(
name|exit_cmp
argument_list|,
name|boolean_type_node
argument_list|,
name|ctr_after
argument_list|,
name|exit_bound
argument_list|)
argument_list|,
name|tree_block_label
argument_list|(
name|loop
operator|->
name|latch
argument_list|)
argument_list|,
name|tree_block_label
argument_list|(
name|rest
argument_list|)
argument_list|)
expr_stmt|;
name|bsi_insert_after
argument_list|(
operator|&
name|bsi
argument_list|,
name|exit_if
argument_list|,
name|BSI_NEW_STMT
argument_list|)
expr_stmt|;
name|verify_flow_info
argument_list|()
expr_stmt|;
name|verify_dominators
argument_list|(
name|CDI_DOMINATORS
argument_list|)
expr_stmt|;
name|verify_loop_structure
argument_list|(
name|loops
argument_list|)
expr_stmt|;
name|verify_loop_closed_ssa
argument_list|()
expr_stmt|;
block|}
end_function

end_unit

