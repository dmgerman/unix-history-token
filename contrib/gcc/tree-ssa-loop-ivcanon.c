begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Induction variable canonicalization.    Copyright (C) 2004, 2005 Free Software Foundation, Inc.     This file is part of GCC.     GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.     GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.     You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* This pass detects the loops that iterate a constant number of times,    adds a canonical induction variable (step -1, tested against 0)     and replaces the exit test.  This enables the less powerful rtl    level analysis to use this information.     This might spoil the code in some cases (by increasing register pressure).    Note that in the case the new variable is not needed, ivopts will get rid    of it, so it might only be a problem when there are no other linear induction    variables.  In that case the created optimization possibilities are likely    to pay up.     Additionally in case we detect that it is beneficial to unroll the    loop completely, we do it right here to expose the optimization    possibilities to the following passes.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_include
include|#
directive|include
file|"tree-flow.h"
end_include

begin_include
include|#
directive|include
file|"tree-dump.h"
end_include

begin_include
include|#
directive|include
file|"cfgloop.h"
end_include

begin_include
include|#
directive|include
file|"tree-pass.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"tree-chrec.h"
end_include

begin_include
include|#
directive|include
file|"tree-scalar-evolution.h"
end_include

begin_include
include|#
directive|include
file|"params.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"tree-inline.h"
end_include

begin_comment
comment|/* Specifies types of loops that may be unrolled.  */
end_comment

begin_enum
enum|enum
name|unroll_level
block|{
name|UL_SINGLE_ITER
block|,
comment|/* Only loops that exit immediately in the first 			   iteration.  */
name|UL_NO_GROWTH
block|,
comment|/* Only loops whose unrolling will not cause increase 			   of code size.  */
name|UL_ALL
comment|/* All suitable loops.  */
block|}
enum|;
end_enum

begin_comment
comment|/* Adds a canonical induction variable to LOOP iterating NITER times.  EXIT    is the exit edge whose condition is replaced.  */
end_comment

begin_function
specifier|static
name|void
name|create_canonical_iv
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|edge
name|exit
parameter_list|,
name|tree
name|niter
parameter_list|)
block|{
name|edge
name|in
decl_stmt|;
name|tree
name|cond
decl_stmt|,
name|type
decl_stmt|,
name|var
decl_stmt|;
name|block_stmt_iterator
name|incr_at
decl_stmt|;
name|enum
name|tree_code
name|cmp
decl_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Added canonical iv to loop %d, "
argument_list|,
name|loop
operator|->
name|num
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|niter
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|" iterations.\n"
argument_list|)
expr_stmt|;
block|}
name|cond
operator|=
name|last_stmt
argument_list|(
name|exit
operator|->
name|src
argument_list|)
expr_stmt|;
name|in
operator|=
name|EDGE_SUCC
argument_list|(
name|exit
operator|->
name|src
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|in
operator|==
name|exit
condition|)
name|in
operator|=
name|EDGE_SUCC
argument_list|(
name|exit
operator|->
name|src
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Note that we do not need to worry about overflows, since      type of niter is always unsigned and all comparisons are      just for equality/nonequality -- i.e. everything works      with a modulo arithmetics.  */
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|niter
argument_list|)
expr_stmt|;
name|niter
operator|=
name|fold_build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|type
argument_list|,
name|niter
argument_list|,
name|build_int_cst
argument_list|(
name|type
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|incr_at
operator|=
name|bsi_last
argument_list|(
name|in
operator|->
name|src
argument_list|)
expr_stmt|;
name|create_iv
argument_list|(
name|niter
argument_list|,
name|build_int_cst
argument_list|(
name|type
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
name|loop
argument_list|,
operator|&
name|incr_at
argument_list|,
name|false
argument_list|,
name|NULL
argument_list|,
operator|&
name|var
argument_list|)
expr_stmt|;
name|cmp
operator|=
operator|(
name|exit
operator|->
name|flags
operator|&
name|EDGE_TRUE_VALUE
operator|)
condition|?
name|EQ_EXPR
else|:
name|NE_EXPR
expr_stmt|;
name|COND_EXPR_COND
argument_list|(
name|cond
argument_list|)
operator|=
name|build2
argument_list|(
name|cmp
argument_list|,
name|boolean_type_node
argument_list|,
name|var
argument_list|,
name|build_int_cst
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|update_stmt
argument_list|(
name|cond
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Computes an estimated number of insns in LOOP.  */
end_comment

begin_function
name|unsigned
name|tree_num_loop_insns
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|)
block|{
name|basic_block
modifier|*
name|body
init|=
name|get_loop_body
argument_list|(
name|loop
argument_list|)
decl_stmt|;
name|block_stmt_iterator
name|bsi
decl_stmt|;
name|unsigned
name|size
init|=
literal|1
decl_stmt|,
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|loop
operator|->
name|num_nodes
condition|;
name|i
operator|++
control|)
for|for
control|(
name|bsi
operator|=
name|bsi_start
argument_list|(
name|body
index|[
name|i
index|]
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|;
name|bsi_next
argument_list|(
operator|&
name|bsi
argument_list|)
control|)
name|size
operator|+=
name|estimate_num_insns
argument_list|(
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|body
argument_list|)
expr_stmt|;
return|return
name|size
return|;
block|}
end_function

begin_comment
comment|/* Estimate number of insns of completely unrolled loop.  We assume    that the size of the unrolled loop is decreased in the    following way (the numbers of insns are based on what    estimate_num_insns returns for appropriate statements):     1) exit condition gets removed (2 insns)    2) increment of the control variable gets removed (2 insns)    3) All remaining statements are likely to get simplified       due to constant propagation.  Hard to estimate; just       as a heuristics we decrease the rest by 1/3.     NINSNS is the number of insns in the loop before unrolling.    NUNROLL is the number of times the loop is unrolled.  */
end_comment

begin_function
specifier|static
name|unsigned
name|HOST_WIDE_INT
name|estimated_unrolled_size
parameter_list|(
name|unsigned
name|HOST_WIDE_INT
name|ninsns
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|nunroll
parameter_list|)
block|{
name|HOST_WIDE_INT
name|unr_insns
init|=
literal|2
operator|*
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
name|ninsns
operator|-
literal|4
operator|)
operator|/
literal|3
decl_stmt|;
if|if
condition|(
name|unr_insns
operator|<=
literal|0
condition|)
name|unr_insns
operator|=
literal|1
expr_stmt|;
name|unr_insns
operator|*=
operator|(
name|nunroll
operator|+
literal|1
operator|)
expr_stmt|;
return|return
name|unr_insns
return|;
block|}
end_function

begin_comment
comment|/* Tries to unroll LOOP completely, i.e. NITER times.  LOOPS is the    loop tree.  UL determines which loops we are allowed to unroll.     EXIT is the exit of the loop that should be eliminated.  */
end_comment

begin_function
specifier|static
name|bool
name|try_unroll_loop_completely
parameter_list|(
name|struct
name|loops
modifier|*
name|loops
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|edge
name|exit
parameter_list|,
name|tree
name|niter
parameter_list|,
name|enum
name|unroll_level
name|ul
parameter_list|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|n_unroll
decl_stmt|,
name|ninsns
decl_stmt|,
name|max_unroll
decl_stmt|,
name|unr_insns
decl_stmt|;
name|tree
name|old_cond
decl_stmt|,
name|cond
decl_stmt|,
name|dont_exit
decl_stmt|,
name|do_exit
decl_stmt|;
if|if
condition|(
name|loop
operator|->
name|inner
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|host_integerp
argument_list|(
name|niter
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|false
return|;
name|n_unroll
operator|=
name|tree_low_cst
argument_list|(
name|niter
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|max_unroll
operator|=
name|PARAM_VALUE
argument_list|(
name|PARAM_MAX_COMPLETELY_PEEL_TIMES
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_unroll
operator|>
name|max_unroll
condition|)
return|return
name|false
return|;
if|if
condition|(
name|n_unroll
condition|)
block|{
if|if
condition|(
name|ul
operator|==
name|UL_SINGLE_ITER
condition|)
return|return
name|false
return|;
name|ninsns
operator|=
name|tree_num_loop_insns
argument_list|(
name|loop
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_unroll
operator|*
name|ninsns
operator|>
operator|(
name|unsigned
operator|)
name|PARAM_VALUE
argument_list|(
name|PARAM_MAX_COMPLETELY_PEELED_INSNS
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|ul
operator|==
name|UL_NO_GROWTH
condition|)
block|{
name|unr_insns
operator|=
name|estimated_unrolled_size
argument_list|(
name|ninsns
argument_list|,
name|n_unroll
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"  Loop size: %d\n"
argument_list|,
operator|(
name|int
operator|)
name|ninsns
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"  Estimated size after unrolling: %d\n"
argument_list|,
operator|(
name|int
operator|)
name|unr_insns
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|unr_insns
operator|>
name|ninsns
condition|)
block|{
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Not unrolling loop %d:\n"
argument_list|,
name|loop
operator|->
name|num
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
block|}
if|if
condition|(
name|exit
operator|->
name|flags
operator|&
name|EDGE_TRUE_VALUE
condition|)
block|{
name|dont_exit
operator|=
name|boolean_false_node
expr_stmt|;
name|do_exit
operator|=
name|boolean_true_node
expr_stmt|;
block|}
else|else
block|{
name|dont_exit
operator|=
name|boolean_true_node
expr_stmt|;
name|do_exit
operator|=
name|boolean_false_node
expr_stmt|;
block|}
name|cond
operator|=
name|last_stmt
argument_list|(
name|exit
operator|->
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_unroll
condition|)
block|{
name|sbitmap
name|wont_exit
decl_stmt|;
name|edge
modifier|*
name|edges_to_remove
init|=
name|XNEWVEC
argument_list|(
name|edge
argument_list|,
name|n_unroll
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|n_to_remove
init|=
literal|0
decl_stmt|;
name|old_cond
operator|=
name|COND_EXPR_COND
argument_list|(
name|cond
argument_list|)
expr_stmt|;
name|COND_EXPR_COND
argument_list|(
name|cond
argument_list|)
operator|=
name|dont_exit
expr_stmt|;
name|update_stmt
argument_list|(
name|cond
argument_list|)
expr_stmt|;
name|initialize_original_copy_tables
argument_list|()
expr_stmt|;
name|wont_exit
operator|=
name|sbitmap_alloc
argument_list|(
name|n_unroll
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sbitmap_ones
argument_list|(
name|wont_exit
argument_list|)
expr_stmt|;
name|RESET_BIT
argument_list|(
name|wont_exit
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tree_duplicate_loop_to_header_edge
argument_list|(
name|loop
argument_list|,
name|loop_preheader_edge
argument_list|(
name|loop
argument_list|)
argument_list|,
name|loops
argument_list|,
name|n_unroll
argument_list|,
name|wont_exit
argument_list|,
name|exit
argument_list|,
name|edges_to_remove
argument_list|,
operator|&
name|n_to_remove
argument_list|,
name|DLTHE_FLAG_UPDATE_FREQ
operator||
name|DLTHE_FLAG_COMPLETTE_PEEL
argument_list|)
condition|)
block|{
name|COND_EXPR_COND
argument_list|(
name|cond
argument_list|)
operator|=
name|old_cond
expr_stmt|;
name|update_stmt
argument_list|(
name|cond
argument_list|)
expr_stmt|;
name|free_original_copy_tables
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|wont_exit
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|edges_to_remove
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|free
argument_list|(
name|wont_exit
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|edges_to_remove
argument_list|)
expr_stmt|;
name|free_original_copy_tables
argument_list|()
expr_stmt|;
block|}
name|COND_EXPR_COND
argument_list|(
name|cond
argument_list|)
operator|=
name|do_exit
expr_stmt|;
name|update_stmt
argument_list|(
name|cond
argument_list|)
expr_stmt|;
name|update_ssa
argument_list|(
name|TODO_update_ssa
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Unrolled loop %d completely.\n"
argument_list|,
name|loop
operator|->
name|num
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Adds a canonical induction variable to LOOP if suitable.  LOOPS is the loops    tree.  CREATE_IV is true if we may create a new iv.  UL determines     which loops we are allowed to completely unroll.  If TRY_EVAL is true, we try    to determine the number of iterations of a loop by direct evaluation.     Returns true if cfg is changed.  */
end_comment

begin_function
specifier|static
name|bool
name|canonicalize_loop_induction_variables
parameter_list|(
name|struct
name|loops
modifier|*
name|loops
parameter_list|,
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|bool
name|create_iv
parameter_list|,
name|enum
name|unroll_level
name|ul
parameter_list|,
name|bool
name|try_eval
parameter_list|)
block|{
name|edge
name|exit
init|=
name|NULL
decl_stmt|;
name|tree
name|niter
decl_stmt|;
name|niter
operator|=
name|number_of_iterations_in_loop
argument_list|(
name|loop
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|niter
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|exit
operator|=
name|loop
operator|->
name|single_exit
expr_stmt|;
if|if
condition|(
operator|!
name|just_once_each_iteration_p
argument_list|(
name|loop
argument_list|,
name|exit
operator|->
name|src
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* The result of number_of_iterations_in_loop is by one higher than 	 we expect (i.e. it returns number of executions of the exit 	 condition, not of the loop latch edge).  */
name|niter
operator|=
name|fold_build2
argument_list|(
name|MINUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|niter
argument_list|)
argument_list|,
name|niter
argument_list|,
name|build_int_cst
argument_list|(
name|TREE_TYPE
argument_list|(
name|niter
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* If the loop has more than one exit, try checking all of them 	 for # of iterations determinable through scev.  */
if|if
condition|(
operator|!
name|loop
operator|->
name|single_exit
condition|)
name|niter
operator|=
name|find_loop_niter
argument_list|(
name|loop
argument_list|,
operator|&
name|exit
argument_list|)
expr_stmt|;
comment|/* Finally if everything else fails, try brute force evaluation.  */
if|if
condition|(
name|try_eval
operator|&&
operator|(
name|chrec_contains_undetermined
argument_list|(
name|niter
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|niter
argument_list|)
operator|!=
name|INTEGER_CST
operator|)
condition|)
name|niter
operator|=
name|find_loop_niter_by_eval
argument_list|(
name|loop
argument_list|,
operator|&
name|exit
argument_list|)
expr_stmt|;
if|if
condition|(
name|chrec_contains_undetermined
argument_list|(
name|niter
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|niter
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Loop %d iterates "
argument_list|,
name|loop
operator|->
name|num
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|niter
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|" times.\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|try_unroll_loop_completely
argument_list|(
name|loops
argument_list|,
name|loop
argument_list|,
name|exit
argument_list|,
name|niter
argument_list|,
name|ul
argument_list|)
condition|)
return|return
name|true
return|;
if|if
condition|(
name|create_iv
condition|)
name|create_canonical_iv
argument_list|(
name|loop
argument_list|,
name|exit
argument_list|,
name|niter
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* The main entry point of the pass.  Adds canonical induction variables    to the suitable LOOPS.  */
end_comment

begin_function
name|unsigned
name|int
name|canonicalize_induction_variables
parameter_list|(
name|struct
name|loops
modifier|*
name|loops
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
name|struct
name|loop
modifier|*
name|loop
decl_stmt|;
name|bool
name|changed
init|=
name|false
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|loops
operator|->
name|num
condition|;
name|i
operator|++
control|)
block|{
name|loop
operator|=
name|loops
operator|->
name|parray
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|loop
condition|)
name|changed
operator||=
name|canonicalize_loop_induction_variables
argument_list|(
name|loops
argument_list|,
name|loop
argument_list|,
name|true
argument_list|,
name|UL_SINGLE_ITER
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
comment|/* Clean up the information about numbers of iterations, since brute force      evaluation could reveal new information.  */
name|scev_reset
argument_list|()
expr_stmt|;
if|if
condition|(
name|changed
condition|)
return|return
name|TODO_cleanup_cfg
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Unroll LOOPS completely if they iterate just few times.  Unless    MAY_INCREASE_SIZE is true, perform the unrolling only if the    size of the code does not increase.  */
end_comment

begin_function
name|unsigned
name|int
name|tree_unroll_loops_completely
parameter_list|(
name|struct
name|loops
modifier|*
name|loops
parameter_list|,
name|bool
name|may_increase_size
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
name|struct
name|loop
modifier|*
name|loop
decl_stmt|;
name|bool
name|changed
init|=
name|false
decl_stmt|;
name|enum
name|unroll_level
name|ul
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|loops
operator|->
name|num
condition|;
name|i
operator|++
control|)
block|{
name|loop
operator|=
name|loops
operator|->
name|parray
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|loop
condition|)
continue|continue;
if|if
condition|(
name|may_increase_size
operator|&&
name|maybe_hot_bb_p
argument_list|(
name|loop
operator|->
name|header
argument_list|)
condition|)
name|ul
operator|=
name|UL_ALL
expr_stmt|;
else|else
name|ul
operator|=
name|UL_NO_GROWTH
expr_stmt|;
name|changed
operator||=
name|canonicalize_loop_induction_variables
argument_list|(
name|loops
argument_list|,
name|loop
argument_list|,
name|false
argument_list|,
name|ul
argument_list|,
operator|!
name|flag_tree_loop_ivcanon
argument_list|)
expr_stmt|;
block|}
comment|/* Clean up the information about numbers of iterations, since complete      unrolling might have invalidated it.  */
name|scev_reset
argument_list|()
expr_stmt|;
if|if
condition|(
name|changed
condition|)
return|return
name|TODO_cleanup_cfg
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Checks whether LOOP is empty.  */
end_comment

begin_function
specifier|static
name|bool
name|empty_loop_p
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|)
block|{
name|edge
name|exit
decl_stmt|;
name|struct
name|tree_niter_desc
name|niter
decl_stmt|;
name|tree
name|phi
decl_stmt|,
name|def
decl_stmt|;
name|basic_block
modifier|*
name|body
decl_stmt|;
name|block_stmt_iterator
name|bsi
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|tree
name|stmt
decl_stmt|;
comment|/* If the loop has multiple exits, it is too hard for us to handle.      Similarly, if the exit is not dominating, we cannot determine      whether the loop is not infinite.  */
name|exit
operator|=
name|single_dom_exit
argument_list|(
name|loop
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|exit
condition|)
return|return
name|false
return|;
comment|/* The loop must be finite.  */
if|if
condition|(
operator|!
name|number_of_iterations_exit
argument_list|(
name|loop
argument_list|,
name|exit
argument_list|,
operator|&
name|niter
argument_list|,
name|false
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Values of all loop exit phi nodes must be invariants.  */
for|for
control|(
name|phi
operator|=
name|phi_nodes
argument_list|(
name|exit
operator|->
name|dest
argument_list|)
init|;
name|phi
condition|;
name|phi
operator|=
name|PHI_CHAIN
argument_list|(
name|phi
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|is_gimple_reg
argument_list|(
name|PHI_RESULT
argument_list|(
name|phi
argument_list|)
argument_list|)
condition|)
continue|continue;
name|def
operator|=
name|PHI_ARG_DEF_FROM_EDGE
argument_list|(
name|phi
argument_list|,
name|exit
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|expr_invariant_in_loop_p
argument_list|(
name|loop
argument_list|,
name|def
argument_list|)
condition|)
return|return
name|false
return|;
block|}
comment|/* And there should be no memory modifying or from other reasons      unremovable statements.  */
name|body
operator|=
name|get_loop_body
argument_list|(
name|loop
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|loop
operator|->
name|num_nodes
condition|;
name|i
operator|++
control|)
block|{
comment|/* Irreducible region might be infinite.  */
if|if
condition|(
name|body
index|[
name|i
index|]
operator|->
name|flags
operator|&
name|BB_IRREDUCIBLE_LOOP
condition|)
block|{
name|free
argument_list|(
name|body
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
for|for
control|(
name|bsi
operator|=
name|bsi_start
argument_list|(
name|body
index|[
name|i
index|]
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|;
name|bsi_next
argument_list|(
operator|&
name|bsi
argument_list|)
control|)
block|{
name|stmt
operator|=
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ZERO_SSA_OPERANDS
argument_list|(
name|stmt
argument_list|,
name|SSA_OP_VIRTUAL_DEFS
argument_list|)
operator|||
name|stmt_ann
argument_list|(
name|stmt
argument_list|)
operator|->
name|has_volatile_ops
condition|)
block|{
name|free
argument_list|(
name|body
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* Also, asm statements and calls may have side effects and we 	     cannot change the number of times they are executed.  */
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
condition|)
block|{
case|case
name|RETURN_EXPR
case|:
case|case
name|MODIFY_EXPR
case|:
name|stmt
operator|=
name|get_call_expr_in
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stmt
condition|)
break|break;
case|case
name|CALL_EXPR
case|:
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|stmt
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|body
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
break|break;
case|case
name|ASM_EXPR
case|:
comment|/* We cannot remove volatile assembler.  */
if|if
condition|(
name|ASM_VOLATILE_P
argument_list|(
name|stmt
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|body
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
break|break;
default|default:
break|break;
block|}
block|}
block|}
name|free
argument_list|(
name|body
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Remove LOOP by making it exit in the first iteration.  */
end_comment

begin_function
specifier|static
name|void
name|remove_empty_loop
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|)
block|{
name|edge
name|exit
init|=
name|single_dom_exit
argument_list|(
name|loop
argument_list|)
decl_stmt|,
name|non_exit
decl_stmt|;
name|tree
name|cond_stmt
init|=
name|last_stmt
argument_list|(
name|exit
operator|->
name|src
argument_list|)
decl_stmt|;
name|tree
name|do_exit
decl_stmt|;
name|basic_block
modifier|*
name|body
decl_stmt|;
name|unsigned
name|n_before
decl_stmt|,
name|freq_in
decl_stmt|,
name|freq_h
decl_stmt|;
name|gcov_type
name|exit_count
init|=
name|exit
operator|->
name|count
decl_stmt|;
name|non_exit
operator|=
name|EDGE_SUCC
argument_list|(
name|exit
operator|->
name|src
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|non_exit
operator|==
name|exit
condition|)
name|non_exit
operator|=
name|EDGE_SUCC
argument_list|(
name|exit
operator|->
name|src
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|exit
operator|->
name|flags
operator|&
name|EDGE_TRUE_VALUE
condition|)
name|do_exit
operator|=
name|boolean_true_node
expr_stmt|;
else|else
name|do_exit
operator|=
name|boolean_false_node
expr_stmt|;
name|COND_EXPR_COND
argument_list|(
name|cond_stmt
argument_list|)
operator|=
name|do_exit
expr_stmt|;
name|update_stmt
argument_list|(
name|cond_stmt
argument_list|)
expr_stmt|;
comment|/* Let us set the probabilities of the edges coming from the exit block.  */
name|exit
operator|->
name|probability
operator|=
name|REG_BR_PROB_BASE
expr_stmt|;
name|non_exit
operator|->
name|probability
operator|=
literal|0
expr_stmt|;
name|non_exit
operator|->
name|count
operator|=
literal|0
expr_stmt|;
comment|/* Update frequencies and counts.  Everything before      the exit needs to be scaled FREQ_IN/FREQ_H times,      where FREQ_IN is the frequency of the entry edge      and FREQ_H is the frequency of the loop header.      Everything after the exit has zero frequency.  */
name|freq_h
operator|=
name|loop
operator|->
name|header
operator|->
name|frequency
expr_stmt|;
name|freq_in
operator|=
name|EDGE_FREQUENCY
argument_list|(
name|loop_preheader_edge
argument_list|(
name|loop
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|freq_h
operator|!=
literal|0
condition|)
block|{
name|body
operator|=
name|get_loop_body_in_dom_order
argument_list|(
name|loop
argument_list|)
expr_stmt|;
for|for
control|(
name|n_before
operator|=
literal|1
init|;
name|n_before
operator|<=
name|loop
operator|->
name|num_nodes
condition|;
name|n_before
operator|++
control|)
if|if
condition|(
name|body
index|[
name|n_before
operator|-
literal|1
index|]
operator|==
name|exit
operator|->
name|src
condition|)
break|break;
name|scale_bbs_frequencies_int
argument_list|(
name|body
argument_list|,
name|n_before
argument_list|,
name|freq_in
argument_list|,
name|freq_h
argument_list|)
expr_stmt|;
name|scale_bbs_frequencies_int
argument_list|(
name|body
operator|+
name|n_before
argument_list|,
name|loop
operator|->
name|num_nodes
operator|-
name|n_before
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|body
argument_list|)
expr_stmt|;
block|}
comment|/* Number of executions of exit is not changed, thus we need to restore      the original value.  */
name|exit
operator|->
name|count
operator|=
name|exit_count
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Removes LOOP if it is empty.  Returns true if LOOP is removed.  CHANGED    is set to true if LOOP or any of its subloops is removed.  */
end_comment

begin_function
specifier|static
name|bool
name|try_remove_empty_loop
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|bool
modifier|*
name|changed
parameter_list|)
block|{
name|bool
name|nonempty_subloop
init|=
name|false
decl_stmt|;
name|struct
name|loop
modifier|*
name|sub
decl_stmt|;
comment|/* First, all subloops must be removed.  */
for|for
control|(
name|sub
operator|=
name|loop
operator|->
name|inner
init|;
name|sub
condition|;
name|sub
operator|=
name|sub
operator|->
name|next
control|)
name|nonempty_subloop
operator||=
operator|!
name|try_remove_empty_loop
argument_list|(
name|sub
argument_list|,
name|changed
argument_list|)
expr_stmt|;
if|if
condition|(
name|nonempty_subloop
operator|||
operator|!
name|empty_loop_p
argument_list|(
name|loop
argument_list|)
condition|)
return|return
name|false
return|;
name|remove_empty_loop
argument_list|(
name|loop
argument_list|)
expr_stmt|;
operator|*
name|changed
operator|=
name|true
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Remove the empty LOOPS.  */
end_comment

begin_function
name|unsigned
name|int
name|remove_empty_loops
parameter_list|(
name|struct
name|loops
modifier|*
name|loops
parameter_list|)
block|{
name|bool
name|changed
init|=
name|false
decl_stmt|;
name|struct
name|loop
modifier|*
name|loop
decl_stmt|;
for|for
control|(
name|loop
operator|=
name|loops
operator|->
name|tree_root
operator|->
name|inner
init|;
name|loop
condition|;
name|loop
operator|=
name|loop
operator|->
name|next
control|)
name|try_remove_empty_loop
argument_list|(
name|loop
argument_list|,
operator|&
name|changed
argument_list|)
expr_stmt|;
if|if
condition|(
name|changed
condition|)
block|{
name|scev_reset
argument_list|()
expr_stmt|;
return|return
name|TODO_cleanup_cfg
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

end_unit

