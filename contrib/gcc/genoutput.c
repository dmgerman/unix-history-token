begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Generate code from to output assembler insns as recognized from rtl.    Copyright (C) 1987, 88, 92, 94-95, 97-98, 1999 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* This program reads the machine description for the compiler target machine    and produces a file containing these things:     1. An array of strings `insn_template' which is indexed by insn code number    and contains the template for output of that insn,     2. An array of functions `insn_outfun' which, indexed by the insn code    number, gives the function that returns a template to use for output of    that insn.  This is used only in the cases where the template is not    constant.  These cases are specified by a * or @ at the beginning of the    template string in the machine description.  They are identified for the    sake of other parts of the compiler by a zero element in `insn_template'.       3. An array of functions `insn_gen_function' which, indexed    by insn code number, gives the function to generate a body    for that pattern, given operands as arguments.     4. An array of strings `insn_name' which, indexed by insn code number,    gives the name for that pattern.  Nameless patterns are given a name.     5. An array of ints `insn_n_operands' which is indexed by insn code number    and contains the number of distinct operands in the pattern for that insn,     6. An array of ints `insn_n_dups' which is indexed by insn code number    and contains the number of match_dup's that appear in the insn's pattern.    This says how many elements of `recog_dup_loc' are significant    after an insn has been recognized.     7. An array of arrays of operand constraint strings,    `insn_operand_constraint',    indexed first by insn code number and second by operand number,    containing the constraint for that operand.     This array is generated only if register constraints appear in     match_operand rtx's.     8. An array of arrays of chars which indicate which operands of    which insn patterns appear within ADDRESS rtx's.  This array is    called `insn_operand_address_p' and is generated only if there    are *no* register constraints in the match_operand rtx's.     9. An array of arrays of machine modes, `insn_operand_mode',    indexed first by insn code number and second by operand number,    containing the machine mode that that operand is supposed to have.    Also `insn_operand_strict_low', which is nonzero for operands    contained in a STRICT_LOW_PART.     10. An array of arrays of int-valued functions, `insn_operand_predicate',    indexed first by insn code number and second by operand number,    containing the match_operand predicate for this operand.     11. An array of ints, `insn_n_alternatives', that gives the number    of alternatives in the constraints of each pattern.  The code number of an insn is simply its position in the machine description; code numbers are assigned sequentially to entries in the description, starting with code number 0.  Thus, the following entry in the machine description      (define_insn "clrdf"       [(set (match_operand:DF 0 "general_operand" "") 	    (const_int 0))]       ""       "clrd %0")  assuming it is the 25th entry present, would cause insn_template[24] to be "clrd %0", and insn_n_operands[24] to be 1. It would not make an case in output_insn_hairy because the template given in the entry is a constant (it does not start with `*').  */
end_comment

begin_escape
end_escape

begin_include
include|#
directive|include
file|"hconfig.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_comment
comment|/* No instruction can have more operands than this.    Sorry for this arbitrary limit, but what machine will    have an instruction with this many operands?  */
end_comment

begin_define
define|#
directive|define
name|MAX_MAX_OPERANDS
value|40
end_define

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|obstack
modifier|*
name|rtl_obstack
init|=
operator|&
name|obstack
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|obstack_chunk_alloc
value|xmalloc
end_define

begin_define
define|#
directive|define
name|obstack_chunk_free
value|free
end_define

begin_decl_stmt
name|void
name|fatal
name|PVPROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
operator|...
operator|)
argument_list|)
name|ATTRIBUTE_PRINTF_1
name|ATTRIBUTE_NORETURN
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|fancy_abort
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
name|ATTRIBUTE_NORETURN
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|error
name|PVPROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
operator|...
operator|)
argument_list|)
name|ATTRIBUTE_PRINTF_1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|n_occurrences
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Define this so we can link with print-rtl.o to get debug_rtx function.  */
end_comment

begin_decl_stmt
name|char
modifier|*
modifier|*
name|insn_name_ptr
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* insns in the machine description are assigned sequential code numbers    that are used by insn-recog.c (produced by genrecog) to communicate    to insn-output.c (produced by this program).  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|next_code_number
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This counts all definitions in the md file,    for the sake of error messages.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|next_index_number
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Record in this chain all information that we will output,    associated with the code number of the insn.  */
end_comment

begin_struct
struct|struct
name|data
block|{
name|int
name|code_number
decl_stmt|;
name|int
name|index_number
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|template
decl_stmt|;
comment|/* string such as "movl %1,%0" */
name|int
name|n_operands
decl_stmt|;
comment|/* Number of operands this insn recognizes */
name|int
name|n_dups
decl_stmt|;
comment|/* Number times match_dup appears in pattern */
name|int
name|n_alternatives
decl_stmt|;
comment|/* Number of alternatives in each constraint */
name|struct
name|data
modifier|*
name|next
decl_stmt|;
name|char
modifier|*
name|constraints
index|[
name|MAX_MAX_OPERANDS
index|]
decl_stmt|;
comment|/* Number of alternatives in constraints of operand N.  */
name|int
name|op_n_alternatives
index|[
name|MAX_MAX_OPERANDS
index|]
decl_stmt|;
name|char
modifier|*
name|predicates
index|[
name|MAX_MAX_OPERANDS
index|]
decl_stmt|;
name|char
name|address_p
index|[
name|MAX_MAX_OPERANDS
index|]
decl_stmt|;
name|enum
name|machine_mode
name|modes
index|[
name|MAX_MAX_OPERANDS
index|]
decl_stmt|;
name|char
name|strict_low
index|[
name|MAX_MAX_OPERANDS
index|]
decl_stmt|;
name|char
name|outfun
decl_stmt|;
comment|/* Nonzero means this has an output function */
block|}
struct|;
end_struct

begin_comment
comment|/* This variable points to the first link in the chain.  */
end_comment

begin_decl_stmt
name|struct
name|data
modifier|*
name|insn_data
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer to the last link in the chain, so new elements    can be added at the end.  */
end_comment

begin_decl_stmt
name|struct
name|data
modifier|*
name|end_of_insn_data
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if any match_operand has a constraint string;    implies that REGISTER_CONSTRAINTS will be defined    for this machine description.  */
end_comment

begin_decl_stmt
name|int
name|have_constraints
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if some error has occurred.  We will make all errors fatal, but    might as well continue until we see all of them.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|have_error
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|char
modifier|*
name|name_for_index
name|PROTO
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_prologue
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_epilogue
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|scan_operands
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|process_template
name|PROTO
argument_list|(
operator|(
expr|struct
name|data
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|validate_insn_alternatives
name|PROTO
argument_list|(
operator|(
expr|struct
name|data
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_insn
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_peephole
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_expand
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_split
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|n_occurrences
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_function
specifier|static
name|char
modifier|*
name|name_for_index
parameter_list|(
name|index
parameter_list|)
name|int
name|index
decl_stmt|;
block|{
specifier|static
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
name|struct
name|data
modifier|*
name|i
decl_stmt|,
modifier|*
name|last_named
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|i
operator|=
name|insn_data
init|;
name|i
condition|;
name|i
operator|=
name|i
operator|->
name|next
control|)
block|{
if|if
condition|(
name|i
operator|->
name|index_number
operator|==
name|index
condition|)
return|return
name|i
operator|->
name|name
return|;
if|if
condition|(
name|i
operator|->
name|name
condition|)
name|last_named
operator|=
name|i
expr_stmt|;
block|}
if|if
condition|(
name|last_named
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s+%d"
argument_list|,
name|last_named
operator|->
name|name
argument_list|,
name|index
operator|-
name|last_named
operator|->
name|index_number
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"insn %d"
argument_list|,
name|index
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_prologue
parameter_list|()
block|{
name|printf
argument_list|(
literal|"/* Generated automatically by the program `genoutput'\n\ from the machine description file `md'.  */\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"config.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"system.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"flags.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"rtl.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"regs.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"hard-reg-set.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"real.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"insn-config.h\"\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"conditions.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"insn-flags.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"insn-attr.h\"\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"insn-codes.h\"\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"recog.h\"\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"output.h\"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_epilogue
parameter_list|()
block|{
specifier|register
name|struct
name|data
modifier|*
name|d
decl_stmt|;
name|printf
argument_list|(
literal|"\nconst char * const insn_template[] =\n  {\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|d
operator|=
name|insn_data
init|;
name|d
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
block|{
if|if
condition|(
name|d
operator|->
name|template
condition|)
name|printf
argument_list|(
literal|"    \"%s\",\n"
argument_list|,
name|d
operator|->
name|template
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"    0,\n"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"  };\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\nconst char *(*const insn_outfun[])() =\n  {\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|d
operator|=
name|insn_data
init|;
name|d
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
block|{
if|if
condition|(
name|d
operator|->
name|outfun
condition|)
name|printf
argument_list|(
literal|"    output_%d,\n"
argument_list|,
name|d
operator|->
name|code_number
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"    0,\n"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"  };\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\nrtx (*const insn_gen_function[]) () =\n  {\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|d
operator|=
name|insn_data
init|;
name|d
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
block|{
if|if
condition|(
name|d
operator|->
name|name
operator|&&
name|d
operator|->
name|name
index|[
literal|0
index|]
operator|!=
literal|'*'
condition|)
name|printf
argument_list|(
literal|"    gen_%s,\n"
argument_list|,
name|d
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"    0,\n"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"  };\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\nconst char *insn_name[] =\n  {\n"
argument_list|)
expr_stmt|;
block|{
name|int
name|offset
init|=
literal|0
decl_stmt|;
name|int
name|next
decl_stmt|;
name|char
modifier|*
name|last_name
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|next_name
init|=
literal|0
decl_stmt|;
specifier|register
name|struct
name|data
modifier|*
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
name|insn_data
operator|,
name|next
operator|=
literal|1
init|;
name|n
condition|;
name|n
operator|=
name|n
operator|->
name|next
operator|,
name|next
operator|++
control|)
if|if
condition|(
name|n
operator|->
name|name
condition|)
block|{
name|next_name
operator|=
name|n
operator|->
name|name
expr_stmt|;
break|break;
block|}
for|for
control|(
name|d
operator|=
name|insn_data
init|;
name|d
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
block|{
if|if
condition|(
name|d
operator|->
name|name
condition|)
block|{
name|printf
argument_list|(
literal|"    \"%s\",\n"
argument_list|,
name|d
operator|->
name|name
argument_list|)
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
name|last_name
operator|=
name|d
operator|->
name|name
expr_stmt|;
name|next_name
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|n
operator|=
name|d
operator|->
name|next
operator|,
name|next
operator|=
literal|1
init|;
name|n
condition|;
name|n
operator|=
name|n
operator|->
name|next
operator|,
name|next
operator|++
control|)
if|if
condition|(
name|n
operator|->
name|name
condition|)
block|{
name|next_name
operator|=
name|n
operator|->
name|name
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|offset
operator|++
expr_stmt|;
if|if
condition|(
name|next_name
operator|&&
operator|(
name|last_name
operator|==
literal|0
operator|||
name|offset
operator|>
name|next
operator|/
literal|2
operator|)
condition|)
name|printf
argument_list|(
literal|"    \"%s-%d\",\n"
argument_list|,
name|next_name
argument_list|,
name|next
operator|-
name|offset
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"    \"%s+%d\",\n"
argument_list|,
name|last_name
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|printf
argument_list|(
literal|"  };\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"const char **insn_name_ptr = insn_name;\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\nconst int insn_n_operands[] =\n  {\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|d
operator|=
name|insn_data
init|;
name|d
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
name|printf
argument_list|(
literal|"    %d,\n"
argument_list|,
name|d
operator|->
name|n_operands
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  };\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\nconst int insn_n_dups[] =\n  {\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|d
operator|=
name|insn_data
init|;
name|d
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
name|printf
argument_list|(
literal|"    %d,\n"
argument_list|,
name|d
operator|->
name|n_dups
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  };\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|have_constraints
condition|)
block|{
name|printf
argument_list|(
literal|"\nconst char *const insn_operand_constraint[][MAX_RECOG_OPERANDS] =\n  {\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|d
operator|=
name|insn_data
init|;
name|d
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"    {"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|n_operands
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|d
operator|->
name|constraints
index|[
name|i
index|]
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|" \"\","
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|" \"%s\","
argument_list|,
name|d
operator|->
name|constraints
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|d
operator|->
name|n_operands
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|" 0"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" },\n"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"  };\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"\nconst char insn_operand_address_p[][MAX_RECOG_OPERANDS] =\n  {\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|d
operator|=
name|insn_data
init|;
name|d
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"    {"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|n_operands
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|" %d,"
argument_list|,
name|d
operator|->
name|address_p
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|n_operands
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|" 0"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" },\n"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"  };\n"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\nconst enum machine_mode insn_operand_mode[][MAX_RECOG_OPERANDS] =\n  {\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|d
operator|=
name|insn_data
init|;
name|d
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"    {"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|n_operands
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|" %smode,"
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|d
operator|->
name|modes
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|n_operands
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|" VOIDmode"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" },\n"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"  };\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\nconst char insn_operand_strict_low[][MAX_RECOG_OPERANDS] =\n  {\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|d
operator|=
name|insn_data
init|;
name|d
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"    {"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|n_operands
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|" %d,"
argument_list|,
name|d
operator|->
name|strict_low
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|n_operands
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|" 0"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" },\n"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"  };\n"
argument_list|)
expr_stmt|;
block|{
comment|/* We need to define all predicates used.  Keep a list of those we        have defined so far.  There normally aren't very many predicates used,        so a linked list should be fast enough.  */
struct|struct
name|predicate
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|predicate
modifier|*
name|next
decl_stmt|;
block|}
modifier|*
name|predicates
init|=
literal|0
struct|;
name|struct
name|predicate
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|d
operator|=
name|insn_data
init|;
name|d
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|n_operands
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|d
operator|->
name|predicates
index|[
name|i
index|]
operator|&&
name|d
operator|->
name|predicates
index|[
name|i
index|]
index|[
literal|0
index|]
condition|)
block|{
for|for
control|(
name|p
operator|=
name|predicates
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
operator|->
name|name
argument_list|,
name|d
operator|->
name|predicates
index|[
name|i
index|]
argument_list|)
condition|)
break|break;
if|if
condition|(
name|p
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"extern int %s ();\n"
argument_list|,
name|d
operator|->
name|predicates
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
expr|struct
name|predicate
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|predicate
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|name
operator|=
name|d
operator|->
name|predicates
index|[
name|i
index|]
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|predicates
expr_stmt|;
name|predicates
operator|=
name|p
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"\nint (*const insn_operand_predicate[][MAX_RECOG_OPERANDS])() =\n  {\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|d
operator|=
name|insn_data
init|;
name|d
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
block|{
name|printf
argument_list|(
literal|"    {"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|n_operands
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|" %s,"
argument_list|,
operator|(
operator|(
name|d
operator|->
name|predicates
index|[
name|i
index|]
operator|&&
name|d
operator|->
name|predicates
index|[
name|i
index|]
index|[
literal|0
index|]
operator|)
condition|?
name|d
operator|->
name|predicates
index|[
name|i
index|]
else|:
literal|"0"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|n_operands
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|" 0"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" },\n"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"  };\n"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\nconst int insn_n_alternatives[] =\n  {\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|d
operator|=
name|insn_data
init|;
name|d
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
name|printf
argument_list|(
literal|"    %d,\n"
argument_list|,
name|d
operator|->
name|n_alternatives
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  };\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* scan_operands (X) stores in max_opno the largest operand    number present in X, if that is larger than the previous    value of max_opno.  It stores all the constraints in `constraints'    and all the machine modes in `modes'.     THIS_ADDRESS_P is nonzero if the containing rtx was an ADDRESS.    THIS_STRICT_LOW is nonzero if the containing rtx was a STRICT_LOW_PART.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|max_opno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|num_dups
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|constraints
index|[
name|MAX_MAX_OPERANDS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|op_n_alternatives
index|[
name|MAX_MAX_OPERANDS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|predicates
index|[
name|MAX_MAX_OPERANDS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|address_p
index|[
name|MAX_MAX_OPERANDS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|enum
name|machine_mode
name|modes
index|[
name|MAX_MAX_OPERANDS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|strict_low
index|[
name|MAX_MAX_OPERANDS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|seen
index|[
name|MAX_MAX_OPERANDS
index|]
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|scan_operands
parameter_list|(
name|part
parameter_list|,
name|this_address_p
parameter_list|,
name|this_strict_low
parameter_list|)
name|rtx
name|part
decl_stmt|;
name|int
name|this_address_p
decl_stmt|;
name|int
name|this_strict_low
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|register
name|char
modifier|*
name|format_ptr
decl_stmt|;
name|int
name|opno
decl_stmt|;
if|if
condition|(
name|part
operator|==
literal|0
condition|)
return|return;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|part
argument_list|)
condition|)
block|{
case|case
name|MATCH_OPERAND
case|:
name|opno
operator|=
name|XINT
argument_list|(
name|part
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|opno
operator|>
name|max_opno
condition|)
name|max_opno
operator|=
name|opno
expr_stmt|;
if|if
condition|(
name|max_opno
operator|>=
name|MAX_MAX_OPERANDS
condition|)
block|{
name|error
argument_list|(
literal|"Too many operands (%d) in definition %s.\n"
argument_list|,
name|max_opno
operator|+
literal|1
argument_list|,
name|name_for_index
argument_list|(
name|next_index_number
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|seen
index|[
name|opno
index|]
condition|)
name|error
argument_list|(
literal|"Definition %s specified operand number %d more than once.\n"
argument_list|,
name|name_for_index
argument_list|(
name|next_index_number
argument_list|)
argument_list|,
name|opno
argument_list|)
expr_stmt|;
name|seen
index|[
name|opno
index|]
operator|=
literal|1
expr_stmt|;
name|modes
index|[
name|opno
index|]
operator|=
name|GET_MODE
argument_list|(
name|part
argument_list|)
expr_stmt|;
name|strict_low
index|[
name|opno
index|]
operator|=
name|this_strict_low
expr_stmt|;
name|predicates
index|[
name|opno
index|]
operator|=
name|XSTR
argument_list|(
name|part
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|constraints
index|[
name|opno
index|]
operator|=
name|XSTR
argument_list|(
name|part
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|XSTR
argument_list|(
name|part
argument_list|,
literal|2
argument_list|)
operator|!=
literal|0
operator|&&
operator|*
name|XSTR
argument_list|(
name|part
argument_list|,
literal|2
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|op_n_alternatives
index|[
name|opno
index|]
operator|=
name|n_occurrences
argument_list|(
literal|','
argument_list|,
name|XSTR
argument_list|(
name|part
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|+
literal|1
expr_stmt|;
name|have_constraints
operator|=
literal|1
expr_stmt|;
block|}
name|address_p
index|[
name|opno
index|]
operator|=
name|this_address_p
expr_stmt|;
return|return;
case|case
name|MATCH_SCRATCH
case|:
name|opno
operator|=
name|XINT
argument_list|(
name|part
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|opno
operator|>
name|max_opno
condition|)
name|max_opno
operator|=
name|opno
expr_stmt|;
if|if
condition|(
name|max_opno
operator|>=
name|MAX_MAX_OPERANDS
condition|)
block|{
name|error
argument_list|(
literal|"Too many operands (%d) in definition %s.\n"
argument_list|,
name|max_opno
operator|+
literal|1
argument_list|,
name|name_for_index
argument_list|(
name|next_index_number
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|seen
index|[
name|opno
index|]
condition|)
name|error
argument_list|(
literal|"Definition %s specified operand number %d more than once.\n"
argument_list|,
name|name_for_index
argument_list|(
name|next_index_number
argument_list|)
argument_list|,
name|opno
argument_list|)
expr_stmt|;
name|seen
index|[
name|opno
index|]
operator|=
literal|1
expr_stmt|;
name|modes
index|[
name|opno
index|]
operator|=
name|GET_MODE
argument_list|(
name|part
argument_list|)
expr_stmt|;
name|strict_low
index|[
name|opno
index|]
operator|=
literal|0
expr_stmt|;
name|predicates
index|[
name|opno
index|]
operator|=
literal|"scratch_operand"
expr_stmt|;
name|constraints
index|[
name|opno
index|]
operator|=
name|XSTR
argument_list|(
name|part
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|XSTR
argument_list|(
name|part
argument_list|,
literal|1
argument_list|)
operator|!=
literal|0
operator|&&
operator|*
name|XSTR
argument_list|(
name|part
argument_list|,
literal|1
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|op_n_alternatives
index|[
name|opno
index|]
operator|=
name|n_occurrences
argument_list|(
literal|','
argument_list|,
name|XSTR
argument_list|(
name|part
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|+
literal|1
expr_stmt|;
name|have_constraints
operator|=
literal|1
expr_stmt|;
block|}
name|address_p
index|[
name|opno
index|]
operator|=
literal|0
expr_stmt|;
return|return;
case|case
name|MATCH_OPERATOR
case|:
case|case
name|MATCH_PARALLEL
case|:
name|opno
operator|=
name|XINT
argument_list|(
name|part
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|opno
operator|>
name|max_opno
condition|)
name|max_opno
operator|=
name|opno
expr_stmt|;
if|if
condition|(
name|max_opno
operator|>=
name|MAX_MAX_OPERANDS
condition|)
block|{
name|error
argument_list|(
literal|"Too many operands (%d) in definition %s.\n"
argument_list|,
name|max_opno
operator|+
literal|1
argument_list|,
name|name_for_index
argument_list|(
name|next_index_number
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|seen
index|[
name|opno
index|]
condition|)
name|error
argument_list|(
literal|"Definition %s specified operand number %d more than once.\n"
argument_list|,
name|name_for_index
argument_list|(
name|next_index_number
argument_list|)
argument_list|,
name|opno
argument_list|)
expr_stmt|;
name|seen
index|[
name|opno
index|]
operator|=
literal|1
expr_stmt|;
name|modes
index|[
name|opno
index|]
operator|=
name|GET_MODE
argument_list|(
name|part
argument_list|)
expr_stmt|;
name|strict_low
index|[
name|opno
index|]
operator|=
literal|0
expr_stmt|;
name|predicates
index|[
name|opno
index|]
operator|=
name|XSTR
argument_list|(
name|part
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|constraints
index|[
name|opno
index|]
operator|=
literal|0
expr_stmt|;
name|address_p
index|[
name|opno
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|part
argument_list|,
literal|2
argument_list|)
condition|;
name|i
operator|++
control|)
name|scan_operands
argument_list|(
name|XVECEXP
argument_list|(
name|part
argument_list|,
literal|2
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
case|case
name|MATCH_DUP
case|:
case|case
name|MATCH_OP_DUP
case|:
case|case
name|MATCH_PAR_DUP
case|:
operator|++
name|num_dups
expr_stmt|;
return|return;
case|case
name|ADDRESS
case|:
name|scan_operands
argument_list|(
name|XEXP
argument_list|(
name|part
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
case|case
name|STRICT_LOW_PART
case|:
name|scan_operands
argument_list|(
name|XEXP
argument_list|(
name|part
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
default|default:
break|break;
block|}
name|format_ptr
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|part
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|part
argument_list|)
argument_list|)
condition|;
name|i
operator|++
control|)
switch|switch
condition|(
operator|*
name|format_ptr
operator|++
condition|)
block|{
case|case
literal|'e'
case|:
case|case
literal|'u'
case|:
name|scan_operands
argument_list|(
name|XEXP
argument_list|(
name|part
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
if|if
condition|(
name|XVEC
argument_list|(
name|part
argument_list|,
name|i
argument_list|)
operator|!=
name|NULL
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|part
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|scan_operands
argument_list|(
name|XVECEXP
argument_list|(
name|part
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Process an assembler template from a define_insn or a define_peephole.    It is either the assembler code template, a list of assembler code    templates, or C code to generate the assembler code template.  */
end_comment

begin_function
specifier|static
name|void
name|process_template
parameter_list|(
name|d
parameter_list|,
name|template
parameter_list|)
name|struct
name|data
modifier|*
name|d
decl_stmt|;
name|char
modifier|*
name|template
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
comment|/* We need to consider only the instructions whose assembler code template      starts with a * or @.  These are the ones where C code is run to decide      on a template to use.  So for all others just return now.  */
if|if
condition|(
name|template
index|[
literal|0
index|]
operator|!=
literal|'*'
operator|&&
name|template
index|[
literal|0
index|]
operator|!=
literal|'@'
condition|)
block|{
name|d
operator|->
name|template
operator|=
name|template
expr_stmt|;
name|d
operator|->
name|outfun
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|d
operator|->
name|template
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|outfun
operator|=
literal|1
expr_stmt|;
name|printf
argument_list|(
literal|"\nstatic const char *\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"output_%d (operands, insn)\n"
argument_list|,
name|d
operator|->
name|code_number
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"     rtx *operands ATTRIBUTE_UNUSED;\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"     rtx insn ATTRIBUTE_UNUSED;\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"{\n"
argument_list|)
expr_stmt|;
comment|/* If the assembler code template starts with a @ it is a newline-separated      list of assembler code templates, one for each alternative.  So produce      a routine to select the correct one.  */
if|if
condition|(
name|template
index|[
literal|0
index|]
operator|==
literal|'@'
condition|)
block|{
name|printf
argument_list|(
literal|"  static const char *const strings_%d[] = {\n"
argument_list|,
name|d
operator|->
name|code_number
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|cp
operator|=
operator|&
name|template
index|[
literal|1
index|]
init|;
operator|*
name|cp
condition|;
control|)
block|{
while|while
condition|(
operator|*
name|cp
operator|==
literal|'\n'
operator|||
operator|*
name|cp
operator|==
literal|' '
operator|||
operator|*
name|cp
operator|==
literal|'\t'
condition|)
name|cp
operator|++
expr_stmt|;
name|printf
argument_list|(
literal|"    \""
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|!=
literal|'\n'
operator|&&
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
block|{
name|putchar
argument_list|(
operator|*
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|++
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\",\n"
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"  };\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  return strings_%d[which_alternative];\n"
argument_list|,
name|d
operator|->
name|code_number
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|d
operator|->
name|n_alternatives
condition|)
name|fatal
argument_list|(
literal|"Insn pattern %d has %d alternatives but %d assembler choices"
argument_list|,
name|d
operator|->
name|index_number
argument_list|,
name|d
operator|->
name|n_alternatives
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* The following is done in a funny way to get around problems in 	  VAX-11 "C" on VMS.  It is the equivalent of: 		printf ("%s\n",&template[1])); */
name|cp
operator|=
operator|&
name|template
index|[
literal|1
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|cp
condition|)
block|{
name|putchar
argument_list|(
operator|*
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|++
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"}\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Check insn D for consistency in number of constraint alternatives.  */
end_comment

begin_function
specifier|static
name|void
name|validate_insn_alternatives
parameter_list|(
name|d
parameter_list|)
name|struct
name|data
modifier|*
name|d
decl_stmt|;
block|{
specifier|register
name|int
name|n
init|=
literal|0
decl_stmt|,
name|start
decl_stmt|;
comment|/* Make sure all the operands have the same number of      alternatives in their constraints.      Let N be that number.  */
for|for
control|(
name|start
operator|=
literal|0
init|;
name|start
operator|<
name|d
operator|->
name|n_operands
condition|;
name|start
operator|++
control|)
if|if
condition|(
name|d
operator|->
name|op_n_alternatives
index|[
name|start
index|]
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|n
operator|==
literal|0
condition|)
name|n
operator|=
name|d
operator|->
name|op_n_alternatives
index|[
name|start
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|n
operator|!=
name|d
operator|->
name|op_n_alternatives
index|[
name|start
index|]
condition|)
name|error
argument_list|(
literal|"wrong number of alternatives in operand %d of insn %s"
argument_list|,
name|start
argument_list|,
name|name_for_index
argument_list|(
name|d
operator|->
name|index_number
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Record the insn's overall number of alternatives.  */
name|d
operator|->
name|n_alternatives
operator|=
name|n
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Look at a define_insn just read.  Assign its code number.    Record on insn_data the template and the number of arguments.    If the insn has a hairy output action, output a function for now.  */
end_comment

begin_function
specifier|static
name|void
name|gen_insn
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
specifier|register
name|struct
name|data
modifier|*
name|d
init|=
operator|(
expr|struct
name|data
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|data
argument_list|)
argument_list|)
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|d
operator|->
name|code_number
operator|=
name|next_code_number
operator|++
expr_stmt|;
name|d
operator|->
name|index_number
operator|=
name|next_index_number
expr_stmt|;
if|if
condition|(
name|XSTR
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|)
index|[
literal|0
index|]
condition|)
name|d
operator|->
name|name
operator|=
name|XSTR
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|d
operator|->
name|name
operator|=
literal|0
expr_stmt|;
comment|/* Build up the list in the same order as the insns are seen      in the machine description.  */
name|d
operator|->
name|next
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|end_of_insn_data
condition|)
name|end_of_insn_data
operator|->
name|next
operator|=
name|d
expr_stmt|;
else|else
name|insn_data
operator|=
name|d
expr_stmt|;
name|end_of_insn_data
operator|=
name|d
expr_stmt|;
name|max_opno
operator|=
operator|-
literal|1
expr_stmt|;
name|num_dups
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
name|constraints
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|constraints
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|op_n_alternatives
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|op_n_alternatives
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|predicates
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|predicates
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|address_p
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|address_p
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|modes
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|modes
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|strict_low
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|strict_low
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|seen
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|seen
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|)
condition|;
name|i
operator|++
control|)
name|scan_operands
argument_list|(
name|XVECEXP
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|d
operator|->
name|n_operands
operator|=
name|max_opno
operator|+
literal|1
expr_stmt|;
name|d
operator|->
name|n_dups
operator|=
name|num_dups
expr_stmt|;
name|memcpy
argument_list|(
name|d
operator|->
name|constraints
argument_list|,
name|constraints
argument_list|,
sizeof|sizeof
name|constraints
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|d
operator|->
name|op_n_alternatives
argument_list|,
name|op_n_alternatives
argument_list|,
sizeof|sizeof
name|op_n_alternatives
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|d
operator|->
name|predicates
argument_list|,
name|predicates
argument_list|,
sizeof|sizeof
name|predicates
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|d
operator|->
name|address_p
argument_list|,
name|address_p
argument_list|,
sizeof|sizeof
name|address_p
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|d
operator|->
name|modes
argument_list|,
name|modes
argument_list|,
sizeof|sizeof
name|modes
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|d
operator|->
name|strict_low
argument_list|,
name|strict_low
argument_list|,
sizeof|sizeof
name|strict_low
argument_list|)
expr_stmt|;
name|validate_insn_alternatives
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|process_template
argument_list|(
name|d
argument_list|,
name|XSTR
argument_list|(
name|insn
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Look at a define_peephole just read.  Assign its code number.    Record on insn_data the template and the number of arguments.    If the insn has a hairy output action, output it now.  */
end_comment

begin_function
specifier|static
name|void
name|gen_peephole
parameter_list|(
name|peep
parameter_list|)
name|rtx
name|peep
decl_stmt|;
block|{
specifier|register
name|struct
name|data
modifier|*
name|d
init|=
operator|(
expr|struct
name|data
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|data
argument_list|)
argument_list|)
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|d
operator|->
name|code_number
operator|=
name|next_code_number
operator|++
expr_stmt|;
name|d
operator|->
name|index_number
operator|=
name|next_index_number
expr_stmt|;
name|d
operator|->
name|name
operator|=
literal|0
expr_stmt|;
comment|/* Build up the list in the same order as the insns are seen      in the machine description.  */
name|d
operator|->
name|next
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|end_of_insn_data
condition|)
name|end_of_insn_data
operator|->
name|next
operator|=
name|d
expr_stmt|;
else|else
name|insn_data
operator|=
name|d
expr_stmt|;
name|end_of_insn_data
operator|=
name|d
expr_stmt|;
name|max_opno
operator|=
operator|-
literal|1
expr_stmt|;
name|memset
argument_list|(
name|constraints
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|constraints
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|op_n_alternatives
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|op_n_alternatives
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|predicates
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|predicates
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|address_p
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|address_p
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|modes
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|modes
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|strict_low
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|strict_low
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|seen
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|seen
argument_list|)
expr_stmt|;
comment|/* Get the number of operands by scanning all the      patterns of the peephole optimizer.      But ignore all the rest of the information thus obtained.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|peep
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
name|scan_operands
argument_list|(
name|XVECEXP
argument_list|(
name|peep
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|d
operator|->
name|n_operands
operator|=
name|max_opno
operator|+
literal|1
expr_stmt|;
name|d
operator|->
name|n_dups
operator|=
literal|0
expr_stmt|;
name|memcpy
argument_list|(
name|d
operator|->
name|constraints
argument_list|,
name|constraints
argument_list|,
sizeof|sizeof
name|constraints
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|d
operator|->
name|op_n_alternatives
argument_list|,
name|op_n_alternatives
argument_list|,
sizeof|sizeof
name|op_n_alternatives
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|d
operator|->
name|predicates
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|predicates
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|d
operator|->
name|address_p
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|address_p
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|d
operator|->
name|modes
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|modes
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|d
operator|->
name|strict_low
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|strict_low
argument_list|)
expr_stmt|;
name|validate_insn_alternatives
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|process_template
argument_list|(
name|d
argument_list|,
name|XSTR
argument_list|(
name|peep
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Process a define_expand just read.  Assign its code number,    only for the purposes of `insn_gen_function'.  */
end_comment

begin_function
specifier|static
name|void
name|gen_expand
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
specifier|register
name|struct
name|data
modifier|*
name|d
init|=
operator|(
expr|struct
name|data
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|data
argument_list|)
argument_list|)
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|d
operator|->
name|code_number
operator|=
name|next_code_number
operator|++
expr_stmt|;
name|d
operator|->
name|index_number
operator|=
name|next_index_number
expr_stmt|;
if|if
condition|(
name|XSTR
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|)
index|[
literal|0
index|]
condition|)
name|d
operator|->
name|name
operator|=
name|XSTR
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|d
operator|->
name|name
operator|=
literal|0
expr_stmt|;
comment|/* Build up the list in the same order as the insns are seen      in the machine description.  */
name|d
operator|->
name|next
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|end_of_insn_data
condition|)
name|end_of_insn_data
operator|->
name|next
operator|=
name|d
expr_stmt|;
else|else
name|insn_data
operator|=
name|d
expr_stmt|;
name|end_of_insn_data
operator|=
name|d
expr_stmt|;
name|max_opno
operator|=
operator|-
literal|1
expr_stmt|;
name|num_dups
operator|=
literal|0
expr_stmt|;
comment|/* Scan the operands to get the specified predicates and modes,      since expand_binop needs to know them.  */
name|memset
argument_list|(
name|constraints
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|constraints
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|op_n_alternatives
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|op_n_alternatives
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|predicates
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|predicates
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|address_p
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|address_p
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|modes
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|modes
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|strict_low
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|strict_low
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|seen
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|seen
argument_list|)
expr_stmt|;
if|if
condition|(
name|XVEC
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|)
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|)
condition|;
name|i
operator|++
control|)
name|scan_operands
argument_list|(
name|XVECEXP
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|d
operator|->
name|n_operands
operator|=
name|max_opno
operator|+
literal|1
expr_stmt|;
name|d
operator|->
name|n_dups
operator|=
name|num_dups
expr_stmt|;
name|memcpy
argument_list|(
name|d
operator|->
name|constraints
argument_list|,
name|constraints
argument_list|,
sizeof|sizeof
name|constraints
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|d
operator|->
name|op_n_alternatives
argument_list|,
name|op_n_alternatives
argument_list|,
sizeof|sizeof
name|op_n_alternatives
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|d
operator|->
name|predicates
argument_list|,
name|predicates
argument_list|,
sizeof|sizeof
name|predicates
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|d
operator|->
name|address_p
argument_list|,
name|address_p
argument_list|,
sizeof|sizeof
name|address_p
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|d
operator|->
name|modes
argument_list|,
name|modes
argument_list|,
sizeof|sizeof
name|modes
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|d
operator|->
name|strict_low
argument_list|,
name|strict_low
argument_list|,
sizeof|sizeof
name|strict_low
argument_list|)
expr_stmt|;
name|d
operator|->
name|template
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|outfun
operator|=
literal|0
expr_stmt|;
name|validate_insn_alternatives
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Process a define_split just read.  Assign its code number,    only for reasons of consistency and to simplify genrecog.  */
end_comment

begin_function
specifier|static
name|void
name|gen_split
parameter_list|(
name|split
parameter_list|)
name|rtx
name|split
decl_stmt|;
block|{
specifier|register
name|struct
name|data
modifier|*
name|d
init|=
operator|(
expr|struct
name|data
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|data
argument_list|)
argument_list|)
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|d
operator|->
name|code_number
operator|=
name|next_code_number
operator|++
expr_stmt|;
name|d
operator|->
name|index_number
operator|=
name|next_index_number
expr_stmt|;
name|d
operator|->
name|name
operator|=
literal|0
expr_stmt|;
comment|/* Build up the list in the same order as the insns are seen      in the machine description.  */
name|d
operator|->
name|next
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|end_of_insn_data
condition|)
name|end_of_insn_data
operator|->
name|next
operator|=
name|d
expr_stmt|;
else|else
name|insn_data
operator|=
name|d
expr_stmt|;
name|end_of_insn_data
operator|=
name|d
expr_stmt|;
name|max_opno
operator|=
operator|-
literal|1
expr_stmt|;
name|num_dups
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
name|constraints
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|constraints
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|op_n_alternatives
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|op_n_alternatives
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|predicates
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|predicates
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|address_p
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|address_p
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|modes
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|modes
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|strict_low
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|strict_low
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|seen
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|seen
argument_list|)
expr_stmt|;
comment|/* Get the number of operands by scanning all the      patterns of the split patterns.      But ignore all the rest of the information thus obtained.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|split
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
name|scan_operands
argument_list|(
name|XVECEXP
argument_list|(
name|split
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|d
operator|->
name|n_operands
operator|=
name|max_opno
operator|+
literal|1
expr_stmt|;
name|memset
argument_list|(
name|d
operator|->
name|constraints
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|constraints
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|d
operator|->
name|op_n_alternatives
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|op_n_alternatives
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|d
operator|->
name|predicates
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|predicates
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|d
operator|->
name|address_p
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|address_p
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|d
operator|->
name|modes
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|modes
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|d
operator|->
name|strict_low
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|strict_low
argument_list|)
expr_stmt|;
name|d
operator|->
name|n_dups
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|n_alternatives
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|template
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|outfun
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|PTR
name|xmalloc
parameter_list|(
name|size
parameter_list|)
name|size_t
name|size
decl_stmt|;
block|{
specifier|register
name|PTR
name|val
init|=
operator|(
name|PTR
operator|)
name|malloc
argument_list|(
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|==
literal|0
condition|)
name|fatal
argument_list|(
literal|"virtual memory exhausted"
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_function
name|PTR
name|xrealloc
parameter_list|(
name|old
parameter_list|,
name|size
parameter_list|)
name|PTR
name|old
decl_stmt|;
name|size_t
name|size
decl_stmt|;
block|{
specifier|register
name|PTR
name|ptr
decl_stmt|;
if|if
condition|(
name|old
condition|)
name|ptr
operator|=
operator|(
name|PTR
operator|)
name|realloc
argument_list|(
name|old
argument_list|,
name|size
argument_list|)
expr_stmt|;
else|else
name|ptr
operator|=
operator|(
name|PTR
operator|)
name|malloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ptr
condition|)
name|fatal
argument_list|(
literal|"virtual memory exhausted"
argument_list|)
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_decl_stmt
name|void
name|fatal
name|VPROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|format
operator|,
operator|...
operator|)
argument_list|)
block|{
ifndef|#
directive|ifndef
name|ANSI_PROTOTYPES
specifier|const
name|char
modifier|*
name|format
decl_stmt|;
endif|#
directive|endif
name|va_list
name|ap
decl_stmt|;
name|VA_START
argument_list|(
name|ap
argument_list|,
name|format
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|ANSI_PROTOTYPES
name|format
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"genoutput: "
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|format
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|FATAL_EXIT_CODE
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* More 'friendly' abort that prints the line and file.    config.h can #define abort fancy_abort if you like that sort of thing.  */
end_comment

begin_function
name|void
name|fancy_abort
parameter_list|()
block|{
name|fatal
argument_list|(
literal|"Internal gcc abort."
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|error
name|VPROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|format
operator|,
operator|...
operator|)
argument_list|)
block|{
ifndef|#
directive|ifndef
name|ANSI_PROTOTYPES
specifier|const
name|char
modifier|*
name|format
decl_stmt|;
endif|#
directive|endif
name|va_list
name|ap
decl_stmt|;
name|VA_START
argument_list|(
name|ap
argument_list|,
name|format
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|ANSI_PROTOTYPES
name|format
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"genoutput: "
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|format
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|have_error
operator|=
literal|1
expr_stmt|;
block|}
end_decl_stmt

begin_escape
end_escape

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|rtx
name|desc
decl_stmt|;
name|FILE
modifier|*
name|infile
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|obstack_init
argument_list|(
name|rtl_obstack
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|<=
literal|1
condition|)
name|fatal
argument_list|(
literal|"No input file name."
argument_list|)
expr_stmt|;
name|infile
operator|=
name|fopen
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|infile
operator|==
literal|0
condition|)
block|{
name|perror
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|FATAL_EXIT_CODE
argument_list|)
expr_stmt|;
block|}
name|init_rtl
argument_list|()
expr_stmt|;
name|output_prologue
argument_list|()
expr_stmt|;
name|next_code_number
operator|=
literal|0
expr_stmt|;
name|next_index_number
operator|=
literal|0
expr_stmt|;
name|have_constraints
operator|=
literal|0
expr_stmt|;
comment|/* Read the machine description.  */
while|while
condition|(
literal|1
condition|)
block|{
name|c
operator|=
name|read_skip_spaces
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
break|break;
name|ungetc
argument_list|(
name|c
argument_list|,
name|infile
argument_list|)
expr_stmt|;
name|desc
operator|=
name|read_rtx
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|desc
argument_list|)
operator|==
name|DEFINE_INSN
condition|)
name|gen_insn
argument_list|(
name|desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|desc
argument_list|)
operator|==
name|DEFINE_PEEPHOLE
condition|)
name|gen_peephole
argument_list|(
name|desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|desc
argument_list|)
operator|==
name|DEFINE_EXPAND
condition|)
name|gen_expand
argument_list|(
name|desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|desc
argument_list|)
operator|==
name|DEFINE_SPLIT
condition|)
name|gen_split
argument_list|(
name|desc
argument_list|)
expr_stmt|;
name|next_index_number
operator|++
expr_stmt|;
block|}
name|output_epilogue
argument_list|()
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|ferror
argument_list|(
name|stdout
argument_list|)
operator|!=
literal|0
operator|||
name|have_error
condition|?
name|FATAL_EXIT_CODE
else|:
name|SUCCESS_EXIT_CODE
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|n_occurrences
parameter_list|(
name|c
parameter_list|,
name|s
parameter_list|)
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|int
name|n
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
name|n
operator|+=
operator|(
operator|*
name|s
operator|++
operator|==
name|c
operator|)
expr_stmt|;
return|return
name|n
return|;
block|}
end_function

end_unit

