begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Generate code from to output assembler insns as recognized from rtl.    Copyright (C) 1987, 1988, 1992, 1994, 1995, 1997, 1998, 1999, 2000    Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* This program reads the machine description for the compiler target machine    and produces a file containing these things:     1. An array of `struct insn_data', which is indexed by insn code number,    which contains:       a. `name' is the name for that pattern.  Nameless patterns are      given a name.       b. `output' hold either the output template, an array of output      templates, or an output function.       c. `genfun' is the function to generate a body for that pattern,      given operands as arguments.       d. `n_operands' is the number of distinct operands in the pattern      for that insn,       e. `n_dups' is the number of match_dup's that appear in the insn's      pattern.  This says how many elements of `recog_data.dup_loc' are      significant after an insn has been recognized.       f. `n_alternatives' is the number of alternatives in the constraints      of each pattern.       g. `output_format' tells what type of thing `output' is.       h. `operand' is the base of an array of operand data for the insn.     2. An array of `struct insn_operand data', used by `operand' above.       a. `predicate', an int-valued function, is the match_operand predicate      for this operand.       b. `constraint' is the constraint for this operand.  This exists      only if register constraints appear in match_operand rtx's.       c. `address_p' indicates that the operand appears within ADDRESS      rtx's.  This exists only if there are *no* register constraints      in the match_operand rtx's.       d. `mode' is the machine mode that that operand is supposed to have.       e. `strict_low', is nonzero for operands contained in a STRICT_LOW_PART.       f. `eliminable', is nonzero for operands that are matched normally by      MATCH_OPERAND; it is zero for operands that should not be changed during      register elimination such as MATCH_OPERATORs.    The code number of an insn is simply its position in the machine   description; code numbers are assigned sequentially to entries in   the description, starting with code number 0.    Thus, the following entry in the machine description      (define_insn "clrdf"       [(set (match_operand:DF 0 "general_operand" "") 	    (const_int 0))]       ""       "clrd %0")    assuming it is the 25th entry present, would cause   insn_data[24].template to be "clrd %0", and   insn_data[24].n_operands to be 1.  */
end_comment

begin_escape
end_escape

begin_include
include|#
directive|include
file|"hconfig.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"errors.h"
end_include

begin_include
include|#
directive|include
file|"gensupport.h"
end_include

begin_comment
comment|/* No instruction can have more operands than this.  Sorry for this    arbitrary limit, but what machine will have an instruction with    this many operands?  */
end_comment

begin_define
define|#
directive|define
name|MAX_MAX_OPERANDS
value|40
end_define

begin_decl_stmt
specifier|static
name|int
name|n_occurrences
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|strip_whitespace
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* insns in the machine description are assigned sequential code numbers    that are used by insn-recog.c (produced by genrecog) to communicate    to insn-output.c (produced by this program).  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|next_code_number
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This counts all definitions in the md file,    for the sake of error messages.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|next_index_number
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This counts all operands used in the md file.  The first is null.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|next_operand_number
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Record in this chain all information about the operands we will output.  */
end_comment

begin_struct
struct|struct
name|operand_data
block|{
name|struct
name|operand_data
modifier|*
name|next
decl_stmt|;
name|int
name|index
decl_stmt|;
specifier|const
name|char
modifier|*
name|predicate
decl_stmt|;
specifier|const
name|char
modifier|*
name|constraint
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|unsigned
name|char
name|n_alternatives
decl_stmt|;
name|char
name|address_p
decl_stmt|;
name|char
name|strict_low
decl_stmt|;
name|char
name|eliminable
decl_stmt|;
name|char
name|seen
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Begin with a null operand at index 0.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|operand_data
name|null_operand
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|""
block|,
literal|""
block|,
name|VOIDmode
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|operand_data
modifier|*
name|odata
init|=
operator|&
name|null_operand
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|operand_data
modifier|*
modifier|*
name|odata_end
init|=
operator|&
name|null_operand
operator|.
name|next
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Must match the constants in recog.h.  */
end_comment

begin_define
define|#
directive|define
name|INSN_OUTPUT_FORMAT_NONE
value|0
end_define

begin_comment
comment|/* abort */
end_comment

begin_define
define|#
directive|define
name|INSN_OUTPUT_FORMAT_SINGLE
value|1
end_define

begin_comment
comment|/* const char * */
end_comment

begin_define
define|#
directive|define
name|INSN_OUTPUT_FORMAT_MULTI
value|2
end_define

begin_comment
comment|/* const char * const * */
end_comment

begin_define
define|#
directive|define
name|INSN_OUTPUT_FORMAT_FUNCTION
value|3
end_define

begin_comment
comment|/* const char * (*)(...) */
end_comment

begin_comment
comment|/* Record in this chain all information that we will output,    associated with the code number of the insn.  */
end_comment

begin_struct
struct|struct
name|data
block|{
name|struct
name|data
modifier|*
name|next
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|char
modifier|*
name|template
decl_stmt|;
name|int
name|code_number
decl_stmt|;
name|int
name|index_number
decl_stmt|;
name|int
name|lineno
decl_stmt|;
name|int
name|n_operands
decl_stmt|;
comment|/* Number of operands this insn recognizes */
name|int
name|n_dups
decl_stmt|;
comment|/* Number times match_dup appears in pattern */
name|int
name|n_alternatives
decl_stmt|;
comment|/* Number of alternatives in each constraint */
name|int
name|operand_number
decl_stmt|;
comment|/* Operand index in the big array.  */
name|int
name|output_format
decl_stmt|;
comment|/* INSN_OUTPUT_FORMAT_*.  */
name|struct
name|operand_data
name|operand
index|[
name|MAX_MAX_OPERANDS
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This variable points to the first link in the insn chain.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|data
modifier|*
name|idata
decl_stmt|,
modifier|*
modifier|*
name|idata_end
init|=
operator|&
name|idata
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|void
name|output_prologue
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_predicate_decls
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_operand_data
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_insn_data
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_get_insn_name
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|scan_operands
name|PARAMS
argument_list|(
operator|(
expr|struct
name|data
operator|*
operator|,
name|rtx
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|compare_operands
name|PARAMS
argument_list|(
operator|(
expr|struct
name|operand_data
operator|*
operator|,
expr|struct
name|operand_data
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|place_operands
name|PARAMS
argument_list|(
operator|(
expr|struct
name|data
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|process_template
name|PARAMS
argument_list|(
operator|(
expr|struct
name|data
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|validate_insn_alternatives
name|PARAMS
argument_list|(
operator|(
expr|struct
name|data
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|validate_insn_operands
name|PARAMS
argument_list|(
operator|(
expr|struct
name|data
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_insn
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_peephole
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_expand
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_split
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_function
specifier|const
name|char
modifier|*
name|get_insn_name
parameter_list|(
name|index
parameter_list|)
name|int
name|index
decl_stmt|;
block|{
specifier|static
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
name|struct
name|data
modifier|*
name|i
decl_stmt|,
modifier|*
name|last_named
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|i
operator|=
name|idata
init|;
name|i
condition|;
name|i
operator|=
name|i
operator|->
name|next
control|)
block|{
if|if
condition|(
name|i
operator|->
name|index_number
operator|==
name|index
condition|)
return|return
name|i
operator|->
name|name
return|;
if|if
condition|(
name|i
operator|->
name|name
condition|)
name|last_named
operator|=
name|i
expr_stmt|;
block|}
if|if
condition|(
name|last_named
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s+%d"
argument_list|,
name|last_named
operator|->
name|name
argument_list|,
name|index
operator|-
name|last_named
operator|->
name|index_number
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"insn %d"
argument_list|,
name|index
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_prologue
parameter_list|()
block|{
name|printf
argument_list|(
literal|"/* Generated automatically by the program `genoutput'\n\    from the machine description file `md'.  */\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"config.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"system.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"flags.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"ggc.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"rtl.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"expr.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"insn-codes.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"tm_p.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"function.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"regs.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"hard-reg-set.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"real.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"insn-config.h\"\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"conditions.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"insn-attr.h\"\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"recog.h\"\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"toplev.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"output.h\"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* We need to define all predicates used.  Keep a list of those we    have defined so far.  There normally aren't very many predicates    used, so a linked list should be fast enough.  */
end_comment

begin_struct
struct|struct
name|predicate
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|predicate
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|output_predicate_decls
parameter_list|()
block|{
name|struct
name|predicate
modifier|*
name|predicates
init|=
literal|0
decl_stmt|;
name|struct
name|operand_data
modifier|*
name|d
decl_stmt|;
name|struct
name|predicate
modifier|*
name|p
decl_stmt|,
modifier|*
name|next
decl_stmt|;
for|for
control|(
name|d
operator|=
name|odata
init|;
name|d
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
if|if
condition|(
name|d
operator|->
name|predicate
operator|&&
name|d
operator|->
name|predicate
index|[
literal|0
index|]
condition|)
block|{
for|for
control|(
name|p
operator|=
name|predicates
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|p
operator|->
name|name
argument_list|,
name|d
operator|->
name|predicate
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|p
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"extern int %s PARAMS ((rtx, enum machine_mode));\n"
argument_list|,
name|d
operator|->
name|predicate
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
expr|struct
name|predicate
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|predicate
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|name
operator|=
name|d
operator|->
name|predicate
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|predicates
expr_stmt|;
name|predicates
operator|=
name|p
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"\n\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|predicates
init|;
name|p
condition|;
name|p
operator|=
name|next
control|)
block|{
name|next
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|output_operand_data
parameter_list|()
block|{
name|struct
name|operand_data
modifier|*
name|d
decl_stmt|;
name|printf
argument_list|(
literal|"\nstatic const struct insn_operand_data operand_data[] = \n{\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|d
operator|=
name|odata
init|;
name|d
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
block|{
name|printf
argument_list|(
literal|"  {\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    %s,\n"
argument_list|,
name|d
operator|->
name|predicate
operator|&&
name|d
operator|->
name|predicate
index|[
literal|0
index|]
condition|?
name|d
operator|->
name|predicate
else|:
literal|"0"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    \"%s\",\n"
argument_list|,
name|d
operator|->
name|constraint
condition|?
name|d
operator|->
name|constraint
else|:
literal|""
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    %smode,\n"
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|d
operator|->
name|mode
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    %d,\n"
argument_list|,
name|d
operator|->
name|strict_low
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    %d\n"
argument_list|,
name|d
operator|->
name|eliminable
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  },\n"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"};\n\n\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_insn_data
parameter_list|()
block|{
name|struct
name|data
modifier|*
name|d
decl_stmt|;
name|int
name|name_offset
init|=
literal|0
decl_stmt|;
name|int
name|next_name_offset
decl_stmt|;
specifier|const
name|char
modifier|*
name|last_name
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|next_name
init|=
literal|0
decl_stmt|;
name|struct
name|data
modifier|*
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
name|idata
operator|,
name|next_name_offset
operator|=
literal|1
init|;
name|n
condition|;
name|n
operator|=
name|n
operator|->
name|next
operator|,
name|next_name_offset
operator|++
control|)
if|if
condition|(
name|n
operator|->
name|name
condition|)
block|{
name|next_name
operator|=
name|n
operator|->
name|name
expr_stmt|;
break|break;
block|}
name|printf
argument_list|(
literal|"\nconst struct insn_data insn_data[] = \n{\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|d
operator|=
name|idata
init|;
name|d
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
block|{
name|printf
argument_list|(
literal|"  {\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|name
condition|)
block|{
name|printf
argument_list|(
literal|"    \"%s\",\n"
argument_list|,
name|d
operator|->
name|name
argument_list|)
expr_stmt|;
name|name_offset
operator|=
literal|0
expr_stmt|;
name|last_name
operator|=
name|d
operator|->
name|name
expr_stmt|;
name|next_name
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|n
operator|=
name|d
operator|->
name|next
operator|,
name|next_name_offset
operator|=
literal|1
init|;
name|n
condition|;
name|n
operator|=
name|n
operator|->
name|next
operator|,
name|next_name_offset
operator|++
control|)
block|{
if|if
condition|(
name|n
operator|->
name|name
condition|)
block|{
name|next_name
operator|=
name|n
operator|->
name|name
expr_stmt|;
break|break;
block|}
block|}
block|}
else|else
block|{
name|name_offset
operator|++
expr_stmt|;
if|if
condition|(
name|next_name
operator|&&
operator|(
name|last_name
operator|==
literal|0
operator|||
name|name_offset
operator|>
name|next_name_offset
operator|/
literal|2
operator|)
condition|)
name|printf
argument_list|(
literal|"    \"%s-%d\",\n"
argument_list|,
name|next_name
argument_list|,
name|next_name_offset
operator|-
name|name_offset
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"    \"%s+%d\",\n"
argument_list|,
name|last_name
argument_list|,
name|name_offset
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|d
operator|->
name|output_format
condition|)
block|{
case|case
name|INSN_OUTPUT_FORMAT_NONE
case|:
name|printf
argument_list|(
literal|"    0,\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|INSN_OUTPUT_FORMAT_SINGLE
case|:
block|{
specifier|const
name|char
modifier|*
name|p
init|=
name|d
operator|->
name|template
decl_stmt|;
name|char
name|prev
init|=
literal|0
decl_stmt|;
name|printf
argument_list|(
literal|"    \""
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\n'
operator|&&
name|prev
operator|!=
literal|'\\'
condition|)
name|printf
argument_list|(
literal|"\\n\\\n"
argument_list|)
expr_stmt|;
else|else
name|putchar
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
name|prev
operator|=
operator|*
name|p
expr_stmt|;
operator|++
name|p
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\",\n"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|INSN_OUTPUT_FORMAT_MULTI
case|:
case|case
name|INSN_OUTPUT_FORMAT_FUNCTION
case|:
name|printf
argument_list|(
literal|"    (const PTR) output_%d,\n"
argument_list|,
name|d
operator|->
name|code_number
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|d
operator|->
name|name
operator|&&
name|d
operator|->
name|name
index|[
literal|0
index|]
operator|!=
literal|'*'
condition|)
name|printf
argument_list|(
literal|"    (insn_gen_fn) gen_%s,\n"
argument_list|,
name|d
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"    0,\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"&operand_data[%d],\n"
argument_list|,
name|d
operator|->
name|operand_number
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    %d,\n"
argument_list|,
name|d
operator|->
name|n_operands
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    %d,\n"
argument_list|,
name|d
operator|->
name|n_dups
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    %d,\n"
argument_list|,
name|d
operator|->
name|n_alternatives
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    %d\n"
argument_list|,
name|d
operator|->
name|output_format
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  },\n"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"};\n\n\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_get_insn_name
parameter_list|()
block|{
name|printf
argument_list|(
literal|"const char *\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"get_insn_name (code)\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"     int code;\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"{\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  return insn_data[code].name;\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"}\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Stores in max_opno the largest operand number present in `part', if    that is larger than the previous value of max_opno, and the rest of    the operand data into `d->operand[i]'.     THIS_ADDRESS_P is nonzero if the containing rtx was an ADDRESS.    THIS_STRICT_LOW is nonzero if the containing rtx was a STRICT_LOW_PART.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|max_opno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|num_dups
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|scan_operands
parameter_list|(
name|d
parameter_list|,
name|part
parameter_list|,
name|this_address_p
parameter_list|,
name|this_strict_low
parameter_list|)
name|struct
name|data
modifier|*
name|d
decl_stmt|;
name|rtx
name|part
decl_stmt|;
name|int
name|this_address_p
decl_stmt|;
name|int
name|this_strict_low
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|const
name|char
modifier|*
name|format_ptr
decl_stmt|;
name|int
name|opno
decl_stmt|;
if|if
condition|(
name|part
operator|==
literal|0
condition|)
return|return;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|part
argument_list|)
condition|)
block|{
case|case
name|MATCH_OPERAND
case|:
name|opno
operator|=
name|XINT
argument_list|(
name|part
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|opno
operator|>
name|max_opno
condition|)
name|max_opno
operator|=
name|opno
expr_stmt|;
if|if
condition|(
name|max_opno
operator|>=
name|MAX_MAX_OPERANDS
condition|)
block|{
name|message_with_line
argument_list|(
name|d
operator|->
name|lineno
argument_list|,
literal|"maximum number of operands exceeded"
argument_list|)
expr_stmt|;
name|have_error
operator|=
literal|1
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|d
operator|->
name|operand
index|[
name|opno
index|]
operator|.
name|seen
condition|)
block|{
name|message_with_line
argument_list|(
name|d
operator|->
name|lineno
argument_list|,
literal|"repeated operand number %d\n"
argument_list|,
name|opno
argument_list|)
expr_stmt|;
name|have_error
operator|=
literal|1
expr_stmt|;
block|}
name|d
operator|->
name|operand
index|[
name|opno
index|]
operator|.
name|seen
operator|=
literal|1
expr_stmt|;
name|d
operator|->
name|operand
index|[
name|opno
index|]
operator|.
name|mode
operator|=
name|GET_MODE
argument_list|(
name|part
argument_list|)
expr_stmt|;
name|d
operator|->
name|operand
index|[
name|opno
index|]
operator|.
name|strict_low
operator|=
name|this_strict_low
expr_stmt|;
name|d
operator|->
name|operand
index|[
name|opno
index|]
operator|.
name|predicate
operator|=
name|XSTR
argument_list|(
name|part
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|d
operator|->
name|operand
index|[
name|opno
index|]
operator|.
name|constraint
operator|=
name|strip_whitespace
argument_list|(
name|XSTR
argument_list|(
name|part
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|->
name|operand
index|[
name|opno
index|]
operator|.
name|n_alternatives
operator|=
name|n_occurrences
argument_list|(
literal|','
argument_list|,
name|d
operator|->
name|operand
index|[
name|opno
index|]
operator|.
name|constraint
argument_list|)
operator|+
literal|1
expr_stmt|;
name|d
operator|->
name|operand
index|[
name|opno
index|]
operator|.
name|address_p
operator|=
name|this_address_p
expr_stmt|;
name|d
operator|->
name|operand
index|[
name|opno
index|]
operator|.
name|eliminable
operator|=
literal|1
expr_stmt|;
return|return;
case|case
name|MATCH_SCRATCH
case|:
name|opno
operator|=
name|XINT
argument_list|(
name|part
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|opno
operator|>
name|max_opno
condition|)
name|max_opno
operator|=
name|opno
expr_stmt|;
if|if
condition|(
name|max_opno
operator|>=
name|MAX_MAX_OPERANDS
condition|)
block|{
name|message_with_line
argument_list|(
name|d
operator|->
name|lineno
argument_list|,
literal|"maximum number of operands exceeded"
argument_list|)
expr_stmt|;
name|have_error
operator|=
literal|1
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|d
operator|->
name|operand
index|[
name|opno
index|]
operator|.
name|seen
condition|)
block|{
name|message_with_line
argument_list|(
name|d
operator|->
name|lineno
argument_list|,
literal|"repeated operand number %d\n"
argument_list|,
name|opno
argument_list|)
expr_stmt|;
name|have_error
operator|=
literal|1
expr_stmt|;
block|}
name|d
operator|->
name|operand
index|[
name|opno
index|]
operator|.
name|seen
operator|=
literal|1
expr_stmt|;
name|d
operator|->
name|operand
index|[
name|opno
index|]
operator|.
name|mode
operator|=
name|GET_MODE
argument_list|(
name|part
argument_list|)
expr_stmt|;
name|d
operator|->
name|operand
index|[
name|opno
index|]
operator|.
name|strict_low
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|operand
index|[
name|opno
index|]
operator|.
name|predicate
operator|=
literal|"scratch_operand"
expr_stmt|;
name|d
operator|->
name|operand
index|[
name|opno
index|]
operator|.
name|constraint
operator|=
name|strip_whitespace
argument_list|(
name|XSTR
argument_list|(
name|part
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|->
name|operand
index|[
name|opno
index|]
operator|.
name|n_alternatives
operator|=
name|n_occurrences
argument_list|(
literal|','
argument_list|,
name|d
operator|->
name|operand
index|[
name|opno
index|]
operator|.
name|constraint
argument_list|)
operator|+
literal|1
expr_stmt|;
name|d
operator|->
name|operand
index|[
name|opno
index|]
operator|.
name|address_p
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|operand
index|[
name|opno
index|]
operator|.
name|eliminable
operator|=
literal|0
expr_stmt|;
return|return;
case|case
name|MATCH_OPERATOR
case|:
case|case
name|MATCH_PARALLEL
case|:
name|opno
operator|=
name|XINT
argument_list|(
name|part
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|opno
operator|>
name|max_opno
condition|)
name|max_opno
operator|=
name|opno
expr_stmt|;
if|if
condition|(
name|max_opno
operator|>=
name|MAX_MAX_OPERANDS
condition|)
block|{
name|message_with_line
argument_list|(
name|d
operator|->
name|lineno
argument_list|,
literal|"maximum number of operands exceeded"
argument_list|)
expr_stmt|;
name|have_error
operator|=
literal|1
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|d
operator|->
name|operand
index|[
name|opno
index|]
operator|.
name|seen
condition|)
block|{
name|message_with_line
argument_list|(
name|d
operator|->
name|lineno
argument_list|,
literal|"repeated operand number %d\n"
argument_list|,
name|opno
argument_list|)
expr_stmt|;
name|have_error
operator|=
literal|1
expr_stmt|;
block|}
name|d
operator|->
name|operand
index|[
name|opno
index|]
operator|.
name|seen
operator|=
literal|1
expr_stmt|;
name|d
operator|->
name|operand
index|[
name|opno
index|]
operator|.
name|mode
operator|=
name|GET_MODE
argument_list|(
name|part
argument_list|)
expr_stmt|;
name|d
operator|->
name|operand
index|[
name|opno
index|]
operator|.
name|strict_low
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|operand
index|[
name|opno
index|]
operator|.
name|predicate
operator|=
name|XSTR
argument_list|(
name|part
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|d
operator|->
name|operand
index|[
name|opno
index|]
operator|.
name|constraint
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|operand
index|[
name|opno
index|]
operator|.
name|address_p
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|operand
index|[
name|opno
index|]
operator|.
name|eliminable
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|part
argument_list|,
literal|2
argument_list|)
condition|;
name|i
operator|++
control|)
name|scan_operands
argument_list|(
name|d
argument_list|,
name|XVECEXP
argument_list|(
name|part
argument_list|,
literal|2
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
case|case
name|MATCH_DUP
case|:
case|case
name|MATCH_OP_DUP
case|:
case|case
name|MATCH_PAR_DUP
case|:
operator|++
name|num_dups
expr_stmt|;
return|return;
case|case
name|ADDRESS
case|:
name|scan_operands
argument_list|(
name|d
argument_list|,
name|XEXP
argument_list|(
name|part
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
case|case
name|STRICT_LOW_PART
case|:
name|scan_operands
argument_list|(
name|d
argument_list|,
name|XEXP
argument_list|(
name|part
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
default|default:
break|break;
block|}
name|format_ptr
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|part
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|part
argument_list|)
argument_list|)
condition|;
name|i
operator|++
control|)
switch|switch
condition|(
operator|*
name|format_ptr
operator|++
condition|)
block|{
case|case
literal|'e'
case|:
case|case
literal|'u'
case|:
name|scan_operands
argument_list|(
name|d
argument_list|,
name|XEXP
argument_list|(
name|part
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
if|if
condition|(
name|XVEC
argument_list|(
name|part
argument_list|,
name|i
argument_list|)
operator|!=
name|NULL
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|part
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|scan_operands
argument_list|(
name|d
argument_list|,
name|XVECEXP
argument_list|(
name|part
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Compare two operands for content equality.  */
end_comment

begin_function
specifier|static
name|int
name|compare_operands
parameter_list|(
name|d0
parameter_list|,
name|d1
parameter_list|)
name|struct
name|operand_data
modifier|*
name|d0
decl_stmt|,
decl|*
name|d1
decl_stmt|;
end_function

begin_block
block|{
specifier|const
name|char
modifier|*
name|p0
decl_stmt|,
modifier|*
name|p1
decl_stmt|;
name|p0
operator|=
name|d0
operator|->
name|predicate
expr_stmt|;
if|if
condition|(
operator|!
name|p0
condition|)
name|p0
operator|=
literal|""
expr_stmt|;
name|p1
operator|=
name|d1
operator|->
name|predicate
expr_stmt|;
if|if
condition|(
operator|!
name|p1
condition|)
name|p1
operator|=
literal|""
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|p0
argument_list|,
name|p1
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
name|p0
operator|=
name|d0
operator|->
name|constraint
expr_stmt|;
if|if
condition|(
operator|!
name|p0
condition|)
name|p0
operator|=
literal|""
expr_stmt|;
name|p1
operator|=
name|d1
operator|->
name|constraint
expr_stmt|;
if|if
condition|(
operator|!
name|p1
condition|)
name|p1
operator|=
literal|""
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|p0
argument_list|,
name|p1
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|d0
operator|->
name|mode
operator|!=
name|d1
operator|->
name|mode
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|d0
operator|->
name|strict_low
operator|!=
name|d1
operator|->
name|strict_low
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|d0
operator|->
name|eliminable
operator|!=
name|d1
operator|->
name|eliminable
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_block

begin_comment
comment|/* Scan the list of operands we've already committed to output and either    find a subsequence that is the same, or allocate a new one at the end.  */
end_comment

begin_function
specifier|static
name|void
name|place_operands
parameter_list|(
name|d
parameter_list|)
name|struct
name|data
modifier|*
name|d
decl_stmt|;
block|{
name|struct
name|operand_data
modifier|*
name|od
decl_stmt|,
modifier|*
name|od2
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|n_operands
operator|==
literal|0
condition|)
block|{
name|d
operator|->
name|operand_number
operator|=
literal|0
expr_stmt|;
return|return;
block|}
comment|/* Brute force substring search.  */
for|for
control|(
name|od
operator|=
name|odata
operator|,
name|i
operator|=
literal|0
init|;
name|od
condition|;
name|od
operator|=
name|od
operator|->
name|next
operator|,
name|i
operator|=
literal|0
control|)
if|if
condition|(
name|compare_operands
argument_list|(
name|od
argument_list|,
operator|&
name|d
operator|->
name|operand
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|od2
operator|=
name|od
operator|->
name|next
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|i
operator|==
name|d
operator|->
name|n_operands
condition|)
goto|goto
name|full_match
goto|;
if|if
condition|(
name|od2
operator|==
name|NULL
condition|)
goto|goto
name|partial_match
goto|;
if|if
condition|(
operator|!
name|compare_operands
argument_list|(
name|od2
argument_list|,
operator|&
name|d
operator|->
name|operand
index|[
name|i
index|]
argument_list|)
condition|)
break|break;
operator|++
name|i
operator|,
name|od2
operator|=
name|od2
operator|->
name|next
expr_stmt|;
block|}
block|}
comment|/* Either partial match at the end of the list, or no match.  In either      case, we tack on what operands are remaining to the end of the list.  */
name|partial_match
label|:
name|d
operator|->
name|operand_number
operator|=
name|next_operand_number
operator|-
name|i
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|d
operator|->
name|n_operands
condition|;
operator|++
name|i
control|)
block|{
name|od2
operator|=
operator|&
name|d
operator|->
name|operand
index|[
name|i
index|]
expr_stmt|;
operator|*
name|odata_end
operator|=
name|od2
expr_stmt|;
name|odata_end
operator|=
operator|&
name|od2
operator|->
name|next
expr_stmt|;
name|od2
operator|->
name|index
operator|=
name|next_operand_number
operator|++
expr_stmt|;
block|}
operator|*
name|odata_end
operator|=
name|NULL
expr_stmt|;
return|return;
name|full_match
label|:
name|d
operator|->
name|operand_number
operator|=
name|od
operator|->
name|index
expr_stmt|;
return|return;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Process an assembler template from a define_insn or a define_peephole.    It is either the assembler code template, a list of assembler code    templates, or C code to generate the assembler code template.  */
end_comment

begin_function
specifier|static
name|void
name|process_template
parameter_list|(
name|d
parameter_list|,
name|template
parameter_list|)
name|struct
name|data
modifier|*
name|d
decl_stmt|;
specifier|const
name|char
modifier|*
name|template
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Templates starting with * contain straight code to be run.  */
if|if
condition|(
name|template
index|[
literal|0
index|]
operator|==
literal|'*'
condition|)
block|{
name|d
operator|->
name|template
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|output_format
operator|=
name|INSN_OUTPUT_FORMAT_FUNCTION
expr_stmt|;
name|printf
argument_list|(
literal|"\nstatic const char *output_%d PARAMS ((rtx *, rtx));\n"
argument_list|,
name|d
operator|->
name|code_number
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"\nstatic const char *"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"output_%d (operands, insn)\n"
argument_list|,
name|d
operator|->
name|code_number
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"     rtx *operands ATTRIBUTE_UNUSED;"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"     rtx insn ATTRIBUTE_UNUSED;"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
name|template
operator|+
literal|1
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
block|}
comment|/* If the assembler code template starts with a @ it is a newline-separated      list of assembler code templates, one for each alternative.  */
elseif|else
if|if
condition|(
name|template
index|[
literal|0
index|]
operator|==
literal|'@'
condition|)
block|{
name|d
operator|->
name|template
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|output_format
operator|=
name|INSN_OUTPUT_FORMAT_MULTI
expr_stmt|;
name|printf
argument_list|(
literal|"\nstatic const char * const output_%d[] = {\n"
argument_list|,
name|d
operator|->
name|code_number
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|cp
operator|=
operator|&
name|template
index|[
literal|1
index|]
init|;
operator|*
name|cp
condition|;
control|)
block|{
while|while
condition|(
operator|*
name|cp
operator|==
literal|'\n'
operator|||
operator|*
name|cp
operator|==
literal|' '
operator|||
operator|*
name|cp
operator|==
literal|'\t'
condition|)
name|cp
operator|++
expr_stmt|;
name|printf
argument_list|(
literal|"  \""
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|!=
literal|'\n'
operator|&&
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
block|{
name|putchar
argument_list|(
operator|*
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|++
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\",\n"
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
literal|1
condition|)
name|message_with_line
argument_list|(
name|d
operator|->
name|lineno
argument_list|,
literal|"'@' is redundant for output template with single alternative"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|d
operator|->
name|n_alternatives
condition|)
block|{
name|message_with_line
argument_list|(
name|d
operator|->
name|lineno
argument_list|,
literal|"wrong number of alternatives in the output template"
argument_list|)
expr_stmt|;
name|have_error
operator|=
literal|1
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"};\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|d
operator|->
name|template
operator|=
name|template
expr_stmt|;
name|d
operator|->
name|output_format
operator|=
name|INSN_OUTPUT_FORMAT_SINGLE
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Check insn D for consistency in number of constraint alternatives.  */
end_comment

begin_function
specifier|static
name|void
name|validate_insn_alternatives
parameter_list|(
name|d
parameter_list|)
name|struct
name|data
modifier|*
name|d
decl_stmt|;
block|{
name|int
name|n
init|=
literal|0
decl_stmt|,
name|start
decl_stmt|;
comment|/* Make sure all the operands have the same number of alternatives      in their constraints.  Let N be that number.  */
for|for
control|(
name|start
operator|=
literal|0
init|;
name|start
operator|<
name|d
operator|->
name|n_operands
condition|;
name|start
operator|++
control|)
if|if
condition|(
name|d
operator|->
name|operand
index|[
name|start
index|]
operator|.
name|n_alternatives
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|n
operator|==
literal|0
condition|)
name|n
operator|=
name|d
operator|->
name|operand
index|[
name|start
index|]
operator|.
name|n_alternatives
expr_stmt|;
elseif|else
if|if
condition|(
name|n
operator|!=
name|d
operator|->
name|operand
index|[
name|start
index|]
operator|.
name|n_alternatives
condition|)
block|{
name|message_with_line
argument_list|(
name|d
operator|->
name|lineno
argument_list|,
literal|"wrong number of alternatives in operand %d"
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|have_error
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* Record the insn's overall number of alternatives.  */
name|d
operator|->
name|n_alternatives
operator|=
name|n
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Verify that there are no gaps in operand numbers for INSNs.  */
end_comment

begin_function
specifier|static
name|void
name|validate_insn_operands
parameter_list|(
name|d
parameter_list|)
name|struct
name|data
modifier|*
name|d
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|n_operands
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|d
operator|->
name|operand
index|[
name|i
index|]
operator|.
name|seen
operator|==
literal|0
condition|)
block|{
name|message_with_line
argument_list|(
name|d
operator|->
name|lineno
argument_list|,
literal|"missing operand %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|have_error
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Look at a define_insn just read.  Assign its code number.  Record    on idata the template and the number of arguments.  If the insn has    a hairy output action, output a function for now.  */
end_comment

begin_function
specifier|static
name|void
name|gen_insn
parameter_list|(
name|insn
parameter_list|,
name|lineno
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|int
name|lineno
decl_stmt|;
block|{
name|struct
name|data
modifier|*
name|d
init|=
operator|(
expr|struct
name|data
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|data
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|d
operator|->
name|code_number
operator|=
name|next_code_number
expr_stmt|;
name|d
operator|->
name|index_number
operator|=
name|next_index_number
expr_stmt|;
name|d
operator|->
name|lineno
operator|=
name|lineno
expr_stmt|;
if|if
condition|(
name|XSTR
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|)
index|[
literal|0
index|]
condition|)
name|d
operator|->
name|name
operator|=
name|XSTR
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|d
operator|->
name|name
operator|=
literal|0
expr_stmt|;
comment|/* Build up the list in the same order as the insns are seen      in the machine description.  */
name|d
operator|->
name|next
operator|=
literal|0
expr_stmt|;
operator|*
name|idata_end
operator|=
name|d
expr_stmt|;
name|idata_end
operator|=
operator|&
name|d
operator|->
name|next
expr_stmt|;
name|max_opno
operator|=
operator|-
literal|1
expr_stmt|;
name|num_dups
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
name|d
operator|->
name|operand
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|d
operator|->
name|operand
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|)
condition|;
name|i
operator|++
control|)
name|scan_operands
argument_list|(
name|d
argument_list|,
name|XVECEXP
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|d
operator|->
name|n_operands
operator|=
name|max_opno
operator|+
literal|1
expr_stmt|;
name|d
operator|->
name|n_dups
operator|=
name|num_dups
expr_stmt|;
name|validate_insn_operands
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|validate_insn_alternatives
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|place_operands
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|process_template
argument_list|(
name|d
argument_list|,
name|XTMPL
argument_list|(
name|insn
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Look at a define_peephole just read.  Assign its code number.    Record on idata the template and the number of arguments.    If the insn has a hairy output action, output it now.  */
end_comment

begin_function
specifier|static
name|void
name|gen_peephole
parameter_list|(
name|peep
parameter_list|,
name|lineno
parameter_list|)
name|rtx
name|peep
decl_stmt|;
name|int
name|lineno
decl_stmt|;
block|{
name|struct
name|data
modifier|*
name|d
init|=
operator|(
expr|struct
name|data
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|data
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|d
operator|->
name|code_number
operator|=
name|next_code_number
expr_stmt|;
name|d
operator|->
name|index_number
operator|=
name|next_index_number
expr_stmt|;
name|d
operator|->
name|lineno
operator|=
name|lineno
expr_stmt|;
name|d
operator|->
name|name
operator|=
literal|0
expr_stmt|;
comment|/* Build up the list in the same order as the insns are seen      in the machine description.  */
name|d
operator|->
name|next
operator|=
literal|0
expr_stmt|;
operator|*
name|idata_end
operator|=
name|d
expr_stmt|;
name|idata_end
operator|=
operator|&
name|d
operator|->
name|next
expr_stmt|;
name|max_opno
operator|=
operator|-
literal|1
expr_stmt|;
name|num_dups
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
name|d
operator|->
name|operand
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|d
operator|->
name|operand
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Get the number of operands by scanning all the patterns of the      peephole optimizer.  But ignore all the rest of the information      thus obtained.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|peep
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
name|scan_operands
argument_list|(
name|d
argument_list|,
name|XVECEXP
argument_list|(
name|peep
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|d
operator|->
name|n_operands
operator|=
name|max_opno
operator|+
literal|1
expr_stmt|;
name|d
operator|->
name|n_dups
operator|=
literal|0
expr_stmt|;
name|validate_insn_alternatives
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|place_operands
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|process_template
argument_list|(
name|d
argument_list|,
name|XTMPL
argument_list|(
name|peep
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Process a define_expand just read.  Assign its code number,    only for the purposes of `insn_gen_function'.  */
end_comment

begin_function
specifier|static
name|void
name|gen_expand
parameter_list|(
name|insn
parameter_list|,
name|lineno
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|int
name|lineno
decl_stmt|;
block|{
name|struct
name|data
modifier|*
name|d
init|=
operator|(
expr|struct
name|data
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|data
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|d
operator|->
name|code_number
operator|=
name|next_code_number
expr_stmt|;
name|d
operator|->
name|index_number
operator|=
name|next_index_number
expr_stmt|;
name|d
operator|->
name|lineno
operator|=
name|lineno
expr_stmt|;
if|if
condition|(
name|XSTR
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|)
index|[
literal|0
index|]
condition|)
name|d
operator|->
name|name
operator|=
name|XSTR
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|d
operator|->
name|name
operator|=
literal|0
expr_stmt|;
comment|/* Build up the list in the same order as the insns are seen      in the machine description.  */
name|d
operator|->
name|next
operator|=
literal|0
expr_stmt|;
operator|*
name|idata_end
operator|=
name|d
expr_stmt|;
name|idata_end
operator|=
operator|&
name|d
operator|->
name|next
expr_stmt|;
name|max_opno
operator|=
operator|-
literal|1
expr_stmt|;
name|num_dups
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
name|d
operator|->
name|operand
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|d
operator|->
name|operand
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Scan the operands to get the specified predicates and modes,      since expand_binop needs to know them.  */
if|if
condition|(
name|XVEC
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|)
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|)
condition|;
name|i
operator|++
control|)
name|scan_operands
argument_list|(
name|d
argument_list|,
name|XVECEXP
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|d
operator|->
name|n_operands
operator|=
name|max_opno
operator|+
literal|1
expr_stmt|;
name|d
operator|->
name|n_dups
operator|=
name|num_dups
expr_stmt|;
name|d
operator|->
name|template
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|output_format
operator|=
name|INSN_OUTPUT_FORMAT_NONE
expr_stmt|;
name|validate_insn_alternatives
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|place_operands
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Process a define_split just read.  Assign its code number,    only for reasons of consistency and to simplify genrecog.  */
end_comment

begin_function
specifier|static
name|void
name|gen_split
parameter_list|(
name|split
parameter_list|,
name|lineno
parameter_list|)
name|rtx
name|split
decl_stmt|;
name|int
name|lineno
decl_stmt|;
block|{
name|struct
name|data
modifier|*
name|d
init|=
operator|(
expr|struct
name|data
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|data
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|d
operator|->
name|code_number
operator|=
name|next_code_number
expr_stmt|;
name|d
operator|->
name|index_number
operator|=
name|next_index_number
expr_stmt|;
name|d
operator|->
name|lineno
operator|=
name|lineno
expr_stmt|;
name|d
operator|->
name|name
operator|=
literal|0
expr_stmt|;
comment|/* Build up the list in the same order as the insns are seen      in the machine description.  */
name|d
operator|->
name|next
operator|=
literal|0
expr_stmt|;
operator|*
name|idata_end
operator|=
name|d
expr_stmt|;
name|idata_end
operator|=
operator|&
name|d
operator|->
name|next
expr_stmt|;
name|max_opno
operator|=
operator|-
literal|1
expr_stmt|;
name|num_dups
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
name|d
operator|->
name|operand
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|d
operator|->
name|operand
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Get the number of operands by scanning all the patterns of the      split patterns.  But ignore all the rest of the information thus      obtained.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|split
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
name|scan_operands
argument_list|(
name|d
argument_list|,
name|XVECEXP
argument_list|(
name|split
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|d
operator|->
name|n_operands
operator|=
name|max_opno
operator|+
literal|1
expr_stmt|;
name|d
operator|->
name|n_dups
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|n_alternatives
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|template
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|output_format
operator|=
name|INSN_OUTPUT_FORMAT_NONE
expr_stmt|;
name|place_operands
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|extern
name|int
decl|main
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|rtx
name|desc
decl_stmt|;
name|progname
operator|=
literal|"genoutput"
expr_stmt|;
if|if
condition|(
name|argc
operator|<=
literal|1
condition|)
name|fatal
argument_list|(
literal|"no input file name"
argument_list|)
expr_stmt|;
if|if
condition|(
name|init_md_reader_args
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
operator|!=
name|SUCCESS_EXIT_CODE
condition|)
return|return
operator|(
name|FATAL_EXIT_CODE
operator|)
return|;
name|output_prologue
argument_list|()
expr_stmt|;
name|next_code_number
operator|=
literal|0
expr_stmt|;
name|next_index_number
operator|=
literal|0
expr_stmt|;
comment|/* Read the machine description.  */
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|line_no
decl_stmt|;
name|desc
operator|=
name|read_md_rtx
argument_list|(
operator|&
name|line_no
argument_list|,
operator|&
name|next_code_number
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|GET_CODE
argument_list|(
name|desc
argument_list|)
operator|==
name|DEFINE_INSN
condition|)
name|gen_insn
argument_list|(
name|desc
argument_list|,
name|line_no
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|desc
argument_list|)
operator|==
name|DEFINE_PEEPHOLE
condition|)
name|gen_peephole
argument_list|(
name|desc
argument_list|,
name|line_no
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|desc
argument_list|)
operator|==
name|DEFINE_EXPAND
condition|)
name|gen_expand
argument_list|(
name|desc
argument_list|,
name|line_no
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|desc
argument_list|)
operator|==
name|DEFINE_SPLIT
operator|||
name|GET_CODE
argument_list|(
name|desc
argument_list|)
operator|==
name|DEFINE_PEEPHOLE2
condition|)
name|gen_split
argument_list|(
name|desc
argument_list|,
name|line_no
argument_list|)
expr_stmt|;
name|next_index_number
operator|++
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n\n"
argument_list|)
expr_stmt|;
name|output_predicate_decls
argument_list|()
expr_stmt|;
name|output_operand_data
argument_list|()
expr_stmt|;
name|output_insn_data
argument_list|()
expr_stmt|;
name|output_get_insn_name
argument_list|()
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
return|return
operator|(
name|ferror
argument_list|(
name|stdout
argument_list|)
operator|!=
literal|0
operator|||
name|have_error
condition|?
name|FATAL_EXIT_CODE
else|:
name|SUCCESS_EXIT_CODE
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the number of occurrences of character C in string S or    -1 if S is the null string.  */
end_comment

begin_function
specifier|static
name|int
name|n_occurrences
parameter_list|(
name|c
parameter_list|,
name|s
parameter_list|)
name|int
name|c
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|int
name|n
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|s
operator|==
literal|0
operator|||
operator|*
name|s
operator|==
literal|'\0'
condition|)
return|return
operator|-
literal|1
return|;
while|while
condition|(
operator|*
name|s
condition|)
name|n
operator|+=
operator|(
operator|*
name|s
operator|++
operator|==
name|c
operator|)
expr_stmt|;
return|return
name|n
return|;
block|}
end_function

begin_comment
comment|/* Remove whitespace in `s' by moving up characters until the end.    Return a new string.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|strip_whitespace
parameter_list|(
name|s
parameter_list|)
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|char
name|ch
decl_stmt|;
if|if
condition|(
name|s
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|p
operator|=
name|q
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
operator|*
name|s
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
if|if
condition|(
operator|!
name|ISSPACE
argument_list|(
name|ch
argument_list|)
condition|)
operator|*
name|p
operator|++
operator|=
name|ch
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
return|return
name|q
return|;
block|}
end_function

end_unit

