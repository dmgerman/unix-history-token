begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Generate code from to output assembler insns as recognized from rtl.    Copyright (C) 1987, 88, 92, 94, 95, 97, 1998 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* This program reads the machine description for the compiler target machine    and produces a file containing these things:     1. An array of strings `insn_template' which is indexed by insn code number    and contains the template for output of that insn,     2. An array of functions `insn_outfun' which, indexed by the insn code    number, gives the function that returns a template to use for output of    that insn.  This is used only in the cases where the template is not    constant.  These cases are specified by a * or @ at the beginning of the    template string in the machine description.  They are identified for the    sake of other parts of the compiler by a zero element in `insn_template'.       3. An array of functions `insn_gen_function' which, indexed    by insn code number, gives the function to generate a body    for that pattern, given operands as arguments.     4. An array of strings `insn_name' which, indexed by insn code number,    gives the name for that pattern.  Nameless patterns are given a name.     5. An array of ints `insn_n_operands' which is indexed by insn code number    and contains the number of distinct operands in the pattern for that insn,     6. An array of ints `insn_n_dups' which is indexed by insn code number    and contains the number of match_dup's that appear in the insn's pattern.    This says how many elements of `recog_dup_loc' are significant    after an insn has been recognized.     7. An array of arrays of operand constraint strings,    `insn_operand_constraint',    indexed first by insn code number and second by operand number,    containing the constraint for that operand.     This array is generated only if register constraints appear in     match_operand rtx's.     8. An array of arrays of chars which indicate which operands of    which insn patterns appear within ADDRESS rtx's.  This array is    called `insn_operand_address_p' and is generated only if there    are *no* register constraints in the match_operand rtx's.     9. An array of arrays of machine modes, `insn_operand_mode',    indexed first by insn code number and second by operand number,    containing the machine mode that that operand is supposed to have.    Also `insn_operand_strict_low', which is nonzero for operands    contained in a STRICT_LOW_PART.     10. An array of arrays of int-valued functions, `insn_operand_predicate',    indexed first by insn code number and second by operand number,    containing the match_operand predicate for this operand.     11. An array of ints, `insn_n_alternatives', that gives the number    of alternatives in the constraints of each pattern.  The code number of an insn is simply its position in the machine description; code numbers are assigned sequentially to entries in the description, starting with code number 0.  Thus, the following entry in the machine description      (define_insn "clrdf"       [(set (match_operand:DF 0 "general_operand" "") 	    (const_int 0))]       ""       "clrd %0")  assuming it is the 25th entry present, would cause insn_template[24] to be "clrd %0", and insn_n_operands[24] to be 1. It would not make an case in output_insn_hairy because the template given in the entry is a constant (it does not start with `*').  */
end_comment

begin_escape
end_escape

begin_include
include|#
directive|include
file|"hconfig.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_comment
comment|/* No instruction can have more operands than this.    Sorry for this arbitrary limit, but what machine will    have an instruction with this many operands?  */
end_comment

begin_define
define|#
directive|define
name|MAX_MAX_OPERANDS
value|40
end_define

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|obstack
modifier|*
name|rtl_obstack
init|=
operator|&
name|obstack
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|obstack_chunk_alloc
value|xmalloc
end_define

begin_define
define|#
directive|define
name|obstack_chunk_free
value|free
end_define

begin_decl_stmt
name|char
modifier|*
name|xmalloc
name|PROTO
argument_list|(
operator|(
name|unsigned
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fatal
name|PVPROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
operator|...
operator|)
argument_list|)
name|ATTRIBUTE_PRINTF_1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|fancy_abort
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|error
name|PVPROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
operator|...
operator|)
argument_list|)
name|ATTRIBUTE_PRINTF_1
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|mybcopy
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mybzero
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|n_occurrences
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Define this so we can link with print-rtl.o to get debug_rtx function.  */
end_comment

begin_decl_stmt
name|char
modifier|*
modifier|*
name|insn_name_ptr
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* insns in the machine description are assigned sequential code numbers    that are used by insn-recog.c (produced by genrecog) to communicate    to insn-output.c (produced by this program).  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|next_code_number
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This counts all definitions in the md file,    for the sake of error messages.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|next_index_number
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Record in this chain all information that we will output,    associated with the code number of the insn.  */
end_comment

begin_struct
struct|struct
name|data
block|{
name|int
name|code_number
decl_stmt|;
name|int
name|index_number
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|template
decl_stmt|;
comment|/* string such as "movl %1,%0" */
name|int
name|n_operands
decl_stmt|;
comment|/* Number of operands this insn recognizes */
name|int
name|n_dups
decl_stmt|;
comment|/* Number times match_dup appears in pattern */
name|int
name|n_alternatives
decl_stmt|;
comment|/* Number of alternatives in each constraint */
name|struct
name|data
modifier|*
name|next
decl_stmt|;
name|char
modifier|*
name|constraints
index|[
name|MAX_MAX_OPERANDS
index|]
decl_stmt|;
comment|/* Number of alternatives in constraints of operand N.  */
name|int
name|op_n_alternatives
index|[
name|MAX_MAX_OPERANDS
index|]
decl_stmt|;
name|char
modifier|*
name|predicates
index|[
name|MAX_MAX_OPERANDS
index|]
decl_stmt|;
name|char
name|address_p
index|[
name|MAX_MAX_OPERANDS
index|]
decl_stmt|;
name|enum
name|machine_mode
name|modes
index|[
name|MAX_MAX_OPERANDS
index|]
decl_stmt|;
name|char
name|strict_low
index|[
name|MAX_MAX_OPERANDS
index|]
decl_stmt|;
name|char
name|outfun
decl_stmt|;
comment|/* Nonzero means this has an output function */
block|}
struct|;
end_struct

begin_comment
comment|/* This variable points to the first link in the chain.  */
end_comment

begin_decl_stmt
name|struct
name|data
modifier|*
name|insn_data
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer to the last link in the chain, so new elements    can be added at the end.  */
end_comment

begin_decl_stmt
name|struct
name|data
modifier|*
name|end_of_insn_data
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if any match_operand has a constraint string;    implies that REGISTER_CONSTRAINTS will be defined    for this machine description.  */
end_comment

begin_decl_stmt
name|int
name|have_constraints
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if some error has occurred.  We will make all errors fatal, but    might as well continue until we see all of them.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|have_error
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|void
name|output_prologue
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_epilogue
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|scan_operands
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|process_template
name|PROTO
argument_list|(
operator|(
expr|struct
name|data
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|validate_insn_alternatives
name|PROTO
argument_list|(
operator|(
expr|struct
name|data
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_insn
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_peephole
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_expand
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_split
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|n_occurrences
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_function
specifier|static
name|void
name|output_prologue
parameter_list|()
block|{
name|printf
argument_list|(
literal|"/* Generated automatically by the program `genoutput'\n\ from the machine description file `md'.  */\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"config.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"system.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"flags.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"rtl.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"regs.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"hard-reg-set.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"real.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"insn-config.h\"\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"conditions.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"insn-flags.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"insn-attr.h\"\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"insn-codes.h\"\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"recog.h\"\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"output.h\"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_epilogue
parameter_list|()
block|{
specifier|register
name|struct
name|data
modifier|*
name|d
decl_stmt|;
name|printf
argument_list|(
literal|"\nchar * const insn_template[] =\n  {\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|d
operator|=
name|insn_data
init|;
name|d
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
block|{
if|if
condition|(
name|d
operator|->
name|template
condition|)
name|printf
argument_list|(
literal|"    \"%s\",\n"
argument_list|,
name|d
operator|->
name|template
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"    0,\n"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"  };\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\nchar *(*const insn_outfun[])() =\n  {\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|d
operator|=
name|insn_data
init|;
name|d
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
block|{
if|if
condition|(
name|d
operator|->
name|outfun
condition|)
name|printf
argument_list|(
literal|"    output_%d,\n"
argument_list|,
name|d
operator|->
name|code_number
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"    0,\n"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"  };\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\nrtx (*const insn_gen_function[]) () =\n  {\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|d
operator|=
name|insn_data
init|;
name|d
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
block|{
if|if
condition|(
name|d
operator|->
name|name
operator|&&
name|d
operator|->
name|name
index|[
literal|0
index|]
operator|!=
literal|'*'
condition|)
name|printf
argument_list|(
literal|"    gen_%s,\n"
argument_list|,
name|d
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"    0,\n"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"  };\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\nchar *insn_name[] =\n  {\n"
argument_list|)
expr_stmt|;
block|{
name|int
name|offset
init|=
literal|0
decl_stmt|;
name|int
name|next
decl_stmt|;
name|char
modifier|*
name|last_name
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|next_name
init|=
literal|0
decl_stmt|;
specifier|register
name|struct
name|data
modifier|*
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
name|insn_data
operator|,
name|next
operator|=
literal|1
init|;
name|n
condition|;
name|n
operator|=
name|n
operator|->
name|next
operator|,
name|next
operator|++
control|)
if|if
condition|(
name|n
operator|->
name|name
condition|)
block|{
name|next_name
operator|=
name|n
operator|->
name|name
expr_stmt|;
break|break;
block|}
for|for
control|(
name|d
operator|=
name|insn_data
init|;
name|d
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
block|{
if|if
condition|(
name|d
operator|->
name|name
condition|)
block|{
name|printf
argument_list|(
literal|"    \"%s\",\n"
argument_list|,
name|d
operator|->
name|name
argument_list|)
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
name|last_name
operator|=
name|d
operator|->
name|name
expr_stmt|;
name|next_name
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|n
operator|=
name|d
operator|->
name|next
operator|,
name|next
operator|=
literal|1
init|;
name|n
condition|;
name|n
operator|=
name|n
operator|->
name|next
operator|,
name|next
operator|++
control|)
if|if
condition|(
name|n
operator|->
name|name
condition|)
block|{
name|next_name
operator|=
name|n
operator|->
name|name
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|offset
operator|++
expr_stmt|;
if|if
condition|(
name|next_name
operator|&&
operator|(
name|last_name
operator|==
literal|0
operator|||
name|offset
operator|>
name|next
operator|/
literal|2
operator|)
condition|)
name|printf
argument_list|(
literal|"    \"%s-%d\",\n"
argument_list|,
name|next_name
argument_list|,
name|next
operator|-
name|offset
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"    \"%s+%d\",\n"
argument_list|,
name|last_name
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|printf
argument_list|(
literal|"  };\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"char **insn_name_ptr = insn_name;\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\nconst int insn_n_operands[] =\n  {\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|d
operator|=
name|insn_data
init|;
name|d
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
name|printf
argument_list|(
literal|"    %d,\n"
argument_list|,
name|d
operator|->
name|n_operands
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  };\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\nconst int insn_n_dups[] =\n  {\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|d
operator|=
name|insn_data
init|;
name|d
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
name|printf
argument_list|(
literal|"    %d,\n"
argument_list|,
name|d
operator|->
name|n_dups
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  };\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|have_constraints
condition|)
block|{
name|printf
argument_list|(
literal|"\nchar *const insn_operand_constraint[][MAX_RECOG_OPERANDS] =\n  {\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|d
operator|=
name|insn_data
init|;
name|d
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"    {"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|n_operands
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|d
operator|->
name|constraints
index|[
name|i
index|]
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|" \"\","
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|" \"%s\","
argument_list|,
name|d
operator|->
name|constraints
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|d
operator|->
name|n_operands
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|" 0"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" },\n"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"  };\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"\nconst char insn_operand_address_p[][MAX_RECOG_OPERANDS] =\n  {\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|d
operator|=
name|insn_data
init|;
name|d
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"    {"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|n_operands
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|" %d,"
argument_list|,
name|d
operator|->
name|address_p
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|n_operands
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|" 0"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" },\n"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"  };\n"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\nconst enum machine_mode insn_operand_mode[][MAX_RECOG_OPERANDS] =\n  {\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|d
operator|=
name|insn_data
init|;
name|d
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"    {"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|n_operands
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|" %smode,"
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|d
operator|->
name|modes
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|n_operands
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|" VOIDmode"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" },\n"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"  };\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\nconst char insn_operand_strict_low[][MAX_RECOG_OPERANDS] =\n  {\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|d
operator|=
name|insn_data
init|;
name|d
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"    {"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|n_operands
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|" %d,"
argument_list|,
name|d
operator|->
name|strict_low
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|n_operands
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|" 0"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" },\n"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"  };\n"
argument_list|)
expr_stmt|;
block|{
comment|/* We need to define all predicates used.  Keep a list of those we        have defined so far.  There normally aren't very many predicates used,        so a linked list should be fast enough.  */
struct|struct
name|predicate
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|predicate
modifier|*
name|next
decl_stmt|;
block|}
modifier|*
name|predicates
init|=
literal|0
struct|;
name|struct
name|predicate
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|d
operator|=
name|insn_data
init|;
name|d
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|n_operands
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|d
operator|->
name|predicates
index|[
name|i
index|]
operator|&&
name|d
operator|->
name|predicates
index|[
name|i
index|]
index|[
literal|0
index|]
condition|)
block|{
for|for
control|(
name|p
operator|=
name|predicates
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
operator|->
name|name
argument_list|,
name|d
operator|->
name|predicates
index|[
name|i
index|]
argument_list|)
condition|)
break|break;
if|if
condition|(
name|p
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"extern int %s ();\n"
argument_list|,
name|d
operator|->
name|predicates
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
expr|struct
name|predicate
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|predicate
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|name
operator|=
name|d
operator|->
name|predicates
index|[
name|i
index|]
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|predicates
expr_stmt|;
name|predicates
operator|=
name|p
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"\nint (*const insn_operand_predicate[][MAX_RECOG_OPERANDS])() =\n  {\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|d
operator|=
name|insn_data
init|;
name|d
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
block|{
name|printf
argument_list|(
literal|"    {"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|n_operands
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|" %s,"
argument_list|,
operator|(
operator|(
name|d
operator|->
name|predicates
index|[
name|i
index|]
operator|&&
name|d
operator|->
name|predicates
index|[
name|i
index|]
index|[
literal|0
index|]
operator|)
condition|?
name|d
operator|->
name|predicates
index|[
name|i
index|]
else|:
literal|"0"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|n_operands
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|" 0"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" },\n"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"  };\n"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\nconst int insn_n_alternatives[] =\n  {\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|d
operator|=
name|insn_data
init|;
name|d
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
name|printf
argument_list|(
literal|"    %d,\n"
argument_list|,
name|d
operator|->
name|n_alternatives
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  };\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* scan_operands (X) stores in max_opno the largest operand    number present in X, if that is larger than the previous    value of max_opno.  It stores all the constraints in `constraints'    and all the machine modes in `modes'.     THIS_ADDRESS_P is nonzero if the containing rtx was an ADDRESS.    THIS_STRICT_LOW is nonzero if the containing rtx was a STRICT_LOW_PART.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|max_opno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|num_dups
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|constraints
index|[
name|MAX_MAX_OPERANDS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|op_n_alternatives
index|[
name|MAX_MAX_OPERANDS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|predicates
index|[
name|MAX_MAX_OPERANDS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|address_p
index|[
name|MAX_MAX_OPERANDS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|enum
name|machine_mode
name|modes
index|[
name|MAX_MAX_OPERANDS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|strict_low
index|[
name|MAX_MAX_OPERANDS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|seen
index|[
name|MAX_MAX_OPERANDS
index|]
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|scan_operands
parameter_list|(
name|part
parameter_list|,
name|this_address_p
parameter_list|,
name|this_strict_low
parameter_list|)
name|rtx
name|part
decl_stmt|;
name|int
name|this_address_p
decl_stmt|;
name|int
name|this_strict_low
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|register
name|char
modifier|*
name|format_ptr
decl_stmt|;
name|int
name|opno
decl_stmt|;
if|if
condition|(
name|part
operator|==
literal|0
condition|)
return|return;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|part
argument_list|)
condition|)
block|{
case|case
name|MATCH_OPERAND
case|:
name|opno
operator|=
name|XINT
argument_list|(
name|part
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|opno
operator|>
name|max_opno
condition|)
name|max_opno
operator|=
name|opno
expr_stmt|;
if|if
condition|(
name|max_opno
operator|>=
name|MAX_MAX_OPERANDS
condition|)
block|{
name|error
argument_list|(
literal|"Too many operands (%d) in definition %d.\n"
argument_list|,
name|max_opno
operator|+
literal|1
argument_list|,
name|next_index_number
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|seen
index|[
name|opno
index|]
condition|)
name|error
argument_list|(
literal|"Definition %d specified operand number %d more than once.\n"
argument_list|,
name|next_index_number
argument_list|,
name|opno
argument_list|)
expr_stmt|;
name|seen
index|[
name|opno
index|]
operator|=
literal|1
expr_stmt|;
name|modes
index|[
name|opno
index|]
operator|=
name|GET_MODE
argument_list|(
name|part
argument_list|)
expr_stmt|;
name|strict_low
index|[
name|opno
index|]
operator|=
name|this_strict_low
expr_stmt|;
name|predicates
index|[
name|opno
index|]
operator|=
name|XSTR
argument_list|(
name|part
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|constraints
index|[
name|opno
index|]
operator|=
name|XSTR
argument_list|(
name|part
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|XSTR
argument_list|(
name|part
argument_list|,
literal|2
argument_list|)
operator|!=
literal|0
operator|&&
operator|*
name|XSTR
argument_list|(
name|part
argument_list|,
literal|2
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|op_n_alternatives
index|[
name|opno
index|]
operator|=
name|n_occurrences
argument_list|(
literal|','
argument_list|,
name|XSTR
argument_list|(
name|part
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|+
literal|1
expr_stmt|;
name|have_constraints
operator|=
literal|1
expr_stmt|;
block|}
name|address_p
index|[
name|opno
index|]
operator|=
name|this_address_p
expr_stmt|;
return|return;
case|case
name|MATCH_SCRATCH
case|:
name|opno
operator|=
name|XINT
argument_list|(
name|part
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|opno
operator|>
name|max_opno
condition|)
name|max_opno
operator|=
name|opno
expr_stmt|;
if|if
condition|(
name|max_opno
operator|>=
name|MAX_MAX_OPERANDS
condition|)
block|{
name|error
argument_list|(
literal|"Too many operands (%d) in definition %d.\n"
argument_list|,
name|max_opno
operator|+
literal|1
argument_list|,
name|next_index_number
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|seen
index|[
name|opno
index|]
condition|)
name|error
argument_list|(
literal|"Definition %d specified operand number %d more than once.\n"
argument_list|,
name|next_index_number
argument_list|,
name|opno
argument_list|)
expr_stmt|;
name|seen
index|[
name|opno
index|]
operator|=
literal|1
expr_stmt|;
name|modes
index|[
name|opno
index|]
operator|=
name|GET_MODE
argument_list|(
name|part
argument_list|)
expr_stmt|;
name|strict_low
index|[
name|opno
index|]
operator|=
literal|0
expr_stmt|;
name|predicates
index|[
name|opno
index|]
operator|=
literal|"scratch_operand"
expr_stmt|;
name|constraints
index|[
name|opno
index|]
operator|=
name|XSTR
argument_list|(
name|part
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|XSTR
argument_list|(
name|part
argument_list|,
literal|1
argument_list|)
operator|!=
literal|0
operator|&&
operator|*
name|XSTR
argument_list|(
name|part
argument_list|,
literal|1
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|op_n_alternatives
index|[
name|opno
index|]
operator|=
name|n_occurrences
argument_list|(
literal|','
argument_list|,
name|XSTR
argument_list|(
name|part
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|+
literal|1
expr_stmt|;
name|have_constraints
operator|=
literal|1
expr_stmt|;
block|}
name|address_p
index|[
name|opno
index|]
operator|=
literal|0
expr_stmt|;
return|return;
case|case
name|MATCH_OPERATOR
case|:
case|case
name|MATCH_PARALLEL
case|:
name|opno
operator|=
name|XINT
argument_list|(
name|part
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|opno
operator|>
name|max_opno
condition|)
name|max_opno
operator|=
name|opno
expr_stmt|;
if|if
condition|(
name|max_opno
operator|>=
name|MAX_MAX_OPERANDS
condition|)
block|{
name|error
argument_list|(
literal|"Too many operands (%d) in definition %d.\n"
argument_list|,
name|max_opno
operator|+
literal|1
argument_list|,
name|next_index_number
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|seen
index|[
name|opno
index|]
condition|)
name|error
argument_list|(
literal|"Definition %d specified operand number %d more than once.\n"
argument_list|,
name|next_index_number
argument_list|,
name|opno
argument_list|)
expr_stmt|;
name|seen
index|[
name|opno
index|]
operator|=
literal|1
expr_stmt|;
name|modes
index|[
name|opno
index|]
operator|=
name|GET_MODE
argument_list|(
name|part
argument_list|)
expr_stmt|;
name|strict_low
index|[
name|opno
index|]
operator|=
literal|0
expr_stmt|;
name|predicates
index|[
name|opno
index|]
operator|=
name|XSTR
argument_list|(
name|part
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|constraints
index|[
name|opno
index|]
operator|=
literal|0
expr_stmt|;
name|address_p
index|[
name|opno
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|part
argument_list|,
literal|2
argument_list|)
condition|;
name|i
operator|++
control|)
name|scan_operands
argument_list|(
name|XVECEXP
argument_list|(
name|part
argument_list|,
literal|2
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
case|case
name|MATCH_DUP
case|:
case|case
name|MATCH_OP_DUP
case|:
case|case
name|MATCH_PAR_DUP
case|:
operator|++
name|num_dups
expr_stmt|;
return|return;
case|case
name|ADDRESS
case|:
name|scan_operands
argument_list|(
name|XEXP
argument_list|(
name|part
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
case|case
name|STRICT_LOW_PART
case|:
name|scan_operands
argument_list|(
name|XEXP
argument_list|(
name|part
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
default|default:
break|break;
block|}
name|format_ptr
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|part
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|part
argument_list|)
argument_list|)
condition|;
name|i
operator|++
control|)
switch|switch
condition|(
operator|*
name|format_ptr
operator|++
condition|)
block|{
case|case
literal|'e'
case|:
case|case
literal|'u'
case|:
name|scan_operands
argument_list|(
name|XEXP
argument_list|(
name|part
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
if|if
condition|(
name|XVEC
argument_list|(
name|part
argument_list|,
name|i
argument_list|)
operator|!=
name|NULL
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|part
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|scan_operands
argument_list|(
name|XVECEXP
argument_list|(
name|part
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Process an assembler template from a define_insn or a define_peephole.    It is either the assembler code template, a list of assembler code    templates, or C code to generate the assembler code template.  */
end_comment

begin_function
specifier|static
name|void
name|process_template
parameter_list|(
name|d
parameter_list|,
name|template
parameter_list|)
name|struct
name|data
modifier|*
name|d
decl_stmt|;
name|char
modifier|*
name|template
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
comment|/* We need to consider only the instructions whose assembler code template      starts with a * or @.  These are the ones where C code is run to decide      on a template to use.  So for all others just return now.  */
if|if
condition|(
name|template
index|[
literal|0
index|]
operator|!=
literal|'*'
operator|&&
name|template
index|[
literal|0
index|]
operator|!=
literal|'@'
condition|)
block|{
name|d
operator|->
name|template
operator|=
name|template
expr_stmt|;
name|d
operator|->
name|outfun
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|d
operator|->
name|template
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|outfun
operator|=
literal|1
expr_stmt|;
name|printf
argument_list|(
literal|"\nstatic char *\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"output_%d (operands, insn)\n"
argument_list|,
name|d
operator|->
name|code_number
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"     rtx *operands ATTRIBUTE_UNUSED;\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"     rtx insn ATTRIBUTE_UNUSED;\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"{\n"
argument_list|)
expr_stmt|;
comment|/* If the assembler code template starts with a @ it is a newline-separated      list of assembler code templates, one for each alternative.  So produce      a routine to select the correct one.  */
if|if
condition|(
name|template
index|[
literal|0
index|]
operator|==
literal|'@'
condition|)
block|{
name|printf
argument_list|(
literal|"  static /*const*/ char *const strings_%d[] = {\n"
argument_list|,
name|d
operator|->
name|code_number
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|cp
operator|=
operator|&
name|template
index|[
literal|1
index|]
init|;
operator|*
name|cp
condition|;
control|)
block|{
while|while
condition|(
operator|*
name|cp
operator|==
literal|'\n'
operator|||
operator|*
name|cp
operator|==
literal|' '
operator|||
operator|*
name|cp
operator|==
literal|'\t'
condition|)
name|cp
operator|++
expr_stmt|;
name|printf
argument_list|(
literal|"    \""
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|!=
literal|'\n'
operator|&&
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
block|{
name|putchar
argument_list|(
operator|*
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|++
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\",\n"
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"  };\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  return strings_%d[which_alternative];\n"
argument_list|,
name|d
operator|->
name|code_number
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|d
operator|->
name|n_alternatives
condition|)
name|fatal
argument_list|(
literal|"Insn pattern %d has %d alternatives but %d assembler choices"
argument_list|,
name|d
operator|->
name|index_number
argument_list|,
name|d
operator|->
name|n_alternatives
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* The following is done in a funny way to get around problems in 	  VAX-11 "C" on VMS.  It is the equivalent of: 		printf ("%s\n",&template[1])); */
name|cp
operator|=
operator|&
name|template
index|[
literal|1
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|cp
condition|)
block|{
name|putchar
argument_list|(
operator|*
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|++
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"}\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Check insn D for consistency in number of constraint alternatives.  */
end_comment

begin_function
specifier|static
name|void
name|validate_insn_alternatives
parameter_list|(
name|d
parameter_list|)
name|struct
name|data
modifier|*
name|d
decl_stmt|;
block|{
specifier|register
name|int
name|n
init|=
literal|0
decl_stmt|,
name|start
decl_stmt|;
comment|/* Make sure all the operands have the same number of      alternatives in their constraints.      Let N be that number.  */
for|for
control|(
name|start
operator|=
literal|0
init|;
name|start
operator|<
name|d
operator|->
name|n_operands
condition|;
name|start
operator|++
control|)
if|if
condition|(
name|d
operator|->
name|op_n_alternatives
index|[
name|start
index|]
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|n
operator|==
literal|0
condition|)
name|n
operator|=
name|d
operator|->
name|op_n_alternatives
index|[
name|start
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|n
operator|!=
name|d
operator|->
name|op_n_alternatives
index|[
name|start
index|]
condition|)
name|error
argument_list|(
literal|"wrong number of alternatives in operand %d of insn number %d"
argument_list|,
name|start
argument_list|,
name|d
operator|->
name|index_number
argument_list|)
expr_stmt|;
block|}
comment|/* Record the insn's overall number of alternatives.  */
name|d
operator|->
name|n_alternatives
operator|=
name|n
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Look at a define_insn just read.  Assign its code number.    Record on insn_data the template and the number of arguments.    If the insn has a hairy output action, output a function for now.  */
end_comment

begin_function
specifier|static
name|void
name|gen_insn
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
specifier|register
name|struct
name|data
modifier|*
name|d
init|=
operator|(
expr|struct
name|data
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|data
argument_list|)
argument_list|)
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|d
operator|->
name|code_number
operator|=
name|next_code_number
operator|++
expr_stmt|;
name|d
operator|->
name|index_number
operator|=
name|next_index_number
expr_stmt|;
if|if
condition|(
name|XSTR
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|)
index|[
literal|0
index|]
condition|)
name|d
operator|->
name|name
operator|=
name|XSTR
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|d
operator|->
name|name
operator|=
literal|0
expr_stmt|;
comment|/* Build up the list in the same order as the insns are seen      in the machine description.  */
name|d
operator|->
name|next
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|end_of_insn_data
condition|)
name|end_of_insn_data
operator|->
name|next
operator|=
name|d
expr_stmt|;
else|else
name|insn_data
operator|=
name|d
expr_stmt|;
name|end_of_insn_data
operator|=
name|d
expr_stmt|;
name|max_opno
operator|=
operator|-
literal|1
expr_stmt|;
name|num_dups
operator|=
literal|0
expr_stmt|;
name|mybzero
argument_list|(
name|constraints
argument_list|,
sizeof|sizeof
name|constraints
argument_list|)
expr_stmt|;
name|mybzero
argument_list|(
name|op_n_alternatives
argument_list|,
sizeof|sizeof
name|op_n_alternatives
argument_list|)
expr_stmt|;
name|mybzero
argument_list|(
name|predicates
argument_list|,
sizeof|sizeof
name|predicates
argument_list|)
expr_stmt|;
name|mybzero
argument_list|(
name|address_p
argument_list|,
sizeof|sizeof
name|address_p
argument_list|)
expr_stmt|;
name|mybzero
argument_list|(
name|modes
argument_list|,
sizeof|sizeof
name|modes
argument_list|)
expr_stmt|;
name|mybzero
argument_list|(
name|strict_low
argument_list|,
sizeof|sizeof
name|strict_low
argument_list|)
expr_stmt|;
name|mybzero
argument_list|(
name|seen
argument_list|,
sizeof|sizeof
name|seen
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|)
condition|;
name|i
operator|++
control|)
name|scan_operands
argument_list|(
name|XVECEXP
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|d
operator|->
name|n_operands
operator|=
name|max_opno
operator|+
literal|1
expr_stmt|;
name|d
operator|->
name|n_dups
operator|=
name|num_dups
expr_stmt|;
name|mybcopy
argument_list|(
name|constraints
argument_list|,
name|d
operator|->
name|constraints
argument_list|,
sizeof|sizeof
name|constraints
argument_list|)
expr_stmt|;
name|mybcopy
argument_list|(
name|op_n_alternatives
argument_list|,
name|d
operator|->
name|op_n_alternatives
argument_list|,
sizeof|sizeof
name|op_n_alternatives
argument_list|)
expr_stmt|;
name|mybcopy
argument_list|(
name|predicates
argument_list|,
name|d
operator|->
name|predicates
argument_list|,
sizeof|sizeof
name|predicates
argument_list|)
expr_stmt|;
name|mybcopy
argument_list|(
name|address_p
argument_list|,
name|d
operator|->
name|address_p
argument_list|,
sizeof|sizeof
name|address_p
argument_list|)
expr_stmt|;
name|mybcopy
argument_list|(
name|modes
argument_list|,
name|d
operator|->
name|modes
argument_list|,
sizeof|sizeof
name|modes
argument_list|)
expr_stmt|;
name|mybcopy
argument_list|(
name|strict_low
argument_list|,
name|d
operator|->
name|strict_low
argument_list|,
sizeof|sizeof
name|strict_low
argument_list|)
expr_stmt|;
name|validate_insn_alternatives
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|process_template
argument_list|(
name|d
argument_list|,
name|XSTR
argument_list|(
name|insn
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Look at a define_peephole just read.  Assign its code number.    Record on insn_data the template and the number of arguments.    If the insn has a hairy output action, output it now.  */
end_comment

begin_function
specifier|static
name|void
name|gen_peephole
parameter_list|(
name|peep
parameter_list|)
name|rtx
name|peep
decl_stmt|;
block|{
specifier|register
name|struct
name|data
modifier|*
name|d
init|=
operator|(
expr|struct
name|data
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|data
argument_list|)
argument_list|)
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|d
operator|->
name|code_number
operator|=
name|next_code_number
operator|++
expr_stmt|;
name|d
operator|->
name|index_number
operator|=
name|next_index_number
expr_stmt|;
name|d
operator|->
name|name
operator|=
literal|0
expr_stmt|;
comment|/* Build up the list in the same order as the insns are seen      in the machine description.  */
name|d
operator|->
name|next
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|end_of_insn_data
condition|)
name|end_of_insn_data
operator|->
name|next
operator|=
name|d
expr_stmt|;
else|else
name|insn_data
operator|=
name|d
expr_stmt|;
name|end_of_insn_data
operator|=
name|d
expr_stmt|;
name|max_opno
operator|=
operator|-
literal|1
expr_stmt|;
name|mybzero
argument_list|(
name|constraints
argument_list|,
sizeof|sizeof
name|constraints
argument_list|)
expr_stmt|;
name|mybzero
argument_list|(
name|op_n_alternatives
argument_list|,
sizeof|sizeof
name|op_n_alternatives
argument_list|)
expr_stmt|;
name|mybzero
argument_list|(
name|predicates
argument_list|,
sizeof|sizeof
name|predicates
argument_list|)
expr_stmt|;
name|mybzero
argument_list|(
name|address_p
argument_list|,
sizeof|sizeof
name|address_p
argument_list|)
expr_stmt|;
name|mybzero
argument_list|(
name|modes
argument_list|,
sizeof|sizeof
name|modes
argument_list|)
expr_stmt|;
name|mybzero
argument_list|(
name|strict_low
argument_list|,
sizeof|sizeof
name|strict_low
argument_list|)
expr_stmt|;
name|mybzero
argument_list|(
name|seen
argument_list|,
sizeof|sizeof
name|seen
argument_list|)
expr_stmt|;
comment|/* Get the number of operands by scanning all the      patterns of the peephole optimizer.      But ignore all the rest of the information thus obtained.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|peep
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
name|scan_operands
argument_list|(
name|XVECEXP
argument_list|(
name|peep
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|d
operator|->
name|n_operands
operator|=
name|max_opno
operator|+
literal|1
expr_stmt|;
name|d
operator|->
name|n_dups
operator|=
literal|0
expr_stmt|;
name|mybcopy
argument_list|(
name|constraints
argument_list|,
name|d
operator|->
name|constraints
argument_list|,
sizeof|sizeof
name|constraints
argument_list|)
expr_stmt|;
name|mybcopy
argument_list|(
name|op_n_alternatives
argument_list|,
name|d
operator|->
name|op_n_alternatives
argument_list|,
sizeof|sizeof
name|op_n_alternatives
argument_list|)
expr_stmt|;
name|mybzero
argument_list|(
name|d
operator|->
name|predicates
argument_list|,
sizeof|sizeof
name|predicates
argument_list|)
expr_stmt|;
name|mybzero
argument_list|(
name|d
operator|->
name|address_p
argument_list|,
sizeof|sizeof
name|address_p
argument_list|)
expr_stmt|;
name|mybzero
argument_list|(
name|d
operator|->
name|modes
argument_list|,
sizeof|sizeof
name|modes
argument_list|)
expr_stmt|;
name|mybzero
argument_list|(
name|d
operator|->
name|strict_low
argument_list|,
sizeof|sizeof
name|strict_low
argument_list|)
expr_stmt|;
name|validate_insn_alternatives
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|process_template
argument_list|(
name|d
argument_list|,
name|XSTR
argument_list|(
name|peep
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Process a define_expand just read.  Assign its code number,    only for the purposes of `insn_gen_function'.  */
end_comment

begin_function
specifier|static
name|void
name|gen_expand
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
specifier|register
name|struct
name|data
modifier|*
name|d
init|=
operator|(
expr|struct
name|data
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|data
argument_list|)
argument_list|)
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|d
operator|->
name|code_number
operator|=
name|next_code_number
operator|++
expr_stmt|;
name|d
operator|->
name|index_number
operator|=
name|next_index_number
expr_stmt|;
if|if
condition|(
name|XSTR
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|)
index|[
literal|0
index|]
condition|)
name|d
operator|->
name|name
operator|=
name|XSTR
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|d
operator|->
name|name
operator|=
literal|0
expr_stmt|;
comment|/* Build up the list in the same order as the insns are seen      in the machine description.  */
name|d
operator|->
name|next
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|end_of_insn_data
condition|)
name|end_of_insn_data
operator|->
name|next
operator|=
name|d
expr_stmt|;
else|else
name|insn_data
operator|=
name|d
expr_stmt|;
name|end_of_insn_data
operator|=
name|d
expr_stmt|;
name|max_opno
operator|=
operator|-
literal|1
expr_stmt|;
name|num_dups
operator|=
literal|0
expr_stmt|;
comment|/* Scan the operands to get the specified predicates and modes,      since expand_binop needs to know them.  */
name|mybzero
argument_list|(
name|constraints
argument_list|,
sizeof|sizeof
name|constraints
argument_list|)
expr_stmt|;
name|mybzero
argument_list|(
name|op_n_alternatives
argument_list|,
sizeof|sizeof
name|op_n_alternatives
argument_list|)
expr_stmt|;
name|mybzero
argument_list|(
name|predicates
argument_list|,
sizeof|sizeof
name|predicates
argument_list|)
expr_stmt|;
name|mybzero
argument_list|(
name|address_p
argument_list|,
sizeof|sizeof
name|address_p
argument_list|)
expr_stmt|;
name|mybzero
argument_list|(
name|modes
argument_list|,
sizeof|sizeof
name|modes
argument_list|)
expr_stmt|;
name|mybzero
argument_list|(
name|strict_low
argument_list|,
sizeof|sizeof
name|strict_low
argument_list|)
expr_stmt|;
name|mybzero
argument_list|(
name|seen
argument_list|,
sizeof|sizeof
name|seen
argument_list|)
expr_stmt|;
if|if
condition|(
name|XVEC
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|)
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|)
condition|;
name|i
operator|++
control|)
name|scan_operands
argument_list|(
name|XVECEXP
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|d
operator|->
name|n_operands
operator|=
name|max_opno
operator|+
literal|1
expr_stmt|;
name|d
operator|->
name|n_dups
operator|=
name|num_dups
expr_stmt|;
name|mybcopy
argument_list|(
name|constraints
argument_list|,
name|d
operator|->
name|constraints
argument_list|,
sizeof|sizeof
name|constraints
argument_list|)
expr_stmt|;
name|mybcopy
argument_list|(
name|op_n_alternatives
argument_list|,
name|d
operator|->
name|op_n_alternatives
argument_list|,
sizeof|sizeof
name|op_n_alternatives
argument_list|)
expr_stmt|;
name|mybcopy
argument_list|(
name|predicates
argument_list|,
name|d
operator|->
name|predicates
argument_list|,
sizeof|sizeof
name|predicates
argument_list|)
expr_stmt|;
name|mybcopy
argument_list|(
name|address_p
argument_list|,
name|d
operator|->
name|address_p
argument_list|,
sizeof|sizeof
name|address_p
argument_list|)
expr_stmt|;
name|mybcopy
argument_list|(
name|modes
argument_list|,
name|d
operator|->
name|modes
argument_list|,
sizeof|sizeof
name|modes
argument_list|)
expr_stmt|;
name|mybcopy
argument_list|(
name|strict_low
argument_list|,
name|d
operator|->
name|strict_low
argument_list|,
sizeof|sizeof
name|strict_low
argument_list|)
expr_stmt|;
name|d
operator|->
name|template
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|outfun
operator|=
literal|0
expr_stmt|;
name|validate_insn_alternatives
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Process a define_split just read.  Assign its code number,    only for reasons of consistency and to simplify genrecog.  */
end_comment

begin_function
specifier|static
name|void
name|gen_split
parameter_list|(
name|split
parameter_list|)
name|rtx
name|split
decl_stmt|;
block|{
specifier|register
name|struct
name|data
modifier|*
name|d
init|=
operator|(
expr|struct
name|data
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|data
argument_list|)
argument_list|)
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|d
operator|->
name|code_number
operator|=
name|next_code_number
operator|++
expr_stmt|;
name|d
operator|->
name|index_number
operator|=
name|next_index_number
expr_stmt|;
name|d
operator|->
name|name
operator|=
literal|0
expr_stmt|;
comment|/* Build up the list in the same order as the insns are seen      in the machine description.  */
name|d
operator|->
name|next
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|end_of_insn_data
condition|)
name|end_of_insn_data
operator|->
name|next
operator|=
name|d
expr_stmt|;
else|else
name|insn_data
operator|=
name|d
expr_stmt|;
name|end_of_insn_data
operator|=
name|d
expr_stmt|;
name|max_opno
operator|=
operator|-
literal|1
expr_stmt|;
name|num_dups
operator|=
literal|0
expr_stmt|;
name|mybzero
argument_list|(
name|constraints
argument_list|,
sizeof|sizeof
name|constraints
argument_list|)
expr_stmt|;
name|mybzero
argument_list|(
name|op_n_alternatives
argument_list|,
sizeof|sizeof
name|op_n_alternatives
argument_list|)
expr_stmt|;
name|mybzero
argument_list|(
name|predicates
argument_list|,
sizeof|sizeof
name|predicates
argument_list|)
expr_stmt|;
name|mybzero
argument_list|(
name|address_p
argument_list|,
sizeof|sizeof
name|address_p
argument_list|)
expr_stmt|;
name|mybzero
argument_list|(
name|modes
argument_list|,
sizeof|sizeof
name|modes
argument_list|)
expr_stmt|;
name|mybzero
argument_list|(
name|strict_low
argument_list|,
sizeof|sizeof
name|strict_low
argument_list|)
expr_stmt|;
name|mybzero
argument_list|(
name|seen
argument_list|,
sizeof|sizeof
name|seen
argument_list|)
expr_stmt|;
comment|/* Get the number of operands by scanning all the      patterns of the split patterns.      But ignore all the rest of the information thus obtained.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|split
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
name|scan_operands
argument_list|(
name|XVECEXP
argument_list|(
name|split
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|d
operator|->
name|n_operands
operator|=
name|max_opno
operator|+
literal|1
expr_stmt|;
name|mybzero
argument_list|(
name|d
operator|->
name|constraints
argument_list|,
sizeof|sizeof
name|constraints
argument_list|)
expr_stmt|;
name|mybzero
argument_list|(
name|d
operator|->
name|op_n_alternatives
argument_list|,
sizeof|sizeof
name|op_n_alternatives
argument_list|)
expr_stmt|;
name|mybzero
argument_list|(
name|d
operator|->
name|predicates
argument_list|,
sizeof|sizeof
name|predicates
argument_list|)
expr_stmt|;
name|mybzero
argument_list|(
name|d
operator|->
name|address_p
argument_list|,
sizeof|sizeof
name|address_p
argument_list|)
expr_stmt|;
name|mybzero
argument_list|(
name|d
operator|->
name|modes
argument_list|,
sizeof|sizeof
name|modes
argument_list|)
expr_stmt|;
name|mybzero
argument_list|(
name|d
operator|->
name|strict_low
argument_list|,
sizeof|sizeof
name|strict_low
argument_list|)
expr_stmt|;
name|d
operator|->
name|n_dups
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|n_alternatives
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|template
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|outfun
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|char
modifier|*
name|xmalloc
parameter_list|(
name|size
parameter_list|)
name|unsigned
name|size
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|val
init|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|==
literal|0
condition|)
name|fatal
argument_list|(
literal|"virtual memory exhausted"
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|xrealloc
parameter_list|(
name|ptr
parameter_list|,
name|size
parameter_list|)
name|char
modifier|*
name|ptr
decl_stmt|;
name|unsigned
name|size
decl_stmt|;
block|{
name|char
modifier|*
name|result
init|=
operator|(
name|char
operator|*
operator|)
name|realloc
argument_list|(
name|ptr
argument_list|,
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|result
condition|)
name|fatal
argument_list|(
literal|"virtual memory exhausted"
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mybzero
parameter_list|(
name|b
parameter_list|,
name|length
parameter_list|)
specifier|register
name|char
modifier|*
name|b
decl_stmt|;
specifier|register
name|unsigned
name|length
decl_stmt|;
block|{
while|while
condition|(
name|length
operator|--
operator|>
literal|0
condition|)
operator|*
name|b
operator|++
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mybcopy
parameter_list|(
name|b1
parameter_list|,
name|b2
parameter_list|,
name|length
parameter_list|)
specifier|register
name|char
modifier|*
name|b1
decl_stmt|;
specifier|register
name|char
modifier|*
name|b2
decl_stmt|;
specifier|register
name|unsigned
name|length
decl_stmt|;
block|{
while|while
condition|(
name|length
operator|--
operator|>
literal|0
condition|)
operator|*
name|b2
operator|++
operator|=
operator|*
name|b1
operator|++
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|fatal
name|VPROTO
argument_list|(
operator|(
name|char
operator|*
name|format
operator|,
operator|...
operator|)
argument_list|)
block|{
ifndef|#
directive|ifndef
name|__STDC__
name|char
modifier|*
name|format
decl_stmt|;
endif|#
directive|endif
name|va_list
name|ap
decl_stmt|;
name|VA_START
argument_list|(
name|ap
argument_list|,
name|format
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|__STDC__
name|format
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"genoutput: "
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|format
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|FATAL_EXIT_CODE
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* More 'friendly' abort that prints the line and file.    config.h can #define abort fancy_abort if you like that sort of thing.  */
end_comment

begin_function
name|void
name|fancy_abort
parameter_list|()
block|{
name|fatal
argument_list|(
literal|"Internal gcc abort."
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|error
name|VPROTO
argument_list|(
operator|(
name|char
operator|*
name|format
operator|,
operator|...
operator|)
argument_list|)
block|{
ifndef|#
directive|ifndef
name|__STDC__
name|char
modifier|*
name|format
decl_stmt|;
endif|#
directive|endif
name|va_list
name|ap
decl_stmt|;
name|VA_START
argument_list|(
name|ap
argument_list|,
name|format
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|__STDC__
name|format
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"genoutput: "
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|format
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|have_error
operator|=
literal|1
expr_stmt|;
block|}
end_decl_stmt

begin_escape
end_escape

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|rtx
name|desc
decl_stmt|;
name|FILE
modifier|*
name|infile
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|obstack_init
argument_list|(
name|rtl_obstack
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|<=
literal|1
condition|)
name|fatal
argument_list|(
literal|"No input file name."
argument_list|)
expr_stmt|;
name|infile
operator|=
name|fopen
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|infile
operator|==
literal|0
condition|)
block|{
name|perror
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|FATAL_EXIT_CODE
argument_list|)
expr_stmt|;
block|}
name|init_rtl
argument_list|()
expr_stmt|;
name|output_prologue
argument_list|()
expr_stmt|;
name|next_code_number
operator|=
literal|0
expr_stmt|;
name|next_index_number
operator|=
literal|0
expr_stmt|;
name|have_constraints
operator|=
literal|0
expr_stmt|;
comment|/* Read the machine description.  */
while|while
condition|(
literal|1
condition|)
block|{
name|c
operator|=
name|read_skip_spaces
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
break|break;
name|ungetc
argument_list|(
name|c
argument_list|,
name|infile
argument_list|)
expr_stmt|;
name|desc
operator|=
name|read_rtx
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|desc
argument_list|)
operator|==
name|DEFINE_INSN
condition|)
name|gen_insn
argument_list|(
name|desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|desc
argument_list|)
operator|==
name|DEFINE_PEEPHOLE
condition|)
name|gen_peephole
argument_list|(
name|desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|desc
argument_list|)
operator|==
name|DEFINE_EXPAND
condition|)
name|gen_expand
argument_list|(
name|desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|desc
argument_list|)
operator|==
name|DEFINE_SPLIT
condition|)
name|gen_split
argument_list|(
name|desc
argument_list|)
expr_stmt|;
name|next_index_number
operator|++
expr_stmt|;
block|}
name|output_epilogue
argument_list|()
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|ferror
argument_list|(
name|stdout
argument_list|)
operator|!=
literal|0
operator|||
name|have_error
condition|?
name|FATAL_EXIT_CODE
else|:
name|SUCCESS_EXIT_CODE
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|n_occurrences
parameter_list|(
name|c
parameter_list|,
name|s
parameter_list|)
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|int
name|n
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
name|n
operator|+=
operator|(
operator|*
name|s
operator|++
operator|==
name|c
operator|)
expr_stmt|;
return|return
name|n
return|;
block|}
end_function

end_unit

