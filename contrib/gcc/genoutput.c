begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Generate code from to output assembler insns as recognized from rtl.    Copyright (C) 1987, 1988, 1992, 1994, 1995, 1997, 1998, 1999, 2000, 2002,    2003, 2004, 2005 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* This program reads the machine description for the compiler target machine    and produces a file containing these things:     1. An array of `struct insn_data', which is indexed by insn code number,    which contains:       a. `name' is the name for that pattern.  Nameless patterns are      given a name.       b. `output' hold either the output template, an array of output      templates, or an output function.       c. `genfun' is the function to generate a body for that pattern,      given operands as arguments.       d. `n_operands' is the number of distinct operands in the pattern      for that insn,       e. `n_dups' is the number of match_dup's that appear in the insn's      pattern.  This says how many elements of `recog_data.dup_loc' are      significant after an insn has been recognized.       f. `n_alternatives' is the number of alternatives in the constraints      of each pattern.       g. `output_format' tells what type of thing `output' is.       h. `operand' is the base of an array of operand data for the insn.     2. An array of `struct insn_operand data', used by `operand' above.       a. `predicate', an int-valued function, is the match_operand predicate      for this operand.       b. `constraint' is the constraint for this operand.       c. `address_p' indicates that the operand appears within ADDRESS      rtx's.       d. `mode' is the machine mode that that operand is supposed to have.       e. `strict_low', is nonzero for operands contained in a STRICT_LOW_PART.       f. `eliminable', is nonzero for operands that are matched normally by      MATCH_OPERAND; it is zero for operands that should not be changed during      register elimination such as MATCH_OPERATORs.    The code number of an insn is simply its position in the machine   description; code numbers are assigned sequentially to entries in   the description, starting with code number 0.    Thus, the following entry in the machine description      (define_insn "clrdf"       [(set (match_operand:DF 0 "general_operand" "") 	    (const_int 0))]       ""       "clrd %0")    assuming it is the 25th entry present, would cause   insn_data[24].template to be "clrd %0", and   insn_data[24].n_operands to be 1.  */
end_comment

begin_escape
end_escape

begin_include
include|#
directive|include
file|"bconfig.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"errors.h"
end_include

begin_include
include|#
directive|include
file|"gensupport.h"
end_include

begin_comment
comment|/* No instruction can have more operands than this.  Sorry for this    arbitrary limit, but what machine will have an instruction with    this many operands?  */
end_comment

begin_define
define|#
directive|define
name|MAX_MAX_OPERANDS
value|40
end_define

begin_function_decl
specifier|static
name|int
name|n_occurrences
parameter_list|(
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|strip_whitespace
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* insns in the machine description are assigned sequential code numbers    that are used by insn-recog.c (produced by genrecog) to communicate    to insn-output.c (produced by this program).  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|next_code_number
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This counts all definitions in the md file,    for the sake of error messages.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|next_index_number
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This counts all operands used in the md file.  The first is null.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|next_operand_number
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Record in this chain all information about the operands we will output.  */
end_comment

begin_struct
struct|struct
name|operand_data
block|{
name|struct
name|operand_data
modifier|*
name|next
decl_stmt|;
name|int
name|index
decl_stmt|;
specifier|const
name|char
modifier|*
name|predicate
decl_stmt|;
specifier|const
name|char
modifier|*
name|constraint
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|unsigned
name|char
name|n_alternatives
decl_stmt|;
name|char
name|address_p
decl_stmt|;
name|char
name|strict_low
decl_stmt|;
name|char
name|eliminable
decl_stmt|;
name|char
name|seen
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Begin with a null operand at index 0.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|operand_data
name|null_operand
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|""
block|,
literal|""
block|,
name|VOIDmode
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|operand_data
modifier|*
name|odata
init|=
operator|&
name|null_operand
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|operand_data
modifier|*
modifier|*
name|odata_end
init|=
operator|&
name|null_operand
operator|.
name|next
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Must match the constants in recog.h.  */
end_comment

begin_define
define|#
directive|define
name|INSN_OUTPUT_FORMAT_NONE
value|0
end_define

begin_comment
comment|/* abort */
end_comment

begin_define
define|#
directive|define
name|INSN_OUTPUT_FORMAT_SINGLE
value|1
end_define

begin_comment
comment|/* const char * */
end_comment

begin_define
define|#
directive|define
name|INSN_OUTPUT_FORMAT_MULTI
value|2
end_define

begin_comment
comment|/* const char * const * */
end_comment

begin_define
define|#
directive|define
name|INSN_OUTPUT_FORMAT_FUNCTION
value|3
end_define

begin_comment
comment|/* const char * (*)(...) */
end_comment

begin_comment
comment|/* Record in this chain all information that we will output,    associated with the code number of the insn.  */
end_comment

begin_struct
struct|struct
name|data
block|{
name|struct
name|data
modifier|*
name|next
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|char
modifier|*
name|template
decl_stmt|;
name|int
name|code_number
decl_stmt|;
name|int
name|index_number
decl_stmt|;
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|lineno
decl_stmt|;
name|int
name|n_operands
decl_stmt|;
comment|/* Number of operands this insn recognizes */
name|int
name|n_dups
decl_stmt|;
comment|/* Number times match_dup appears in pattern */
name|int
name|n_alternatives
decl_stmt|;
comment|/* Number of alternatives in each constraint */
name|int
name|operand_number
decl_stmt|;
comment|/* Operand index in the big array.  */
name|int
name|output_format
decl_stmt|;
comment|/* INSN_OUTPUT_FORMAT_*.  */
name|struct
name|operand_data
name|operand
index|[
name|MAX_MAX_OPERANDS
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This variable points to the first link in the insn chain.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|data
modifier|*
name|idata
decl_stmt|,
modifier|*
modifier|*
name|idata_end
init|=
operator|&
name|idata
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_function_decl
specifier|static
name|void
name|output_prologue
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|output_operand_data
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|output_insn_data
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|output_get_insn_name
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|scan_operands
parameter_list|(
name|struct
name|data
modifier|*
parameter_list|,
name|rtx
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|compare_operands
parameter_list|(
name|struct
name|operand_data
modifier|*
parameter_list|,
name|struct
name|operand_data
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|place_operands
parameter_list|(
name|struct
name|data
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|process_template
parameter_list|(
name|struct
name|data
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|validate_insn_alternatives
parameter_list|(
name|struct
name|data
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|validate_insn_operands
parameter_list|(
name|struct
name|data
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gen_insn
parameter_list|(
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gen_peephole
parameter_list|(
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gen_expand
parameter_list|(
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gen_split
parameter_list|(
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|USE_MD_CONSTRAINTS
end_ifdef

begin_struct
struct|struct
name|constraint_data
block|{
name|struct
name|constraint_data
modifier|*
name|next_this_letter
decl_stmt|;
name|int
name|lineno
decl_stmt|;
name|unsigned
name|int
name|namelen
decl_stmt|;
specifier|const
name|char
name|name
index|[
literal|1
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This is a complete list (unlike the one in genpreds.c) of constraint    letters and modifiers with machine-independent meaning.  The only    omission is digits, as these are handled specially.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
name|indep_constraints
index|[]
init|=
literal|",=+%*?!#&<>EFVXgimnoprs"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|constraint_data
modifier|*
name|constraints_by_letter_table
index|[
literal|1
operator|<<
name|CHAR_BIT
index|]
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|mdep_constraint_len
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|note_constraint
parameter_list|(
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !USE_MD_CONSTRAINTS */
end_comment

begin_function_decl
specifier|static
name|void
name|check_constraint_len
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|constraint_len
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !USE_MD_CONSTRAINTS */
end_comment

begin_escape
end_escape

begin_function
specifier|static
name|void
name|output_prologue
parameter_list|(
name|void
parameter_list|)
block|{
name|printf
argument_list|(
literal|"/* Generated automatically by the program `genoutput'\n\    from the machine description file `md'.  */\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"config.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"system.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"coretypes.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"tm.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"flags.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"ggc.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"rtl.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"expr.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"insn-codes.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"tm_p.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"function.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"regs.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"hard-reg-set.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"real.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"insn-config.h\"\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"conditions.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"insn-attr.h\"\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"recog.h\"\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"toplev.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"output.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"target.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"tm-constrs.h\"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_operand_data
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|operand_data
modifier|*
name|d
decl_stmt|;
name|printf
argument_list|(
literal|"\nstatic const struct insn_operand_data operand_data[] = \n{\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|d
operator|=
name|odata
init|;
name|d
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
block|{
name|printf
argument_list|(
literal|"  {\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    %s,\n"
argument_list|,
name|d
operator|->
name|predicate
operator|&&
name|d
operator|->
name|predicate
index|[
literal|0
index|]
condition|?
name|d
operator|->
name|predicate
else|:
literal|"0"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    \"%s\",\n"
argument_list|,
name|d
operator|->
name|constraint
condition|?
name|d
operator|->
name|constraint
else|:
literal|""
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    %smode,\n"
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|d
operator|->
name|mode
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    %d,\n"
argument_list|,
name|d
operator|->
name|strict_low
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    %d\n"
argument_list|,
name|d
operator|->
name|eliminable
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  },\n"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"};\n\n\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_insn_data
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|data
modifier|*
name|d
decl_stmt|;
name|int
name|name_offset
init|=
literal|0
decl_stmt|;
name|int
name|next_name_offset
decl_stmt|;
specifier|const
name|char
modifier|*
name|last_name
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|next_name
init|=
literal|0
decl_stmt|;
name|struct
name|data
modifier|*
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
name|idata
operator|,
name|next_name_offset
operator|=
literal|1
init|;
name|n
condition|;
name|n
operator|=
name|n
operator|->
name|next
operator|,
name|next_name_offset
operator|++
control|)
if|if
condition|(
name|n
operator|->
name|name
condition|)
block|{
name|next_name
operator|=
name|n
operator|->
name|name
expr_stmt|;
break|break;
block|}
name|printf
argument_list|(
literal|"#if GCC_VERSION>= 2007\n__extension__\n#endif\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\nconst struct insn_data insn_data[] = \n{\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|d
operator|=
name|idata
init|;
name|d
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
block|{
name|printf
argument_list|(
literal|"  /* %s:%d */\n"
argument_list|,
name|d
operator|->
name|filename
argument_list|,
name|d
operator|->
name|lineno
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  {\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|name
condition|)
block|{
name|printf
argument_list|(
literal|"    \"%s\",\n"
argument_list|,
name|d
operator|->
name|name
argument_list|)
expr_stmt|;
name|name_offset
operator|=
literal|0
expr_stmt|;
name|last_name
operator|=
name|d
operator|->
name|name
expr_stmt|;
name|next_name
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|n
operator|=
name|d
operator|->
name|next
operator|,
name|next_name_offset
operator|=
literal|1
init|;
name|n
condition|;
name|n
operator|=
name|n
operator|->
name|next
operator|,
name|next_name_offset
operator|++
control|)
block|{
if|if
condition|(
name|n
operator|->
name|name
condition|)
block|{
name|next_name
operator|=
name|n
operator|->
name|name
expr_stmt|;
break|break;
block|}
block|}
block|}
else|else
block|{
name|name_offset
operator|++
expr_stmt|;
if|if
condition|(
name|next_name
operator|&&
operator|(
name|last_name
operator|==
literal|0
operator|||
name|name_offset
operator|>
name|next_name_offset
operator|/
literal|2
operator|)
condition|)
name|printf
argument_list|(
literal|"    \"%s-%d\",\n"
argument_list|,
name|next_name
argument_list|,
name|next_name_offset
operator|-
name|name_offset
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"    \"%s+%d\",\n"
argument_list|,
name|last_name
argument_list|,
name|name_offset
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|d
operator|->
name|output_format
condition|)
block|{
case|case
name|INSN_OUTPUT_FORMAT_NONE
case|:
name|printf
argument_list|(
literal|"#if HAVE_DESIGNATED_INITIALIZERS\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    { 0 },\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#else\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    { 0, 0, 0 },\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#endif\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|INSN_OUTPUT_FORMAT_SINGLE
case|:
block|{
specifier|const
name|char
modifier|*
name|p
init|=
name|d
operator|->
name|template
decl_stmt|;
name|char
name|prev
init|=
literal|0
decl_stmt|;
name|printf
argument_list|(
literal|"#if HAVE_DESIGNATED_INITIALIZERS\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    { .single =\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#else\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    {\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#endif\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    \""
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
block|{
if|if
condition|(
name|IS_VSPACE
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|prev
operator|!=
literal|'\\'
condition|)
block|{
comment|/* Preserve two consecutive \n's or \r's, but treat \r\n 		       as a single newline.  */
if|if
condition|(
operator|*
name|p
operator|==
literal|'\n'
operator|&&
name|prev
operator|!=
literal|'\r'
condition|)
name|printf
argument_list|(
literal|"\\n\\\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|putchar
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
name|prev
operator|=
operator|*
name|p
expr_stmt|;
operator|++
name|p
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\",\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#if HAVE_DESIGNATED_INITIALIZERS\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    },\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#else\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    0, 0 },\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#endif\n"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|INSN_OUTPUT_FORMAT_MULTI
case|:
name|printf
argument_list|(
literal|"#if HAVE_DESIGNATED_INITIALIZERS\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    { .multi = output_%d },\n"
argument_list|,
name|d
operator|->
name|code_number
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#else\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    { 0, output_%d, 0 },\n"
argument_list|,
name|d
operator|->
name|code_number
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#endif\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|INSN_OUTPUT_FORMAT_FUNCTION
case|:
name|printf
argument_list|(
literal|"#if HAVE_DESIGNATED_INITIALIZERS\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    { .function = output_%d },\n"
argument_list|,
name|d
operator|->
name|code_number
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#else\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    { 0, 0, output_%d },\n"
argument_list|,
name|d
operator|->
name|code_number
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#endif\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|d
operator|->
name|name
operator|&&
name|d
operator|->
name|name
index|[
literal|0
index|]
operator|!=
literal|'*'
condition|)
name|printf
argument_list|(
literal|"    (insn_gen_fn) gen_%s,\n"
argument_list|,
name|d
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"    0,\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"&operand_data[%d],\n"
argument_list|,
name|d
operator|->
name|operand_number
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    %d,\n"
argument_list|,
name|d
operator|->
name|n_operands
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    %d,\n"
argument_list|,
name|d
operator|->
name|n_dups
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    %d,\n"
argument_list|,
name|d
operator|->
name|n_alternatives
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    %d\n"
argument_list|,
name|d
operator|->
name|output_format
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  },\n"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"};\n\n\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_get_insn_name
parameter_list|(
name|void
parameter_list|)
block|{
name|printf
argument_list|(
literal|"const char *\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"get_insn_name (int code)\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"{\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  if (code == NOOP_MOVE_INSN_CODE)\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    return \"NOOP_MOVE\";\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  else\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    return insn_data[code].name;\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"}\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Stores in max_opno the largest operand number present in `part', if    that is larger than the previous value of max_opno, and the rest of    the operand data into `d->operand[i]'.     THIS_ADDRESS_P is nonzero if the containing rtx was an ADDRESS.    THIS_STRICT_LOW is nonzero if the containing rtx was a STRICT_LOW_PART.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|max_opno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|num_dups
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|scan_operands
parameter_list|(
name|struct
name|data
modifier|*
name|d
parameter_list|,
name|rtx
name|part
parameter_list|,
name|int
name|this_address_p
parameter_list|,
name|int
name|this_strict_low
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|const
name|char
modifier|*
name|format_ptr
decl_stmt|;
name|int
name|opno
decl_stmt|;
if|if
condition|(
name|part
operator|==
literal|0
condition|)
return|return;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|part
argument_list|)
condition|)
block|{
case|case
name|MATCH_OPERAND
case|:
name|opno
operator|=
name|XINT
argument_list|(
name|part
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|opno
operator|>
name|max_opno
condition|)
name|max_opno
operator|=
name|opno
expr_stmt|;
if|if
condition|(
name|max_opno
operator|>=
name|MAX_MAX_OPERANDS
condition|)
block|{
name|message_with_line
argument_list|(
name|d
operator|->
name|lineno
argument_list|,
literal|"maximum number of operands exceeded"
argument_list|)
expr_stmt|;
name|have_error
operator|=
literal|1
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|d
operator|->
name|operand
index|[
name|opno
index|]
operator|.
name|seen
condition|)
block|{
name|message_with_line
argument_list|(
name|d
operator|->
name|lineno
argument_list|,
literal|"repeated operand number %d\n"
argument_list|,
name|opno
argument_list|)
expr_stmt|;
name|have_error
operator|=
literal|1
expr_stmt|;
block|}
name|d
operator|->
name|operand
index|[
name|opno
index|]
operator|.
name|seen
operator|=
literal|1
expr_stmt|;
name|d
operator|->
name|operand
index|[
name|opno
index|]
operator|.
name|mode
operator|=
name|GET_MODE
argument_list|(
name|part
argument_list|)
expr_stmt|;
name|d
operator|->
name|operand
index|[
name|opno
index|]
operator|.
name|strict_low
operator|=
name|this_strict_low
expr_stmt|;
name|d
operator|->
name|operand
index|[
name|opno
index|]
operator|.
name|predicate
operator|=
name|XSTR
argument_list|(
name|part
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|d
operator|->
name|operand
index|[
name|opno
index|]
operator|.
name|constraint
operator|=
name|strip_whitespace
argument_list|(
name|XSTR
argument_list|(
name|part
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|->
name|operand
index|[
name|opno
index|]
operator|.
name|n_alternatives
operator|=
name|n_occurrences
argument_list|(
literal|','
argument_list|,
name|d
operator|->
name|operand
index|[
name|opno
index|]
operator|.
name|constraint
argument_list|)
operator|+
literal|1
expr_stmt|;
name|d
operator|->
name|operand
index|[
name|opno
index|]
operator|.
name|address_p
operator|=
name|this_address_p
expr_stmt|;
name|d
operator|->
name|operand
index|[
name|opno
index|]
operator|.
name|eliminable
operator|=
literal|1
expr_stmt|;
return|return;
case|case
name|MATCH_SCRATCH
case|:
name|opno
operator|=
name|XINT
argument_list|(
name|part
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|opno
operator|>
name|max_opno
condition|)
name|max_opno
operator|=
name|opno
expr_stmt|;
if|if
condition|(
name|max_opno
operator|>=
name|MAX_MAX_OPERANDS
condition|)
block|{
name|message_with_line
argument_list|(
name|d
operator|->
name|lineno
argument_list|,
literal|"maximum number of operands exceeded"
argument_list|)
expr_stmt|;
name|have_error
operator|=
literal|1
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|d
operator|->
name|operand
index|[
name|opno
index|]
operator|.
name|seen
condition|)
block|{
name|message_with_line
argument_list|(
name|d
operator|->
name|lineno
argument_list|,
literal|"repeated operand number %d\n"
argument_list|,
name|opno
argument_list|)
expr_stmt|;
name|have_error
operator|=
literal|1
expr_stmt|;
block|}
name|d
operator|->
name|operand
index|[
name|opno
index|]
operator|.
name|seen
operator|=
literal|1
expr_stmt|;
name|d
operator|->
name|operand
index|[
name|opno
index|]
operator|.
name|mode
operator|=
name|GET_MODE
argument_list|(
name|part
argument_list|)
expr_stmt|;
name|d
operator|->
name|operand
index|[
name|opno
index|]
operator|.
name|strict_low
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|operand
index|[
name|opno
index|]
operator|.
name|predicate
operator|=
literal|"scratch_operand"
expr_stmt|;
name|d
operator|->
name|operand
index|[
name|opno
index|]
operator|.
name|constraint
operator|=
name|strip_whitespace
argument_list|(
name|XSTR
argument_list|(
name|part
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|->
name|operand
index|[
name|opno
index|]
operator|.
name|n_alternatives
operator|=
name|n_occurrences
argument_list|(
literal|','
argument_list|,
name|d
operator|->
name|operand
index|[
name|opno
index|]
operator|.
name|constraint
argument_list|)
operator|+
literal|1
expr_stmt|;
name|d
operator|->
name|operand
index|[
name|opno
index|]
operator|.
name|address_p
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|operand
index|[
name|opno
index|]
operator|.
name|eliminable
operator|=
literal|0
expr_stmt|;
return|return;
case|case
name|MATCH_OPERATOR
case|:
case|case
name|MATCH_PARALLEL
case|:
name|opno
operator|=
name|XINT
argument_list|(
name|part
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|opno
operator|>
name|max_opno
condition|)
name|max_opno
operator|=
name|opno
expr_stmt|;
if|if
condition|(
name|max_opno
operator|>=
name|MAX_MAX_OPERANDS
condition|)
block|{
name|message_with_line
argument_list|(
name|d
operator|->
name|lineno
argument_list|,
literal|"maximum number of operands exceeded"
argument_list|)
expr_stmt|;
name|have_error
operator|=
literal|1
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|d
operator|->
name|operand
index|[
name|opno
index|]
operator|.
name|seen
condition|)
block|{
name|message_with_line
argument_list|(
name|d
operator|->
name|lineno
argument_list|,
literal|"repeated operand number %d\n"
argument_list|,
name|opno
argument_list|)
expr_stmt|;
name|have_error
operator|=
literal|1
expr_stmt|;
block|}
name|d
operator|->
name|operand
index|[
name|opno
index|]
operator|.
name|seen
operator|=
literal|1
expr_stmt|;
name|d
operator|->
name|operand
index|[
name|opno
index|]
operator|.
name|mode
operator|=
name|GET_MODE
argument_list|(
name|part
argument_list|)
expr_stmt|;
name|d
operator|->
name|operand
index|[
name|opno
index|]
operator|.
name|strict_low
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|operand
index|[
name|opno
index|]
operator|.
name|predicate
operator|=
name|XSTR
argument_list|(
name|part
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|d
operator|->
name|operand
index|[
name|opno
index|]
operator|.
name|constraint
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|operand
index|[
name|opno
index|]
operator|.
name|address_p
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|operand
index|[
name|opno
index|]
operator|.
name|eliminable
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|part
argument_list|,
literal|2
argument_list|)
condition|;
name|i
operator|++
control|)
name|scan_operands
argument_list|(
name|d
argument_list|,
name|XVECEXP
argument_list|(
name|part
argument_list|,
literal|2
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
case|case
name|MATCH_DUP
case|:
case|case
name|MATCH_OP_DUP
case|:
case|case
name|MATCH_PAR_DUP
case|:
operator|++
name|num_dups
expr_stmt|;
break|break;
case|case
name|ADDRESS
case|:
name|scan_operands
argument_list|(
name|d
argument_list|,
name|XEXP
argument_list|(
name|part
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
case|case
name|STRICT_LOW_PART
case|:
name|scan_operands
argument_list|(
name|d
argument_list|,
name|XEXP
argument_list|(
name|part
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
default|default:
break|break;
block|}
name|format_ptr
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|part
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|part
argument_list|)
argument_list|)
condition|;
name|i
operator|++
control|)
switch|switch
condition|(
operator|*
name|format_ptr
operator|++
condition|)
block|{
case|case
literal|'e'
case|:
case|case
literal|'u'
case|:
name|scan_operands
argument_list|(
name|d
argument_list|,
name|XEXP
argument_list|(
name|part
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
if|if
condition|(
name|XVEC
argument_list|(
name|part
argument_list|,
name|i
argument_list|)
operator|!=
name|NULL
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|part
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|scan_operands
argument_list|(
name|d
argument_list|,
name|XVECEXP
argument_list|(
name|part
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Compare two operands for content equality.  */
end_comment

begin_function
specifier|static
name|int
name|compare_operands
parameter_list|(
name|struct
name|operand_data
modifier|*
name|d0
parameter_list|,
name|struct
name|operand_data
modifier|*
name|d1
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p0
decl_stmt|,
modifier|*
name|p1
decl_stmt|;
name|p0
operator|=
name|d0
operator|->
name|predicate
expr_stmt|;
if|if
condition|(
operator|!
name|p0
condition|)
name|p0
operator|=
literal|""
expr_stmt|;
name|p1
operator|=
name|d1
operator|->
name|predicate
expr_stmt|;
if|if
condition|(
operator|!
name|p1
condition|)
name|p1
operator|=
literal|""
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|p0
argument_list|,
name|p1
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
name|p0
operator|=
name|d0
operator|->
name|constraint
expr_stmt|;
if|if
condition|(
operator|!
name|p0
condition|)
name|p0
operator|=
literal|""
expr_stmt|;
name|p1
operator|=
name|d1
operator|->
name|constraint
expr_stmt|;
if|if
condition|(
operator|!
name|p1
condition|)
name|p1
operator|=
literal|""
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|p0
argument_list|,
name|p1
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|d0
operator|->
name|mode
operator|!=
name|d1
operator|->
name|mode
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|d0
operator|->
name|strict_low
operator|!=
name|d1
operator|->
name|strict_low
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|d0
operator|->
name|eliminable
operator|!=
name|d1
operator|->
name|eliminable
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Scan the list of operands we've already committed to output and either    find a subsequence that is the same, or allocate a new one at the end.  */
end_comment

begin_function
specifier|static
name|void
name|place_operands
parameter_list|(
name|struct
name|data
modifier|*
name|d
parameter_list|)
block|{
name|struct
name|operand_data
modifier|*
name|od
decl_stmt|,
modifier|*
name|od2
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|n_operands
operator|==
literal|0
condition|)
block|{
name|d
operator|->
name|operand_number
operator|=
literal|0
expr_stmt|;
return|return;
block|}
comment|/* Brute force substring search.  */
for|for
control|(
name|od
operator|=
name|odata
operator|,
name|i
operator|=
literal|0
init|;
name|od
condition|;
name|od
operator|=
name|od
operator|->
name|next
operator|,
name|i
operator|=
literal|0
control|)
if|if
condition|(
name|compare_operands
argument_list|(
name|od
argument_list|,
operator|&
name|d
operator|->
name|operand
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|od2
operator|=
name|od
operator|->
name|next
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|i
operator|==
name|d
operator|->
name|n_operands
condition|)
goto|goto
name|full_match
goto|;
if|if
condition|(
name|od2
operator|==
name|NULL
condition|)
goto|goto
name|partial_match
goto|;
if|if
condition|(
operator|!
name|compare_operands
argument_list|(
name|od2
argument_list|,
operator|&
name|d
operator|->
name|operand
index|[
name|i
index|]
argument_list|)
condition|)
break|break;
operator|++
name|i
operator|,
name|od2
operator|=
name|od2
operator|->
name|next
expr_stmt|;
block|}
block|}
comment|/* Either partial match at the end of the list, or no match.  In either      case, we tack on what operands are remaining to the end of the list.  */
name|partial_match
label|:
name|d
operator|->
name|operand_number
operator|=
name|next_operand_number
operator|-
name|i
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|d
operator|->
name|n_operands
condition|;
operator|++
name|i
control|)
block|{
name|od2
operator|=
operator|&
name|d
operator|->
name|operand
index|[
name|i
index|]
expr_stmt|;
operator|*
name|odata_end
operator|=
name|od2
expr_stmt|;
name|odata_end
operator|=
operator|&
name|od2
operator|->
name|next
expr_stmt|;
name|od2
operator|->
name|index
operator|=
name|next_operand_number
operator|++
expr_stmt|;
block|}
operator|*
name|odata_end
operator|=
name|NULL
expr_stmt|;
return|return;
name|full_match
label|:
name|d
operator|->
name|operand_number
operator|=
name|od
operator|->
name|index
expr_stmt|;
return|return;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Process an assembler template from a define_insn or a define_peephole.    It is either the assembler code template, a list of assembler code    templates, or C code to generate the assembler code template.  */
end_comment

begin_function
specifier|static
name|void
name|process_template
parameter_list|(
name|struct
name|data
modifier|*
name|d
parameter_list|,
specifier|const
name|char
modifier|*
name|template
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Templates starting with * contain straight code to be run.  */
if|if
condition|(
name|template
index|[
literal|0
index|]
operator|==
literal|'*'
condition|)
block|{
name|d
operator|->
name|template
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|output_format
operator|=
name|INSN_OUTPUT_FORMAT_FUNCTION
expr_stmt|;
name|puts
argument_list|(
literal|"\nstatic const char *"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"output_%d (rtx *operands ATTRIBUTE_UNUSED, rtx insn ATTRIBUTE_UNUSED)\n"
argument_list|,
name|d
operator|->
name|code_number
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
name|print_rtx_ptr_loc
argument_list|(
name|template
argument_list|)
expr_stmt|;
name|puts
argument_list|(
name|template
operator|+
literal|1
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
block|}
comment|/* If the assembler code template starts with a @ it is a newline-separated      list of assembler code templates, one for each alternative.  */
elseif|else
if|if
condition|(
name|template
index|[
literal|0
index|]
operator|==
literal|'@'
condition|)
block|{
name|d
operator|->
name|template
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|output_format
operator|=
name|INSN_OUTPUT_FORMAT_MULTI
expr_stmt|;
name|printf
argument_list|(
literal|"\nstatic const char * const output_%d[] = {\n"
argument_list|,
name|d
operator|->
name|code_number
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|cp
operator|=
operator|&
name|template
index|[
literal|1
index|]
init|;
operator|*
name|cp
condition|;
control|)
block|{
specifier|const
name|char
modifier|*
name|ep
decl_stmt|,
modifier|*
name|sp
decl_stmt|;
while|while
condition|(
name|ISSPACE
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|cp
operator|++
expr_stmt|;
name|printf
argument_list|(
literal|"  \""
argument_list|)
expr_stmt|;
for|for
control|(
name|ep
operator|=
name|sp
operator|=
name|cp
init|;
operator|!
name|IS_VSPACE
argument_list|(
operator|*
name|ep
argument_list|)
operator|&&
operator|*
name|ep
operator|!=
literal|'\0'
condition|;
operator|++
name|ep
control|)
if|if
condition|(
operator|!
name|ISSPACE
argument_list|(
operator|*
name|ep
argument_list|)
condition|)
name|sp
operator|=
name|ep
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|sp
operator|!=
name|ep
condition|)
name|message_with_line
argument_list|(
name|d
operator|->
name|lineno
argument_list|,
literal|"trailing whitespace in output template"
argument_list|)
expr_stmt|;
while|while
condition|(
name|cp
operator|<
name|sp
condition|)
block|{
name|putchar
argument_list|(
operator|*
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|++
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\",\n"
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
literal|1
condition|)
name|message_with_line
argument_list|(
name|d
operator|->
name|lineno
argument_list|,
literal|"'@' is redundant for output template with single alternative"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|d
operator|->
name|n_alternatives
condition|)
block|{
name|message_with_line
argument_list|(
name|d
operator|->
name|lineno
argument_list|,
literal|"wrong number of alternatives in the output template"
argument_list|)
expr_stmt|;
name|have_error
operator|=
literal|1
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"};\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|d
operator|->
name|template
operator|=
name|template
expr_stmt|;
name|d
operator|->
name|output_format
operator|=
name|INSN_OUTPUT_FORMAT_SINGLE
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Check insn D for consistency in number of constraint alternatives.  */
end_comment

begin_function
specifier|static
name|void
name|validate_insn_alternatives
parameter_list|(
name|struct
name|data
modifier|*
name|d
parameter_list|)
block|{
name|int
name|n
init|=
literal|0
decl_stmt|,
name|start
decl_stmt|;
comment|/* Make sure all the operands have the same number of alternatives      in their constraints.  Let N be that number.  */
for|for
control|(
name|start
operator|=
literal|0
init|;
name|start
operator|<
name|d
operator|->
name|n_operands
condition|;
name|start
operator|++
control|)
if|if
condition|(
name|d
operator|->
name|operand
index|[
name|start
index|]
operator|.
name|n_alternatives
operator|>
literal|0
condition|)
block|{
name|int
name|len
decl_stmt|,
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|c
decl_stmt|;
name|int
name|which_alternative
init|=
literal|0
decl_stmt|;
name|int
name|alternative_count_unsure
init|=
literal|0
decl_stmt|;
for|for
control|(
name|p
operator|=
name|d
operator|->
name|operand
index|[
name|start
index|]
operator|.
name|constraint
init|;
operator|(
name|c
operator|=
operator|*
name|p
operator|)
condition|;
name|p
operator|+=
name|len
control|)
block|{
ifdef|#
directive|ifdef
name|USE_MD_CONSTRAINTS
if|if
condition|(
name|ISSPACE
argument_list|(
name|c
argument_list|)
operator|||
name|strchr
argument_list|(
name|indep_constraints
argument_list|,
name|c
argument_list|)
condition|)
name|len
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|ISDIGIT
argument_list|(
name|c
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|q
init|=
name|p
decl_stmt|;
do|do
name|q
operator|++
expr_stmt|;
do|while
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|q
argument_list|)
condition|)
do|;
name|len
operator|=
name|q
operator|-
name|p
expr_stmt|;
block|}
else|else
name|len
operator|=
name|mdep_constraint_len
argument_list|(
name|p
argument_list|,
name|d
operator|->
name|lineno
argument_list|,
name|start
argument_list|)
expr_stmt|;
else|#
directive|else
name|len
operator|=
name|CONSTRAINT_LEN
argument_list|(
name|c
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|1
operator|||
operator|(
name|len
operator|>
literal|1
operator|&&
name|strchr
argument_list|(
literal|",#*+=&%!0123456789"
argument_list|,
name|c
argument_list|)
operator|)
condition|)
block|{
name|message_with_line
argument_list|(
name|d
operator|->
name|lineno
argument_list|,
literal|"invalid length %d for char '%c' in alternative %d of operand %d"
argument_list|,
name|len
argument_list|,
name|c
argument_list|,
name|which_alternative
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|len
operator|=
literal|1
expr_stmt|;
name|have_error
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|c
operator|==
literal|','
condition|)
block|{
name|which_alternative
operator|++
expr_stmt|;
continue|continue;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|p
index|[
name|i
index|]
operator|==
literal|'\0'
condition|)
block|{
name|message_with_line
argument_list|(
name|d
operator|->
name|lineno
argument_list|,
literal|"NUL in alternative %d of operand %d"
argument_list|,
name|which_alternative
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|alternative_count_unsure
operator|=
literal|1
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|strchr
argument_list|(
literal|",#*"
argument_list|,
name|p
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|message_with_line
argument_list|(
name|d
operator|->
name|lineno
argument_list|,
literal|"'%c' in alternative %d of operand %d"
argument_list|,
name|p
index|[
name|i
index|]
argument_list|,
name|which_alternative
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|alternative_count_unsure
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|alternative_count_unsure
condition|)
name|have_error
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|n
operator|==
literal|0
condition|)
name|n
operator|=
name|d
operator|->
name|operand
index|[
name|start
index|]
operator|.
name|n_alternatives
expr_stmt|;
elseif|else
if|if
condition|(
name|n
operator|!=
name|d
operator|->
name|operand
index|[
name|start
index|]
operator|.
name|n_alternatives
condition|)
block|{
name|message_with_line
argument_list|(
name|d
operator|->
name|lineno
argument_list|,
literal|"wrong number of alternatives in operand %d"
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|have_error
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* Record the insn's overall number of alternatives.  */
name|d
operator|->
name|n_alternatives
operator|=
name|n
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Verify that there are no gaps in operand numbers for INSNs.  */
end_comment

begin_function
specifier|static
name|void
name|validate_insn_operands
parameter_list|(
name|struct
name|data
modifier|*
name|d
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|n_operands
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|d
operator|->
name|operand
index|[
name|i
index|]
operator|.
name|seen
operator|==
literal|0
condition|)
block|{
name|message_with_line
argument_list|(
name|d
operator|->
name|lineno
argument_list|,
literal|"missing operand %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|have_error
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Look at a define_insn just read.  Assign its code number.  Record    on idata the template and the number of arguments.  If the insn has    a hairy output action, output a function for now.  */
end_comment

begin_function
specifier|static
name|void
name|gen_insn
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|int
name|lineno
parameter_list|)
block|{
name|struct
name|data
modifier|*
name|d
init|=
name|XNEW
argument_list|(
expr|struct
name|data
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|d
operator|->
name|code_number
operator|=
name|next_code_number
expr_stmt|;
name|d
operator|->
name|index_number
operator|=
name|next_index_number
expr_stmt|;
name|d
operator|->
name|filename
operator|=
name|read_rtx_filename
expr_stmt|;
name|d
operator|->
name|lineno
operator|=
name|lineno
expr_stmt|;
if|if
condition|(
name|XSTR
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|)
index|[
literal|0
index|]
condition|)
name|d
operator|->
name|name
operator|=
name|XSTR
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|d
operator|->
name|name
operator|=
literal|0
expr_stmt|;
comment|/* Build up the list in the same order as the insns are seen      in the machine description.  */
name|d
operator|->
name|next
operator|=
literal|0
expr_stmt|;
operator|*
name|idata_end
operator|=
name|d
expr_stmt|;
name|idata_end
operator|=
operator|&
name|d
operator|->
name|next
expr_stmt|;
name|max_opno
operator|=
operator|-
literal|1
expr_stmt|;
name|num_dups
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
name|d
operator|->
name|operand
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|d
operator|->
name|operand
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|)
condition|;
name|i
operator|++
control|)
name|scan_operands
argument_list|(
name|d
argument_list|,
name|XVECEXP
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|d
operator|->
name|n_operands
operator|=
name|max_opno
operator|+
literal|1
expr_stmt|;
name|d
operator|->
name|n_dups
operator|=
name|num_dups
expr_stmt|;
ifndef|#
directive|ifndef
name|USE_MD_CONSTRAINTS
name|check_constraint_len
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|validate_insn_operands
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|validate_insn_alternatives
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|place_operands
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|process_template
argument_list|(
name|d
argument_list|,
name|XTMPL
argument_list|(
name|insn
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Look at a define_peephole just read.  Assign its code number.    Record on idata the template and the number of arguments.    If the insn has a hairy output action, output it now.  */
end_comment

begin_function
specifier|static
name|void
name|gen_peephole
parameter_list|(
name|rtx
name|peep
parameter_list|,
name|int
name|lineno
parameter_list|)
block|{
name|struct
name|data
modifier|*
name|d
init|=
name|XNEW
argument_list|(
expr|struct
name|data
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|d
operator|->
name|code_number
operator|=
name|next_code_number
expr_stmt|;
name|d
operator|->
name|index_number
operator|=
name|next_index_number
expr_stmt|;
name|d
operator|->
name|filename
operator|=
name|read_rtx_filename
expr_stmt|;
name|d
operator|->
name|lineno
operator|=
name|lineno
expr_stmt|;
name|d
operator|->
name|name
operator|=
literal|0
expr_stmt|;
comment|/* Build up the list in the same order as the insns are seen      in the machine description.  */
name|d
operator|->
name|next
operator|=
literal|0
expr_stmt|;
operator|*
name|idata_end
operator|=
name|d
expr_stmt|;
name|idata_end
operator|=
operator|&
name|d
operator|->
name|next
expr_stmt|;
name|max_opno
operator|=
operator|-
literal|1
expr_stmt|;
name|num_dups
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
name|d
operator|->
name|operand
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|d
operator|->
name|operand
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Get the number of operands by scanning all the patterns of the      peephole optimizer.  But ignore all the rest of the information      thus obtained.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|peep
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
name|scan_operands
argument_list|(
name|d
argument_list|,
name|XVECEXP
argument_list|(
name|peep
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|d
operator|->
name|n_operands
operator|=
name|max_opno
operator|+
literal|1
expr_stmt|;
name|d
operator|->
name|n_dups
operator|=
literal|0
expr_stmt|;
name|validate_insn_alternatives
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|place_operands
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|process_template
argument_list|(
name|d
argument_list|,
name|XTMPL
argument_list|(
name|peep
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Process a define_expand just read.  Assign its code number,    only for the purposes of `insn_gen_function'.  */
end_comment

begin_function
specifier|static
name|void
name|gen_expand
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|int
name|lineno
parameter_list|)
block|{
name|struct
name|data
modifier|*
name|d
init|=
name|XNEW
argument_list|(
expr|struct
name|data
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|d
operator|->
name|code_number
operator|=
name|next_code_number
expr_stmt|;
name|d
operator|->
name|index_number
operator|=
name|next_index_number
expr_stmt|;
name|d
operator|->
name|filename
operator|=
name|read_rtx_filename
expr_stmt|;
name|d
operator|->
name|lineno
operator|=
name|lineno
expr_stmt|;
if|if
condition|(
name|XSTR
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|)
index|[
literal|0
index|]
condition|)
name|d
operator|->
name|name
operator|=
name|XSTR
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|d
operator|->
name|name
operator|=
literal|0
expr_stmt|;
comment|/* Build up the list in the same order as the insns are seen      in the machine description.  */
name|d
operator|->
name|next
operator|=
literal|0
expr_stmt|;
operator|*
name|idata_end
operator|=
name|d
expr_stmt|;
name|idata_end
operator|=
operator|&
name|d
operator|->
name|next
expr_stmt|;
name|max_opno
operator|=
operator|-
literal|1
expr_stmt|;
name|num_dups
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
name|d
operator|->
name|operand
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|d
operator|->
name|operand
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Scan the operands to get the specified predicates and modes,      since expand_binop needs to know them.  */
if|if
condition|(
name|XVEC
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|)
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|)
condition|;
name|i
operator|++
control|)
name|scan_operands
argument_list|(
name|d
argument_list|,
name|XVECEXP
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|d
operator|->
name|n_operands
operator|=
name|max_opno
operator|+
literal|1
expr_stmt|;
name|d
operator|->
name|n_dups
operator|=
name|num_dups
expr_stmt|;
name|d
operator|->
name|template
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|output_format
operator|=
name|INSN_OUTPUT_FORMAT_NONE
expr_stmt|;
name|validate_insn_alternatives
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|place_operands
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Process a define_split just read.  Assign its code number,    only for reasons of consistency and to simplify genrecog.  */
end_comment

begin_function
specifier|static
name|void
name|gen_split
parameter_list|(
name|rtx
name|split
parameter_list|,
name|int
name|lineno
parameter_list|)
block|{
name|struct
name|data
modifier|*
name|d
init|=
name|XNEW
argument_list|(
expr|struct
name|data
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|d
operator|->
name|code_number
operator|=
name|next_code_number
expr_stmt|;
name|d
operator|->
name|index_number
operator|=
name|next_index_number
expr_stmt|;
name|d
operator|->
name|filename
operator|=
name|read_rtx_filename
expr_stmt|;
name|d
operator|->
name|lineno
operator|=
name|lineno
expr_stmt|;
name|d
operator|->
name|name
operator|=
literal|0
expr_stmt|;
comment|/* Build up the list in the same order as the insns are seen      in the machine description.  */
name|d
operator|->
name|next
operator|=
literal|0
expr_stmt|;
operator|*
name|idata_end
operator|=
name|d
expr_stmt|;
name|idata_end
operator|=
operator|&
name|d
operator|->
name|next
expr_stmt|;
name|max_opno
operator|=
operator|-
literal|1
expr_stmt|;
name|num_dups
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
name|d
operator|->
name|operand
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|d
operator|->
name|operand
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Get the number of operands by scanning all the patterns of the      split patterns.  But ignore all the rest of the information thus      obtained.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|split
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
name|scan_operands
argument_list|(
name|d
argument_list|,
name|XVECEXP
argument_list|(
name|split
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|d
operator|->
name|n_operands
operator|=
name|max_opno
operator|+
literal|1
expr_stmt|;
name|d
operator|->
name|n_dups
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|n_alternatives
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|template
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|output_format
operator|=
name|INSN_OUTPUT_FORMAT_NONE
expr_stmt|;
name|place_operands
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
end_function

begin_function_decl
specifier|extern
name|int
name|main
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|rtx
name|desc
decl_stmt|;
name|progname
operator|=
literal|"genoutput"
expr_stmt|;
if|if
condition|(
name|init_md_reader_args
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
operator|!=
name|SUCCESS_EXIT_CODE
condition|)
return|return
operator|(
name|FATAL_EXIT_CODE
operator|)
return|;
name|output_prologue
argument_list|()
expr_stmt|;
name|next_code_number
operator|=
literal|0
expr_stmt|;
name|next_index_number
operator|=
literal|0
expr_stmt|;
comment|/* Read the machine description.  */
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|line_no
decl_stmt|;
name|desc
operator|=
name|read_md_rtx
argument_list|(
operator|&
name|line_no
argument_list|,
operator|&
name|next_code_number
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc
operator|==
name|NULL
condition|)
break|break;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|desc
argument_list|)
condition|)
block|{
case|case
name|DEFINE_INSN
case|:
name|gen_insn
argument_list|(
name|desc
argument_list|,
name|line_no
argument_list|)
expr_stmt|;
break|break;
case|case
name|DEFINE_PEEPHOLE
case|:
name|gen_peephole
argument_list|(
name|desc
argument_list|,
name|line_no
argument_list|)
expr_stmt|;
break|break;
case|case
name|DEFINE_EXPAND
case|:
name|gen_expand
argument_list|(
name|desc
argument_list|,
name|line_no
argument_list|)
expr_stmt|;
break|break;
case|case
name|DEFINE_SPLIT
case|:
case|case
name|DEFINE_PEEPHOLE2
case|:
name|gen_split
argument_list|(
name|desc
argument_list|,
name|line_no
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|USE_MD_CONSTRAINTS
case|case
name|DEFINE_CONSTRAINT
case|:
case|case
name|DEFINE_REGISTER_CONSTRAINT
case|:
case|case
name|DEFINE_ADDRESS_CONSTRAINT
case|:
case|case
name|DEFINE_MEMORY_CONSTRAINT
case|:
name|note_constraint
argument_list|(
name|desc
argument_list|,
name|line_no
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
break|break;
block|}
name|next_index_number
operator|++
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n\n"
argument_list|)
expr_stmt|;
name|output_operand_data
argument_list|()
expr_stmt|;
name|output_insn_data
argument_list|()
expr_stmt|;
name|output_get_insn_name
argument_list|()
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
return|return
operator|(
name|ferror
argument_list|(
name|stdout
argument_list|)
operator|!=
literal|0
operator|||
name|have_error
condition|?
name|FATAL_EXIT_CODE
else|:
name|SUCCESS_EXIT_CODE
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the number of occurrences of character C in string S or    -1 if S is the null string.  */
end_comment

begin_function
specifier|static
name|int
name|n_occurrences
parameter_list|(
name|int
name|c
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
name|int
name|n
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|s
operator|==
literal|0
operator|||
operator|*
name|s
operator|==
literal|'\0'
condition|)
return|return
operator|-
literal|1
return|;
while|while
condition|(
operator|*
name|s
condition|)
name|n
operator|+=
operator|(
operator|*
name|s
operator|++
operator|==
name|c
operator|)
expr_stmt|;
return|return
name|n
return|;
block|}
end_function

begin_comment
comment|/* Remove whitespace in `s' by moving up characters until the end.    Return a new string.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|strip_whitespace
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|char
name|ch
decl_stmt|;
if|if
condition|(
name|s
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|p
operator|=
name|q
operator|=
name|XNEWVEC
argument_list|(
name|char
argument_list|,
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
operator|*
name|s
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
if|if
condition|(
operator|!
name|ISSPACE
argument_list|(
name|ch
argument_list|)
condition|)
operator|*
name|p
operator|++
operator|=
name|ch
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
return|return
name|q
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|USE_MD_CONSTRAINTS
end_ifdef

begin_comment
comment|/* Record just enough information about a constraint to allow checking    of operand constraint strings above, in validate_insn_alternatives.    Does not validate most properties of the constraint itself; does    enforce no duplicate names, no overlap with MI constraints, and no    prefixes.  EXP is the define_*constraint form, LINENO the line number    reported by the reader.  */
end_comment

begin_function
specifier|static
name|void
name|note_constraint
parameter_list|(
name|rtx
name|exp
parameter_list|,
name|int
name|lineno
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|namelen
init|=
name|strlen
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|struct
name|constraint_data
modifier|*
modifier|*
name|iter
decl_stmt|,
modifier|*
modifier|*
name|slot
decl_stmt|,
modifier|*
name|new
decl_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|indep_constraints
argument_list|,
name|name
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|name
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
name|message_with_line
argument_list|(
name|lineno
argument_list|,
literal|"constraint letter '%s' cannot be "
literal|"redefined by the machine description"
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|message_with_line
argument_list|(
name|lineno
argument_list|,
literal|"constraint name '%s' cannot be defined by "
literal|"the machine description, as it begins with '%c'"
argument_list|,
name|name
argument_list|,
name|name
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|have_error
operator|=
literal|1
expr_stmt|;
return|return;
block|}
name|slot
operator|=
operator|&
name|constraints_by_letter_table
index|[
operator|(
name|unsigned
name|int
operator|)
name|name
index|[
literal|0
index|]
index|]
expr_stmt|;
for|for
control|(
name|iter
operator|=
name|slot
init|;
operator|*
name|iter
condition|;
name|iter
operator|=
operator|&
operator|(
operator|*
name|iter
operator|)
operator|->
name|next_this_letter
control|)
block|{
comment|/* This causes slot to end up pointing to the 	 next_this_letter field of the last constraint with a name 	 of equal or greater length than the new constraint; hence 	 the new constraint will be inserted after all previous 	 constraints with names of the same length.  */
if|if
condition|(
operator|(
operator|*
name|iter
operator|)
operator|->
name|namelen
operator|>=
name|namelen
condition|)
name|slot
operator|=
name|iter
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|(
operator|*
name|iter
operator|)
operator|->
name|name
argument_list|,
name|name
argument_list|)
condition|)
block|{
name|message_with_line
argument_list|(
name|lineno
argument_list|,
literal|"redefinition of constraint '%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|message_with_line
argument_list|(
operator|(
operator|*
name|iter
operator|)
operator|->
name|lineno
argument_list|,
literal|"previous definition is here"
argument_list|)
expr_stmt|;
name|have_error
operator|=
literal|1
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
operator|(
operator|*
name|iter
operator|)
operator|->
name|name
argument_list|,
name|name
argument_list|,
operator|(
operator|*
name|iter
operator|)
operator|->
name|namelen
argument_list|)
condition|)
block|{
name|message_with_line
argument_list|(
name|lineno
argument_list|,
literal|"defining constraint '%s' here"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|message_with_line
argument_list|(
operator|(
operator|*
name|iter
operator|)
operator|->
name|lineno
argument_list|,
literal|"renders constraint '%s' "
literal|"(defined here) a prefix"
argument_list|,
operator|(
operator|*
name|iter
operator|)
operator|->
name|name
argument_list|)
expr_stmt|;
name|have_error
operator|=
literal|1
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
operator|(
operator|*
name|iter
operator|)
operator|->
name|name
argument_list|,
name|name
argument_list|,
name|namelen
argument_list|)
condition|)
block|{
name|message_with_line
argument_list|(
name|lineno
argument_list|,
literal|"constraint '%s' is a prefix"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|message_with_line
argument_list|(
operator|(
operator|*
name|iter
operator|)
operator|->
name|lineno
argument_list|,
literal|"of constraint '%s' "
literal|"(defined here)"
argument_list|,
operator|(
operator|*
name|iter
operator|)
operator|->
name|name
argument_list|)
expr_stmt|;
name|have_error
operator|=
literal|1
expr_stmt|;
return|return;
block|}
block|}
name|new
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|constraint_data
argument_list|)
operator|+
name|namelen
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|new
operator|+
name|offsetof
argument_list|(
expr|struct
name|constraint_data
argument_list|,
name|name
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|new
operator|->
name|namelen
operator|=
name|namelen
expr_stmt|;
name|new
operator|->
name|lineno
operator|=
name|lineno
expr_stmt|;
name|new
operator|->
name|next_this_letter
operator|=
operator|*
name|slot
expr_stmt|;
operator|*
name|slot
operator|=
name|new
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the length of the constraint name beginning at position S    of an operand constraint string, or issue an error message if there    is no such constraint.  Does not expect to be called for generic    constraints.  */
end_comment

begin_function
specifier|static
name|int
name|mdep_constraint_len
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|int
name|lineno
parameter_list|,
name|int
name|opno
parameter_list|)
block|{
name|struct
name|constraint_data
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|constraints_by_letter_table
index|[
operator|(
name|unsigned
name|int
operator|)
name|s
index|[
literal|0
index|]
index|]
expr_stmt|;
if|if
condition|(
name|p
condition|)
for|for
control|(
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next_this_letter
control|)
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|s
argument_list|,
name|p
operator|->
name|name
argument_list|,
name|p
operator|->
name|namelen
argument_list|)
condition|)
return|return
name|p
operator|->
name|namelen
return|;
name|message_with_line
argument_list|(
name|lineno
argument_list|,
literal|"error: undefined machine-specific constraint "
literal|"at this point: \"%s\""
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|message_with_line
argument_list|(
name|lineno
argument_list|,
literal|"note:  in operand %d"
argument_list|,
name|opno
argument_list|)
expr_stmt|;
name|have_error
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
comment|/* safe */
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* Verify that DEFAULT_CONSTRAINT_LEN is used properly and not    tampered with.  This isn't bullet-proof, but it should catch    most genuine mistakes.  */
end_comment

begin_function
specifier|static
name|void
name|check_constraint_len
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|d
decl_stmt|;
for|for
control|(
name|p
operator|=
literal|",#*+=&%!1234567890"
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
for|for
control|(
name|d
operator|=
operator|-
literal|9
init|;
name|d
operator|<
literal|9
condition|;
name|d
operator|++
control|)
name|gcc_assert
argument_list|(
name|constraint_len
argument_list|(
name|p
argument_list|,
name|d
argument_list|)
operator|==
name|d
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|constraint_len
parameter_list|(
specifier|const
name|char
modifier|*
name|p
parameter_list|,
name|int
name|genoutput_default_constraint_len
parameter_list|)
block|{
comment|/* Check that we still match defaults.h .  First we do a generation-time      check that fails if the value is not the expected one...  */
name|gcc_assert
argument_list|(
name|DEFAULT_CONSTRAINT_LEN
argument_list|(
operator|*
name|p
argument_list|,
name|p
argument_list|)
operator|==
literal|1
argument_list|)
expr_stmt|;
comment|/* And now a compile-time check that should give a diagnostic if the      definition doesn't exactly match.  */
define|#
directive|define
name|DEFAULT_CONSTRAINT_LEN
parameter_list|(
name|C
parameter_list|,
name|STR
parameter_list|)
value|1
comment|/* Now re-define DEFAULT_CONSTRAINT_LEN so that we can verify it is      being used.  */
undef|#
directive|undef
name|DEFAULT_CONSTRAINT_LEN
define|#
directive|define
name|DEFAULT_CONSTRAINT_LEN
parameter_list|(
name|C
parameter_list|,
name|STR
parameter_list|)
define|\
value|((C) != *p || STR != p ? -1 : genoutput_default_constraint_len)
return|return
name|CONSTRAINT_LEN
argument_list|(
operator|*
name|p
argument_list|,
name|p
argument_list|)
return|;
comment|/* And set it back.  */
undef|#
directive|undef
name|DEFAULT_CONSTRAINT_LEN
define|#
directive|define
name|DEFAULT_CONSTRAINT_LEN
parameter_list|(
name|C
parameter_list|,
name|STR
parameter_list|)
value|1
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

