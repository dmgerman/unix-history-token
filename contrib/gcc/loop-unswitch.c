begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Loop unswitching for GNU compiler.    Copyright (C) 2002, 2003, 2004, 2005 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"cfgloop.h"
end_include

begin_include
include|#
directive|include
file|"cfglayout.h"
end_include

begin_include
include|#
directive|include
file|"params.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_comment
comment|/* This pass moves constant conditions out of loops, duplicating the loop    in progress, i.e. this code:     while (loop_cond)      {        A;        if (cond)          branch1;        else 	 branch2;        B;        if (cond)          branch3;        C;      }    where nothing inside the loop alters cond is transformed    into     if (cond)      {        while (loop_cond) 	 { 	   A; 	   branch1; 	   B; 	   branch3; 	   C; 	 }      }    else      {        while (loop_cond) 	 { 	   A; 	   branch2; 	   B; 	   C; 	 }      }    Duplicating the loop might lead to code growth exponential in number of   branches inside loop, so we limit the number of unswitchings performed   in a single loop to PARAM_MAX_UNSWITCH_LEVEL.  We only perform the   transformation on innermost loops, as the benefit of doing it on loops   containing subloops would not be very large compared to complications   with handling this case.  */
end_comment

begin_function_decl
specifier|static
name|struct
name|loop
modifier|*
name|unswitch_loop
parameter_list|(
name|struct
name|loops
modifier|*
parameter_list|,
name|struct
name|loop
modifier|*
parameter_list|,
name|basic_block
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|unswitch_single_loop
parameter_list|(
name|struct
name|loops
modifier|*
parameter_list|,
name|struct
name|loop
modifier|*
parameter_list|,
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|may_unswitch_on
parameter_list|(
name|basic_block
parameter_list|,
name|struct
name|loop
modifier|*
parameter_list|,
name|rtx
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Prepare a sequence comparing OP0 with OP1 using COMP and jumping to LABEL if    true, with probability PROB.  If CINSN is not NULL, it is the insn to copy    in order to create a jump.  */
end_comment

begin_function
name|rtx
name|compare_and_jump_seq
parameter_list|(
name|rtx
name|op0
parameter_list|,
name|rtx
name|op1
parameter_list|,
name|enum
name|rtx_code
name|comp
parameter_list|,
name|rtx
name|label
parameter_list|,
name|int
name|prob
parameter_list|,
name|rtx
name|cinsn
parameter_list|)
block|{
name|rtx
name|seq
decl_stmt|,
name|jump
decl_stmt|,
name|cond
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|mode
operator|=
name|GET_MODE
argument_list|(
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
name|mode
operator|=
name|GET_MODE
argument_list|(
name|op1
argument_list|)
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_CC
condition|)
block|{
comment|/* A hack -- there seems to be no easy generic way how to make a 	 conditional jump from a ccmode comparison.  */
name|gcc_assert
argument_list|(
name|cinsn
argument_list|)
expr_stmt|;
name|cond
operator|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|pc_set
argument_list|(
name|cinsn
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|cond
argument_list|)
operator|==
name|comp
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|rtx_equal_p
argument_list|(
name|op0
argument_list|,
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|rtx_equal_p
argument_list|(
name|op1
argument_list|,
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|copy_insn
argument_list|(
name|PATTERN
argument_list|(
name|cinsn
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|jump
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
name|JUMP_LABEL
argument_list|(
name|jump
argument_list|)
operator|=
name|JUMP_LABEL
argument_list|(
name|cinsn
argument_list|)
expr_stmt|;
name|LABEL_NUSES
argument_list|(
name|JUMP_LABEL
argument_list|(
name|jump
argument_list|)
argument_list|)
operator|++
expr_stmt|;
name|redirect_jump
argument_list|(
name|jump
argument_list|,
name|label
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gcc_assert
argument_list|(
operator|!
name|cinsn
argument_list|)
expr_stmt|;
name|op0
operator|=
name|force_operand
argument_list|(
name|op0
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|op1
operator|=
name|force_operand
argument_list|(
name|op1
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|do_compare_rtx_and_jump
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|,
name|comp
argument_list|,
literal|0
argument_list|,
name|mode
argument_list|,
name|NULL_RTX
argument_list|,
name|NULL_RTX
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|jump
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
name|JUMP_LABEL
argument_list|(
name|jump
argument_list|)
operator|=
name|label
expr_stmt|;
name|LABEL_NUSES
argument_list|(
name|label
argument_list|)
operator|++
expr_stmt|;
block|}
name|REG_NOTES
argument_list|(
name|jump
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_BR_PROB
argument_list|,
name|GEN_INT
argument_list|(
name|prob
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|jump
argument_list|)
argument_list|)
expr_stmt|;
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
return|return
name|seq
return|;
block|}
end_function

begin_comment
comment|/* Main entry point.  Perform loop unswitching on all suitable LOOPS.  */
end_comment

begin_function
name|void
name|unswitch_loops
parameter_list|(
name|struct
name|loops
modifier|*
name|loops
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|num
decl_stmt|;
name|struct
name|loop
modifier|*
name|loop
decl_stmt|;
comment|/* Go through inner loops (only original ones).  */
name|num
operator|=
name|loops
operator|->
name|num
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
comment|/* Removed loop?  */
name|loop
operator|=
name|loops
operator|->
name|parray
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|loop
condition|)
continue|continue;
if|if
condition|(
name|loop
operator|->
name|inner
condition|)
continue|continue;
name|unswitch_single_loop
argument_list|(
name|loops
argument_list|,
name|loop
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
name|verify_dominators
argument_list|(
name|CDI_DOMINATORS
argument_list|)
expr_stmt|;
name|verify_loop_structure
argument_list|(
name|loops
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|iv_analysis_done
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Checks whether we can unswitch LOOP on condition at end of BB -- one of its    basic blocks (for what it means see comments below).  In case condition    compares loop invariant cc mode register, return the jump in CINSN.  */
end_comment

begin_function
specifier|static
name|rtx
name|may_unswitch_on
parameter_list|(
name|basic_block
name|bb
parameter_list|,
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|rtx
modifier|*
name|cinsn
parameter_list|)
block|{
name|rtx
name|test
decl_stmt|,
name|at
decl_stmt|,
name|op
index|[
literal|2
index|]
decl_stmt|,
name|stest
decl_stmt|;
name|struct
name|rtx_iv
name|iv
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
comment|/* BB must end in a simple conditional jump.  */
if|if
condition|(
name|EDGE_COUNT
argument_list|(
name|bb
operator|->
name|succs
argument_list|)
operator|!=
literal|2
condition|)
return|return
name|NULL_RTX
return|;
if|if
condition|(
operator|!
name|any_condjump_p
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
condition|)
return|return
name|NULL_RTX
return|;
comment|/* With branches inside loop.  */
if|if
condition|(
operator|!
name|flow_bb_inside_loop_p
argument_list|(
name|loop
argument_list|,
name|EDGE_SUCC
argument_list|(
name|bb
argument_list|,
literal|0
argument_list|)
operator|->
name|dest
argument_list|)
operator|||
operator|!
name|flow_bb_inside_loop_p
argument_list|(
name|loop
argument_list|,
name|EDGE_SUCC
argument_list|(
name|bb
argument_list|,
literal|1
argument_list|)
operator|->
name|dest
argument_list|)
condition|)
return|return
name|NULL_RTX
return|;
comment|/* It must be executed just once each iteration (because otherwise we      are unable to update dominator/irreducible loop information correctly).  */
if|if
condition|(
operator|!
name|just_once_each_iteration_p
argument_list|(
name|loop
argument_list|,
name|bb
argument_list|)
condition|)
return|return
name|NULL_RTX
return|;
comment|/* Condition must be invariant.  */
name|test
operator|=
name|get_condition
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|,
operator|&
name|at
argument_list|,
name|true
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|test
condition|)
return|return
name|NULL_RTX
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|op
index|[
name|i
index|]
operator|=
name|XEXP
argument_list|(
name|test
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|op
index|[
name|i
index|]
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|iv_analyze
argument_list|(
name|at
argument_list|,
name|op
index|[
name|i
index|]
argument_list|,
operator|&
name|iv
argument_list|)
condition|)
return|return
name|NULL_RTX
return|;
if|if
condition|(
name|iv
operator|.
name|step
operator|!=
name|const0_rtx
operator|||
name|iv
operator|.
name|first_special
condition|)
return|return
name|NULL_RTX
return|;
name|op
index|[
name|i
index|]
operator|=
name|get_iv_value
argument_list|(
operator|&
name|iv
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
block|}
name|mode
operator|=
name|GET_MODE
argument_list|(
name|op
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
name|mode
operator|=
name|GET_MODE
argument_list|(
name|op
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_CC
condition|)
block|{
if|if
condition|(
name|at
operator|!=
name|BB_END
argument_list|(
name|bb
argument_list|)
condition|)
return|return
name|NULL_RTX
return|;
if|if
condition|(
operator|!
name|rtx_equal_p
argument_list|(
name|op
index|[
literal|0
index|]
argument_list|,
name|XEXP
argument_list|(
name|test
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
operator|!
name|rtx_equal_p
argument_list|(
name|op
index|[
literal|1
index|]
argument_list|,
name|XEXP
argument_list|(
name|test
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
return|return
name|NULL_RTX
return|;
operator|*
name|cinsn
operator|=
name|BB_END
argument_list|(
name|bb
argument_list|)
expr_stmt|;
return|return
name|test
return|;
block|}
name|stest
operator|=
name|simplify_gen_relational
argument_list|(
name|GET_CODE
argument_list|(
name|test
argument_list|)
argument_list|,
name|SImode
argument_list|,
name|mode
argument_list|,
name|op
index|[
literal|0
index|]
argument_list|,
name|op
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|stest
operator|==
name|const0_rtx
operator|||
name|stest
operator|==
name|const_true_rtx
condition|)
return|return
name|stest
return|;
return|return
name|canon_condition
argument_list|(
name|gen_rtx_fmt_ee
argument_list|(
name|GET_CODE
argument_list|(
name|test
argument_list|)
argument_list|,
name|SImode
argument_list|,
name|op
index|[
literal|0
index|]
argument_list|,
name|op
index|[
literal|1
index|]
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Reverses CONDition; returns NULL if we cannot.  */
end_comment

begin_function
name|rtx
name|reversed_condition
parameter_list|(
name|rtx
name|cond
parameter_list|)
block|{
name|enum
name|rtx_code
name|reversed
decl_stmt|;
name|reversed
operator|=
name|reversed_comparison_code
argument_list|(
name|cond
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|reversed
operator|==
name|UNKNOWN
condition|)
return|return
name|NULL_RTX
return|;
else|else
return|return
name|gen_rtx_fmt_ee
argument_list|(
name|reversed
argument_list|,
name|GET_MODE
argument_list|(
name|cond
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Unswitch single LOOP.  COND_CHECKED holds list of conditions we already    unswitched on and are therefore known to be true in this LOOP.  NUM is    number of unswitchings done; do not allow it to grow too much, it is too    easy to create example on that the code would grow exponentially.  */
end_comment

begin_function
specifier|static
name|void
name|unswitch_single_loop
parameter_list|(
name|struct
name|loops
modifier|*
name|loops
parameter_list|,
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|rtx
name|cond_checked
parameter_list|,
name|int
name|num
parameter_list|)
block|{
name|basic_block
modifier|*
name|bbs
decl_stmt|;
name|struct
name|loop
modifier|*
name|nloop
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|rtx
name|cond
decl_stmt|,
name|rcond
init|=
name|NULL_RTX
decl_stmt|,
name|conds
decl_stmt|,
name|rconds
decl_stmt|,
name|acond
decl_stmt|,
name|cinsn
decl_stmt|;
name|int
name|repeat
decl_stmt|;
name|edge
name|e
decl_stmt|;
comment|/* Do not unswitch too much.  */
if|if
condition|(
name|num
operator|>
name|PARAM_VALUE
argument_list|(
name|PARAM_MAX_UNSWITCH_LEVEL
argument_list|)
condition|)
block|{
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|";; Not unswitching anymore, hit max level\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Only unswitch innermost loops.  */
if|if
condition|(
name|loop
operator|->
name|inner
condition|)
block|{
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|";; Not unswitching, not innermost loop\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* We must be able to duplicate loop body.  */
if|if
condition|(
operator|!
name|can_duplicate_loop_p
argument_list|(
name|loop
argument_list|)
condition|)
block|{
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|";; Not unswitching, can't duplicate loop\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* The loop should not be too large, to limit code growth.  */
if|if
condition|(
name|num_loop_insns
argument_list|(
name|loop
argument_list|)
operator|>
name|PARAM_VALUE
argument_list|(
name|PARAM_MAX_UNSWITCH_INSNS
argument_list|)
condition|)
block|{
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|";; Not unswitching, loop too big\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Do not unswitch in cold areas.  */
if|if
condition|(
operator|!
name|maybe_hot_bb_p
argument_list|(
name|loop
operator|->
name|header
argument_list|)
condition|)
block|{
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|";; Not unswitching, not hot area\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Nor if the loop usually does not roll.  */
if|if
condition|(
name|expected_loop_iterations
argument_list|(
name|loop
argument_list|)
operator|<
literal|1
condition|)
block|{
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|";; Not unswitching, loop iterations< 1\n"
argument_list|)
expr_stmt|;
return|return;
block|}
do|do
block|{
name|repeat
operator|=
literal|0
expr_stmt|;
name|cinsn
operator|=
name|NULL_RTX
expr_stmt|;
comment|/* Find a bb to unswitch on.  */
name|bbs
operator|=
name|get_loop_body
argument_list|(
name|loop
argument_list|)
expr_stmt|;
name|iv_analysis_loop_init
argument_list|(
name|loop
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|loop
operator|->
name|num_nodes
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|cond
operator|=
name|may_unswitch_on
argument_list|(
name|bbs
index|[
name|i
index|]
argument_list|,
name|loop
argument_list|,
operator|&
name|cinsn
argument_list|)
operator|)
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|loop
operator|->
name|num_nodes
condition|)
block|{
name|free
argument_list|(
name|bbs
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|cond
operator|!=
name|const0_rtx
operator|&&
name|cond
operator|!=
name|const_true_rtx
condition|)
block|{
name|rcond
operator|=
name|reversed_condition
argument_list|(
name|cond
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcond
condition|)
name|rcond
operator|=
name|canon_condition
argument_list|(
name|rcond
argument_list|)
expr_stmt|;
comment|/* Check whether the result can be predicted.  */
for|for
control|(
name|acond
operator|=
name|cond_checked
init|;
name|acond
condition|;
name|acond
operator|=
name|XEXP
argument_list|(
name|acond
argument_list|,
literal|1
argument_list|)
control|)
name|simplify_using_condition
argument_list|(
name|XEXP
argument_list|(
name|acond
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|cond
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cond
operator|==
name|const_true_rtx
condition|)
block|{
comment|/* Remove false path.  */
name|e
operator|=
name|FALLTHRU_EDGE
argument_list|(
name|bbs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|remove_path
argument_list|(
name|loops
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|bbs
argument_list|)
expr_stmt|;
name|repeat
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cond
operator|==
name|const0_rtx
condition|)
block|{
comment|/* Remove true path.  */
name|e
operator|=
name|BRANCH_EDGE
argument_list|(
name|bbs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|remove_path
argument_list|(
name|loops
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|bbs
argument_list|)
expr_stmt|;
name|repeat
operator|=
literal|1
expr_stmt|;
block|}
block|}
do|while
condition|(
name|repeat
condition|)
do|;
comment|/* We found the condition we can unswitch on.  */
name|conds
operator|=
name|alloc_EXPR_LIST
argument_list|(
literal|0
argument_list|,
name|cond
argument_list|,
name|cond_checked
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcond
condition|)
name|rconds
operator|=
name|alloc_EXPR_LIST
argument_list|(
literal|0
argument_list|,
name|rcond
argument_list|,
name|cond_checked
argument_list|)
expr_stmt|;
else|else
name|rconds
operator|=
name|cond_checked
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|";; Unswitching loop\n"
argument_list|)
expr_stmt|;
comment|/* Unswitch the loop on this condition.  */
name|nloop
operator|=
name|unswitch_loop
argument_list|(
name|loops
argument_list|,
name|loop
argument_list|,
name|bbs
index|[
name|i
index|]
argument_list|,
name|cond
argument_list|,
name|cinsn
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|nloop
argument_list|)
expr_stmt|;
comment|/* Invoke itself on modified loops.  */
name|unswitch_single_loop
argument_list|(
name|loops
argument_list|,
name|nloop
argument_list|,
name|rconds
argument_list|,
name|num
operator|+
literal|1
argument_list|)
expr_stmt|;
name|unswitch_single_loop
argument_list|(
name|loops
argument_list|,
name|loop
argument_list|,
name|conds
argument_list|,
name|num
operator|+
literal|1
argument_list|)
expr_stmt|;
name|free_EXPR_LIST_node
argument_list|(
name|conds
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcond
condition|)
name|free_EXPR_LIST_node
argument_list|(
name|rconds
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|bbs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Unswitch a LOOP w.r. to given basic block UNSWITCH_ON.  We only support    unswitching of innermost loops.  UNSWITCH_ON must be executed in every    iteration, i.e. it must dominate LOOP latch.  COND is the condition    determining which loop is entered.  Returns NULL if impossible, new loop    otherwise.  The new loop is entered if COND is true.  If CINSN is not    NULL, it is the insn in that COND is compared.  */
end_comment

begin_function
specifier|static
name|struct
name|loop
modifier|*
name|unswitch_loop
parameter_list|(
name|struct
name|loops
modifier|*
name|loops
parameter_list|,
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|basic_block
name|unswitch_on
parameter_list|,
name|rtx
name|cond
parameter_list|,
name|rtx
name|cinsn
parameter_list|)
block|{
name|edge
name|entry
decl_stmt|,
name|latch_edge
decl_stmt|,
name|true_edge
decl_stmt|,
name|false_edge
decl_stmt|,
name|e
decl_stmt|;
name|basic_block
name|switch_bb
decl_stmt|,
name|unswitch_on_alt
decl_stmt|;
name|struct
name|loop
modifier|*
name|nloop
decl_stmt|;
name|sbitmap
name|zero_bitmap
decl_stmt|;
name|int
name|irred_flag
decl_stmt|,
name|prob
decl_stmt|;
name|rtx
name|seq
decl_stmt|;
comment|/* Some sanity checking.  */
name|gcc_assert
argument_list|(
name|flow_bb_inside_loop_p
argument_list|(
name|loop
argument_list|,
name|unswitch_on
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|EDGE_COUNT
argument_list|(
name|unswitch_on
operator|->
name|succs
argument_list|)
operator|==
literal|2
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|just_once_each_iteration_p
argument_list|(
name|loop
argument_list|,
name|unswitch_on
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|loop
operator|->
name|inner
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|flow_bb_inside_loop_p
argument_list|(
name|loop
argument_list|,
name|EDGE_SUCC
argument_list|(
name|unswitch_on
argument_list|,
literal|0
argument_list|)
operator|->
name|dest
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|flow_bb_inside_loop_p
argument_list|(
name|loop
argument_list|,
name|EDGE_SUCC
argument_list|(
name|unswitch_on
argument_list|,
literal|1
argument_list|)
operator|->
name|dest
argument_list|)
argument_list|)
expr_stmt|;
name|entry
operator|=
name|loop_preheader_edge
argument_list|(
name|loop
argument_list|)
expr_stmt|;
comment|/* Make a copy.  */
name|irred_flag
operator|=
name|entry
operator|->
name|flags
operator|&
name|EDGE_IRREDUCIBLE_LOOP
expr_stmt|;
name|entry
operator|->
name|flags
operator|&=
operator|~
name|EDGE_IRREDUCIBLE_LOOP
expr_stmt|;
name|zero_bitmap
operator|=
name|sbitmap_alloc
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|zero_bitmap
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|duplicate_loop_to_header_edge
argument_list|(
name|loop
argument_list|,
name|entry
argument_list|,
name|loops
argument_list|,
literal|1
argument_list|,
name|zero_bitmap
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|sbitmap_free
argument_list|(
name|zero_bitmap
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|sbitmap_free
argument_list|(
name|zero_bitmap
argument_list|)
expr_stmt|;
name|entry
operator|->
name|flags
operator||=
name|irred_flag
expr_stmt|;
comment|/* Record the block with condition we unswitch on.  */
name|unswitch_on_alt
operator|=
name|get_bb_copy
argument_list|(
name|unswitch_on
argument_list|)
expr_stmt|;
name|true_edge
operator|=
name|BRANCH_EDGE
argument_list|(
name|unswitch_on_alt
argument_list|)
expr_stmt|;
name|false_edge
operator|=
name|FALLTHRU_EDGE
argument_list|(
name|unswitch_on
argument_list|)
expr_stmt|;
name|latch_edge
operator|=
name|single_succ_edge
argument_list|(
name|get_bb_copy
argument_list|(
name|loop
operator|->
name|latch
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create a block with the condition.  */
name|prob
operator|=
name|true_edge
operator|->
name|probability
expr_stmt|;
name|switch_bb
operator|=
name|create_empty_bb
argument_list|(
name|EXIT_BLOCK_PTR
operator|->
name|prev_bb
argument_list|)
expr_stmt|;
name|seq
operator|=
name|compare_and_jump_seq
argument_list|(
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
argument_list|,
name|GET_CODE
argument_list|(
name|cond
argument_list|)
argument_list|,
name|block_label
argument_list|(
name|true_edge
operator|->
name|dest
argument_list|)
argument_list|,
name|prob
argument_list|,
name|cinsn
argument_list|)
expr_stmt|;
name|emit_insn_after
argument_list|(
name|seq
argument_list|,
name|BB_END
argument_list|(
name|switch_bb
argument_list|)
argument_list|)
expr_stmt|;
name|e
operator|=
name|make_edge
argument_list|(
name|switch_bb
argument_list|,
name|true_edge
operator|->
name|dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|e
operator|->
name|probability
operator|=
name|prob
expr_stmt|;
name|e
operator|->
name|count
operator|=
name|latch_edge
operator|->
name|count
operator|*
name|prob
operator|/
name|REG_BR_PROB_BASE
expr_stmt|;
name|e
operator|=
name|make_edge
argument_list|(
name|switch_bb
argument_list|,
name|FALLTHRU_EDGE
argument_list|(
name|unswitch_on
argument_list|)
operator|->
name|dest
argument_list|,
name|EDGE_FALLTHRU
argument_list|)
expr_stmt|;
name|e
operator|->
name|probability
operator|=
name|false_edge
operator|->
name|probability
expr_stmt|;
name|e
operator|->
name|count
operator|=
name|latch_edge
operator|->
name|count
operator|*
operator|(
name|false_edge
operator|->
name|probability
operator|)
operator|/
name|REG_BR_PROB_BASE
expr_stmt|;
if|if
condition|(
name|irred_flag
condition|)
block|{
name|switch_bb
operator|->
name|flags
operator||=
name|BB_IRREDUCIBLE_LOOP
expr_stmt|;
name|EDGE_SUCC
argument_list|(
name|switch_bb
argument_list|,
literal|0
argument_list|)
operator|->
name|flags
operator||=
name|EDGE_IRREDUCIBLE_LOOP
expr_stmt|;
name|EDGE_SUCC
argument_list|(
name|switch_bb
argument_list|,
literal|1
argument_list|)
operator|->
name|flags
operator||=
name|EDGE_IRREDUCIBLE_LOOP
expr_stmt|;
block|}
else|else
block|{
name|switch_bb
operator|->
name|flags
operator|&=
operator|~
name|BB_IRREDUCIBLE_LOOP
expr_stmt|;
name|EDGE_SUCC
argument_list|(
name|switch_bb
argument_list|,
literal|0
argument_list|)
operator|->
name|flags
operator|&=
operator|~
name|EDGE_IRREDUCIBLE_LOOP
expr_stmt|;
name|EDGE_SUCC
argument_list|(
name|switch_bb
argument_list|,
literal|1
argument_list|)
operator|->
name|flags
operator|&=
operator|~
name|EDGE_IRREDUCIBLE_LOOP
expr_stmt|;
block|}
comment|/* Loopify from the copy of LOOP body, constructing the new loop.  */
name|nloop
operator|=
name|loopify
argument_list|(
name|loops
argument_list|,
name|latch_edge
argument_list|,
name|single_pred_edge
argument_list|(
name|get_bb_copy
argument_list|(
name|loop
operator|->
name|header
argument_list|)
argument_list|)
argument_list|,
name|switch_bb
argument_list|,
name|BRANCH_EDGE
argument_list|(
name|switch_bb
argument_list|)
argument_list|,
name|FALLTHRU_EDGE
argument_list|(
name|switch_bb
argument_list|)
argument_list|,
name|true
argument_list|)
expr_stmt|;
comment|/* Remove branches that are now unreachable in new loops.  */
name|remove_path
argument_list|(
name|loops
argument_list|,
name|true_edge
argument_list|)
expr_stmt|;
name|remove_path
argument_list|(
name|loops
argument_list|,
name|false_edge
argument_list|)
expr_stmt|;
comment|/* One of created loops do not have to be subloop of the outer loop now,      so fix its placement in loop data structure.  */
name|fix_loop_placement
argument_list|(
name|loop
argument_list|)
expr_stmt|;
name|fix_loop_placement
argument_list|(
name|nloop
argument_list|)
expr_stmt|;
comment|/* Preserve the simple loop preheaders.  */
name|loop_split_edge_with
argument_list|(
name|loop_preheader_edge
argument_list|(
name|loop
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|loop_split_edge_with
argument_list|(
name|loop_preheader_edge
argument_list|(
name|nloop
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
return|return
name|nloop
return|;
block|}
end_function

end_unit

