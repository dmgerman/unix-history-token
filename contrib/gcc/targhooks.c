begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Default target hook functions.    Copyright (C) 2003, 2004 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* The migration of target macros to target hooks works as follows:     1. Create a target hook that uses the existing target macros to       implement the same functionality.     2. Convert all the MI files to use the hook instead of the macro.     3. Repeat for a majority of the remaining target macros.  This will       take some time.     4. Tell target maintainers to start migrating.     5. Eventually convert the backends to override the hook instead of       defining the macros.  This will take some time too.     6. TBD when, poison the macros.  Unmigrated targets will break at       this point.     Note that we expect steps 1-3 to be done by the people that    understand what the MI does with each macro, and step 5 to be done    by the target maintainers for their respective targets.     Note that steps 1 and 2 don't have to be done together, but no    target can override the new hook until step 2 is complete for it.     Once the macros are poisoned, we will revert to the old migration    rules - migrate the macro, callers, and targets all at once.  This    comment can thus be removed at that point.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"machmode.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"target-def.h"
end_include

begin_function
name|void
name|default_external_libcall
parameter_list|(
name|rtx
name|fun
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|ASM_OUTPUT_EXTERNAL_LIBCALL
name|ASM_OUTPUT_EXTERNAL_LIBCALL
argument_list|(
name|asm_out_file
argument_list|,
name|fun
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|enum
name|machine_mode
name|default_cc_modes_compatible
parameter_list|(
name|enum
name|machine_mode
name|m1
parameter_list|,
name|enum
name|machine_mode
name|m2
parameter_list|)
block|{
if|if
condition|(
name|m1
operator|==
name|m2
condition|)
return|return
name|m1
return|;
return|return
name|VOIDmode
return|;
block|}
end_function

begin_function
name|bool
name|default_promote_function_args
parameter_list|(
name|tree
name|fntype
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|PROMOTE_FUNCTION_ARGS
return|return
name|true
return|;
else|#
directive|else
return|return
name|false
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|bool
name|default_promote_function_return
parameter_list|(
name|tree
name|fntype
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|PROMOTE_FUNCTION_RETURN
return|return
name|true
return|;
else|#
directive|else
return|return
name|false
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|bool
name|default_promote_prototypes
parameter_list|(
name|tree
name|fntype
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|PROMOTE_PROTOTYPES
condition|)
return|return
name|true
return|;
else|else
return|return
name|false
return|;
block|}
end_function

begin_function
name|rtx
name|default_struct_value_rtx
parameter_list|(
name|tree
name|fntype
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|incoming
parameter_list|)
block|{
name|rtx
name|rv
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|incoming
condition|)
block|{
ifdef|#
directive|ifdef
name|STRUCT_VALUE_INCOMING
name|rv
operator|=
name|STRUCT_VALUE_INCOMING
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|STRUCT_VALUE
name|rv
operator|=
name|STRUCT_VALUE
expr_stmt|;
else|#
directive|else
ifndef|#
directive|ifndef
name|STRUCT_VALUE_REGNUM
name|abort
argument_list|()
expr_stmt|;
else|#
directive|else
name|rv
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|STRUCT_VALUE_REGNUM
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|STRUCT_VALUE
name|rv
operator|=
name|STRUCT_VALUE
expr_stmt|;
else|#
directive|else
ifndef|#
directive|ifndef
name|STRUCT_VALUE_REGNUM
name|abort
argument_list|()
expr_stmt|;
else|#
directive|else
name|rv
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|STRUCT_VALUE_REGNUM
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
block|}
return|return
name|rv
return|;
block|}
end_function

begin_function
name|bool
name|default_return_in_memory
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|fntype
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|RETURN_IN_MEMORY
return|return
operator|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|==
name|BLKmode
operator|)
return|;
else|#
directive|else
return|return
name|RETURN_IN_MEMORY
argument_list|(
name|type
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|rtx
name|default_expand_builtin_saveregs
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|EXPAND_BUILTIN_SAVEREGS
return|return
name|EXPAND_BUILTIN_SAVEREGS
argument_list|()
return|;
else|#
directive|else
name|error
argument_list|(
literal|"__builtin_saveregs not supported by this target"
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|default_setup_incoming_varargs
parameter_list|(
name|CUMULATIVE_ARGS
modifier|*
name|ca
name|ATTRIBUTE_UNUSED
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|,
name|tree
name|type
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
modifier|*
name|pretend_arg_size
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|second_time
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|SETUP_INCOMING_VARARGS
name|SETUP_INCOMING_VARARGS
argument_list|(
operator|(
operator|*
name|ca
operator|)
argument_list|,
name|mode
argument_list|,
name|type
argument_list|,
operator|(
operator|*
name|pretend_arg_size
operator|)
argument_list|,
name|second_time
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|bool
name|default_strict_argument_naming
parameter_list|(
name|CUMULATIVE_ARGS
modifier|*
name|ca
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|STRICT_ARGUMENT_NAMING
return|return
name|STRICT_ARGUMENT_NAMING
return|;
else|#
directive|else
return|return
literal|0
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|bool
name|default_pretend_outgoing_varargs_named
parameter_list|(
name|CUMULATIVE_ARGS
modifier|*
name|ca
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|SETUP_INCOMING_VARARGS
return|return
literal|1
return|;
else|#
directive|else
return|return
operator|(
name|targetm
operator|.
name|calls
operator|.
name|setup_incoming_varargs
operator|!=
name|default_setup_incoming_varargs
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Generic hook that takes a CUMULATIVE_ARGS pointer and returns true.  */
end_comment

begin_function
name|bool
name|hook_bool_CUMULATIVE_ARGS_true
parameter_list|(
name|CUMULATIVE_ARGS
modifier|*
name|a
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Generic hook that takes a machine mode and returns true.  */
end_comment

begin_function
name|bool
name|hook_bool_machine_mode_true
parameter_list|(
name|enum
name|machine_mode
name|a
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|true
return|;
block|}
end_function

end_unit

