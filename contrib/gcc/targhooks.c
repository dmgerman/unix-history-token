begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Default target hook functions.    Copyright (C) 2003, 2004, 2005, 2007 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* The migration of target macros to target hooks works as follows:     1. Create a target hook that uses the existing target macros to       implement the same functionality.     2. Convert all the MI files to use the hook instead of the macro.     3. Repeat for a majority of the remaining target macros.  This will       take some time.     4. Tell target maintainers to start migrating.     5. Eventually convert the backends to override the hook instead of       defining the macros.  This will take some time too.     6. TBD when, poison the macros.  Unmigrated targets will break at       this point.     Note that we expect steps 1-3 to be done by the people that    understand what the MI does with each macro, and step 5 to be done    by the target maintainers for their respective targets.     Note that steps 1 and 2 don't have to be done together, but no    target can override the new hook until step 2 is complete for it.     Once the macros are poisoned, we will revert to the old migration    rules - migrate the macro, callers, and targets all at once.  This    comment can thus be removed at that point.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"machmode.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"target-def.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"reload.h"
end_include

begin_include
include|#
directive|include
file|"optabs.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_function
name|void
name|default_external_libcall
parameter_list|(
name|rtx
name|fun
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|ASM_OUTPUT_EXTERNAL_LIBCALL
name|ASM_OUTPUT_EXTERNAL_LIBCALL
argument_list|(
name|asm_out_file
argument_list|,
name|fun
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|enum
name|machine_mode
name|default_cc_modes_compatible
parameter_list|(
name|enum
name|machine_mode
name|m1
parameter_list|,
name|enum
name|machine_mode
name|m2
parameter_list|)
block|{
if|if
condition|(
name|m1
operator|==
name|m2
condition|)
return|return
name|m1
return|;
return|return
name|VOIDmode
return|;
block|}
end_function

begin_function
name|bool
name|default_return_in_memory
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|fntype
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|RETURN_IN_MEMORY
return|return
operator|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|==
name|BLKmode
operator|)
return|;
else|#
directive|else
return|return
name|RETURN_IN_MEMORY
argument_list|(
name|type
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* APPLE LOCAL begin radar 4781080 */
end_comment

begin_function
name|bool
name|default_objc_fpreturn_msgcall
parameter_list|(
name|tree
name|type
parameter_list|,
name|bool
name|no_long_double
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|OBJC_FPRETURN_MSGCALL
return|return
name|type
operator|==
name|NULL_TREE
operator|&&
name|no_long_double
return|;
else|#
directive|else
return|return
name|OBJC_FPRETURN_MSGCALL
argument_list|(
name|type
argument_list|,
name|no_long_double
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* APPLE LOCAL end radar 4781080 */
end_comment

begin_function
name|rtx
name|default_expand_builtin_saveregs
parameter_list|(
name|void
parameter_list|)
block|{
name|error
argument_list|(
literal|"__builtin_saveregs not supported by this target"
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
end_function

begin_function
name|void
name|default_setup_incoming_varargs
parameter_list|(
name|CUMULATIVE_ARGS
modifier|*
name|ca
name|ATTRIBUTE_UNUSED
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|,
name|tree
name|type
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
modifier|*
name|pretend_arg_size
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|second_time
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{ }
end_function

begin_comment
comment|/* The default implementation of TARGET_BUILTIN_SETJMP_FRAME_VALUE.  */
end_comment

begin_function
name|rtx
name|default_builtin_setjmp_frame_value
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|virtual_stack_vars_rtx
return|;
block|}
end_function

begin_comment
comment|/* Generic hook that takes a CUMULATIVE_ARGS pointer and returns false.  */
end_comment

begin_function
name|bool
name|hook_bool_CUMULATIVE_ARGS_false
parameter_list|(
name|CUMULATIVE_ARGS
modifier|*
name|ca
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|false
return|;
block|}
end_function

begin_function
name|bool
name|default_pretend_outgoing_varargs_named
parameter_list|(
name|CUMULATIVE_ARGS
modifier|*
name|ca
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
operator|(
name|targetm
operator|.
name|calls
operator|.
name|setup_incoming_varargs
operator|!=
name|default_setup_incoming_varargs
operator|)
return|;
block|}
end_function

begin_function
name|enum
name|machine_mode
name|default_eh_return_filter_mode
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|word_mode
return|;
block|}
end_function

begin_comment
comment|/* The default implementation of TARGET_SHIFT_TRUNCATION_MASK.  */
end_comment

begin_function
name|unsigned
name|HOST_WIDE_INT
name|default_shift_truncation_mask
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
return|return
name|SHIFT_COUNT_TRUNCATED
condition|?
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|-
literal|1
else|:
literal|0
return|;
block|}
end_function

begin_comment
comment|/* The default implementation of TARGET_MIN_DIVISIONS_FOR_RECIP_MUL.  */
end_comment

begin_function
name|unsigned
name|int
name|default_min_divisions_for_recip_mul
parameter_list|(
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|have_insn_for
argument_list|(
name|DIV
argument_list|,
name|mode
argument_list|)
condition|?
literal|3
else|:
literal|2
return|;
block|}
end_function

begin_comment
comment|/* The default implementation of TARGET_MODE_REP_EXTENDED.  */
end_comment

begin_function
name|int
name|default_mode_rep_extended
parameter_list|(
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|,
name|enum
name|machine_mode
name|mode_rep
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|UNKNOWN
return|;
block|}
end_function

begin_comment
comment|/* Generic hook that takes a CUMULATIVE_ARGS pointer and returns true.  */
end_comment

begin_function
name|bool
name|hook_bool_CUMULATIVE_ARGS_true
parameter_list|(
name|CUMULATIVE_ARGS
modifier|*
name|a
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* The generic C++ ABI specifies this is a 64-bit value.  */
end_comment

begin_function
name|tree
name|default_cxx_guard_type
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|long_long_integer_type_node
return|;
block|}
end_function

begin_comment
comment|/* Returns the size of the cookie to use when allocating an array    whose elements have the indicated TYPE.  Assumes that it is already    known that a cookie is needed.  */
end_comment

begin_function
name|tree
name|default_cxx_get_cookie_size
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|tree
name|cookie_size
decl_stmt|;
comment|/* We need to allocate an additional max (sizeof (size_t), alignof      (true_type)) bytes.  */
name|tree
name|sizetype_size
decl_stmt|;
name|tree
name|type_align
decl_stmt|;
name|sizetype_size
operator|=
name|size_in_bytes
argument_list|(
name|sizetype
argument_list|)
expr_stmt|;
name|type_align
operator|=
name|size_int
argument_list|(
name|TYPE_ALIGN_UNIT
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|INT_CST_LT_UNSIGNED
argument_list|(
name|type_align
argument_list|,
name|sizetype_size
argument_list|)
condition|)
name|cookie_size
operator|=
name|sizetype_size
expr_stmt|;
else|else
name|cookie_size
operator|=
name|type_align
expr_stmt|;
return|return
name|cookie_size
return|;
block|}
end_function

begin_comment
comment|/* Return true if a parameter must be passed by reference.  This version    of the TARGET_PASS_BY_REFERENCE hook uses just MUST_PASS_IN_STACK.  */
end_comment

begin_function
name|bool
name|hook_pass_by_reference_must_pass_in_stack
parameter_list|(
name|CUMULATIVE_ARGS
modifier|*
name|c
name|ATTRIBUTE_UNUSED
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|,
name|tree
name|type
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bool
name|named_arg
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|targetm
operator|.
name|calls
operator|.
name|must_pass_in_stack
argument_list|(
name|mode
argument_list|,
name|type
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if a parameter follows callee copies conventions.  This    version of the hook is true for all named arguments.  */
end_comment

begin_function
name|bool
name|hook_callee_copies_named
parameter_list|(
name|CUMULATIVE_ARGS
modifier|*
name|ca
name|ATTRIBUTE_UNUSED
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|,
name|tree
name|type
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bool
name|named
parameter_list|)
block|{
return|return
name|named
return|;
block|}
end_function

begin_comment
comment|/* Emit any directives required to unwind this instruction.  */
end_comment

begin_function
name|void
name|default_unwind_emit
parameter_list|(
name|FILE
modifier|*
name|stream
name|ATTRIBUTE_UNUSED
parameter_list|,
name|rtx
name|insn
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
comment|/* Should never happen.  */
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* True if MODE is valid for the target.  By "valid", we mean able to    be manipulated in non-trivial ways.  In particular, this means all    the arithmetic is supported.     By default we guess this means that any C type is supported.  If    we can't map the mode back to a type that would be available in C,    then reject it.  Special case, here, is the double-word arithmetic    supported by optabs.c.  */
end_comment

begin_function
name|bool
name|default_scalar_mode_supported_p
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|int
name|precision
init|=
name|GET_MODE_PRECISION
argument_list|(
name|mode
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
condition|)
block|{
case|case
name|MODE_PARTIAL_INT
case|:
case|case
name|MODE_INT
case|:
if|if
condition|(
name|precision
operator|==
name|CHAR_TYPE_SIZE
condition|)
return|return
name|true
return|;
if|if
condition|(
name|precision
operator|==
name|SHORT_TYPE_SIZE
condition|)
return|return
name|true
return|;
if|if
condition|(
name|precision
operator|==
name|INT_TYPE_SIZE
condition|)
return|return
name|true
return|;
if|if
condition|(
name|precision
operator|==
name|LONG_TYPE_SIZE
condition|)
return|return
name|true
return|;
if|if
condition|(
name|precision
operator|==
name|LONG_LONG_TYPE_SIZE
condition|)
return|return
name|true
return|;
if|if
condition|(
name|precision
operator|==
literal|2
operator|*
name|BITS_PER_WORD
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
case|case
name|MODE_FLOAT
case|:
if|if
condition|(
name|precision
operator|==
name|FLOAT_TYPE_SIZE
condition|)
return|return
name|true
return|;
if|if
condition|(
name|precision
operator|==
name|DOUBLE_TYPE_SIZE
condition|)
return|return
name|true
return|;
if|if
condition|(
name|precision
operator|==
name|LONG_DOUBLE_TYPE_SIZE
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
case|case
name|MODE_DECIMAL_FLOAT
case|:
return|return
name|false
return|;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* True if the target supports decimal floating point.  */
end_comment

begin_function
name|bool
name|default_decimal_float_supported_p
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|ENABLE_DECIMAL_FLOAT
return|;
block|}
end_function

begin_comment
comment|/* NULL if INSN insn is valid within a low-overhead loop, otherwise returns    an error message.       This function checks whether a given INSN is valid within a low-overhead    loop.  If INSN is invalid it returns the reason for that, otherwise it    returns NULL. A called function may clobber any special registers required    for low-overhead looping. Additionally, some targets (eg, PPC) use the count    register for branch on table instructions. We reject the doloop pattern in    these cases.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|default_invalid_within_doloop
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
if|if
condition|(
name|CALL_P
argument_list|(
name|insn
argument_list|)
condition|)
return|return
literal|"Function call in loop."
return|;
if|if
condition|(
name|JUMP_P
argument_list|(
name|insn
argument_list|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|ADDR_DIFF_VEC
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|ADDR_VEC
operator|)
condition|)
return|return
literal|"Computed branch in the loop."
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|bool
name|hook_bool_CUMULATIVE_ARGS_mode_tree_bool_false
parameter_list|(
name|CUMULATIVE_ARGS
modifier|*
name|ca
name|ATTRIBUTE_UNUSED
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|,
name|tree
name|type
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bool
name|named
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|false
return|;
block|}
end_function

begin_function
name|bool
name|hook_bool_CUMULATIVE_ARGS_mode_tree_bool_true
parameter_list|(
name|CUMULATIVE_ARGS
modifier|*
name|ca
name|ATTRIBUTE_UNUSED
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|,
name|tree
name|type
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bool
name|named
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|true
return|;
block|}
end_function

begin_function
name|int
name|hook_int_CUMULATIVE_ARGS_mode_tree_bool_0
parameter_list|(
name|CUMULATIVE_ARGS
modifier|*
name|ca
name|ATTRIBUTE_UNUSED
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|,
name|tree
name|type
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bool
name|named
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|hook_void_bitmap
parameter_list|(
name|bitmap
name|regs
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{ }
end_function

begin_function
specifier|const
name|char
modifier|*
name|hook_invalid_arg_for_unprototyped_fn
parameter_list|(
name|tree
name|typelist
name|ATTRIBUTE_UNUSED
parameter_list|,
name|tree
name|funcdecl
name|ATTRIBUTE_UNUSED
parameter_list|,
name|tree
name|val
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Initialize the stack protection decls.  */
end_comment

begin_comment
comment|/* Stack protection related decls living in libgcc.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|tree
name|stack_chk_guard_decl
expr_stmt|;
end_expr_stmt

begin_function
name|tree
name|default_stack_protect_guard
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|t
init|=
name|stack_chk_guard_decl
decl_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL
condition|)
block|{
name|t
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"__stack_chk_guard"
argument_list|)
argument_list|,
name|ptr_type_node
argument_list|)
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_USED
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_IGNORED_P
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|stack_chk_guard_decl
operator|=
name|t
expr_stmt|;
block|}
return|return
name|t
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|tree
name|stack_chk_fail_decl
expr_stmt|;
end_expr_stmt

begin_function
name|tree
name|default_external_stack_protect_fail
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|t
init|=
name|stack_chk_fail_decl
decl_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL_TREE
condition|)
block|{
name|t
operator|=
name|build_function_type_list
argument_list|(
name|void_type_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_decl
argument_list|(
name|FUNCTION_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"__stack_chk_fail"
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_USED
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_NOTHROW
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_IGNORED_P
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_VISIBILITY
argument_list|(
name|t
argument_list|)
operator|=
name|VISIBILITY_DEFAULT
expr_stmt|;
name|DECL_VISIBILITY_SPECIFIED
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|stack_chk_fail_decl
operator|=
name|t
expr_stmt|;
block|}
return|return
name|build_function_call_expr
argument_list|(
name|t
argument_list|,
name|NULL_TREE
argument_list|)
return|;
block|}
end_function

begin_function
name|tree
name|default_hidden_stack_protect_fail
parameter_list|(
name|void
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|HAVE_GAS_HIDDEN
return|return
name|default_external_stack_protect_fail
argument_list|()
return|;
else|#
directive|else
name|tree
name|t
init|=
name|stack_chk_fail_decl
decl_stmt|;
if|if
condition|(
operator|!
name|flag_pic
condition|)
return|return
name|default_external_stack_protect_fail
argument_list|()
return|;
if|if
condition|(
name|t
operator|==
name|NULL_TREE
condition|)
block|{
name|t
operator|=
name|build_function_type_list
argument_list|(
name|void_type_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_decl
argument_list|(
name|FUNCTION_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"__stack_chk_fail_local"
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_USED
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_NOTHROW
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_IGNORED_P
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_VISIBILITY_SPECIFIED
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_VISIBILITY
argument_list|(
name|t
argument_list|)
operator|=
name|VISIBILITY_HIDDEN
expr_stmt|;
name|stack_chk_fail_decl
operator|=
name|t
expr_stmt|;
block|}
return|return
name|build_function_call_expr
argument_list|(
name|t
argument_list|,
name|NULL_TREE
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|bool
name|hook_bool_rtx_commutative_p
parameter_list|(
name|rtx
name|x
parameter_list|,
name|int
name|outer_code
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|COMMUTATIVE_P
argument_list|(
name|x
argument_list|)
return|;
block|}
end_function

begin_function
name|rtx
name|default_function_value
parameter_list|(
name|tree
name|ret_type
name|ATTRIBUTE_UNUSED
parameter_list|,
name|tree
name|fn_decl_or_type
parameter_list|,
name|bool
name|outgoing
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
comment|/* The old interface doesn't handle receiving the function type.  */
if|if
condition|(
name|fn_decl_or_type
operator|&&
operator|!
name|DECL_P
argument_list|(
name|fn_decl_or_type
argument_list|)
condition|)
name|fn_decl_or_type
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|FUNCTION_OUTGOING_VALUE
if|if
condition|(
name|outgoing
condition|)
return|return
name|FUNCTION_OUTGOING_VALUE
argument_list|(
name|ret_type
argument_list|,
name|fn_decl_or_type
argument_list|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|FUNCTION_VALUE
return|return
name|FUNCTION_VALUE
argument_list|(
name|ret_type
argument_list|,
name|fn_decl_or_type
argument_list|)
return|;
else|#
directive|else
return|return
name|NULL_RTX
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|rtx
name|default_internal_arg_pointer
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* If the reg that the virtual arg pointer will be translated into is      not a fixed reg or is the stack pointer, make a copy of the virtual      arg pointer, and address parms via the copy.  The frame pointer is      considered fixed even though it is not marked as such.  */
if|if
condition|(
operator|(
name|ARG_POINTER_REGNUM
operator|==
name|STACK_POINTER_REGNUM
operator|||
operator|!
operator|(
name|fixed_regs
index|[
name|ARG_POINTER_REGNUM
index|]
operator|||
name|ARG_POINTER_REGNUM
operator|==
name|FRAME_POINTER_REGNUM
operator|)
operator|)
condition|)
return|return
name|copy_to_reg
argument_list|(
name|virtual_incoming_args_rtx
argument_list|)
return|;
else|else
return|return
name|virtual_incoming_args_rtx
return|;
block|}
end_function

begin_function
name|enum
name|reg_class
name|default_secondary_reload
parameter_list|(
name|bool
name|in_p
name|ATTRIBUTE_UNUSED
parameter_list|,
name|rtx
name|x
name|ATTRIBUTE_UNUSED
parameter_list|,
name|enum
name|reg_class
name|reload_class
name|ATTRIBUTE_UNUSED
parameter_list|,
name|enum
name|machine_mode
name|reload_mode
name|ATTRIBUTE_UNUSED
parameter_list|,
name|secondary_reload_info
modifier|*
name|sri
parameter_list|)
block|{
name|enum
name|reg_class
name|class
init|=
name|NO_REGS
decl_stmt|;
if|if
condition|(
name|sri
operator|->
name|prev_sri
operator|&&
name|sri
operator|->
name|prev_sri
operator|->
name|t_icode
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
name|sri
operator|->
name|icode
operator|=
name|sri
operator|->
name|prev_sri
operator|->
name|t_icode
expr_stmt|;
return|return
name|NO_REGS
return|;
block|}
ifdef|#
directive|ifdef
name|SECONDARY_INPUT_RELOAD_CLASS
if|if
condition|(
name|in_p
condition|)
name|class
operator|=
name|SECONDARY_INPUT_RELOAD_CLASS
argument_list|(
name|reload_class
argument_list|,
name|reload_mode
argument_list|,
name|x
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SECONDARY_OUTPUT_RELOAD_CLASS
if|if
condition|(
operator|!
name|in_p
condition|)
name|class
operator|=
name|SECONDARY_OUTPUT_RELOAD_CLASS
argument_list|(
name|reload_class
argument_list|,
name|reload_mode
argument_list|,
name|x
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|class
operator|!=
name|NO_REGS
condition|)
block|{
name|enum
name|insn_code
name|icode
init|=
operator|(
name|in_p
condition|?
name|reload_in_optab
index|[
operator|(
name|int
operator|)
name|reload_mode
index|]
else|:
name|reload_out_optab
index|[
operator|(
name|int
operator|)
name|reload_mode
index|]
operator|)
decl_stmt|;
if|if
condition|(
name|icode
operator|!=
name|CODE_FOR_nothing
operator|&&
name|insn_data
index|[
operator|(
name|int
operator|)
name|icode
index|]
operator|.
name|operand
index|[
name|in_p
index|]
operator|.
name|predicate
operator|&&
operator|!
name|insn_data
index|[
operator|(
name|int
operator|)
name|icode
index|]
operator|.
name|operand
index|[
name|in_p
index|]
operator|.
name|predicate
argument_list|(
name|x
argument_list|,
name|reload_mode
argument_list|)
condition|)
name|icode
operator|=
name|CODE_FOR_nothing
expr_stmt|;
elseif|else
if|if
condition|(
name|icode
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
specifier|const
name|char
modifier|*
name|insn_constraint
decl_stmt|,
modifier|*
name|scratch_constraint
decl_stmt|;
name|char
name|insn_letter
decl_stmt|,
name|scratch_letter
decl_stmt|;
name|enum
name|reg_class
name|insn_class
decl_stmt|,
name|scratch_class
decl_stmt|;
name|gcc_assert
argument_list|(
name|insn_data
index|[
operator|(
name|int
operator|)
name|icode
index|]
operator|.
name|n_operands
operator|==
literal|3
argument_list|)
expr_stmt|;
name|insn_constraint
operator|=
name|insn_data
index|[
operator|(
name|int
operator|)
name|icode
index|]
operator|.
name|operand
index|[
operator|!
name|in_p
index|]
operator|.
name|constraint
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|insn_constraint
condition|)
name|insn_class
operator|=
name|ALL_REGS
expr_stmt|;
else|else
block|{
if|if
condition|(
name|in_p
condition|)
block|{
name|gcc_assert
argument_list|(
operator|*
name|insn_constraint
operator|==
literal|'='
argument_list|)
expr_stmt|;
name|insn_constraint
operator|++
expr_stmt|;
block|}
name|insn_letter
operator|=
operator|*
name|insn_constraint
expr_stmt|;
name|insn_class
operator|=
operator|(
name|insn_letter
operator|==
literal|'r'
condition|?
name|GENERAL_REGS
else|:
name|REG_CLASS_FROM_CONSTRAINT
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|insn_letter
argument_list|,
name|insn_constraint
argument_list|)
operator|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|insn_class
operator|!=
name|NO_REGS
argument_list|)
expr_stmt|;
block|}
name|scratch_constraint
operator|=
name|insn_data
index|[
operator|(
name|int
operator|)
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|constraint
expr_stmt|;
comment|/* The scratch register's constraint must start with "=&", 	     except for an input reload, where only "=" is necessary, 	     and where it might be beneficial to re-use registers from 	     the input.  */
name|gcc_assert
argument_list|(
name|scratch_constraint
index|[
literal|0
index|]
operator|==
literal|'='
operator|&&
operator|(
name|in_p
operator|||
name|scratch_constraint
index|[
literal|1
index|]
operator|==
literal|'&'
operator|)
argument_list|)
expr_stmt|;
name|scratch_constraint
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|scratch_constraint
operator|==
literal|'&'
condition|)
name|scratch_constraint
operator|++
expr_stmt|;
name|scratch_letter
operator|=
operator|*
name|scratch_constraint
expr_stmt|;
name|scratch_class
operator|=
operator|(
name|scratch_letter
operator|==
literal|'r'
condition|?
name|GENERAL_REGS
else|:
name|REG_CLASS_FROM_CONSTRAINT
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|scratch_letter
argument_list|,
name|scratch_constraint
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|reg_class_subset_p
argument_list|(
name|reload_class
argument_list|,
name|insn_class
argument_list|)
condition|)
block|{
name|gcc_assert
argument_list|(
name|scratch_class
operator|==
name|class
argument_list|)
expr_stmt|;
name|class
operator|=
name|NO_REGS
expr_stmt|;
block|}
else|else
name|class
operator|=
name|insn_class
expr_stmt|;
block|}
if|if
condition|(
name|class
operator|==
name|NO_REGS
condition|)
name|sri
operator|->
name|icode
operator|=
name|icode
expr_stmt|;
else|else
name|sri
operator|->
name|t_icode
operator|=
name|icode
expr_stmt|;
block|}
return|return
name|class
return|;
block|}
end_function

begin_comment
comment|/* If STRICT_ALIGNMENT is true we use the container type for accessing    volatile bitfields.  This is generally the preferred behavior for memory    mapped peripherals on RISC architectures.    If STRICT_ALIGNMENT is false we use the narrowest type possible.  This    is typically used to avoid spurious page faults and extra memory accesses    due to unaligned accesses on CISC architectures.  */
end_comment

begin_function
name|bool
name|default_narrow_bitfield
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|!
name|STRICT_ALIGNMENT
return|;
block|}
end_function

begin_comment
comment|/* By default, if flag_pic is true, then neither local nor global relocs    should be placed in readonly memory.  */
end_comment

begin_function
name|int
name|default_reloc_rw_mask
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|flag_pic
condition|?
literal|3
else|:
literal|0
return|;
block|}
end_function

begin_function
name|bool
name|default_builtin_vector_alignment_reachable
parameter_list|(
name|tree
name|type
parameter_list|,
name|bool
name|is_packed
parameter_list|)
block|{
if|if
condition|(
name|is_packed
condition|)
return|return
name|false
return|;
comment|/* Assuming that types whose size is> pointer-size are not guaranteed to be      naturally aligned.  */
if|if
condition|(
name|tree_int_cst_compare
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|,
name|bitsize_int
argument_list|(
name|POINTER_SIZE
argument_list|)
argument_list|)
operator|>
literal|0
condition|)
return|return
name|false
return|;
comment|/* Assuming that types whose size is<= pointer-size      are naturally aligned.  */
return|return
name|true
return|;
block|}
end_function

begin_include
include|#
directive|include
file|"gt-targhooks.h"
end_include

end_unit

