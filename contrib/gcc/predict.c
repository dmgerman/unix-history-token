begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Branch prediction routines for the GNU compiler.    Copyright (C) 2000, 2001, 2002 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* References:     [1] "Branch Prediction for Free"        Ball and Larus; PLDI '93.    [2] "Static Branch Frequency and Program Profile Analysis"        Wu and Larus; MICRO-27.    [3] "Corpus-based Static Branch Prediction"        Calder, Grunwald, Lindsay, Martin, Mozer, and Zorn; PLDI '95.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"predict.h"
end_include

begin_comment
comment|/* Random guesstimation given names.  */
end_comment

begin_define
define|#
directive|define
name|PROB_NEVER
value|(0)
end_define

begin_define
define|#
directive|define
name|PROB_VERY_UNLIKELY
value|(REG_BR_PROB_BASE / 10 - 1)
end_define

begin_define
define|#
directive|define
name|PROB_UNLIKELY
value|(REG_BR_PROB_BASE * 4 / 10 - 1)
end_define

begin_define
define|#
directive|define
name|PROB_EVEN
value|(REG_BR_PROB_BASE / 2)
end_define

begin_define
define|#
directive|define
name|PROB_LIKELY
value|(REG_BR_PROB_BASE - PROB_UNLIKELY)
end_define

begin_define
define|#
directive|define
name|PROB_VERY_LIKELY
value|(REG_BR_PROB_BASE - PROB_VERY_UNLIKELY)
end_define

begin_define
define|#
directive|define
name|PROB_ALWAYS
value|(REG_BR_PROB_BASE)
end_define

begin_decl_stmt
specifier|static
name|void
name|combine_predictions_for_insn
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|basic_block
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dump_prediction
name|PARAMS
argument_list|(
operator|(
expr|enum
name|br_predictor
operator|,
name|int
operator|,
name|basic_block
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|estimate_loops_at_level
name|PARAMS
argument_list|(
operator|(
expr|struct
name|loop
operator|*
name|loop
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|propagate_freq
name|PARAMS
argument_list|(
operator|(
name|basic_block
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|estimate_bb_frequencies
name|PARAMS
argument_list|(
operator|(
expr|struct
name|loops
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|counts_to_freqs
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Information we hold about each branch predictor.    Filled using information from predict.def.  */
end_comment

begin_struct
struct|struct
name|predictor_info
block|{
specifier|const
name|char
modifier|*
specifier|const
name|name
decl_stmt|;
comment|/* Name used in the debugging dumps.  */
specifier|const
name|int
name|hitrate
decl_stmt|;
comment|/* Expected hitrate used by 				   predict_insn_def call.  */
specifier|const
name|int
name|flags
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Use given predictor without Dempster-Shaffer theory if it matches    using first_match heuristics.  */
end_comment

begin_define
define|#
directive|define
name|PRED_FLAG_FIRST_MATCH
value|1
end_define

begin_comment
comment|/* Recompute hitrate in percent to our representation.  */
end_comment

begin_define
define|#
directive|define
name|HITRATE
parameter_list|(
name|VAL
parameter_list|)
value|((int) ((VAL) * REG_BR_PROB_BASE + 50) / 100)
end_define

begin_define
define|#
directive|define
name|DEF_PREDICTOR
parameter_list|(
name|ENUM
parameter_list|,
name|NAME
parameter_list|,
name|HITRATE
parameter_list|,
name|FLAGS
parameter_list|)
value|{NAME, HITRATE, FLAGS},
end_define

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|predictor_info
name|predictor_info
index|[]
init|=
block|{
include|#
directive|include
file|"predict.def"
comment|/* Upper bound on predictors.  */
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|DEF_PREDICTOR
end_undef

begin_function
name|void
name|predict_insn
parameter_list|(
name|insn
parameter_list|,
name|predictor
parameter_list|,
name|probability
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|int
name|probability
decl_stmt|;
name|enum
name|br_predictor
name|predictor
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|any_condjump_p
argument_list|(
name|insn
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_BR_PRED
argument_list|,
name|gen_rtx_CONCAT
argument_list|(
name|VOIDmode
argument_list|,
name|GEN_INT
argument_list|(
operator|(
name|int
operator|)
name|predictor
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
operator|(
name|int
operator|)
name|probability
argument_list|)
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Predict insn by given predictor.  */
end_comment

begin_function
name|void
name|predict_insn_def
parameter_list|(
name|insn
parameter_list|,
name|predictor
parameter_list|,
name|taken
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|enum
name|br_predictor
name|predictor
decl_stmt|;
name|enum
name|prediction
name|taken
decl_stmt|;
block|{
name|int
name|probability
init|=
name|predictor_info
index|[
operator|(
name|int
operator|)
name|predictor
index|]
operator|.
name|hitrate
decl_stmt|;
if|if
condition|(
name|taken
operator|!=
name|TAKEN
condition|)
name|probability
operator|=
name|REG_BR_PROB_BASE
operator|-
name|probability
expr_stmt|;
name|predict_insn
argument_list|(
name|insn
argument_list|,
name|predictor
argument_list|,
name|probability
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Predict edge E with given probability if possible.  */
end_comment

begin_function
name|void
name|predict_edge
parameter_list|(
name|e
parameter_list|,
name|predictor
parameter_list|,
name|probability
parameter_list|)
name|edge
name|e
decl_stmt|;
name|int
name|probability
decl_stmt|;
name|enum
name|br_predictor
name|predictor
decl_stmt|;
block|{
name|rtx
name|last_insn
decl_stmt|;
name|last_insn
operator|=
name|e
operator|->
name|src
operator|->
name|end
expr_stmt|;
comment|/* We can store the branch prediction information only about      conditional jumps.  */
if|if
condition|(
operator|!
name|any_condjump_p
argument_list|(
name|last_insn
argument_list|)
condition|)
return|return;
comment|/* We always store probability of branching.  */
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
condition|)
name|probability
operator|=
name|REG_BR_PROB_BASE
operator|-
name|probability
expr_stmt|;
name|predict_insn
argument_list|(
name|last_insn
argument_list|,
name|predictor
argument_list|,
name|probability
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Predict edge E by given predictor if possible.  */
end_comment

begin_function
name|void
name|predict_edge_def
parameter_list|(
name|e
parameter_list|,
name|predictor
parameter_list|,
name|taken
parameter_list|)
name|edge
name|e
decl_stmt|;
name|enum
name|br_predictor
name|predictor
decl_stmt|;
name|enum
name|prediction
name|taken
decl_stmt|;
block|{
name|int
name|probability
init|=
name|predictor_info
index|[
operator|(
name|int
operator|)
name|predictor
index|]
operator|.
name|hitrate
decl_stmt|;
if|if
condition|(
name|taken
operator|!=
name|TAKEN
condition|)
name|probability
operator|=
name|REG_BR_PROB_BASE
operator|-
name|probability
expr_stmt|;
name|predict_edge
argument_list|(
name|e
argument_list|,
name|predictor
argument_list|,
name|probability
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Invert all branch predictions or probability notes in the INSN.  This needs    to be done each time we invert the condition used by the jump.  */
end_comment

begin_function
name|void
name|invert_br_probabilities
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|rtx
name|note
decl_stmt|;
for|for
control|(
name|note
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|note
condition|;
name|note
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
operator|==
name|REG_BR_PROB
condition|)
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
operator|=
name|GEN_INT
argument_list|(
name|REG_BR_PROB_BASE
operator|-
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
operator|==
name|REG_BR_PRED
condition|)
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|=
name|GEN_INT
argument_list|(
name|REG_BR_PROB_BASE
operator|-
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dump information about the branch prediction to the output file.  */
end_comment

begin_function
specifier|static
name|void
name|dump_prediction
parameter_list|(
name|predictor
parameter_list|,
name|probability
parameter_list|,
name|bb
parameter_list|,
name|used
parameter_list|)
name|enum
name|br_predictor
name|predictor
decl_stmt|;
name|int
name|probability
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|int
name|used
decl_stmt|;
block|{
name|edge
name|e
init|=
name|bb
operator|->
name|succ
decl_stmt|;
if|if
condition|(
operator|!
name|rtl_dump_file
condition|)
return|return;
while|while
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
condition|)
name|e
operator|=
name|e
operator|->
name|succ_next
expr_stmt|;
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"  %s heuristics%s: %.1f%%"
argument_list|,
name|predictor_info
index|[
name|predictor
index|]
operator|.
name|name
argument_list|,
name|used
condition|?
literal|""
else|:
literal|" (ignored)"
argument_list|,
name|probability
operator|*
literal|100.0
operator|/
name|REG_BR_PROB_BASE
argument_list|)
expr_stmt|;
if|if
condition|(
name|bb
operator|->
name|count
condition|)
block|{
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"  exec "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
name|HOST_WIDEST_INT_PRINT_DEC
argument_list|,
name|bb
operator|->
name|count
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|" hit "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
name|HOST_WIDEST_INT_PRINT_DEC
argument_list|,
name|e
operator|->
name|count
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|" (%.1f%%)"
argument_list|,
name|e
operator|->
name|count
operator|*
literal|100.0
operator|/
name|bb
operator|->
name|count
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Combine all REG_BR_PRED notes into single probability and attach REG_BR_PROB    note if not already present.  Remove now useless REG_BR_PRED notes.  */
end_comment

begin_function
specifier|static
name|void
name|combine_predictions_for_insn
parameter_list|(
name|insn
parameter_list|,
name|bb
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
block|{
name|rtx
name|prob_note
init|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_BR_PROB
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
modifier|*
name|pnote
init|=
operator|&
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|note
decl_stmt|;
name|int
name|best_probability
init|=
name|PROB_EVEN
decl_stmt|;
name|int
name|best_predictor
init|=
name|END_PREDICTORS
decl_stmt|;
name|int
name|combined_probability
init|=
name|REG_BR_PROB_BASE
operator|/
literal|2
decl_stmt|;
name|int
name|d
decl_stmt|;
name|bool
name|first_match
init|=
name|false
decl_stmt|;
name|bool
name|found
init|=
name|false
decl_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Predictions for insn %i bb %i\n"
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
comment|/* We implement "first match" heuristics and use probability guessed      by predictor with smallest index.  In the future we will use better      probability combination techniques.  */
for|for
control|(
name|note
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|note
condition|;
name|note
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
operator|==
name|REG_BR_PRED
condition|)
block|{
name|int
name|predictor
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|probability
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|found
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|best_predictor
operator|>
name|predictor
condition|)
name|best_probability
operator|=
name|probability
operator|,
name|best_predictor
operator|=
name|predictor
expr_stmt|;
name|d
operator|=
operator|(
name|combined_probability
operator|*
name|probability
operator|+
operator|(
name|REG_BR_PROB_BASE
operator|-
name|combined_probability
operator|)
operator|*
operator|(
name|REG_BR_PROB_BASE
operator|-
name|probability
operator|)
operator|)
expr_stmt|;
comment|/* Use FP math to avoid overflows of 32bit integers.  */
if|if
condition|(
name|d
operator|==
literal|0
condition|)
comment|/* If one probability is 0% and one 100%, avoid division by zero.  */
name|combined_probability
operator|=
name|REG_BR_PROB_BASE
operator|/
literal|2
expr_stmt|;
else|else
name|combined_probability
operator|=
operator|(
operator|(
operator|(
name|double
operator|)
name|combined_probability
operator|)
operator|*
name|probability
operator|*
name|REG_BR_PROB_BASE
operator|/
name|d
operator|+
literal|0.5
operator|)
expr_stmt|;
block|}
comment|/* Decide which heuristic to use.  In case we didn't match anything,      use no_prediction heuristic, in case we did match, use either      first match or Dempster-Shaffer theory depending on the flags.  */
if|if
condition|(
name|predictor_info
index|[
name|best_predictor
index|]
operator|.
name|flags
operator|&
name|PRED_FLAG_FIRST_MATCH
condition|)
name|first_match
operator|=
name|true
expr_stmt|;
if|if
condition|(
operator|!
name|found
condition|)
name|dump_prediction
argument_list|(
name|PRED_NO_PREDICTION
argument_list|,
name|combined_probability
argument_list|,
name|bb
argument_list|,
name|true
argument_list|)
expr_stmt|;
else|else
block|{
name|dump_prediction
argument_list|(
name|PRED_DS_THEORY
argument_list|,
name|combined_probability
argument_list|,
name|bb
argument_list|,
operator|!
name|first_match
argument_list|)
expr_stmt|;
name|dump_prediction
argument_list|(
name|PRED_FIRST_MATCH
argument_list|,
name|best_probability
argument_list|,
name|bb
argument_list|,
name|first_match
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|first_match
condition|)
name|combined_probability
operator|=
name|best_probability
expr_stmt|;
name|dump_prediction
argument_list|(
name|PRED_COMBINED
argument_list|,
name|combined_probability
argument_list|,
name|bb
argument_list|,
name|true
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|pnote
condition|)
block|{
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
operator|*
name|pnote
argument_list|)
operator|==
name|REG_BR_PRED
condition|)
block|{
name|int
name|predictor
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
operator|*
name|pnote
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|probability
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
operator|*
name|pnote
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|dump_prediction
argument_list|(
name|predictor
argument_list|,
name|probability
argument_list|,
name|bb
argument_list|,
operator|!
name|first_match
operator|||
name|best_predictor
operator|==
name|predictor
argument_list|)
expr_stmt|;
operator|*
name|pnote
operator|=
name|XEXP
argument_list|(
operator|*
name|pnote
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|pnote
operator|=
operator|&
name|XEXP
argument_list|(
operator|*
name|pnote
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|prob_note
condition|)
block|{
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_BR_PROB
argument_list|,
name|GEN_INT
argument_list|(
name|combined_probability
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Save the prediction into CFG in case we are seeing non-degenerated 	 conditional jump.  */
if|if
condition|(
name|bb
operator|->
name|succ
operator|->
name|succ_next
condition|)
block|{
name|BRANCH_EDGE
argument_list|(
name|bb
argument_list|)
operator|->
name|probability
operator|=
name|combined_probability
expr_stmt|;
name|FALLTHRU_EDGE
argument_list|(
name|bb
argument_list|)
operator|->
name|probability
operator|=
name|REG_BR_PROB_BASE
operator|-
name|combined_probability
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Statically estimate the probability that a branch will be taken.    ??? In the next revision there will be a number of other predictors added    from the above references. Further, each heuristic will be factored out    into its own function for clarity (and to facilitate the combination of    predictions).  */
end_comment

begin_function
name|void
name|estimate_probability
parameter_list|(
name|loops_info
parameter_list|)
name|struct
name|loops
modifier|*
name|loops_info
decl_stmt|;
block|{
name|sbitmap
modifier|*
name|dominators
decl_stmt|,
modifier|*
name|post_dominators
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|found_noreturn
init|=
literal|0
decl_stmt|;
name|dominators
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|n_basic_blocks
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|post_dominators
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|n_basic_blocks
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|calculate_dominance_info
argument_list|(
name|NULL
argument_list|,
name|dominators
argument_list|,
name|CDI_DOMINATORS
argument_list|)
expr_stmt|;
name|calculate_dominance_info
argument_list|(
name|NULL
argument_list|,
name|post_dominators
argument_list|,
name|CDI_POST_DOMINATORS
argument_list|)
expr_stmt|;
comment|/* Try to predict out blocks in a loop that are not part of a      natural loop.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|loops_info
operator|->
name|num
condition|;
name|i
operator|++
control|)
block|{
name|int
name|j
decl_stmt|;
name|int
name|exits
decl_stmt|;
name|struct
name|loop
modifier|*
name|loop
init|=
operator|&
name|loops_info
operator|->
name|array
index|[
name|i
index|]
decl_stmt|;
name|flow_loop_scan
argument_list|(
name|loops_info
argument_list|,
name|loop
argument_list|,
name|LOOP_EXIT_EDGES
argument_list|)
expr_stmt|;
name|exits
operator|=
name|loop
operator|->
name|num_exits
expr_stmt|;
for|for
control|(
name|j
operator|=
name|loop
operator|->
name|first
operator|->
name|index
init|;
name|j
operator|<=
name|loop
operator|->
name|last
operator|->
name|index
condition|;
operator|++
name|j
control|)
if|if
condition|(
name|TEST_BIT
argument_list|(
name|loop
operator|->
name|nodes
argument_list|,
name|j
argument_list|)
condition|)
block|{
name|int
name|header_found
init|=
literal|0
decl_stmt|;
name|edge
name|e
decl_stmt|;
comment|/* Loop branch heuristics - predict an edge back to a 	       loop's head as taken.  */
for|for
control|(
name|e
operator|=
name|BASIC_BLOCK
argument_list|(
name|j
argument_list|)
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
if|if
condition|(
name|e
operator|->
name|dest
operator|==
name|loop
operator|->
name|header
operator|&&
name|e
operator|->
name|src
operator|==
name|loop
operator|->
name|latch
condition|)
block|{
name|header_found
operator|=
literal|1
expr_stmt|;
name|predict_edge_def
argument_list|(
name|e
argument_list|,
name|PRED_LOOP_BRANCH
argument_list|,
name|TAKEN
argument_list|)
expr_stmt|;
block|}
comment|/* Loop exit heuristics - predict an edge exiting the loop if the 	       conditinal has no loop header successors as not taken.  */
if|if
condition|(
operator|!
name|header_found
condition|)
for|for
control|(
name|e
operator|=
name|BASIC_BLOCK
argument_list|(
name|j
argument_list|)
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
if|if
condition|(
name|e
operator|->
name|dest
operator|->
name|index
operator|<
literal|0
operator|||
operator|!
name|TEST_BIT
argument_list|(
name|loop
operator|->
name|nodes
argument_list|,
name|e
operator|->
name|dest
operator|->
name|index
argument_list|)
condition|)
name|predict_edge
argument_list|(
name|e
argument_list|,
name|PRED_LOOP_EXIT
argument_list|,
operator|(
name|REG_BR_PROB_BASE
operator|-
name|predictor_info
index|[
operator|(
name|int
operator|)
name|PRED_LOOP_EXIT
index|]
operator|.
name|hitrate
operator|)
operator|/
name|exits
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Attempt to predict conditional jumps using a number of heuristics.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
name|i
operator|++
control|)
block|{
name|basic_block
name|bb
init|=
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|rtx
name|last_insn
init|=
name|bb
operator|->
name|end
decl_stmt|;
name|rtx
name|cond
decl_stmt|,
name|earliest
decl_stmt|;
name|edge
name|e
decl_stmt|;
comment|/* If block has no successor, predict all possible paths to it as          improbable, as the block contains a call to a noreturn function and          thus can be executed only once.  */
if|if
condition|(
name|bb
operator|->
name|succ
operator|==
name|NULL
operator|&&
operator|!
name|found_noreturn
condition|)
block|{
name|int
name|y
decl_stmt|;
comment|/* ??? Postdominator claims each noreturn block to be postdominated 	     by each, so we need to run only once.  This needs to be changed 	     once postdominace algorithm is updated to say something more 	     sane.  */
name|found_noreturn
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|n_basic_blocks
condition|;
name|y
operator|++
control|)
if|if
condition|(
operator|!
name|TEST_BIT
argument_list|(
name|post_dominators
index|[
name|y
index|]
argument_list|,
name|i
argument_list|)
condition|)
for|for
control|(
name|e
operator|=
name|BASIC_BLOCK
argument_list|(
name|y
argument_list|)
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
if|if
condition|(
name|e
operator|->
name|dest
operator|->
name|index
operator|>=
literal|0
operator|&&
name|TEST_BIT
argument_list|(
name|post_dominators
index|[
name|e
operator|->
name|dest
operator|->
name|index
index|]
argument_list|,
name|i
argument_list|)
condition|)
name|predict_edge_def
argument_list|(
name|e
argument_list|,
name|PRED_NORETURN
argument_list|,
name|NOT_TAKEN
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|last_insn
argument_list|)
operator|!=
name|JUMP_INSN
operator|||
operator|!
name|any_condjump_p
argument_list|(
name|last_insn
argument_list|)
condition|)
continue|continue;
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
block|{
comment|/* Predict edges to blocks that return immediately to be 	     improbable.  These are usually used to signal error states.  */
if|if
condition|(
name|e
operator|->
name|dest
operator|==
name|EXIT_BLOCK_PTR
operator|||
operator|(
name|e
operator|->
name|dest
operator|->
name|succ
operator|&&
operator|!
name|e
operator|->
name|dest
operator|->
name|succ
operator|->
name|succ_next
operator|&&
name|e
operator|->
name|dest
operator|->
name|succ
operator|->
name|dest
operator|==
name|EXIT_BLOCK_PTR
operator|)
condition|)
name|predict_edge_def
argument_list|(
name|e
argument_list|,
name|PRED_ERROR_RETURN
argument_list|,
name|NOT_TAKEN
argument_list|)
expr_stmt|;
comment|/* Look for block we are guarding (ie we dominate it, 	     but it doesn't postdominate us).  */
if|if
condition|(
name|e
operator|->
name|dest
operator|!=
name|EXIT_BLOCK_PTR
operator|&&
name|e
operator|->
name|dest
operator|!=
name|bb
operator|&&
name|TEST_BIT
argument_list|(
name|dominators
index|[
name|e
operator|->
name|dest
operator|->
name|index
index|]
argument_list|,
name|e
operator|->
name|src
operator|->
name|index
argument_list|)
operator|&&
operator|!
name|TEST_BIT
argument_list|(
name|post_dominators
index|[
name|e
operator|->
name|src
operator|->
name|index
index|]
argument_list|,
name|e
operator|->
name|dest
operator|->
name|index
argument_list|)
condition|)
block|{
name|rtx
name|insn
decl_stmt|;
comment|/* The call heuristic claims that a guarded function call 		 is improbable.  This is because such calls are often used 		 to signal exceptional situations such as printing error 		 messages.  */
for|for
control|(
name|insn
operator|=
name|e
operator|->
name|dest
operator|->
name|head
init|;
name|insn
operator|!=
name|NEXT_INSN
argument_list|(
name|e
operator|->
name|dest
operator|->
name|end
argument_list|)
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
comment|/* Constant and pure calls are hardly used to signalize 		       something exceptional.  */
operator|&&
operator|!
name|CONST_OR_PURE_CALL_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|predict_edge_def
argument_list|(
name|e
argument_list|,
name|PRED_CALL
argument_list|,
name|NOT_TAKEN
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
name|cond
operator|=
name|get_condition
argument_list|(
name|last_insn
argument_list|,
operator|&
name|earliest
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cond
condition|)
continue|continue;
comment|/* Try "pointer heuristic." 	 A comparison ptr == 0 is predicted as false. 	 Similarly, a comparison ptr1 == ptr2 is predicted as false.  */
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|cond
argument_list|)
argument_list|)
operator|==
literal|'<'
operator|&&
operator|(
operator|(
name|REG_P
argument_list|(
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|REG_POINTER
argument_list|(
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|REG_P
argument_list|(
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|REG_POINTER
argument_list|(
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|cond
argument_list|)
operator|==
name|EQ
condition|)
name|predict_insn_def
argument_list|(
name|last_insn
argument_list|,
name|PRED_POINTER
argument_list|,
name|NOT_TAKEN
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|cond
argument_list|)
operator|==
name|NE
condition|)
name|predict_insn_def
argument_list|(
name|last_insn
argument_list|,
name|PRED_POINTER
argument_list|,
name|TAKEN
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Try "opcode heuristic." 	 EQ tests are usually false and NE tests are usually true. Also, 	 most quantities are positive, so we can make the appropriate guesses 	 about signed comparisons against zero.  */
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|cond
argument_list|)
condition|)
block|{
case|case
name|CONST_INT
case|:
comment|/* Unconditional branch.  */
name|predict_insn_def
argument_list|(
name|last_insn
argument_list|,
name|PRED_UNCONDITIONAL
argument_list|,
name|cond
operator|==
name|const0_rtx
condition|?
name|NOT_TAKEN
else|:
name|TAKEN
argument_list|)
expr_stmt|;
break|break;
case|case
name|EQ
case|:
case|case
name|UNEQ
case|:
comment|/* Floating point comparisons appears to behave in a very 	       inpredictable way because of special role of = tests in 	       FP code.  */
if|if
condition|(
name|FLOAT_MODE_P
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
empty_stmt|;
comment|/* Comparisons with 0 are often used for booleans and there is 	       nothing usefull to predict about them.  */
elseif|else
if|if
condition|(
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
operator|==
name|const0_rtx
operator|||
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
operator|==
name|const0_rtx
condition|)
empty_stmt|;
else|else
name|predict_insn_def
argument_list|(
name|last_insn
argument_list|,
name|PRED_OPCODE_NONEQUAL
argument_list|,
name|NOT_TAKEN
argument_list|)
expr_stmt|;
break|break;
case|case
name|NE
case|:
case|case
name|LTGT
case|:
comment|/* Floating point comparisons appears to behave in a very 	       inpredictable way because of special role of = tests in 	       FP code.  */
if|if
condition|(
name|FLOAT_MODE_P
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
empty_stmt|;
comment|/* Comparisons with 0 are often used for booleans and there is 	       nothing usefull to predict about them.  */
elseif|else
if|if
condition|(
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
operator|==
name|const0_rtx
operator|||
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
operator|==
name|const0_rtx
condition|)
empty_stmt|;
else|else
name|predict_insn_def
argument_list|(
name|last_insn
argument_list|,
name|PRED_OPCODE_NONEQUAL
argument_list|,
name|TAKEN
argument_list|)
expr_stmt|;
break|break;
case|case
name|ORDERED
case|:
name|predict_insn_def
argument_list|(
name|last_insn
argument_list|,
name|PRED_FPOPCODE
argument_list|,
name|TAKEN
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNORDERED
case|:
name|predict_insn_def
argument_list|(
name|last_insn
argument_list|,
name|PRED_FPOPCODE
argument_list|,
name|NOT_TAKEN
argument_list|)
expr_stmt|;
break|break;
case|case
name|LE
case|:
case|case
name|LT
case|:
if|if
condition|(
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
operator|==
name|const0_rtx
operator|||
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
operator|==
name|const1_rtx
operator|||
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
operator|==
name|constm1_rtx
condition|)
name|predict_insn_def
argument_list|(
name|last_insn
argument_list|,
name|PRED_OPCODE_POSITIVE
argument_list|,
name|NOT_TAKEN
argument_list|)
expr_stmt|;
break|break;
case|case
name|GE
case|:
case|case
name|GT
case|:
if|if
condition|(
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
operator|==
name|const0_rtx
operator|||
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
operator|==
name|const1_rtx
operator|||
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
operator|==
name|constm1_rtx
condition|)
name|predict_insn_def
argument_list|(
name|last_insn
argument_list|,
name|PRED_OPCODE_POSITIVE
argument_list|,
name|TAKEN
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
comment|/* Attach the combined probability to each conditional jump.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|BLOCK_END
argument_list|(
name|i
argument_list|)
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|any_condjump_p
argument_list|(
name|BLOCK_END
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
name|combine_predictions_for_insn
argument_list|(
name|BLOCK_END
argument_list|(
name|i
argument_list|)
argument_list|,
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|sbitmap_vector_free
argument_list|(
name|post_dominators
argument_list|)
expr_stmt|;
name|sbitmap_vector_free
argument_list|(
name|dominators
argument_list|)
expr_stmt|;
name|estimate_bb_frequencies
argument_list|(
name|loops_info
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* __builtin_expect dropped tokens into the insn stream describing expected    values of registers.  Generate branch probabilities based off these    values.  */
end_comment

begin_function
name|void
name|expected_value_to_br_prob
parameter_list|()
block|{
name|rtx
name|insn
decl_stmt|,
name|cond
decl_stmt|,
name|ev
init|=
name|NULL_RTX
decl_stmt|,
name|ev_reg
init|=
name|NULL_RTX
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
condition|)
block|{
case|case
name|NOTE
case|:
comment|/* Look for expected value notes.  */
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_EXPECTED_VALUE
condition|)
block|{
name|ev
operator|=
name|NOTE_EXPECTED_VALUE
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|ev_reg
operator|=
name|XEXP
argument_list|(
name|ev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|delete_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
continue|continue;
case|case
name|CODE_LABEL
case|:
comment|/* Never propagate across labels.  */
name|ev
operator|=
name|NULL_RTX
expr_stmt|;
continue|continue;
case|case
name|JUMP_INSN
case|:
comment|/* Look for simple conditional branches.  If we haven't got an 	     expected value yet, no point going further.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|JUMP_INSN
operator|||
name|ev
operator|==
name|NULL_RTX
operator|||
operator|!
name|any_condjump_p
argument_list|(
name|insn
argument_list|)
condition|)
continue|continue;
break|break;
default|default:
comment|/* Look for insns that clobber the EV register.  */
if|if
condition|(
name|ev
operator|&&
name|reg_set_p
argument_list|(
name|ev_reg
argument_list|,
name|insn
argument_list|)
condition|)
name|ev
operator|=
name|NULL_RTX
expr_stmt|;
continue|continue;
block|}
comment|/* Collect the branch condition, hopefully relative to EV_REG.  */
comment|/* ???  At present we'll miss things like 		(expected_value (eq r70 0)) 		(set r71 -1) 		(set r80 (lt r70 r71)) 		(set pc (if_then_else (ne r80 0) ...)) 	 as canonicalize_condition will render this to us as 		(lt r70, r71) 	 Could use cselib to try and reduce this further.  */
name|cond
operator|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|pc_set
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cond
operator|=
name|canonicalize_condition
argument_list|(
name|insn
argument_list|,
name|cond
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|ev_reg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cond
operator|||
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
operator|!=
name|ev_reg
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
condition|)
continue|continue;
comment|/* Substitute and simplify.  Given that the expression we're 	 building involves two constants, we should wind up with either 	 true or false.  */
name|cond
operator|=
name|gen_rtx_fmt_ee
argument_list|(
name|GET_CODE
argument_list|(
name|cond
argument_list|)
argument_list|,
name|VOIDmode
argument_list|,
name|XEXP
argument_list|(
name|ev
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|cond
operator|=
name|simplify_rtx
argument_list|(
name|cond
argument_list|)
expr_stmt|;
comment|/* Turn the condition into a scaled branch probability.  */
if|if
condition|(
name|cond
operator|!=
name|const_true_rtx
operator|&&
name|cond
operator|!=
name|const0_rtx
condition|)
name|abort
argument_list|()
expr_stmt|;
name|predict_insn_def
argument_list|(
name|insn
argument_list|,
name|PRED_BUILTIN_EXPECT
argument_list|,
name|cond
operator|==
name|const_true_rtx
condition|?
name|TAKEN
else|:
name|NOT_TAKEN
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This is used to carry information about basic blocks.  It is    attached to the AUX field of the standard CFG block.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|block_info_def
block|{
comment|/* Estimated frequency of execution of basic_block.  */
specifier|volatile
name|double
name|frequency
decl_stmt|;
comment|/* To keep queue of basic blocks to process.  */
name|basic_block
name|next
decl_stmt|;
comment|/* True if block needs to be visited in prop_freqency.  */
name|int
name|tovisit
range|:
literal|1
decl_stmt|;
comment|/* Number of predecessors we need to visit first.  */
name|int
name|npredecessors
decl_stmt|;
block|}
typedef|*
name|block_info
typedef|;
end_typedef

begin_comment
comment|/* Similar information for edges.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|edge_info_def
block|{
comment|/* In case edge is an loopback edge, the probability edge will be reached      in case header is.  Estimated number of iterations of the loop can be      then computed as 1 / (1 - back_edge_prob).       Volatile is needed to avoid differences in the optimized and unoptimized      builds on machines where FP registers are wider than double.  */
specifier|volatile
name|double
name|back_edge_prob
decl_stmt|;
comment|/* True if the edge is an loopback edge in the natural loop.  */
name|int
name|back_edge
range|:
literal|1
decl_stmt|;
block|}
typedef|*
name|edge_info
typedef|;
end_typedef

begin_define
define|#
directive|define
name|BLOCK_INFO
parameter_list|(
name|B
parameter_list|)
value|((block_info) (B)->aux)
end_define

begin_define
define|#
directive|define
name|EDGE_INFO
parameter_list|(
name|E
parameter_list|)
value|((edge_info) (E)->aux)
end_define

begin_comment
comment|/* Helper function for estimate_bb_frequencies.    Propagate the frequencies for loops headed by HEAD.  */
end_comment

begin_function
specifier|static
name|void
name|propagate_freq
parameter_list|(
name|head
parameter_list|)
name|basic_block
name|head
decl_stmt|;
block|{
name|basic_block
name|bb
init|=
name|head
decl_stmt|;
name|basic_block
name|last
init|=
name|bb
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|basic_block
name|nextbb
decl_stmt|;
name|int
name|n
decl_stmt|;
comment|/* For each basic block we need to visit count number of his predecessors      we need to visit first.  */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|n_basic_blocks
condition|;
name|n
operator|++
control|)
block|{
name|basic_block
name|bb
init|=
name|BASIC_BLOCK
argument_list|(
name|n
argument_list|)
decl_stmt|;
if|if
condition|(
name|BLOCK_INFO
argument_list|(
name|bb
argument_list|)
operator|->
name|tovisit
condition|)
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|pred
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|pred_next
control|)
if|if
condition|(
name|BLOCK_INFO
argument_list|(
name|e
operator|->
name|src
argument_list|)
operator|->
name|tovisit
operator|&&
operator|!
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_DFS_BACK
operator|)
condition|)
name|count
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|BLOCK_INFO
argument_list|(
name|e
operator|->
name|src
argument_list|)
operator|->
name|tovisit
operator|&&
name|rtl_dump_file
operator|&&
operator|!
name|EDGE_INFO
argument_list|(
name|e
argument_list|)
operator|->
name|back_edge
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Irreducible region hit, ignoring edge to %i->%i\n"
argument_list|,
name|e
operator|->
name|src
operator|->
name|index
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|BLOCK_INFO
argument_list|(
name|bb
argument_list|)
operator|->
name|npredecessors
operator|=
name|count
expr_stmt|;
block|}
block|}
name|BLOCK_INFO
argument_list|(
name|head
argument_list|)
operator|->
name|frequency
operator|=
literal|1
expr_stmt|;
for|for
control|(
init|;
name|bb
condition|;
name|bb
operator|=
name|nextbb
control|)
block|{
name|double
name|cyclic_probability
init|=
literal|0
decl_stmt|,
name|frequency
init|=
literal|0
decl_stmt|;
name|nextbb
operator|=
name|BLOCK_INFO
argument_list|(
name|bb
argument_list|)
operator|->
name|next
expr_stmt|;
name|BLOCK_INFO
argument_list|(
name|bb
argument_list|)
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
comment|/* Compute frequency of basic block.  */
if|if
condition|(
name|bb
operator|!=
name|head
condition|)
block|{
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|pred
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|pred_next
control|)
if|if
condition|(
name|BLOCK_INFO
argument_list|(
name|e
operator|->
name|src
argument_list|)
operator|->
name|tovisit
operator|&&
operator|!
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_DFS_BACK
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|pred
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|pred_next
control|)
if|if
condition|(
name|EDGE_INFO
argument_list|(
name|e
argument_list|)
operator|->
name|back_edge
condition|)
name|cyclic_probability
operator|+=
name|EDGE_INFO
argument_list|(
name|e
argument_list|)
operator|->
name|back_edge_prob
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_DFS_BACK
operator|)
condition|)
name|frequency
operator|+=
operator|(
name|e
operator|->
name|probability
operator|*
name|BLOCK_INFO
argument_list|(
name|e
operator|->
name|src
argument_list|)
operator|->
name|frequency
operator|/
name|REG_BR_PROB_BASE
operator|)
expr_stmt|;
if|if
condition|(
name|cyclic_probability
operator|>
literal|1.0
operator|-
literal|1.0
operator|/
name|REG_BR_PROB_BASE
condition|)
name|cyclic_probability
operator|=
literal|1.0
operator|-
literal|1.0
operator|/
name|REG_BR_PROB_BASE
expr_stmt|;
name|BLOCK_INFO
argument_list|(
name|bb
argument_list|)
operator|->
name|frequency
operator|=
name|frequency
operator|/
operator|(
literal|1
operator|-
name|cyclic_probability
operator|)
expr_stmt|;
block|}
name|BLOCK_INFO
argument_list|(
name|bb
argument_list|)
operator|->
name|tovisit
operator|=
literal|0
expr_stmt|;
comment|/* Compute back edge frequencies.  */
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
if|if
condition|(
name|e
operator|->
name|dest
operator|==
name|head
condition|)
name|EDGE_INFO
argument_list|(
name|e
argument_list|)
operator|->
name|back_edge_prob
operator|=
operator|(
operator|(
name|e
operator|->
name|probability
operator|*
name|BLOCK_INFO
argument_list|(
name|bb
argument_list|)
operator|->
name|frequency
operator|)
operator|/
name|REG_BR_PROB_BASE
operator|)
expr_stmt|;
comment|/* Propagate to successor blocks.  */
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
if|if
condition|(
operator|!
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_DFS_BACK
operator|)
operator|&&
name|BLOCK_INFO
argument_list|(
name|e
operator|->
name|dest
argument_list|)
operator|->
name|npredecessors
condition|)
block|{
name|BLOCK_INFO
argument_list|(
name|e
operator|->
name|dest
argument_list|)
operator|->
name|npredecessors
operator|--
expr_stmt|;
if|if
condition|(
operator|!
name|BLOCK_INFO
argument_list|(
name|e
operator|->
name|dest
argument_list|)
operator|->
name|npredecessors
condition|)
block|{
if|if
condition|(
operator|!
name|nextbb
condition|)
name|nextbb
operator|=
name|e
operator|->
name|dest
expr_stmt|;
else|else
name|BLOCK_INFO
argument_list|(
name|last
argument_list|)
operator|->
name|next
operator|=
name|e
operator|->
name|dest
expr_stmt|;
name|last
operator|=
name|e
operator|->
name|dest
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Estimate probabilities of loopback edges in loops at same nest level.  */
end_comment

begin_function
specifier|static
name|void
name|estimate_loops_at_level
parameter_list|(
name|first_loop
parameter_list|)
name|struct
name|loop
modifier|*
name|first_loop
decl_stmt|;
block|{
name|struct
name|loop
modifier|*
name|l
decl_stmt|,
modifier|*
name|loop
init|=
name|first_loop
decl_stmt|;
for|for
control|(
name|loop
operator|=
name|first_loop
init|;
name|loop
condition|;
name|loop
operator|=
name|loop
operator|->
name|next
control|)
block|{
name|int
name|n
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|estimate_loops_at_level
argument_list|(
name|loop
operator|->
name|inner
argument_list|)
expr_stmt|;
comment|/* Find current loop back edge and mark it.  */
for|for
control|(
name|e
operator|=
name|loop
operator|->
name|latch
operator|->
name|succ
init|;
name|e
operator|->
name|dest
operator|!=
name|loop
operator|->
name|header
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
empty_stmt|;
name|EDGE_INFO
argument_list|(
name|e
argument_list|)
operator|->
name|back_edge
operator|=
literal|1
expr_stmt|;
comment|/* In case the loop header is shared, ensure that it is the last 	 one sharing the same header, so we avoid redundant work.  */
if|if
condition|(
name|loop
operator|->
name|shared
condition|)
block|{
for|for
control|(
name|l
operator|=
name|loop
operator|->
name|next
init|;
name|l
condition|;
name|l
operator|=
name|l
operator|->
name|next
control|)
if|if
condition|(
name|l
operator|->
name|header
operator|==
name|loop
operator|->
name|header
condition|)
break|break;
if|if
condition|(
name|l
condition|)
continue|continue;
block|}
comment|/* Now merge all nodes of all loops with given header as not visited.  */
for|for
control|(
name|l
operator|=
name|loop
operator|->
name|shared
condition|?
name|first_loop
else|:
name|loop
init|;
name|l
operator|!=
name|loop
operator|->
name|next
condition|;
name|l
operator|=
name|l
operator|->
name|next
control|)
if|if
condition|(
name|loop
operator|->
name|header
operator|==
name|l
operator|->
name|header
condition|)
name|EXECUTE_IF_SET_IN_SBITMAP
argument_list|(
name|l
operator|->
name|nodes
argument_list|,
literal|0
argument_list|,
name|n
argument_list|,
name|BLOCK_INFO
argument_list|(
name|BASIC_BLOCK
argument_list|(
name|n
argument_list|)
argument_list|)
operator|->
name|tovisit
operator|=
literal|1
argument_list|)
expr_stmt|;
name|propagate_freq
argument_list|(
name|loop
operator|->
name|header
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Convert counts measured by profile driven feedback to frequencies.  */
end_comment

begin_function
specifier|static
name|void
name|counts_to_freqs
parameter_list|()
block|{
name|HOST_WIDEST_INT
name|count_max
init|=
literal|1
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
name|i
operator|++
control|)
name|count_max
operator|=
name|MAX
argument_list|(
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
operator|->
name|count
argument_list|,
name|count_max
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
operator|-
literal|2
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
name|i
operator|++
control|)
block|{
name|basic_block
name|bb
decl_stmt|;
if|if
condition|(
name|i
operator|==
operator|-
literal|2
condition|)
name|bb
operator|=
name|ENTRY_BLOCK_PTR
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
name|bb
operator|=
name|EXIT_BLOCK_PTR
expr_stmt|;
else|else
name|bb
operator|=
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|bb
operator|->
name|frequency
operator|=
operator|(
name|bb
operator|->
name|count
operator|*
name|BB_FREQ_MAX
operator|+
name|count_max
operator|/
literal|2
operator|)
operator|/
name|count_max
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return true if function is likely to be expensive, so there is no point to    optimize performance of prologue, epilogue or do inlining at the expense    of code size growth.  THRESHOLD is the limit of number of isntructions    function can execute at average to be still considered not expensive.  */
end_comment

begin_function
name|bool
name|expensive_function_p
parameter_list|(
name|threshold
parameter_list|)
name|int
name|threshold
decl_stmt|;
block|{
name|unsigned
name|int
name|sum
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|limit
decl_stmt|;
comment|/* We can not compute accurately for large thresholds due to scaled      frequencies.  */
if|if
condition|(
name|threshold
operator|>
name|BB_FREQ_MAX
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Frequencies are out of range.  This either means that function contains      internal loop executing more than BB_FREQ_MAX times or profile feedback      is available and function has not been executed at all.  */
if|if
condition|(
name|ENTRY_BLOCK_PTR
operator|->
name|frequency
operator|==
literal|0
condition|)
return|return
name|true
return|;
comment|/* Maximally BB_FREQ_MAX^2 so overflow won't happen.  */
name|limit
operator|=
name|ENTRY_BLOCK_PTR
operator|->
name|frequency
operator|*
name|threshold
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
name|i
operator|++
control|)
block|{
name|basic_block
name|bb
init|=
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|bb
operator|->
name|head
init|;
name|insn
operator|!=
name|NEXT_INSN
argument_list|(
name|bb
operator|->
name|end
argument_list|)
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|active_insn_p
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|sum
operator|+=
name|bb
operator|->
name|frequency
expr_stmt|;
if|if
condition|(
name|sum
operator|>
name|limit
condition|)
return|return
name|true
return|;
block|}
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Estimate basic blocks frequency by given branch probabilities.  */
end_comment

begin_function
specifier|static
name|void
name|estimate_bb_frequencies
parameter_list|(
name|loops
parameter_list|)
name|struct
name|loops
modifier|*
name|loops
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|double
name|freq_max
init|=
literal|0
decl_stmt|;
name|mark_dfs_back_edges
argument_list|()
expr_stmt|;
if|if
condition|(
name|flag_branch_probabilities
condition|)
block|{
name|counts_to_freqs
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* Fill in the probability values in flowgraph based on the REG_BR_PROB      notes.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|last_insn
init|=
name|BLOCK_END
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|int
name|probability
decl_stmt|;
name|edge
name|fallthru
decl_stmt|,
name|branch
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|last_insn
argument_list|)
operator|!=
name|JUMP_INSN
operator|||
operator|!
name|any_condjump_p
argument_list|(
name|last_insn
argument_list|)
comment|/* Avoid handling of conditional jumps jumping to fallthru edge.  */
operator|||
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
operator|->
name|succ
operator|->
name|succ_next
operator|==
name|NULL
condition|)
block|{
comment|/* We can predict only conditional jumps at the moment. 	     Expect each edge to be equally probable. 	     ?? In the future we want to make abnormal edges improbable.  */
name|int
name|nedges
init|=
literal|0
decl_stmt|;
name|edge
name|e
decl_stmt|;
for|for
control|(
name|e
operator|=
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
block|{
name|nedges
operator|++
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|probability
operator|!=
literal|0
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|e
condition|)
for|for
control|(
name|e
operator|=
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
name|e
operator|->
name|probability
operator|=
operator|(
name|REG_BR_PROB_BASE
operator|+
name|nedges
operator|/
literal|2
operator|)
operator|/
name|nedges
expr_stmt|;
block|}
else|else
block|{
name|probability
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|find_reg_note
argument_list|(
name|last_insn
argument_list|,
name|REG_BR_PROB
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fallthru
operator|=
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
operator|->
name|succ
expr_stmt|;
if|if
condition|(
operator|!
name|fallthru
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
condition|)
name|fallthru
operator|=
name|fallthru
operator|->
name|succ_next
expr_stmt|;
name|branch
operator|=
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
operator|->
name|succ
expr_stmt|;
if|if
condition|(
name|branch
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
condition|)
name|branch
operator|=
name|branch
operator|->
name|succ_next
expr_stmt|;
name|branch
operator|->
name|probability
operator|=
name|probability
expr_stmt|;
name|fallthru
operator|->
name|probability
operator|=
name|REG_BR_PROB_BASE
operator|-
name|probability
expr_stmt|;
block|}
block|}
name|ENTRY_BLOCK_PTR
operator|->
name|succ
operator|->
name|probability
operator|=
name|REG_BR_PROB_BASE
expr_stmt|;
comment|/* Set up block info for each basic block.  */
name|alloc_aux_for_blocks
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|block_info_def
argument_list|)
argument_list|)
expr_stmt|;
name|alloc_aux_for_edges
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|edge_info_def
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
operator|-
literal|2
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
name|i
operator|++
control|)
block|{
name|edge
name|e
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
if|if
condition|(
name|i
operator|==
operator|-
literal|2
condition|)
name|bb
operator|=
name|ENTRY_BLOCK_PTR
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
name|bb
operator|=
name|EXIT_BLOCK_PTR
expr_stmt|;
else|else
name|bb
operator|=
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|BLOCK_INFO
argument_list|(
name|bb
argument_list|)
operator|->
name|tovisit
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
name|EDGE_INFO
argument_list|(
name|e
argument_list|)
operator|->
name|back_edge_prob
operator|=
operator|(
operator|(
name|double
operator|)
name|e
operator|->
name|probability
operator|/
name|REG_BR_PROB_BASE
operator|)
expr_stmt|;
block|}
comment|/* First compute probabilities locally for each loop from innermost      to outermost to examine probabilities for back edges.  */
name|estimate_loops_at_level
argument_list|(
name|loops
operator|->
name|tree_root
argument_list|)
expr_stmt|;
comment|/* Now fake loop around whole function to finalize probabilities.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
name|i
operator|++
control|)
name|BLOCK_INFO
argument_list|(
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
argument_list|)
operator|->
name|tovisit
operator|=
literal|1
expr_stmt|;
name|BLOCK_INFO
argument_list|(
name|ENTRY_BLOCK_PTR
argument_list|)
operator|->
name|tovisit
operator|=
literal|1
expr_stmt|;
name|BLOCK_INFO
argument_list|(
name|EXIT_BLOCK_PTR
argument_list|)
operator|->
name|tovisit
operator|=
literal|1
expr_stmt|;
name|propagate_freq
argument_list|(
name|ENTRY_BLOCK_PTR
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|BLOCK_INFO
argument_list|(
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
argument_list|)
operator|->
name|frequency
operator|>
name|freq_max
condition|)
name|freq_max
operator|=
name|BLOCK_INFO
argument_list|(
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
argument_list|)
operator|->
name|frequency
expr_stmt|;
for|for
control|(
name|i
operator|=
operator|-
literal|2
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
name|i
operator|++
control|)
block|{
name|basic_block
name|bb
decl_stmt|;
specifier|volatile
name|double
name|tmp
decl_stmt|;
if|if
condition|(
name|i
operator|==
operator|-
literal|2
condition|)
name|bb
operator|=
name|ENTRY_BLOCK_PTR
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
name|bb
operator|=
name|EXIT_BLOCK_PTR
expr_stmt|;
else|else
name|bb
operator|=
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
expr_stmt|;
comment|/* ??? Prevent rounding differences due to optimization on x86.  */
name|tmp
operator|=
name|BLOCK_INFO
argument_list|(
name|bb
argument_list|)
operator|->
name|frequency
operator|*
name|BB_FREQ_MAX
expr_stmt|;
name|tmp
operator|/=
name|freq_max
expr_stmt|;
name|tmp
operator|+=
literal|0.5
expr_stmt|;
name|bb
operator|->
name|frequency
operator|=
name|tmp
expr_stmt|;
block|}
name|free_aux_for_blocks
argument_list|()
expr_stmt|;
name|free_aux_for_edges
argument_list|()
expr_stmt|;
block|}
end_function

end_unit

