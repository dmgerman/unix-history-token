begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Branch prediction routines for the GNU compiler.    Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005    Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* References:     [1] "Branch Prediction for Free"        Ball and Larus; PLDI '93.    [2] "Static Branch Frequency and Program Profile Analysis"        Wu and Larus; MICRO-27.    [3] "Corpus-based Static Branch Prediction"        Calder, Grunwald, Lindsay, Martin, Mozer, and Zorn; PLDI '95.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"predict.h"
end_include

begin_include
include|#
directive|include
file|"coverage.h"
end_include

begin_include
include|#
directive|include
file|"sreal.h"
end_include

begin_include
include|#
directive|include
file|"params.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"loop.h"
end_include

begin_include
include|#
directive|include
file|"cfgloop.h"
end_include

begin_comment
comment|/* real constants: 0, 1, 1-1/REG_BR_PROB_BASE, REG_BR_PROB_BASE, 		   1/REG_BR_PROB_BASE, 0.5, BB_FREQ_MAX.  */
end_comment

begin_decl_stmt
specifier|static
name|sreal
name|real_zero
decl_stmt|,
name|real_one
decl_stmt|,
name|real_almost_one
decl_stmt|,
name|real_br_prob_base
decl_stmt|,
name|real_inv_br_prob_base
decl_stmt|,
name|real_one_half
decl_stmt|,
name|real_bb_freq_max
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Random guesstimation given names.  */
end_comment

begin_define
define|#
directive|define
name|PROB_VERY_UNLIKELY
value|(REG_BR_PROB_BASE / 100 - 1)
end_define

begin_define
define|#
directive|define
name|PROB_EVEN
value|(REG_BR_PROB_BASE / 2)
end_define

begin_define
define|#
directive|define
name|PROB_VERY_LIKELY
value|(REG_BR_PROB_BASE - PROB_VERY_UNLIKELY)
end_define

begin_define
define|#
directive|define
name|PROB_ALWAYS
value|(REG_BR_PROB_BASE)
end_define

begin_function_decl
specifier|static
name|bool
name|predicted_by_p
parameter_list|(
name|basic_block
parameter_list|,
name|enum
name|br_predictor
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|combine_predictions_for_insn
parameter_list|(
name|rtx
parameter_list|,
name|basic_block
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_prediction
parameter_list|(
name|enum
name|br_predictor
parameter_list|,
name|int
parameter_list|,
name|basic_block
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|estimate_loops_at_level
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|propagate_freq
parameter_list|(
name|struct
name|loop
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|estimate_bb_frequencies
parameter_list|(
name|struct
name|loops
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|counts_to_freqs
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|process_note_predictions
parameter_list|(
name|basic_block
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|process_note_prediction
parameter_list|(
name|basic_block
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|last_basic_block_p
parameter_list|(
name|basic_block
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|compute_function_frequency
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|choose_function_section
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|can_predict_insn_p
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Information we hold about each branch predictor.    Filled using information from predict.def.  */
end_comment

begin_struct
struct|struct
name|predictor_info
block|{
specifier|const
name|char
modifier|*
specifier|const
name|name
decl_stmt|;
comment|/* Name used in the debugging dumps.  */
specifier|const
name|int
name|hitrate
decl_stmt|;
comment|/* Expected hitrate used by 				   predict_insn_def call.  */
specifier|const
name|int
name|flags
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Use given predictor without Dempster-Shaffer theory if it matches    using first_match heuristics.  */
end_comment

begin_define
define|#
directive|define
name|PRED_FLAG_FIRST_MATCH
value|1
end_define

begin_comment
comment|/* Recompute hitrate in percent to our representation.  */
end_comment

begin_define
define|#
directive|define
name|HITRATE
parameter_list|(
name|VAL
parameter_list|)
value|((int) ((VAL) * REG_BR_PROB_BASE + 50) / 100)
end_define

begin_define
define|#
directive|define
name|DEF_PREDICTOR
parameter_list|(
name|ENUM
parameter_list|,
name|NAME
parameter_list|,
name|HITRATE
parameter_list|,
name|FLAGS
parameter_list|)
value|{NAME, HITRATE, FLAGS},
end_define

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|predictor_info
name|predictor_info
index|[]
init|=
block|{
include|#
directive|include
file|"predict.def"
comment|/* Upper bound on predictors.  */
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|DEF_PREDICTOR
end_undef

begin_comment
comment|/* Return true in case BB can be CPU intensive and should be optimized    for maximal performance.  */
end_comment

begin_function
name|bool
name|maybe_hot_bb_p
parameter_list|(
name|basic_block
name|bb
parameter_list|)
block|{
if|if
condition|(
name|profile_info
operator|&&
name|flag_branch_probabilities
operator|&&
operator|(
name|bb
operator|->
name|count
operator|<
name|profile_info
operator|->
name|sum_max
operator|/
name|PARAM_VALUE
argument_list|(
name|HOT_BB_COUNT_FRACTION
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|bb
operator|->
name|frequency
operator|<
name|BB_FREQ_MAX
operator|/
name|PARAM_VALUE
argument_list|(
name|HOT_BB_FREQUENCY_FRACTION
argument_list|)
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Return true in case BB is cold and should be optimized for size.  */
end_comment

begin_function
name|bool
name|probably_cold_bb_p
parameter_list|(
name|basic_block
name|bb
parameter_list|)
block|{
if|if
condition|(
name|profile_info
operator|&&
name|flag_branch_probabilities
operator|&&
operator|(
name|bb
operator|->
name|count
operator|<
name|profile_info
operator|->
name|sum_max
operator|/
name|PARAM_VALUE
argument_list|(
name|HOT_BB_COUNT_FRACTION
argument_list|)
operator|)
condition|)
return|return
name|true
return|;
if|if
condition|(
name|bb
operator|->
name|frequency
operator|<
name|BB_FREQ_MAX
operator|/
name|PARAM_VALUE
argument_list|(
name|HOT_BB_FREQUENCY_FRACTION
argument_list|)
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Return true in case BB is probably never executed.  */
end_comment

begin_function
name|bool
name|probably_never_executed_bb_p
parameter_list|(
name|basic_block
name|bb
parameter_list|)
block|{
if|if
condition|(
name|profile_info
operator|&&
name|flag_branch_probabilities
condition|)
return|return
operator|(
operator|(
name|bb
operator|->
name|count
operator|+
name|profile_info
operator|->
name|runs
operator|/
literal|2
operator|)
operator|/
name|profile_info
operator|->
name|runs
operator|)
operator|==
literal|0
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Return true if the one of outgoing edges is already predicted by    PREDICTOR.  */
end_comment

begin_function
specifier|static
name|bool
name|predicted_by_p
parameter_list|(
name|basic_block
name|bb
parameter_list|,
name|enum
name|br_predictor
name|predictor
parameter_list|)
block|{
name|rtx
name|note
decl_stmt|;
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
for|for
control|(
name|note
operator|=
name|REG_NOTES
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
init|;
name|note
condition|;
name|note
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
operator|==
name|REG_BR_PRED
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
operator|(
name|int
operator|)
name|predictor
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_function
name|void
name|predict_insn
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|enum
name|br_predictor
name|predictor
parameter_list|,
name|int
name|probability
parameter_list|)
block|{
if|if
condition|(
operator|!
name|any_condjump_p
argument_list|(
name|insn
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|flag_guess_branch_prob
condition|)
return|return;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_BR_PRED
argument_list|,
name|gen_rtx_CONCAT
argument_list|(
name|VOIDmode
argument_list|,
name|GEN_INT
argument_list|(
operator|(
name|int
operator|)
name|predictor
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
operator|(
name|int
operator|)
name|probability
argument_list|)
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Predict insn by given predictor.  */
end_comment

begin_function
name|void
name|predict_insn_def
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|enum
name|br_predictor
name|predictor
parameter_list|,
name|enum
name|prediction
name|taken
parameter_list|)
block|{
name|int
name|probability
init|=
name|predictor_info
index|[
operator|(
name|int
operator|)
name|predictor
index|]
operator|.
name|hitrate
decl_stmt|;
if|if
condition|(
name|taken
operator|!=
name|TAKEN
condition|)
name|probability
operator|=
name|REG_BR_PROB_BASE
operator|-
name|probability
expr_stmt|;
name|predict_insn
argument_list|(
name|insn
argument_list|,
name|predictor
argument_list|,
name|probability
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Predict edge E with given probability if possible.  */
end_comment

begin_function
name|void
name|predict_edge
parameter_list|(
name|edge
name|e
parameter_list|,
name|enum
name|br_predictor
name|predictor
parameter_list|,
name|int
name|probability
parameter_list|)
block|{
name|rtx
name|last_insn
decl_stmt|;
name|last_insn
operator|=
name|BB_END
argument_list|(
name|e
operator|->
name|src
argument_list|)
expr_stmt|;
comment|/* We can store the branch prediction information only about      conditional jumps.  */
if|if
condition|(
operator|!
name|any_condjump_p
argument_list|(
name|last_insn
argument_list|)
condition|)
return|return;
comment|/* We always store probability of branching.  */
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
condition|)
name|probability
operator|=
name|REG_BR_PROB_BASE
operator|-
name|probability
expr_stmt|;
name|predict_insn
argument_list|(
name|last_insn
argument_list|,
name|predictor
argument_list|,
name|probability
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return true when we can store prediction on insn INSN.    At the moment we represent predictions only on conditional    jumps, not at computed jump or other complicated cases.  */
end_comment

begin_function
specifier|static
name|bool
name|can_predict_insn_p
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
return|return
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|any_condjump_p
argument_list|(
name|insn
argument_list|)
operator|&&
name|BLOCK_FOR_INSN
argument_list|(
name|insn
argument_list|)
operator|->
name|succ
operator|->
name|succ_next
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Predict edge E by given predictor if possible.  */
end_comment

begin_function
name|void
name|predict_edge_def
parameter_list|(
name|edge
name|e
parameter_list|,
name|enum
name|br_predictor
name|predictor
parameter_list|,
name|enum
name|prediction
name|taken
parameter_list|)
block|{
name|int
name|probability
init|=
name|predictor_info
index|[
operator|(
name|int
operator|)
name|predictor
index|]
operator|.
name|hitrate
decl_stmt|;
if|if
condition|(
name|taken
operator|!=
name|TAKEN
condition|)
name|probability
operator|=
name|REG_BR_PROB_BASE
operator|-
name|probability
expr_stmt|;
name|predict_edge
argument_list|(
name|e
argument_list|,
name|predictor
argument_list|,
name|probability
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Invert all branch predictions or probability notes in the INSN.  This needs    to be done each time we invert the condition used by the jump.  */
end_comment

begin_function
name|void
name|invert_br_probabilities
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|rtx
name|note
decl_stmt|;
for|for
control|(
name|note
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|note
condition|;
name|note
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
operator|==
name|REG_BR_PROB
condition|)
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
operator|=
name|GEN_INT
argument_list|(
name|REG_BR_PROB_BASE
operator|-
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
operator|==
name|REG_BR_PRED
condition|)
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|=
name|GEN_INT
argument_list|(
name|REG_BR_PROB_BASE
operator|-
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dump information about the branch prediction to the output file.  */
end_comment

begin_function
specifier|static
name|void
name|dump_prediction
parameter_list|(
name|enum
name|br_predictor
name|predictor
parameter_list|,
name|int
name|probability
parameter_list|,
name|basic_block
name|bb
parameter_list|,
name|int
name|used
parameter_list|)
block|{
name|edge
name|e
init|=
name|bb
operator|->
name|succ
decl_stmt|;
if|if
condition|(
operator|!
name|rtl_dump_file
condition|)
return|return;
while|while
condition|(
name|e
operator|&&
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
operator|)
condition|)
name|e
operator|=
name|e
operator|->
name|succ_next
expr_stmt|;
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"  %s heuristics%s: %.1f%%"
argument_list|,
name|predictor_info
index|[
name|predictor
index|]
operator|.
name|name
argument_list|,
name|used
condition|?
literal|""
else|:
literal|" (ignored)"
argument_list|,
name|probability
operator|*
literal|100.0
operator|/
name|REG_BR_PROB_BASE
argument_list|)
expr_stmt|;
if|if
condition|(
name|bb
operator|->
name|count
condition|)
block|{
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"  exec "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
name|HOST_WIDEST_INT_PRINT_DEC
argument_list|,
name|bb
operator|->
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
condition|)
block|{
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|" hit "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
name|HOST_WIDEST_INT_PRINT_DEC
argument_list|,
name|e
operator|->
name|count
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|" (%.1f%%)"
argument_list|,
name|e
operator|->
name|count
operator|*
literal|100.0
operator|/
name|bb
operator|->
name|count
argument_list|)
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Combine all REG_BR_PRED notes into single probability and attach REG_BR_PROB    note if not already present.  Remove now useless REG_BR_PRED notes.  */
end_comment

begin_function
specifier|static
name|void
name|combine_predictions_for_insn
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|basic_block
name|bb
parameter_list|)
block|{
name|rtx
name|prob_note
init|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_BR_PROB
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
modifier|*
name|pnote
init|=
operator|&
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|note
decl_stmt|;
name|int
name|best_probability
init|=
name|PROB_EVEN
decl_stmt|;
name|int
name|best_predictor
init|=
name|END_PREDICTORS
decl_stmt|;
name|int
name|combined_probability
init|=
name|REG_BR_PROB_BASE
operator|/
literal|2
decl_stmt|;
name|int
name|d
decl_stmt|;
name|bool
name|first_match
init|=
name|false
decl_stmt|;
name|bool
name|found
init|=
name|false
decl_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Predictions for insn %i bb %i\n"
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
comment|/* We implement "first match" heuristics and use probability guessed      by predictor with smallest index.  In the future we will use better      probability combination techniques.  */
for|for
control|(
name|note
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|note
condition|;
name|note
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
operator|==
name|REG_BR_PRED
condition|)
block|{
name|int
name|predictor
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|probability
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|found
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|best_predictor
operator|>
name|predictor
condition|)
name|best_probability
operator|=
name|probability
operator|,
name|best_predictor
operator|=
name|predictor
expr_stmt|;
name|d
operator|=
operator|(
name|combined_probability
operator|*
name|probability
operator|+
operator|(
name|REG_BR_PROB_BASE
operator|-
name|combined_probability
operator|)
operator|*
operator|(
name|REG_BR_PROB_BASE
operator|-
name|probability
operator|)
operator|)
expr_stmt|;
comment|/* Use FP math to avoid overflows of 32bit integers.  */
if|if
condition|(
name|d
operator|==
literal|0
condition|)
comment|/* If one probability is 0% and one 100%, avoid division by zero.  */
name|combined_probability
operator|=
name|REG_BR_PROB_BASE
operator|/
literal|2
expr_stmt|;
else|else
name|combined_probability
operator|=
operator|(
operator|(
operator|(
name|double
operator|)
name|combined_probability
operator|)
operator|*
name|probability
operator|*
name|REG_BR_PROB_BASE
operator|/
name|d
operator|+
literal|0.5
operator|)
expr_stmt|;
block|}
comment|/* Decide which heuristic to use.  In case we didn't match anything,      use no_prediction heuristic, in case we did match, use either      first match or Dempster-Shaffer theory depending on the flags.  */
if|if
condition|(
name|predictor_info
index|[
name|best_predictor
index|]
operator|.
name|flags
operator|&
name|PRED_FLAG_FIRST_MATCH
condition|)
name|first_match
operator|=
name|true
expr_stmt|;
if|if
condition|(
operator|!
name|found
condition|)
name|dump_prediction
argument_list|(
name|PRED_NO_PREDICTION
argument_list|,
name|combined_probability
argument_list|,
name|bb
argument_list|,
name|true
argument_list|)
expr_stmt|;
else|else
block|{
name|dump_prediction
argument_list|(
name|PRED_DS_THEORY
argument_list|,
name|combined_probability
argument_list|,
name|bb
argument_list|,
operator|!
name|first_match
argument_list|)
expr_stmt|;
name|dump_prediction
argument_list|(
name|PRED_FIRST_MATCH
argument_list|,
name|best_probability
argument_list|,
name|bb
argument_list|,
name|first_match
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|first_match
condition|)
name|combined_probability
operator|=
name|best_probability
expr_stmt|;
name|dump_prediction
argument_list|(
name|PRED_COMBINED
argument_list|,
name|combined_probability
argument_list|,
name|bb
argument_list|,
name|true
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|pnote
condition|)
block|{
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
operator|*
name|pnote
argument_list|)
operator|==
name|REG_BR_PRED
condition|)
block|{
name|int
name|predictor
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
operator|*
name|pnote
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|probability
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
operator|*
name|pnote
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|dump_prediction
argument_list|(
name|predictor
argument_list|,
name|probability
argument_list|,
name|bb
argument_list|,
operator|!
name|first_match
operator|||
name|best_predictor
operator|==
name|predictor
argument_list|)
expr_stmt|;
operator|*
name|pnote
operator|=
name|XEXP
argument_list|(
operator|*
name|pnote
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|pnote
operator|=
operator|&
name|XEXP
argument_list|(
operator|*
name|pnote
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|prob_note
condition|)
block|{
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_BR_PROB
argument_list|,
name|GEN_INT
argument_list|(
name|combined_probability
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Save the prediction into CFG in case we are seeing non-degenerated 	 conditional jump.  */
if|if
condition|(
name|bb
operator|->
name|succ
operator|->
name|succ_next
condition|)
block|{
name|BRANCH_EDGE
argument_list|(
name|bb
argument_list|)
operator|->
name|probability
operator|=
name|combined_probability
expr_stmt|;
name|FALLTHRU_EDGE
argument_list|(
name|bb
argument_list|)
operator|->
name|probability
operator|=
name|REG_BR_PROB_BASE
operator|-
name|combined_probability
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Statically estimate the probability that a branch will be taken.    ??? In the next revision there will be a number of other predictors added    from the above references. Further, each heuristic will be factored out    into its own function for clarity (and to facilitate the combination of    predictions).  */
end_comment

begin_function
name|void
name|estimate_probability
parameter_list|(
name|struct
name|loops
modifier|*
name|loops_info
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|connect_infinite_loops_to_exit
argument_list|()
expr_stmt|;
name|calculate_dominance_info
argument_list|(
name|CDI_DOMINATORS
argument_list|)
expr_stmt|;
name|calculate_dominance_info
argument_list|(
name|CDI_POST_DOMINATORS
argument_list|)
expr_stmt|;
comment|/* Try to predict out blocks in a loop that are not part of a      natural loop.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|loops_info
operator|->
name|num
condition|;
name|i
operator|++
control|)
block|{
name|basic_block
name|bb
decl_stmt|,
modifier|*
name|bbs
decl_stmt|;
name|unsigned
name|j
decl_stmt|;
name|int
name|exits
decl_stmt|;
name|struct
name|loop
modifier|*
name|loop
init|=
name|loops_info
operator|->
name|parray
index|[
name|i
index|]
decl_stmt|;
name|struct
name|loop_desc
name|desc
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|niter
decl_stmt|;
name|flow_loop_scan
argument_list|(
name|loop
argument_list|,
name|LOOP_EXIT_EDGES
argument_list|)
expr_stmt|;
name|exits
operator|=
name|loop
operator|->
name|num_exits
expr_stmt|;
if|if
condition|(
name|simple_loop_p
argument_list|(
name|loop
argument_list|,
operator|&
name|desc
argument_list|)
operator|&&
name|desc
operator|.
name|const_iter
condition|)
block|{
name|int
name|prob
decl_stmt|;
name|niter
operator|=
name|desc
operator|.
name|niter
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|niter
operator|==
literal|0
condition|)
comment|/* We might overflow here.  */
name|niter
operator|=
name|desc
operator|.
name|niter
expr_stmt|;
name|prob
operator|=
operator|(
name|REG_BR_PROB_BASE
operator|-
operator|(
name|REG_BR_PROB_BASE
operator|+
name|niter
operator|/
literal|2
operator|)
operator|/
name|niter
operator|)
expr_stmt|;
comment|/* Branch prediction algorithm gives 0 frequency for everything 	     after the end of loop for loop having 0 probability to finish.  */
if|if
condition|(
name|prob
operator|==
name|REG_BR_PROB_BASE
condition|)
name|prob
operator|=
name|REG_BR_PROB_BASE
operator|-
literal|1
expr_stmt|;
name|predict_edge
argument_list|(
name|desc
operator|.
name|in_edge
argument_list|,
name|PRED_LOOP_ITERATIONS
argument_list|,
name|prob
argument_list|)
expr_stmt|;
block|}
name|bbs
operator|=
name|get_loop_body
argument_list|(
name|loop
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|loop
operator|->
name|num_nodes
condition|;
name|j
operator|++
control|)
block|{
name|int
name|header_found
init|=
literal|0
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|bb
operator|=
name|bbs
index|[
name|j
index|]
expr_stmt|;
comment|/* Bypass loop heuristics on continue statement.  These 	     statements construct loops via "non-loop" constructs 	     in the source language and are better to be handled 	     separately.  */
if|if
condition|(
operator|!
name|can_predict_insn_p
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
operator|||
name|predicted_by_p
argument_list|(
name|bb
argument_list|,
name|PRED_CONTINUE
argument_list|)
condition|)
continue|continue;
comment|/* Loop branch heuristics - predict an edge back to a 	     loop's head as taken.  */
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
if|if
condition|(
name|e
operator|->
name|dest
operator|==
name|loop
operator|->
name|header
operator|&&
name|e
operator|->
name|src
operator|==
name|loop
operator|->
name|latch
condition|)
block|{
name|header_found
operator|=
literal|1
expr_stmt|;
name|predict_edge_def
argument_list|(
name|e
argument_list|,
name|PRED_LOOP_BRANCH
argument_list|,
name|TAKEN
argument_list|)
expr_stmt|;
block|}
comment|/* Loop exit heuristics - predict an edge exiting the loop if the 	     conditional has no loop header successors as not taken.  */
if|if
condition|(
operator|!
name|header_found
condition|)
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
if|if
condition|(
name|e
operator|->
name|dest
operator|->
name|index
operator|<
literal|0
operator|||
operator|!
name|flow_bb_inside_loop_p
argument_list|(
name|loop
argument_list|,
name|e
operator|->
name|dest
argument_list|)
condition|)
name|predict_edge
argument_list|(
name|e
argument_list|,
name|PRED_LOOP_EXIT
argument_list|,
operator|(
name|REG_BR_PROB_BASE
operator|-
name|predictor_info
index|[
operator|(
name|int
operator|)
name|PRED_LOOP_EXIT
index|]
operator|.
name|hitrate
operator|)
operator|/
name|exits
argument_list|)
expr_stmt|;
block|}
comment|/* Free basic blocks from get_loop_body.  */
name|free
argument_list|(
name|bbs
argument_list|)
expr_stmt|;
block|}
comment|/* Attempt to predict conditional jumps using a number of heuristics.  */
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|rtx
name|last_insn
init|=
name|BB_END
argument_list|(
name|bb
argument_list|)
decl_stmt|;
name|rtx
name|cond
decl_stmt|,
name|earliest
decl_stmt|;
name|edge
name|e
decl_stmt|;
if|if
condition|(
operator|!
name|can_predict_insn_p
argument_list|(
name|last_insn
argument_list|)
condition|)
continue|continue;
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
block|{
comment|/* Predict early returns to be probable, as we've already taken 	     care for error returns and other are often used for fast paths 	     trought function.  */
if|if
condition|(
operator|(
name|e
operator|->
name|dest
operator|==
name|EXIT_BLOCK_PTR
operator|||
operator|(
name|e
operator|->
name|dest
operator|->
name|succ
operator|&&
operator|!
name|e
operator|->
name|dest
operator|->
name|succ
operator|->
name|succ_next
operator|&&
name|e
operator|->
name|dest
operator|->
name|succ
operator|->
name|dest
operator|==
name|EXIT_BLOCK_PTR
operator|)
operator|)
operator|&&
operator|!
name|predicted_by_p
argument_list|(
name|bb
argument_list|,
name|PRED_NULL_RETURN
argument_list|)
operator|&&
operator|!
name|predicted_by_p
argument_list|(
name|bb
argument_list|,
name|PRED_CONST_RETURN
argument_list|)
operator|&&
operator|!
name|predicted_by_p
argument_list|(
name|bb
argument_list|,
name|PRED_NEGATIVE_RETURN
argument_list|)
operator|&&
operator|!
name|last_basic_block_p
argument_list|(
name|e
operator|->
name|dest
argument_list|)
condition|)
name|predict_edge_def
argument_list|(
name|e
argument_list|,
name|PRED_EARLY_RETURN
argument_list|,
name|TAKEN
argument_list|)
expr_stmt|;
comment|/* Look for block we are guarding (ie we dominate it, 	     but it doesn't postdominate us).  */
if|if
condition|(
name|e
operator|->
name|dest
operator|!=
name|EXIT_BLOCK_PTR
operator|&&
name|e
operator|->
name|dest
operator|!=
name|bb
operator|&&
name|dominated_by_p
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|e
operator|->
name|dest
argument_list|,
name|e
operator|->
name|src
argument_list|)
operator|&&
operator|!
name|dominated_by_p
argument_list|(
name|CDI_POST_DOMINATORS
argument_list|,
name|e
operator|->
name|src
argument_list|,
name|e
operator|->
name|dest
argument_list|)
condition|)
block|{
name|rtx
name|insn
decl_stmt|;
comment|/* The call heuristic claims that a guarded function call 		 is improbable.  This is because such calls are often used 		 to signal exceptional situations such as printing error 		 messages.  */
for|for
control|(
name|insn
operator|=
name|BB_HEAD
argument_list|(
name|e
operator|->
name|dest
argument_list|)
init|;
name|insn
operator|!=
name|NEXT_INSN
argument_list|(
name|BB_END
argument_list|(
name|e
operator|->
name|dest
argument_list|)
argument_list|)
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
comment|/* Constant and pure calls are hardly used to signalize 		       something exceptional.  */
operator|&&
operator|!
name|CONST_OR_PURE_CALL_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|predict_edge_def
argument_list|(
name|e
argument_list|,
name|PRED_CALL
argument_list|,
name|NOT_TAKEN
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
name|cond
operator|=
name|get_condition
argument_list|(
name|last_insn
argument_list|,
operator|&
name|earliest
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cond
condition|)
continue|continue;
comment|/* Try "pointer heuristic." 	 A comparison ptr == 0 is predicted as false. 	 Similarly, a comparison ptr1 == ptr2 is predicted as false.  */
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|cond
argument_list|)
argument_list|)
operator|==
literal|'<'
operator|&&
operator|(
operator|(
name|REG_P
argument_list|(
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|REG_POINTER
argument_list|(
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|REG_P
argument_list|(
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|REG_POINTER
argument_list|(
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|cond
argument_list|)
operator|==
name|EQ
condition|)
name|predict_insn_def
argument_list|(
name|last_insn
argument_list|,
name|PRED_POINTER
argument_list|,
name|NOT_TAKEN
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|cond
argument_list|)
operator|==
name|NE
condition|)
name|predict_insn_def
argument_list|(
name|last_insn
argument_list|,
name|PRED_POINTER
argument_list|,
name|TAKEN
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Try "opcode heuristic." 	 EQ tests are usually false and NE tests are usually true. Also, 	 most quantities are positive, so we can make the appropriate guesses 	 about signed comparisons against zero.  */
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|cond
argument_list|)
condition|)
block|{
case|case
name|CONST_INT
case|:
comment|/* Unconditional branch.  */
name|predict_insn_def
argument_list|(
name|last_insn
argument_list|,
name|PRED_UNCONDITIONAL
argument_list|,
name|cond
operator|==
name|const0_rtx
condition|?
name|NOT_TAKEN
else|:
name|TAKEN
argument_list|)
expr_stmt|;
break|break;
case|case
name|EQ
case|:
case|case
name|UNEQ
case|:
comment|/* Floating point comparisons appears to behave in a very 	       unpredictable way because of special role of = tests in 	       FP code.  */
if|if
condition|(
name|FLOAT_MODE_P
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
empty_stmt|;
comment|/* Comparisons with 0 are often used for booleans and there is 	       nothing useful to predict about them.  */
elseif|else
if|if
condition|(
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
operator|==
name|const0_rtx
operator|||
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
operator|==
name|const0_rtx
condition|)
empty_stmt|;
else|else
name|predict_insn_def
argument_list|(
name|last_insn
argument_list|,
name|PRED_OPCODE_NONEQUAL
argument_list|,
name|NOT_TAKEN
argument_list|)
expr_stmt|;
break|break;
case|case
name|NE
case|:
case|case
name|LTGT
case|:
comment|/* Floating point comparisons appears to behave in a very 	       unpredictable way because of special role of = tests in 	       FP code.  */
if|if
condition|(
name|FLOAT_MODE_P
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
empty_stmt|;
comment|/* Comparisons with 0 are often used for booleans and there is 	       nothing useful to predict about them.  */
elseif|else
if|if
condition|(
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
operator|==
name|const0_rtx
operator|||
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
operator|==
name|const0_rtx
condition|)
empty_stmt|;
else|else
name|predict_insn_def
argument_list|(
name|last_insn
argument_list|,
name|PRED_OPCODE_NONEQUAL
argument_list|,
name|TAKEN
argument_list|)
expr_stmt|;
break|break;
case|case
name|ORDERED
case|:
name|predict_insn_def
argument_list|(
name|last_insn
argument_list|,
name|PRED_FPOPCODE
argument_list|,
name|TAKEN
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNORDERED
case|:
name|predict_insn_def
argument_list|(
name|last_insn
argument_list|,
name|PRED_FPOPCODE
argument_list|,
name|NOT_TAKEN
argument_list|)
expr_stmt|;
break|break;
case|case
name|LE
case|:
case|case
name|LT
case|:
if|if
condition|(
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
operator|==
name|const0_rtx
operator|||
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
operator|==
name|const1_rtx
operator|||
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
operator|==
name|constm1_rtx
condition|)
name|predict_insn_def
argument_list|(
name|last_insn
argument_list|,
name|PRED_OPCODE_POSITIVE
argument_list|,
name|NOT_TAKEN
argument_list|)
expr_stmt|;
break|break;
case|case
name|GE
case|:
case|case
name|GT
case|:
if|if
condition|(
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
operator|==
name|const0_rtx
operator|||
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
operator|==
name|const1_rtx
operator|||
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
operator|==
name|constm1_rtx
condition|)
name|predict_insn_def
argument_list|(
name|last_insn
argument_list|,
name|PRED_OPCODE_POSITIVE
argument_list|,
name|TAKEN
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
comment|/* Attach the combined probability to each conditional jump.  */
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|any_condjump_p
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
operator|&&
name|bb
operator|->
name|succ
operator|->
name|succ_next
operator|!=
name|NULL
condition|)
name|combine_predictions_for_insn
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|,
name|bb
argument_list|)
expr_stmt|;
name|free_dominance_info
argument_list|(
name|CDI_POST_DOMINATORS
argument_list|)
expr_stmt|;
name|remove_fake_edges
argument_list|()
expr_stmt|;
name|estimate_bb_frequencies
argument_list|(
name|loops_info
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* __builtin_expect dropped tokens into the insn stream describing expected    values of registers.  Generate branch probabilities based off these    values.  */
end_comment

begin_function
name|void
name|expected_value_to_br_prob
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|,
name|cond
decl_stmt|,
name|ev
init|=
name|NULL_RTX
decl_stmt|,
name|ev_reg
init|=
name|NULL_RTX
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
condition|)
block|{
case|case
name|NOTE
case|:
comment|/* Look for expected value notes.  */
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_EXPECTED_VALUE
condition|)
block|{
name|ev
operator|=
name|NOTE_EXPECTED_VALUE
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|ev_reg
operator|=
name|XEXP
argument_list|(
name|ev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|delete_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
continue|continue;
case|case
name|CODE_LABEL
case|:
comment|/* Never propagate across labels.  */
name|ev
operator|=
name|NULL_RTX
expr_stmt|;
continue|continue;
case|case
name|JUMP_INSN
case|:
comment|/* Look for simple conditional branches.  If we haven't got an 	     expected value yet, no point going further.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|JUMP_INSN
operator|||
name|ev
operator|==
name|NULL_RTX
operator|||
operator|!
name|any_condjump_p
argument_list|(
name|insn
argument_list|)
condition|)
continue|continue;
break|break;
default|default:
comment|/* Look for insns that clobber the EV register.  */
if|if
condition|(
name|ev
operator|&&
name|reg_set_p
argument_list|(
name|ev_reg
argument_list|,
name|insn
argument_list|)
condition|)
name|ev
operator|=
name|NULL_RTX
expr_stmt|;
continue|continue;
block|}
comment|/* Collect the branch condition, hopefully relative to EV_REG.  */
comment|/* ???  At present we'll miss things like 		(expected_value (eq r70 0)) 		(set r71 -1) 		(set r80 (lt r70 r71)) 		(set pc (if_then_else (ne r80 0) ...)) 	 as canonicalize_condition will render this to us as 		(lt r70, r71) 	 Could use cselib to try and reduce this further.  */
name|cond
operator|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|pc_set
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cond
operator|=
name|canonicalize_condition
argument_list|(
name|insn
argument_list|,
name|cond
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|ev_reg
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cond
operator|||
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
operator|!=
name|ev_reg
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
condition|)
continue|continue;
comment|/* Substitute and simplify.  Given that the expression we're 	 building involves two constants, we should wind up with either 	 true or false.  */
name|cond
operator|=
name|gen_rtx_fmt_ee
argument_list|(
name|GET_CODE
argument_list|(
name|cond
argument_list|)
argument_list|,
name|VOIDmode
argument_list|,
name|XEXP
argument_list|(
name|ev
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|cond
operator|=
name|simplify_rtx
argument_list|(
name|cond
argument_list|)
expr_stmt|;
comment|/* Turn the condition into a scaled branch probability.  */
if|if
condition|(
name|cond
operator|!=
name|const_true_rtx
operator|&&
name|cond
operator|!=
name|const0_rtx
condition|)
name|abort
argument_list|()
expr_stmt|;
name|predict_insn_def
argument_list|(
name|insn
argument_list|,
name|PRED_BUILTIN_EXPECT
argument_list|,
name|cond
operator|==
name|const_true_rtx
condition|?
name|TAKEN
else|:
name|NOT_TAKEN
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Check whether this is the last basic block of function.  Commonly    there is one extra common cleanup block.  */
end_comment

begin_function
specifier|static
name|bool
name|last_basic_block_p
parameter_list|(
name|basic_block
name|bb
parameter_list|)
block|{
if|if
condition|(
name|bb
operator|==
name|EXIT_BLOCK_PTR
condition|)
return|return
name|false
return|;
return|return
operator|(
name|bb
operator|->
name|next_bb
operator|==
name|EXIT_BLOCK_PTR
operator|||
operator|(
name|bb
operator|->
name|next_bb
operator|->
name|next_bb
operator|==
name|EXIT_BLOCK_PTR
operator|&&
name|bb
operator|->
name|succ
operator|&&
operator|!
name|bb
operator|->
name|succ
operator|->
name|succ_next
operator|&&
name|bb
operator|->
name|succ
operator|->
name|dest
operator|->
name|next_bb
operator|==
name|EXIT_BLOCK_PTR
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Sets branch probabilities according to PREDiction and    FLAGS. HEADS[bb->index] should be index of basic block in that we    need to alter branch predictions (i.e. the first of our dominators    such that we do not post-dominate it) (but we fill this information    on demand, so -1 may be there in case this was not needed yet).  */
end_comment

begin_function
specifier|static
name|void
name|process_note_prediction
parameter_list|(
name|basic_block
name|bb
parameter_list|,
name|int
modifier|*
name|heads
parameter_list|,
name|int
name|pred
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|edge
name|e
decl_stmt|;
name|int
name|y
decl_stmt|;
name|bool
name|taken
decl_stmt|;
name|taken
operator|=
name|flags
operator|&
name|IS_TAKEN
expr_stmt|;
if|if
condition|(
name|heads
index|[
name|bb
operator|->
name|index
index|]
operator|<
literal|0
condition|)
block|{
comment|/* This is first time we need this field in heads array; so          find first dominator that we do not post-dominate (we are          using already known members of heads array).  */
name|basic_block
name|ai
init|=
name|bb
decl_stmt|;
name|basic_block
name|next_ai
init|=
name|get_immediate_dominator
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|bb
argument_list|)
decl_stmt|;
name|int
name|head
decl_stmt|;
while|while
condition|(
name|heads
index|[
name|next_ai
operator|->
name|index
index|]
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|dominated_by_p
argument_list|(
name|CDI_POST_DOMINATORS
argument_list|,
name|next_ai
argument_list|,
name|bb
argument_list|)
condition|)
break|break;
name|heads
index|[
name|next_ai
operator|->
name|index
index|]
operator|=
name|ai
operator|->
name|index
expr_stmt|;
name|ai
operator|=
name|next_ai
expr_stmt|;
name|next_ai
operator|=
name|get_immediate_dominator
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|next_ai
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|dominated_by_p
argument_list|(
name|CDI_POST_DOMINATORS
argument_list|,
name|next_ai
argument_list|,
name|bb
argument_list|)
condition|)
name|head
operator|=
name|next_ai
operator|->
name|index
expr_stmt|;
else|else
name|head
operator|=
name|heads
index|[
name|next_ai
operator|->
name|index
index|]
expr_stmt|;
while|while
condition|(
name|next_ai
operator|!=
name|bb
condition|)
block|{
name|next_ai
operator|=
name|ai
expr_stmt|;
if|if
condition|(
name|heads
index|[
name|ai
operator|->
name|index
index|]
operator|==
name|ENTRY_BLOCK
condition|)
name|ai
operator|=
name|ENTRY_BLOCK_PTR
expr_stmt|;
else|else
name|ai
operator|=
name|BASIC_BLOCK
argument_list|(
name|heads
index|[
name|ai
operator|->
name|index
index|]
argument_list|)
expr_stmt|;
name|heads
index|[
name|next_ai
operator|->
name|index
index|]
operator|=
name|head
expr_stmt|;
block|}
block|}
name|y
operator|=
name|heads
index|[
name|bb
operator|->
name|index
index|]
expr_stmt|;
comment|/* Now find the edge that leads to our branch and aply the prediction.  */
if|if
condition|(
name|y
operator|==
name|last_basic_block
operator|||
operator|!
name|can_predict_insn_p
argument_list|(
name|BB_END
argument_list|(
name|BASIC_BLOCK
argument_list|(
name|y
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return;
for|for
control|(
name|e
operator|=
name|BASIC_BLOCK
argument_list|(
name|y
argument_list|)
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
if|if
condition|(
name|e
operator|->
name|dest
operator|->
name|index
operator|>=
literal|0
operator|&&
name|dominated_by_p
argument_list|(
name|CDI_POST_DOMINATORS
argument_list|,
name|e
operator|->
name|dest
argument_list|,
name|bb
argument_list|)
condition|)
name|predict_edge_def
argument_list|(
name|e
argument_list|,
name|pred
argument_list|,
name|taken
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Gathers NOTE_INSN_PREDICTIONs in given basic block and turns them    into branch probabilities.  For description of heads array, see    process_note_prediction.  */
end_comment

begin_function
specifier|static
name|void
name|process_note_predictions
parameter_list|(
name|basic_block
name|bb
parameter_list|,
name|int
modifier|*
name|heads
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
name|edge
name|e
decl_stmt|;
comment|/* Additionally, we check here for blocks with no successors.  */
name|int
name|contained_noreturn_call
init|=
literal|0
decl_stmt|;
name|int
name|was_bb_head
init|=
literal|0
decl_stmt|;
name|int
name|noreturn_block
init|=
literal|1
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|BB_END
argument_list|(
name|bb
argument_list|)
init|;
name|insn
condition|;
name|was_bb_head
operator||=
operator|(
name|insn
operator|==
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
operator|)
operator|,
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE
condition|)
block|{
if|if
condition|(
name|was_bb_head
condition|)
break|break;
else|else
block|{
comment|/* Noreturn calls cause program to exit, therefore they are 	         always predicted as not taken.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
operator|&&
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_NORETURN
argument_list|,
name|NULL
argument_list|)
condition|)
name|contained_noreturn_call
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_PREDICTION
condition|)
block|{
name|int
name|alg
init|=
operator|(
name|int
operator|)
name|NOTE_PREDICTION_ALG
argument_list|(
name|insn
argument_list|)
decl_stmt|;
comment|/* Process single prediction note.  */
name|process_note_prediction
argument_list|(
name|bb
argument_list|,
name|heads
argument_list|,
name|alg
argument_list|,
operator|(
name|int
operator|)
name|NOTE_PREDICTION_FLAGS
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|delete_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
if|if
condition|(
operator|!
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FAKE
operator|)
condition|)
name|noreturn_block
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|contained_noreturn_call
condition|)
block|{
comment|/* This block ended from other reasons than because of return.          If it is because of noreturn call, this should certainly not          be taken.  Otherwise it is probably some error recovery.  */
name|process_note_prediction
argument_list|(
name|bb
argument_list|,
name|heads
argument_list|,
name|PRED_NORETURN
argument_list|,
name|NOT_TAKEN
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Gathers NOTE_INSN_PREDICTIONs and turns them into    branch probabilities.  */
end_comment

begin_function
name|void
name|note_prediction_to_br_prob
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|int
modifier|*
name|heads
decl_stmt|;
comment|/* To enable handling of noreturn blocks.  */
name|add_noreturn_fake_exit_edges
argument_list|()
expr_stmt|;
name|connect_infinite_loops_to_exit
argument_list|()
expr_stmt|;
name|calculate_dominance_info
argument_list|(
name|CDI_POST_DOMINATORS
argument_list|)
expr_stmt|;
name|calculate_dominance_info
argument_list|(
name|CDI_DOMINATORS
argument_list|)
expr_stmt|;
name|heads
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|last_basic_block
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|heads
argument_list|,
operator|-
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|last_basic_block
argument_list|)
expr_stmt|;
name|heads
index|[
name|ENTRY_BLOCK_PTR
operator|->
name|next_bb
operator|->
name|index
index|]
operator|=
name|last_basic_block
expr_stmt|;
comment|/* Process all prediction notes.  */
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
name|process_note_predictions
argument_list|(
name|bb
argument_list|,
name|heads
argument_list|)
expr_stmt|;
name|free_dominance_info
argument_list|(
name|CDI_POST_DOMINATORS
argument_list|)
expr_stmt|;
name|free_dominance_info
argument_list|(
name|CDI_DOMINATORS
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|heads
argument_list|)
expr_stmt|;
name|remove_fake_edges
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This is used to carry information about basic blocks.  It is    attached to the AUX field of the standard CFG block.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|block_info_def
block|{
comment|/* Estimated frequency of execution of basic_block.  */
name|sreal
name|frequency
decl_stmt|;
comment|/* To keep queue of basic blocks to process.  */
name|basic_block
name|next
decl_stmt|;
comment|/* True if block needs to be visited in propagate_freq.  */
name|unsigned
name|int
name|tovisit
range|:
literal|1
decl_stmt|;
comment|/* Number of predecessors we need to visit first.  */
name|int
name|npredecessors
decl_stmt|;
block|}
typedef|*
name|block_info
typedef|;
end_typedef

begin_comment
comment|/* Similar information for edges.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|edge_info_def
block|{
comment|/* In case edge is an loopback edge, the probability edge will be reached      in case header is.  Estimated number of iterations of the loop can be      then computed as 1 / (1 - back_edge_prob).  */
name|sreal
name|back_edge_prob
decl_stmt|;
comment|/* True if the edge is an loopback edge in the natural loop.  */
name|unsigned
name|int
name|back_edge
range|:
literal|1
decl_stmt|;
block|}
typedef|*
name|edge_info
typedef|;
end_typedef

begin_define
define|#
directive|define
name|BLOCK_INFO
parameter_list|(
name|B
parameter_list|)
value|((block_info) (B)->aux)
end_define

begin_define
define|#
directive|define
name|EDGE_INFO
parameter_list|(
name|E
parameter_list|)
value|((edge_info) (E)->aux)
end_define

begin_comment
comment|/* Helper function for estimate_bb_frequencies.    Propagate the frequencies for LOOP.  */
end_comment

begin_function
specifier|static
name|void
name|propagate_freq
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|)
block|{
name|basic_block
name|head
init|=
name|loop
operator|->
name|header
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|basic_block
name|last
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|basic_block
name|nextbb
decl_stmt|;
comment|/* For each basic block we need to visit count number of his predecessors      we need to visit first.  */
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
if|if
condition|(
name|BLOCK_INFO
argument_list|(
name|bb
argument_list|)
operator|->
name|tovisit
condition|)
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|pred
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|pred_next
control|)
if|if
condition|(
name|BLOCK_INFO
argument_list|(
name|e
operator|->
name|src
argument_list|)
operator|->
name|tovisit
operator|&&
operator|!
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_DFS_BACK
operator|)
condition|)
name|count
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|BLOCK_INFO
argument_list|(
name|e
operator|->
name|src
argument_list|)
operator|->
name|tovisit
operator|&&
name|rtl_dump_file
operator|&&
operator|!
name|EDGE_INFO
argument_list|(
name|e
argument_list|)
operator|->
name|back_edge
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Irreducible region hit, ignoring edge to %i->%i\n"
argument_list|,
name|e
operator|->
name|src
operator|->
name|index
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|BLOCK_INFO
argument_list|(
name|bb
argument_list|)
operator|->
name|npredecessors
operator|=
name|count
expr_stmt|;
block|}
block|}
name|memcpy
argument_list|(
operator|&
name|BLOCK_INFO
argument_list|(
name|head
argument_list|)
operator|->
name|frequency
argument_list|,
operator|&
name|real_one
argument_list|,
sizeof|sizeof
argument_list|(
name|real_one
argument_list|)
argument_list|)
expr_stmt|;
name|last
operator|=
name|head
expr_stmt|;
for|for
control|(
name|bb
operator|=
name|head
init|;
name|bb
condition|;
name|bb
operator|=
name|nextbb
control|)
block|{
name|sreal
name|cyclic_probability
decl_stmt|,
name|frequency
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|cyclic_probability
argument_list|,
operator|&
name|real_zero
argument_list|,
sizeof|sizeof
argument_list|(
name|real_zero
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|frequency
argument_list|,
operator|&
name|real_zero
argument_list|,
sizeof|sizeof
argument_list|(
name|real_zero
argument_list|)
argument_list|)
expr_stmt|;
name|nextbb
operator|=
name|BLOCK_INFO
argument_list|(
name|bb
argument_list|)
operator|->
name|next
expr_stmt|;
name|BLOCK_INFO
argument_list|(
name|bb
argument_list|)
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
comment|/* Compute frequency of basic block.  */
if|if
condition|(
name|bb
operator|!=
name|head
condition|)
block|{
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|pred
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|pred_next
control|)
if|if
condition|(
name|BLOCK_INFO
argument_list|(
name|e
operator|->
name|src
argument_list|)
operator|->
name|tovisit
operator|&&
operator|!
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_DFS_BACK
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|pred
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|pred_next
control|)
if|if
condition|(
name|EDGE_INFO
argument_list|(
name|e
argument_list|)
operator|->
name|back_edge
condition|)
block|{
name|sreal_add
argument_list|(
operator|&
name|cyclic_probability
argument_list|,
operator|&
name|cyclic_probability
argument_list|,
operator|&
name|EDGE_INFO
argument_list|(
name|e
argument_list|)
operator|->
name|back_edge_prob
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_DFS_BACK
operator|)
condition|)
block|{
name|sreal
name|tmp
decl_stmt|;
comment|/*  frequency += (e->probability 				  * BLOCK_INFO (e->src)->frequency / 				  REG_BR_PROB_BASE);  */
name|sreal_init
argument_list|(
operator|&
name|tmp
argument_list|,
name|e
operator|->
name|probability
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sreal_mul
argument_list|(
operator|&
name|tmp
argument_list|,
operator|&
name|tmp
argument_list|,
operator|&
name|BLOCK_INFO
argument_list|(
name|e
operator|->
name|src
argument_list|)
operator|->
name|frequency
argument_list|)
expr_stmt|;
name|sreal_mul
argument_list|(
operator|&
name|tmp
argument_list|,
operator|&
name|tmp
argument_list|,
operator|&
name|real_inv_br_prob_base
argument_list|)
expr_stmt|;
name|sreal_add
argument_list|(
operator|&
name|frequency
argument_list|,
operator|&
name|frequency
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sreal_compare
argument_list|(
operator|&
name|cyclic_probability
argument_list|,
operator|&
name|real_zero
argument_list|)
operator|==
literal|0
condition|)
block|{
name|memcpy
argument_list|(
operator|&
name|BLOCK_INFO
argument_list|(
name|bb
argument_list|)
operator|->
name|frequency
argument_list|,
operator|&
name|frequency
argument_list|,
sizeof|sizeof
argument_list|(
name|frequency
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|sreal_compare
argument_list|(
operator|&
name|cyclic_probability
argument_list|,
operator|&
name|real_almost_one
argument_list|)
operator|>
literal|0
condition|)
block|{
name|memcpy
argument_list|(
operator|&
name|cyclic_probability
argument_list|,
operator|&
name|real_almost_one
argument_list|,
sizeof|sizeof
argument_list|(
name|real_almost_one
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* BLOCK_INFO (bb)->frequency = frequency 					      / (1 - cyclic_probability) */
name|sreal_sub
argument_list|(
operator|&
name|cyclic_probability
argument_list|,
operator|&
name|real_one
argument_list|,
operator|&
name|cyclic_probability
argument_list|)
expr_stmt|;
name|sreal_div
argument_list|(
operator|&
name|BLOCK_INFO
argument_list|(
name|bb
argument_list|)
operator|->
name|frequency
argument_list|,
operator|&
name|frequency
argument_list|,
operator|&
name|cyclic_probability
argument_list|)
expr_stmt|;
block|}
block|}
name|BLOCK_INFO
argument_list|(
name|bb
argument_list|)
operator|->
name|tovisit
operator|=
literal|0
expr_stmt|;
comment|/* Compute back edge frequencies.  */
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
if|if
condition|(
name|e
operator|->
name|dest
operator|==
name|head
condition|)
block|{
name|sreal
name|tmp
decl_stmt|;
comment|/* EDGE_INFO (e)->back_edge_prob 		  = ((e->probability * BLOCK_INFO (bb)->frequency) 		     / REG_BR_PROB_BASE); */
name|sreal_init
argument_list|(
operator|&
name|tmp
argument_list|,
name|e
operator|->
name|probability
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sreal_mul
argument_list|(
operator|&
name|tmp
argument_list|,
operator|&
name|tmp
argument_list|,
operator|&
name|BLOCK_INFO
argument_list|(
name|bb
argument_list|)
operator|->
name|frequency
argument_list|)
expr_stmt|;
name|sreal_mul
argument_list|(
operator|&
name|EDGE_INFO
argument_list|(
name|e
argument_list|)
operator|->
name|back_edge_prob
argument_list|,
operator|&
name|tmp
argument_list|,
operator|&
name|real_inv_br_prob_base
argument_list|)
expr_stmt|;
block|}
comment|/* Propagate to successor blocks.  */
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
if|if
condition|(
operator|!
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_DFS_BACK
operator|)
operator|&&
name|BLOCK_INFO
argument_list|(
name|e
operator|->
name|dest
argument_list|)
operator|->
name|npredecessors
condition|)
block|{
name|BLOCK_INFO
argument_list|(
name|e
operator|->
name|dest
argument_list|)
operator|->
name|npredecessors
operator|--
expr_stmt|;
if|if
condition|(
operator|!
name|BLOCK_INFO
argument_list|(
name|e
operator|->
name|dest
argument_list|)
operator|->
name|npredecessors
condition|)
block|{
if|if
condition|(
operator|!
name|nextbb
condition|)
name|nextbb
operator|=
name|e
operator|->
name|dest
expr_stmt|;
else|else
name|BLOCK_INFO
argument_list|(
name|last
argument_list|)
operator|->
name|next
operator|=
name|e
operator|->
name|dest
expr_stmt|;
name|last
operator|=
name|e
operator|->
name|dest
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Estimate probabilities of loopback edges in loops at same nest level.  */
end_comment

begin_function
specifier|static
name|void
name|estimate_loops_at_level
parameter_list|(
name|struct
name|loop
modifier|*
name|first_loop
parameter_list|)
block|{
name|struct
name|loop
modifier|*
name|loop
decl_stmt|;
for|for
control|(
name|loop
operator|=
name|first_loop
init|;
name|loop
condition|;
name|loop
operator|=
name|loop
operator|->
name|next
control|)
block|{
name|edge
name|e
decl_stmt|;
name|basic_block
modifier|*
name|bbs
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|estimate_loops_at_level
argument_list|(
name|loop
operator|->
name|inner
argument_list|)
expr_stmt|;
if|if
condition|(
name|loop
operator|->
name|latch
operator|->
name|succ
condition|)
comment|/* Do not do this for dummy function loop.  */
block|{
comment|/* Find current loop back edge and mark it.  */
name|e
operator|=
name|loop_latch_edge
argument_list|(
name|loop
argument_list|)
expr_stmt|;
name|EDGE_INFO
argument_list|(
name|e
argument_list|)
operator|->
name|back_edge
operator|=
literal|1
expr_stmt|;
block|}
name|bbs
operator|=
name|get_loop_body
argument_list|(
name|loop
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|loop
operator|->
name|num_nodes
condition|;
name|i
operator|++
control|)
name|BLOCK_INFO
argument_list|(
name|bbs
index|[
name|i
index|]
argument_list|)
operator|->
name|tovisit
operator|=
literal|1
expr_stmt|;
name|free
argument_list|(
name|bbs
argument_list|)
expr_stmt|;
name|propagate_freq
argument_list|(
name|loop
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Convert counts measured by profile driven feedback to frequencies.  */
end_comment

begin_function
specifier|static
name|void
name|counts_to_freqs
parameter_list|(
name|void
parameter_list|)
block|{
name|gcov_type
name|count_max
init|=
literal|1
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
name|count_max
operator|=
name|MAX
argument_list|(
name|bb
operator|->
name|count
argument_list|,
name|count_max
argument_list|)
expr_stmt|;
name|FOR_BB_BETWEEN
argument_list|(
argument|bb
argument_list|,
argument|ENTRY_BLOCK_PTR
argument_list|,
argument|NULL
argument_list|,
argument|next_bb
argument_list|)
name|bb
operator|->
name|frequency
operator|=
operator|(
name|bb
operator|->
name|count
operator|*
name|BB_FREQ_MAX
operator|+
name|count_max
operator|/
literal|2
operator|)
operator|/
name|count_max
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return true if function is likely to be expensive, so there is no point to    optimize performance of prologue, epilogue or do inlining at the expense    of code size growth.  THRESHOLD is the limit of number of instructions    function can execute at average to be still considered not expensive.  */
end_comment

begin_function
name|bool
name|expensive_function_p
parameter_list|(
name|int
name|threshold
parameter_list|)
block|{
name|unsigned
name|int
name|sum
init|=
literal|0
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|unsigned
name|int
name|limit
decl_stmt|;
comment|/* We can not compute accurately for large thresholds due to scaled      frequencies.  */
if|if
condition|(
name|threshold
operator|>
name|BB_FREQ_MAX
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Frequencies are out of range.  This either means that function contains      internal loop executing more than BB_FREQ_MAX times or profile feedback      is available and function has not been executed at all.  */
if|if
condition|(
name|ENTRY_BLOCK_PTR
operator|->
name|frequency
operator|==
literal|0
condition|)
return|return
name|true
return|;
comment|/* Maximally BB_FREQ_MAX^2 so overflow won't happen.  */
name|limit
operator|=
name|ENTRY_BLOCK_PTR
operator|->
name|frequency
operator|*
name|threshold
expr_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|rtx
name|insn
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
init|;
name|insn
operator|!=
name|NEXT_INSN
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|active_insn_p
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|sum
operator|+=
name|bb
operator|->
name|frequency
expr_stmt|;
if|if
condition|(
name|sum
operator|>
name|limit
condition|)
return|return
name|true
return|;
block|}
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Estimate basic blocks frequency by given branch probabilities.  */
end_comment

begin_function
specifier|static
name|void
name|estimate_bb_frequencies
parameter_list|(
name|struct
name|loops
modifier|*
name|loops
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|sreal
name|freq_max
decl_stmt|;
if|if
condition|(
name|flag_branch_probabilities
condition|)
name|counts_to_freqs
argument_list|()
expr_stmt|;
else|else
block|{
specifier|static
name|int
name|real_values_initialized
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|real_values_initialized
condition|)
block|{
name|real_values_initialized
operator|=
literal|1
expr_stmt|;
name|sreal_init
argument_list|(
operator|&
name|real_zero
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sreal_init
argument_list|(
operator|&
name|real_one
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sreal_init
argument_list|(
operator|&
name|real_br_prob_base
argument_list|,
name|REG_BR_PROB_BASE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sreal_init
argument_list|(
operator|&
name|real_bb_freq_max
argument_list|,
name|BB_FREQ_MAX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sreal_init
argument_list|(
operator|&
name|real_one_half
argument_list|,
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|sreal_div
argument_list|(
operator|&
name|real_inv_br_prob_base
argument_list|,
operator|&
name|real_one
argument_list|,
operator|&
name|real_br_prob_base
argument_list|)
expr_stmt|;
name|sreal_sub
argument_list|(
operator|&
name|real_almost_one
argument_list|,
operator|&
name|real_one
argument_list|,
operator|&
name|real_inv_br_prob_base
argument_list|)
expr_stmt|;
block|}
name|mark_dfs_back_edges
argument_list|()
expr_stmt|;
comment|/* Fill in the probability values in flowgraph based on the REG_BR_PROB          notes.  */
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|rtx
name|last_insn
init|=
name|BB_END
argument_list|(
name|bb
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|can_predict_insn_p
argument_list|(
name|last_insn
argument_list|)
condition|)
block|{
comment|/* We can predict only conditional jumps at the moment. 	         Expect each edge to be equally probable. 	         ?? In the future we want to make abnormal edges improbable.  */
name|int
name|nedges
init|=
literal|0
decl_stmt|;
name|edge
name|e
decl_stmt|;
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
block|{
name|nedges
operator|++
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|probability
operator|!=
literal|0
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|e
condition|)
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
name|e
operator|->
name|probability
operator|=
operator|(
name|REG_BR_PROB_BASE
operator|+
name|nedges
operator|/
literal|2
operator|)
operator|/
name|nedges
expr_stmt|;
block|}
block|}
name|ENTRY_BLOCK_PTR
operator|->
name|succ
operator|->
name|probability
operator|=
name|REG_BR_PROB_BASE
expr_stmt|;
comment|/* Set up block info for each basic block.  */
name|alloc_aux_for_blocks
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|block_info_def
argument_list|)
argument_list|)
expr_stmt|;
name|alloc_aux_for_edges
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|edge_info_def
argument_list|)
argument_list|)
expr_stmt|;
name|FOR_BB_BETWEEN
argument_list|(
argument|bb
argument_list|,
argument|ENTRY_BLOCK_PTR
argument_list|,
argument|NULL
argument_list|,
argument|next_bb
argument_list|)
block|{
name|edge
name|e
decl_stmt|;
name|BLOCK_INFO
argument_list|(
name|bb
argument_list|)
operator|->
name|tovisit
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
block|{
name|sreal_init
argument_list|(
operator|&
name|EDGE_INFO
argument_list|(
name|e
argument_list|)
operator|->
name|back_edge_prob
argument_list|,
name|e
operator|->
name|probability
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sreal_mul
argument_list|(
operator|&
name|EDGE_INFO
argument_list|(
name|e
argument_list|)
operator|->
name|back_edge_prob
argument_list|,
operator|&
name|EDGE_INFO
argument_list|(
name|e
argument_list|)
operator|->
name|back_edge_prob
argument_list|,
operator|&
name|real_inv_br_prob_base
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* First compute probabilities locally for each loop from innermost          to outermost to examine probabilities for back edges.  */
name|estimate_loops_at_level
argument_list|(
name|loops
operator|->
name|tree_root
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|freq_max
argument_list|,
operator|&
name|real_zero
argument_list|,
sizeof|sizeof
argument_list|(
name|real_zero
argument_list|)
argument_list|)
expr_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
if|if
condition|(
name|sreal_compare
argument_list|(
operator|&
name|freq_max
argument_list|,
operator|&
name|BLOCK_INFO
argument_list|(
name|bb
argument_list|)
operator|->
name|frequency
argument_list|)
operator|<
literal|0
condition|)
name|memcpy
argument_list|(
operator|&
name|freq_max
argument_list|,
operator|&
name|BLOCK_INFO
argument_list|(
name|bb
argument_list|)
operator|->
name|frequency
argument_list|,
sizeof|sizeof
argument_list|(
name|freq_max
argument_list|)
argument_list|)
expr_stmt|;
name|sreal_div
argument_list|(
operator|&
name|freq_max
argument_list|,
operator|&
name|real_bb_freq_max
argument_list|,
operator|&
name|freq_max
argument_list|)
expr_stmt|;
name|FOR_BB_BETWEEN
argument_list|(
argument|bb
argument_list|,
argument|ENTRY_BLOCK_PTR
argument_list|,
argument|NULL
argument_list|,
argument|next_bb
argument_list|)
block|{
name|sreal
name|tmp
decl_stmt|;
name|sreal_mul
argument_list|(
operator|&
name|tmp
argument_list|,
operator|&
name|BLOCK_INFO
argument_list|(
name|bb
argument_list|)
operator|->
name|frequency
argument_list|,
operator|&
name|freq_max
argument_list|)
expr_stmt|;
name|sreal_add
argument_list|(
operator|&
name|tmp
argument_list|,
operator|&
name|tmp
argument_list|,
operator|&
name|real_one_half
argument_list|)
expr_stmt|;
name|bb
operator|->
name|frequency
operator|=
name|sreal_to_int
argument_list|(
operator|&
name|tmp
argument_list|)
expr_stmt|;
block|}
name|free_aux_for_blocks
argument_list|()
expr_stmt|;
name|free_aux_for_edges
argument_list|()
expr_stmt|;
block|}
name|compute_function_frequency
argument_list|()
expr_stmt|;
if|if
condition|(
name|flag_reorder_functions
condition|)
name|choose_function_section
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Decide whether function is hot, cold or unlikely executed.  */
end_comment

begin_function
specifier|static
name|void
name|compute_function_frequency
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
if|if
condition|(
operator|!
name|profile_info
operator|||
operator|!
name|flag_branch_probabilities
condition|)
return|return;
name|cfun
operator|->
name|function_frequency
operator|=
name|FUNCTION_FREQUENCY_UNLIKELY_EXECUTED
expr_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
if|if
condition|(
name|maybe_hot_bb_p
argument_list|(
name|bb
argument_list|)
condition|)
block|{
name|cfun
operator|->
name|function_frequency
operator|=
name|FUNCTION_FREQUENCY_HOT
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|probably_never_executed_bb_p
argument_list|(
name|bb
argument_list|)
condition|)
name|cfun
operator|->
name|function_frequency
operator|=
name|FUNCTION_FREQUENCY_NORMAL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Choose appropriate section for the function.  */
end_comment

begin_function
specifier|static
name|void
name|choose_function_section
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|DECL_SECTION_NAME
argument_list|(
name|current_function_decl
argument_list|)
operator|||
operator|!
name|targetm
operator|.
name|have_named_sections
comment|/* Theoretically we can split the gnu.linkonce text section too, 	 but this requires more work as the frequency needs to match 	 for all generated objects so we need to merge the frequency 	 of all instances.  For now just never set frequency for these.  */
operator|||
name|DECL_ONE_ONLY
argument_list|(
name|current_function_decl
argument_list|)
condition|)
return|return;
if|if
condition|(
name|cfun
operator|->
name|function_frequency
operator|==
name|FUNCTION_FREQUENCY_HOT
condition|)
name|DECL_SECTION_NAME
argument_list|(
name|current_function_decl
argument_list|)
operator|=
name|build_string
argument_list|(
name|strlen
argument_list|(
name|HOT_TEXT_SECTION_NAME
argument_list|)
argument_list|,
name|HOT_TEXT_SECTION_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfun
operator|->
name|function_frequency
operator|==
name|FUNCTION_FREQUENCY_UNLIKELY_EXECUTED
condition|)
name|DECL_SECTION_NAME
argument_list|(
name|current_function_decl
argument_list|)
operator|=
name|build_string
argument_list|(
name|strlen
argument_list|(
name|UNLIKELY_EXECUTED_TEXT_SECTION_NAME
argument_list|)
argument_list|,
name|UNLIKELY_EXECUTED_TEXT_SECTION_NAME
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

