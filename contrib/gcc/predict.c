begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Branch prediction routines for the GNU compiler.    Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005    Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* References:     [1] "Branch Prediction for Free"        Ball and Larus; PLDI '93.    [2] "Static Branch Frequency and Program Profile Analysis"        Wu and Larus; MICRO-27.    [3] "Corpus-based Static Branch Prediction"        Calder, Grunwald, Lindsay, Martin, Mozer, and Zorn; PLDI '95.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"predict.h"
end_include

begin_include
include|#
directive|include
file|"coverage.h"
end_include

begin_include
include|#
directive|include
file|"sreal.h"
end_include

begin_include
include|#
directive|include
file|"params.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"cfgloop.h"
end_include

begin_include
include|#
directive|include
file|"tree-flow.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"tree-dump.h"
end_include

begin_include
include|#
directive|include
file|"tree-pass.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"tree-scalar-evolution.h"
end_include

begin_include
include|#
directive|include
file|"cfgloop.h"
end_include

begin_comment
comment|/* real constants: 0, 1, 1-1/REG_BR_PROB_BASE, REG_BR_PROB_BASE, 		   1/REG_BR_PROB_BASE, 0.5, BB_FREQ_MAX.  */
end_comment

begin_decl_stmt
specifier|static
name|sreal
name|real_zero
decl_stmt|,
name|real_one
decl_stmt|,
name|real_almost_one
decl_stmt|,
name|real_br_prob_base
decl_stmt|,
name|real_inv_br_prob_base
decl_stmt|,
name|real_one_half
decl_stmt|,
name|real_bb_freq_max
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Random guesstimation given names.  */
end_comment

begin_define
define|#
directive|define
name|PROB_VERY_UNLIKELY
value|(REG_BR_PROB_BASE / 100 - 1)
end_define

begin_define
define|#
directive|define
name|PROB_EVEN
value|(REG_BR_PROB_BASE / 2)
end_define

begin_define
define|#
directive|define
name|PROB_VERY_LIKELY
value|(REG_BR_PROB_BASE - PROB_VERY_UNLIKELY)
end_define

begin_define
define|#
directive|define
name|PROB_ALWAYS
value|(REG_BR_PROB_BASE)
end_define

begin_function_decl
specifier|static
name|void
name|combine_predictions_for_insn
parameter_list|(
name|rtx
parameter_list|,
name|basic_block
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_prediction
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|enum
name|br_predictor
parameter_list|,
name|int
parameter_list|,
name|basic_block
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|estimate_loops_at_level
parameter_list|(
name|struct
name|loop
modifier|*
parameter_list|,
name|bitmap
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|propagate_freq
parameter_list|(
name|struct
name|loop
modifier|*
parameter_list|,
name|bitmap
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|estimate_bb_frequencies
parameter_list|(
name|struct
name|loops
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|predict_paths_leading_to
parameter_list|(
name|basic_block
parameter_list|,
name|int
modifier|*
parameter_list|,
name|enum
name|br_predictor
parameter_list|,
name|enum
name|prediction
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|last_basic_block_p
parameter_list|(
name|basic_block
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|compute_function_frequency
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|choose_function_section
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|can_predict_insn_p
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Information we hold about each branch predictor.    Filled using information from predict.def.  */
end_comment

begin_struct
struct|struct
name|predictor_info
block|{
specifier|const
name|char
modifier|*
specifier|const
name|name
decl_stmt|;
comment|/* Name used in the debugging dumps.  */
specifier|const
name|int
name|hitrate
decl_stmt|;
comment|/* Expected hitrate used by 				   predict_insn_def call.  */
specifier|const
name|int
name|flags
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Use given predictor without Dempster-Shaffer theory if it matches    using first_match heuristics.  */
end_comment

begin_define
define|#
directive|define
name|PRED_FLAG_FIRST_MATCH
value|1
end_define

begin_comment
comment|/* Recompute hitrate in percent to our representation.  */
end_comment

begin_define
define|#
directive|define
name|HITRATE
parameter_list|(
name|VAL
parameter_list|)
value|((int) ((VAL) * REG_BR_PROB_BASE + 50) / 100)
end_define

begin_define
define|#
directive|define
name|DEF_PREDICTOR
parameter_list|(
name|ENUM
parameter_list|,
name|NAME
parameter_list|,
name|HITRATE
parameter_list|,
name|FLAGS
parameter_list|)
value|{NAME, HITRATE, FLAGS},
end_define

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|predictor_info
name|predictor_info
index|[]
init|=
block|{
include|#
directive|include
file|"predict.def"
comment|/* Upper bound on predictors.  */
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|DEF_PREDICTOR
end_undef

begin_comment
comment|/* Return true in case BB can be CPU intensive and should be optimized    for maximal performance.  */
end_comment

begin_function
name|bool
name|maybe_hot_bb_p
parameter_list|(
name|basic_block
name|bb
parameter_list|)
block|{
if|if
condition|(
name|profile_info
operator|&&
name|flag_branch_probabilities
operator|&&
operator|(
name|bb
operator|->
name|count
operator|<
name|profile_info
operator|->
name|sum_max
operator|/
name|PARAM_VALUE
argument_list|(
name|HOT_BB_COUNT_FRACTION
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|bb
operator|->
name|frequency
operator|<
name|BB_FREQ_MAX
operator|/
name|PARAM_VALUE
argument_list|(
name|HOT_BB_FREQUENCY_FRACTION
argument_list|)
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Return true in case BB is cold and should be optimized for size.  */
end_comment

begin_function
name|bool
name|probably_cold_bb_p
parameter_list|(
name|basic_block
name|bb
parameter_list|)
block|{
if|if
condition|(
name|profile_info
operator|&&
name|flag_branch_probabilities
operator|&&
operator|(
name|bb
operator|->
name|count
operator|<
name|profile_info
operator|->
name|sum_max
operator|/
name|PARAM_VALUE
argument_list|(
name|HOT_BB_COUNT_FRACTION
argument_list|)
operator|)
condition|)
return|return
name|true
return|;
if|if
condition|(
name|bb
operator|->
name|frequency
operator|<
name|BB_FREQ_MAX
operator|/
name|PARAM_VALUE
argument_list|(
name|HOT_BB_FREQUENCY_FRACTION
argument_list|)
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Return true in case BB is probably never executed.  */
end_comment

begin_function
name|bool
name|probably_never_executed_bb_p
parameter_list|(
name|basic_block
name|bb
parameter_list|)
block|{
if|if
condition|(
name|profile_info
operator|&&
name|flag_branch_probabilities
condition|)
return|return
operator|(
operator|(
name|bb
operator|->
name|count
operator|+
name|profile_info
operator|->
name|runs
operator|/
literal|2
operator|)
operator|/
name|profile_info
operator|->
name|runs
operator|)
operator|==
literal|0
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Return true if the one of outgoing edges is already predicted by    PREDICTOR.  */
end_comment

begin_function
name|bool
name|rtl_predicted_by_p
parameter_list|(
name|basic_block
name|bb
parameter_list|,
name|enum
name|br_predictor
name|predictor
parameter_list|)
block|{
name|rtx
name|note
decl_stmt|;
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
for|for
control|(
name|note
operator|=
name|REG_NOTES
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
init|;
name|note
condition|;
name|note
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
operator|==
name|REG_BR_PRED
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
operator|(
name|int
operator|)
name|predictor
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Return true if the one of outgoing edges is already predicted by    PREDICTOR.  */
end_comment

begin_function
name|bool
name|tree_predicted_by_p
parameter_list|(
name|basic_block
name|bb
parameter_list|,
name|enum
name|br_predictor
name|predictor
parameter_list|)
block|{
name|struct
name|edge_prediction
modifier|*
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|bb
operator|->
name|predictions
init|;
name|i
condition|;
name|i
operator|=
name|i
operator|->
name|ep_next
control|)
if|if
condition|(
name|i
operator|->
name|ep_predictor
operator|==
name|predictor
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Return true when the probability of edge is reliable.       The profile guessing code is good at predicting branch outcome (ie.    taken/not taken), that is predicted right slightly over 75% of time.    It is however notoriously poor on predicting the probability itself.    In general the profile appear a lot flatter (with probabilities closer    to 50%) than the reality so it is bad idea to use it to drive optimization    such as those disabling dynamic branch prediction for well predictable    branches.     There are two exceptions - edges leading to noreturn edges and edges    predicted by number of iterations heuristics are predicted well.  This macro    should be able to distinguish those, but at the moment it simply check for    noreturn heuristic that is only one giving probability over 99% or bellow    1%.  In future we might want to propagate reliability information across the    CFG if we find this information useful on multiple places.   */
end_comment

begin_function
specifier|static
name|bool
name|probability_reliable_p
parameter_list|(
name|int
name|prob
parameter_list|)
block|{
return|return
operator|(
name|profile_status
operator|==
name|PROFILE_READ
operator|||
operator|(
name|profile_status
operator|==
name|PROFILE_GUESSED
operator|&&
operator|(
name|prob
operator|<=
name|HITRATE
argument_list|(
literal|1
argument_list|)
operator|||
name|prob
operator|>=
name|HITRATE
argument_list|(
literal|99
argument_list|)
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Same predicate as above, working on edges.  */
end_comment

begin_function
name|bool
name|edge_probability_reliable_p
parameter_list|(
name|edge
name|e
parameter_list|)
block|{
return|return
name|probability_reliable_p
argument_list|(
name|e
operator|->
name|probability
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Same predicate as edge_probability_reliable_p, working on notes.  */
end_comment

begin_function
name|bool
name|br_prob_note_reliable_p
parameter_list|(
name|rtx
name|note
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
operator|==
name|REG_BR_PROB
argument_list|)
expr_stmt|;
return|return
name|probability_reliable_p
argument_list|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|predict_insn
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|enum
name|br_predictor
name|predictor
parameter_list|,
name|int
name|probability
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|any_condjump_p
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|flag_guess_branch_prob
condition|)
return|return;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_BR_PRED
argument_list|,
name|gen_rtx_CONCAT
argument_list|(
name|VOIDmode
argument_list|,
name|GEN_INT
argument_list|(
operator|(
name|int
operator|)
name|predictor
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
operator|(
name|int
operator|)
name|probability
argument_list|)
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Predict insn by given predictor.  */
end_comment

begin_function
name|void
name|predict_insn_def
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|enum
name|br_predictor
name|predictor
parameter_list|,
name|enum
name|prediction
name|taken
parameter_list|)
block|{
name|int
name|probability
init|=
name|predictor_info
index|[
operator|(
name|int
operator|)
name|predictor
index|]
operator|.
name|hitrate
decl_stmt|;
if|if
condition|(
name|taken
operator|!=
name|TAKEN
condition|)
name|probability
operator|=
name|REG_BR_PROB_BASE
operator|-
name|probability
expr_stmt|;
name|predict_insn
argument_list|(
name|insn
argument_list|,
name|predictor
argument_list|,
name|probability
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Predict edge E with given probability if possible.  */
end_comment

begin_function
name|void
name|rtl_predict_edge
parameter_list|(
name|edge
name|e
parameter_list|,
name|enum
name|br_predictor
name|predictor
parameter_list|,
name|int
name|probability
parameter_list|)
block|{
name|rtx
name|last_insn
decl_stmt|;
name|last_insn
operator|=
name|BB_END
argument_list|(
name|e
operator|->
name|src
argument_list|)
expr_stmt|;
comment|/* We can store the branch prediction information only about      conditional jumps.  */
if|if
condition|(
operator|!
name|any_condjump_p
argument_list|(
name|last_insn
argument_list|)
condition|)
return|return;
comment|/* We always store probability of branching.  */
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
condition|)
name|probability
operator|=
name|REG_BR_PROB_BASE
operator|-
name|probability
expr_stmt|;
name|predict_insn
argument_list|(
name|last_insn
argument_list|,
name|predictor
argument_list|,
name|probability
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Predict edge E with the given PROBABILITY.  */
end_comment

begin_function
name|void
name|tree_predict_edge
parameter_list|(
name|edge
name|e
parameter_list|,
name|enum
name|br_predictor
name|predictor
parameter_list|,
name|int
name|probability
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|profile_status
operator|!=
name|PROFILE_GUESSED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|e
operator|->
name|src
operator|!=
name|ENTRY_BLOCK_PTR
operator|&&
name|EDGE_COUNT
argument_list|(
name|e
operator|->
name|src
operator|->
name|succs
argument_list|)
operator|>
literal|1
operator|)
operator|&&
name|flag_guess_branch_prob
operator|&&
name|optimize
condition|)
block|{
name|struct
name|edge_prediction
modifier|*
name|i
init|=
name|ggc_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|edge_prediction
argument_list|)
argument_list|)
decl_stmt|;
name|i
operator|->
name|ep_next
operator|=
name|e
operator|->
name|src
operator|->
name|predictions
expr_stmt|;
name|e
operator|->
name|src
operator|->
name|predictions
operator|=
name|i
expr_stmt|;
name|i
operator|->
name|ep_probability
operator|=
name|probability
expr_stmt|;
name|i
operator|->
name|ep_predictor
operator|=
name|predictor
expr_stmt|;
name|i
operator|->
name|ep_edge
operator|=
name|e
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Remove all predictions on given basic block that are attached    to edge E.  */
end_comment

begin_function
name|void
name|remove_predictions_associated_with_edge
parameter_list|(
name|edge
name|e
parameter_list|)
block|{
if|if
condition|(
name|e
operator|->
name|src
operator|->
name|predictions
condition|)
block|{
name|struct
name|edge_prediction
modifier|*
modifier|*
name|prediction
init|=
operator|&
name|e
operator|->
name|src
operator|->
name|predictions
decl_stmt|;
while|while
condition|(
operator|*
name|prediction
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|prediction
operator|)
operator|->
name|ep_edge
operator|==
name|e
condition|)
operator|*
name|prediction
operator|=
operator|(
operator|*
name|prediction
operator|)
operator|->
name|ep_next
expr_stmt|;
else|else
name|prediction
operator|=
operator|&
operator|(
operator|(
operator|*
name|prediction
operator|)
operator|->
name|ep_next
operator|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Return true when we can store prediction on insn INSN.    At the moment we represent predictions only on conditional    jumps, not at computed jump or other complicated cases.  */
end_comment

begin_function
specifier|static
name|bool
name|can_predict_insn_p
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
return|return
operator|(
name|JUMP_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|any_condjump_p
argument_list|(
name|insn
argument_list|)
operator|&&
name|EDGE_COUNT
argument_list|(
name|BLOCK_FOR_INSN
argument_list|(
name|insn
argument_list|)
operator|->
name|succs
argument_list|)
operator|>=
literal|2
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Predict edge E by given predictor if possible.  */
end_comment

begin_function
name|void
name|predict_edge_def
parameter_list|(
name|edge
name|e
parameter_list|,
name|enum
name|br_predictor
name|predictor
parameter_list|,
name|enum
name|prediction
name|taken
parameter_list|)
block|{
name|int
name|probability
init|=
name|predictor_info
index|[
operator|(
name|int
operator|)
name|predictor
index|]
operator|.
name|hitrate
decl_stmt|;
if|if
condition|(
name|taken
operator|!=
name|TAKEN
condition|)
name|probability
operator|=
name|REG_BR_PROB_BASE
operator|-
name|probability
expr_stmt|;
name|predict_edge
argument_list|(
name|e
argument_list|,
name|predictor
argument_list|,
name|probability
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Invert all branch predictions or probability notes in the INSN.  This needs    to be done each time we invert the condition used by the jump.  */
end_comment

begin_function
name|void
name|invert_br_probabilities
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|rtx
name|note
decl_stmt|;
for|for
control|(
name|note
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|note
condition|;
name|note
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
operator|==
name|REG_BR_PROB
condition|)
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
operator|=
name|GEN_INT
argument_list|(
name|REG_BR_PROB_BASE
operator|-
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
operator|==
name|REG_BR_PRED
condition|)
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|=
name|GEN_INT
argument_list|(
name|REG_BR_PROB_BASE
operator|-
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dump information about the branch prediction to the output file.  */
end_comment

begin_function
specifier|static
name|void
name|dump_prediction
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|enum
name|br_predictor
name|predictor
parameter_list|,
name|int
name|probability
parameter_list|,
name|basic_block
name|bb
parameter_list|,
name|int
name|used
parameter_list|)
block|{
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
if|if
condition|(
operator|!
name|file
condition|)
return|return;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
if|if
condition|(
operator|!
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
operator|)
condition|)
break|break;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"  %s heuristics%s: %.1f%%"
argument_list|,
name|predictor_info
index|[
name|predictor
index|]
operator|.
name|name
argument_list|,
name|used
condition|?
literal|""
else|:
literal|" (ignored)"
argument_list|,
name|probability
operator|*
literal|100.0
operator|/
name|REG_BR_PROB_BASE
argument_list|)
expr_stmt|;
if|if
condition|(
name|bb
operator|->
name|count
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"  exec "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDEST_INT_PRINT_DEC
argument_list|,
name|bb
operator|->
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" hit "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDEST_INT_PRINT_DEC
argument_list|,
name|e
operator|->
name|count
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" (%.1f%%)"
argument_list|,
name|e
operator|->
name|count
operator|*
literal|100.0
operator|/
name|bb
operator|->
name|count
argument_list|)
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* We can not predict the probabilities of outgoing edges of bb.  Set them    evenly and hope for the best.  */
end_comment

begin_function
specifier|static
name|void
name|set_even_probabilities
parameter_list|(
name|basic_block
name|bb
parameter_list|)
block|{
name|int
name|nedges
init|=
literal|0
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
if|if
condition|(
operator|!
operator|(
name|e
operator|->
name|flags
operator|&
operator|(
name|EDGE_EH
operator||
name|EDGE_FAKE
operator|)
operator|)
condition|)
name|nedges
operator|++
expr_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
if|if
condition|(
operator|!
operator|(
name|e
operator|->
name|flags
operator|&
operator|(
name|EDGE_EH
operator||
name|EDGE_FAKE
operator|)
operator|)
condition|)
name|e
operator|->
name|probability
operator|=
operator|(
name|REG_BR_PROB_BASE
operator|+
name|nedges
operator|/
literal|2
operator|)
operator|/
name|nedges
expr_stmt|;
else|else
name|e
operator|->
name|probability
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Combine all REG_BR_PRED notes into single probability and attach REG_BR_PROB    note if not already present.  Remove now useless REG_BR_PRED notes.  */
end_comment

begin_function
specifier|static
name|void
name|combine_predictions_for_insn
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|basic_block
name|bb
parameter_list|)
block|{
name|rtx
name|prob_note
decl_stmt|;
name|rtx
modifier|*
name|pnote
decl_stmt|;
name|rtx
name|note
decl_stmt|;
name|int
name|best_probability
init|=
name|PROB_EVEN
decl_stmt|;
name|int
name|best_predictor
init|=
name|END_PREDICTORS
decl_stmt|;
name|int
name|combined_probability
init|=
name|REG_BR_PROB_BASE
operator|/
literal|2
decl_stmt|;
name|int
name|d
decl_stmt|;
name|bool
name|first_match
init|=
name|false
decl_stmt|;
name|bool
name|found
init|=
name|false
decl_stmt|;
if|if
condition|(
operator|!
name|can_predict_insn_p
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|set_even_probabilities
argument_list|(
name|bb
argument_list|)
expr_stmt|;
return|return;
block|}
name|prob_note
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_BR_PROB
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pnote
operator|=
operator|&
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Predictions for insn %i bb %i\n"
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
comment|/* We implement "first match" heuristics and use probability guessed      by predictor with smallest index.  */
for|for
control|(
name|note
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|note
condition|;
name|note
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
operator|==
name|REG_BR_PRED
condition|)
block|{
name|int
name|predictor
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|probability
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|found
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|best_predictor
operator|>
name|predictor
condition|)
name|best_probability
operator|=
name|probability
operator|,
name|best_predictor
operator|=
name|predictor
expr_stmt|;
name|d
operator|=
operator|(
name|combined_probability
operator|*
name|probability
operator|+
operator|(
name|REG_BR_PROB_BASE
operator|-
name|combined_probability
operator|)
operator|*
operator|(
name|REG_BR_PROB_BASE
operator|-
name|probability
operator|)
operator|)
expr_stmt|;
comment|/* Use FP math to avoid overflows of 32bit integers.  */
if|if
condition|(
name|d
operator|==
literal|0
condition|)
comment|/* If one probability is 0% and one 100%, avoid division by zero.  */
name|combined_probability
operator|=
name|REG_BR_PROB_BASE
operator|/
literal|2
expr_stmt|;
else|else
name|combined_probability
operator|=
operator|(
operator|(
operator|(
name|double
operator|)
name|combined_probability
operator|)
operator|*
name|probability
operator|*
name|REG_BR_PROB_BASE
operator|/
name|d
operator|+
literal|0.5
operator|)
expr_stmt|;
block|}
comment|/* Decide which heuristic to use.  In case we didn't match anything,      use no_prediction heuristic, in case we did match, use either      first match or Dempster-Shaffer theory depending on the flags.  */
if|if
condition|(
name|predictor_info
index|[
name|best_predictor
index|]
operator|.
name|flags
operator|&
name|PRED_FLAG_FIRST_MATCH
condition|)
name|first_match
operator|=
name|true
expr_stmt|;
if|if
condition|(
operator|!
name|found
condition|)
name|dump_prediction
argument_list|(
name|dump_file
argument_list|,
name|PRED_NO_PREDICTION
argument_list|,
name|combined_probability
argument_list|,
name|bb
argument_list|,
name|true
argument_list|)
expr_stmt|;
else|else
block|{
name|dump_prediction
argument_list|(
name|dump_file
argument_list|,
name|PRED_DS_THEORY
argument_list|,
name|combined_probability
argument_list|,
name|bb
argument_list|,
operator|!
name|first_match
argument_list|)
expr_stmt|;
name|dump_prediction
argument_list|(
name|dump_file
argument_list|,
name|PRED_FIRST_MATCH
argument_list|,
name|best_probability
argument_list|,
name|bb
argument_list|,
name|first_match
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|first_match
condition|)
name|combined_probability
operator|=
name|best_probability
expr_stmt|;
name|dump_prediction
argument_list|(
name|dump_file
argument_list|,
name|PRED_COMBINED
argument_list|,
name|combined_probability
argument_list|,
name|bb
argument_list|,
name|true
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|pnote
condition|)
block|{
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
operator|*
name|pnote
argument_list|)
operator|==
name|REG_BR_PRED
condition|)
block|{
name|int
name|predictor
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
operator|*
name|pnote
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|probability
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
operator|*
name|pnote
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|dump_prediction
argument_list|(
name|dump_file
argument_list|,
name|predictor
argument_list|,
name|probability
argument_list|,
name|bb
argument_list|,
operator|!
name|first_match
operator|||
name|best_predictor
operator|==
name|predictor
argument_list|)
expr_stmt|;
operator|*
name|pnote
operator|=
name|XEXP
argument_list|(
operator|*
name|pnote
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|pnote
operator|=
operator|&
name|XEXP
argument_list|(
operator|*
name|pnote
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|prob_note
condition|)
block|{
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_BR_PROB
argument_list|,
name|GEN_INT
argument_list|(
name|combined_probability
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Save the prediction into CFG in case we are seeing non-degenerated 	 conditional jump.  */
if|if
condition|(
operator|!
name|single_succ_p
argument_list|(
name|bb
argument_list|)
condition|)
block|{
name|BRANCH_EDGE
argument_list|(
name|bb
argument_list|)
operator|->
name|probability
operator|=
name|combined_probability
expr_stmt|;
name|FALLTHRU_EDGE
argument_list|(
name|bb
argument_list|)
operator|->
name|probability
operator|=
name|REG_BR_PROB_BASE
operator|-
name|combined_probability
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|single_succ_p
argument_list|(
name|bb
argument_list|)
condition|)
block|{
name|int
name|prob
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|prob_note
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|BRANCH_EDGE
argument_list|(
name|bb
argument_list|)
operator|->
name|probability
operator|=
name|prob
expr_stmt|;
name|FALLTHRU_EDGE
argument_list|(
name|bb
argument_list|)
operator|->
name|probability
operator|=
name|REG_BR_PROB_BASE
operator|-
name|prob
expr_stmt|;
block|}
else|else
name|single_succ_edge
argument_list|(
name|bb
argument_list|)
operator|->
name|probability
operator|=
name|REG_BR_PROB_BASE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Combine predictions into single probability and store them into CFG.    Remove now useless prediction entries.  */
end_comment

begin_function
specifier|static
name|void
name|combine_predictions_for_bb
parameter_list|(
name|basic_block
name|bb
parameter_list|)
block|{
name|int
name|best_probability
init|=
name|PROB_EVEN
decl_stmt|;
name|int
name|best_predictor
init|=
name|END_PREDICTORS
decl_stmt|;
name|int
name|combined_probability
init|=
name|REG_BR_PROB_BASE
operator|/
literal|2
decl_stmt|;
name|int
name|d
decl_stmt|;
name|bool
name|first_match
init|=
name|false
decl_stmt|;
name|bool
name|found
init|=
name|false
decl_stmt|;
name|struct
name|edge_prediction
modifier|*
name|pred
decl_stmt|;
name|int
name|nedges
init|=
literal|0
decl_stmt|;
name|edge
name|e
decl_stmt|,
name|first
init|=
name|NULL
decl_stmt|,
name|second
init|=
name|NULL
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
if|if
condition|(
operator|!
operator|(
name|e
operator|->
name|flags
operator|&
operator|(
name|EDGE_EH
operator||
name|EDGE_FAKE
operator|)
operator|)
condition|)
block|{
name|nedges
operator|++
expr_stmt|;
if|if
condition|(
name|first
operator|&&
operator|!
name|second
condition|)
name|second
operator|=
name|e
expr_stmt|;
if|if
condition|(
operator|!
name|first
condition|)
name|first
operator|=
name|e
expr_stmt|;
block|}
comment|/* When there is no successor or only one choice, prediction is easy.        We are lazy for now and predict only basic blocks with two outgoing      edges.  It is possible to predict generic case too, but we have to      ignore first match heuristics and do more involved combining.  Implement      this later.  */
if|if
condition|(
name|nedges
operator|!=
literal|2
condition|)
block|{
if|if
condition|(
operator|!
name|bb
operator|->
name|count
condition|)
name|set_even_probabilities
argument_list|(
name|bb
argument_list|)
expr_stmt|;
name|bb
operator|->
name|predictions
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"%i edges in bb %i predicted to even probabilities\n"
argument_list|,
name|nedges
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Predictions for bb %i\n"
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
comment|/* We implement "first match" heuristics and use probability guessed      by predictor with smallest index.  */
for|for
control|(
name|pred
operator|=
name|bb
operator|->
name|predictions
init|;
name|pred
condition|;
name|pred
operator|=
name|pred
operator|->
name|ep_next
control|)
block|{
name|int
name|predictor
init|=
name|pred
operator|->
name|ep_predictor
decl_stmt|;
name|int
name|probability
init|=
name|pred
operator|->
name|ep_probability
decl_stmt|;
if|if
condition|(
name|pred
operator|->
name|ep_edge
operator|!=
name|first
condition|)
name|probability
operator|=
name|REG_BR_PROB_BASE
operator|-
name|probability
expr_stmt|;
name|found
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|best_predictor
operator|>
name|predictor
condition|)
name|best_probability
operator|=
name|probability
operator|,
name|best_predictor
operator|=
name|predictor
expr_stmt|;
name|d
operator|=
operator|(
name|combined_probability
operator|*
name|probability
operator|+
operator|(
name|REG_BR_PROB_BASE
operator|-
name|combined_probability
operator|)
operator|*
operator|(
name|REG_BR_PROB_BASE
operator|-
name|probability
operator|)
operator|)
expr_stmt|;
comment|/* Use FP math to avoid overflows of 32bit integers.  */
if|if
condition|(
name|d
operator|==
literal|0
condition|)
comment|/* If one probability is 0% and one 100%, avoid division by zero.  */
name|combined_probability
operator|=
name|REG_BR_PROB_BASE
operator|/
literal|2
expr_stmt|;
else|else
name|combined_probability
operator|=
operator|(
operator|(
operator|(
name|double
operator|)
name|combined_probability
operator|)
operator|*
name|probability
operator|*
name|REG_BR_PROB_BASE
operator|/
name|d
operator|+
literal|0.5
operator|)
expr_stmt|;
block|}
comment|/* Decide which heuristic to use.  In case we didn't match anything,      use no_prediction heuristic, in case we did match, use either      first match or Dempster-Shaffer theory depending on the flags.  */
if|if
condition|(
name|predictor_info
index|[
name|best_predictor
index|]
operator|.
name|flags
operator|&
name|PRED_FLAG_FIRST_MATCH
condition|)
name|first_match
operator|=
name|true
expr_stmt|;
if|if
condition|(
operator|!
name|found
condition|)
name|dump_prediction
argument_list|(
name|dump_file
argument_list|,
name|PRED_NO_PREDICTION
argument_list|,
name|combined_probability
argument_list|,
name|bb
argument_list|,
name|true
argument_list|)
expr_stmt|;
else|else
block|{
name|dump_prediction
argument_list|(
name|dump_file
argument_list|,
name|PRED_DS_THEORY
argument_list|,
name|combined_probability
argument_list|,
name|bb
argument_list|,
operator|!
name|first_match
argument_list|)
expr_stmt|;
name|dump_prediction
argument_list|(
name|dump_file
argument_list|,
name|PRED_FIRST_MATCH
argument_list|,
name|best_probability
argument_list|,
name|bb
argument_list|,
name|first_match
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|first_match
condition|)
name|combined_probability
operator|=
name|best_probability
expr_stmt|;
name|dump_prediction
argument_list|(
name|dump_file
argument_list|,
name|PRED_COMBINED
argument_list|,
name|combined_probability
argument_list|,
name|bb
argument_list|,
name|true
argument_list|)
expr_stmt|;
for|for
control|(
name|pred
operator|=
name|bb
operator|->
name|predictions
init|;
name|pred
condition|;
name|pred
operator|=
name|pred
operator|->
name|ep_next
control|)
block|{
name|int
name|predictor
init|=
name|pred
operator|->
name|ep_predictor
decl_stmt|;
name|int
name|probability
init|=
name|pred
operator|->
name|ep_probability
decl_stmt|;
if|if
condition|(
name|pred
operator|->
name|ep_edge
operator|!=
name|EDGE_SUCC
argument_list|(
name|bb
argument_list|,
literal|0
argument_list|)
condition|)
name|probability
operator|=
name|REG_BR_PROB_BASE
operator|-
name|probability
expr_stmt|;
name|dump_prediction
argument_list|(
name|dump_file
argument_list|,
name|predictor
argument_list|,
name|probability
argument_list|,
name|bb
argument_list|,
operator|!
name|first_match
operator|||
name|best_predictor
operator|==
name|predictor
argument_list|)
expr_stmt|;
block|}
name|bb
operator|->
name|predictions
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|bb
operator|->
name|count
condition|)
block|{
name|first
operator|->
name|probability
operator|=
name|combined_probability
expr_stmt|;
name|second
operator|->
name|probability
operator|=
name|REG_BR_PROB_BASE
operator|-
name|combined_probability
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Predict edge probabilities by exploiting loop structure.    When RTLSIMPLELOOPS is set, attempt to count number of iterations by analyzing    RTL otherwise use tree based approach.  */
end_comment

begin_function
specifier|static
name|void
name|predict_loops
parameter_list|(
name|struct
name|loops
modifier|*
name|loops_info
parameter_list|,
name|bool
name|rtlsimpleloops
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|rtlsimpleloops
condition|)
name|scev_initialize
argument_list|(
name|loops_info
argument_list|)
expr_stmt|;
comment|/* Try to predict out blocks in a loop that are not part of a      natural loop.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|loops_info
operator|->
name|num
condition|;
name|i
operator|++
control|)
block|{
name|basic_block
name|bb
decl_stmt|,
modifier|*
name|bbs
decl_stmt|;
name|unsigned
name|j
decl_stmt|;
name|unsigned
name|n_exits
decl_stmt|;
name|struct
name|loop
modifier|*
name|loop
init|=
name|loops_info
operator|->
name|parray
index|[
name|i
index|]
decl_stmt|;
name|struct
name|niter_desc
name|desc
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|niter
decl_stmt|;
name|edge
modifier|*
name|exits
decl_stmt|;
name|exits
operator|=
name|get_loop_exit_edges
argument_list|(
name|loop
argument_list|,
operator|&
name|n_exits
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtlsimpleloops
condition|)
block|{
name|iv_analysis_loop_init
argument_list|(
name|loop
argument_list|)
expr_stmt|;
name|find_simple_exit
argument_list|(
name|loop
argument_list|,
operator|&
name|desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc
operator|.
name|simple_p
operator|&&
name|desc
operator|.
name|const_iter
condition|)
block|{
name|int
name|prob
decl_stmt|;
name|niter
operator|=
name|desc
operator|.
name|niter
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|niter
operator|==
literal|0
condition|)
comment|/* We might overflow here.  */
name|niter
operator|=
name|desc
operator|.
name|niter
expr_stmt|;
if|if
condition|(
name|niter
operator|>
operator|(
name|unsigned
name|int
operator|)
name|PARAM_VALUE
argument_list|(
name|PARAM_MAX_PREDICTED_ITERATIONS
argument_list|)
condition|)
name|niter
operator|=
name|PARAM_VALUE
argument_list|(
name|PARAM_MAX_PREDICTED_ITERATIONS
argument_list|)
expr_stmt|;
name|prob
operator|=
operator|(
name|REG_BR_PROB_BASE
operator|-
operator|(
name|REG_BR_PROB_BASE
operator|+
name|niter
operator|/
literal|2
operator|)
operator|/
name|niter
operator|)
expr_stmt|;
comment|/* Branch prediction algorithm gives 0 frequency for everything 		 after the end of loop for loop having 0 probability to finish.  */
if|if
condition|(
name|prob
operator|==
name|REG_BR_PROB_BASE
condition|)
name|prob
operator|=
name|REG_BR_PROB_BASE
operator|-
literal|1
expr_stmt|;
name|predict_edge
argument_list|(
name|desc
operator|.
name|in_edge
argument_list|,
name|PRED_LOOP_ITERATIONS
argument_list|,
name|prob
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|struct
name|tree_niter_desc
name|niter_desc
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n_exits
condition|;
name|j
operator|++
control|)
block|{
name|tree
name|niter
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|number_of_iterations_exit
argument_list|(
name|loop
argument_list|,
name|exits
index|[
name|j
index|]
argument_list|,
operator|&
name|niter_desc
argument_list|,
name|false
argument_list|)
condition|)
name|niter
operator|=
name|niter_desc
operator|.
name|niter
expr_stmt|;
if|if
condition|(
operator|!
name|niter
operator|||
name|TREE_CODE
argument_list|(
name|niter_desc
operator|.
name|niter
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
name|niter
operator|=
name|loop_niter_by_eval
argument_list|(
name|loop
argument_list|,
name|exits
index|[
name|j
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|niter
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|int
name|probability
decl_stmt|;
name|int
name|max
init|=
name|PARAM_VALUE
argument_list|(
name|PARAM_MAX_PREDICTED_ITERATIONS
argument_list|)
decl_stmt|;
if|if
condition|(
name|host_integerp
argument_list|(
name|niter
argument_list|,
literal|1
argument_list|)
operator|&&
name|tree_int_cst_lt
argument_list|(
name|niter
argument_list|,
name|build_int_cstu
argument_list|(
name|NULL_TREE
argument_list|,
name|max
operator|-
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|HOST_WIDE_INT
name|nitercst
init|=
name|tree_low_cst
argument_list|(
name|niter
argument_list|,
literal|1
argument_list|)
operator|+
literal|1
decl_stmt|;
name|probability
operator|=
operator|(
operator|(
name|REG_BR_PROB_BASE
operator|+
name|nitercst
operator|/
literal|2
operator|)
operator|/
name|nitercst
operator|)
expr_stmt|;
block|}
else|else
name|probability
operator|=
operator|(
operator|(
name|REG_BR_PROB_BASE
operator|+
name|max
operator|/
literal|2
operator|)
operator|/
name|max
operator|)
expr_stmt|;
name|predict_edge
argument_list|(
name|exits
index|[
name|j
index|]
argument_list|,
name|PRED_LOOP_ITERATIONS
argument_list|,
name|probability
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|free
argument_list|(
name|exits
argument_list|)
expr_stmt|;
name|bbs
operator|=
name|get_loop_body
argument_list|(
name|loop
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|loop
operator|->
name|num_nodes
condition|;
name|j
operator|++
control|)
block|{
name|int
name|header_found
init|=
literal|0
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|bb
operator|=
name|bbs
index|[
name|j
index|]
expr_stmt|;
comment|/* Bypass loop heuristics on continue statement.  These 	     statements construct loops via "non-loop" constructs 	     in the source language and are better to be handled 	     separately.  */
if|if
condition|(
operator|(
name|rtlsimpleloops
operator|&&
operator|!
name|can_predict_insn_p
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
operator|)
operator|||
name|predicted_by_p
argument_list|(
name|bb
argument_list|,
name|PRED_CONTINUE
argument_list|)
condition|)
continue|continue;
comment|/* Loop branch heuristics - predict an edge back to a 	     loop's head as taken.  */
if|if
condition|(
name|bb
operator|==
name|loop
operator|->
name|latch
condition|)
block|{
name|e
operator|=
name|find_edge
argument_list|(
name|loop
operator|->
name|latch
argument_list|,
name|loop
operator|->
name|header
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
condition|)
block|{
name|header_found
operator|=
literal|1
expr_stmt|;
name|predict_edge_def
argument_list|(
name|e
argument_list|,
name|PRED_LOOP_BRANCH
argument_list|,
name|TAKEN
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Loop exit heuristics - predict an edge exiting the loop if the 	     conditional has no loop header successors as not taken.  */
if|if
condition|(
operator|!
name|header_found
condition|)
block|{
comment|/* For loop with many exits we don't want to predict all exits 	         with the pretty large probability, because if all exits are 		 considered in row, the loop would be predicted to iterate 		 almost never.  The code to divide probability by number of 		 exits is very rough.  It should compute the number of exits 		 taken in each patch through function (not the overall number 		 of exits that might be a lot higher for loops with wide switch 		 statements in them) and compute n-th square root.  		 We limit the minimal probability by 2% to avoid 		 EDGE_PROBABILITY_RELIABLE from trusting the branch prediction 		 as this was causing regression in perl benchmark containing such 		 a wide loop.  */
name|int
name|probability
init|=
operator|(
operator|(
name|REG_BR_PROB_BASE
operator|-
name|predictor_info
index|[
operator|(
name|int
operator|)
name|PRED_LOOP_EXIT
index|]
operator|.
name|hitrate
operator|)
operator|/
name|n_exits
operator|)
decl_stmt|;
if|if
condition|(
name|probability
operator|<
name|HITRATE
argument_list|(
literal|2
argument_list|)
condition|)
name|probability
operator|=
name|HITRATE
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
if|if
condition|(
name|e
operator|->
name|dest
operator|->
name|index
operator|<
name|NUM_FIXED_BLOCKS
operator|||
operator|!
name|flow_bb_inside_loop_p
argument_list|(
name|loop
argument_list|,
name|e
operator|->
name|dest
argument_list|)
condition|)
name|predict_edge
argument_list|(
name|e
argument_list|,
name|PRED_LOOP_EXIT
argument_list|,
name|probability
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Free basic blocks from get_loop_body.  */
name|free
argument_list|(
name|bbs
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|rtlsimpleloops
condition|)
block|{
name|scev_finalize
argument_list|()
expr_stmt|;
name|current_loops
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Attempt to predict probabilities of BB outgoing edges using local    properties.  */
end_comment

begin_function
specifier|static
name|void
name|bb_estimate_probability_locally
parameter_list|(
name|basic_block
name|bb
parameter_list|)
block|{
name|rtx
name|last_insn
init|=
name|BB_END
argument_list|(
name|bb
argument_list|)
decl_stmt|;
name|rtx
name|cond
decl_stmt|;
if|if
condition|(
operator|!
name|can_predict_insn_p
argument_list|(
name|last_insn
argument_list|)
condition|)
return|return;
name|cond
operator|=
name|get_condition
argument_list|(
name|last_insn
argument_list|,
name|NULL
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cond
condition|)
return|return;
comment|/* Try "pointer heuristic."      A comparison ptr == 0 is predicted as false.      Similarly, a comparison ptr1 == ptr2 is predicted as false.  */
if|if
condition|(
name|COMPARISON_P
argument_list|(
name|cond
argument_list|)
operator|&&
operator|(
operator|(
name|REG_P
argument_list|(
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|REG_POINTER
argument_list|(
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|REG_P
argument_list|(
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|REG_POINTER
argument_list|(
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|cond
argument_list|)
operator|==
name|EQ
condition|)
name|predict_insn_def
argument_list|(
name|last_insn
argument_list|,
name|PRED_POINTER
argument_list|,
name|NOT_TAKEN
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|cond
argument_list|)
operator|==
name|NE
condition|)
name|predict_insn_def
argument_list|(
name|last_insn
argument_list|,
name|PRED_POINTER
argument_list|,
name|TAKEN
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Try "opcode heuristic."      EQ tests are usually false and NE tests are usually true. Also,      most quantities are positive, so we can make the appropriate guesses      about signed comparisons against zero.  */
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|cond
argument_list|)
condition|)
block|{
case|case
name|CONST_INT
case|:
comment|/* Unconditional branch.  */
name|predict_insn_def
argument_list|(
name|last_insn
argument_list|,
name|PRED_UNCONDITIONAL
argument_list|,
name|cond
operator|==
name|const0_rtx
condition|?
name|NOT_TAKEN
else|:
name|TAKEN
argument_list|)
expr_stmt|;
break|break;
case|case
name|EQ
case|:
case|case
name|UNEQ
case|:
comment|/* Floating point comparisons appears to behave in a very 	   unpredictable way because of special role of = tests in 	   FP code.  */
if|if
condition|(
name|FLOAT_MODE_P
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
empty_stmt|;
comment|/* Comparisons with 0 are often used for booleans and there is 	   nothing useful to predict about them.  */
elseif|else
if|if
condition|(
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
operator|==
name|const0_rtx
operator|||
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
operator|==
name|const0_rtx
condition|)
empty_stmt|;
else|else
name|predict_insn_def
argument_list|(
name|last_insn
argument_list|,
name|PRED_OPCODE_NONEQUAL
argument_list|,
name|NOT_TAKEN
argument_list|)
expr_stmt|;
break|break;
case|case
name|NE
case|:
case|case
name|LTGT
case|:
comment|/* Floating point comparisons appears to behave in a very 	   unpredictable way because of special role of = tests in 	   FP code.  */
if|if
condition|(
name|FLOAT_MODE_P
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
empty_stmt|;
comment|/* Comparisons with 0 are often used for booleans and there is 	   nothing useful to predict about them.  */
elseif|else
if|if
condition|(
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
operator|==
name|const0_rtx
operator|||
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
operator|==
name|const0_rtx
condition|)
empty_stmt|;
else|else
name|predict_insn_def
argument_list|(
name|last_insn
argument_list|,
name|PRED_OPCODE_NONEQUAL
argument_list|,
name|TAKEN
argument_list|)
expr_stmt|;
break|break;
case|case
name|ORDERED
case|:
name|predict_insn_def
argument_list|(
name|last_insn
argument_list|,
name|PRED_FPOPCODE
argument_list|,
name|TAKEN
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNORDERED
case|:
name|predict_insn_def
argument_list|(
name|last_insn
argument_list|,
name|PRED_FPOPCODE
argument_list|,
name|NOT_TAKEN
argument_list|)
expr_stmt|;
break|break;
case|case
name|LE
case|:
case|case
name|LT
case|:
if|if
condition|(
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
operator|==
name|const0_rtx
operator|||
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
operator|==
name|const1_rtx
operator|||
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
operator|==
name|constm1_rtx
condition|)
name|predict_insn_def
argument_list|(
name|last_insn
argument_list|,
name|PRED_OPCODE_POSITIVE
argument_list|,
name|NOT_TAKEN
argument_list|)
expr_stmt|;
break|break;
case|case
name|GE
case|:
case|case
name|GT
case|:
if|if
condition|(
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
operator|==
name|const0_rtx
operator|||
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
operator|==
name|const1_rtx
operator|||
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
operator|==
name|constm1_rtx
condition|)
name|predict_insn_def
argument_list|(
name|last_insn
argument_list|,
name|PRED_OPCODE_POSITIVE
argument_list|,
name|TAKEN
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Set edge->probability for each successor edge of BB.  */
end_comment

begin_function
name|void
name|guess_outgoing_edge_probabilities
parameter_list|(
name|basic_block
name|bb
parameter_list|)
block|{
name|bb_estimate_probability_locally
argument_list|(
name|bb
argument_list|)
expr_stmt|;
name|combine_predictions_for_insn
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|,
name|bb
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return constant EXPR will likely have at execution time, NULL if unknown.     The function is used by builtin_expect branch predictor so the evidence    must come from this construct and additional possible constant folding.       We may want to implement more involved value guess (such as value range    propagation based prediction), but such tricks shall go to new    implementation.  */
end_comment

begin_function
specifier|static
name|tree
name|expr_expected_value
parameter_list|(
name|tree
name|expr
parameter_list|,
name|bitmap
name|visited
parameter_list|)
block|{
if|if
condition|(
name|TREE_CONSTANT
argument_list|(
name|expr
argument_list|)
condition|)
return|return
name|expr
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|SSA_NAME
condition|)
block|{
name|tree
name|def
init|=
name|SSA_NAME_DEF_STMT
argument_list|(
name|expr
argument_list|)
decl_stmt|;
comment|/* If we were already here, break the infinite cycle.  */
if|if
condition|(
name|bitmap_bit_p
argument_list|(
name|visited
argument_list|,
name|SSA_NAME_VERSION
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
return|return
name|NULL
return|;
name|bitmap_set_bit
argument_list|(
name|visited
argument_list|,
name|SSA_NAME_VERSION
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|def
argument_list|)
operator|==
name|PHI_NODE
condition|)
block|{
comment|/* All the arguments of the PHI node must have the same constant 	     length.  */
name|int
name|i
decl_stmt|;
name|tree
name|val
init|=
name|NULL
decl_stmt|,
name|new_val
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PHI_NUM_ARGS
argument_list|(
name|def
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|arg
init|=
name|PHI_ARG_DEF
argument_list|(
name|def
argument_list|,
name|i
argument_list|)
decl_stmt|;
comment|/* If this PHI has itself as an argument, we cannot 		 determine the string length of this argument.  However, 		 if we can find an expected constant value for the other 		 PHI args then we can still be sure that this is 		 likely a constant.  So be optimistic and just 		 continue with the next argument.  */
if|if
condition|(
name|arg
operator|==
name|PHI_RESULT
argument_list|(
name|def
argument_list|)
condition|)
continue|continue;
name|new_val
operator|=
name|expr_expected_value
argument_list|(
name|arg
argument_list|,
name|visited
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|new_val
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|val
condition|)
name|val
operator|=
name|new_val
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|operand_equal_p
argument_list|(
name|val
argument_list|,
name|new_val
argument_list|,
name|false
argument_list|)
condition|)
return|return
name|NULL
return|;
block|}
return|return
name|val
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|def
argument_list|)
operator|!=
name|MODIFY_EXPR
operator|||
name|TREE_OPERAND
argument_list|(
name|def
argument_list|,
literal|0
argument_list|)
operator|!=
name|expr
condition|)
return|return
name|NULL
return|;
return|return
name|expr_expected_value
argument_list|(
name|TREE_OPERAND
argument_list|(
name|def
argument_list|,
literal|1
argument_list|)
argument_list|,
name|visited
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|CALL_EXPR
condition|)
block|{
name|tree
name|decl
init|=
name|get_callee_fndecl
argument_list|(
name|expr
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|decl
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|DECL_BUILT_IN_CLASS
argument_list|(
name|decl
argument_list|)
operator|==
name|BUILT_IN_NORMAL
operator|&&
name|DECL_FUNCTION_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|BUILT_IN_EXPECT
condition|)
block|{
name|tree
name|arglist
init|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|val
decl_stmt|;
if|if
condition|(
name|arglist
operator|==
name|NULL_TREE
operator|||
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
operator|==
name|NULL_TREE
condition|)
return|return
name|NULL
return|;
name|val
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CONSTANT
argument_list|(
name|val
argument_list|)
condition|)
return|return
name|val
return|;
return|return
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|BINARY_CLASS_P
argument_list|(
name|expr
argument_list|)
operator|||
name|COMPARISON_CLASS_P
argument_list|(
name|expr
argument_list|)
condition|)
block|{
name|tree
name|op0
decl_stmt|,
name|op1
decl_stmt|,
name|res
decl_stmt|;
name|op0
operator|=
name|expr_expected_value
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|visited
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|op0
condition|)
return|return
name|NULL
return|;
name|op1
operator|=
name|expr_expected_value
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|,
name|visited
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|op1
condition|)
return|return
name|NULL
return|;
name|res
operator|=
name|fold_build2
argument_list|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CONSTANT
argument_list|(
name|res
argument_list|)
condition|)
return|return
name|res
return|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|UNARY_CLASS_P
argument_list|(
name|expr
argument_list|)
condition|)
block|{
name|tree
name|op0
decl_stmt|,
name|res
decl_stmt|;
name|op0
operator|=
name|expr_expected_value
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|visited
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|op0
condition|)
return|return
name|NULL
return|;
name|res
operator|=
name|fold_build1
argument_list|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CONSTANT
argument_list|(
name|res
argument_list|)
condition|)
return|return
name|res
return|;
return|return
name|NULL
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Get rid of all builtin_expect calls we no longer need.  */
end_comment

begin_function
specifier|static
name|void
name|strip_builtin_expect
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|block_stmt_iterator
name|bi
decl_stmt|;
for|for
control|(
name|bi
operator|=
name|bsi_start
argument_list|(
name|bb
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|bi
argument_list|)
condition|;
name|bsi_next
argument_list|(
operator|&
name|bi
argument_list|)
control|)
block|{
name|tree
name|stmt
init|=
name|bsi_stmt
argument_list|(
name|bi
argument_list|)
decl_stmt|;
name|tree
name|fndecl
decl_stmt|;
name|tree
name|arglist
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|MODIFY_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CALL_EXPR
operator|&&
operator|(
name|fndecl
operator|=
name|get_callee_fndecl
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|&&
name|DECL_BUILT_IN_CLASS
argument_list|(
name|fndecl
argument_list|)
operator|==
name|BUILT_IN_NORMAL
operator|&&
name|DECL_FUNCTION_CODE
argument_list|(
name|fndecl
argument_list|)
operator|==
name|BUILT_IN_EXPECT
operator|&&
operator|(
name|arglist
operator|=
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|)
operator|&&
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
condition|)
block|{
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|update_stmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Predict using opcode of the last statement in basic block.  */
end_comment

begin_function
specifier|static
name|void
name|tree_predict_by_opcode
parameter_list|(
name|basic_block
name|bb
parameter_list|)
block|{
name|tree
name|stmt
init|=
name|last_stmt
argument_list|(
name|bb
argument_list|)
decl_stmt|;
name|edge
name|then_edge
decl_stmt|;
name|tree
name|cond
decl_stmt|;
name|tree
name|op0
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|tree
name|val
decl_stmt|;
name|bitmap
name|visited
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
if|if
condition|(
operator|!
name|stmt
operator|||
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|!=
name|COND_EXPR
condition|)
return|return;
name|FOR_EACH_EDGE
argument_list|(
argument|then_edge
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
if|if
condition|(
name|then_edge
operator|->
name|flags
operator|&
name|EDGE_TRUE_VALUE
condition|)
break|break;
name|cond
operator|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|COMPARISON_CLASS_P
argument_list|(
name|cond
argument_list|)
condition|)
return|return;
name|op0
operator|=
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|visited
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|val
operator|=
name|expr_expected_value
argument_list|(
name|cond
argument_list|,
name|visited
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|visited
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
condition|)
block|{
if|if
condition|(
name|integer_zerop
argument_list|(
name|val
argument_list|)
condition|)
name|predict_edge_def
argument_list|(
name|then_edge
argument_list|,
name|PRED_BUILTIN_EXPECT
argument_list|,
name|NOT_TAKEN
argument_list|)
expr_stmt|;
else|else
name|predict_edge_def
argument_list|(
name|then_edge
argument_list|,
name|PRED_BUILTIN_EXPECT
argument_list|,
name|TAKEN
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Try "pointer heuristic."      A comparison ptr == 0 is predicted as false.      Similarly, a comparison ptr1 == ptr2 is predicted as false.  */
if|if
condition|(
name|POINTER_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|cond
argument_list|)
operator|==
name|EQ_EXPR
condition|)
name|predict_edge_def
argument_list|(
name|then_edge
argument_list|,
name|PRED_TREE_POINTER
argument_list|,
name|NOT_TAKEN
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|cond
argument_list|)
operator|==
name|NE_EXPR
condition|)
name|predict_edge_def
argument_list|(
name|then_edge
argument_list|,
name|PRED_TREE_POINTER
argument_list|,
name|TAKEN
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Try "opcode heuristic."      EQ tests are usually false and NE tests are usually true. Also,      most quantities are positive, so we can make the appropriate guesses      about signed comparisons against zero.  */
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|cond
argument_list|)
condition|)
block|{
case|case
name|EQ_EXPR
case|:
case|case
name|UNEQ_EXPR
case|:
comment|/* Floating point comparisons appears to behave in a very 	   unpredictable way because of special role of = tests in 	   FP code.  */
if|if
condition|(
name|FLOAT_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
empty_stmt|;
comment|/* Comparisons with 0 are often used for booleans and there is 	   nothing useful to predict about them.  */
elseif|else
if|if
condition|(
name|integer_zerop
argument_list|(
name|op0
argument_list|)
operator|||
name|integer_zerop
argument_list|(
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
empty_stmt|;
else|else
name|predict_edge_def
argument_list|(
name|then_edge
argument_list|,
name|PRED_TREE_OPCODE_NONEQUAL
argument_list|,
name|NOT_TAKEN
argument_list|)
expr_stmt|;
break|break;
case|case
name|NE_EXPR
case|:
case|case
name|LTGT_EXPR
case|:
comment|/* Floating point comparisons appears to behave in a very 	   unpredictable way because of special role of = tests in 	   FP code.  */
if|if
condition|(
name|FLOAT_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
empty_stmt|;
comment|/* Comparisons with 0 are often used for booleans and there is 	   nothing useful to predict about them.  */
elseif|else
if|if
condition|(
name|integer_zerop
argument_list|(
name|op0
argument_list|)
operator|||
name|integer_zerop
argument_list|(
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
empty_stmt|;
else|else
name|predict_edge_def
argument_list|(
name|then_edge
argument_list|,
name|PRED_TREE_OPCODE_NONEQUAL
argument_list|,
name|TAKEN
argument_list|)
expr_stmt|;
break|break;
case|case
name|ORDERED_EXPR
case|:
name|predict_edge_def
argument_list|(
name|then_edge
argument_list|,
name|PRED_TREE_FPOPCODE
argument_list|,
name|TAKEN
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNORDERED_EXPR
case|:
name|predict_edge_def
argument_list|(
name|then_edge
argument_list|,
name|PRED_TREE_FPOPCODE
argument_list|,
name|NOT_TAKEN
argument_list|)
expr_stmt|;
break|break;
case|case
name|LE_EXPR
case|:
case|case
name|LT_EXPR
case|:
if|if
condition|(
name|integer_zerop
argument_list|(
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|||
name|integer_onep
argument_list|(
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|||
name|integer_all_onesp
argument_list|(
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|||
name|real_zerop
argument_list|(
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|||
name|real_onep
argument_list|(
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|||
name|real_minus_onep
argument_list|(
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
name|predict_edge_def
argument_list|(
name|then_edge
argument_list|,
name|PRED_TREE_OPCODE_POSITIVE
argument_list|,
name|NOT_TAKEN
argument_list|)
expr_stmt|;
break|break;
case|case
name|GE_EXPR
case|:
case|case
name|GT_EXPR
case|:
if|if
condition|(
name|integer_zerop
argument_list|(
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|||
name|integer_onep
argument_list|(
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|||
name|integer_all_onesp
argument_list|(
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|||
name|real_zerop
argument_list|(
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|||
name|real_onep
argument_list|(
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|||
name|real_minus_onep
argument_list|(
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
name|predict_edge_def
argument_list|(
name|then_edge
argument_list|,
name|PRED_TREE_OPCODE_POSITIVE
argument_list|,
name|TAKEN
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Try to guess whether the value of return means error code.  */
end_comment

begin_function
specifier|static
name|enum
name|br_predictor
name|return_prediction
parameter_list|(
name|tree
name|val
parameter_list|,
name|enum
name|prediction
modifier|*
name|prediction
parameter_list|)
block|{
comment|/* VOID.  */
if|if
condition|(
operator|!
name|val
condition|)
return|return
name|PRED_NO_PREDICTION
return|;
comment|/* Different heuristics for pointers and scalars.  */
if|if
condition|(
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
condition|)
block|{
comment|/* NULL is usually not returned.  */
if|if
condition|(
name|integer_zerop
argument_list|(
name|val
argument_list|)
condition|)
block|{
operator|*
name|prediction
operator|=
name|NOT_TAKEN
expr_stmt|;
return|return
name|PRED_NULL_RETURN
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Negative return values are often used to indicate          errors.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|tree_int_cst_sgn
argument_list|(
name|val
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|*
name|prediction
operator|=
name|NOT_TAKEN
expr_stmt|;
return|return
name|PRED_NEGATIVE_RETURN
return|;
block|}
comment|/* Constant return values seems to be commonly taken.          Zero/one often represent booleans so exclude them from the 	 heuristics.  */
if|if
condition|(
name|TREE_CONSTANT
argument_list|(
name|val
argument_list|)
operator|&&
operator|(
operator|!
name|integer_zerop
argument_list|(
name|val
argument_list|)
operator|&&
operator|!
name|integer_onep
argument_list|(
name|val
argument_list|)
operator|)
condition|)
block|{
operator|*
name|prediction
operator|=
name|TAKEN
expr_stmt|;
return|return
name|PRED_NEGATIVE_RETURN
return|;
block|}
block|}
return|return
name|PRED_NO_PREDICTION
return|;
block|}
end_function

begin_comment
comment|/* Find the basic block with return expression and look up for possible    return value trying to apply RETURN_PREDICTION heuristics.  */
end_comment

begin_function
specifier|static
name|void
name|apply_return_prediction
parameter_list|(
name|int
modifier|*
name|heads
parameter_list|)
block|{
name|tree
name|return_stmt
init|=
name|NULL
decl_stmt|;
name|tree
name|return_val
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|tree
name|phi
decl_stmt|;
name|int
name|phi_num_args
decl_stmt|,
name|i
decl_stmt|;
name|enum
name|br_predictor
name|pred
decl_stmt|;
name|enum
name|prediction
name|direction
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|EXIT_BLOCK_PTR->preds
argument_list|)
block|{
name|return_stmt
operator|=
name|last_stmt
argument_list|(
name|e
operator|->
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|return_stmt
argument_list|)
operator|==
name|RETURN_EXPR
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|e
condition|)
return|return;
name|return_val
operator|=
name|TREE_OPERAND
argument_list|(
name|return_stmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|return_val
condition|)
return|return;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|return_val
argument_list|)
operator|==
name|MODIFY_EXPR
condition|)
name|return_val
operator|=
name|TREE_OPERAND
argument_list|(
name|return_val
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|return_val
argument_list|)
operator|!=
name|SSA_NAME
operator|||
operator|!
name|SSA_NAME_DEF_STMT
argument_list|(
name|return_val
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|SSA_NAME_DEF_STMT
argument_list|(
name|return_val
argument_list|)
argument_list|)
operator|!=
name|PHI_NODE
condition|)
return|return;
for|for
control|(
name|phi
operator|=
name|SSA_NAME_DEF_STMT
argument_list|(
name|return_val
argument_list|)
init|;
name|phi
condition|;
name|phi
operator|=
name|PHI_CHAIN
argument_list|(
name|phi
argument_list|)
control|)
if|if
condition|(
name|PHI_RESULT
argument_list|(
name|phi
argument_list|)
operator|==
name|return_val
condition|)
break|break;
if|if
condition|(
operator|!
name|phi
condition|)
return|return;
name|phi_num_args
operator|=
name|PHI_NUM_ARGS
argument_list|(
name|phi
argument_list|)
expr_stmt|;
name|pred
operator|=
name|return_prediction
argument_list|(
name|PHI_ARG_DEF
argument_list|(
name|phi
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|direction
argument_list|)
expr_stmt|;
comment|/* Avoid the degenerate case where all return values form the function      belongs to same category (ie they are all positive constants)      so we can hardly say something about them.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|phi_num_args
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|pred
operator|!=
name|return_prediction
argument_list|(
name|PHI_ARG_DEF
argument_list|(
name|phi
argument_list|,
name|i
argument_list|)
argument_list|,
operator|&
name|direction
argument_list|)
condition|)
break|break;
if|if
condition|(
name|i
operator|!=
name|phi_num_args
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|phi_num_args
condition|;
name|i
operator|++
control|)
block|{
name|pred
operator|=
name|return_prediction
argument_list|(
name|PHI_ARG_DEF
argument_list|(
name|phi
argument_list|,
name|i
argument_list|)
argument_list|,
operator|&
name|direction
argument_list|)
expr_stmt|;
if|if
condition|(
name|pred
operator|!=
name|PRED_NO_PREDICTION
condition|)
name|predict_paths_leading_to
argument_list|(
name|PHI_ARG_EDGE
argument_list|(
name|phi
argument_list|,
name|i
argument_list|)
operator|->
name|src
argument_list|,
name|heads
argument_list|,
name|pred
argument_list|,
name|direction
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Look for basic block that contains unlikely to happen events    (such as noreturn calls) and mark all paths leading to execution    of this basic blocks as unlikely.  */
end_comment

begin_function
specifier|static
name|void
name|tree_bb_level_predictions
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|int
modifier|*
name|heads
decl_stmt|;
name|heads
operator|=
name|XNEWVEC
argument_list|(
name|int
argument_list|,
name|last_basic_block
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|heads
argument_list|,
name|ENTRY_BLOCK
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|last_basic_block
argument_list|)
expr_stmt|;
name|heads
index|[
name|ENTRY_BLOCK_PTR
operator|->
name|next_bb
operator|->
name|index
index|]
operator|=
name|last_basic_block
expr_stmt|;
name|apply_return_prediction
argument_list|(
name|heads
argument_list|)
expr_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|block_stmt_iterator
name|bsi
init|=
name|bsi_last
argument_list|(
name|bb
argument_list|)
decl_stmt|;
for|for
control|(
name|bsi
operator|=
name|bsi_start
argument_list|(
name|bb
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|;
name|bsi_next
argument_list|(
operator|&
name|bsi
argument_list|)
control|)
block|{
name|tree
name|stmt
init|=
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
condition|)
block|{
case|case
name|MODIFY_EXPR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CALL_EXPR
condition|)
block|{
name|stmt
operator|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|call_expr
goto|;
block|}
break|break;
case|case
name|CALL_EXPR
case|:
name|call_expr
label|:
empty_stmt|;
if|if
condition|(
name|call_expr_flags
argument_list|(
name|stmt
argument_list|)
operator|&
name|ECF_NORETURN
condition|)
name|predict_paths_leading_to
argument_list|(
name|bb
argument_list|,
name|heads
argument_list|,
name|PRED_NORETURN
argument_list|,
name|NOT_TAKEN
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
block|}
name|free
argument_list|(
name|heads
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Predict branch probabilities and estimate profile of the tree CFG.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|tree_estimate_probability
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|struct
name|loops
name|loops_info
decl_stmt|;
name|flow_loops_find
argument_list|(
operator|&
name|loops_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|flow_loops_dump
argument_list|(
operator|&
name|loops_info
argument_list|,
name|dump_file
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_noreturn_fake_exit_edges
argument_list|()
expr_stmt|;
name|connect_infinite_loops_to_exit
argument_list|()
expr_stmt|;
name|calculate_dominance_info
argument_list|(
name|CDI_DOMINATORS
argument_list|)
expr_stmt|;
name|calculate_dominance_info
argument_list|(
name|CDI_POST_DOMINATORS
argument_list|)
expr_stmt|;
name|tree_bb_level_predictions
argument_list|()
expr_stmt|;
name|mark_irreducible_loops
argument_list|(
operator|&
name|loops_info
argument_list|)
expr_stmt|;
name|predict_loops
argument_list|(
operator|&
name|loops_info
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
block|{
comment|/* Predict early returns to be probable, as we've already taken 	     care for error returns and other cases are often used for 	     fast paths through function.  */
if|if
condition|(
name|e
operator|->
name|dest
operator|==
name|EXIT_BLOCK_PTR
operator|&&
name|TREE_CODE
argument_list|(
name|last_stmt
argument_list|(
name|bb
argument_list|)
argument_list|)
operator|==
name|RETURN_EXPR
operator|&&
operator|!
name|single_pred_p
argument_list|(
name|bb
argument_list|)
condition|)
block|{
name|edge
name|e1
decl_stmt|;
name|edge_iterator
name|ei1
decl_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e1
argument_list|,
argument|ei1
argument_list|,
argument|bb->preds
argument_list|)
if|if
condition|(
operator|!
name|predicted_by_p
argument_list|(
name|e1
operator|->
name|src
argument_list|,
name|PRED_NULL_RETURN
argument_list|)
operator|&&
operator|!
name|predicted_by_p
argument_list|(
name|e1
operator|->
name|src
argument_list|,
name|PRED_CONST_RETURN
argument_list|)
operator|&&
operator|!
name|predicted_by_p
argument_list|(
name|e1
operator|->
name|src
argument_list|,
name|PRED_NEGATIVE_RETURN
argument_list|)
operator|&&
operator|!
name|last_basic_block_p
argument_list|(
name|e1
operator|->
name|src
argument_list|)
condition|)
name|predict_edge_def
argument_list|(
name|e1
argument_list|,
name|PRED_TREE_EARLY_RETURN
argument_list|,
name|NOT_TAKEN
argument_list|)
expr_stmt|;
block|}
comment|/* Look for block we are guarding (ie we dominate it, 	     but it doesn't postdominate us).  */
if|if
condition|(
name|e
operator|->
name|dest
operator|!=
name|EXIT_BLOCK_PTR
operator|&&
name|e
operator|->
name|dest
operator|!=
name|bb
operator|&&
name|dominated_by_p
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|e
operator|->
name|dest
argument_list|,
name|e
operator|->
name|src
argument_list|)
operator|&&
operator|!
name|dominated_by_p
argument_list|(
name|CDI_POST_DOMINATORS
argument_list|,
name|e
operator|->
name|src
argument_list|,
name|e
operator|->
name|dest
argument_list|)
condition|)
block|{
name|block_stmt_iterator
name|bi
decl_stmt|;
comment|/* The call heuristic claims that a guarded function call 		 is improbable.  This is because such calls are often used 		 to signal exceptional situations such as printing error 		 messages.  */
for|for
control|(
name|bi
operator|=
name|bsi_start
argument_list|(
name|e
operator|->
name|dest
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|bi
argument_list|)
condition|;
name|bsi_next
argument_list|(
operator|&
name|bi
argument_list|)
control|)
block|{
name|tree
name|stmt
init|=
name|bsi_stmt
argument_list|(
name|bi
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|CALL_EXPR
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|MODIFY_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CALL_EXPR
operator|)
operator|)
comment|/* Constant and pure calls are hardly used to signalize 			 something exceptional.  */
operator|&&
name|TREE_SIDE_EFFECTS
argument_list|(
name|stmt
argument_list|)
condition|)
block|{
name|predict_edge_def
argument_list|(
name|e
argument_list|,
name|PRED_CALL
argument_list|,
name|NOT_TAKEN
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
name|tree_predict_by_opcode
argument_list|(
name|bb
argument_list|)
expr_stmt|;
block|}
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
name|combine_predictions_for_bb
argument_list|(
name|bb
argument_list|)
expr_stmt|;
name|strip_builtin_expect
argument_list|()
expr_stmt|;
name|estimate_bb_frequencies
argument_list|(
operator|&
name|loops_info
argument_list|)
expr_stmt|;
name|free_dominance_info
argument_list|(
name|CDI_POST_DOMINATORS
argument_list|)
expr_stmt|;
name|remove_fake_exit_edges
argument_list|()
expr_stmt|;
name|flow_loops_free
argument_list|(
operator|&
name|loops_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|dump_tree_cfg
argument_list|(
name|dump_file
argument_list|,
name|dump_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|profile_status
operator|==
name|PROFILE_ABSENT
condition|)
name|profile_status
operator|=
name|PROFILE_GUESSED
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* __builtin_expect dropped tokens into the insn stream describing expected    values of registers.  Generate branch probabilities based off these    values.  */
end_comment

begin_function
name|void
name|expected_value_to_br_prob
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|,
name|cond
decl_stmt|,
name|ev
init|=
name|NULL_RTX
decl_stmt|,
name|ev_reg
init|=
name|NULL_RTX
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
condition|)
block|{
case|case
name|NOTE
case|:
comment|/* Look for expected value notes.  */
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_EXPECTED_VALUE
condition|)
block|{
name|ev
operator|=
name|NOTE_EXPECTED_VALUE
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|ev_reg
operator|=
name|XEXP
argument_list|(
name|ev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|delete_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
continue|continue;
case|case
name|CODE_LABEL
case|:
comment|/* Never propagate across labels.  */
name|ev
operator|=
name|NULL_RTX
expr_stmt|;
continue|continue;
case|case
name|JUMP_INSN
case|:
comment|/* Look for simple conditional branches.  If we haven't got an 	     expected value yet, no point going further.  */
if|if
condition|(
operator|!
name|JUMP_P
argument_list|(
name|insn
argument_list|)
operator|||
name|ev
operator|==
name|NULL_RTX
operator|||
operator|!
name|any_condjump_p
argument_list|(
name|insn
argument_list|)
condition|)
continue|continue;
break|break;
default|default:
comment|/* Look for insns that clobber the EV register.  */
if|if
condition|(
name|ev
operator|&&
name|reg_set_p
argument_list|(
name|ev_reg
argument_list|,
name|insn
argument_list|)
condition|)
name|ev
operator|=
name|NULL_RTX
expr_stmt|;
continue|continue;
block|}
comment|/* Collect the branch condition, hopefully relative to EV_REG.  */
comment|/* ???  At present we'll miss things like 		(expected_value (eq r70 0)) 		(set r71 -1) 		(set r80 (lt r70 r71)) 		(set pc (if_then_else (ne r80 0) ...)) 	 as canonicalize_condition will render this to us as 		(lt r70, r71) 	 Could use cselib to try and reduce this further.  */
name|cond
operator|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|pc_set
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cond
operator|=
name|canonicalize_condition
argument_list|(
name|insn
argument_list|,
name|cond
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|ev_reg
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cond
operator|||
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
operator|!=
name|ev_reg
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
condition|)
continue|continue;
comment|/* Substitute and simplify.  Given that the expression we're 	 building involves two constants, we should wind up with either 	 true or false.  */
name|cond
operator|=
name|gen_rtx_fmt_ee
argument_list|(
name|GET_CODE
argument_list|(
name|cond
argument_list|)
argument_list|,
name|VOIDmode
argument_list|,
name|XEXP
argument_list|(
name|ev
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|cond
operator|=
name|simplify_rtx
argument_list|(
name|cond
argument_list|)
expr_stmt|;
comment|/* Turn the condition into a scaled branch probability.  */
name|gcc_assert
argument_list|(
name|cond
operator|==
name|const_true_rtx
operator|||
name|cond
operator|==
name|const0_rtx
argument_list|)
expr_stmt|;
name|predict_insn_def
argument_list|(
name|insn
argument_list|,
name|PRED_BUILTIN_EXPECT
argument_list|,
name|cond
operator|==
name|const_true_rtx
condition|?
name|TAKEN
else|:
name|NOT_TAKEN
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Check whether this is the last basic block of function.  Commonly    there is one extra common cleanup block.  */
end_comment

begin_function
specifier|static
name|bool
name|last_basic_block_p
parameter_list|(
name|basic_block
name|bb
parameter_list|)
block|{
if|if
condition|(
name|bb
operator|==
name|EXIT_BLOCK_PTR
condition|)
return|return
name|false
return|;
return|return
operator|(
name|bb
operator|->
name|next_bb
operator|==
name|EXIT_BLOCK_PTR
operator|||
operator|(
name|bb
operator|->
name|next_bb
operator|->
name|next_bb
operator|==
name|EXIT_BLOCK_PTR
operator|&&
name|single_succ_p
argument_list|(
name|bb
argument_list|)
operator|&&
name|single_succ
argument_list|(
name|bb
argument_list|)
operator|->
name|next_bb
operator|==
name|EXIT_BLOCK_PTR
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Sets branch probabilities according to PREDiction and    FLAGS. HEADS[bb->index] should be index of basic block in that we    need to alter branch predictions (i.e. the first of our dominators    such that we do not post-dominate it) (but we fill this information    on demand, so -1 may be there in case this was not needed yet).  */
end_comment

begin_function
specifier|static
name|void
name|predict_paths_leading_to
parameter_list|(
name|basic_block
name|bb
parameter_list|,
name|int
modifier|*
name|heads
parameter_list|,
name|enum
name|br_predictor
name|pred
parameter_list|,
name|enum
name|prediction
name|taken
parameter_list|)
block|{
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|int
name|y
decl_stmt|;
if|if
condition|(
name|heads
index|[
name|bb
operator|->
name|index
index|]
operator|==
name|ENTRY_BLOCK
condition|)
block|{
comment|/* This is first time we need this field in heads array; so          find first dominator that we do not post-dominate (we are          using already known members of heads array).  */
name|basic_block
name|ai
init|=
name|bb
decl_stmt|;
name|basic_block
name|next_ai
init|=
name|get_immediate_dominator
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|bb
argument_list|)
decl_stmt|;
name|int
name|head
decl_stmt|;
while|while
condition|(
name|heads
index|[
name|next_ai
operator|->
name|index
index|]
operator|==
name|ENTRY_BLOCK
condition|)
block|{
if|if
condition|(
operator|!
name|dominated_by_p
argument_list|(
name|CDI_POST_DOMINATORS
argument_list|,
name|next_ai
argument_list|,
name|bb
argument_list|)
condition|)
break|break;
name|heads
index|[
name|next_ai
operator|->
name|index
index|]
operator|=
name|ai
operator|->
name|index
expr_stmt|;
name|ai
operator|=
name|next_ai
expr_stmt|;
name|next_ai
operator|=
name|get_immediate_dominator
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|next_ai
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|dominated_by_p
argument_list|(
name|CDI_POST_DOMINATORS
argument_list|,
name|next_ai
argument_list|,
name|bb
argument_list|)
condition|)
name|head
operator|=
name|next_ai
operator|->
name|index
expr_stmt|;
else|else
name|head
operator|=
name|heads
index|[
name|next_ai
operator|->
name|index
index|]
expr_stmt|;
while|while
condition|(
name|next_ai
operator|!=
name|bb
condition|)
block|{
name|next_ai
operator|=
name|ai
expr_stmt|;
name|ai
operator|=
name|BASIC_BLOCK
argument_list|(
name|heads
index|[
name|ai
operator|->
name|index
index|]
argument_list|)
expr_stmt|;
name|heads
index|[
name|next_ai
operator|->
name|index
index|]
operator|=
name|head
expr_stmt|;
block|}
block|}
name|y
operator|=
name|heads
index|[
name|bb
operator|->
name|index
index|]
expr_stmt|;
comment|/* Now find the edge that leads to our branch and aply the prediction.  */
if|if
condition|(
name|y
operator|==
name|last_basic_block
condition|)
return|return;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|BASIC_BLOCK (y)->succs
argument_list|)
if|if
condition|(
name|e
operator|->
name|dest
operator|->
name|index
operator|>=
name|NUM_FIXED_BLOCKS
operator|&&
name|dominated_by_p
argument_list|(
name|CDI_POST_DOMINATORS
argument_list|,
name|e
operator|->
name|dest
argument_list|,
name|bb
argument_list|)
condition|)
name|predict_edge_def
argument_list|(
name|e
argument_list|,
name|pred
argument_list|,
name|taken
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This is used to carry information about basic blocks.  It is    attached to the AUX field of the standard CFG block.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|block_info_def
block|{
comment|/* Estimated frequency of execution of basic_block.  */
name|sreal
name|frequency
decl_stmt|;
comment|/* To keep queue of basic blocks to process.  */
name|basic_block
name|next
decl_stmt|;
comment|/* Number of predecessors we need to visit first.  */
name|int
name|npredecessors
decl_stmt|;
block|}
typedef|*
name|block_info
typedef|;
end_typedef

begin_comment
comment|/* Similar information for edges.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|edge_info_def
block|{
comment|/* In case edge is a loopback edge, the probability edge will be reached      in case header is.  Estimated number of iterations of the loop can be      then computed as 1 / (1 - back_edge_prob).  */
name|sreal
name|back_edge_prob
decl_stmt|;
comment|/* True if the edge is a loopback edge in the natural loop.  */
name|unsigned
name|int
name|back_edge
range|:
literal|1
decl_stmt|;
block|}
typedef|*
name|edge_info
typedef|;
end_typedef

begin_define
define|#
directive|define
name|BLOCK_INFO
parameter_list|(
name|B
parameter_list|)
value|((block_info) (B)->aux)
end_define

begin_define
define|#
directive|define
name|EDGE_INFO
parameter_list|(
name|E
parameter_list|)
value|((edge_info) (E)->aux)
end_define

begin_comment
comment|/* Helper function for estimate_bb_frequencies.    Propagate the frequencies for LOOP.  */
end_comment

begin_function
specifier|static
name|void
name|propagate_freq
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|bitmap
name|tovisit
parameter_list|)
block|{
name|basic_block
name|head
init|=
name|loop
operator|->
name|header
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|basic_block
name|last
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|basic_block
name|nextbb
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
comment|/* For each basic block we need to visit count number of his predecessors      we need to visit first.  */
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|tovisit
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|bi
argument_list|)
block|{
name|edge_iterator
name|ei
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
comment|/* The outermost "loop" includes the exit block, which we can not 	  look up via BASIC_BLOCK.  Detect this and use EXIT_BLOCK_PTR 	  directly.  Do the same for the entry block.  */
name|bb
operator|=
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->preds
argument_list|)
block|{
name|bool
name|visit
init|=
name|bitmap_bit_p
argument_list|(
name|tovisit
argument_list|,
name|e
operator|->
name|src
operator|->
name|index
argument_list|)
decl_stmt|;
if|if
condition|(
name|visit
operator|&&
operator|!
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_DFS_BACK
operator|)
condition|)
name|count
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|visit
operator|&&
name|dump_file
operator|&&
operator|!
name|EDGE_INFO
argument_list|(
name|e
argument_list|)
operator|->
name|back_edge
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Irreducible region hit, ignoring edge to %i->%i\n"
argument_list|,
name|e
operator|->
name|src
operator|->
name|index
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
name|BLOCK_INFO
argument_list|(
name|bb
argument_list|)
operator|->
name|npredecessors
operator|=
name|count
expr_stmt|;
block|}
name|memcpy
argument_list|(
operator|&
name|BLOCK_INFO
argument_list|(
name|head
argument_list|)
operator|->
name|frequency
argument_list|,
operator|&
name|real_one
argument_list|,
sizeof|sizeof
argument_list|(
name|real_one
argument_list|)
argument_list|)
expr_stmt|;
name|last
operator|=
name|head
expr_stmt|;
for|for
control|(
name|bb
operator|=
name|head
init|;
name|bb
condition|;
name|bb
operator|=
name|nextbb
control|)
block|{
name|edge_iterator
name|ei
decl_stmt|;
name|sreal
name|cyclic_probability
decl_stmt|,
name|frequency
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|cyclic_probability
argument_list|,
operator|&
name|real_zero
argument_list|,
sizeof|sizeof
argument_list|(
name|real_zero
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|frequency
argument_list|,
operator|&
name|real_zero
argument_list|,
sizeof|sizeof
argument_list|(
name|real_zero
argument_list|)
argument_list|)
expr_stmt|;
name|nextbb
operator|=
name|BLOCK_INFO
argument_list|(
name|bb
argument_list|)
operator|->
name|next
expr_stmt|;
name|BLOCK_INFO
argument_list|(
name|bb
argument_list|)
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
comment|/* Compute frequency of basic block.  */
if|if
condition|(
name|bb
operator|!=
name|head
condition|)
block|{
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->preds
argument_list|)
name|gcc_assert
argument_list|(
operator|!
name|bitmap_bit_p
argument_list|(
name|tovisit
argument_list|,
name|e
operator|->
name|src
operator|->
name|index
argument_list|)
operator|||
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_DFS_BACK
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->preds
argument_list|)
if|if
condition|(
name|EDGE_INFO
argument_list|(
name|e
argument_list|)
operator|->
name|back_edge
condition|)
block|{
name|sreal_add
argument_list|(
operator|&
name|cyclic_probability
argument_list|,
operator|&
name|cyclic_probability
argument_list|,
operator|&
name|EDGE_INFO
argument_list|(
name|e
argument_list|)
operator|->
name|back_edge_prob
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_DFS_BACK
operator|)
condition|)
block|{
name|sreal
name|tmp
decl_stmt|;
comment|/*  frequency += (e->probability 				  * BLOCK_INFO (e->src)->frequency / 				  REG_BR_PROB_BASE);  */
name|sreal_init
argument_list|(
operator|&
name|tmp
argument_list|,
name|e
operator|->
name|probability
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sreal_mul
argument_list|(
operator|&
name|tmp
argument_list|,
operator|&
name|tmp
argument_list|,
operator|&
name|BLOCK_INFO
argument_list|(
name|e
operator|->
name|src
argument_list|)
operator|->
name|frequency
argument_list|)
expr_stmt|;
name|sreal_mul
argument_list|(
operator|&
name|tmp
argument_list|,
operator|&
name|tmp
argument_list|,
operator|&
name|real_inv_br_prob_base
argument_list|)
expr_stmt|;
name|sreal_add
argument_list|(
operator|&
name|frequency
argument_list|,
operator|&
name|frequency
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sreal_compare
argument_list|(
operator|&
name|cyclic_probability
argument_list|,
operator|&
name|real_zero
argument_list|)
operator|==
literal|0
condition|)
block|{
name|memcpy
argument_list|(
operator|&
name|BLOCK_INFO
argument_list|(
name|bb
argument_list|)
operator|->
name|frequency
argument_list|,
operator|&
name|frequency
argument_list|,
sizeof|sizeof
argument_list|(
name|frequency
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|sreal_compare
argument_list|(
operator|&
name|cyclic_probability
argument_list|,
operator|&
name|real_almost_one
argument_list|)
operator|>
literal|0
condition|)
block|{
name|memcpy
argument_list|(
operator|&
name|cyclic_probability
argument_list|,
operator|&
name|real_almost_one
argument_list|,
sizeof|sizeof
argument_list|(
name|real_almost_one
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* BLOCK_INFO (bb)->frequency = frequency 					      / (1 - cyclic_probability) */
name|sreal_sub
argument_list|(
operator|&
name|cyclic_probability
argument_list|,
operator|&
name|real_one
argument_list|,
operator|&
name|cyclic_probability
argument_list|)
expr_stmt|;
name|sreal_div
argument_list|(
operator|&
name|BLOCK_INFO
argument_list|(
name|bb
argument_list|)
operator|->
name|frequency
argument_list|,
operator|&
name|frequency
argument_list|,
operator|&
name|cyclic_probability
argument_list|)
expr_stmt|;
block|}
block|}
name|bitmap_clear_bit
argument_list|(
name|tovisit
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|e
operator|=
name|find_edge
argument_list|(
name|bb
argument_list|,
name|head
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
condition|)
block|{
name|sreal
name|tmp
decl_stmt|;
comment|/* EDGE_INFO (e)->back_edge_prob 	     = ((e->probability * BLOCK_INFO (bb)->frequency) 	     / REG_BR_PROB_BASE); */
name|sreal_init
argument_list|(
operator|&
name|tmp
argument_list|,
name|e
operator|->
name|probability
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sreal_mul
argument_list|(
operator|&
name|tmp
argument_list|,
operator|&
name|tmp
argument_list|,
operator|&
name|BLOCK_INFO
argument_list|(
name|bb
argument_list|)
operator|->
name|frequency
argument_list|)
expr_stmt|;
name|sreal_mul
argument_list|(
operator|&
name|EDGE_INFO
argument_list|(
name|e
argument_list|)
operator|->
name|back_edge_prob
argument_list|,
operator|&
name|tmp
argument_list|,
operator|&
name|real_inv_br_prob_base
argument_list|)
expr_stmt|;
block|}
comment|/* Propagate to successor blocks.  */
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
if|if
condition|(
operator|!
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_DFS_BACK
operator|)
operator|&&
name|BLOCK_INFO
argument_list|(
name|e
operator|->
name|dest
argument_list|)
operator|->
name|npredecessors
condition|)
block|{
name|BLOCK_INFO
argument_list|(
name|e
operator|->
name|dest
argument_list|)
operator|->
name|npredecessors
operator|--
expr_stmt|;
if|if
condition|(
operator|!
name|BLOCK_INFO
argument_list|(
name|e
operator|->
name|dest
argument_list|)
operator|->
name|npredecessors
condition|)
block|{
if|if
condition|(
operator|!
name|nextbb
condition|)
name|nextbb
operator|=
name|e
operator|->
name|dest
expr_stmt|;
else|else
name|BLOCK_INFO
argument_list|(
name|last
argument_list|)
operator|->
name|next
operator|=
name|e
operator|->
name|dest
expr_stmt|;
name|last
operator|=
name|e
operator|->
name|dest
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Estimate probabilities of loopback edges in loops at same nest level.  */
end_comment

begin_function
specifier|static
name|void
name|estimate_loops_at_level
parameter_list|(
name|struct
name|loop
modifier|*
name|first_loop
parameter_list|,
name|bitmap
name|tovisit
parameter_list|)
block|{
name|struct
name|loop
modifier|*
name|loop
decl_stmt|;
for|for
control|(
name|loop
operator|=
name|first_loop
init|;
name|loop
condition|;
name|loop
operator|=
name|loop
operator|->
name|next
control|)
block|{
name|edge
name|e
decl_stmt|;
name|basic_block
modifier|*
name|bbs
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|estimate_loops_at_level
argument_list|(
name|loop
operator|->
name|inner
argument_list|,
name|tovisit
argument_list|)
expr_stmt|;
comment|/* Do not do this for dummy function loop.  */
if|if
condition|(
name|EDGE_COUNT
argument_list|(
name|loop
operator|->
name|latch
operator|->
name|succs
argument_list|)
operator|>
literal|0
condition|)
block|{
comment|/* Find current loop back edge and mark it.  */
name|e
operator|=
name|loop_latch_edge
argument_list|(
name|loop
argument_list|)
expr_stmt|;
name|EDGE_INFO
argument_list|(
name|e
argument_list|)
operator|->
name|back_edge
operator|=
literal|1
expr_stmt|;
block|}
name|bbs
operator|=
name|get_loop_body
argument_list|(
name|loop
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|loop
operator|->
name|num_nodes
condition|;
name|i
operator|++
control|)
name|bitmap_set_bit
argument_list|(
name|tovisit
argument_list|,
name|bbs
index|[
name|i
index|]
operator|->
name|index
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|bbs
argument_list|)
expr_stmt|;
name|propagate_freq
argument_list|(
name|loop
argument_list|,
name|tovisit
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Convert counts measured by profile driven feedback to frequencies.    Return nonzero iff there was any nonzero execution count.  */
end_comment

begin_function
name|int
name|counts_to_freqs
parameter_list|(
name|void
parameter_list|)
block|{
name|gcov_type
name|count_max
decl_stmt|,
name|true_count_max
init|=
literal|0
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
name|true_count_max
operator|=
name|MAX
argument_list|(
name|bb
operator|->
name|count
argument_list|,
name|true_count_max
argument_list|)
expr_stmt|;
name|count_max
operator|=
name|MAX
argument_list|(
name|true_count_max
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|FOR_BB_BETWEEN
argument_list|(
argument|bb
argument_list|,
argument|ENTRY_BLOCK_PTR
argument_list|,
argument|NULL
argument_list|,
argument|next_bb
argument_list|)
name|bb
operator|->
name|frequency
operator|=
operator|(
name|bb
operator|->
name|count
operator|*
name|BB_FREQ_MAX
operator|+
name|count_max
operator|/
literal|2
operator|)
operator|/
name|count_max
expr_stmt|;
return|return
name|true_count_max
return|;
block|}
end_function

begin_comment
comment|/* Return true if function is likely to be expensive, so there is no point to    optimize performance of prologue, epilogue or do inlining at the expense    of code size growth.  THRESHOLD is the limit of number of instructions    function can execute at average to be still considered not expensive.  */
end_comment

begin_function
name|bool
name|expensive_function_p
parameter_list|(
name|int
name|threshold
parameter_list|)
block|{
name|unsigned
name|int
name|sum
init|=
literal|0
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|unsigned
name|int
name|limit
decl_stmt|;
comment|/* We can not compute accurately for large thresholds due to scaled      frequencies.  */
name|gcc_assert
argument_list|(
name|threshold
operator|<=
name|BB_FREQ_MAX
argument_list|)
expr_stmt|;
comment|/* Frequencies are out of range.  This either means that function contains      internal loop executing more than BB_FREQ_MAX times or profile feedback      is available and function has not been executed at all.  */
if|if
condition|(
name|ENTRY_BLOCK_PTR
operator|->
name|frequency
operator|==
literal|0
condition|)
return|return
name|true
return|;
comment|/* Maximally BB_FREQ_MAX^2 so overflow won't happen.  */
name|limit
operator|=
name|ENTRY_BLOCK_PTR
operator|->
name|frequency
operator|*
name|threshold
expr_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|rtx
name|insn
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
init|;
name|insn
operator|!=
name|NEXT_INSN
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|active_insn_p
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|sum
operator|+=
name|bb
operator|->
name|frequency
expr_stmt|;
if|if
condition|(
name|sum
operator|>
name|limit
condition|)
return|return
name|true
return|;
block|}
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Estimate basic blocks frequency by given branch probabilities.  */
end_comment

begin_function
specifier|static
name|void
name|estimate_bb_frequencies
parameter_list|(
name|struct
name|loops
modifier|*
name|loops
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|sreal
name|freq_max
decl_stmt|;
if|if
condition|(
operator|!
name|flag_branch_probabilities
operator|||
operator|!
name|counts_to_freqs
argument_list|()
condition|)
block|{
specifier|static
name|int
name|real_values_initialized
init|=
literal|0
decl_stmt|;
name|bitmap
name|tovisit
decl_stmt|;
if|if
condition|(
operator|!
name|real_values_initialized
condition|)
block|{
name|real_values_initialized
operator|=
literal|1
expr_stmt|;
name|sreal_init
argument_list|(
operator|&
name|real_zero
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sreal_init
argument_list|(
operator|&
name|real_one
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sreal_init
argument_list|(
operator|&
name|real_br_prob_base
argument_list|,
name|REG_BR_PROB_BASE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sreal_init
argument_list|(
operator|&
name|real_bb_freq_max
argument_list|,
name|BB_FREQ_MAX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sreal_init
argument_list|(
operator|&
name|real_one_half
argument_list|,
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|sreal_div
argument_list|(
operator|&
name|real_inv_br_prob_base
argument_list|,
operator|&
name|real_one
argument_list|,
operator|&
name|real_br_prob_base
argument_list|)
expr_stmt|;
name|sreal_sub
argument_list|(
operator|&
name|real_almost_one
argument_list|,
operator|&
name|real_one
argument_list|,
operator|&
name|real_inv_br_prob_base
argument_list|)
expr_stmt|;
block|}
name|mark_dfs_back_edges
argument_list|()
expr_stmt|;
name|single_succ_edge
argument_list|(
name|ENTRY_BLOCK_PTR
argument_list|)
operator|->
name|probability
operator|=
name|REG_BR_PROB_BASE
expr_stmt|;
comment|/* Set up block info for each basic block.  */
name|tovisit
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|alloc_aux_for_blocks
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|block_info_def
argument_list|)
argument_list|)
expr_stmt|;
name|alloc_aux_for_edges
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|edge_info_def
argument_list|)
argument_list|)
expr_stmt|;
name|FOR_BB_BETWEEN
argument_list|(
argument|bb
argument_list|,
argument|ENTRY_BLOCK_PTR
argument_list|,
argument|NULL
argument_list|,
argument|next_bb
argument_list|)
block|{
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
block|{
name|sreal_init
argument_list|(
operator|&
name|EDGE_INFO
argument_list|(
name|e
argument_list|)
operator|->
name|back_edge_prob
argument_list|,
name|e
operator|->
name|probability
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sreal_mul
argument_list|(
operator|&
name|EDGE_INFO
argument_list|(
name|e
argument_list|)
operator|->
name|back_edge_prob
argument_list|,
operator|&
name|EDGE_INFO
argument_list|(
name|e
argument_list|)
operator|->
name|back_edge_prob
argument_list|,
operator|&
name|real_inv_br_prob_base
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* First compute probabilities locally for each loop from innermost          to outermost to examine probabilities for back edges.  */
name|estimate_loops_at_level
argument_list|(
name|loops
operator|->
name|tree_root
argument_list|,
name|tovisit
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|freq_max
argument_list|,
operator|&
name|real_zero
argument_list|,
sizeof|sizeof
argument_list|(
name|real_zero
argument_list|)
argument_list|)
expr_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
if|if
condition|(
name|sreal_compare
argument_list|(
operator|&
name|freq_max
argument_list|,
operator|&
name|BLOCK_INFO
argument_list|(
name|bb
argument_list|)
operator|->
name|frequency
argument_list|)
operator|<
literal|0
condition|)
name|memcpy
argument_list|(
operator|&
name|freq_max
argument_list|,
operator|&
name|BLOCK_INFO
argument_list|(
name|bb
argument_list|)
operator|->
name|frequency
argument_list|,
sizeof|sizeof
argument_list|(
name|freq_max
argument_list|)
argument_list|)
expr_stmt|;
name|sreal_div
argument_list|(
operator|&
name|freq_max
argument_list|,
operator|&
name|real_bb_freq_max
argument_list|,
operator|&
name|freq_max
argument_list|)
expr_stmt|;
name|FOR_BB_BETWEEN
argument_list|(
argument|bb
argument_list|,
argument|ENTRY_BLOCK_PTR
argument_list|,
argument|NULL
argument_list|,
argument|next_bb
argument_list|)
block|{
name|sreal
name|tmp
decl_stmt|;
name|sreal_mul
argument_list|(
operator|&
name|tmp
argument_list|,
operator|&
name|BLOCK_INFO
argument_list|(
name|bb
argument_list|)
operator|->
name|frequency
argument_list|,
operator|&
name|freq_max
argument_list|)
expr_stmt|;
name|sreal_add
argument_list|(
operator|&
name|tmp
argument_list|,
operator|&
name|tmp
argument_list|,
operator|&
name|real_one_half
argument_list|)
expr_stmt|;
name|bb
operator|->
name|frequency
operator|=
name|sreal_to_int
argument_list|(
operator|&
name|tmp
argument_list|)
expr_stmt|;
block|}
name|free_aux_for_blocks
argument_list|()
expr_stmt|;
name|free_aux_for_edges
argument_list|()
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|tovisit
argument_list|)
expr_stmt|;
block|}
name|compute_function_frequency
argument_list|()
expr_stmt|;
if|if
condition|(
name|flag_reorder_functions
condition|)
name|choose_function_section
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Decide whether function is hot, cold or unlikely executed.  */
end_comment

begin_function
specifier|static
name|void
name|compute_function_frequency
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
if|if
condition|(
operator|!
name|profile_info
operator|||
operator|!
name|flag_branch_probabilities
condition|)
return|return;
name|cfun
operator|->
name|function_frequency
operator|=
name|FUNCTION_FREQUENCY_UNLIKELY_EXECUTED
expr_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
if|if
condition|(
name|maybe_hot_bb_p
argument_list|(
name|bb
argument_list|)
condition|)
block|{
name|cfun
operator|->
name|function_frequency
operator|=
name|FUNCTION_FREQUENCY_HOT
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|probably_never_executed_bb_p
argument_list|(
name|bb
argument_list|)
condition|)
name|cfun
operator|->
name|function_frequency
operator|=
name|FUNCTION_FREQUENCY_NORMAL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Choose appropriate section for the function.  */
end_comment

begin_function
specifier|static
name|void
name|choose_function_section
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|DECL_SECTION_NAME
argument_list|(
name|current_function_decl
argument_list|)
operator|||
operator|!
name|targetm
operator|.
name|have_named_sections
comment|/* Theoretically we can split the gnu.linkonce text section too, 	 but this requires more work as the frequency needs to match 	 for all generated objects so we need to merge the frequency 	 of all instances.  For now just never set frequency for these.  */
operator|||
name|DECL_ONE_ONLY
argument_list|(
name|current_function_decl
argument_list|)
condition|)
return|return;
comment|/* If we are doing the partitioning optimization, let the optimization      choose the correct section into which to put things.  */
if|if
condition|(
name|flag_reorder_blocks_and_partition
condition|)
return|return;
if|if
condition|(
name|cfun
operator|->
name|function_frequency
operator|==
name|FUNCTION_FREQUENCY_HOT
condition|)
name|DECL_SECTION_NAME
argument_list|(
name|current_function_decl
argument_list|)
operator|=
name|build_string
argument_list|(
name|strlen
argument_list|(
name|HOT_TEXT_SECTION_NAME
argument_list|)
argument_list|,
name|HOT_TEXT_SECTION_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfun
operator|->
name|function_frequency
operator|==
name|FUNCTION_FREQUENCY_UNLIKELY_EXECUTED
condition|)
name|DECL_SECTION_NAME
argument_list|(
name|current_function_decl
argument_list|)
operator|=
name|build_string
argument_list|(
name|strlen
argument_list|(
name|UNLIKELY_EXECUTED_TEXT_SECTION_NAME
argument_list|)
argument_list|,
name|UNLIKELY_EXECUTED_TEXT_SECTION_NAME
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bool
name|gate_estimate_probability
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|flag_guess_branch_prob
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|tree_opt_pass
name|pass_profile
init|=
block|{
literal|"profile"
block|,
comment|/* name */
name|gate_estimate_probability
block|,
comment|/* gate */
name|tree_estimate_probability
block|,
comment|/* execute */
name|NULL
block|,
comment|/* sub */
name|NULL
block|,
comment|/* next */
literal|0
block|,
comment|/* static_pass_number */
name|TV_BRANCH_PROB
block|,
comment|/* tv_id */
name|PROP_cfg
block|,
comment|/* properties_required */
literal|0
block|,
comment|/* properties_provided */
literal|0
block|,
comment|/* properties_destroyed */
literal|0
block|,
comment|/* todo_flags_start */
name|TODO_ggc_collect
operator||
name|TODO_verify_ssa
block|,
comment|/* todo_flags_finish */
literal|0
comment|/* letter */
block|}
decl_stmt|;
end_decl_stmt

end_unit

