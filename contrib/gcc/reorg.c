begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Perform instruction reorganizations for delay slot filling.    Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2000, 2001, 2002 Free Software Foundation, Inc.    Contributed by Richard Kenner (kenner@vlsi1.ultra.nyu.edu).    Hacked by Michael Tiemann (tiemann@cygnus.com).  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* Instruction reorganization pass.     This pass runs after register allocation and final jump    optimization.  It should be the last pass to run before peephole.    It serves primarily to fill delay slots of insns, typically branch    and call insns.  Other insns typically involve more complicated    interactions of data dependencies and resource constraints, and    are better handled by scheduling before register allocation (by the    function `schedule_insns').     The Branch Penalty is the number of extra cycles that are needed to    execute a branch insn.  On an ideal machine, branches take a single    cycle, and the Branch Penalty is 0.  Several RISC machines approach    branch delays differently:     The MIPS and AMD 29000 have a single branch delay slot.  Most insns    (except other branches) can be used to fill this slot.  When the    slot is filled, two insns execute in two cycles, reducing the    branch penalty to zero.     The Motorola 88000 conditionally exposes its branch delay slot,    so code is shorter when it is turned off, but will run faster    when useful insns are scheduled there.     The IBM ROMP has two forms of branch and call insns, both with and    without a delay slot.  Much like the 88k, insns not using the delay    slot can be shorted (2 bytes vs. 4 bytes), but will run slowed.     The SPARC always has a branch delay slot, but its effects can be    annulled when the branch is not taken.  This means that failing to    find other sources of insns, we can hoist an insn from the branch    target that would only be safe to execute knowing that the branch    is taken.     The HP-PA always has a branch delay slot.  For unconditional branches    its effects can be annulled when the branch is taken.  The effects    of the delay slot in a conditional branch can be nullified for forward    taken branches, or for untaken backward branches.  This means    we can hoist insns from the fall-through path for forward branches or    steal insns from the target of backward branches.     The TMS320C3x and C4x have three branch delay slots.  When the three    slots are filled, the branch penalty is zero.  Most insns can fill the    delay slots except jump insns.     Three techniques for filling delay slots have been implemented so far:     (1) `fill_simple_delay_slots' is the simplest, most efficient way    to fill delay slots.  This pass first looks for insns which come    from before the branch and which are safe to execute after the    branch.  Then it searches after the insn requiring delay slots or,    in the case of a branch, for insns that are after the point at    which the branch merges into the fallthrough code, if such a point    exists.  When such insns are found, the branch penalty decreases    and no code expansion takes place.     (2) `fill_eager_delay_slots' is more complicated: it is used for    scheduling conditional jumps, or for scheduling jumps which cannot    be filled using (1).  A machine need not have annulled jumps to use    this strategy, but it helps (by keeping more options open).    `fill_eager_delay_slots' tries to guess the direction the branch    will go; if it guesses right 100% of the time, it can reduce the    branch penalty as much as `fill_simple_delay_slots' does.  If it    guesses wrong 100% of the time, it might as well schedule nops (or    on the m88k, unexpose the branch slot).  When    `fill_eager_delay_slots' takes insns from the fall-through path of    the jump, usually there is no code expansion; when it takes insns    from the branch target, there is code expansion if it is not the    only way to reach that target.     (3) `relax_delay_slots' uses a set of rules to simplify code that    has been reorganized by (1) and (2).  It finds cases where    conditional test can be eliminated, jumps can be threaded, extra    insns can be eliminated, etc.  It is the job of (1) and (2) to do a    good job of scheduling locally; `relax_delay_slots' takes care of    making the various individual schedules work well together.  It is    especially tuned to handle the control flow interactions of branch    insns.  It does nothing for insns with delay slots that do not    branch.     On machines that use CC0, we are very conservative.  We will not make    a copy of an insn involving CC0 since we want to maintain a 1-1    correspondence between the insn that sets and uses CC0.  The insns are    allowed to be separated by placing an insn that sets CC0 (but not an insn    that uses CC0; we could do this, but it doesn't seem worthwhile) in a    delay slot.  In that case, we point each insn at the other with REG_CC_USER    and REG_CC_SETTER notes.  Note that these restrictions affect very few    machines because most RISC machines with delay slots will not use CC0    (the RT is the only known exception at this point).     Not yet implemented:     The Acorn Risc Machine can conditionally execute most insns, so    it is profitable to move single insns into a position to execute    based on the condition code of the previous insn.     The HP-PA can conditionally nullify insns, providing a similar    effect to the ARM, differing mostly in which insn is "in charge".  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"conditions.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"insn-attr.h"
end_include

begin_include
include|#
directive|include
file|"resource.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"params.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DELAY_SLOTS
end_ifdef

begin_define
define|#
directive|define
name|obstack_chunk_alloc
value|xmalloc
end_define

begin_define
define|#
directive|define
name|obstack_chunk_free
value|free
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|ANNUL_IFTRUE_SLOTS
end_ifndef

begin_define
define|#
directive|define
name|eligible_for_annul_true
parameter_list|(
name|INSN
parameter_list|,
name|SLOTS
parameter_list|,
name|TRIAL
parameter_list|,
name|FLAGS
parameter_list|)
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ANNUL_IFFALSE_SLOTS
end_ifndef

begin_define
define|#
directive|define
name|eligible_for_annul_false
parameter_list|(
name|INSN
parameter_list|,
name|SLOTS
parameter_list|,
name|TRIAL
parameter_list|,
name|FLAGS
parameter_list|)
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Insns which have delay slots that have not yet been filled.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|unfilled_slots_obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
modifier|*
name|unfilled_firstobj
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Define macros to refer to the first and last slot containing unfilled    insns.  These are used because the list may move and its address    should be recomputed at each use.  */
end_comment

begin_define
define|#
directive|define
name|unfilled_slots_base
define|\
value|((rtx *) obstack_base (&unfilled_slots_obstack))
end_define

begin_define
define|#
directive|define
name|unfilled_slots_next
define|\
value|((rtx *) obstack_next_free (&unfilled_slots_obstack))
end_define

begin_comment
comment|/* Points to the label before the end of the function.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|end_of_function_label
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Mapping between INSN_UID's and position in the code since INSN_UID's do    not always monotonically increase.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|uid_to_ruid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Highest valid index in `uid_to_ruid'.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|max_uid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|stop_search_p
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|resource_conflicts_p
name|PARAMS
argument_list|(
operator|(
expr|struct
name|resources
operator|*
operator|,
expr|struct
name|resources
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|insn_references_resource_p
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
expr|struct
name|resources
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|insn_sets_resource_p
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
expr|struct
name|resources
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|find_end_label
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|emit_delay_sequence
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|add_to_delay_list
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|delete_from_delay_slot
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|delete_scheduled_jump
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|note_delay_statistics
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|ANNUL_IFFALSE_SLOTS
argument_list|)
operator|||
name|defined
argument_list|(
name|ANNUL_IFTRUE_SLOTS
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|rtx
name|optimize_skip
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|get_jump_flags
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|rare_destination
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mostly_true_jump
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|get_branch_condition
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|condition_dominates_p
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|redirect_with_delay_slots_safe_p
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|redirect_with_delay_list_safe_p
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|check_annul_list_true_false
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|steal_delay_list_from_target
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|,
expr|struct
name|resources
operator|*
operator|,
expr|struct
name|resources
operator|*
operator|,
expr|struct
name|resources
operator|*
operator|,
name|int
operator|,
name|int
operator|*
operator|,
name|int
operator|*
operator|,
name|rtx
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|steal_delay_list_from_fallthrough
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|,
expr|struct
name|resources
operator|*
operator|,
expr|struct
name|resources
operator|*
operator|,
expr|struct
name|resources
operator|*
operator|,
name|int
operator|,
name|int
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|try_merge_delay_insns
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|redundant_insn
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|own_thread_p
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|update_block
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|reorg_redirect_jump
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|update_reg_dead_notes
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fix_reg_dead_note
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|update_reg_unused_notes
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fill_simple_delay_slots
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|fill_slots_from_thread
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|*
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fill_eager_delay_slots
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|relax_delay_slots
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_return
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|make_return_insns
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Return TRUE if this insn should stop the search for insn to fill delay    slots.  LABELS_P indicates that labels should terminate the search.    In all cases, jumps terminate the search.  */
end_comment

begin_function
specifier|static
name|int
name|stop_search_p
parameter_list|(
name|insn
parameter_list|,
name|labels_p
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|int
name|labels_p
decl_stmt|;
block|{
if|if
condition|(
name|insn
operator|==
literal|0
condition|)
return|return
literal|1
return|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
condition|)
block|{
case|case
name|NOTE
case|:
case|case
name|CALL_INSN
case|:
return|return
literal|0
return|;
case|case
name|CODE_LABEL
case|:
return|return
name|labels_p
return|;
case|case
name|JUMP_INSN
case|:
case|case
name|BARRIER
case|:
return|return
literal|1
return|;
case|case
name|INSN
case|:
comment|/* OK unless it contains a delay slot or is an `asm' insn of some type. 	 We don't know anything about these.  */
return|return
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SEQUENCE
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|ASM_INPUT
operator|||
name|asm_noperands
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|>=
literal|0
operator|)
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return TRUE if any resources are marked in both RES1 and RES2 or if either    resource set contains a volatile memory reference.  Otherwise, return FALSE.  */
end_comment

begin_function
specifier|static
name|int
name|resource_conflicts_p
parameter_list|(
name|res1
parameter_list|,
name|res2
parameter_list|)
name|struct
name|resources
modifier|*
name|res1
decl_stmt|,
decl|*
name|res2
decl_stmt|;
end_function

begin_block
block|{
if|if
condition|(
operator|(
name|res1
operator|->
name|cc
operator|&&
name|res2
operator|->
name|cc
operator|)
operator|||
operator|(
name|res1
operator|->
name|memory
operator|&&
name|res2
operator|->
name|memory
operator|)
operator|||
operator|(
name|res1
operator|->
name|unch_memory
operator|&&
name|res2
operator|->
name|unch_memory
operator|)
operator|||
name|res1
operator|->
name|volatil
operator|||
name|res2
operator|->
name|volatil
condition|)
return|return
literal|1
return|;
ifdef|#
directive|ifdef
name|HARD_REG_SET
return|return
operator|(
name|res1
operator|->
name|regs
operator|&
name|res2
operator|->
name|regs
operator|)
operator|!=
name|HARD_CONST
argument_list|(
literal|0
argument_list|)
return|;
else|#
directive|else
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HARD_REG_SET_LONGS
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|res1
operator|->
name|regs
index|[
name|i
index|]
operator|&
name|res2
operator|->
name|regs
index|[
name|i
index|]
operator|)
operator|!=
literal|0
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/* Return TRUE if any resource marked in RES, a `struct resources', is    referenced by INSN.  If INCLUDE_DELAYED_EFFECTS is set, return if the called    routine is using those resources.     We compute this by computing all the resources referenced by INSN and    seeing if this conflicts with RES.  It might be faster to directly check    ourselves, and this is the way it used to work, but it means duplicating    a large block of complex code.  */
end_comment

begin_function
specifier|static
name|int
name|insn_references_resource_p
parameter_list|(
name|insn
parameter_list|,
name|res
parameter_list|,
name|include_delayed_effects
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|struct
name|resources
modifier|*
name|res
decl_stmt|;
name|int
name|include_delayed_effects
decl_stmt|;
block|{
name|struct
name|resources
name|insn_res
decl_stmt|;
name|CLEAR_RESOURCE
argument_list|(
operator|&
name|insn_res
argument_list|)
expr_stmt|;
name|mark_referenced_resources
argument_list|(
name|insn
argument_list|,
operator|&
name|insn_res
argument_list|,
name|include_delayed_effects
argument_list|)
expr_stmt|;
return|return
name|resource_conflicts_p
argument_list|(
operator|&
name|insn_res
argument_list|,
name|res
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE if INSN modifies resources that are marked in RES.    INCLUDE_DELAYED_EFFECTS is set if the actions of that routine should be    included.   CC0 is only modified if it is explicitly set; see comments    in front of mark_set_resources for details.  */
end_comment

begin_function
specifier|static
name|int
name|insn_sets_resource_p
parameter_list|(
name|insn
parameter_list|,
name|res
parameter_list|,
name|include_delayed_effects
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|struct
name|resources
modifier|*
name|res
decl_stmt|;
name|int
name|include_delayed_effects
decl_stmt|;
block|{
name|struct
name|resources
name|insn_sets
decl_stmt|;
name|CLEAR_RESOURCE
argument_list|(
operator|&
name|insn_sets
argument_list|)
expr_stmt|;
name|mark_set_resources
argument_list|(
name|insn
argument_list|,
operator|&
name|insn_sets
argument_list|,
literal|0
argument_list|,
name|include_delayed_effects
argument_list|)
expr_stmt|;
return|return
name|resource_conflicts_p
argument_list|(
operator|&
name|insn_sets
argument_list|,
name|res
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Find a label at the end of the function or before a RETURN.  If there is    none, make one.  */
end_comment

begin_function
specifier|static
name|rtx
name|find_end_label
parameter_list|()
block|{
name|rtx
name|insn
decl_stmt|;
comment|/* If we found one previously, return it.  */
if|if
condition|(
name|end_of_function_label
condition|)
return|return
name|end_of_function_label
return|;
comment|/* Otherwise, see if there is a label at the end of the function.  If there      is, it must be that RETURN insns aren't needed, so that is our return      label and we don't have to do anything else.  */
name|insn
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|||
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|USE
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|CLOBBER
operator|)
operator|)
condition|)
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* When a target threads its epilogue we might already have a      suitable return insn.  If so put a label before it for the      end_of_function_label.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|BARRIER
operator|&&
name|GET_CODE
argument_list|(
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|RETURN
condition|)
block|{
name|rtx
name|temp
init|=
name|PREV_INSN
argument_list|(
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
decl_stmt|;
name|end_of_function_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|LABEL_NUSES
argument_list|(
name|end_of_function_label
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Put the label before an USE insns that may proceed the RETURN insn.  */
while|while
condition|(
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|==
name|USE
condition|)
name|temp
operator|=
name|PREV_INSN
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|emit_label_after
argument_list|(
name|end_of_function_label
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
condition|)
name|end_of_function_label
operator|=
name|insn
expr_stmt|;
else|else
block|{
name|end_of_function_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|LABEL_NUSES
argument_list|(
name|end_of_function_label
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* If the basic block reorder pass moves the return insn to 	 some other place try to locate it again and put our 	 end_of_function_label there.  */
while|while
condition|(
name|insn
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|RETURN
operator|)
operator|)
condition|)
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
condition|)
block|{
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Put the label before an USE insns that may proceed the 	     RETURN insn.  */
while|while
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|USE
condition|)
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|emit_label_after
argument_list|(
name|end_of_function_label
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Otherwise, make a new label and emit a RETURN and BARRIER, 	     if needed.  */
name|emit_label
argument_list|(
name|end_of_function_label
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_return
if|if
condition|(
name|HAVE_return
condition|)
block|{
comment|/* The return we make may have delay slots too.  */
name|rtx
name|insn
init|=
name|gen_return
argument_list|()
decl_stmt|;
name|insn
operator|=
name|emit_jump_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|emit_barrier
argument_list|()
expr_stmt|;
if|if
condition|(
name|num_delay_slots
argument_list|(
name|insn
argument_list|)
operator|>
literal|0
condition|)
name|obstack_ptr_grow
argument_list|(
operator|&
name|unfilled_slots_obstack
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
block|}
comment|/* Show one additional use for this label so it won't go away until      we are done.  */
operator|++
name|LABEL_NUSES
argument_list|(
name|end_of_function_label
argument_list|)
expr_stmt|;
return|return
name|end_of_function_label
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Put INSN and LIST together in a SEQUENCE rtx of LENGTH, and replace    the pattern of INSN with the SEQUENCE.     Chain the insns so that NEXT_INSN of each insn in the sequence points to    the next and NEXT_INSN of the last insn in the sequence points to    the first insn after the sequence.  Similarly for PREV_INSN.  This makes    it easier to scan all insns.     Returns the SEQUENCE that replaces INSN.  */
end_comment

begin_function
specifier|static
name|rtx
name|emit_delay_sequence
parameter_list|(
name|insn
parameter_list|,
name|list
parameter_list|,
name|length
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|rtx
name|list
decl_stmt|;
name|int
name|length
decl_stmt|;
block|{
name|int
name|i
init|=
literal|1
decl_stmt|;
name|rtx
name|li
decl_stmt|;
name|int
name|had_barrier
init|=
literal|0
decl_stmt|;
comment|/* Allocate the rtvec to hold the insns and the SEQUENCE.  */
name|rtvec
name|seqv
init|=
name|rtvec_alloc
argument_list|(
name|length
operator|+
literal|1
argument_list|)
decl_stmt|;
name|rtx
name|seq
init|=
name|gen_rtx_SEQUENCE
argument_list|(
name|VOIDmode
argument_list|,
name|seqv
argument_list|)
decl_stmt|;
name|rtx
name|seq_insn
init|=
name|make_insn_raw
argument_list|(
name|seq
argument_list|)
decl_stmt|;
name|rtx
name|first
init|=
name|get_insns
argument_list|()
decl_stmt|;
name|rtx
name|last
init|=
name|get_last_insn
argument_list|()
decl_stmt|;
comment|/* Make a copy of the insn having delay slots.  */
name|rtx
name|delay_insn
init|=
name|copy_rtx
argument_list|(
name|insn
argument_list|)
decl_stmt|;
comment|/* If INSN is followed by a BARRIER, delete the BARRIER since it will only      confuse further processing.  Update LAST in case it was the last insn.      We will put the BARRIER back in later.  */
if|if
condition|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|BARRIER
condition|)
block|{
name|delete_related_insns
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|last
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
name|had_barrier
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Splice our SEQUENCE into the insn stream where INSN used to be.  */
name|NEXT_INSN
argument_list|(
name|seq_insn
argument_list|)
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|PREV_INSN
argument_list|(
name|seq_insn
argument_list|)
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|!=
name|last
condition|)
name|PREV_INSN
argument_list|(
name|NEXT_INSN
argument_list|(
name|seq_insn
argument_list|)
argument_list|)
operator|=
name|seq_insn
expr_stmt|;
if|if
condition|(
name|insn
operator|!=
name|first
condition|)
name|NEXT_INSN
argument_list|(
name|PREV_INSN
argument_list|(
name|seq_insn
argument_list|)
argument_list|)
operator|=
name|seq_insn
expr_stmt|;
comment|/* Note the calls to set_new_first_and_last_insn must occur after      SEQ_INSN has been completely spliced into the insn stream.       Otherwise CUR_INSN_UID will get set to an incorrect value because      set_new_first_and_last_insn will not find SEQ_INSN in the chain.  */
if|if
condition|(
name|insn
operator|==
name|last
condition|)
name|set_new_first_and_last_insn
argument_list|(
name|first
argument_list|,
name|seq_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|==
name|first
condition|)
name|set_new_first_and_last_insn
argument_list|(
name|seq_insn
argument_list|,
name|last
argument_list|)
expr_stmt|;
comment|/* Build our SEQUENCE and rebuild the insn chain.  */
name|XVECEXP
argument_list|(
name|seq
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|=
name|delay_insn
expr_stmt|;
name|INSN_DELETED_P
argument_list|(
name|delay_insn
argument_list|)
operator|=
literal|0
expr_stmt|;
name|PREV_INSN
argument_list|(
name|delay_insn
argument_list|)
operator|=
name|PREV_INSN
argument_list|(
name|seq_insn
argument_list|)
expr_stmt|;
for|for
control|(
name|li
operator|=
name|list
init|;
name|li
condition|;
name|li
operator|=
name|XEXP
argument_list|(
name|li
argument_list|,
literal|1
argument_list|)
operator|,
name|i
operator|++
control|)
block|{
name|rtx
name|tem
init|=
name|XEXP
argument_list|(
name|li
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|note
decl_stmt|,
name|next
decl_stmt|;
comment|/* Show that this copy of the insn isn't deleted.  */
name|INSN_DELETED_P
argument_list|(
name|tem
argument_list|)
operator|=
literal|0
expr_stmt|;
name|XVECEXP
argument_list|(
name|seq
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
operator|=
name|tem
expr_stmt|;
name|PREV_INSN
argument_list|(
name|tem
argument_list|)
operator|=
name|XVECEXP
argument_list|(
name|seq
argument_list|,
literal|0
argument_list|,
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|XVECEXP
argument_list|(
name|seq
argument_list|,
literal|0
argument_list|,
name|i
operator|-
literal|1
argument_list|)
argument_list|)
operator|=
name|tem
expr_stmt|;
for|for
control|(
name|note
operator|=
name|REG_NOTES
argument_list|(
name|tem
argument_list|)
init|;
name|note
condition|;
name|note
operator|=
name|next
control|)
block|{
name|next
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
condition|)
block|{
case|case
name|REG_DEAD
case|:
comment|/* Remove any REG_DEAD notes because we can't rely on them now 		 that the insn has been moved.  */
name|remove_note
argument_list|(
name|tem
argument_list|,
name|note
argument_list|)
expr_stmt|;
break|break;
case|case
name|REG_LABEL
case|:
comment|/* Keep the label reference count up to date.  */
name|LABEL_NUSES
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|++
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
block|}
name|NEXT_INSN
argument_list|(
name|XVECEXP
argument_list|(
name|seq
argument_list|,
literal|0
argument_list|,
name|length
argument_list|)
argument_list|)
operator|=
name|NEXT_INSN
argument_list|(
name|seq_insn
argument_list|)
expr_stmt|;
comment|/* If the previous insn is a SEQUENCE, update the NEXT_INSN pointer on the      last insn in that SEQUENCE to point to us.  Similarly for the first      insn in the following insn if it is a SEQUENCE.  */
if|if
condition|(
name|PREV_INSN
argument_list|(
name|seq_insn
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|PREV_INSN
argument_list|(
name|seq_insn
argument_list|)
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|PREV_INSN
argument_list|(
name|seq_insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|SEQUENCE
condition|)
name|NEXT_INSN
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|PREV_INSN
argument_list|(
name|seq_insn
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|,
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|PREV_INSN
argument_list|(
name|seq_insn
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
argument_list|)
argument_list|)
operator|=
name|seq_insn
expr_stmt|;
if|if
condition|(
name|NEXT_INSN
argument_list|(
name|seq_insn
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|NEXT_INSN
argument_list|(
name|seq_insn
argument_list|)
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|NEXT_INSN
argument_list|(
name|seq_insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|SEQUENCE
condition|)
name|PREV_INSN
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|NEXT_INSN
argument_list|(
name|seq_insn
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|=
name|seq_insn
expr_stmt|;
comment|/* If there used to be a BARRIER, put it back.  */
if|if
condition|(
name|had_barrier
condition|)
name|emit_barrier_after
argument_list|(
name|seq_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|length
operator|+
literal|1
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|seq_insn
return|;
block|}
end_function

begin_comment
comment|/* Add INSN to DELAY_LIST and return the head of the new list.  The list must    be in the order in which the insns are to be executed.  */
end_comment

begin_function
specifier|static
name|rtx
name|add_to_delay_list
parameter_list|(
name|insn
parameter_list|,
name|delay_list
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|rtx
name|delay_list
decl_stmt|;
block|{
comment|/* If we have an empty list, just make a new list element.  If      INSN has its block number recorded, clear it since we may      be moving the insn to a new block.  */
if|if
condition|(
name|delay_list
operator|==
literal|0
condition|)
block|{
name|clear_hashed_info_for_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
return|return
name|gen_rtx_INSN_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|insn
argument_list|,
name|NULL_RTX
argument_list|)
return|;
block|}
comment|/* Otherwise this must be an INSN_LIST.  Add INSN to the end of the      list.  */
name|XEXP
argument_list|(
name|delay_list
argument_list|,
literal|1
argument_list|)
operator|=
name|add_to_delay_list
argument_list|(
name|insn
argument_list|,
name|XEXP
argument_list|(
name|delay_list
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|delay_list
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Delete INSN from the delay slot of the insn that it is in, which may    produce an insn with no delay slots.  Return the new insn.  */
end_comment

begin_function
specifier|static
name|rtx
name|delete_from_delay_slot
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|rtx
name|trial
decl_stmt|,
name|seq_insn
decl_stmt|,
name|seq
decl_stmt|,
name|prev
decl_stmt|;
name|rtx
name|delay_list
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* We first must find the insn containing the SEQUENCE with INSN in its      delay slot.  Do this by finding an insn, TRIAL, where      PREV_INSN (NEXT_INSN (TRIAL)) != TRIAL.  */
for|for
control|(
name|trial
operator|=
name|insn
init|;
name|PREV_INSN
argument_list|(
name|NEXT_INSN
argument_list|(
name|trial
argument_list|)
argument_list|)
operator|==
name|trial
condition|;
name|trial
operator|=
name|NEXT_INSN
argument_list|(
name|trial
argument_list|)
control|)
empty_stmt|;
name|seq_insn
operator|=
name|PREV_INSN
argument_list|(
name|NEXT_INSN
argument_list|(
name|trial
argument_list|)
argument_list|)
expr_stmt|;
name|seq
operator|=
name|PATTERN
argument_list|(
name|seq_insn
argument_list|)
expr_stmt|;
comment|/* Create a delay list consisting of all the insns other than the one      we are deleting (unless we were the only one).  */
if|if
condition|(
name|XVECLEN
argument_list|(
name|seq
argument_list|,
literal|0
argument_list|)
operator|>
literal|2
condition|)
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|seq
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|XVECEXP
argument_list|(
name|seq
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
operator|!=
name|insn
condition|)
name|delay_list
operator|=
name|add_to_delay_list
argument_list|(
name|XVECEXP
argument_list|(
name|seq
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|delay_list
argument_list|)
expr_stmt|;
comment|/* Delete the old SEQUENCE, re-emit the insn that used to have the delay      list, and rebuild the delay list if non-empty.  */
name|prev
operator|=
name|PREV_INSN
argument_list|(
name|seq_insn
argument_list|)
expr_stmt|;
name|trial
operator|=
name|XVECEXP
argument_list|(
name|seq
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|delete_related_insns
argument_list|(
name|seq_insn
argument_list|)
expr_stmt|;
name|add_insn_after
argument_list|(
name|trial
argument_list|,
name|prev
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|trial
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
operator|(
name|simplejump_p
argument_list|(
name|trial
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|trial
argument_list|)
argument_list|)
operator|==
name|RETURN
operator|)
condition|)
name|emit_barrier_after
argument_list|(
name|trial
argument_list|)
expr_stmt|;
comment|/* If there are any delay insns, remit them.  Otherwise clear the      annul flag.  */
if|if
condition|(
name|delay_list
condition|)
name|trial
operator|=
name|emit_delay_sequence
argument_list|(
name|trial
argument_list|,
name|delay_list
argument_list|,
name|XVECLEN
argument_list|(
name|seq
argument_list|,
literal|0
argument_list|)
operator|-
literal|2
argument_list|)
expr_stmt|;
else|else
name|INSN_ANNULLED_BRANCH_P
argument_list|(
name|trial
argument_list|)
operator|=
literal|0
expr_stmt|;
name|INSN_FROM_TARGET_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Show we need to fill this insn again.  */
name|obstack_ptr_grow
argument_list|(
operator|&
name|unfilled_slots_obstack
argument_list|,
name|trial
argument_list|)
expr_stmt|;
return|return
name|trial
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Delete INSN, a JUMP_INSN.  If it is a conditional jump, we must track down    the insn that sets CC0 for it and delete it too.  */
end_comment

begin_function
specifier|static
name|void
name|delete_scheduled_jump
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
comment|/* Delete the insn that sets cc0 for us.  On machines without cc0, we could      delete the insn that sets the condition code, but it is hard to find it.      Since this case is rare anyway, don't bother trying; there would likely      be other insns that became dead anyway, which we wouldn't know to      delete.  */
ifdef|#
directive|ifdef
name|HAVE_cc0
if|if
condition|(
name|reg_mentioned_p
argument_list|(
name|cc0_rtx
argument_list|,
name|insn
argument_list|)
condition|)
block|{
name|rtx
name|note
init|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_CC_SETTER
argument_list|,
name|NULL_RTX
argument_list|)
decl_stmt|;
comment|/* If a reg-note was found, it points to an insn to set CC0.  This 	 insn is in the delay list of some other insn.  So delete it from 	 the delay list it was in.  */
if|if
condition|(
name|note
condition|)
block|{
if|if
condition|(
operator|!
name|FIND_REG_INC_NOTE
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
operator|&&
name|sets_cc0_p
argument_list|(
name|PATTERN
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|1
condition|)
name|delete_from_delay_slot
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* The insn setting CC0 is our previous insn, but it may be in 	     a delay slot.  It will be the last insn in the delay slot, if 	     it is.  */
name|rtx
name|trial
init|=
name|previous_insn
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|trial
argument_list|)
operator|==
name|NOTE
condition|)
name|trial
operator|=
name|prev_nonnote_insn
argument_list|(
name|trial
argument_list|)
expr_stmt|;
if|if
condition|(
name|sets_cc0_p
argument_list|(
name|PATTERN
argument_list|(
name|trial
argument_list|)
argument_list|)
operator|!=
literal|1
operator|||
name|FIND_REG_INC_NOTE
argument_list|(
name|trial
argument_list|,
name|NULL_RTX
argument_list|)
condition|)
return|return;
if|if
condition|(
name|PREV_INSN
argument_list|(
name|NEXT_INSN
argument_list|(
name|trial
argument_list|)
argument_list|)
operator|==
name|trial
condition|)
name|delete_related_insns
argument_list|(
name|trial
argument_list|)
expr_stmt|;
else|else
name|delete_from_delay_slot
argument_list|(
name|trial
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|delete_related_insns
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Counters for delay-slot filling.  */
end_comment

begin_define
define|#
directive|define
name|NUM_REORG_FUNCTIONS
value|2
end_define

begin_define
define|#
directive|define
name|MAX_DELAY_HISTOGRAM
value|3
end_define

begin_define
define|#
directive|define
name|MAX_REORG_PASSES
value|2
end_define

begin_decl_stmt
specifier|static
name|int
name|num_insns_needing_delays
index|[
name|NUM_REORG_FUNCTIONS
index|]
index|[
name|MAX_REORG_PASSES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|num_filled_delays
index|[
name|NUM_REORG_FUNCTIONS
index|]
index|[
name|MAX_DELAY_HISTOGRAM
operator|+
literal|1
index|]
index|[
name|MAX_REORG_PASSES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|reorg_pass_number
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|note_delay_statistics
parameter_list|(
name|slots_filled
parameter_list|,
name|index
parameter_list|)
name|int
name|slots_filled
decl_stmt|,
name|index
decl_stmt|;
block|{
name|num_insns_needing_delays
index|[
name|index
index|]
index|[
name|reorg_pass_number
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|slots_filled
operator|>
name|MAX_DELAY_HISTOGRAM
condition|)
name|slots_filled
operator|=
name|MAX_DELAY_HISTOGRAM
expr_stmt|;
name|num_filled_delays
index|[
name|index
index|]
index|[
name|slots_filled
index|]
index|[
name|reorg_pass_number
index|]
operator|++
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_if
if|#
directive|if
name|defined
argument_list|(
name|ANNUL_IFFALSE_SLOTS
argument_list|)
operator|||
name|defined
argument_list|(
name|ANNUL_IFTRUE_SLOTS
argument_list|)
end_if

begin_comment
comment|/* Optimize the following cases:     1.  When a conditional branch skips over only one instruction,        use an annulling branch and put that insn in the delay slot.        Use either a branch that annuls when the condition if true or        invert the test with a branch that annuls when the condition is        false.  This saves insns, since otherwise we must copy an insn        from the L1 target.          (orig)		 (skip)		(otherwise) 	Bcc.n L1	Bcc',a L1	Bcc,a L1' 	insn		insn		insn2       L1:	      L1:	      L1: 	insn2		insn2		insn2 	insn3		insn3	      L1': 					insn3     2.  When a conditional branch skips over only one instruction,        and after that, it unconditionally branches somewhere else,        perform the similar optimization. This saves executing the        second branch in the case where the inverted condition is true.  	Bcc.n L1	Bcc',a L2 	insn		insn       L1:	      L1: 	Bra L2		Bra L2     INSN is a JUMP_INSN.     This should be expanded to skip over N insns, where N is the number    of delay slots required.  */
end_comment

begin_function
specifier|static
name|rtx
name|optimize_skip
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|rtx
name|trial
init|=
name|next_nonnote_insn
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|next_trial
init|=
name|next_active_insn
argument_list|(
name|trial
argument_list|)
decl_stmt|;
name|rtx
name|delay_list
init|=
literal|0
decl_stmt|;
name|rtx
name|target_label
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|flags
operator|=
name|get_jump_flags
argument_list|(
name|insn
argument_list|,
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|trial
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|trial
argument_list|)
operator|!=
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|trial
argument_list|)
argument_list|)
operator|==
name|SEQUENCE
operator|||
name|recog_memoized
argument_list|(
name|trial
argument_list|)
operator|<
literal|0
operator|||
operator|(
operator|!
name|eligible_for_annul_false
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|,
name|trial
argument_list|,
name|flags
argument_list|)
operator|&&
operator|!
name|eligible_for_annul_true
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|,
name|trial
argument_list|,
name|flags
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
comment|/* There are two cases where we are just executing one insn (we assume      here that a branch requires only one insn; this should be generalized      at some point):  Where the branch goes around a single insn or where      we have one insn followed by a branch to the same label we branch to.      In both of these cases, inverting the jump and annulling the delay      slot give the same effect in fewer insns.  */
if|if
condition|(
operator|(
name|next_trial
operator|==
name|next_active_insn
argument_list|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|&&
operator|!
operator|(
name|next_trial
operator|==
literal|0
operator|&&
name|current_function_epilogue_delay_list
operator|!=
literal|0
operator|)
operator|)
operator|||
operator|(
name|next_trial
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|next_trial
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_LABEL
argument_list|(
name|next_trial
argument_list|)
operator|&&
operator|(
name|simplejump_p
argument_list|(
name|next_trial
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|next_trial
argument_list|)
argument_list|)
operator|==
name|RETURN
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|eligible_for_annul_false
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|,
name|trial
argument_list|,
name|flags
argument_list|)
condition|)
block|{
if|if
condition|(
name|invert_jump
argument_list|(
name|insn
argument_list|,
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
name|INSN_FROM_TARGET_P
argument_list|(
name|trial
argument_list|)
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|eligible_for_annul_true
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|,
name|trial
argument_list|,
name|flags
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
name|delay_list
operator|=
name|add_to_delay_list
argument_list|(
name|trial
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|next_trial
operator|=
name|next_active_insn
argument_list|(
name|trial
argument_list|)
expr_stmt|;
name|update_block
argument_list|(
name|trial
argument_list|,
name|trial
argument_list|)
expr_stmt|;
name|delete_related_insns
argument_list|(
name|trial
argument_list|)
expr_stmt|;
comment|/* Also, if we are targeting an unconditional 	 branch, thread our jump to the target of that branch.  Don't 	 change this into a RETURN here, because it may not accept what 	 we have in the delay slot.  We'll fix this up later.  */
if|if
condition|(
name|next_trial
operator|&&
name|GET_CODE
argument_list|(
name|next_trial
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
operator|(
name|simplejump_p
argument_list|(
name|next_trial
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|next_trial
argument_list|)
argument_list|)
operator|==
name|RETURN
operator|)
condition|)
block|{
name|target_label
operator|=
name|JUMP_LABEL
argument_list|(
name|next_trial
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_label
operator|==
literal|0
condition|)
name|target_label
operator|=
name|find_end_label
argument_list|()
expr_stmt|;
comment|/* Recompute the flags based on TARGET_LABEL since threading 	     the jump to TARGET_LABEL may change the direction of the 	     jump (which may change the circumstances in which the 	     delay slot is nullified).  */
name|flags
operator|=
name|get_jump_flags
argument_list|(
name|insn
argument_list|,
name|target_label
argument_list|)
expr_stmt|;
if|if
condition|(
name|eligible_for_annul_true
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|,
name|trial
argument_list|,
name|flags
argument_list|)
condition|)
name|reorg_redirect_jump
argument_list|(
name|insn
argument_list|,
name|target_label
argument_list|)
expr_stmt|;
block|}
name|INSN_ANNULLED_BRANCH_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|delay_list
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/*  Encode and return branch direction and prediction information for     INSN assuming it will jump to LABEL.      Non conditional branches return no direction information and     are predicted as very likely taken.  */
end_comment

begin_function
specifier|static
name|int
name|get_jump_flags
parameter_list|(
name|insn
parameter_list|,
name|label
parameter_list|)
name|rtx
name|insn
decl_stmt|,
name|label
decl_stmt|;
block|{
name|int
name|flags
decl_stmt|;
comment|/* get_jump_flags can be passed any insn with delay slots, these may      be INSNs, CALL_INSNs, or JUMP_INSNs.  Only JUMP_INSNs have branch      direction information, and only if they are conditional jumps.       If LABEL is zero, then there is no way to determine the branch      direction.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
operator|(
name|condjump_p
argument_list|(
name|insn
argument_list|)
operator|||
name|condjump_in_parallel_p
argument_list|(
name|insn
argument_list|)
operator|)
operator|&&
name|INSN_UID
argument_list|(
name|insn
argument_list|)
operator|<=
name|max_uid
operator|&&
name|label
operator|!=
literal|0
operator|&&
name|INSN_UID
argument_list|(
name|label
argument_list|)
operator|<=
name|max_uid
condition|)
name|flags
operator|=
operator|(
name|uid_to_ruid
index|[
name|INSN_UID
argument_list|(
name|label
argument_list|)
index|]
operator|>
name|uid_to_ruid
index|[
name|INSN_UID
argument_list|(
name|insn
argument_list|)
index|]
operator|)
condition|?
name|ATTR_FLAG_forward
else|:
name|ATTR_FLAG_backward
expr_stmt|;
comment|/* No valid direction information.  */
else|else
name|flags
operator|=
literal|0
expr_stmt|;
comment|/* If insn is a conditional branch call mostly_true_jump to get      determine the branch prediction.       Non conditional branches are predicted as very likely taken.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
operator|(
name|condjump_p
argument_list|(
name|insn
argument_list|)
operator|||
name|condjump_in_parallel_p
argument_list|(
name|insn
argument_list|)
operator|)
condition|)
block|{
name|int
name|prediction
decl_stmt|;
name|prediction
operator|=
name|mostly_true_jump
argument_list|(
name|insn
argument_list|,
name|get_branch_condition
argument_list|(
name|insn
argument_list|,
name|label
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|prediction
condition|)
block|{
case|case
literal|2
case|:
name|flags
operator||=
operator|(
name|ATTR_FLAG_very_likely
operator||
name|ATTR_FLAG_likely
operator|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|flags
operator||=
name|ATTR_FLAG_likely
expr_stmt|;
break|break;
case|case
literal|0
case|:
name|flags
operator||=
name|ATTR_FLAG_unlikely
expr_stmt|;
break|break;
case|case
operator|-
literal|1
case|:
name|flags
operator||=
operator|(
name|ATTR_FLAG_very_unlikely
operator||
name|ATTR_FLAG_unlikely
operator|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
else|else
name|flags
operator||=
operator|(
name|ATTR_FLAG_very_likely
operator||
name|ATTR_FLAG_likely
operator|)
expr_stmt|;
return|return
name|flags
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if INSN is a destination that will be branched to rarely (the    return point of a function); return 2 if DEST will be branched to very    rarely (a call to a function that doesn't return).  Otherwise,    return 0.  */
end_comment

begin_function
specifier|static
name|int
name|rare_destination
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|int
name|jump_count
init|=
literal|0
decl_stmt|;
name|rtx
name|next
decl_stmt|;
for|for
control|(
init|;
name|insn
condition|;
name|insn
operator|=
name|next
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SEQUENCE
condition|)
name|insn
operator|=
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
condition|)
block|{
case|case
name|CODE_LABEL
case|:
return|return
literal|0
return|;
case|case
name|BARRIER
case|:
comment|/* A BARRIER can either be after a JUMP_INSN or a CALL_INSN.  We 	     don't scan past JUMP_INSNs, so any barrier we find here must 	     have been after a CALL_INSN and hence mean the call doesn't 	     return.  */
return|return
literal|2
return|;
case|case
name|JUMP_INSN
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|RETURN
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|simplejump_p
argument_list|(
name|insn
argument_list|)
operator|&&
name|jump_count
operator|++
operator|<
literal|10
condition|)
name|next
operator|=
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
expr_stmt|;
else|else
return|return
literal|0
return|;
default|default:
break|break;
block|}
block|}
comment|/* If we got here it means we hit the end of the function.  So this      is an unlikely destination.  */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return truth value of the statement that this branch    is mostly taken.  If we think that the branch is extremely likely    to be taken, we return 2.  If the branch is slightly more likely to be    taken, return 1.  If the branch is slightly less likely to be taken,    return 0 and if the branch is highly unlikely to be taken, return -1.     CONDITION, if non-zero, is the condition that JUMP_INSN is testing.  */
end_comment

begin_function
specifier|static
name|int
name|mostly_true_jump
parameter_list|(
name|jump_insn
parameter_list|,
name|condition
parameter_list|)
name|rtx
name|jump_insn
decl_stmt|,
name|condition
decl_stmt|;
block|{
name|rtx
name|target_label
init|=
name|JUMP_LABEL
argument_list|(
name|jump_insn
argument_list|)
decl_stmt|;
name|rtx
name|insn
decl_stmt|,
name|note
decl_stmt|;
name|int
name|rare_dest
init|=
name|rare_destination
argument_list|(
name|target_label
argument_list|)
decl_stmt|;
name|int
name|rare_fallthrough
init|=
name|rare_destination
argument_list|(
name|NEXT_INSN
argument_list|(
name|jump_insn
argument_list|)
argument_list|)
decl_stmt|;
comment|/* If branch probabilities are available, then use that number since it      always gives a correct answer.  */
name|note
operator|=
name|find_reg_note
argument_list|(
name|jump_insn
argument_list|,
name|REG_BR_PROB
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|note
condition|)
block|{
name|int
name|prob
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|prob
operator|>=
name|REG_BR_PROB_BASE
operator|*
literal|9
operator|/
literal|10
condition|)
return|return
literal|2
return|;
elseif|else
if|if
condition|(
name|prob
operator|>=
name|REG_BR_PROB_BASE
operator|/
literal|2
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|prob
operator|>=
name|REG_BR_PROB_BASE
operator|/
literal|10
condition|)
return|return
literal|0
return|;
else|else
return|return
operator|-
literal|1
return|;
block|}
comment|/* ??? Ought to use estimate_probability instead.  */
comment|/* If this is a branch outside a loop, it is highly unlikely.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|jump_insn
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|jump_insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|IF_THEN_ELSE
operator|&&
operator|(
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|jump_insn
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|&&
name|LABEL_OUTSIDE_LOOP_P
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|jump_insn
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|jump_insn
argument_list|)
argument_list|)
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|&&
name|LABEL_OUTSIDE_LOOP_P
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|jump_insn
argument_list|)
argument_list|)
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|target_label
condition|)
block|{
comment|/* If this is the test of a loop, it is very likely true.  We scan 	 backwards from the target label.  If we find a NOTE_INSN_LOOP_BEG 	 before the next real insn, we assume the branch is to the top of 	 the loop.  */
for|for
control|(
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|target_label
argument_list|)
init|;
name|insn
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_LOOP_BEG
condition|)
return|return
literal|2
return|;
comment|/* If this is a jump to the test of a loop, it is likely true.  We scan 	 forwards from the target label.  If we find a NOTE_INSN_LOOP_VTOP 	 before the next real insn, we assume the branch is to the loop branch 	 test.  */
for|for
control|(
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|target_label
argument_list|)
init|;
name|insn
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_LOOP_VTOP
condition|)
return|return
literal|1
return|;
block|}
comment|/* Look at the relative rarities of the fallthrough and destination.  If      they differ, we can predict the branch that way.  */
switch|switch
condition|(
name|rare_fallthrough
operator|-
name|rare_dest
condition|)
block|{
case|case
operator|-
literal|2
case|:
return|return
operator|-
literal|1
return|;
case|case
operator|-
literal|1
case|:
return|return
literal|0
return|;
case|case
literal|0
case|:
break|break;
case|case
literal|1
case|:
return|return
literal|1
return|;
case|case
literal|2
case|:
return|return
literal|2
return|;
block|}
comment|/* If we couldn't figure out what this jump was, assume it won't be      taken.  This should be rare.  */
if|if
condition|(
name|condition
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* EQ tests are usually false and NE tests are usually true.  Also,      most quantities are positive, so we can make the appropriate guesses      about signed comparisons against zero.  */
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|condition
argument_list|)
condition|)
block|{
case|case
name|CONST_INT
case|:
comment|/* Unconditional branch.  */
return|return
literal|1
return|;
case|case
name|EQ
case|:
return|return
literal|0
return|;
case|case
name|NE
case|:
return|return
literal|1
return|;
case|case
name|LE
case|:
case|case
name|LT
case|:
if|if
condition|(
name|XEXP
argument_list|(
name|condition
argument_list|,
literal|1
argument_list|)
operator|==
name|const0_rtx
condition|)
return|return
literal|0
return|;
break|break;
case|case
name|GE
case|:
case|case
name|GT
case|:
if|if
condition|(
name|XEXP
argument_list|(
name|condition
argument_list|,
literal|1
argument_list|)
operator|==
name|const0_rtx
condition|)
return|return
literal|1
return|;
break|break;
default|default:
break|break;
block|}
comment|/* Predict backward branches usually take, forward branches usually not.  If      we don't know whether this is forward or backward, assume the branch      will be taken, since most are.  */
return|return
operator|(
name|target_label
operator|==
literal|0
operator|||
name|INSN_UID
argument_list|(
name|jump_insn
argument_list|)
operator|>
name|max_uid
operator|||
name|INSN_UID
argument_list|(
name|target_label
argument_list|)
operator|>
name|max_uid
operator|||
operator|(
name|uid_to_ruid
index|[
name|INSN_UID
argument_list|(
name|jump_insn
argument_list|)
index|]
operator|>
name|uid_to_ruid
index|[
name|INSN_UID
argument_list|(
name|target_label
argument_list|)
index|]
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the condition under which INSN will branch to TARGET.  If TARGET    is zero, return the condition under which INSN will return.  If INSN is    an unconditional branch, return const_true_rtx.  If INSN isn't a simple    type of jump, or it doesn't go to TARGET, return 0.  */
end_comment

begin_function
specifier|static
name|rtx
name|get_branch_condition
parameter_list|(
name|insn
parameter_list|,
name|target
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|rtx
name|target
decl_stmt|;
block|{
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|src
decl_stmt|;
if|if
condition|(
name|condjump_in_parallel_p
argument_list|(
name|insn
argument_list|)
condition|)
name|pat
operator|=
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|RETURN
condition|)
return|return
name|target
operator|==
literal|0
condition|?
name|const_true_rtx
else|:
literal|0
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|!=
name|SET
operator|||
name|SET_DEST
argument_list|(
name|pat
argument_list|)
operator|!=
name|pc_rtx
condition|)
return|return
literal|0
return|;
name|src
operator|=
name|SET_SRC
argument_list|(
name|pat
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|LABEL_REF
operator|&&
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
operator|==
name|target
condition|)
return|return
name|const_true_rtx
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|IF_THEN_ELSE
operator|&&
operator|(
operator|(
name|target
operator|==
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|RETURN
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|&&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|target
operator|)
operator|)
operator|&&
name|XEXP
argument_list|(
name|src
argument_list|,
literal|2
argument_list|)
operator|==
name|pc_rtx
condition|)
return|return
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|IF_THEN_ELSE
operator|&&
operator|(
operator|(
name|target
operator|==
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|==
name|RETURN
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|&&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|2
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|target
operator|)
operator|)
operator|&&
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
operator|==
name|pc_rtx
condition|)
return|return
name|gen_rtx_fmt_ee
argument_list|(
name|reverse_condition
argument_list|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return non-zero if CONDITION is more strict than the condition of    INSN, i.e., if INSN will always branch if CONDITION is true.  */
end_comment

begin_function
specifier|static
name|int
name|condition_dominates_p
parameter_list|(
name|condition
parameter_list|,
name|insn
parameter_list|)
name|rtx
name|condition
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
name|rtx
name|other_condition
init|=
name|get_branch_condition
argument_list|(
name|insn
argument_list|,
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
argument_list|)
decl_stmt|;
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|condition
argument_list|)
decl_stmt|;
name|enum
name|rtx_code
name|other_code
decl_stmt|;
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|condition
argument_list|,
name|other_condition
argument_list|)
operator|||
name|other_condition
operator|==
name|const_true_rtx
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|condition
operator|==
name|const_true_rtx
operator|||
name|other_condition
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|other_code
operator|=
name|GET_CODE
argument_list|(
name|other_condition
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|!=
literal|2
operator|||
name|GET_RTX_LENGTH
argument_list|(
name|other_code
argument_list|)
operator|!=
literal|2
operator|||
operator|!
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|condition
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|other_condition
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
operator|!
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|condition
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|other_condition
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|comparison_dominates_p
argument_list|(
name|code
argument_list|,
name|other_code
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return non-zero if redirecting JUMP to NEWLABEL does not invalidate    any insns already in the delay slot of JUMP.  */
end_comment

begin_function
specifier|static
name|int
name|redirect_with_delay_slots_safe_p
parameter_list|(
name|jump
parameter_list|,
name|newlabel
parameter_list|,
name|seq
parameter_list|)
name|rtx
name|jump
decl_stmt|,
name|newlabel
decl_stmt|,
name|seq
decl_stmt|;
block|{
name|int
name|flags
decl_stmt|,
name|i
decl_stmt|;
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|seq
argument_list|)
decl_stmt|;
comment|/* Make sure all the delay slots of this jump would still      be valid after threading the jump.  If they are still      valid, then return non-zero.  */
name|flags
operator|=
name|get_jump_flags
argument_list|(
name|jump
argument_list|,
name|newlabel
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
operator|(
ifdef|#
directive|ifdef
name|ANNUL_IFFALSE_SLOTS
operator|(
name|INSN_ANNULLED_BRANCH_P
argument_list|(
name|jump
argument_list|)
operator|&&
name|INSN_FROM_TARGET_P
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|)
condition|?
name|eligible_for_annul_false
argument_list|(
name|jump
argument_list|,
name|i
operator|-
literal|1
argument_list|,
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|flags
argument_list|)
else|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ANNUL_IFTRUE_SLOTS
operator|(
name|INSN_ANNULLED_BRANCH_P
argument_list|(
name|jump
argument_list|)
operator|&&
operator|!
name|INSN_FROM_TARGET_P
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|)
condition|?
name|eligible_for_annul_true
argument_list|(
name|jump
argument_list|,
name|i
operator|-
literal|1
argument_list|,
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|flags
argument_list|)
else|:
endif|#
directive|endif
name|eligible_for_delay
argument_list|(
name|jump
argument_list|,
name|i
operator|-
literal|1
argument_list|,
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|flags
argument_list|)
operator|)
condition|)
break|break;
return|return
operator|(
name|i
operator|==
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return non-zero if redirecting JUMP to NEWLABEL does not invalidate    any insns we wish to place in the delay slot of JUMP.  */
end_comment

begin_function
specifier|static
name|int
name|redirect_with_delay_list_safe_p
parameter_list|(
name|jump
parameter_list|,
name|newlabel
parameter_list|,
name|delay_list
parameter_list|)
name|rtx
name|jump
decl_stmt|,
name|newlabel
decl_stmt|,
name|delay_list
decl_stmt|;
block|{
name|int
name|flags
decl_stmt|,
name|i
decl_stmt|;
name|rtx
name|li
decl_stmt|;
comment|/* Make sure all the insns in DELAY_LIST would still be      valid after threading the jump.  If they are still      valid, then return non-zero.  */
name|flags
operator|=
name|get_jump_flags
argument_list|(
name|jump
argument_list|,
name|newlabel
argument_list|)
expr_stmt|;
for|for
control|(
name|li
operator|=
name|delay_list
operator|,
name|i
operator|=
literal|0
init|;
name|li
condition|;
name|li
operator|=
name|XEXP
argument_list|(
name|li
argument_list|,
literal|1
argument_list|)
operator|,
name|i
operator|++
control|)
if|if
condition|(
operator|!
operator|(
ifdef|#
directive|ifdef
name|ANNUL_IFFALSE_SLOTS
operator|(
name|INSN_ANNULLED_BRANCH_P
argument_list|(
name|jump
argument_list|)
operator|&&
name|INSN_FROM_TARGET_P
argument_list|(
name|XEXP
argument_list|(
name|li
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
condition|?
name|eligible_for_annul_false
argument_list|(
name|jump
argument_list|,
name|i
argument_list|,
name|XEXP
argument_list|(
name|li
argument_list|,
literal|0
argument_list|)
argument_list|,
name|flags
argument_list|)
else|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ANNUL_IFTRUE_SLOTS
operator|(
name|INSN_ANNULLED_BRANCH_P
argument_list|(
name|jump
argument_list|)
operator|&&
operator|!
name|INSN_FROM_TARGET_P
argument_list|(
name|XEXP
argument_list|(
name|li
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
condition|?
name|eligible_for_annul_true
argument_list|(
name|jump
argument_list|,
name|i
argument_list|,
name|XEXP
argument_list|(
name|li
argument_list|,
literal|0
argument_list|)
argument_list|,
name|flags
argument_list|)
else|:
endif|#
directive|endif
name|eligible_for_delay
argument_list|(
name|jump
argument_list|,
name|i
argument_list|,
name|XEXP
argument_list|(
name|li
argument_list|,
literal|0
argument_list|)
argument_list|,
name|flags
argument_list|)
operator|)
condition|)
break|break;
return|return
operator|(
name|li
operator|==
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* DELAY_LIST is a list of insns that have already been placed into delay    slots.  See if all of them have the same annulling status as ANNUL_TRUE_P.    If not, return 0; otherwise return 1.  */
end_comment

begin_function
specifier|static
name|int
name|check_annul_list_true_false
parameter_list|(
name|annul_true_p
parameter_list|,
name|delay_list
parameter_list|)
name|int
name|annul_true_p
decl_stmt|;
name|rtx
name|delay_list
decl_stmt|;
block|{
name|rtx
name|temp
decl_stmt|;
if|if
condition|(
name|delay_list
condition|)
block|{
for|for
control|(
name|temp
operator|=
name|delay_list
init|;
name|temp
condition|;
name|temp
operator|=
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|rtx
name|trial
init|=
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|annul_true_p
operator|&&
name|INSN_FROM_TARGET_P
argument_list|(
name|trial
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|annul_true_p
operator|&&
operator|!
name|INSN_FROM_TARGET_P
argument_list|(
name|trial
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* INSN branches to an insn whose pattern SEQ is a SEQUENCE.  Given that    the condition tested by INSN is CONDITION and the resources shown in    OTHER_NEEDED are needed after INSN, see whether INSN can take all the insns    from SEQ's delay list, in addition to whatever insns it may execute    (in DELAY_LIST).   SETS and NEEDED are denote resources already set and    needed while searching for delay slot insns.  Return the concatenated    delay list if possible, otherwise, return 0.     SLOTS_TO_FILL is the total number of slots required by INSN, and    PSLOTS_FILLED points to the number filled so far (also the number of    insns in DELAY_LIST).  It is updated with the number that have been    filled from the SEQUENCE, if any.     PANNUL_P points to a non-zero value if we already know that we need    to annul INSN.  If this routine determines that annulling is needed,    it may set that value non-zero.     PNEW_THREAD points to a location that is to receive the place at which    execution should continue.  */
end_comment

begin_function
specifier|static
name|rtx
name|steal_delay_list_from_target
parameter_list|(
name|insn
parameter_list|,
name|condition
parameter_list|,
name|seq
parameter_list|,
name|delay_list
parameter_list|,
name|sets
parameter_list|,
name|needed
parameter_list|,
name|other_needed
parameter_list|,
name|slots_to_fill
parameter_list|,
name|pslots_filled
parameter_list|,
name|pannul_p
parameter_list|,
name|pnew_thread
parameter_list|)
name|rtx
name|insn
decl_stmt|,
name|condition
decl_stmt|;
name|rtx
name|seq
decl_stmt|;
name|rtx
name|delay_list
decl_stmt|;
name|struct
name|resources
modifier|*
name|sets
decl_stmt|,
decl|*
name|needed
decl_stmt|,
modifier|*
name|other_needed
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|slots_to_fill
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|pslots_filled
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|pannul_p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
modifier|*
name|pnew_thread
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|rtx
name|temp
decl_stmt|;
name|int
name|slots_remaining
init|=
name|slots_to_fill
operator|-
operator|*
name|pslots_filled
decl_stmt|;
name|int
name|total_slots_filled
init|=
operator|*
name|pslots_filled
decl_stmt|;
name|rtx
name|new_delay_list
init|=
literal|0
decl_stmt|;
name|int
name|must_annul
init|=
operator|*
name|pannul_p
decl_stmt|;
name|int
name|used_annul
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|resources
name|cc_set
decl_stmt|;
comment|/* We can't do anything if there are more delay slots in SEQ than we      can handle, or if we don't know that it will be a taken branch.      We know that it will be a taken branch if it is either an unconditional      branch or a conditional branch with a stricter branch condition.       Also, exit if the branch has more than one set, since then it is computing      other results that can't be ignored, e.g. the HPPA mov&branch instruction.      ??? It may be possible to move other sets into INSN in addition to      moving the instructions in the delay slots.       We can not steal the delay list if one of the instructions in the      current delay_list modifies the condition codes and the jump in the      sequence is a conditional jump. We can not do this because we can      not change the direction of the jump because the condition codes      will effect the direction of the jump in the sequence.  */
name|CLEAR_RESOURCE
argument_list|(
operator|&
name|cc_set
argument_list|)
expr_stmt|;
for|for
control|(
name|temp
operator|=
name|delay_list
init|;
name|temp
condition|;
name|temp
operator|=
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|rtx
name|trial
init|=
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|mark_set_resources
argument_list|(
name|trial
argument_list|,
operator|&
name|cc_set
argument_list|,
literal|0
argument_list|,
name|MARK_SRC_DEST_CALL
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn_references_resource_p
argument_list|(
name|XVECEXP
argument_list|(
name|seq
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|cc_set
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|delay_list
return|;
block|}
if|if
condition|(
name|XVECLEN
argument_list|(
name|seq
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
operator|>
name|slots_remaining
operator|||
operator|!
name|condition_dominates_p
argument_list|(
name|condition
argument_list|,
name|XVECEXP
argument_list|(
name|seq
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
operator|!
name|single_set
argument_list|(
name|XVECEXP
argument_list|(
name|seq
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|delay_list
return|;
ifdef|#
directive|ifdef
name|MD_CAN_REDIRECT_BRANCH
comment|/* On some targets, branches with delay slots can have a limited      displacement.  Give the back end a chance to tell us we can't do      this.  */
if|if
condition|(
operator|!
name|MD_CAN_REDIRECT_BRANCH
argument_list|(
name|insn
argument_list|,
name|XVECEXP
argument_list|(
name|seq
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|delay_list
return|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|seq
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|trial
init|=
name|XVECEXP
argument_list|(
name|seq
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|int
name|flags
decl_stmt|;
if|if
condition|(
name|insn_references_resource_p
argument_list|(
name|trial
argument_list|,
name|sets
argument_list|,
literal|0
argument_list|)
operator|||
name|insn_sets_resource_p
argument_list|(
name|trial
argument_list|,
name|needed
argument_list|,
literal|0
argument_list|)
operator|||
name|insn_sets_resource_p
argument_list|(
name|trial
argument_list|,
name|sets
argument_list|,
literal|0
argument_list|)
ifdef|#
directive|ifdef
name|HAVE_cc0
comment|/* If TRIAL sets CC0, we can't copy it, so we can't steal this 	     delay list.  */
operator|||
name|find_reg_note
argument_list|(
name|trial
argument_list|,
name|REG_CC_USER
argument_list|,
name|NULL_RTX
argument_list|)
endif|#
directive|endif
comment|/* If TRIAL is from the fallthrough code of an annulled branch insn 	     in SEQ, we cannot use it.  */
operator|||
operator|(
name|INSN_ANNULLED_BRANCH_P
argument_list|(
name|XVECEXP
argument_list|(
name|seq
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
operator|!
name|INSN_FROM_TARGET_P
argument_list|(
name|trial
argument_list|)
operator|)
condition|)
return|return
name|delay_list
return|;
comment|/* If this insn was already done (usually in a previous delay slot), 	 pretend we put it in our delay slot.  */
if|if
condition|(
name|redundant_insn
argument_list|(
name|trial
argument_list|,
name|insn
argument_list|,
name|new_delay_list
argument_list|)
condition|)
continue|continue;
comment|/* We will end up re-vectoring this branch, so compute flags 	 based on jumping to the new label.  */
name|flags
operator|=
name|get_jump_flags
argument_list|(
name|insn
argument_list|,
name|JUMP_LABEL
argument_list|(
name|XVECEXP
argument_list|(
name|seq
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|must_annul
operator|&&
operator|(
operator|(
name|condition
operator|==
name|const_true_rtx
operator|||
operator|(
operator|!
name|insn_sets_resource_p
argument_list|(
name|trial
argument_list|,
name|other_needed
argument_list|,
literal|0
argument_list|)
operator|&&
operator|!
name|may_trap_p
argument_list|(
name|PATTERN
argument_list|(
name|trial
argument_list|)
argument_list|)
operator|)
operator|)
operator|)
condition|?
name|eligible_for_delay
argument_list|(
name|insn
argument_list|,
name|total_slots_filled
argument_list|,
name|trial
argument_list|,
name|flags
argument_list|)
else|:
operator|(
name|must_annul
operator|||
operator|(
name|delay_list
operator|==
name|NULL
operator|&&
name|new_delay_list
operator|==
name|NULL
operator|)
operator|)
operator|&&
operator|(
name|must_annul
operator|=
literal|1
operator|,
name|check_annul_list_true_false
argument_list|(
literal|0
argument_list|,
name|delay_list
argument_list|)
operator|&&
name|check_annul_list_true_false
argument_list|(
literal|0
argument_list|,
name|new_delay_list
argument_list|)
operator|&&
name|eligible_for_annul_false
argument_list|(
name|insn
argument_list|,
name|total_slots_filled
argument_list|,
name|trial
argument_list|,
name|flags
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|must_annul
condition|)
name|used_annul
operator|=
literal|1
expr_stmt|;
name|temp
operator|=
name|copy_rtx
argument_list|(
name|trial
argument_list|)
expr_stmt|;
name|INSN_FROM_TARGET_P
argument_list|(
name|temp
argument_list|)
operator|=
literal|1
expr_stmt|;
name|new_delay_list
operator|=
name|add_to_delay_list
argument_list|(
name|temp
argument_list|,
name|new_delay_list
argument_list|)
expr_stmt|;
name|total_slots_filled
operator|++
expr_stmt|;
if|if
condition|(
operator|--
name|slots_remaining
operator|==
literal|0
condition|)
break|break;
block|}
else|else
return|return
name|delay_list
return|;
block|}
comment|/* Show the place to which we will be branching.  */
operator|*
name|pnew_thread
operator|=
name|next_active_insn
argument_list|(
name|JUMP_LABEL
argument_list|(
name|XVECEXP
argument_list|(
name|seq
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Add any new insns to the delay list and update the count of the      number of slots filled.  */
operator|*
name|pslots_filled
operator|=
name|total_slots_filled
expr_stmt|;
if|if
condition|(
name|used_annul
condition|)
operator|*
name|pannul_p
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|delay_list
operator|==
literal|0
condition|)
return|return
name|new_delay_list
return|;
for|for
control|(
name|temp
operator|=
name|new_delay_list
init|;
name|temp
condition|;
name|temp
operator|=
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|1
argument_list|)
control|)
name|delay_list
operator|=
name|add_to_delay_list
argument_list|(
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|delay_list
argument_list|)
expr_stmt|;
return|return
name|delay_list
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Similar to steal_delay_list_from_target except that SEQ is on the    fallthrough path of INSN.  Here we only do something if the delay insn    of SEQ is an unconditional branch.  In that case we steal its delay slot    for INSN since unconditional branches are much easier to fill.  */
end_comment

begin_function
specifier|static
name|rtx
name|steal_delay_list_from_fallthrough
parameter_list|(
name|insn
parameter_list|,
name|condition
parameter_list|,
name|seq
parameter_list|,
name|delay_list
parameter_list|,
name|sets
parameter_list|,
name|needed
parameter_list|,
name|other_needed
parameter_list|,
name|slots_to_fill
parameter_list|,
name|pslots_filled
parameter_list|,
name|pannul_p
parameter_list|)
name|rtx
name|insn
decl_stmt|,
name|condition
decl_stmt|;
name|rtx
name|seq
decl_stmt|;
name|rtx
name|delay_list
decl_stmt|;
name|struct
name|resources
modifier|*
name|sets
decl_stmt|,
decl|*
name|needed
decl_stmt|,
modifier|*
name|other_needed
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|slots_to_fill
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|pslots_filled
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|pannul_p
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|int
name|must_annul
init|=
operator|*
name|pannul_p
decl_stmt|;
name|int
name|used_annul
init|=
literal|0
decl_stmt|;
name|flags
operator|=
name|get_jump_flags
argument_list|(
name|insn
argument_list|,
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We can't do anything if SEQ's delay insn isn't an      unconditional branch.  */
if|if
condition|(
operator|!
name|simplejump_p
argument_list|(
name|XVECEXP
argument_list|(
name|seq
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|XVECEXP
argument_list|(
name|seq
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|RETURN
condition|)
return|return
name|delay_list
return|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|seq
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|trial
init|=
name|XVECEXP
argument_list|(
name|seq
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
comment|/* If TRIAL sets CC0, stealing it will move it too far from the use 	 of CC0.  */
if|if
condition|(
name|insn_references_resource_p
argument_list|(
name|trial
argument_list|,
name|sets
argument_list|,
literal|0
argument_list|)
operator|||
name|insn_sets_resource_p
argument_list|(
name|trial
argument_list|,
name|needed
argument_list|,
literal|0
argument_list|)
operator|||
name|insn_sets_resource_p
argument_list|(
name|trial
argument_list|,
name|sets
argument_list|,
literal|0
argument_list|)
ifdef|#
directive|ifdef
name|HAVE_cc0
operator|||
name|sets_cc0_p
argument_list|(
name|PATTERN
argument_list|(
name|trial
argument_list|)
argument_list|)
endif|#
directive|endif
condition|)
break|break;
comment|/* If this insn was already done, we don't need it.  */
if|if
condition|(
name|redundant_insn
argument_list|(
name|trial
argument_list|,
name|insn
argument_list|,
name|delay_list
argument_list|)
condition|)
block|{
name|delete_from_delay_slot
argument_list|(
name|trial
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|must_annul
operator|&&
operator|(
operator|(
name|condition
operator|==
name|const_true_rtx
operator|||
operator|(
operator|!
name|insn_sets_resource_p
argument_list|(
name|trial
argument_list|,
name|other_needed
argument_list|,
literal|0
argument_list|)
operator|&&
operator|!
name|may_trap_p
argument_list|(
name|PATTERN
argument_list|(
name|trial
argument_list|)
argument_list|)
operator|)
operator|)
operator|)
condition|?
name|eligible_for_delay
argument_list|(
name|insn
argument_list|,
operator|*
name|pslots_filled
argument_list|,
name|trial
argument_list|,
name|flags
argument_list|)
else|:
operator|(
name|must_annul
operator|||
name|delay_list
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|must_annul
operator|=
literal|1
operator|,
name|check_annul_list_true_false
argument_list|(
literal|1
argument_list|,
name|delay_list
argument_list|)
operator|&&
name|eligible_for_annul_true
argument_list|(
name|insn
argument_list|,
operator|*
name|pslots_filled
argument_list|,
name|trial
argument_list|,
name|flags
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|must_annul
condition|)
name|used_annul
operator|=
literal|1
expr_stmt|;
name|delete_from_delay_slot
argument_list|(
name|trial
argument_list|)
expr_stmt|;
name|delay_list
operator|=
name|add_to_delay_list
argument_list|(
name|trial
argument_list|,
name|delay_list
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
operator|(
operator|*
name|pslots_filled
operator|)
operator|==
name|slots_to_fill
condition|)
break|break;
block|}
else|else
break|break;
block|}
if|if
condition|(
name|used_annul
condition|)
operator|*
name|pannul_p
operator|=
literal|1
expr_stmt|;
return|return
name|delay_list
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Try merging insns starting at THREAD which match exactly the insns in    INSN's delay list.     If all insns were matched and the insn was previously annulling, the    annul bit will be cleared.     For each insn that is merged, if the branch is or will be non-annulling,    we delete the merged insn.  */
end_comment

begin_function
specifier|static
name|void
name|try_merge_delay_insns
parameter_list|(
name|insn
parameter_list|,
name|thread
parameter_list|)
name|rtx
name|insn
decl_stmt|,
name|thread
decl_stmt|;
block|{
name|rtx
name|trial
decl_stmt|,
name|next_trial
decl_stmt|;
name|rtx
name|delay_insn
init|=
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|annul_p
init|=
name|INSN_ANNULLED_BRANCH_P
argument_list|(
name|delay_insn
argument_list|)
decl_stmt|;
name|int
name|slot_number
init|=
literal|1
decl_stmt|;
name|int
name|num_slots
init|=
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|next_to_match
init|=
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|slot_number
argument_list|)
decl_stmt|;
name|struct
name|resources
name|set
decl_stmt|,
name|needed
decl_stmt|;
name|rtx
name|merged_insns
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|flags
operator|=
name|get_jump_flags
argument_list|(
name|delay_insn
argument_list|,
name|JUMP_LABEL
argument_list|(
name|delay_insn
argument_list|)
argument_list|)
expr_stmt|;
name|CLEAR_RESOURCE
argument_list|(
operator|&
name|needed
argument_list|)
expr_stmt|;
name|CLEAR_RESOURCE
argument_list|(
operator|&
name|set
argument_list|)
expr_stmt|;
comment|/* If this is not an annulling branch, take into account anything needed in      INSN's delay slot.  This prevents two increments from being incorrectly      folded into one.  If we are annulling, this would be the correct      thing to do.  (The alternative, looking at things set in NEXT_TO_MATCH      will essentially disable this optimization.  This method is somewhat of      a kludge, but I don't see a better way.)  */
if|if
condition|(
operator|!
name|annul_p
condition|)
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|num_slots
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
condition|)
name|mark_referenced_resources
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
operator|&
name|needed
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|trial
operator|=
name|thread
init|;
operator|!
name|stop_search_p
argument_list|(
name|trial
argument_list|,
literal|1
argument_list|)
condition|;
name|trial
operator|=
name|next_trial
control|)
block|{
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|trial
argument_list|)
decl_stmt|;
name|rtx
name|oldtrial
init|=
name|trial
decl_stmt|;
name|next_trial
operator|=
name|next_nonnote_insn
argument_list|(
name|trial
argument_list|)
expr_stmt|;
comment|/* TRIAL must be a CALL_INSN or INSN.  Skip USE and CLOBBER.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|trial
argument_list|)
operator|==
name|INSN
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|USE
operator|||
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|CLOBBER
operator|)
condition|)
continue|continue;
if|if
condition|(
name|GET_CODE
argument_list|(
name|next_to_match
argument_list|)
operator|==
name|GET_CODE
argument_list|(
name|trial
argument_list|)
ifdef|#
directive|ifdef
name|HAVE_cc0
comment|/* We can't share an insn that sets cc0.  */
operator|&&
operator|!
name|sets_cc0_p
argument_list|(
name|pat
argument_list|)
endif|#
directive|endif
operator|&&
operator|!
name|insn_references_resource_p
argument_list|(
name|trial
argument_list|,
operator|&
name|set
argument_list|,
literal|1
argument_list|)
operator|&&
operator|!
name|insn_sets_resource_p
argument_list|(
name|trial
argument_list|,
operator|&
name|set
argument_list|,
literal|1
argument_list|)
operator|&&
operator|!
name|insn_sets_resource_p
argument_list|(
name|trial
argument_list|,
operator|&
name|needed
argument_list|,
literal|1
argument_list|)
operator|&&
operator|(
name|trial
operator|=
name|try_split
argument_list|(
name|pat
argument_list|,
name|trial
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
comment|/* Update next_trial, in case try_split succeeded.  */
operator|&&
operator|(
name|next_trial
operator|=
name|next_nonnote_insn
argument_list|(
name|trial
argument_list|)
operator|)
comment|/* Likewise THREAD.  */
operator|&&
operator|(
name|thread
operator|=
name|oldtrial
operator|==
name|thread
condition|?
name|trial
else|:
name|thread
operator|)
operator|&&
name|rtx_equal_p
argument_list|(
name|PATTERN
argument_list|(
name|next_to_match
argument_list|)
argument_list|,
name|PATTERN
argument_list|(
name|trial
argument_list|)
argument_list|)
comment|/* Have to test this condition if annul condition is different 	     from (and less restrictive than) non-annulling one.  */
operator|&&
name|eligible_for_delay
argument_list|(
name|delay_insn
argument_list|,
name|slot_number
operator|-
literal|1
argument_list|,
name|trial
argument_list|,
name|flags
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|annul_p
condition|)
block|{
name|update_block
argument_list|(
name|trial
argument_list|,
name|thread
argument_list|)
expr_stmt|;
if|if
condition|(
name|trial
operator|==
name|thread
condition|)
name|thread
operator|=
name|next_active_insn
argument_list|(
name|thread
argument_list|)
expr_stmt|;
name|delete_related_insns
argument_list|(
name|trial
argument_list|)
expr_stmt|;
name|INSN_FROM_TARGET_P
argument_list|(
name|next_to_match
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|merged_insns
operator|=
name|gen_rtx_INSN_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|trial
argument_list|,
name|merged_insns
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|slot_number
operator|==
name|num_slots
condition|)
break|break;
name|next_to_match
operator|=
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|slot_number
argument_list|)
expr_stmt|;
block|}
name|mark_set_resources
argument_list|(
name|trial
argument_list|,
operator|&
name|set
argument_list|,
literal|0
argument_list|,
name|MARK_SRC_DEST_CALL
argument_list|)
expr_stmt|;
name|mark_referenced_resources
argument_list|(
name|trial
argument_list|,
operator|&
name|needed
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* See if we stopped on a filled insn.  If we did, try to see if its      delay slots match.  */
if|if
condition|(
name|slot_number
operator|!=
name|num_slots
operator|&&
name|trial
operator|&&
name|GET_CODE
argument_list|(
name|trial
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|trial
argument_list|)
argument_list|)
operator|==
name|SEQUENCE
operator|&&
operator|!
name|INSN_ANNULLED_BRANCH_P
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|trial
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|trial
argument_list|)
decl_stmt|;
name|rtx
name|filled_insn
init|=
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* Account for resources set/needed by the filled insn.  */
name|mark_set_resources
argument_list|(
name|filled_insn
argument_list|,
operator|&
name|set
argument_list|,
literal|0
argument_list|,
name|MARK_SRC_DEST_CALL
argument_list|)
expr_stmt|;
name|mark_referenced_resources
argument_list|(
name|filled_insn
argument_list|,
operator|&
name|needed
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|dtrial
init|=
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|insn_references_resource_p
argument_list|(
name|dtrial
argument_list|,
operator|&
name|set
argument_list|,
literal|1
argument_list|)
operator|&&
operator|!
name|insn_sets_resource_p
argument_list|(
name|dtrial
argument_list|,
operator|&
name|set
argument_list|,
literal|1
argument_list|)
operator|&&
operator|!
name|insn_sets_resource_p
argument_list|(
name|dtrial
argument_list|,
operator|&
name|needed
argument_list|,
literal|1
argument_list|)
ifdef|#
directive|ifdef
name|HAVE_cc0
operator|&&
operator|!
name|sets_cc0_p
argument_list|(
name|PATTERN
argument_list|(
name|dtrial
argument_list|)
argument_list|)
endif|#
directive|endif
operator|&&
name|rtx_equal_p
argument_list|(
name|PATTERN
argument_list|(
name|next_to_match
argument_list|)
argument_list|,
name|PATTERN
argument_list|(
name|dtrial
argument_list|)
argument_list|)
operator|&&
name|eligible_for_delay
argument_list|(
name|delay_insn
argument_list|,
name|slot_number
operator|-
literal|1
argument_list|,
name|dtrial
argument_list|,
name|flags
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|annul_p
condition|)
block|{
name|rtx
name|new
decl_stmt|;
name|update_block
argument_list|(
name|dtrial
argument_list|,
name|thread
argument_list|)
expr_stmt|;
name|new
operator|=
name|delete_from_delay_slot
argument_list|(
name|dtrial
argument_list|)
expr_stmt|;
if|if
condition|(
name|INSN_DELETED_P
argument_list|(
name|thread
argument_list|)
condition|)
name|thread
operator|=
name|new
expr_stmt|;
name|INSN_FROM_TARGET_P
argument_list|(
name|next_to_match
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|merged_insns
operator|=
name|gen_rtx_INSN_LIST
argument_list|(
name|SImode
argument_list|,
name|dtrial
argument_list|,
name|merged_insns
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|slot_number
operator|==
name|num_slots
condition|)
break|break;
name|next_to_match
operator|=
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|slot_number
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Keep track of the set/referenced resources for the delay 		 slots of any trial insns we encounter.  */
name|mark_set_resources
argument_list|(
name|dtrial
argument_list|,
operator|&
name|set
argument_list|,
literal|0
argument_list|,
name|MARK_SRC_DEST_CALL
argument_list|)
expr_stmt|;
name|mark_referenced_resources
argument_list|(
name|dtrial
argument_list|,
operator|&
name|needed
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* If all insns in the delay slot have been matched and we were previously      annulling the branch, we need not any more.  In that case delete all the      merged insns.  Also clear the INSN_FROM_TARGET_P bit of each insn in      the delay list so that we know that it isn't only being used at the      target.  */
if|if
condition|(
name|slot_number
operator|==
name|num_slots
operator|&&
name|annul_p
condition|)
block|{
for|for
control|(
init|;
name|merged_insns
condition|;
name|merged_insns
operator|=
name|XEXP
argument_list|(
name|merged_insns
argument_list|,
literal|1
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|merged_insns
argument_list|)
operator|==
name|SImode
condition|)
block|{
name|rtx
name|new
decl_stmt|;
name|update_block
argument_list|(
name|XEXP
argument_list|(
name|merged_insns
argument_list|,
literal|0
argument_list|)
argument_list|,
name|thread
argument_list|)
expr_stmt|;
name|new
operator|=
name|delete_from_delay_slot
argument_list|(
name|XEXP
argument_list|(
name|merged_insns
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|INSN_DELETED_P
argument_list|(
name|thread
argument_list|)
condition|)
name|thread
operator|=
name|new
expr_stmt|;
block|}
else|else
block|{
name|update_block
argument_list|(
name|XEXP
argument_list|(
name|merged_insns
argument_list|,
literal|0
argument_list|)
argument_list|,
name|thread
argument_list|)
expr_stmt|;
name|delete_related_insns
argument_list|(
name|XEXP
argument_list|(
name|merged_insns
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|INSN_ANNULLED_BRANCH_P
argument_list|(
name|delay_insn
argument_list|)
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
name|INSN_FROM_TARGET_P
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* See if INSN is redundant with an insn in front of TARGET.  Often this    is called when INSN is a candidate for a delay slot of TARGET.    DELAY_LIST are insns that will be placed in delay slots of TARGET in front    of INSN.  Often INSN will be redundant with an insn in a delay slot of    some previous insn.  This happens when we have a series of branches to the    same label; in that case the first insn at the target might want to go    into each of the delay slots.     If we are not careful, this routine can take up a significant fraction    of the total compilation time (4%), but only wins rarely.  Hence we    speed this routine up by making two passes.  The first pass goes back    until it hits a label and sees if it find an insn with an identical    pattern.  Only in this (relatively rare) event does it check for    data conflicts.     We do not split insns we encounter.  This could cause us not to find a    redundant insn, but the cost of splitting seems greater than the possible    gain in rare cases.  */
end_comment

begin_function
specifier|static
name|rtx
name|redundant_insn
parameter_list|(
name|insn
parameter_list|,
name|target
parameter_list|,
name|delay_list
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|rtx
name|target
decl_stmt|;
name|rtx
name|delay_list
decl_stmt|;
block|{
name|rtx
name|target_main
init|=
name|target
decl_stmt|;
name|rtx
name|ipat
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|trial
decl_stmt|,
name|pat
decl_stmt|;
name|struct
name|resources
name|needed
decl_stmt|,
name|set
decl_stmt|;
name|int
name|i
decl_stmt|;
name|unsigned
name|insns_to_search
decl_stmt|;
comment|/* If INSN has any REG_UNUSED notes, it can't match anything since we      are allowed to not actually assign to such a register.  */
if|if
condition|(
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_UNUSED
argument_list|,
name|NULL_RTX
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Scan backwards looking for a match.  */
for|for
control|(
name|trial
operator|=
name|PREV_INSN
argument_list|(
name|target
argument_list|)
operator|,
name|insns_to_search
operator|=
name|MAX_DELAY_SLOT_INSN_SEARCH
init|;
name|trial
operator|&&
name|insns_to_search
operator|>
literal|0
condition|;
name|trial
operator|=
name|PREV_INSN
argument_list|(
name|trial
argument_list|)
operator|,
operator|--
name|insns_to_search
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|trial
argument_list|)
operator|==
name|CODE_LABEL
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|trial
argument_list|)
condition|)
continue|continue;
name|pat
operator|=
name|PATTERN
argument_list|(
name|trial
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|USE
operator|||
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|CLOBBER
condition|)
continue|continue;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|SEQUENCE
condition|)
block|{
comment|/* Stop for a CALL and its delay slots because it is difficult to 	     track its resource needs correctly.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CALL_INSN
condition|)
return|return
literal|0
return|;
comment|/* Stop for an INSN or JUMP_INSN with delayed effects and its delay 	     slots because it is difficult to track its resource needs 	     correctly.  */
ifdef|#
directive|ifdef
name|INSN_SETS_ARE_DELAYED
if|if
condition|(
name|INSN_SETS_ARE_DELAYED
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INSN_REFERENCES_ARE_DELAYED
if|if
condition|(
name|INSN_REFERENCES_ARE_DELAYED
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
comment|/* See if any of the insns in the delay slot match, updating 	     resource requirements as we go.  */
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|&&
name|rtx_equal_p
argument_list|(
name|PATTERN
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|,
name|ipat
argument_list|)
operator|&&
operator|!
name|find_reg_note
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|REG_UNUSED
argument_list|,
name|NULL_RTX
argument_list|)
condition|)
break|break;
comment|/* If found a match, exit this loop early.  */
if|if
condition|(
name|i
operator|>
literal|0
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|trial
argument_list|)
operator|==
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|&&
name|rtx_equal_p
argument_list|(
name|pat
argument_list|,
name|ipat
argument_list|)
operator|&&
operator|!
name|find_reg_note
argument_list|(
name|trial
argument_list|,
name|REG_UNUSED
argument_list|,
name|NULL_RTX
argument_list|)
condition|)
break|break;
block|}
comment|/* If we didn't find an insn that matches, return 0.  */
if|if
condition|(
name|trial
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* See what resources this insn sets and needs.  If they overlap, or      if this insn references CC0, it can't be redundant.  */
name|CLEAR_RESOURCE
argument_list|(
operator|&
name|needed
argument_list|)
expr_stmt|;
name|CLEAR_RESOURCE
argument_list|(
operator|&
name|set
argument_list|)
expr_stmt|;
name|mark_set_resources
argument_list|(
name|insn
argument_list|,
operator|&
name|set
argument_list|,
literal|0
argument_list|,
name|MARK_SRC_DEST_CALL
argument_list|)
expr_stmt|;
name|mark_referenced_resources
argument_list|(
name|insn
argument_list|,
operator|&
name|needed
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* If TARGET is a SEQUENCE, get the main insn.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|target
argument_list|)
argument_list|)
operator|==
name|SEQUENCE
condition|)
name|target_main
operator|=
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|target
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|resource_conflicts_p
argument_list|(
operator|&
name|needed
argument_list|,
operator|&
name|set
argument_list|)
ifdef|#
directive|ifdef
name|HAVE_cc0
operator|||
name|reg_mentioned_p
argument_list|(
name|cc0_rtx
argument_list|,
name|ipat
argument_list|)
endif|#
directive|endif
comment|/* The insn requiring the delay may not set anything needed or set by 	 INSN.  */
operator|||
name|insn_sets_resource_p
argument_list|(
name|target_main
argument_list|,
operator|&
name|needed
argument_list|,
literal|1
argument_list|)
operator|||
name|insn_sets_resource_p
argument_list|(
name|target_main
argument_list|,
operator|&
name|set
argument_list|,
literal|1
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Insns we pass may not set either NEEDED or SET, so merge them for      simpler tests.  */
name|needed
operator|.
name|memory
operator||=
name|set
operator|.
name|memory
expr_stmt|;
name|needed
operator|.
name|unch_memory
operator||=
name|set
operator|.
name|unch_memory
expr_stmt|;
name|IOR_HARD_REG_SET
argument_list|(
name|needed
operator|.
name|regs
argument_list|,
name|set
operator|.
name|regs
argument_list|)
expr_stmt|;
comment|/* This insn isn't redundant if it conflicts with an insn that either is      or will be in a delay slot of TARGET.  */
while|while
condition|(
name|delay_list
condition|)
block|{
if|if
condition|(
name|insn_sets_resource_p
argument_list|(
name|XEXP
argument_list|(
name|delay_list
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|needed
argument_list|,
literal|1
argument_list|)
condition|)
return|return
literal|0
return|;
name|delay_list
operator|=
name|XEXP
argument_list|(
name|delay_list
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|target
argument_list|)
argument_list|)
operator|==
name|SEQUENCE
condition|)
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|target
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|insn_sets_resource_p
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|target
argument_list|)
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
operator|&
name|needed
argument_list|,
literal|1
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Scan backwards until we reach a label or an insn that uses something      INSN sets or sets something insn uses or sets.  */
for|for
control|(
name|trial
operator|=
name|PREV_INSN
argument_list|(
name|target
argument_list|)
operator|,
name|insns_to_search
operator|=
name|MAX_DELAY_SLOT_INSN_SEARCH
init|;
name|trial
operator|&&
name|GET_CODE
argument_list|(
name|trial
argument_list|)
operator|!=
name|CODE_LABEL
operator|&&
name|insns_to_search
operator|>
literal|0
condition|;
name|trial
operator|=
name|PREV_INSN
argument_list|(
name|trial
argument_list|)
operator|,
operator|--
name|insns_to_search
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|trial
argument_list|)
operator|!=
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|trial
argument_list|)
operator|!=
name|CALL_INSN
operator|&&
name|GET_CODE
argument_list|(
name|trial
argument_list|)
operator|!=
name|JUMP_INSN
condition|)
continue|continue;
name|pat
operator|=
name|PATTERN
argument_list|(
name|trial
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|USE
operator|||
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|CLOBBER
condition|)
continue|continue;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|SEQUENCE
condition|)
block|{
comment|/* If this is a CALL_INSN and its delay slots, it is hard to track 	     the resource needs properly, so give up.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CALL_INSN
condition|)
return|return
literal|0
return|;
comment|/* If this is an INSN or JUMP_INSN with delayed effects, it 	     is hard to track the resource needs properly, so give up.  */
ifdef|#
directive|ifdef
name|INSN_SETS_ARE_DELAYED
if|if
condition|(
name|INSN_SETS_ARE_DELAYED
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INSN_REFERENCES_ARE_DELAYED
if|if
condition|(
name|INSN_REFERENCES_ARE_DELAYED
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
comment|/* See if any of the insns in the delay slot match, updating 	     resource requirements as we go.  */
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|rtx
name|candidate
init|=
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
comment|/* If an insn will be annulled if the branch is false, it isn't 		 considered as a possible duplicate insn.  */
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|PATTERN
argument_list|(
name|candidate
argument_list|)
argument_list|,
name|ipat
argument_list|)
operator|&&
operator|!
operator|(
name|INSN_ANNULLED_BRANCH_P
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|INSN_FROM_TARGET_P
argument_list|(
name|candidate
argument_list|)
operator|)
condition|)
block|{
comment|/* Show that this insn will be used in the sequel.  */
name|INSN_FROM_TARGET_P
argument_list|(
name|candidate
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return
name|candidate
return|;
block|}
comment|/* Unless this is an annulled insn from the target of a branch, 		 we must stop if it sets anything needed or set by INSN.  */
if|if
condition|(
operator|(
operator|!
name|INSN_ANNULLED_BRANCH_P
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
operator|!
name|INSN_FROM_TARGET_P
argument_list|(
name|candidate
argument_list|)
operator|)
operator|&&
name|insn_sets_resource_p
argument_list|(
name|candidate
argument_list|,
operator|&
name|needed
argument_list|,
literal|1
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
comment|/* If the insn requiring the delay slot conflicts with INSN, we 	     must stop.  */
if|if
condition|(
name|insn_sets_resource_p
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|needed
argument_list|,
literal|1
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
else|else
block|{
comment|/* See if TRIAL is the same as INSN.  */
name|pat
operator|=
name|PATTERN
argument_list|(
name|trial
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|pat
argument_list|,
name|ipat
argument_list|)
condition|)
return|return
name|trial
return|;
comment|/* Can't go any further if TRIAL conflicts with INSN.  */
if|if
condition|(
name|insn_sets_resource_p
argument_list|(
name|trial
argument_list|,
operator|&
name|needed
argument_list|,
literal|1
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if THREAD can only be executed in one way.  If LABEL is non-zero,    it is the target of the branch insn being scanned.  If ALLOW_FALLTHROUGH    is non-zero, we are allowed to fall into this thread; otherwise, we are    not.     If LABEL is used more than one or we pass a label other than LABEL before    finding an active insn, we do not own this thread.  */
end_comment

begin_function
specifier|static
name|int
name|own_thread_p
parameter_list|(
name|thread
parameter_list|,
name|label
parameter_list|,
name|allow_fallthrough
parameter_list|)
name|rtx
name|thread
decl_stmt|;
name|rtx
name|label
decl_stmt|;
name|int
name|allow_fallthrough
decl_stmt|;
block|{
name|rtx
name|active_insn
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
comment|/* We don't own the function end.  */
if|if
condition|(
name|thread
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Get the first active insn, or THREAD, if it is an active insn.  */
name|active_insn
operator|=
name|next_active_insn
argument_list|(
name|PREV_INSN
argument_list|(
name|thread
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|thread
init|;
name|insn
operator|!=
name|active_insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
operator|&&
operator|(
name|insn
operator|!=
name|label
operator|||
name|LABEL_NUSES
argument_list|(
name|insn
argument_list|)
operator|!=
literal|1
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|allow_fallthrough
condition|)
return|return
literal|1
return|;
comment|/* Ensure that we reach a BARRIER before any insn or label.  */
for|for
control|(
name|insn
operator|=
name|prev_nonnote_insn
argument_list|(
name|thread
argument_list|)
init|;
name|insn
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|BARRIER
condition|;
name|insn
operator|=
name|prev_nonnote_insn
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|insn
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
operator|||
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|USE
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|CLOBBER
operator|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Called when INSN is being moved from a location near the target of a jump.    We leave a marker of the form (use (INSN)) immediately in front    of WHERE for mark_target_live_regs.  These markers will be deleted when    reorg finishes.     We used to try to update the live status of registers if WHERE is at    the start of a basic block, but that can't work since we may remove a    BARRIER in relax_delay_slots.  */
end_comment

begin_function
specifier|static
name|void
name|update_block
parameter_list|(
name|insn
parameter_list|,
name|where
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|rtx
name|where
decl_stmt|;
block|{
comment|/* Ignore if this was in a delay slot and it came from the target of      a branch.  */
if|if
condition|(
name|INSN_FROM_TARGET_P
argument_list|(
name|insn
argument_list|)
condition|)
return|return;
name|emit_insn_before
argument_list|(
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|insn
argument_list|)
argument_list|,
name|where
argument_list|)
expr_stmt|;
comment|/* INSN might be making a value live in a block where it didn't use to      be.  So recompute liveness information for this block.  */
name|incr_ticks_for_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Similar to REDIRECT_JUMP except that we update the BB_TICKS entry for    the basic block containing the jump.  */
end_comment

begin_function
specifier|static
name|int
name|reorg_redirect_jump
parameter_list|(
name|jump
parameter_list|,
name|nlabel
parameter_list|)
name|rtx
name|jump
decl_stmt|;
name|rtx
name|nlabel
decl_stmt|;
block|{
name|incr_ticks_for_insn
argument_list|(
name|jump
argument_list|)
expr_stmt|;
return|return
name|redirect_jump
argument_list|(
name|jump
argument_list|,
name|nlabel
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Called when INSN is being moved forward into a delay slot of DELAYED_INSN.    We check every instruction between INSN and DELAYED_INSN for REG_DEAD notes    that reference values used in INSN.  If we find one, then we move the    REG_DEAD note to INSN.     This is needed to handle the case where an later insn (after INSN) has a    REG_DEAD note for a register used by INSN, and this later insn subsequently    gets moved before a CODE_LABEL because it is a redundant insn.  In this    case, mark_target_live_regs may be confused into thinking the register    is dead because it sees a REG_DEAD note immediately before a CODE_LABEL.  */
end_comment

begin_function
specifier|static
name|void
name|update_reg_dead_notes
parameter_list|(
name|insn
parameter_list|,
name|delayed_insn
parameter_list|)
name|rtx
name|insn
decl_stmt|,
name|delayed_insn
decl_stmt|;
block|{
name|rtx
name|p
decl_stmt|,
name|link
decl_stmt|,
name|next
decl_stmt|;
for|for
control|(
name|p
operator|=
name|next_nonnote_insn
argument_list|(
name|insn
argument_list|)
init|;
name|p
operator|!=
name|delayed_insn
condition|;
name|p
operator|=
name|next_nonnote_insn
argument_list|(
name|p
argument_list|)
control|)
for|for
control|(
name|link
operator|=
name|REG_NOTES
argument_list|(
name|p
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|next
control|)
block|{
name|next
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|!=
name|REG_DEAD
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|REG
condition|)
continue|continue;
if|if
condition|(
name|reg_referenced_p
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Move the REG_DEAD note from P to INSN.  */
name|remove_note
argument_list|(
name|p
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|link
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Called when an insn redundant with start_insn is deleted.  If there    is a REG_DEAD note for the target of start_insn between start_insn    and stop_insn, then the REG_DEAD note needs to be deleted since the    value no longer dies there.     If the REG_DEAD note isn't deleted, then mark_target_live_regs may be    confused into thinking the register is dead.  */
end_comment

begin_function
specifier|static
name|void
name|fix_reg_dead_note
parameter_list|(
name|start_insn
parameter_list|,
name|stop_insn
parameter_list|)
name|rtx
name|start_insn
decl_stmt|,
name|stop_insn
decl_stmt|;
block|{
name|rtx
name|p
decl_stmt|,
name|link
decl_stmt|,
name|next
decl_stmt|;
for|for
control|(
name|p
operator|=
name|next_nonnote_insn
argument_list|(
name|start_insn
argument_list|)
init|;
name|p
operator|!=
name|stop_insn
condition|;
name|p
operator|=
name|next_nonnote_insn
argument_list|(
name|p
argument_list|)
control|)
for|for
control|(
name|link
operator|=
name|REG_NOTES
argument_list|(
name|p
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|next
control|)
block|{
name|next
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|!=
name|REG_DEAD
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|REG
condition|)
continue|continue;
if|if
condition|(
name|reg_set_p
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|,
name|PATTERN
argument_list|(
name|start_insn
argument_list|)
argument_list|)
condition|)
block|{
name|remove_note
argument_list|(
name|p
argument_list|,
name|link
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Delete any REG_UNUSED notes that exist on INSN but not on REDUNDANT_INSN.     This handles the case of udivmodXi4 instructions which optimize their    output depending on whether any REG_UNUSED notes are present.    we must make sure that INSN calculates as many results as REDUNDANT_INSN    does.  */
end_comment

begin_function
specifier|static
name|void
name|update_reg_unused_notes
parameter_list|(
name|insn
parameter_list|,
name|redundant_insn
parameter_list|)
name|rtx
name|insn
decl_stmt|,
name|redundant_insn
decl_stmt|;
block|{
name|rtx
name|link
decl_stmt|,
name|next
decl_stmt|;
for|for
control|(
name|link
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|next
control|)
block|{
name|next
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|!=
name|REG_UNUSED
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|REG
condition|)
continue|continue;
if|if
condition|(
operator|!
name|find_regno_note
argument_list|(
name|redundant_insn
argument_list|,
name|REG_UNUSED
argument_list|,
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
name|remove_note
argument_list|(
name|insn
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Scan a function looking for insns that need a delay slot and find insns to    put into the delay slot.     NON_JUMPS_P is non-zero if we are to only try to fill non-jump insns (such    as calls).  We do these first since we don't want jump insns (that are    easier to fill) to get the only insns that could be used for non-jump insns.    When it is zero, only try to fill JUMP_INSNs.     When slots are filled in this manner, the insns (including the    delay_insn) are put together in a SEQUENCE rtx.  In this fashion,    it is possible to tell whether a delay slot has really been filled    or not.  `final' knows how to deal with this, by communicating    through FINAL_SEQUENCE.  */
end_comment

begin_function
specifier|static
name|void
name|fill_simple_delay_slots
parameter_list|(
name|non_jumps_p
parameter_list|)
name|int
name|non_jumps_p
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|,
name|pat
decl_stmt|,
name|trial
decl_stmt|,
name|next_trial
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|num_unfilled_slots
init|=
name|unfilled_slots_next
operator|-
name|unfilled_slots_base
decl_stmt|;
name|struct
name|resources
name|needed
decl_stmt|,
name|set
decl_stmt|;
name|int
name|slots_to_fill
decl_stmt|,
name|slots_filled
decl_stmt|;
name|rtx
name|delay_list
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_unfilled_slots
condition|;
name|i
operator|++
control|)
block|{
name|int
name|flags
decl_stmt|;
comment|/* Get the next insn to fill.  If it has already had any slots assigned, 	 we can't do anything with it.  Maybe we'll improve this later.  */
name|insn
operator|=
name|unfilled_slots_base
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|insn
operator|==
literal|0
operator|||
name|INSN_DELETED_P
argument_list|(
name|insn
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SEQUENCE
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|non_jumps_p
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|JUMP_INSN
operator|&&
operator|!
name|non_jumps_p
operator|)
condition|)
continue|continue;
comment|/* It may have been that this insn used to need delay slots, but 	 now doesn't; ignore in that case.  This can happen, for example, 	 on the HP PA RISC, where the number of delay slots depends on 	 what insns are nearby.  */
name|slots_to_fill
operator|=
name|num_delay_slots
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Some machine description have defined instructions to have 	 delay slots only in certain circumstances which may depend on 	 nearby insns (which change due to reorg's actions).  	 For example, the PA port normally has delay slots for unconditional 	 jumps.  	 However, the PA port claims such jumps do not have a delay slot 	 if they are immediate successors of certain CALL_INSNs.  This 	 allows the port to favor filling the delay slot of the call with 	 the unconditional jump.  */
if|if
condition|(
name|slots_to_fill
operator|==
literal|0
condition|)
continue|continue;
comment|/* This insn needs, or can use, some delay slots.  SLOTS_TO_FILL 	 says how many.  After initialization, first try optimizing  	 call _foo		call _foo 	 nop			add %o7,.-L1,%o7 	 b,a L1 	 nop  	 If this case applies, the delay slot of the call is filled with 	 the unconditional jump.  This is done first to avoid having the 	 delay slot of the call filled in the backward scan.  Also, since 	 the unconditional jump is likely to also have a delay slot, that 	 insn must exist when it is subsequently scanned.  	 This is tried on each insn with delay slots as some machines 	 have insns which perform calls, but are not represented as 	 CALL_INSNs.  */
name|slots_filled
operator|=
literal|0
expr_stmt|;
name|delay_list
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
name|flags
operator|=
name|get_jump_flags
argument_list|(
name|insn
argument_list|,
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|flags
operator|=
name|get_jump_flags
argument_list|(
name|insn
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|trial
operator|=
name|next_active_insn
argument_list|(
name|insn
argument_list|)
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|trial
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|simplejump_p
argument_list|(
name|trial
argument_list|)
operator|&&
name|eligible_for_delay
argument_list|(
name|insn
argument_list|,
name|slots_filled
argument_list|,
name|trial
argument_list|,
name|flags
argument_list|)
operator|&&
name|no_labels_between_p
argument_list|(
name|insn
argument_list|,
name|trial
argument_list|)
condition|)
block|{
name|rtx
modifier|*
name|tmp
decl_stmt|;
name|slots_filled
operator|++
expr_stmt|;
name|delay_list
operator|=
name|add_to_delay_list
argument_list|(
name|trial
argument_list|,
name|delay_list
argument_list|)
expr_stmt|;
comment|/* TRIAL may have had its delay slot filled, then unfilled.  When 	     the delay slot is unfilled, TRIAL is placed back on the unfilled 	     slots obstack.  Unfortunately, it is placed on the end of the 	     obstack, not in its original location.  Therefore, we must search 	     from entry i + 1 to the end of the unfilled slots obstack to 	     try and find TRIAL.  */
name|tmp
operator|=
operator|&
name|unfilled_slots_base
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|tmp
operator|!=
name|trial
operator|&&
name|tmp
operator|!=
name|unfilled_slots_next
condition|)
name|tmp
operator|++
expr_stmt|;
comment|/* Remove the unconditional jump from consideration for delay slot 	     filling and unthread it.  */
if|if
condition|(
operator|*
name|tmp
operator|==
name|trial
condition|)
operator|*
name|tmp
operator|=
literal|0
expr_stmt|;
block|{
name|rtx
name|next
init|=
name|NEXT_INSN
argument_list|(
name|trial
argument_list|)
decl_stmt|;
name|rtx
name|prev
init|=
name|PREV_INSN
argument_list|(
name|trial
argument_list|)
decl_stmt|;
if|if
condition|(
name|prev
condition|)
name|NEXT_INSN
argument_list|(
name|prev
argument_list|)
operator|=
name|next
expr_stmt|;
if|if
condition|(
name|next
condition|)
name|PREV_INSN
argument_list|(
name|next
argument_list|)
operator|=
name|prev
expr_stmt|;
block|}
block|}
comment|/* Now, scan backwards from the insn to search for a potential 	 delay-slot candidate.  Stop searching when a label or jump is hit.  	 For each candidate, if it is to go into the delay slot (moved 	 forward in execution sequence), it must not need or set any resources 	 that were set by later insns and must not set any resources that 	 are needed for those insns.  	 The delay slot insn itself sets resources unless it is a call 	 (in which case the called routine, not the insn itself, is doing 	 the setting).  */
if|if
condition|(
name|slots_filled
operator|<
name|slots_to_fill
condition|)
block|{
name|CLEAR_RESOURCE
argument_list|(
operator|&
name|needed
argument_list|)
expr_stmt|;
name|CLEAR_RESOURCE
argument_list|(
operator|&
name|set
argument_list|)
expr_stmt|;
name|mark_set_resources
argument_list|(
name|insn
argument_list|,
operator|&
name|set
argument_list|,
literal|0
argument_list|,
name|MARK_SRC_DEST
argument_list|)
expr_stmt|;
name|mark_referenced_resources
argument_list|(
name|insn
argument_list|,
operator|&
name|needed
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|trial
operator|=
name|prev_nonnote_insn
argument_list|(
name|insn
argument_list|)
init|;
operator|!
name|stop_search_p
argument_list|(
name|trial
argument_list|,
literal|1
argument_list|)
condition|;
name|trial
operator|=
name|next_trial
control|)
block|{
name|next_trial
operator|=
name|prev_nonnote_insn
argument_list|(
name|trial
argument_list|)
expr_stmt|;
comment|/* This must be an INSN or CALL_INSN.  */
name|pat
operator|=
name|PATTERN
argument_list|(
name|trial
argument_list|)
expr_stmt|;
comment|/* USE and CLOBBER at this level was just for flow; ignore it.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|USE
operator|||
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|CLOBBER
condition|)
continue|continue;
comment|/* Check for resource conflict first, to avoid unnecessary 		 splitting.  */
if|if
condition|(
operator|!
name|insn_references_resource_p
argument_list|(
name|trial
argument_list|,
operator|&
name|set
argument_list|,
literal|1
argument_list|)
operator|&&
operator|!
name|insn_sets_resource_p
argument_list|(
name|trial
argument_list|,
operator|&
name|set
argument_list|,
literal|1
argument_list|)
operator|&&
operator|!
name|insn_sets_resource_p
argument_list|(
name|trial
argument_list|,
operator|&
name|needed
argument_list|,
literal|1
argument_list|)
ifdef|#
directive|ifdef
name|HAVE_cc0
comment|/* Can't separate set of cc0 from its use.  */
operator|&&
operator|!
operator|(
name|reg_mentioned_p
argument_list|(
name|cc0_rtx
argument_list|,
name|pat
argument_list|)
operator|&&
operator|!
name|sets_cc0_p
argument_list|(
name|pat
argument_list|)
operator|)
endif|#
directive|endif
condition|)
block|{
name|trial
operator|=
name|try_split
argument_list|(
name|pat
argument_list|,
name|trial
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|next_trial
operator|=
name|prev_nonnote_insn
argument_list|(
name|trial
argument_list|)
expr_stmt|;
if|if
condition|(
name|eligible_for_delay
argument_list|(
name|insn
argument_list|,
name|slots_filled
argument_list|,
name|trial
argument_list|,
name|flags
argument_list|)
condition|)
block|{
comment|/* In this case, we are searching backward, so if we 			 find insns to put on the delay list, we want 			 to put them at the head, rather than the 			 tail, of the list.  */
name|update_reg_dead_notes
argument_list|(
name|trial
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|delay_list
operator|=
name|gen_rtx_INSN_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|trial
argument_list|,
name|delay_list
argument_list|)
expr_stmt|;
name|update_block
argument_list|(
name|trial
argument_list|,
name|trial
argument_list|)
expr_stmt|;
name|delete_related_insns
argument_list|(
name|trial
argument_list|)
expr_stmt|;
if|if
condition|(
name|slots_to_fill
operator|==
operator|++
name|slots_filled
condition|)
break|break;
continue|continue;
block|}
block|}
name|mark_set_resources
argument_list|(
name|trial
argument_list|,
operator|&
name|set
argument_list|,
literal|0
argument_list|,
name|MARK_SRC_DEST_CALL
argument_list|)
expr_stmt|;
name|mark_referenced_resources
argument_list|(
name|trial
argument_list|,
operator|&
name|needed
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If all needed slots haven't been filled, we come here.  */
comment|/* Try to optimize case of jumping around a single insn.  */
if|#
directive|if
name|defined
argument_list|(
name|ANNUL_IFFALSE_SLOTS
argument_list|)
operator|||
name|defined
argument_list|(
name|ANNUL_IFTRUE_SLOTS
argument_list|)
if|if
condition|(
name|slots_filled
operator|!=
name|slots_to_fill
operator|&&
name|delay_list
operator|==
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
operator|(
name|condjump_p
argument_list|(
name|insn
argument_list|)
operator|||
name|condjump_in_parallel_p
argument_list|(
name|insn
argument_list|)
operator|)
condition|)
block|{
name|delay_list
operator|=
name|optimize_skip
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|delay_list
condition|)
name|slots_filled
operator|+=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Try to get insns from beyond the insn needing the delay slot. 	 These insns can neither set or reference resources set in insns being 	 skipped, cannot set resources in the insn being skipped, and, if this 	 is a CALL_INSN (or a CALL_INSN is passed), cannot trap (because the 	 call might not return).  	 There used to be code which continued past the target label if 	 we saw all uses of the target label.  This code did not work, 	 because it failed to account for some instructions which were 	 both annulled and marked as from the target.  This can happen as a 	 result of optimize_skip.  Since this code was redundant with 	 fill_eager_delay_slots anyways, it was just deleted.  */
if|if
condition|(
name|slots_filled
operator|!=
name|slots_to_fill
comment|/* If this instruction could throw an exception which is 	     caught in the same function, then it's not safe to fill 	     the delay slot with an instruction from beyond this 	     point.  For example, consider:                 int i = 2;  	       try {                  f(); 	         i = 3;                } catch (...) {}                 return i;  	     Even though `i' is a local variable, we must be sure not 	     to put `i = 3' in the delay slot if `f' might throw an 	     exception.  	     Presumably, we should also check to see if we could get 	     back to this function via `setjmp'.  */
operator|&&
operator|!
name|can_throw_internal
argument_list|(
name|insn
argument_list|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|JUMP_INSN
operator|||
operator|(
operator|(
name|condjump_p
argument_list|(
name|insn
argument_list|)
operator|||
name|condjump_in_parallel_p
argument_list|(
name|insn
argument_list|)
operator|)
operator|&&
operator|!
name|simplejump_p
argument_list|(
name|insn
argument_list|)
operator|&&
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
operator|!=
literal|0
operator|)
operator|)
condition|)
block|{
comment|/* Invariant: If insn is a JUMP_INSN, the insn's jump 	     label.  Otherwise, zero.  */
name|rtx
name|target
init|=
literal|0
decl_stmt|;
name|int
name|maybe_never
init|=
literal|0
decl_stmt|;
name|rtx
name|pat
decl_stmt|,
name|trial_delay
decl_stmt|;
name|CLEAR_RESOURCE
argument_list|(
operator|&
name|needed
argument_list|)
expr_stmt|;
name|CLEAR_RESOURCE
argument_list|(
operator|&
name|set
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
name|mark_set_resources
argument_list|(
name|insn
argument_list|,
operator|&
name|set
argument_list|,
literal|0
argument_list|,
name|MARK_SRC_DEST_CALL
argument_list|)
expr_stmt|;
name|mark_referenced_resources
argument_list|(
name|insn
argument_list|,
operator|&
name|needed
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|maybe_never
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|mark_set_resources
argument_list|(
name|insn
argument_list|,
operator|&
name|set
argument_list|,
literal|0
argument_list|,
name|MARK_SRC_DEST_CALL
argument_list|)
expr_stmt|;
name|mark_referenced_resources
argument_list|(
name|insn
argument_list|,
operator|&
name|needed
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
name|target
operator|=
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|target
operator|==
literal|0
condition|)
for|for
control|(
name|trial
operator|=
name|next_nonnote_insn
argument_list|(
name|insn
argument_list|)
init|;
name|trial
condition|;
name|trial
operator|=
name|next_trial
control|)
block|{
name|next_trial
operator|=
name|next_nonnote_insn
argument_list|(
name|trial
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|trial
argument_list|)
operator|==
name|CODE_LABEL
operator|||
name|GET_CODE
argument_list|(
name|trial
argument_list|)
operator|==
name|BARRIER
condition|)
break|break;
comment|/* We must have an INSN, JUMP_INSN, or CALL_INSN.  */
name|pat
operator|=
name|PATTERN
argument_list|(
name|trial
argument_list|)
expr_stmt|;
comment|/* Stand-alone USE and CLOBBER are just for flow.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|USE
operator|||
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|CLOBBER
condition|)
continue|continue;
comment|/* If this already has filled delay slots, get the insn needing 		   the delay slots.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|SEQUENCE
condition|)
name|trial_delay
operator|=
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|trial_delay
operator|=
name|trial
expr_stmt|;
comment|/* Stop our search when seeing an unconditional jump.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|trial_delay
argument_list|)
operator|==
name|JUMP_INSN
condition|)
break|break;
comment|/* See if we have a resource problem before we try to 		   split.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|!=
name|SEQUENCE
operator|&&
operator|!
name|insn_references_resource_p
argument_list|(
name|trial
argument_list|,
operator|&
name|set
argument_list|,
literal|1
argument_list|)
operator|&&
operator|!
name|insn_sets_resource_p
argument_list|(
name|trial
argument_list|,
operator|&
name|set
argument_list|,
literal|1
argument_list|)
operator|&&
operator|!
name|insn_sets_resource_p
argument_list|(
name|trial
argument_list|,
operator|&
name|needed
argument_list|,
literal|1
argument_list|)
ifdef|#
directive|ifdef
name|HAVE_cc0
operator|&&
operator|!
operator|(
name|reg_mentioned_p
argument_list|(
name|cc0_rtx
argument_list|,
name|pat
argument_list|)
operator|&&
operator|!
name|sets_cc0_p
argument_list|(
name|pat
argument_list|)
operator|)
endif|#
directive|endif
operator|&&
operator|!
operator|(
name|maybe_never
operator|&&
name|may_trap_p
argument_list|(
name|pat
argument_list|)
operator|)
operator|&&
operator|(
name|trial
operator|=
name|try_split
argument_list|(
name|pat
argument_list|,
name|trial
argument_list|,
literal|0
argument_list|)
operator|)
operator|&&
name|eligible_for_delay
argument_list|(
name|insn
argument_list|,
name|slots_filled
argument_list|,
name|trial
argument_list|,
name|flags
argument_list|)
condition|)
block|{
name|next_trial
operator|=
name|next_nonnote_insn
argument_list|(
name|trial
argument_list|)
expr_stmt|;
name|delay_list
operator|=
name|add_to_delay_list
argument_list|(
name|trial
argument_list|,
name|delay_list
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_cc0
if|if
condition|(
name|reg_mentioned_p
argument_list|(
name|cc0_rtx
argument_list|,
name|pat
argument_list|)
condition|)
name|link_cc0_insns
argument_list|(
name|trial
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|delete_related_insns
argument_list|(
name|trial
argument_list|)
expr_stmt|;
if|if
condition|(
name|slots_to_fill
operator|==
operator|++
name|slots_filled
condition|)
break|break;
continue|continue;
block|}
name|mark_set_resources
argument_list|(
name|trial
argument_list|,
operator|&
name|set
argument_list|,
literal|0
argument_list|,
name|MARK_SRC_DEST_CALL
argument_list|)
expr_stmt|;
name|mark_referenced_resources
argument_list|(
name|trial
argument_list|,
operator|&
name|needed
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Ensure we don't put insns between the setting of cc and the 		   comparison by moving a setting of cc into an earlier delay 		   slot since these insns could clobber the condition code.  */
name|set
operator|.
name|cc
operator|=
literal|1
expr_stmt|;
comment|/* If this is a call or jump, we might not get here.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|trial_delay
argument_list|)
operator|==
name|CALL_INSN
operator|||
name|GET_CODE
argument_list|(
name|trial_delay
argument_list|)
operator|==
name|JUMP_INSN
condition|)
name|maybe_never
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If there are slots left to fill and our search was stopped by an 	     unconditional branch, try the insn at the branch target.  We can 	     redirect the branch if it works.  	     Don't do this if the insn at the branch target is a branch.  */
if|if
condition|(
name|slots_to_fill
operator|!=
name|slots_filled
operator|&&
name|trial
operator|&&
name|GET_CODE
argument_list|(
name|trial
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|simplejump_p
argument_list|(
name|trial
argument_list|)
operator|&&
operator|(
name|target
operator|==
literal|0
operator|||
name|JUMP_LABEL
argument_list|(
name|trial
argument_list|)
operator|==
name|target
operator|)
operator|&&
operator|(
name|next_trial
operator|=
name|next_active_insn
argument_list|(
name|JUMP_LABEL
argument_list|(
name|trial
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|next_trial
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|next_trial
argument_list|)
argument_list|)
operator|==
name|SEQUENCE
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|next_trial
argument_list|)
operator|!=
name|JUMP_INSN
operator|&&
operator|!
name|insn_references_resource_p
argument_list|(
name|next_trial
argument_list|,
operator|&
name|set
argument_list|,
literal|1
argument_list|)
operator|&&
operator|!
name|insn_sets_resource_p
argument_list|(
name|next_trial
argument_list|,
operator|&
name|set
argument_list|,
literal|1
argument_list|)
operator|&&
operator|!
name|insn_sets_resource_p
argument_list|(
name|next_trial
argument_list|,
operator|&
name|needed
argument_list|,
literal|1
argument_list|)
ifdef|#
directive|ifdef
name|HAVE_cc0
operator|&&
operator|!
name|reg_mentioned_p
argument_list|(
name|cc0_rtx
argument_list|,
name|PATTERN
argument_list|(
name|next_trial
argument_list|)
argument_list|)
endif|#
directive|endif
operator|&&
operator|!
operator|(
name|maybe_never
operator|&&
name|may_trap_p
argument_list|(
name|PATTERN
argument_list|(
name|next_trial
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
name|next_trial
operator|=
name|try_split
argument_list|(
name|PATTERN
argument_list|(
name|next_trial
argument_list|)
argument_list|,
name|next_trial
argument_list|,
literal|0
argument_list|)
operator|)
operator|&&
name|eligible_for_delay
argument_list|(
name|insn
argument_list|,
name|slots_filled
argument_list|,
name|next_trial
argument_list|,
name|flags
argument_list|)
condition|)
block|{
name|rtx
name|new_label
init|=
name|next_active_insn
argument_list|(
name|next_trial
argument_list|)
decl_stmt|;
if|if
condition|(
name|new_label
operator|!=
literal|0
condition|)
name|new_label
operator|=
name|get_label_before
argument_list|(
name|new_label
argument_list|)
expr_stmt|;
else|else
name|new_label
operator|=
name|find_end_label
argument_list|()
expr_stmt|;
name|delay_list
operator|=
name|add_to_delay_list
argument_list|(
name|copy_rtx
argument_list|(
name|next_trial
argument_list|)
argument_list|,
name|delay_list
argument_list|)
expr_stmt|;
name|slots_filled
operator|++
expr_stmt|;
name|reorg_redirect_jump
argument_list|(
name|trial
argument_list|,
name|new_label
argument_list|)
expr_stmt|;
comment|/* If we merged because we both jumped to the same place, 		 redirect the original insn also.  */
if|if
condition|(
name|target
condition|)
name|reorg_redirect_jump
argument_list|(
name|insn
argument_list|,
name|new_label
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If this is an unconditional jump, then try to get insns from the 	 target of the jump.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|simplejump_p
argument_list|(
name|insn
argument_list|)
operator|&&
name|slots_filled
operator|!=
name|slots_to_fill
condition|)
name|delay_list
operator|=
name|fill_slots_from_thread
argument_list|(
name|insn
argument_list|,
name|const_true_rtx
argument_list|,
name|next_active_insn
argument_list|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|own_thread_p
argument_list|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
argument_list|,
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|slots_to_fill
argument_list|,
operator|&
name|slots_filled
argument_list|,
name|delay_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|delay_list
condition|)
name|unfilled_slots_base
index|[
name|i
index|]
operator|=
name|emit_delay_sequence
argument_list|(
name|insn
argument_list|,
name|delay_list
argument_list|,
name|slots_filled
argument_list|)
expr_stmt|;
if|if
condition|(
name|slots_to_fill
operator|==
name|slots_filled
condition|)
name|unfilled_slots_base
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|note_delay_statistics
argument_list|(
name|slots_filled
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DELAY_SLOTS_FOR_EPILOGUE
comment|/* See if the epilogue needs any delay slots.  Try to fill them if so.      The only thing we can do is scan backwards from the end of the      function.  If we did this in a previous pass, it is incorrect to do it      again.  */
if|if
condition|(
name|current_function_epilogue_delay_list
condition|)
return|return;
name|slots_to_fill
operator|=
name|DELAY_SLOTS_FOR_EPILOGUE
expr_stmt|;
if|if
condition|(
name|slots_to_fill
operator|==
literal|0
condition|)
return|return;
name|slots_filled
operator|=
literal|0
expr_stmt|;
name|CLEAR_RESOURCE
argument_list|(
operator|&
name|set
argument_list|)
expr_stmt|;
comment|/* The frame pointer and stack pointer are needed at the beginning of      the epilogue, so instructions setting them can not be put in the      epilogue delay slot.  However, everything else needed at function      end is safe, so we don't want to use end_of_function_needs here.  */
name|CLEAR_RESOURCE
argument_list|(
operator|&
name|needed
argument_list|)
expr_stmt|;
if|if
condition|(
name|frame_pointer_needed
condition|)
block|{
name|SET_HARD_REG_BIT
argument_list|(
name|needed
operator|.
name|regs
argument_list|,
name|FRAME_POINTER_REGNUM
argument_list|)
expr_stmt|;
if|#
directive|if
name|HARD_FRAME_POINTER_REGNUM
operator|!=
name|FRAME_POINTER_REGNUM
name|SET_HARD_REG_BIT
argument_list|(
name|needed
operator|.
name|regs
argument_list|,
name|HARD_FRAME_POINTER_REGNUM
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EXIT_IGNORE_STACK
if|if
condition|(
operator|!
name|EXIT_IGNORE_STACK
operator|||
name|current_function_sp_is_unchanging
condition|)
endif|#
directive|endif
name|SET_HARD_REG_BIT
argument_list|(
name|needed
operator|.
name|regs
argument_list|,
name|STACK_POINTER_REGNUM
argument_list|)
expr_stmt|;
block|}
else|else
name|SET_HARD_REG_BIT
argument_list|(
name|needed
operator|.
name|regs
argument_list|,
name|STACK_POINTER_REGNUM
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EPILOGUE_USES
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|EPILOGUE_USES
argument_list|(
name|i
argument_list|)
condition|)
name|SET_HARD_REG_BIT
argument_list|(
name|needed
operator|.
name|regs
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
for|for
control|(
name|trial
operator|=
name|get_last_insn
argument_list|()
init|;
operator|!
name|stop_search_p
argument_list|(
name|trial
argument_list|,
literal|1
argument_list|)
condition|;
name|trial
operator|=
name|PREV_INSN
argument_list|(
name|trial
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|trial
argument_list|)
operator|==
name|NOTE
condition|)
continue|continue;
name|pat
operator|=
name|PATTERN
argument_list|(
name|trial
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|USE
operator|||
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|CLOBBER
condition|)
continue|continue;
if|if
condition|(
operator|!
name|insn_references_resource_p
argument_list|(
name|trial
argument_list|,
operator|&
name|set
argument_list|,
literal|1
argument_list|)
operator|&&
operator|!
name|insn_sets_resource_p
argument_list|(
name|trial
argument_list|,
operator|&
name|needed
argument_list|,
literal|1
argument_list|)
operator|&&
operator|!
name|insn_sets_resource_p
argument_list|(
name|trial
argument_list|,
operator|&
name|set
argument_list|,
literal|1
argument_list|)
ifdef|#
directive|ifdef
name|HAVE_cc0
comment|/* Don't want to mess with cc0 here.  */
operator|&&
operator|!
name|reg_mentioned_p
argument_list|(
name|cc0_rtx
argument_list|,
name|pat
argument_list|)
endif|#
directive|endif
condition|)
block|{
name|trial
operator|=
name|try_split
argument_list|(
name|pat
argument_list|,
name|trial
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ELIGIBLE_FOR_EPILOGUE_DELAY
argument_list|(
name|trial
argument_list|,
name|slots_filled
argument_list|)
condition|)
block|{
comment|/* Here as well we are searching backward, so put the 		 insns we find on the head of the list.  */
name|current_function_epilogue_delay_list
operator|=
name|gen_rtx_INSN_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|trial
argument_list|,
name|current_function_epilogue_delay_list
argument_list|)
expr_stmt|;
name|mark_end_of_function_resources
argument_list|(
name|trial
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|update_block
argument_list|(
name|trial
argument_list|,
name|trial
argument_list|)
expr_stmt|;
name|delete_related_insns
argument_list|(
name|trial
argument_list|)
expr_stmt|;
comment|/* Clear deleted bit so final.c will output the insn.  */
name|INSN_DELETED_P
argument_list|(
name|trial
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|slots_to_fill
operator|==
operator|++
name|slots_filled
condition|)
break|break;
continue|continue;
block|}
block|}
name|mark_set_resources
argument_list|(
name|trial
argument_list|,
operator|&
name|set
argument_list|,
literal|0
argument_list|,
name|MARK_SRC_DEST_CALL
argument_list|)
expr_stmt|;
name|mark_referenced_resources
argument_list|(
name|trial
argument_list|,
operator|&
name|needed
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|note_delay_statistics
argument_list|(
name|slots_filled
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Try to find insns to place in delay slots.     INSN is the jump needing SLOTS_TO_FILL delay slots.  It tests CONDITION    or is an unconditional branch if CONDITION is const_true_rtx.    *PSLOTS_FILLED is updated with the number of slots that we have filled.     THREAD is a flow-of-control, either the insns to be executed if the    branch is true or if the branch is false, THREAD_IF_TRUE says which.     OPPOSITE_THREAD is the thread in the opposite direction.  It is used    to see if any potential delay slot insns set things needed there.     LIKELY is non-zero if it is extremely likely that the branch will be    taken and THREAD_IF_TRUE is set.  This is used for the branch at the    end of a loop back up to the top.     OWN_THREAD and OWN_OPPOSITE_THREAD are true if we are the only user of the    thread.  I.e., it is the fallthrough code of our jump or the target of the    jump when we are the only jump going there.     If OWN_THREAD is false, it must be the "true" thread of a jump.  In that    case, we can only take insns from the head of the thread for our delay    slot.  We then adjust the jump to point after the insns we have taken.  */
end_comment

begin_function
specifier|static
name|rtx
name|fill_slots_from_thread
parameter_list|(
name|insn
parameter_list|,
name|condition
parameter_list|,
name|thread
parameter_list|,
name|opposite_thread
parameter_list|,
name|likely
parameter_list|,
name|thread_if_true
parameter_list|,
name|own_thread
parameter_list|,
name|slots_to_fill
parameter_list|,
name|pslots_filled
parameter_list|,
name|delay_list
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|rtx
name|condition
decl_stmt|;
name|rtx
name|thread
decl_stmt|,
name|opposite_thread
decl_stmt|;
name|int
name|likely
decl_stmt|;
name|int
name|thread_if_true
decl_stmt|;
name|int
name|own_thread
decl_stmt|;
name|int
name|slots_to_fill
decl_stmt|,
decl|*
name|pslots_filled
decl_stmt|;
end_function

begin_decl_stmt
name|rtx
name|delay_list
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|rtx
name|new_thread
decl_stmt|;
name|struct
name|resources
name|opposite_needed
decl_stmt|,
name|set
decl_stmt|,
name|needed
decl_stmt|;
name|rtx
name|trial
decl_stmt|;
name|int
name|lose
init|=
literal|0
decl_stmt|;
name|int
name|must_annul
init|=
literal|0
decl_stmt|;
name|int
name|flags
decl_stmt|;
comment|/* Validate our arguments.  */
if|if
condition|(
operator|(
name|condition
operator|==
name|const_true_rtx
operator|&&
operator|!
name|thread_if_true
operator|)
operator|||
operator|(
operator|!
name|own_thread
operator|&&
operator|!
name|thread_if_true
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|flags
operator|=
name|get_jump_flags
argument_list|(
name|insn
argument_list|,
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If our thread is the end of subroutine, we can't get any delay      insns from that.  */
if|if
condition|(
name|thread
operator|==
literal|0
condition|)
return|return
name|delay_list
return|;
comment|/* If this is an unconditional branch, nothing is needed at the      opposite thread.  Otherwise, compute what is needed there.  */
if|if
condition|(
name|condition
operator|==
name|const_true_rtx
condition|)
name|CLEAR_RESOURCE
argument_list|(
operator|&
name|opposite_needed
argument_list|)
expr_stmt|;
else|else
name|mark_target_live_regs
argument_list|(
name|get_insns
argument_list|()
argument_list|,
name|opposite_thread
argument_list|,
operator|&
name|opposite_needed
argument_list|)
expr_stmt|;
comment|/* If the insn at THREAD can be split, do it here to avoid having to      update THREAD and NEW_THREAD if it is done in the loop below.  Also      initialize NEW_THREAD.  */
name|new_thread
operator|=
name|thread
operator|=
name|try_split
argument_list|(
name|PATTERN
argument_list|(
name|thread
argument_list|)
argument_list|,
name|thread
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Scan insns at THREAD.  We are looking for an insn that can be removed      from THREAD (it neither sets nor references resources that were set      ahead of it and it doesn't set anything needs by the insns ahead of      it) and that either can be placed in an annulling insn or aren't      needed at OPPOSITE_THREAD.  */
name|CLEAR_RESOURCE
argument_list|(
operator|&
name|needed
argument_list|)
expr_stmt|;
name|CLEAR_RESOURCE
argument_list|(
operator|&
name|set
argument_list|)
expr_stmt|;
comment|/* If we do not own this thread, we must stop as soon as we find      something that we can't put in a delay slot, since all we can do      is branch into THREAD at a later point.  Therefore, labels stop      the search if this is not the `true' thread.  */
for|for
control|(
name|trial
operator|=
name|thread
init|;
operator|!
name|stop_search_p
argument_list|(
name|trial
argument_list|,
operator|!
name|thread_if_true
argument_list|)
operator|&&
operator|(
operator|!
name|lose
operator|||
name|own_thread
operator|)
condition|;
name|trial
operator|=
name|next_nonnote_insn
argument_list|(
name|trial
argument_list|)
control|)
block|{
name|rtx
name|pat
decl_stmt|,
name|old_trial
decl_stmt|;
comment|/* If we have passed a label, we no longer own this thread.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|trial
argument_list|)
operator|==
name|CODE_LABEL
condition|)
block|{
name|own_thread
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
name|pat
operator|=
name|PATTERN
argument_list|(
name|trial
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|USE
operator|||
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|CLOBBER
condition|)
continue|continue;
comment|/* If TRIAL conflicts with the insns ahead of it, we lose.  Also, 	 don't separate or copy insns that set and use CC0.  */
if|if
condition|(
operator|!
name|insn_references_resource_p
argument_list|(
name|trial
argument_list|,
operator|&
name|set
argument_list|,
literal|1
argument_list|)
operator|&&
operator|!
name|insn_sets_resource_p
argument_list|(
name|trial
argument_list|,
operator|&
name|set
argument_list|,
literal|1
argument_list|)
operator|&&
operator|!
name|insn_sets_resource_p
argument_list|(
name|trial
argument_list|,
operator|&
name|needed
argument_list|,
literal|1
argument_list|)
ifdef|#
directive|ifdef
name|HAVE_cc0
operator|&&
operator|!
operator|(
name|reg_mentioned_p
argument_list|(
name|cc0_rtx
argument_list|,
name|pat
argument_list|)
operator|&&
operator|(
operator|!
name|own_thread
operator|||
operator|!
name|sets_cc0_p
argument_list|(
name|pat
argument_list|)
operator|)
operator|)
endif|#
directive|endif
condition|)
block|{
name|rtx
name|prior_insn
decl_stmt|;
comment|/* If TRIAL is redundant with some insn before INSN, we don't 	     actually need to add it to the delay list; we can merely pretend 	     we did.  */
if|if
condition|(
operator|(
name|prior_insn
operator|=
name|redundant_insn
argument_list|(
name|trial
argument_list|,
name|insn
argument_list|,
name|delay_list
argument_list|)
operator|)
condition|)
block|{
name|fix_reg_dead_note
argument_list|(
name|prior_insn
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|own_thread
condition|)
block|{
name|update_block
argument_list|(
name|trial
argument_list|,
name|thread
argument_list|)
expr_stmt|;
if|if
condition|(
name|trial
operator|==
name|thread
condition|)
block|{
name|thread
operator|=
name|next_active_insn
argument_list|(
name|thread
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_thread
operator|==
name|trial
condition|)
name|new_thread
operator|=
name|thread
expr_stmt|;
block|}
name|delete_related_insns
argument_list|(
name|trial
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|update_reg_unused_notes
argument_list|(
name|prior_insn
argument_list|,
name|trial
argument_list|)
expr_stmt|;
name|new_thread
operator|=
name|next_active_insn
argument_list|(
name|trial
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
comment|/* There are two ways we can win:  If TRIAL doesn't set anything 	     needed at the opposite thread and can't trap, or if it can 	     go into an annulled delay slot.  */
if|if
condition|(
operator|!
name|must_annul
operator|&&
operator|(
name|condition
operator|==
name|const_true_rtx
operator|||
operator|(
operator|!
name|insn_sets_resource_p
argument_list|(
name|trial
argument_list|,
operator|&
name|opposite_needed
argument_list|,
literal|1
argument_list|)
operator|&&
operator|!
name|may_trap_p
argument_list|(
name|pat
argument_list|)
operator|)
operator|)
condition|)
block|{
name|old_trial
operator|=
name|trial
expr_stmt|;
name|trial
operator|=
name|try_split
argument_list|(
name|pat
argument_list|,
name|trial
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_thread
operator|==
name|old_trial
condition|)
name|new_thread
operator|=
name|trial
expr_stmt|;
if|if
condition|(
name|thread
operator|==
name|old_trial
condition|)
name|thread
operator|=
name|trial
expr_stmt|;
name|pat
operator|=
name|PATTERN
argument_list|(
name|trial
argument_list|)
expr_stmt|;
if|if
condition|(
name|eligible_for_delay
argument_list|(
name|insn
argument_list|,
operator|*
name|pslots_filled
argument_list|,
name|trial
argument_list|,
name|flags
argument_list|)
condition|)
goto|goto
name|winner
goto|;
block|}
elseif|else
if|if
condition|(
literal|0
ifdef|#
directive|ifdef
name|ANNUL_IFTRUE_SLOTS
operator|||
operator|!
name|thread_if_true
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ANNUL_IFFALSE_SLOTS
operator|||
name|thread_if_true
endif|#
directive|endif
condition|)
block|{
name|old_trial
operator|=
name|trial
expr_stmt|;
name|trial
operator|=
name|try_split
argument_list|(
name|pat
argument_list|,
name|trial
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_thread
operator|==
name|old_trial
condition|)
name|new_thread
operator|=
name|trial
expr_stmt|;
if|if
condition|(
name|thread
operator|==
name|old_trial
condition|)
name|thread
operator|=
name|trial
expr_stmt|;
name|pat
operator|=
name|PATTERN
argument_list|(
name|trial
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|must_annul
operator|||
name|delay_list
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|thread_if_true
condition|?
name|check_annul_list_true_false
argument_list|(
literal|0
argument_list|,
name|delay_list
argument_list|)
operator|&&
name|eligible_for_annul_false
argument_list|(
name|insn
argument_list|,
operator|*
name|pslots_filled
argument_list|,
name|trial
argument_list|,
name|flags
argument_list|)
else|:
name|check_annul_list_true_false
argument_list|(
literal|1
argument_list|,
name|delay_list
argument_list|)
operator|&&
name|eligible_for_annul_true
argument_list|(
name|insn
argument_list|,
operator|*
name|pslots_filled
argument_list|,
name|trial
argument_list|,
name|flags
argument_list|)
operator|)
condition|)
block|{
name|rtx
name|temp
decl_stmt|;
name|must_annul
operator|=
literal|1
expr_stmt|;
name|winner
label|:
ifdef|#
directive|ifdef
name|HAVE_cc0
if|if
condition|(
name|reg_mentioned_p
argument_list|(
name|cc0_rtx
argument_list|,
name|pat
argument_list|)
condition|)
name|link_cc0_insns
argument_list|(
name|trial
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* If we own this thread, delete the insn.  If this is the 		     destination of a branch, show that a basic block status 		     may have been updated.  In any case, mark the new 		     starting point of this thread.  */
if|if
condition|(
name|own_thread
condition|)
block|{
name|rtx
name|note
decl_stmt|;
name|update_block
argument_list|(
name|trial
argument_list|,
name|thread
argument_list|)
expr_stmt|;
if|if
condition|(
name|trial
operator|==
name|thread
condition|)
block|{
name|thread
operator|=
name|next_active_insn
argument_list|(
name|thread
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_thread
operator|==
name|trial
condition|)
name|new_thread
operator|=
name|thread
expr_stmt|;
block|}
comment|/* We are moving this insn, not deleting it.  We must 			 temporarily increment the use count on any referenced 			 label lest it be deleted by delete_related_insns.  */
name|note
operator|=
name|find_reg_note
argument_list|(
name|trial
argument_list|,
name|REG_LABEL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|note
condition|)
name|LABEL_NUSES
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|++
expr_stmt|;
name|delete_related_insns
argument_list|(
name|trial
argument_list|)
expr_stmt|;
if|if
condition|(
name|note
condition|)
name|LABEL_NUSES
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|--
expr_stmt|;
block|}
else|else
name|new_thread
operator|=
name|next_active_insn
argument_list|(
name|trial
argument_list|)
expr_stmt|;
name|temp
operator|=
name|own_thread
condition|?
name|trial
else|:
name|copy_rtx
argument_list|(
name|trial
argument_list|)
expr_stmt|;
if|if
condition|(
name|thread_if_true
condition|)
name|INSN_FROM_TARGET_P
argument_list|(
name|temp
argument_list|)
operator|=
literal|1
expr_stmt|;
name|delay_list
operator|=
name|add_to_delay_list
argument_list|(
name|temp
argument_list|,
name|delay_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|slots_to_fill
operator|==
operator|++
operator|(
operator|*
name|pslots_filled
operator|)
condition|)
block|{
comment|/* Even though we have filled all the slots, we 			 may be branching to a location that has a 			 redundant insn.  Skip any if so.  */
while|while
condition|(
name|new_thread
operator|&&
operator|!
name|own_thread
operator|&&
operator|!
name|insn_sets_resource_p
argument_list|(
name|new_thread
argument_list|,
operator|&
name|set
argument_list|,
literal|1
argument_list|)
operator|&&
operator|!
name|insn_sets_resource_p
argument_list|(
name|new_thread
argument_list|,
operator|&
name|needed
argument_list|,
literal|1
argument_list|)
operator|&&
operator|!
name|insn_references_resource_p
argument_list|(
name|new_thread
argument_list|,
operator|&
name|set
argument_list|,
literal|1
argument_list|)
operator|&&
operator|(
name|prior_insn
operator|=
name|redundant_insn
argument_list|(
name|new_thread
argument_list|,
name|insn
argument_list|,
name|delay_list
argument_list|)
operator|)
condition|)
block|{
comment|/* We know we do not own the thread, so no need 			     to call update_block and delete_insn.  */
name|fix_reg_dead_note
argument_list|(
name|prior_insn
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|update_reg_unused_notes
argument_list|(
name|prior_insn
argument_list|,
name|new_thread
argument_list|)
expr_stmt|;
name|new_thread
operator|=
name|next_active_insn
argument_list|(
name|new_thread
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
continue|continue;
block|}
block|}
block|}
comment|/* This insn can't go into a delay slot.  */
name|lose
operator|=
literal|1
expr_stmt|;
name|mark_set_resources
argument_list|(
name|trial
argument_list|,
operator|&
name|set
argument_list|,
literal|0
argument_list|,
name|MARK_SRC_DEST_CALL
argument_list|)
expr_stmt|;
name|mark_referenced_resources
argument_list|(
name|trial
argument_list|,
operator|&
name|needed
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Ensure we don't put insns between the setting of cc and the comparison 	 by moving a setting of cc into an earlier delay slot since these insns 	 could clobber the condition code.  */
name|set
operator|.
name|cc
operator|=
literal|1
expr_stmt|;
comment|/* If this insn is a register-register copy and the next insn has 	 a use of our destination, change it to use our source.  That way, 	 it will become a candidate for our delay slot the next time 	 through this loop.  This case occurs commonly in loops that 	 scan a list.  	 We could check for more complex cases than those tested below, 	 but it doesn't seem worth it.  It might also be a good idea to try 	 to swap the two insns.  That might do better.  	 We can't do this if the next insn modifies our destination, because 	 that would make the replacement into the insn invalid.  We also can't 	 do this if it modifies our source, because it might be an earlyclobber 	 operand.  This latter test also prevents updating the contents of 	 a PRE_INC.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|trial
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|rtx
name|next
init|=
name|next_nonnote_insn
argument_list|(
name|trial
argument_list|)
decl_stmt|;
if|if
condition|(
name|next
operator|&&
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|next
argument_list|)
argument_list|)
operator|!=
name|USE
operator|&&
operator|!
name|reg_set_p
argument_list|(
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|,
name|next
argument_list|)
operator|&&
operator|!
name|reg_set_p
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|,
name|next
argument_list|)
operator|&&
name|reg_referenced_p
argument_list|(
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|,
name|PATTERN
argument_list|(
name|next
argument_list|)
argument_list|)
operator|&&
operator|!
name|modified_in_p
argument_list|(
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|,
name|next
argument_list|)
condition|)
name|validate_replace_rtx
argument_list|(
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|,
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If we stopped on a branch insn that has delay slots, see if we can      steal some of the insns in those slots.  */
if|if
condition|(
name|trial
operator|&&
name|GET_CODE
argument_list|(
name|trial
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|trial
argument_list|)
argument_list|)
operator|==
name|SEQUENCE
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|trial
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|JUMP_INSN
condition|)
block|{
comment|/* If this is the `true' thread, we will want to follow the jump, 	 so we can only do this if we have taken everything up to here.  */
if|if
condition|(
name|thread_if_true
operator|&&
name|trial
operator|==
name|new_thread
condition|)
block|{
name|delay_list
operator|=
name|steal_delay_list_from_target
argument_list|(
name|insn
argument_list|,
name|condition
argument_list|,
name|PATTERN
argument_list|(
name|trial
argument_list|)
argument_list|,
name|delay_list
argument_list|,
operator|&
name|set
argument_list|,
operator|&
name|needed
argument_list|,
operator|&
name|opposite_needed
argument_list|,
name|slots_to_fill
argument_list|,
name|pslots_filled
argument_list|,
operator|&
name|must_annul
argument_list|,
operator|&
name|new_thread
argument_list|)
expr_stmt|;
comment|/* If we owned the thread and are told that it branched 	     elsewhere, make sure we own the thread at the new location.  */
if|if
condition|(
name|own_thread
operator|&&
name|trial
operator|!=
name|new_thread
condition|)
name|own_thread
operator|=
name|own_thread_p
argument_list|(
name|new_thread
argument_list|,
name|new_thread
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|thread_if_true
condition|)
name|delay_list
operator|=
name|steal_delay_list_from_fallthrough
argument_list|(
name|insn
argument_list|,
name|condition
argument_list|,
name|PATTERN
argument_list|(
name|trial
argument_list|)
argument_list|,
name|delay_list
argument_list|,
operator|&
name|set
argument_list|,
operator|&
name|needed
argument_list|,
operator|&
name|opposite_needed
argument_list|,
name|slots_to_fill
argument_list|,
name|pslots_filled
argument_list|,
operator|&
name|must_annul
argument_list|)
expr_stmt|;
block|}
comment|/* If we haven't found anything for this delay slot and it is very      likely that the branch will be taken, see if the insn at our target      increments or decrements a register with an increment that does not      depend on the destination register.  If so, try to place the opposite      arithmetic insn after the jump insn and put the arithmetic insn in the      delay slot.  If we can't do this, return.  */
if|if
condition|(
name|delay_list
operator|==
literal|0
operator|&&
name|likely
operator|&&
name|new_thread
operator|&&
name|GET_CODE
argument_list|(
name|new_thread
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|new_thread
argument_list|)
argument_list|)
operator|!=
name|ASM_INPUT
operator|&&
name|asm_noperands
argument_list|(
name|PATTERN
argument_list|(
name|new_thread
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|new_thread
argument_list|)
decl_stmt|;
name|rtx
name|dest
decl_stmt|;
name|rtx
name|src
decl_stmt|;
name|trial
operator|=
name|new_thread
expr_stmt|;
name|pat
operator|=
name|PATTERN
argument_list|(
name|trial
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|trial
argument_list|)
operator|!=
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|!=
name|SET
operator|||
operator|!
name|eligible_for_delay
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|,
name|trial
argument_list|,
name|flags
argument_list|)
condition|)
return|return
literal|0
return|;
name|dest
operator|=
name|SET_DEST
argument_list|(
name|pat
argument_list|)
operator|,
name|src
operator|=
name|SET_SRC
argument_list|(
name|pat
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|PLUS
operator|||
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|MINUS
operator|)
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|,
name|dest
argument_list|)
operator|&&
operator|!
name|reg_overlap_mentioned_p
argument_list|(
name|dest
argument_list|,
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|pat
argument_list|)
condition|)
block|{
name|rtx
name|other
init|=
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|rtx
name|new_arith
decl_stmt|;
name|rtx
name|ninsn
decl_stmt|;
comment|/* If this is a constant adjustment, use the same code with 	     the negated constant.  Otherwise, reverse the sense of the 	     arithmetic.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|other
argument_list|)
operator|==
name|CONST_INT
condition|)
name|new_arith
operator|=
name|gen_rtx_fmt_ee
argument_list|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|src
argument_list|)
argument_list|,
name|dest
argument_list|,
name|negate_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|src
argument_list|)
argument_list|,
name|other
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|new_arith
operator|=
name|gen_rtx_fmt_ee
argument_list|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|PLUS
condition|?
name|MINUS
else|:
name|PLUS
argument_list|,
name|GET_MODE
argument_list|(
name|src
argument_list|)
argument_list|,
name|dest
argument_list|,
name|other
argument_list|)
expr_stmt|;
name|ninsn
operator|=
name|emit_insn_after
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|dest
argument_list|,
name|new_arith
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|recog_memoized
argument_list|(
name|ninsn
argument_list|)
operator|<
literal|0
operator|||
operator|(
name|extract_insn
argument_list|(
name|ninsn
argument_list|)
operator|,
operator|!
name|constrain_operands
argument_list|(
literal|1
argument_list|)
operator|)
condition|)
block|{
name|delete_related_insns
argument_list|(
name|ninsn
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|own_thread
condition|)
block|{
name|update_block
argument_list|(
name|trial
argument_list|,
name|thread
argument_list|)
expr_stmt|;
if|if
condition|(
name|trial
operator|==
name|thread
condition|)
block|{
name|thread
operator|=
name|next_active_insn
argument_list|(
name|thread
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_thread
operator|==
name|trial
condition|)
name|new_thread
operator|=
name|thread
expr_stmt|;
block|}
name|delete_related_insns
argument_list|(
name|trial
argument_list|)
expr_stmt|;
block|}
else|else
name|new_thread
operator|=
name|next_active_insn
argument_list|(
name|trial
argument_list|)
expr_stmt|;
name|ninsn
operator|=
name|own_thread
condition|?
name|trial
else|:
name|copy_rtx
argument_list|(
name|trial
argument_list|)
expr_stmt|;
if|if
condition|(
name|thread_if_true
condition|)
name|INSN_FROM_TARGET_P
argument_list|(
name|ninsn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|delay_list
operator|=
name|add_to_delay_list
argument_list|(
name|ninsn
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
operator|(
operator|*
name|pslots_filled
operator|)
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|delay_list
operator|&&
name|must_annul
condition|)
name|INSN_ANNULLED_BRANCH_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* If we are to branch into the middle of this thread, find an appropriate      label or make a new one if none, and redirect INSN to it.  If we hit the      end of the function, use the end-of-function label.  */
if|if
condition|(
name|new_thread
operator|!=
name|thread
condition|)
block|{
name|rtx
name|label
decl_stmt|;
if|if
condition|(
operator|!
name|thread_if_true
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|new_thread
operator|&&
name|GET_CODE
argument_list|(
name|new_thread
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
operator|(
name|simplejump_p
argument_list|(
name|new_thread
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|new_thread
argument_list|)
argument_list|)
operator|==
name|RETURN
operator|)
operator|&&
name|redirect_with_delay_list_safe_p
argument_list|(
name|insn
argument_list|,
name|JUMP_LABEL
argument_list|(
name|new_thread
argument_list|)
argument_list|,
name|delay_list
argument_list|)
condition|)
name|new_thread
operator|=
name|follow_jumps
argument_list|(
name|JUMP_LABEL
argument_list|(
name|new_thread
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_thread
operator|==
literal|0
condition|)
name|label
operator|=
name|find_end_label
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|new_thread
argument_list|)
operator|==
name|CODE_LABEL
condition|)
name|label
operator|=
name|new_thread
expr_stmt|;
else|else
name|label
operator|=
name|get_label_before
argument_list|(
name|new_thread
argument_list|)
expr_stmt|;
name|reorg_redirect_jump
argument_list|(
name|insn
argument_list|,
name|label
argument_list|)
expr_stmt|;
block|}
return|return
name|delay_list
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Make another attempt to find insns to place in delay slots.     We previously looked for insns located in front of the delay insn    and, for non-jump delay insns, located behind the delay insn.     Here only try to schedule jump insns and try to move insns from either    the target or the following insns into the delay slot.  If annulling is    supported, we will be likely to do this.  Otherwise, we can do this only    if safe.  */
end_comment

begin_function
specifier|static
name|void
name|fill_eager_delay_slots
parameter_list|()
block|{
name|rtx
name|insn
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|num_unfilled_slots
init|=
name|unfilled_slots_next
operator|-
name|unfilled_slots_base
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_unfilled_slots
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|condition
decl_stmt|;
name|rtx
name|target_label
decl_stmt|,
name|insn_at_target
decl_stmt|,
name|fallthrough_insn
decl_stmt|;
name|rtx
name|delay_list
init|=
literal|0
decl_stmt|;
name|int
name|own_target
decl_stmt|;
name|int
name|own_fallthrough
decl_stmt|;
name|int
name|prediction
decl_stmt|,
name|slots_to_fill
decl_stmt|,
name|slots_filled
decl_stmt|;
name|insn
operator|=
name|unfilled_slots_base
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|insn
operator|==
literal|0
operator|||
name|INSN_DELETED_P
argument_list|(
name|insn
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|JUMP_INSN
operator|||
operator|!
operator|(
name|condjump_p
argument_list|(
name|insn
argument_list|)
operator|||
name|condjump_in_parallel_p
argument_list|(
name|insn
argument_list|)
operator|)
condition|)
continue|continue;
name|slots_to_fill
operator|=
name|num_delay_slots
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Some machine description have defined instructions to have 	 delay slots only in certain circumstances which may depend on 	 nearby insns (which change due to reorg's actions).   	 For example, the PA port normally has delay slots for unconditional 	 jumps.  	 However, the PA port claims such jumps do not have a delay slot 	 if they are immediate successors of certain CALL_INSNs.  This 	 allows the port to favor filling the delay slot of the call with 	 the unconditional jump.  */
if|if
condition|(
name|slots_to_fill
operator|==
literal|0
condition|)
continue|continue;
name|slots_filled
operator|=
literal|0
expr_stmt|;
name|target_label
operator|=
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|condition
operator|=
name|get_branch_condition
argument_list|(
name|insn
argument_list|,
name|target_label
argument_list|)
expr_stmt|;
if|if
condition|(
name|condition
operator|==
literal|0
condition|)
continue|continue;
comment|/* Get the next active fallthrough and target insns and see if we own 	 them.  Then see whether the branch is likely true.  We don't need 	 to do a lot of this for unconditional branches.  */
name|insn_at_target
operator|=
name|next_active_insn
argument_list|(
name|target_label
argument_list|)
expr_stmt|;
name|own_target
operator|=
name|own_thread_p
argument_list|(
name|target_label
argument_list|,
name|target_label
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|condition
operator|==
name|const_true_rtx
condition|)
block|{
name|own_fallthrough
operator|=
literal|0
expr_stmt|;
name|fallthrough_insn
operator|=
literal|0
expr_stmt|;
name|prediction
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|fallthrough_insn
operator|=
name|next_active_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|own_fallthrough
operator|=
name|own_thread_p
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|prediction
operator|=
name|mostly_true_jump
argument_list|(
name|insn
argument_list|,
name|condition
argument_list|)
expr_stmt|;
block|}
comment|/* If this insn is expected to branch, first try to get insns from our 	 target, then our fallthrough insns.  If it is not expected to branch, 	 try the other order.  */
if|if
condition|(
name|prediction
operator|>
literal|0
condition|)
block|{
name|delay_list
operator|=
name|fill_slots_from_thread
argument_list|(
name|insn
argument_list|,
name|condition
argument_list|,
name|insn_at_target
argument_list|,
name|fallthrough_insn
argument_list|,
name|prediction
operator|==
literal|2
argument_list|,
literal|1
argument_list|,
name|own_target
argument_list|,
name|slots_to_fill
argument_list|,
operator|&
name|slots_filled
argument_list|,
name|delay_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|delay_list
operator|==
literal|0
operator|&&
name|own_fallthrough
condition|)
block|{
comment|/* Even though we didn't find anything for delay slots, 		 we might have found a redundant insn which we deleted 		 from the thread that was filled.  So we have to recompute 		 the next insn at the target.  */
name|target_label
operator|=
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|insn_at_target
operator|=
name|next_active_insn
argument_list|(
name|target_label
argument_list|)
expr_stmt|;
name|delay_list
operator|=
name|fill_slots_from_thread
argument_list|(
name|insn
argument_list|,
name|condition
argument_list|,
name|fallthrough_insn
argument_list|,
name|insn_at_target
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|own_fallthrough
argument_list|,
name|slots_to_fill
argument_list|,
operator|&
name|slots_filled
argument_list|,
name|delay_list
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|own_fallthrough
condition|)
name|delay_list
operator|=
name|fill_slots_from_thread
argument_list|(
name|insn
argument_list|,
name|condition
argument_list|,
name|fallthrough_insn
argument_list|,
name|insn_at_target
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|own_fallthrough
argument_list|,
name|slots_to_fill
argument_list|,
operator|&
name|slots_filled
argument_list|,
name|delay_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|delay_list
operator|==
literal|0
condition|)
name|delay_list
operator|=
name|fill_slots_from_thread
argument_list|(
name|insn
argument_list|,
name|condition
argument_list|,
name|insn_at_target
argument_list|,
name|next_active_insn
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|own_target
argument_list|,
name|slots_to_fill
argument_list|,
operator|&
name|slots_filled
argument_list|,
name|delay_list
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|delay_list
condition|)
name|unfilled_slots_base
index|[
name|i
index|]
operator|=
name|emit_delay_sequence
argument_list|(
name|insn
argument_list|,
name|delay_list
argument_list|,
name|slots_filled
argument_list|)
expr_stmt|;
if|if
condition|(
name|slots_to_fill
operator|==
name|slots_filled
condition|)
name|unfilled_slots_base
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|note_delay_statistics
argument_list|(
name|slots_filled
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Once we have tried two ways to fill a delay slot, make a pass over the    code to try to improve the results and to do such things as more jump    threading.  */
end_comment

begin_function
specifier|static
name|void
name|relax_delay_slots
parameter_list|(
name|first
parameter_list|)
name|rtx
name|first
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|,
name|next
decl_stmt|,
name|pat
decl_stmt|;
name|rtx
name|trial
decl_stmt|,
name|delay_insn
decl_stmt|,
name|target_label
decl_stmt|;
comment|/* Look at every JUMP_INSN and see if we can improve it.  */
for|for
control|(
name|insn
operator|=
name|first
init|;
name|insn
condition|;
name|insn
operator|=
name|next
control|)
block|{
name|rtx
name|other
decl_stmt|;
name|next
operator|=
name|next_active_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* If this is a jump insn, see if it now jumps to a jump, jumps to 	 the next insn, or jumps to a label that is not the last of a 	 group of consecutive labels.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
operator|(
name|condjump_p
argument_list|(
name|insn
argument_list|)
operator|||
name|condjump_in_parallel_p
argument_list|(
name|insn
argument_list|)
operator|)
operator|&&
operator|(
name|target_label
operator|=
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|target_label
operator|=
name|follow_jumps
argument_list|(
name|target_label
argument_list|)
expr_stmt|;
name|target_label
operator|=
name|prev_label
argument_list|(
name|next_active_insn
argument_list|(
name|target_label
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_label
operator|==
literal|0
condition|)
name|target_label
operator|=
name|find_end_label
argument_list|()
expr_stmt|;
if|if
condition|(
name|next_active_insn
argument_list|(
name|target_label
argument_list|)
operator|==
name|next
operator|&&
operator|!
name|condjump_in_parallel_p
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|delete_jump
argument_list|(
name|insn
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|target_label
operator|!=
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
condition|)
name|reorg_redirect_jump
argument_list|(
name|insn
argument_list|,
name|target_label
argument_list|)
expr_stmt|;
comment|/* See if this jump branches around an unconditional jump. 	     If so, invert this jump and point it to the target of the 	     second jump.  */
if|if
condition|(
name|next
operator|&&
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
operator|(
name|simplejump_p
argument_list|(
name|next
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|next
argument_list|)
argument_list|)
operator|==
name|RETURN
operator|)
operator|&&
name|next_active_insn
argument_list|(
name|target_label
argument_list|)
operator|==
name|next_active_insn
argument_list|(
name|next
argument_list|)
operator|&&
name|no_labels_between_p
argument_list|(
name|insn
argument_list|,
name|next
argument_list|)
condition|)
block|{
name|rtx
name|label
init|=
name|JUMP_LABEL
argument_list|(
name|next
argument_list|)
decl_stmt|;
comment|/* Be careful how we do this to avoid deleting code or 		 labels that are momentarily dead.  See similar optimization 		 in jump.c.  		 We also need to ensure we properly handle the case when 		 invert_jump fails.  */
operator|++
name|LABEL_NUSES
argument_list|(
name|target_label
argument_list|)
expr_stmt|;
if|if
condition|(
name|label
condition|)
operator|++
name|LABEL_NUSES
argument_list|(
name|label
argument_list|)
expr_stmt|;
if|if
condition|(
name|invert_jump
argument_list|(
name|insn
argument_list|,
name|label
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|delete_related_insns
argument_list|(
name|next
argument_list|)
expr_stmt|;
name|next
operator|=
name|insn
expr_stmt|;
block|}
if|if
condition|(
name|label
condition|)
operator|--
name|LABEL_NUSES
argument_list|(
name|label
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|LABEL_NUSES
argument_list|(
name|target_label
argument_list|)
operator|==
literal|0
condition|)
name|delete_related_insns
argument_list|(
name|target_label
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* If this is an unconditional jump and the previous insn is a 	 conditional jump, try reversing the condition of the previous 	 insn and swapping our targets.  The next pass might be able to 	 fill the slots.  	 Don't do this if we expect the conditional branch to be true, because 	 we would then be making the more common case longer.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
operator|(
name|simplejump_p
argument_list|(
name|insn
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|RETURN
operator|)
operator|&&
operator|(
name|other
operator|=
name|prev_active_insn
argument_list|(
name|insn
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|condjump_p
argument_list|(
name|other
argument_list|)
operator|||
name|condjump_in_parallel_p
argument_list|(
name|other
argument_list|)
operator|)
operator|&&
name|no_labels_between_p
argument_list|(
name|other
argument_list|,
name|insn
argument_list|)
operator|&&
literal|0
operator|>
name|mostly_true_jump
argument_list|(
name|other
argument_list|,
name|get_branch_condition
argument_list|(
name|other
argument_list|,
name|JUMP_LABEL
argument_list|(
name|other
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|other_target
init|=
name|JUMP_LABEL
argument_list|(
name|other
argument_list|)
decl_stmt|;
name|target_label
operator|=
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|invert_jump
argument_list|(
name|other
argument_list|,
name|target_label
argument_list|,
literal|0
argument_list|)
condition|)
name|reorg_redirect_jump
argument_list|(
name|insn
argument_list|,
name|other_target
argument_list|)
expr_stmt|;
block|}
comment|/* Now look only at cases where we have filled a delay slot.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|SEQUENCE
condition|)
continue|continue;
name|pat
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|delay_insn
operator|=
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* See if the first insn in the delay slot is redundant with some 	 previous insn.  Remove it from the delay slot if so; then set up 	 to reprocess this insn.  */
if|if
condition|(
name|redundant_insn
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|delay_insn
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|delete_from_delay_slot
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|next
operator|=
name|prev_active_insn
argument_list|(
name|next
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* See if we have a RETURN insn with a filled delay slot followed 	 by a RETURN insn with an unfilled a delay slot.  If so, we can delete 	 the first RETURN (but not it's delay insn).  This gives the same 	 effect in fewer instructions.  	 Only do so if optimizing for size since this results in slower, but 	 smaller code.  */
if|if
condition|(
name|optimize_size
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|delay_insn
argument_list|)
argument_list|)
operator|==
name|RETURN
operator|&&
name|next
operator|&&
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|next
argument_list|)
argument_list|)
operator|==
name|RETURN
condition|)
block|{
name|int
name|i
decl_stmt|;
comment|/* Delete the RETURN and just execute the delay list insns.  	     We do this by deleting the INSN containing the SEQUENCE, then 	     re-emitting the insns separately, and then deleting the RETURN. 	     This allows the count of the jump target to be properly 	     decremented.  */
comment|/* Clear the from target bit, since these insns are no longer 	     in delay slots.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
name|INSN_FROM_TARGET_P
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
name|trial
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|delete_related_insns
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|emit_insn_after
argument_list|(
name|pat
argument_list|,
name|trial
argument_list|)
expr_stmt|;
name|delete_scheduled_jump
argument_list|(
name|delay_insn
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Now look only at the cases where we have a filled JUMP_INSN.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|JUMP_INSN
operator|||
operator|!
operator|(
name|condjump_p
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
name|condjump_in_parallel_p
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
condition|)
continue|continue;
name|target_label
operator|=
name|JUMP_LABEL
argument_list|(
name|delay_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_label
condition|)
block|{
comment|/* If this jump goes to another unconditional jump, thread it, but 	     don't convert a jump into a RETURN here.  */
name|trial
operator|=
name|follow_jumps
argument_list|(
name|target_label
argument_list|)
expr_stmt|;
comment|/* We use next_real_insn instead of next_active_insn, so that 	     the special USE insns emitted by reorg won't be ignored. 	     If they are ignored, then they will get deleted if target_label 	     is now unreachable, and that would cause mark_target_live_regs 	     to fail.  */
name|trial
operator|=
name|prev_label
argument_list|(
name|next_real_insn
argument_list|(
name|trial
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|trial
operator|==
literal|0
operator|&&
name|target_label
operator|!=
literal|0
condition|)
name|trial
operator|=
name|find_end_label
argument_list|()
expr_stmt|;
if|if
condition|(
name|trial
operator|!=
name|target_label
operator|&&
name|redirect_with_delay_slots_safe_p
argument_list|(
name|delay_insn
argument_list|,
name|trial
argument_list|,
name|insn
argument_list|)
condition|)
block|{
name|reorg_redirect_jump
argument_list|(
name|delay_insn
argument_list|,
name|trial
argument_list|)
expr_stmt|;
name|target_label
operator|=
name|trial
expr_stmt|;
block|}
comment|/* If the first insn at TARGET_LABEL is redundant with a previous 	     insn, redirect the jump to the following insn process again.  */
name|trial
operator|=
name|next_active_insn
argument_list|(
name|target_label
argument_list|)
expr_stmt|;
if|if
condition|(
name|trial
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|trial
argument_list|)
argument_list|)
operator|!=
name|SEQUENCE
operator|&&
name|redundant_insn
argument_list|(
name|trial
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|rtx
name|tmp
decl_stmt|;
comment|/* Figure out where to emit the special USE insn so we don't 		 later incorrectly compute register live/death info.  */
name|tmp
operator|=
name|next_active_insn
argument_list|(
name|trial
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
literal|0
condition|)
name|tmp
operator|=
name|find_end_label
argument_list|()
expr_stmt|;
comment|/* Insert the special USE insn and update dataflow info.  */
name|update_block
argument_list|(
name|trial
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* Now emit a label before the special USE insn, and 		 redirect our jump to the new label.  */
name|target_label
operator|=
name|get_label_before
argument_list|(
name|PREV_INSN
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
name|reorg_redirect_jump
argument_list|(
name|delay_insn
argument_list|,
name|target_label
argument_list|)
expr_stmt|;
name|next
operator|=
name|insn
expr_stmt|;
continue|continue;
block|}
comment|/* Similarly, if it is an unconditional jump with one insn in its 	     delay list and that insn is redundant, thread the jump.  */
if|if
condition|(
name|trial
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|trial
argument_list|)
argument_list|)
operator|==
name|SEQUENCE
operator|&&
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|trial
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
literal|2
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|trial
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
operator|(
name|simplejump_p
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|trial
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|trial
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|RETURN
operator|)
operator|&&
name|redundant_insn
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|trial
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|target_label
operator|=
name|JUMP_LABEL
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|trial
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_label
operator|==
literal|0
condition|)
name|target_label
operator|=
name|find_end_label
argument_list|()
expr_stmt|;
if|if
condition|(
name|redirect_with_delay_slots_safe_p
argument_list|(
name|delay_insn
argument_list|,
name|target_label
argument_list|,
name|insn
argument_list|)
condition|)
block|{
name|reorg_redirect_jump
argument_list|(
name|delay_insn
argument_list|,
name|target_label
argument_list|)
expr_stmt|;
name|next
operator|=
name|insn
expr_stmt|;
continue|continue;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|INSN_ANNULLED_BRANCH_P
argument_list|(
name|delay_insn
argument_list|)
operator|&&
name|prev_active_insn
argument_list|(
name|target_label
argument_list|)
operator|==
name|insn
operator|&&
operator|!
name|condjump_in_parallel_p
argument_list|(
name|delay_insn
argument_list|)
ifdef|#
directive|ifdef
name|HAVE_cc0
comment|/* If the last insn in the delay slot sets CC0 for some insn, 	     various code assumes that it is in a delay slot.  We could 	     put it back where it belonged and delete the register notes, 	     but it doesn't seem worthwhile in this uncommon case.  */
operator|&&
operator|!
name|find_reg_note
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
argument_list|)
argument_list|,
name|REG_CC_USER
argument_list|,
name|NULL_RTX
argument_list|)
endif|#
directive|endif
condition|)
block|{
name|int
name|i
decl_stmt|;
comment|/* All this insn does is execute its delay list and jump to the 	     following insn.  So delete the jump and just execute the delay 	     list insns.  	     We do this by deleting the INSN containing the SEQUENCE, then 	     re-emitting the insns separately, and then deleting the jump. 	     This allows the count of the jump target to be properly 	     decremented.  */
comment|/* Clear the from target bit, since these insns are no longer 	     in delay slots.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
name|INSN_FROM_TARGET_P
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
name|trial
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|delete_related_insns
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|emit_insn_after
argument_list|(
name|pat
argument_list|,
name|trial
argument_list|)
expr_stmt|;
name|delete_scheduled_jump
argument_list|(
name|delay_insn
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* See if this is an unconditional jump around a single insn which is 	 identical to the one in its delay slot.  In this case, we can just 	 delete the branch and the insn in its delay slot.  */
if|if
condition|(
name|next
operator|&&
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|INSN
operator|&&
name|prev_label
argument_list|(
name|next_active_insn
argument_list|(
name|next
argument_list|)
argument_list|)
operator|==
name|target_label
operator|&&
name|simplejump_p
argument_list|(
name|insn
argument_list|)
operator|&&
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
operator|==
literal|2
operator|&&
name|rtx_equal_p
argument_list|(
name|PATTERN
argument_list|(
name|next
argument_list|)
argument_list|,
name|PATTERN
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|delete_related_insns
argument_list|(
name|insn
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* See if this jump (with its delay slots) branches around another 	 jump (without delay slots).  If so, invert this jump and point 	 it to the target of the second jump.  We cannot do this for 	 annulled jumps, though.  Again, don't convert a jump to a RETURN 	 here.  */
if|if
condition|(
operator|!
name|INSN_ANNULLED_BRANCH_P
argument_list|(
name|delay_insn
argument_list|)
operator|&&
name|next
operator|&&
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
operator|(
name|simplejump_p
argument_list|(
name|next
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|next
argument_list|)
argument_list|)
operator|==
name|RETURN
operator|)
operator|&&
name|next_active_insn
argument_list|(
name|target_label
argument_list|)
operator|==
name|next_active_insn
argument_list|(
name|next
argument_list|)
operator|&&
name|no_labels_between_p
argument_list|(
name|insn
argument_list|,
name|next
argument_list|)
condition|)
block|{
name|rtx
name|label
init|=
name|JUMP_LABEL
argument_list|(
name|next
argument_list|)
decl_stmt|;
name|rtx
name|old_label
init|=
name|JUMP_LABEL
argument_list|(
name|delay_insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|label
operator|==
literal|0
condition|)
name|label
operator|=
name|find_end_label
argument_list|()
expr_stmt|;
comment|/* find_end_label can generate a new label. Check this first.  */
if|if
condition|(
name|no_labels_between_p
argument_list|(
name|insn
argument_list|,
name|next
argument_list|)
operator|&&
name|redirect_with_delay_slots_safe_p
argument_list|(
name|delay_insn
argument_list|,
name|label
argument_list|,
name|insn
argument_list|)
condition|)
block|{
comment|/* Be careful how we do this to avoid deleting code or labels 		 that are momentarily dead.  See similar optimization in 		 jump.c  */
if|if
condition|(
name|old_label
condition|)
operator|++
name|LABEL_NUSES
argument_list|(
name|old_label
argument_list|)
expr_stmt|;
if|if
condition|(
name|invert_jump
argument_list|(
name|delay_insn
argument_list|,
name|label
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|int
name|i
decl_stmt|;
comment|/* Must update the INSN_FROM_TARGET_P bits now that 		     the branch is reversed, so that mark_target_live_regs 		     will handle the delay slot insn correctly.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|slot
init|=
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|INSN_FROM_TARGET_P
argument_list|(
name|slot
argument_list|)
operator|=
operator|!
name|INSN_FROM_TARGET_P
argument_list|(
name|slot
argument_list|)
expr_stmt|;
block|}
name|delete_related_insns
argument_list|(
name|next
argument_list|)
expr_stmt|;
name|next
operator|=
name|insn
expr_stmt|;
block|}
if|if
condition|(
name|old_label
operator|&&
operator|--
name|LABEL_NUSES
argument_list|(
name|old_label
argument_list|)
operator|==
literal|0
condition|)
name|delete_related_insns
argument_list|(
name|old_label
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* If we own the thread opposite the way this insn branches, see if we 	 can merge its delay slots with following insns.  */
if|if
condition|(
name|INSN_FROM_TARGET_P
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|own_thread_p
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
condition|)
name|try_merge_delay_insns
argument_list|(
name|insn
argument_list|,
name|next
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|INSN_FROM_TARGET_P
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|own_thread_p
argument_list|(
name|target_label
argument_list|,
name|target_label
argument_list|,
literal|0
argument_list|)
condition|)
name|try_merge_delay_insns
argument_list|(
name|insn
argument_list|,
name|next_active_insn
argument_list|(
name|target_label
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we get here, we haven't deleted INSN.  But we may have deleted 	 NEXT, so recompute it.  */
name|next
operator|=
name|next_active_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_return
end_ifdef

begin_comment
comment|/* Look for filled jumps to the end of function label.  We can try to convert    them into RETURN insns if the insns in the delay slot are valid for the    RETURN as well.  */
end_comment

begin_function
specifier|static
name|void
name|make_return_insns
parameter_list|(
name|first
parameter_list|)
name|rtx
name|first
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|,
name|jump_insn
decl_stmt|,
name|pat
decl_stmt|;
name|rtx
name|real_return_label
init|=
name|end_of_function_label
decl_stmt|;
name|int
name|slots
decl_stmt|,
name|i
decl_stmt|;
comment|/* See if there is a RETURN insn in the function other than the one we      made for END_OF_FUNCTION_LABEL.  If so, set up anything we can't change      into a RETURN to jump to it.  */
for|for
control|(
name|insn
operator|=
name|first
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|RETURN
condition|)
block|{
name|real_return_label
operator|=
name|get_label_before
argument_list|(
name|insn
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Show an extra usage of REAL_RETURN_LABEL so it won't go away if it      was equal to END_OF_FUNCTION_LABEL.  */
name|LABEL_NUSES
argument_list|(
name|real_return_label
argument_list|)
operator|++
expr_stmt|;
comment|/* Clear the list of insns to fill so we can use it.  */
name|obstack_free
argument_list|(
operator|&
name|unfilled_slots_obstack
argument_list|,
name|unfilled_firstobj
argument_list|)
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|first
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|int
name|flags
decl_stmt|;
comment|/* Only look at filled JUMP_INSNs that go to the end of function 	 label.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|SEQUENCE
operator|||
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|JUMP_INSN
operator|||
name|JUMP_LABEL
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|end_of_function_label
condition|)
continue|continue;
name|pat
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|jump_insn
operator|=
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If we can't make the jump into a RETURN, try to redirect it to the best 	 RETURN and go on to the next insn.  */
if|if
condition|(
operator|!
name|reorg_redirect_jump
argument_list|(
name|jump_insn
argument_list|,
name|NULL_RTX
argument_list|)
condition|)
block|{
comment|/* Make sure redirecting the jump will not invalidate the delay 	     slot insns.  */
if|if
condition|(
name|redirect_with_delay_slots_safe_p
argument_list|(
name|jump_insn
argument_list|,
name|real_return_label
argument_list|,
name|insn
argument_list|)
condition|)
name|reorg_redirect_jump
argument_list|(
name|jump_insn
argument_list|,
name|real_return_label
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* See if this RETURN can accept the insns current in its delay slot. 	 It can if it has more or an equal number of slots and the contents 	 of each is valid.  */
name|flags
operator|=
name|get_jump_flags
argument_list|(
name|jump_insn
argument_list|,
name|JUMP_LABEL
argument_list|(
name|jump_insn
argument_list|)
argument_list|)
expr_stmt|;
name|slots
operator|=
name|num_delay_slots
argument_list|(
name|jump_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|slots
operator|>=
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
operator|(
ifdef|#
directive|ifdef
name|ANNUL_IFFALSE_SLOTS
operator|(
name|INSN_ANNULLED_BRANCH_P
argument_list|(
name|jump_insn
argument_list|)
operator|&&
name|INSN_FROM_TARGET_P
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|)
condition|?
name|eligible_for_annul_false
argument_list|(
name|jump_insn
argument_list|,
name|i
operator|-
literal|1
argument_list|,
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|flags
argument_list|)
else|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ANNUL_IFTRUE_SLOTS
operator|(
name|INSN_ANNULLED_BRANCH_P
argument_list|(
name|jump_insn
argument_list|)
operator|&&
operator|!
name|INSN_FROM_TARGET_P
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|)
condition|?
name|eligible_for_annul_true
argument_list|(
name|jump_insn
argument_list|,
name|i
operator|-
literal|1
argument_list|,
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|flags
argument_list|)
else|:
endif|#
directive|endif
name|eligible_for_delay
argument_list|(
name|jump_insn
argument_list|,
name|i
operator|-
literal|1
argument_list|,
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|flags
argument_list|)
operator|)
condition|)
break|break;
block|}
else|else
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
condition|)
continue|continue;
comment|/* We have to do something with this insn.  If it is an unconditional 	 RETURN, delete the SEQUENCE and output the individual insns, 	 followed by the RETURN.  Then set things up so we try to find 	 insns for its delay slots, if it needs some.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|jump_insn
argument_list|)
argument_list|)
operator|==
name|RETURN
condition|)
block|{
name|rtx
name|prev
init|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|delete_related_insns
argument_list|(
name|insn
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
name|prev
operator|=
name|emit_insn_after
argument_list|(
name|PATTERN
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|,
name|prev
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_jump_insn_after
argument_list|(
name|PATTERN
argument_list|(
name|jump_insn
argument_list|)
argument_list|,
name|prev
argument_list|)
expr_stmt|;
name|emit_barrier_after
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|slots
condition|)
name|obstack_ptr_grow
argument_list|(
operator|&
name|unfilled_slots_obstack
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* It is probably more efficient to keep this with its current 	   delay slot as a branch to a RETURN.  */
name|reorg_redirect_jump
argument_list|(
name|jump_insn
argument_list|,
name|real_return_label
argument_list|)
expr_stmt|;
block|}
comment|/* Now delete REAL_RETURN_LABEL if we never used it.  Then try to fill any      new delay slots we have created.  */
if|if
condition|(
operator|--
name|LABEL_NUSES
argument_list|(
name|real_return_label
argument_list|)
operator|==
literal|0
condition|)
name|delete_related_insns
argument_list|(
name|real_return_label
argument_list|)
expr_stmt|;
name|fill_simple_delay_slots
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|fill_simple_delay_slots
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Try to find insns to place in delay slots.  */
end_comment

begin_function
name|void
name|dbr_schedule
parameter_list|(
name|first
parameter_list|,
name|file
parameter_list|)
name|rtx
name|first
decl_stmt|;
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|,
name|next
decl_stmt|,
name|epilogue_insn
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
if|#
directive|if
literal|0
block|int old_flag_no_peephole = flag_no_peephole;
comment|/* Execute `final' once in prescan mode to delete any insns that won't be      used.  Don't let final try to do any peephole optimization--it will      ruin dataflow information for this pass.  */
block|flag_no_peephole = 1;   final (first, 0, NO_DEBUG, 1, 1);   flag_no_peephole = old_flag_no_peephole;
endif|#
directive|endif
comment|/* If the current function has no insns other than the prologue and      epilogue, then do not try to fill any delay slots.  */
if|if
condition|(
name|n_basic_blocks
operator|==
literal|0
condition|)
return|return;
comment|/* Find the highest INSN_UID and allocate and initialize our map from      INSN_UID's to position in code.  */
for|for
control|(
name|max_uid
operator|=
literal|0
operator|,
name|insn
operator|=
name|first
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|INSN_UID
argument_list|(
name|insn
argument_list|)
operator|>
name|max_uid
condition|)
name|max_uid
operator|=
name|INSN_UID
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_EPILOGUE_BEG
condition|)
name|epilogue_insn
operator|=
name|insn
expr_stmt|;
block|}
name|uid_to_ruid
operator|=
operator|(
name|int
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|max_uid
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|insn
operator|=
name|first
init|;
name|insn
condition|;
name|i
operator|++
operator|,
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
name|uid_to_ruid
index|[
name|INSN_UID
argument_list|(
name|insn
argument_list|)
index|]
operator|=
name|i
expr_stmt|;
comment|/* Initialize the list of insns that need filling.  */
if|if
condition|(
name|unfilled_firstobj
operator|==
literal|0
condition|)
block|{
name|gcc_obstack_init
argument_list|(
operator|&
name|unfilled_slots_obstack
argument_list|)
expr_stmt|;
name|unfilled_firstobj
operator|=
operator|(
name|rtx
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|unfilled_slots_obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|insn
operator|=
name|next_active_insn
argument_list|(
name|first
argument_list|)
init|;
name|insn
condition|;
name|insn
operator|=
name|next_active_insn
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|rtx
name|target
decl_stmt|;
name|INSN_ANNULLED_BRANCH_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|0
expr_stmt|;
name|INSN_FROM_TARGET_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Skip vector tables.  We can't get attributes for them.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|ADDR_VEC
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|ADDR_DIFF_VEC
operator|)
condition|)
continue|continue;
if|if
condition|(
name|num_delay_slots
argument_list|(
name|insn
argument_list|)
operator|>
literal|0
condition|)
name|obstack_ptr_grow
argument_list|(
operator|&
name|unfilled_slots_obstack
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* Ensure all jumps go to the last of a set of consecutive labels.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
operator|(
name|condjump_p
argument_list|(
name|insn
argument_list|)
operator|||
name|condjump_in_parallel_p
argument_list|(
name|insn
argument_list|)
operator|)
operator|&&
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|target
operator|=
name|prev_label
argument_list|(
name|next_active_insn
argument_list|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|!=
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
operator|)
condition|)
name|redirect_jump
argument_list|(
name|insn
argument_list|,
name|target
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|init_resource_info
argument_list|(
name|epilogue_insn
argument_list|)
expr_stmt|;
comment|/* Show we haven't computed an end-of-function label yet.  */
name|end_of_function_label
operator|=
literal|0
expr_stmt|;
comment|/* Initialize the statistics for this function.  */
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|num_insns_needing_delays
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|num_insns_needing_delays
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|num_filled_delays
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|num_filled_delays
argument_list|)
expr_stmt|;
comment|/* Now do the delay slot filling.  Try everything twice in case earlier      changes make more slots fillable.  */
for|for
control|(
name|reorg_pass_number
operator|=
literal|0
init|;
name|reorg_pass_number
operator|<
name|MAX_REORG_PASSES
condition|;
name|reorg_pass_number
operator|++
control|)
block|{
name|fill_simple_delay_slots
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|fill_simple_delay_slots
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|fill_eager_delay_slots
argument_list|()
expr_stmt|;
name|relax_delay_slots
argument_list|(
name|first
argument_list|)
expr_stmt|;
block|}
comment|/* Delete any USE insns made by update_block; subsequent passes don't need      them or know how to deal with them.  */
for|for
control|(
name|insn
operator|=
name|first
init|;
name|insn
condition|;
name|insn
operator|=
name|next
control|)
block|{
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|USE
operator|&&
name|INSN_P
argument_list|(
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|next
operator|=
name|delete_related_insns
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
comment|/* If we made an end of function label, indicate that it is now      safe to delete it by undoing our prior adjustment to LABEL_NUSES.      If it is now unused, delete it.  */
if|if
condition|(
name|end_of_function_label
operator|&&
operator|--
name|LABEL_NUSES
argument_list|(
name|end_of_function_label
argument_list|)
operator|==
literal|0
condition|)
name|delete_related_insns
argument_list|(
name|end_of_function_label
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_return
if|if
condition|(
name|HAVE_return
operator|&&
name|end_of_function_label
operator|!=
literal|0
condition|)
name|make_return_insns
argument_list|(
name|first
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|obstack_free
argument_list|(
operator|&
name|unfilled_slots_obstack
argument_list|,
name|unfilled_firstobj
argument_list|)
expr_stmt|;
comment|/* It is not clear why the line below is needed, but it does seem to be.  */
name|unfilled_firstobj
operator|=
operator|(
name|rtx
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|unfilled_slots_obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Reposition the prologue and epilogue notes in case we moved the      prologue/epilogue insns.  */
name|reposition_prologue_and_epilogue_notes
argument_list|(
name|first
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
condition|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|need_comma
decl_stmt|;
name|int
name|total_delay_slots
index|[
name|MAX_DELAY_HISTOGRAM
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|total_annul_slots
index|[
name|MAX_DELAY_HISTOGRAM
operator|+
literal|1
index|]
decl_stmt|;
for|for
control|(
name|reorg_pass_number
operator|=
literal|0
init|;
name|reorg_pass_number
operator|<
name|MAX_REORG_PASSES
condition|;
name|reorg_pass_number
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|";; Reorg pass #%d:\n"
argument_list|,
name|reorg_pass_number
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_REORG_FUNCTIONS
condition|;
name|i
operator|++
control|)
block|{
name|need_comma
operator|=
literal|0
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|";; Reorg function #%d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|";; %d insns needing delay slots\n;; "
argument_list|,
name|num_insns_needing_delays
index|[
name|i
index|]
index|[
name|reorg_pass_number
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|MAX_DELAY_HISTOGRAM
operator|+
literal|1
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|num_filled_delays
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|reorg_pass_number
index|]
condition|)
block|{
if|if
condition|(
name|need_comma
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|need_comma
operator|=
literal|1
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d got %d delays"
argument_list|,
name|num_filled_delays
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|reorg_pass_number
index|]
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|total_delay_slots
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|total_delay_slots
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|total_annul_slots
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|total_annul_slots
argument_list|)
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|first
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|INSN_DELETED_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|USE
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|CLOBBER
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SEQUENCE
condition|)
block|{
name|j
operator|=
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|j
operator|>
name|MAX_DELAY_HISTOGRAM
condition|)
name|j
operator|=
name|MAX_DELAY_HISTOGRAM
expr_stmt|;
if|if
condition|(
name|INSN_ANNULLED_BRANCH_P
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|total_annul_slots
index|[
name|j
index|]
operator|++
expr_stmt|;
else|else
name|total_delay_slots
index|[
name|j
index|]
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|num_delay_slots
argument_list|(
name|insn
argument_list|)
operator|>
literal|0
condition|)
name|total_delay_slots
index|[
literal|0
index|]
operator|++
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|";; Reorg totals: "
argument_list|)
expr_stmt|;
name|need_comma
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|MAX_DELAY_HISTOGRAM
operator|+
literal|1
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|total_delay_slots
index|[
name|j
index|]
condition|)
block|{
if|if
condition|(
name|need_comma
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|need_comma
operator|=
literal|1
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d got %d delays"
argument_list|,
name|total_delay_slots
index|[
name|j
index|]
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|ANNUL_IFTRUE_SLOTS
argument_list|)
operator|||
name|defined
argument_list|(
name|ANNUL_IFFALSE_SLOTS
argument_list|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|";; Reorg annuls: "
argument_list|)
expr_stmt|;
name|need_comma
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|MAX_DELAY_HISTOGRAM
operator|+
literal|1
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|total_annul_slots
index|[
name|j
index|]
condition|)
block|{
if|if
condition|(
name|need_comma
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|need_comma
operator|=
literal|1
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d got %d delays"
argument_list|,
name|total_annul_slots
index|[
name|j
index|]
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
comment|/* For all JUMP insns, fill in branch prediction notes, so that during      assembler output a target can set branch prediction bits in the code.      We have to do this now, as up until this point the destinations of      JUMPS can be moved around and changed, but past right here that cannot      happen.  */
for|for
control|(
name|insn
operator|=
name|first
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|int
name|pred_flags
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
condition|)
block|{
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|SEQUENCE
condition|)
name|insn
operator|=
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|JUMP_INSN
condition|)
continue|continue;
name|pred_flags
operator|=
name|get_jump_flags
argument_list|(
name|insn
argument_list|,
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_BR_PRED
argument_list|,
name|GEN_INT
argument_list|(
name|pred_flags
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|free_resource_info
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|uid_to_ruid
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DELAY_SLOTS */
end_comment

end_unit

